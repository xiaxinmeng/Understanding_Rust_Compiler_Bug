{"sha": "6c10620da8cb58bf660fbca234b2fa1492e91bd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMTA2MjBkYThjYjU4YmY2NjBmYmNhMjM0YjJmYTE0OTJlOTFiZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-18T23:59:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-18T23:59:32Z"}, "message": "Auto merge of #3729 - illicitonion:match_enum_wildcard, r=flip1995\n\nwildcard_enum_match_arm gives suggestions\n\nAnd is also more robust", "tree": {"sha": "cc063623da796f89cdeb4a677f5ee63b3250852e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc063623da796f89cdeb4a677f5ee63b3250852e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c10620da8cb58bf660fbca234b2fa1492e91bd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c10620da8cb58bf660fbca234b2fa1492e91bd2", "html_url": "https://github.com/rust-lang/rust/commit/6c10620da8cb58bf660fbca234b2fa1492e91bd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c10620da8cb58bf660fbca234b2fa1492e91bd2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2139fbdbe13dd97f44526b0834a8745c5319a8bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2139fbdbe13dd97f44526b0834a8745c5319a8bd", "html_url": "https://github.com/rust-lang/rust/commit/2139fbdbe13dd97f44526b0834a8745c5319a8bd"}, {"sha": "4009a441189ff8fa9a46acd52a9f7d2f629e47df", "url": "https://api.github.com/repos/rust-lang/rust/commits/4009a441189ff8fa9a46acd52a9f7d2f629e47df", "html_url": "https://github.com/rust-lang/rust/commit/4009a441189ff8fa9a46acd52a9f7d2f629e47df"}], "stats": {"total": 140, "additions": 125, "deletions": 15}, "files": [{"sha": "fcff1e16f38308da0c411e3b93e2d879bd4abbd8", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 85, "deletions": 12, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6c10620da8cb58bf660fbca234b2fa1492e91bd2/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c10620da8cb58bf660fbca234b2fa1492e91bd2/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=6c10620da8cb58bf660fbca234b2fa1492e91bd2", "patch": "@@ -6,13 +6,15 @@ use crate::utils::{\n     snippet_with_applicability, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n+use rustc::hir::def::CtorKind;\n use rustc::hir::*;\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, TyKind};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::cmp::Ordering;\n use std::collections::Bound;\n+use std::ops::Deref;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n@@ -191,7 +193,8 @@ declare_clippy_lint! {\n ///\n /// **Why is this bad?** New enum variants added by library updates can be missed.\n ///\n-/// **Known problems:** Nested wildcards a la `Foo(_)` are currently not detected.\n+/// **Known problems:** Suggested replacements may be incorrect if guards exhaustively cover some\n+/// variants, and also may not use correct path to enum if it's not present in the current scope.\n ///\n /// **Example:**\n /// ```rust\n@@ -464,19 +467,89 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n }\n \n fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n-    if cx.tables.expr_ty(ex).is_enum() {\n+    let ty = cx.tables.expr_ty(ex);\n+    if !ty.is_enum() {\n+        // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n+        // don't complain about not enumerating the mall.\n+        return;\n+    }\n+\n+    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n+    // the uncommon case, and the book-keeping is slightly expensive.\n+    let mut wildcard_span = None;\n+    let mut wildcard_ident = None;\n+    for arm in arms {\n+        for pat in &arm.pats {\n+            if let PatKind::Wild = pat.node {\n+                wildcard_span = Some(pat.span);\n+            } else if let PatKind::Binding(_, _, _, ident, None) = pat.node {\n+                wildcard_span = Some(pat.span);\n+                wildcard_ident = Some(ident);\n+            }\n+        }\n+    }\n+\n+    if let Some(wildcard_span) = wildcard_span {\n+        // Accumulate the variants which should be put in place of the wildcard because they're not\n+        // already covered.\n+\n+        let mut missing_variants = vec![];\n+        if let TyKind::Adt(def, _) = ty.sty {\n+            for variant in &def.variants {\n+                missing_variants.push(variant);\n+            }\n+        }\n+\n         for arm in arms {\n-            if is_wild(&arm.pats[0]) {\n-                span_note_and_lint(\n-                    cx,\n-                    WILDCARD_ENUM_MATCH_ARM,\n-                    arm.pats[0].span,\n-                    \"wildcard match will miss any future added variants.\",\n-                    arm.pats[0].span,\n-                    \"to resolve, match each variant explicitly\",\n-                );\n+            if arm.guard.is_some() {\n+                // Guards mean that this case probably isn't exhaustively covered. Technically\n+                // this is incorrect, as we should really check whether each variant is exhaustively\n+                // covered by the set of guards that cover it, but that's really hard to do.\n+                continue;\n             }\n+            for pat in &arm.pats {\n+                if let PatKind::Path(ref path) = pat.deref().node {\n+                    if let QPath::Resolved(_, p) = path {\n+                        missing_variants.retain(|e| e.did != p.def.def_id());\n+                    }\n+                } else if let PatKind::TupleStruct(ref path, ..) = pat.deref().node {\n+                    if let QPath::Resolved(_, p) = path {\n+                        missing_variants.retain(|e| e.did != p.def.def_id());\n+                    }\n+                }\n+            }\n+        }\n+\n+        let suggestion: Vec<String> = missing_variants\n+            .iter()\n+            .map(|v| {\n+                let suffix = match v.ctor_kind {\n+                    CtorKind::Fn => \"(..)\",\n+                    CtorKind::Const | CtorKind::Fictive => \"\",\n+                };\n+                let ident_str = if let Some(ident) = wildcard_ident {\n+                    format!(\"{} @ \", ident.name)\n+                } else {\n+                    String::new()\n+                };\n+                // This path assumes that the enum type is imported into scope.\n+                format!(\"{}{}{}\", ident_str, cx.tcx.item_path_str(v.did), suffix)\n+            })\n+            .collect();\n+\n+        if suggestion.is_empty() {\n+            return;\n         }\n+\n+        span_lint_and_sugg(\n+            cx,\n+            WILDCARD_ENUM_MATCH_ARM,\n+            wildcard_span,\n+            \"wildcard match will miss any future added variants.\",\n+            \"try this\",\n+            suggestion.join(\" | \"),\n+            Applicability::MachineApplicable,\n+        )\n     }\n }\n "}, {"sha": "94d69d3c8a43e5a7f6d096463650ff16061c7187", "filename": "tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c10620da8cb58bf660fbca234b2fa1492e91bd2/tests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c10620da8cb58bf660fbca234b2fa1492e91bd2/tests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.rs?ref=6c10620da8cb58bf660fbca234b2fa1492e91bd2", "patch": "@@ -25,6 +25,14 @@ fn main() {\n         Color::Red => println!(\"Red\"),\n         _ => eprintln!(\"Not red\"),\n     };\n+    match color {\n+        Color::Red => println!(\"Red\"),\n+        _not_red => eprintln!(\"Not red\"),\n+    };\n+    let _str = match color {\n+        Color::Red => \"Red\".to_owned(),\n+        not_red => format!(\"{:?}\", not_red),\n+    };\n     match color {\n         Color::Red => {},\n         Color::Green => {},\n@@ -33,6 +41,18 @@ fn main() {\n         c if c.is_monochrome() => {},\n         Color::Rgb(_, _, _) => {},\n     };\n+    let _str = match color {\n+        Color::Red => \"Red\",\n+        c @ Color::Green | c @ Color::Blue | c @ Color::Rgb(_, _, _) | c @ Color::Cyan => \"Not red\",\n+    };\n+    match color {\n+        Color::Rgb(r, _, _) if r > 0 => \"Some red\",\n+        _ => \"No red\",\n+    };\n+    match color {\n+        Color::Red | Color::Green | Color::Blue | Color::Cyan => {},\n+        Color::Rgb(..) => {},\n+    };\n     let x: u8 = unimplemented!();\n     match x {\n         0 => {},"}, {"sha": "999c1693301464121982df4e7bb24b2c19280e4f", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c10620da8cb58bf660fbca234b2fa1492e91bd2/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c10620da8cb58bf660fbca234b2fa1492e91bd2/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=6c10620da8cb58bf660fbca234b2fa1492e91bd2", "patch": "@@ -2,14 +2,31 @@ error: wildcard match will miss any future added variants.\n   --> $DIR/wildcard_enum_match_arm.rs:26:9\n    |\n LL |         _ => eprintln!(\"Not red\"),\n-   |         ^\n+   |         ^ help: try this: `Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n    |\n note: lint level defined here\n   --> $DIR/wildcard_enum_match_arm.rs:1:9\n    |\n LL | #![deny(clippy::wildcard_enum_match_arm)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: to resolve, match each variant explicitly\n \n-error: aborting due to previous error\n+error: wildcard match will miss any future added variants.\n+  --> $DIR/wildcard_enum_match_arm.rs:30:9\n+   |\n+LL |         _not_red => eprintln!(\"Not red\"),\n+   |         ^^^^^^^^ help: try this: `_not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan`\n+\n+error: wildcard match will miss any future added variants.\n+  --> $DIR/wildcard_enum_match_arm.rs:34:9\n+   |\n+LL |         not_red => format!(\"{:?}\", not_red),\n+   |         ^^^^^^^ help: try this: `not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan`\n+\n+error: wildcard match will miss any future added variants.\n+  --> $DIR/wildcard_enum_match_arm.rs:50:9\n+   |\n+LL |         _ => \"No red\",\n+   |         ^ help: try this: `Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n+\n+error: aborting due to 4 previous errors\n "}]}