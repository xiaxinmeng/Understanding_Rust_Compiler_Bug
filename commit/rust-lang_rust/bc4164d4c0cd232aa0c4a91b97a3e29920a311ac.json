{"sha": "bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNDE2NGQ0YzBjZDIzMmFhMGM0YTkxYjk3YTNlMjk5MjBhMzExYWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-16T22:29:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-28T11:43:39Z"}, "message": "Modify iterators to make them safe with the new rules.", "tree": {"sha": "e06a117057fefefdb502649ad807d44307954b45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e06a117057fefefdb502649ad807d44307954b45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "html_url": "https://github.com/rust-lang/rust/commit/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce44094bbbeb76dc5721701e91f0e466e59f0b70", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce44094bbbeb76dc5721701e91f0e466e59f0b70", "html_url": "https://github.com/rust-lang/rust/commit/ce44094bbbeb76dc5721701e91f0e466e59f0b70"}], "stats": {"total": 160, "additions": 111, "deletions": 49}, "files": [{"sha": "aa8f7de82f7ac7bf4155e19044689a7d135451fd", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "patch": "@@ -225,8 +225,9 @@ impl<T> Deque<T> for DList<T> {\n     /// Provide a mutable reference to the back element, or None if the list is empty\n     #[inline]\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n-        let mut tmp = self.list_tail.resolve(); // FIXME: #3511: shouldn't need variable\n-        tmp.as_mut().map(|tail| &mut tail.value)\n+        let tmp: Option<&'a mut Node<T>> =\n+            self.list_tail.resolve(); // FIXME: #3511: shouldn't need variable\n+        tmp.map(|tail| &mut tail.value)\n     }\n \n     /// Add an element first in the list"}, {"sha": "24fd4d077d46767f6aba93328198c71ad18b421d", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 108, "deletions": 47, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "patch": "@@ -198,7 +198,28 @@ impl<T> RingBuf<T> {\n \n     /// Front-to-back iterator which returns mutable values.\n     pub fn mut_iter<'a>(&'a mut self) -> RingBufMutIterator<'a, T> {\n-        RingBufMutIterator{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts}\n+        let start_index = raw_index(self.lo, self.elts.len(), 0);\n+        let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n+\n+        // Divide up the array\n+        if end_index <= start_index {\n+            // Items to iterate goes from:\n+            //    start_index to self.elts.len()\n+            // and then\n+            //    0 to end_index\n+            let (temp, remaining1) = self.elts.mut_split(start_index);\n+            let (remaining2, _) = temp.mut_split(end_index);\n+            RingBufMutIterator { remaining1: remaining1,\n+                                 remaining2: remaining2,\n+                                 nelts: self.nelts }\n+        } else {\n+            // Items to iterate goes from start_index to end_index:\n+            let (empty, elts) = self.elts.mut_split(0);\n+            let remaining1 = elts.mut_slice(start_index, end_index);\n+            RingBufMutIterator { remaining1: remaining1,\n+                                 remaining2: empty,\n+                                 nelts: self.nelts }\n+        }\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n@@ -207,54 +228,43 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-macro_rules! iterator {\n-    (impl $name:ident -> $elem:ty, $getter:ident) => {\n-        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n-            #[inline]\n-            fn next(&mut self) -> Option<$elem> {\n-                if self.index == self.rindex {\n-                    return None;\n-                }\n-                let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n-                self.index += 1;\n-                Some(self.elts[raw_index] . $getter ())\n-            }\n+/// RingBuf iterator\n+pub struct RingBufIterator<'self, T> {\n+    priv lo: uint,\n+    priv index: uint,\n+    priv rindex: uint,\n+    priv elts: &'self [Option<T>],\n+}\n \n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let len = self.rindex - self.index;\n-                (len, Some(len))\n-            }\n+impl<'self, T> Iterator<&'self T> for RingBufIterator<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self T> {\n+        if self.index == self.rindex {\n+            return None;\n         }\n+        let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n+        self.index += 1;\n+        Some(self.elts[raw_index].get_ref())\n     }\n-}\n \n-macro_rules! iterator_rev {\n-    (impl $name:ident -> $elem:ty, $getter:ident) => {\n-        impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$elem> {\n-                if self.index == self.rindex {\n-                    return None;\n-                }\n-                self.rindex -= 1;\n-                let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n-                Some(self.elts[raw_index] . $getter ())\n-            }\n-        }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let len = self.rindex - self.index;\n+        (len, Some(len))\n     }\n }\n \n-\n-/// RingBuf iterator\n-pub struct RingBufIterator<'self, T> {\n-    priv lo: uint,\n-    priv index: uint,\n-    priv rindex: uint,\n-    priv elts: &'self [Option<T>],\n+impl<'self, T> DoubleEndedIterator<&'self T> for RingBufIterator<'self, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'self T> {\n+        if self.index == self.rindex {\n+            return None;\n+        }\n+        self.rindex -= 1;\n+        let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n+        Some(self.elts[raw_index].get_ref())\n+    }\n }\n-iterator!{impl RingBufIterator -> &'self T, get_ref}\n-iterator_rev!{impl RingBufIterator -> &'self T, get_ref}\n \n impl<'self, T> ExactSize<&'self T> for RingBufIterator<'self, T> {}\n \n@@ -275,13 +285,49 @@ impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n \n /// RingBuf mutable iterator\n pub struct RingBufMutIterator<'self, T> {\n-    priv lo: uint,\n-    priv index: uint,\n-    priv rindex: uint,\n-    priv elts: &'self mut [Option<T>],\n+    priv remaining1: &'self mut [Option<T>],\n+    priv remaining2: &'self mut [Option<T>],\n+    priv nelts: uint,\n+}\n+\n+impl<'self, T> Iterator<&'self mut T> for RingBufMutIterator<'self, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'self mut T> {\n+        if self.nelts == 0 {\n+            return None;\n+        }\n+        let r = if self.remaining1.len() > 0 {\n+            &mut self.remaining1\n+        } else {\n+            assert!(self.remaining2.len() > 0);\n+            &mut self.remaining2\n+        };\n+        self.nelts -= 1;\n+        Some(r.mut_shift_ref().get_mut_ref())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.nelts, Some(self.nelts))\n+    }\n+}\n+\n+impl<'self, T> DoubleEndedIterator<&'self mut T> for RingBufMutIterator<'self, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'self mut T> {\n+        if self.nelts == 0 {\n+            return None;\n+        }\n+        let r = if self.remaining2.len() > 0 {\n+            &mut self.remaining2\n+        } else {\n+            assert!(self.remaining1.len() > 0);\n+            &mut self.remaining1\n+        };\n+        self.nelts -= 1;\n+        Some(r.mut_pop_ref().get_mut_ref())\n+    }\n }\n-iterator!{impl RingBufMutIterator -> &'self mut T, get_mut_ref}\n-iterator_rev!{impl RingBufMutIterator -> &'self mut T, get_mut_ref}\n \n impl<'self, T> ExactSize<&'self mut T> for RingBufMutIterator<'self, T> {}\n \n@@ -667,6 +713,21 @@ mod tests {\n         assert_eq!(d.rev_iter().collect::<~[&int]>(), ~[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n \n+    #[test]\n+    fn test_mut_rev_iter_wrap() {\n+        let mut d = RingBuf::with_capacity(3);\n+        assert!(d.mut_rev_iter().next().is_none());\n+\n+        d.push_back(1);\n+        d.push_back(2);\n+        d.push_back(3);\n+        assert_eq!(d.pop_front(), Some(1));\n+        d.push_back(4);\n+\n+        assert_eq!(d.mut_rev_iter().map(|x| *x).collect::<~[int]>(),\n+                   ~[4, 3, 2]);\n+    }\n+\n     #[test]\n     fn test_mut_iter() {\n         let mut d = RingBuf::new();"}]}