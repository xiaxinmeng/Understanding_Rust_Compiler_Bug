{"sha": "cc4213418e3ab225867d8e3911f592481b1bbffc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNDIxMzQxOGUzYWIyMjU4NjdkOGUzOTExZjU5MjQ4MWIxYmJmZmM=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-06-18T17:44:20Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-09T07:06:29Z"}, "message": "syntax: don't parse numeric literals in the lexer\n\nThis removes a bunch of token types. Tokens now store the original, unaltered\nnumeric literal (that is still checked for correctness), which is parsed into\nan actual number later, as needed, when creating the AST.\n\nThis can change how syntax extensions work, but otherwise poses no visible\nchanges.\n\n[breaking-change]", "tree": {"sha": "c66b1d206a18a456a81f1ee3d859fec9fbd1e010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c66b1d206a18a456a81f1ee3d859fec9fbd1e010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc4213418e3ab225867d8e3911f592481b1bbffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4213418e3ab225867d8e3911f592481b1bbffc", "html_url": "https://github.com/rust-lang/rust/commit/cc4213418e3ab225867d8e3911f592481b1bbffc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc4213418e3ab225867d8e3911f592481b1bbffc/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "html_url": "https://github.com/rust-lang/rust/commit/9f5e21da4ef95e5d2914a76b09848ebc2504c53d"}], "stats": {"total": 591, "additions": 325, "deletions": 266}, "files": [{"sha": "11a8207f8c43ea22608be19a96bc33590910554a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -42,6 +42,7 @@ use syntax::{ast, ast_util};\n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n+    debug!(\"const_lit: {}\", lit);\n     match lit.node {\n         ast::LitByte(b) => C_integral(Type::uint_from_ty(cx, ast::TyU8), b as u64, false),\n         ast::LitChar(i) => C_integral(Type::char(cx), i as u64, false),"}, {"sha": "af7a822bc29e9bec7d9a629b3449970d8ea71e5c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -144,8 +144,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 t::LIT_CHAR(..) | t::LIT_STR(..) | t::LIT_STR_RAW(..) => \"string\",\n \n             // number literals\n-            t::LIT_INT(..) | t::LIT_UINT(..) | t::LIT_INT_UNSUFFIXED(..) |\n-                t::LIT_FLOAT(..) | t::LIT_FLOAT_UNSUFFIXED(..) => \"number\",\n+            t::LIT_INTEGER(..) | t::LIT_FLOAT(..) => \"number\",\n \n             // keywords are also included in the identifier set\n             t::IDENT(ident, _is_mod_sep) => {"}, {"sha": "2a49d0e0f5bf81a71d8b6e1778992364c6466a3a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -619,15 +619,15 @@ pub enum Mac_ {\n     MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum StrStyle {\n     CookedStr,\n     RawStr(uint)\n }\n \n pub type Lit = Spanned<Lit_>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<Vec<u8> >),\n@@ -697,6 +697,16 @@ impl fmt::Show for IntTy {\n     }\n }\n \n+impl IntTy {\n+    pub fn suffix_len(&self) -> uint {\n+        match *self {\n+            TyI => 1,\n+            TyI8 => 2,\n+            TyI16 | TyI32 | TyI64  => 3,\n+        }\n+    }\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum UintTy {\n     TyU,\n@@ -706,6 +716,16 @@ pub enum UintTy {\n     TyU64,\n }\n \n+impl UintTy {\n+    pub fn suffix_len(&self) -> uint {\n+        match *self {\n+            TyU => 1,\n+            TyU8 => 2,\n+            TyU16 | TyU32 | TyU64  => 3,\n+        }\n+    }\n+}\n+\n impl fmt::Show for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", ast_util::uint_ty_to_string(*self, None))\n@@ -724,6 +744,14 @@ impl fmt::Show for FloatTy {\n     }\n }\n \n+impl FloatTy {\n+    pub fn suffix_len(&self) -> uint {\n+        match *self {\n+            TyF32 | TyF64 => 3, // add F128 handling here\n+        }\n+    }\n+}\n+\n // NB PartialEq method appears below.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Ty {"}, {"sha": "ef4024a8f83fe0cabb79fda2d0250998c747db17", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -96,7 +96,7 @@ pub struct Span {\n \n pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,"}, {"sha": "24630dd09a20eda282f459edd087e17bada72975", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -412,45 +412,14 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n             return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_CHAR\"), vec!(e_char));\n         }\n \n-        LIT_INT(i, ity) => {\n-            let s_ity = match ity {\n-                ast::TyI => \"TyI\",\n-                ast::TyI8 => \"TyI8\",\n-                ast::TyI16 => \"TyI16\",\n-                ast::TyI32 => \"TyI32\",\n-                ast::TyI64 => \"TyI64\"\n-            };\n-            let e_ity = mk_ast_path(cx, sp, s_ity);\n-            let e_i64 = cx.expr_lit(sp, ast::LitInt(i, ast::TyI64));\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_INT\"), vec!(e_i64, e_ity));\n+        LIT_INTEGER(i) => {\n+            let e_int = mk_ident(cx, sp, i);\n+            return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_INTEGER\"), vec!(e_int));\n         }\n \n-        LIT_UINT(u, uty) => {\n-            let s_uty = match uty {\n-                ast::TyU => \"TyU\",\n-                ast::TyU8 => \"TyU8\",\n-                ast::TyU16 => \"TyU16\",\n-                ast::TyU32 => \"TyU32\",\n-                ast::TyU64 => \"TyU64\"\n-            };\n-            let e_uty = mk_ast_path(cx, sp, s_uty);\n-            let e_u64 = cx.expr_lit(sp, ast::LitUint(u, ast::TyU64));\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_UINT\"), vec!(e_u64, e_uty));\n-        }\n-\n-        LIT_INT_UNSUFFIXED(i) => {\n-            let e_i64 = cx.expr_lit(sp, ast::LitInt(i, ast::TyI64));\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_INT_UNSUFFIXED\"), vec!(e_i64));\n-        }\n-\n-        LIT_FLOAT(fident, fty) => {\n-            let s_fty = match fty {\n-                ast::TyF32 => \"TyF32\",\n-                ast::TyF64 => \"TyF64\",\n-            };\n-            let e_fty = mk_ast_path(cx, sp, s_fty);\n+        LIT_FLOAT(fident) => {\n             let e_fident = mk_ident(cx, sp, fident);\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_FLOAT\"), vec!(e_fident, e_fty));\n+            return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_FLOAT\"), vec!(e_fident));\n         }\n \n         LIT_STR(ident) => {"}, {"sha": "61a37f77d348b18393e0c39db9cd4f6d66aca103", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 162, "deletions": 180, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -18,7 +18,6 @@ use parse::token::{str_to_ident};\n \n use std::char;\n use std::mem::replace;\n-use std::num::from_str_radix;\n use std::rc::Rc;\n use std::str;\n \n@@ -491,204 +490,113 @@ impl<'a> StringReader<'a> {\n         if res.is_some() { res } else { self.consume_whitespace_and_comments() }\n     }\n \n-    fn scan_exponent(&mut self, start_bpos: BytePos) -> Option<String> {\n-        // \\x00 hits the `return None` case immediately, so this is fine.\n-        let mut c = self.curr.unwrap_or('\\x00');\n-        let mut rslt = String::new();\n-        if c == 'e' || c == 'E' {\n-            rslt.push_char(c);\n-            self.bump();\n-            c = self.curr.unwrap_or('\\x00');\n-            if c == '-' || c == '+' {\n-                rslt.push_char(c);\n-                self.bump();\n-            }\n-            let exponent = self.scan_digits(10u);\n-            if exponent.len() > 0u {\n-                rslt.push_str(exponent.as_slice());\n-                return Some(rslt);\n-            } else {\n-                let last_bpos = self.last_pos;\n-                self.err_span_(start_bpos, last_bpos, \"scan_exponent: bad fp literal\");\n-                rslt.push_str(\"1\"); // arbitrary placeholder exponent\n-                return Some(rslt);\n-            }\n-        } else {\n-            return None::<String>;\n-        }\n-    }\n-\n-    fn scan_digits(&mut self, radix: uint) -> String {\n-        let mut rslt = String::new();\n+    /// Scan through any digits (base `radix`) or underscores, and return how\n+    /// many digits there were.\n+    fn scan_digits(&mut self, radix: uint) -> uint {\n+        let mut len = 0u;\n         loop {\n             let c = self.curr;\n-            if c == Some('_') { self.bump(); continue; }\n+            if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n             match c.and_then(|cc| char::to_digit(cc, radix)) {\n-              Some(_) => {\n-                rslt.push_char(c.unwrap());\n-                self.bump();\n-              }\n-              _ => return rslt\n+                Some(_) => {\n+                    debug!(\"{} in scan_digits\", c);\n+                    len += 1;\n+                    self.bump();\n+                }\n+                _ => return len\n             }\n         };\n     }\n \n-    fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: uint) {\n-        match base {\n-          16u => self.err_span_(start_bpos, last_bpos,\n-                                \"hexadecimal float literal is not supported\"),\n-          8u => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n-          2u => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n-          _ => ()\n-        }\n-    }\n-\n+    /// Lex a LIT_INTEGER or a LIT_FLOAT\n     fn scan_number(&mut self, c: char) -> token::Token {\n-        let mut num_str;\n-        let mut base = 10u;\n-        let mut c = c;\n-        let mut n = self.nextch().unwrap_or('\\x00');\n+        let mut num_digits;\n+        let mut base = 10;\n         let start_bpos = self.last_pos;\n-        if c == '0' && n == 'x' {\n-            self.bump();\n-            self.bump();\n-            base = 16u;\n-        } else if c == '0' && n == 'o' {\n-            self.bump();\n-            self.bump();\n-            base = 8u;\n-        } else if c == '0' && n == 'b' {\n-            self.bump();\n-            self.bump();\n-            base = 2u;\n-        }\n-        num_str = self.scan_digits(base);\n-        c = self.curr.unwrap_or('\\x00');\n-        self.nextch();\n-        if c == 'u' || c == 'i' {\n-            enum Result { Signed(ast::IntTy), Unsigned(ast::UintTy) }\n-            let signed = c == 'i';\n-            let mut tp = {\n-                if signed { Signed(ast::TyI) }\n-                else { Unsigned(ast::TyU) }\n-            };\n-            self.bump();\n-            c = self.curr.unwrap_or('\\x00');\n-            if c == '8' {\n-                self.bump();\n-                tp = if signed { Signed(ast::TyI8) }\n-                          else { Unsigned(ast::TyU8) };\n-            }\n-            n = self.nextch().unwrap_or('\\x00');\n-            if c == '1' && n == '6' {\n-                self.bump();\n-                self.bump();\n-                tp = if signed { Signed(ast::TyI16) }\n-                          else { Unsigned(ast::TyU16) };\n-            } else if c == '3' && n == '2' {\n-                self.bump();\n-                self.bump();\n-                tp = if signed { Signed(ast::TyI32) }\n-                          else { Unsigned(ast::TyU32) };\n-            } else if c == '6' && n == '4' {\n-                self.bump();\n-                self.bump();\n-                tp = if signed { Signed(ast::TyI64) }\n-                          else { Unsigned(ast::TyU64) };\n-            }\n-            if num_str.len() == 0u {\n-                let last_bpos = self.last_pos;\n-                self.err_span_(start_bpos, last_bpos, \"no valid digits found for number\");\n-                num_str = \"1\".to_string();\n-            }\n-            let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n-                                                     base as uint) {\n-                Some(p) => p,\n-                None => {\n-                    let last_bpos = self.last_pos;\n-                    self.err_span_(start_bpos, last_bpos, \"int literal is too large\");\n-                    1\n-                }\n-            };\n \n-            match tp {\n-              Signed(t) => return token::LIT_INT(parsed as i64, t),\n-              Unsigned(t) => return token::LIT_UINT(parsed, t)\n+        self.bump();\n+\n+        if c == '0' {\n+            match self.curr.unwrap_or('\\0') {\n+                'b' => { self.bump(); base = 2; num_digits = self.scan_digits(2); }\n+                'o' => { self.bump(); base = 8; num_digits = self.scan_digits(8); }\n+                'x' => { self.bump(); base = 16; num_digits = self.scan_digits(16); }\n+                '0'..'9' | '_' | '.' => {\n+                    num_digits = self.scan_digits(10) + 1;\n+                }\n+                'u' | 'i' => {\n+                    self.scan_int_suffix();\n+                    return token::LIT_INTEGER(self.ident_from(start_bpos));\n+                },\n+                'f' => {\n+                    let last_pos = self.last_pos;\n+                    self.scan_float_suffix();\n+                    self.check_float_base(start_bpos, last_pos, base);\n+                    return token::LIT_FLOAT(self.ident_from(start_bpos));\n+                }\n+                _ => {\n+                    // just a 0\n+                    return token::LIT_INTEGER(self.ident_from(start_bpos));\n+                }\n             }\n+        } else if c.is_digit_radix(10) {\n+            num_digits = self.scan_digits(10) + 1;\n+        } else {\n+            num_digits = 0;\n         }\n-        let mut is_float = false;\n-        if self.curr_is('.') && !(ident_start(self.nextch()) || self.nextch_is('.')) {\n-            is_float = true;\n-            self.bump();\n-            let dec_part = self.scan_digits(10u);\n-            num_str.push_char('.');\n-            num_str.push_str(dec_part.as_slice());\n-        }\n-        match self.scan_exponent(start_bpos) {\n-          Some(ref s) => {\n-            is_float = true;\n-            num_str.push_str(s.as_slice());\n-          }\n-          None => ()\n+\n+        if num_digits == 0 {\n+            self.err_span_(start_bpos, self.last_pos, \"no valid digits found for number\");\n+            // eat any suffix\n+            self.scan_int_suffix();\n+            return token::LIT_INTEGER(str_to_ident(\"0\"));\n         }\n \n-        if self.curr_is('f') {\n+        // might be a float, but don't be greedy if this is actually an\n+        // integer literal followed by field/method access or a range pattern\n+        // (`0..2` and `12.foo()`)\n+        if self.curr_is('.') && !self.nextch_is('.') && !self.nextch().unwrap_or('\\0')\n+                                                             .is_XID_start() {\n+            // might have stuff after the ., and if it does, it needs to start\n+            // with a number\n             self.bump();\n-            c = self.curr.unwrap_or('\\x00');\n-            n = self.nextch().unwrap_or('\\x00');\n-            if c == '3' && n == '2' {\n-                self.bump();\n-                self.bump();\n-                let last_bpos = self.last_pos;\n-                self.check_float_base(start_bpos, last_bpos, base);\n-                return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n-                                        ast::TyF32);\n-            } else if c == '6' && n == '4' {\n-                self.bump();\n-                self.bump();\n-                let last_bpos = self.last_pos;\n-                self.check_float_base(start_bpos, last_bpos, base);\n-                return token::LIT_FLOAT(str_to_ident(num_str.as_slice()),\n-                                        ast::TyF64);\n-                /* FIXME (#2252): if this is out of range for either a\n-                32-bit or 64-bit float, it won't be noticed till the\n-                back-end.  */\n+            if self.curr.unwrap_or('\\0').is_digit_radix(10) {\n+                self.scan_digits(10);\n+                self.scan_float_exponent();\n+                self.scan_float_suffix();\n             }\n-            let last_bpos = self.last_pos;\n-            self.err_span_(start_bpos, last_bpos, \"expected `f32` or `f64` suffix\");\n-        }\n-        if is_float {\n-            let last_bpos = self.last_pos;\n-            self.check_float_base(start_bpos, last_bpos, base);\n-            return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(\n-                    num_str.as_slice()));\n+            let last_pos = self.last_pos;\n+            self.check_float_base(start_bpos, last_pos, base);\n+            return token::LIT_FLOAT(self.ident_from(start_bpos));\n+        } else if self.curr_is('f') {\n+            // or it might be an integer literal suffixed as a float\n+            self.scan_float_suffix();\n+            let last_pos = self.last_pos;\n+            self.check_float_base(start_bpos, last_pos, base);\n+            return token::LIT_FLOAT(self.ident_from(start_bpos));\n         } else {\n-            if num_str.len() == 0u {\n-                let last_bpos = self.last_pos;\n-                self.err_span_(start_bpos, last_bpos, \"no valid digits found for number\");\n-                num_str = \"1\".to_string();\n+            // it might be a float if it has an exponent\n+            if self.curr_is('e') || self.curr_is('E') {\n+                self.scan_float_exponent();\n+                self.scan_float_suffix();\n+                let last_pos = self.last_pos;\n+                self.check_float_base(start_bpos, last_pos, base);\n+                return token::LIT_FLOAT(self.ident_from(start_bpos));\n             }\n-            let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n-                                                     base as uint) {\n-                Some(p) => p,\n-                None => {\n-                    let last_bpos = self.last_pos;\n-                    self.err_span_(start_bpos, last_bpos, \"int literal is too large\");\n-                    1\n-                }\n-            };\n-\n-            debug!(\"lexing {} as an unsuffixed integer literal\",\n-                   num_str.as_slice());\n-            return token::LIT_INT_UNSUFFIXED(parsed as i64);\n+            // but we certainly have an integer!\n+            self.scan_int_suffix();\n+            return token::LIT_INTEGER(self.ident_from(start_bpos));\n         }\n     }\n \n-\n-    fn scan_numeric_escape(&mut self, n_hex_digits: uint, delim: char) -> bool {\n-        let mut accum_int = 0u32;\n+    /// Scan over `n_digits` hex digits, stopping at `delim`, reporting an\n+    /// error if too many or too few digits are encountered.\n+    fn scan_hex_digits(&mut self, n_digits: uint, delim: char) -> bool {\n+        debug!(\"scanning {} digits until {}\", n_digits, delim);\n         let start_bpos = self.last_pos;\n-        for _ in range(0, n_hex_digits) {\n+        let mut accum_int = 0;\n+\n+        for _ in range(0, n_digits) {\n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n                 self.fatal_span_(start_bpos, last_bpos, \"unterminated numeric character escape\");\n@@ -736,9 +644,9 @@ impl<'a> StringReader<'a> {\n                     Some(e) => {\n                         return match e {\n                             'n' | 'r' | 't' | '\\\\' | '\\'' | '\"' | '0' => true,\n-                            'x' => self.scan_numeric_escape(2u, delim),\n-                            'u' if !ascii_only => self.scan_numeric_escape(4u, delim),\n-                            'U' if !ascii_only => self.scan_numeric_escape(8u, delim),\n+                            'x' => self.scan_hex_digits(2u, delim),\n+                            'u' if !ascii_only => self.scan_hex_digits(4u, delim),\n+                            'U' if !ascii_only => self.scan_hex_digits(8u, delim),\n                             '\\n' if delim == '\"' => {\n                                 self.consume_whitespace();\n                                 true\n@@ -791,6 +699,80 @@ impl<'a> StringReader<'a> {\n         true\n     }\n \n+    /// Scan over an int literal suffix.\n+    fn scan_int_suffix(&mut self) {\n+        match self.curr {\n+            Some('i') | Some('u') => {\n+                self.bump();\n+\n+                if self.curr_is('8') {\n+                    self.bump();\n+                } else if self.curr_is('1') {\n+                    if !self.nextch_is('6') {\n+                        self.err_span_(self.last_pos, self.pos,\n+                                      \"illegal int suffix\");\n+                    } else {\n+                        self.bump(); self.bump();\n+                    }\n+                } else if self.curr_is('3') {\n+                    if !self.nextch_is('2') {\n+                        self.err_span_(self.last_pos, self.pos,\n+                                      \"illegal int suffix\");\n+                    } else {\n+                        self.bump(); self.bump();\n+                    }\n+                } else if self.curr_is('6') {\n+                    if !self.nextch_is('4') {\n+                        self.err_span_(self.last_pos, self.pos,\n+                                      \"illegal int suffix\");\n+                    } else {\n+                        self.bump(); self.bump();\n+                    }\n+                }\n+            },\n+            _ => { }\n+        }\n+    }\n+\n+    /// Scan over a float literal suffix\n+    fn scan_float_suffix(&mut self) {\n+        if self.curr_is('f') {\n+            if (self.nextch_is('3') && self.nextnextch_is('2'))\n+            || (self.nextch_is('6') && self.nextnextch_is('4')) {\n+                self.bump();\n+                self.bump();\n+                self.bump();\n+            } else {\n+                self.err_span_(self.last_pos, self.pos, \"illegal float suffix\");\n+            }\n+        }\n+    }\n+\n+    /// Scan over a float exponent.\n+    fn scan_float_exponent(&mut self) {\n+        if self.curr_is('e') || self.curr_is('E') {\n+            self.bump();\n+            if self.curr_is('-') || self.curr_is('+') {\n+                self.bump();\n+            }\n+            if self.scan_digits(10) == 0 {\n+                self.err_span_(self.last_pos, self.pos, \"expected at least one digit in exponent\")\n+            }\n+        }\n+    }\n+\n+    /// Check that a base is valid for a floating literal, emitting a nice\n+    /// error if it isn't.\n+    fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: uint) {\n+        match base {\n+            16u => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n+                                 supported\"),\n+            8u => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n+            2u => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n+            _ => ()\n+        }\n+    }\n+\n     fn binop(&mut self, op: token::BinOp) -> token::Token {\n         self.bump();\n         if self.curr_is('=') {"}, {"sha": "37c84c95af654e3f98ce63060c94b1bd7161c4a1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -506,6 +506,115 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n+pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+    // s can only be ascii, byte indexing is fine\n+\n+    let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n+    let mut s = s2.as_slice();\n+\n+    debug!(\"parse_integer_lit: {}\", s);\n+\n+    if s.len() == 1 {\n+        return ast::LitIntUnsuffixed((s.char_at(0)).to_digit(10).unwrap() as i64);\n+    }\n+\n+    let mut base = 10;\n+    let orig = s;\n+\n+    #[deriving(Show)]\n+    enum Result {\n+        Nothing,\n+        Signed(ast::IntTy),\n+        Unsigned(ast::UintTy)\n+    }\n+\n+    impl Result {\n+        fn suffix_len(&self) -> uint {\n+            match *self {\n+                Nothing => 0,\n+                Signed(s) => s.suffix_len(),\n+                Unsigned(u) => u.suffix_len()\n+            }\n+        }\n+    }\n+\n+    let mut ty = Nothing;\n+\n+\n+    if s.char_at(0) == '0' {\n+        match s.char_at(1) {\n+            'x' => base = 16,\n+            'o' => base = 8,\n+            'b' => base = 2,\n+            _ => { }\n+        }\n+    }\n+\n+    if base != 10 {\n+        s = s.slice_from(2);\n+    }\n+\n+    let last = s.len() - 1;\n+    match s.char_at(last) {\n+        'i' => ty = Signed(ast::TyI),\n+        'u' => ty = Unsigned(ast::TyU),\n+        '8' => {\n+            if s.len() > 2 {\n+                match s.char_at(last - 1) {\n+                    'i' => ty = Signed(ast::TyI8),\n+                    'u' => ty = Unsigned(ast::TyU8),\n+                    _ => { }\n+                }\n+            }\n+        },\n+        '6' => {\n+            if s.len() > 3 && s.char_at(last - 1) == '1' {\n+                match s.char_at(last - 2) {\n+                    'i' => ty = Signed(ast::TyI16),\n+                    'u' => ty = Unsigned(ast::TyU16),\n+                    _ => { }\n+                }\n+            }\n+        },\n+        '2' => {\n+            if s.len() > 3 && s.char_at(last - 1) == '3' {\n+                match s.char_at(last - 2) {\n+                    'i' => ty = Signed(ast::TyI32),\n+                    'u' => ty = Unsigned(ast::TyU32),\n+                    _ => { }\n+                }\n+            }\n+        },\n+        '4' => {\n+            if s.len() > 3 && s.char_at(last - 1) == '6' {\n+                match s.char_at(last - 2) {\n+                    'i' => ty = Signed(ast::TyI64),\n+                    'u' => ty = Unsigned(ast::TyU64),\n+                    _ => { }\n+                }\n+            }\n+        },\n+        _ => { }\n+    }\n+\n+\n+    s = s.slice_to(s.len() - ty.suffix_len());\n+\n+    debug!(\"The suffix is {}, base {}, the new string is {}, the original \\\n+           string was {}\", ty, base, s, orig);\n+\n+    let res: u64 = match ::std::num::from_str_radix(s, base) {\n+        Some(r) => r,\n+        None => { sd.span_err(sp, \"int literal is too large\"); 0 }\n+    };\n+\n+    match ty {\n+        Nothing => ast::LitIntUnsuffixed(res as i64),\n+        Signed(t) => ast::LitInt(res as i64, t),\n+        Unsigned(t) => ast::LitUint(res, t)\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "e0bcb41a75369cfda3ffcf66ea214b5ccdb586ce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -33,8 +33,8 @@ use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n use ast::{Ident, NormalFn, Inherited, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, Lit, Lit_};\n-use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar, LitByte, LitBinary};\n-use ast::{LitIntUnsuffixed, LitNil, LitStr, LitUint, Local, LocalLet};\n+use ast::{LitBool, LitChar, LitByte, LitBinary};\n+use ast::{LitNil, LitStr, LitUint, Local, LocalLet};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n use ast::{NamedField, UnNeg, NoReturn, UnNot, P, Pat, PatEnum};\n@@ -1541,20 +1541,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Matches token_lit = LIT_INT | ...\n+    /// Matches token_lit = LIT_INTEGER | ...\n     pub fn lit_from_token(&mut self, tok: &token::Token) -> Lit_ {\n         match *tok {\n             token::LIT_BYTE(i) => LitByte(parse::byte_lit(i.as_str()).val0()),\n             token::LIT_CHAR(i) => LitChar(parse::char_lit(i.as_str()).val0()),\n-            token::LIT_INT(i, it) => LitInt(i, it),\n-            token::LIT_UINT(u, ut) => LitUint(u, ut),\n-            token::LIT_INT_UNSUFFIXED(i) => LitIntUnsuffixed(i),\n-            token::LIT_FLOAT(s, ft) => {\n-                LitFloat(self.id_to_interned_str(s), ft)\n-            }\n-            token::LIT_FLOAT_UNSUFFIXED(s) => {\n-                LitFloatUnsuffixed(self.id_to_interned_str(s))\n-            }\n+            token::LIT_INTEGER(s) => parse::integer_lit(self.id_to_interned_str(s).get(),\n+                                                       &self.sess.span_diagnostic, self.span),\n+            token::LIT_FLOAT(s) => parse::float_lit(s.as_str()),\n             token::LIT_STR(s) => {\n                 LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n                        ast::CookedStr)\n@@ -5398,3 +5392,4 @@ impl<'a> Parser<'a> {\n         }\n     }\n }\n+"}, {"sha": "83d373d033b3d10110c34ec1c81859d9f1829ca1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4213418e3ab225867d8e3911f592481b1bbffc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cc4213418e3ab225867d8e3911f592481b1bbffc", "patch": "@@ -10,7 +10,6 @@\n \n use ast;\n use ast::{P, Ident, Name, Mrk};\n-use ast_util;\n use ext::mtwt;\n use parse::token;\n use util::interner::{RcStr, StrInterner};\n@@ -81,11 +80,8 @@ pub enum Token {\n     /* Literals */\n     LIT_BYTE(Ident),\n     LIT_CHAR(Ident),\n-    LIT_INT(i64, ast::IntTy),\n-    LIT_UINT(u64, ast::UintTy),\n-    LIT_INT_UNSUFFIXED(i64),\n-    LIT_FLOAT(Ident, ast::FloatTy),\n-    LIT_FLOAT_UNSUFFIXED(Ident),\n+    LIT_INTEGER(Ident),\n+    LIT_FLOAT(Ident),\n     LIT_STR(Ident),\n     LIT_STR_RAW(Ident, uint), /* raw str delimited by n hash symbols */\n     LIT_BINARY(Ident),\n@@ -206,24 +202,10 @@ pub fn to_string(t: &Token) -> String {\n       LIT_CHAR(c) => {\n           format!(\"'{}'\", get_ident(c).get())\n       }\n-      LIT_INT(i, t) => ast_util::int_ty_to_string(t, Some(i)),\n-      LIT_UINT(u, t) => ast_util::uint_ty_to_string(t, Some(u)),\n-      LIT_INT_UNSUFFIXED(i) => { (i as u64).to_string() }\n-      LIT_FLOAT(s, t) => {\n-        let mut body = String::from_str(get_ident(s).get());\n-        if body.as_slice().ends_with(\".\") {\n-            body.push_char('0');  // `10.f` is not a float literal\n-        }\n-        body.push_str(ast_util::float_ty_to_string(t).as_slice());\n-        body\n-      }\n-      LIT_FLOAT_UNSUFFIXED(s) => {\n-        let mut body = String::from_str(get_ident(s).get());\n-        if body.as_slice().ends_with(\".\") {\n-            body.push_char('0');  // `10.f` is not a float literal\n-        }\n-        body\n+      LIT_INTEGER(c) | LIT_FLOAT(c) => {\n+          get_ident(c).get().to_string()\n       }\n+\n       LIT_STR(s) => {\n           format!(\"\\\"{}\\\"\", get_ident(s).get())\n       }\n@@ -285,11 +267,8 @@ pub fn can_begin_expr(t: &Token) -> bool {\n       TILDE => true,\n       LIT_BYTE(_) => true,\n       LIT_CHAR(_) => true,\n-      LIT_INT(_, _) => true,\n-      LIT_UINT(_, _) => true,\n-      LIT_INT_UNSUFFIXED(_) => true,\n-      LIT_FLOAT(_, _) => true,\n-      LIT_FLOAT_UNSUFFIXED(_) => true,\n+      LIT_INTEGER(_) => true,\n+      LIT_FLOAT(_) => true,\n       LIT_STR(_) => true,\n       LIT_STR_RAW(_, _) => true,\n       LIT_BINARY(_) => true,\n@@ -326,11 +305,8 @@ pub fn is_lit(t: &Token) -> bool {\n     match *t {\n       LIT_BYTE(_) => true,\n       LIT_CHAR(_) => true,\n-      LIT_INT(_, _) => true,\n-      LIT_UINT(_, _) => true,\n-      LIT_INT_UNSUFFIXED(_) => true,\n-      LIT_FLOAT(_, _) => true,\n-      LIT_FLOAT_UNSUFFIXED(_) => true,\n+      LIT_INTEGER(_) => true,\n+      LIT_FLOAT(_) => true,\n       LIT_STR(_) => true,\n       LIT_STR_RAW(_, _) => true,\n       LIT_BINARY(_) => true,"}]}