{"sha": "8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMjViN2YwZThjMDFkMzk0NmU3ZTdlNjkxMmUyMjViMzBiNjBmODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-24T23:46:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-24T23:46:24Z"}, "message": "auto merge of #8740 : brson/rust/rt-opt, r=thestinger\n\nSee #8599", "tree": {"sha": "a7c03648b5fc6184a9b6870fb3dbf2152673ab07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7c03648b5fc6184a9b6870fb3dbf2152673ab07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "html_url": "https://github.com/rust-lang/rust/commit/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e311a1ee02af4309394f0b3195c4b6abfcf770a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e311a1ee02af4309394f0b3195c4b6abfcf770a2", "html_url": "https://github.com/rust-lang/rust/commit/e311a1ee02af4309394f0b3195c4b6abfcf770a2"}, {"sha": "bbe347cee79df9cb68ee490ba957e515e3da70a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe347cee79df9cb68ee490ba957e515e3da70a1", "html_url": "https://github.com/rust-lang/rust/commit/bbe347cee79df9cb68ee490ba957e515e3da70a1"}], "stats": {"total": 457, "additions": 240, "deletions": 217}, "files": [{"sha": "0575f48c4c467d7695119ccd9a4afea7aa6dba71", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -96,7 +96,8 @@ ifdef CFG_DISABLE_OPTIMIZE\n   $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n   CFG_RUSTC_FLAGS +=\n else\n-  CFG_RUSTC_FLAGS += -O\n+  # The rtopt cfg turns off runtime sanity checks\n+  CFG_RUSTC_FLAGS += -O --cfg rtopt\n endif\n \n ifdef CFG_ENABLE_DEBUG"}, {"sha": "5378a2c798d8723a40fd103ccbe46822b0a878dc", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -27,8 +27,10 @@ macro_rules! rtdebug (\n \n macro_rules! rtassert (\n     ( $arg:expr ) => ( {\n-        if !$arg {\n-            rtabort!(\"assertion failed: %s\", stringify!($arg));\n+        if ::rt::util::ENFORCE_SANITY {\n+            if !$arg {\n+                rtabort!(\"assertion failed: %s\", stringify!($arg));\n+            }\n         }\n     } )\n )"}, {"sha": "bd83e2861567d25618088a75dd7aac66069d5821", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -125,7 +125,7 @@ impl<T> ChanOne<T> {\n         unsafe {\n \n             // Install the payload\n-            assert!((*packet).payload.is_none());\n+            rtassert!((*packet).payload.is_none());\n             (*packet).payload = Some(val);\n \n             // Atomically swap out the old state to figure out what\n@@ -144,16 +144,8 @@ impl<T> ChanOne<T> {\n             match oldstate {\n                 STATE_BOTH => {\n                     // Port is not waiting yet. Nothing to do\n-                    do Local::borrow::<Scheduler, ()> |sched| {\n-                        rtdebug!(\"non-rendezvous send\");\n-                        sched.metrics.non_rendezvous_sends += 1;\n-                    }\n                 }\n                 STATE_ONE => {\n-                    do Local::borrow::<Scheduler, ()> |sched| {\n-                        rtdebug!(\"rendezvous send\");\n-                        sched.metrics.rendezvous_sends += 1;\n-                    }\n                     // Port has closed. Need to clean up.\n                     let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n                     recvr_active = false;\n@@ -251,7 +243,6 @@ impl<T> SelectInner for PortOne<T> {\n                 STATE_BOTH => {\n                     // Data has not been sent. Now we're blocked.\n                     rtdebug!(\"non-rendezvous recv\");\n-                    sched.metrics.non_rendezvous_recvs += 1;\n                     false\n                 }\n                 STATE_ONE => {\n@@ -267,7 +258,6 @@ impl<T> SelectInner for PortOne<T> {\n                     (*self.packet()).state.store(STATE_ONE, Relaxed);\n \n                     rtdebug!(\"rendezvous recv\");\n-                    sched.metrics.rendezvous_recvs += 1;\n \n                     // Channel is closed. Switch back and check the data.\n                     // NB: We have to drop back into the scheduler event loop here\n@@ -307,7 +297,7 @@ impl<T> SelectInner for PortOne<T> {\n                         STATE_ONE  => true, // Lost the race. Data available.\n                         same_ptr   => {\n                             // We successfully unblocked our task pointer.\n-                            assert!(task_as_state == same_ptr);\n+                            rtassert!(task_as_state == same_ptr);\n                             let handle = BlockedTask::cast_from_uint(task_as_state);\n                             // Because we are already awake, the handle we\n                             // gave to this port shall already be empty.\n@@ -341,7 +331,8 @@ impl<T> SelectPortInner<T> for PortOne<T> {\n         unsafe {\n             // See corresponding store() above in block_on for rationale.\n             // FIXME(#8130) This can happen only in test builds.\n-            assert!((*packet).state.load(Relaxed) == STATE_ONE);\n+            // This load is not required for correctness and may be compiled out.\n+            rtassert!((*packet).state.load(Relaxed) == STATE_ONE);\n \n             let payload = (*packet).payload.take();\n \n@@ -387,7 +378,7 @@ impl<T> Drop for ChanOne<T> {\n                 },\n                 task_as_state => {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n-                    assert!((*this.packet()).payload.is_none());\n+                    rtassert!((*this.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     do recvr.wake().map_move |woken_task| {\n                         Scheduler::run_task(woken_task);"}, {"sha": "18b7394700f356d241e3b9ba9b0a197777623f14", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -21,12 +21,15 @@ pub trait Local {\n     fn take() -> ~Self;\n     fn exists() -> bool;\n     fn borrow<T>(f: &fn(&mut Self) -> T) -> T;\n+    unsafe fn unsafe_take() -> ~Self;\n     unsafe fn unsafe_borrow() -> *mut Self;\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n }\n \n impl Local for Task {\n+    #[inline]\n     fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n+    #[inline]\n     fn take() -> ~Task { unsafe { local_ptr::take() } }\n     fn exists() -> bool { local_ptr::exists() }\n     fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n@@ -43,7 +46,11 @@ impl Local for Task {\n             None => { rtabort!(\"function failed in local_borrow\") }\n         }\n     }\n+    #[inline]\n+    unsafe fn unsafe_take() -> ~Task { local_ptr::unsafe_take() }\n+    #[inline]\n     unsafe fn unsafe_borrow() -> *mut Task { local_ptr::unsafe_borrow() }\n+    #[inline]\n     unsafe fn try_unsafe_borrow() -> Option<*mut Task> {\n         local_ptr::try_unsafe_borrow()\n     }\n@@ -57,12 +64,12 @@ impl Local for Scheduler {\n             task.sched = Some(value.take());\n         };\n     }\n+    #[inline]\n     fn take() -> ~Scheduler {\n-        do Local::borrow::<Task,~Scheduler> |task| {\n-            let sched = task.sched.take_unwrap();\n-            let task = task;\n-            task.sched = None;\n-            sched\n+        unsafe {\n+            // XXX: Unsafe for speed\n+            let task = Local::unsafe_borrow::<Task>();\n+            (*task).sched.take_unwrap()\n         }\n     }\n     fn exists() -> bool {\n@@ -85,6 +92,7 @@ impl Local for Scheduler {\n             }\n         }\n     }\n+    unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut Scheduler {\n         match (*Local::unsafe_borrow::<Task>()).sched {\n             Some(~ref mut sched) => {\n@@ -97,10 +105,17 @@ impl Local for Scheduler {\n         }\n     }\n     unsafe fn try_unsafe_borrow() -> Option<*mut Scheduler> {\n-        if Local::exists::<Scheduler>() {\n-            Some(Local::unsafe_borrow())\n-        } else {\n-            None\n+        match Local::try_unsafe_borrow::<Task>() {\n+            Some(task) => {\n+                match (*task).sched {\n+                    Some(~ref mut sched) => {\n+                        let s: *mut Scheduler = &mut *sched;\n+                        Some(s)\n+                    }\n+                    None => None\n+                }\n+            }\n+            None => None\n         }\n     }\n }\n@@ -111,6 +126,7 @@ impl Local for IoFactoryObject {\n     fn take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n     fn exists() -> bool { rtabort!(\"unimpl\") }\n     fn borrow<T>(_f: &fn(&mut IoFactoryObject) -> T) -> T { rtabort!(\"unimpl\") }\n+    unsafe fn unsafe_take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n         let sched = Local::unsafe_borrow::<Scheduler>();\n         let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();"}, {"sha": "e843fd1adef07aa6e258ac16cc52c628b1b374f7", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -23,14 +23,16 @@ use option::{Option, Some, None};\n use unstable::finally::Finally;\n use tls = rt::thread_local_storage;\n \n+static mut RT_TLS_KEY: tls::Key = -1;\n+\n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n #[fixed_stack_segment]\n #[inline(never)]\n pub fn init_tls_key() {\n     unsafe {\n-        rust_initialize_rt_tls_key();\n+        rust_initialize_rt_tls_key(&mut RT_TLS_KEY);\n         extern {\n-            fn rust_initialize_rt_tls_key();\n+            fn rust_initialize_rt_tls_key(key: *mut tls::Key);\n         }\n     }\n }\n@@ -40,6 +42,7 @@ pub fn init_tls_key() {\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n+#[inline]\n pub unsafe fn put<T>(sched: ~T) {\n     let key = tls_key();\n     let void_ptr: *mut c_void = cast::transmute(sched);\n@@ -51,6 +54,7 @@ pub unsafe fn put<T>(sched: ~T) {\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n+#[inline]\n pub unsafe fn take<T>() -> ~T {\n     let key = tls_key();\n     let void_ptr: *mut c_void = tls::get(key);\n@@ -62,6 +66,23 @@ pub unsafe fn take<T>() -> ~T {\n     return ptr;\n }\n \n+/// Take ownership of a pointer from thread-local storage.\n+///\n+/// # Safety note\n+///\n+/// Does not validate the pointer type.\n+/// Leaves the old pointer in TLS for speed.\n+#[inline]\n+pub unsafe fn unsafe_take<T>() -> ~T {\n+    let key = tls_key();\n+    let void_ptr: *mut c_void = tls::get(key);\n+    if void_ptr.is_null() {\n+        rtabort!(\"thread-local pointer is null. bogus!\");\n+    }\n+    let ptr: ~T = cast::transmute(void_ptr);\n+    return ptr;\n+}\n+\n /// Check whether there is a thread-local pointer installed.\n pub fn exists() -> bool {\n     unsafe {\n@@ -99,10 +120,15 @@ pub unsafe fn borrow<T>(f: &fn(&mut T)) {\n /// Because this leaves the value in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n pub unsafe fn unsafe_borrow<T>() -> *mut T {\n-    match try_unsafe_borrow() {\n-        Some(p) => p,\n-        None => rtabort!(\"thread-local pointer is null. bogus!\")\n+    let key = tls_key();\n+    let mut void_ptr: *mut c_void = tls::get(key);\n+    if void_ptr.is_null() {\n+        rtabort!(\"thread-local pointer is null. bogus!\");\n     }\n+    let ptr: *mut *mut c_void = &mut void_ptr;\n+    let ptr: *mut ~T = ptr as *mut ~T;\n+    let ptr: *mut T = &mut **ptr;\n+    return ptr;\n }\n \n pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n@@ -119,22 +145,18 @@ pub unsafe fn try_unsafe_borrow<T>() -> Option<*mut T> {\n     }\n }\n \n+#[inline]\n fn tls_key() -> tls::Key {\n     match maybe_tls_key() {\n         Some(key) => key,\n         None => rtabort!(\"runtime tls key not initialized\")\n     }\n }\n \n-#[fixed_stack_segment]\n-#[inline(never)]\n-fn maybe_tls_key() -> Option<tls::Key> {\n+#[inline]\n+#[cfg(not(test))]\n+pub fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n-        let key: *mut c_void = rust_get_rt_tls_key();\n-        let key: &mut tls::Key = cast::transmute(key);\n-        let key = *key;\n-        // Check that the key has been initialized.\n-\n         // NB: This is a little racy because, while the key is\n         // initalized under a mutex and it's assumed to be initalized\n         // in the Scheduler ctor by any thread that needs to use it,\n@@ -145,14 +167,19 @@ fn maybe_tls_key() -> Option<tls::Key> {\n         // another thread. I think this is fine since the only action\n         // they could take if it was initialized would be to check the\n         // thread-local value and see that it's not set.\n-        if key != -1 {\n-            return Some(key);\n+        if RT_TLS_KEY != -1 {\n+            return Some(RT_TLS_KEY);\n         } else {\n             return None;\n         }\n     }\n+}\n \n-    extern {\n-        fn rust_get_rt_tls_key() -> *mut c_void;\n-    }\n+// XXX: The boundary between the running runtime and the testing runtime\n+// seems to be fuzzy at the moment, and trying to use two different keys\n+// results in disaster. This should not be necessary.\n+#[inline]\n+#[cfg(test)]\n+pub fn maybe_tls_key() -> Option<tls::Key> {\n+    unsafe { ::cast::transmute(::realstd::rt::local_ptr::maybe_tls_key()) }\n }"}, {"sha": "2bbcaff6d28d606ceb768d42aa72e5d837f0d6e4", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -16,33 +16,66 @@ use kinds::Send;\n use vec::OwnedVector;\n use cell::Cell;\n use option::*;\n-use unstable::sync::Exclusive;\n+use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use clone::Clone;\n \n pub struct MessageQueue<T> {\n-    // XXX: Another mystery bug fixed by boxing this lock\n-    priv queue: ~Exclusive<~[T]>\n+    priv state: UnsafeAtomicRcBox<State<T>>\n+}\n+\n+struct State<T> {\n+    count: uint,\n+    queue: ~[T],\n+    lock: LittleLock\n }\n \n impl<T: Send> MessageQueue<T> {\n     pub fn new() -> MessageQueue<T> {\n         MessageQueue {\n-            queue: ~Exclusive::new(~[])\n+            state: UnsafeAtomicRcBox::new(State {\n+                count: 0,\n+                queue: ~[],\n+                lock: LittleLock::new()\n+            })\n         }\n     }\n \n     pub fn push(&mut self, value: T) {\n         unsafe {\n             let value = Cell::new(value);\n-            self.queue.with(|q| q.push(value.take()) );\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                (*state).count += 1;\n+                (*state).queue.push(value.take());\n+            }\n         }\n     }\n \n     pub fn pop(&mut self) -> Option<T> {\n         unsafe {\n-            do self.queue.with |q| {\n-                if !q.is_empty() {\n-                    Some(q.shift())\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                if !(*state).queue.is_empty() {\n+                    (*state).count += 1;\n+                    Some((*state).queue.shift())\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    /// A pop that may sometimes miss enqueued elements, but is much faster\n+    /// to give up without doing any synchronization\n+    pub fn casual_pop(&mut self) -> Option<T> {\n+        unsafe {\n+            let state = self.state.get();\n+            // NB: Unsynchronized check\n+            if (*state).count == 0 { return None; }\n+            do (*state).lock.lock {\n+                if !(*state).queue.is_empty() {\n+                    (*state).count += 1;\n+                    Some((*state).queue.shift())\n                 } else {\n                     None\n                 }\n@@ -51,10 +84,10 @@ impl<T: Send> MessageQueue<T> {\n     }\n }\n \n-impl<T> Clone for MessageQueue<T> {\n+impl<T: Send> Clone for MessageQueue<T> {\n     fn clone(&self) -> MessageQueue<T> {\n         MessageQueue {\n-            queue: self.queue.clone()\n+            state: self.state.clone()\n         }\n     }\n }"}, {"sha": "b0c0fa5d708623d216bdfb58bdf6947da29ada29", "filename": "src/libstd/rt/metrics.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e311a1ee02af4309394f0b3195c4b6abfcf770a2/src%2Flibstd%2Frt%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e311a1ee02af4309394f0b3195c4b6abfcf770a2/src%2Flibstd%2Frt%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmetrics.rs?ref=e311a1ee02af4309394f0b3195c4b6abfcf770a2", "patch": "@@ -1,98 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use to_str::ToStr;\n-\n-pub struct SchedMetrics {\n-    // The number of times executing `run_sched_once`.\n-    turns: uint,\n-    // The number of turns that received a message.\n-    messages_received: uint,\n-    // The number of turns that ran a task from the queue.\n-    tasks_resumed_from_queue: uint,\n-    // The number of turns that found no work to perform.\n-    wasted_turns: uint,\n-    // The number of times the scheduler went to sleep.\n-    sleepy_times: uint,\n-    // Context switches from the scheduler into a task.\n-    context_switches_sched_to_task: uint,\n-    // Context switches from a task into the scheduler.\n-    context_switches_task_to_sched: uint,\n-    // Context switches from a task to a task.\n-    context_switches_task_to_task: uint,\n-    // Message sends that unblock the receiver\n-    rendezvous_sends: uint,\n-    // Message sends that do not unblock the receiver\n-    non_rendezvous_sends: uint,\n-    // Message receives that do not block the receiver\n-    rendezvous_recvs: uint,\n-    // Message receives that block the receiver\n-    non_rendezvous_recvs: uint,\n-    // JoinLatch releases that create tombstones\n-    release_tombstone: uint,\n-    // JoinLatch releases that do not create tombstones\n-    release_no_tombstone: uint,\n-}\n-\n-impl SchedMetrics {\n-    pub fn new() -> SchedMetrics {\n-        SchedMetrics {\n-            turns: 0,\n-            messages_received: 0,\n-            tasks_resumed_from_queue: 0,\n-            wasted_turns: 0,\n-            sleepy_times: 0,\n-            context_switches_sched_to_task: 0,\n-            context_switches_task_to_sched: 0,\n-            context_switches_task_to_task: 0,\n-            rendezvous_sends: 0,\n-            non_rendezvous_sends: 0,\n-            rendezvous_recvs: 0,\n-            non_rendezvous_recvs: 0,\n-            release_tombstone: 0,\n-            release_no_tombstone: 0\n-        }\n-    }\n-}\n-\n-impl ToStr for SchedMetrics {\n-    fn to_str(&self) -> ~str {\n-        fmt!(\"turns: %u\\n\\\n-              messages_received: %u\\n\\\n-              tasks_resumed_from_queue: %u\\n\\\n-              wasted_turns: %u\\n\\\n-              sleepy_times: %u\\n\\\n-              context_switches_sched_to_task: %u\\n\\\n-              context_switches_task_to_sched: %u\\n\\\n-              context_switches_task_to_task: %u\\n\\\n-              rendezvous_sends: %u\\n\\\n-              non_rendezvous_sends: %u\\n\\\n-              rendezvous_recvs: %u\\n\\\n-              non_rendezvous_recvs: %u\\n\\\n-              release_tombstone: %u\\n\\\n-              release_no_tombstone: %u\\n\\\n-              \",\n-             self.turns,\n-             self.messages_received,\n-             self.tasks_resumed_from_queue,\n-             self.wasted_turns,\n-             self.sleepy_times,\n-             self.context_switches_sched_to_task,\n-             self.context_switches_task_to_sched,\n-             self.context_switches_task_to_task,\n-             self.rendezvous_sends,\n-             self.non_rendezvous_sends,\n-             self.rendezvous_recvs,\n-             self.non_rendezvous_recvs,\n-             self.release_tombstone,\n-             self.release_no_tombstone\n-        )\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "0d59d5780cc875c0b4f910ea00b013f63b3d3ce5", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -152,8 +152,6 @@ pub mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n \n-pub mod metrics;\n-\n // FIXME #5248 shouldn't be pub\n /// Just stuff\n pub mod util;"}, {"sha": "7d59627ba399beba5837dd9fb37d635645e3344f", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -24,7 +24,6 @@ use rt::kill::BlockedTask;\n use rt::local_ptr;\n use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n-use rt::metrics::SchedMetrics;\n use borrow::{to_uint};\n use cell::Cell;\n use rand::{XorShiftRng, RngUtil};\n@@ -71,7 +70,6 @@ pub struct Scheduler {\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     cleanup_job: Option<CleanupJob>,\n-    metrics: SchedMetrics,\n     /// Should this scheduler run any task, or only pinned tasks?\n     run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n@@ -83,6 +81,14 @@ pub struct Scheduler {\n     idle_callback: Option<~PausibleIdleCallback>\n }\n \n+/// An indication of how hard to work on a given operation, the difference\n+/// mainly being whether memory is synchronized or not\n+#[deriving(Eq)]\n+enum EffortLevel {\n+    DontTryTooHard,\n+    GiveItYourBest\n+}\n+\n impl Scheduler {\n \n     // * Initialization Functions\n@@ -118,7 +124,6 @@ impl Scheduler {\n             stack_pool: StackPool::new(),\n             sched_task: None,\n             cleanup_job: None,\n-            metrics: SchedMetrics::new(),\n             run_anything: run_anything,\n             friend_handle: friend,\n             rng: XorShiftRng::new(),\n@@ -186,7 +191,7 @@ impl Scheduler {\n \n         // Should not have any messages\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n-        assert!(message.is_none());\n+        rtassert!(message.is_none());\n \n         stask.destroyed = true;\n     }\n@@ -237,25 +242,30 @@ impl Scheduler {\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n-        let sched = match sched.interpret_message_queue() {\n+        let sched = match sched.interpret_message_queue(DontTryTooHard) {\n             Some(sched) => sched,\n             None => return\n         };\n \n         // This helper will use a randomized work-stealing algorithm\n         // to find work.\n-        let mut sched = match sched.do_work() {\n+        let sched = match sched.do_work() {\n+            Some(sched) => sched,\n+            None => return\n+        };\n+\n+        // Now, before sleeping we need to find out if there really\n+        // were any messages. Give it your best!\n+        let mut sched = match sched.interpret_message_queue(GiveItYourBest) {\n             Some(sched) => sched,\n             None => return\n         };\n \n         // If we got here then there was no work to do.\n         // Generate a SchedHandle and push it to the sleeper list so\n         // somebody can wake us up later.\n-        sched.metrics.wasted_turns += 1;\n         if !sched.sleepy && !sched.no_sleep {\n             rtdebug!(\"scheduler has no work to do, going to sleep\");\n-            sched.metrics.sleepy_times += 1;\n             sched.sleepy = true;\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n@@ -277,10 +287,18 @@ impl Scheduler {\n     // returns the still-available scheduler. At this point all\n     // message-handling will count as a turn of work, and as a result\n     // return None.\n-    fn interpret_message_queue(~self) -> Option<~Scheduler> {\n+    fn interpret_message_queue(~self, effort: EffortLevel) -> Option<~Scheduler> {\n \n         let mut this = self;\n-        match this.message_queue.pop() {\n+\n+        let msg = if effort == DontTryTooHard {\n+            // Do a cheap check that may miss messages\n+            this.message_queue.casual_pop()\n+        } else {\n+            this.message_queue.pop()\n+        };\n+\n+        match msg {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n                 task.give_home(Sched(this.make_handle()));\n@@ -469,10 +487,7 @@ impl Scheduler {\n         // We've made work available. Notify a\n         // sleeping scheduler.\n \n-        // XXX: perf. Check for a sleeper without\n-        // synchronizing memory.  It's not critical\n-        // that we always find it.\n-        match this.sleeper_list.pop() {\n+        match this.sleeper_list.casual_pop() {\n             Some(handle) => {\n                         let mut handle = handle;\n                 handle.send(Wake)\n@@ -505,7 +520,9 @@ impl Scheduler {\n         let mut this = self;\n \n         // The current task is grabbed from TLS, not taken as an input.\n-        let current_task: ~Task = Local::take::<Task>();\n+        // Doing an unsafe_take to avoid writing back a null pointer -\n+        // We're going to call `put` later to do that.\n+        let current_task: ~Task = unsafe { Local::unsafe_take::<Task>() };\n \n         // Check that the task is not in an atomically() section (e.g.,\n         // holding a pthread mutex, which could deadlock the scheduler).\n@@ -563,11 +580,10 @@ impl Scheduler {\n         // run the cleanup job, as expected by the previously called\n         // swap_contexts function.\n         unsafe {\n-            let sched = Local::unsafe_borrow::<Scheduler>();\n-            (*sched).run_cleanup_job();\n+            let task = Local::unsafe_borrow::<Task>();\n+            (*task).sched.get_mut_ref().run_cleanup_job();\n \n             // Must happen after running the cleanup job (of course).\n-            let task = Local::unsafe_borrow::<Task>();\n             (*task).death.check_killed((*task).unwinder.unwinding);\n         }\n     }"}, {"sha": "7232afd6594b5ac9daadb14e2f6b51b7d63dcc16", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -15,33 +15,68 @@ use container::Container;\n use vec::OwnedVector;\n use option::{Option, Some, None};\n use cell::Cell;\n-use unstable::sync::Exclusive;\n+use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use rt::sched::SchedHandle;\n use clone::Clone;\n \n pub struct SleeperList {\n-    priv stack: ~Exclusive<~[SchedHandle]>\n+    priv state: UnsafeAtomicRcBox<State>\n+}\n+\n+struct State {\n+    count: uint,\n+    stack: ~[SchedHandle],\n+    lock: LittleLock\n }\n \n impl SleeperList {\n     pub fn new() -> SleeperList {\n         SleeperList {\n-            stack: ~Exclusive::new(~[])\n+            state: UnsafeAtomicRcBox::new(State {\n+                count: 0,\n+                stack: ~[],\n+                lock: LittleLock::new()\n+            })\n         }\n     }\n \n     pub fn push(&mut self, handle: SchedHandle) {\n         let handle = Cell::new(handle);\n         unsafe {\n-            self.stack.with(|s| s.push(handle.take()));\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                (*state).count += 1;\n+                (*state).stack.push(handle.take());\n+            }\n         }\n     }\n \n     pub fn pop(&mut self) -> Option<SchedHandle> {\n         unsafe {\n-            do self.stack.with |s| {\n-                if !s.is_empty() {\n-                    Some(s.pop())\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                if !(*state).stack.is_empty() {\n+                    (*state).count -= 1;\n+                    Some((*state).stack.pop())\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    /// A pop that may sometimes miss enqueued elements, but is much faster\n+    /// to give up without doing any synchronization\n+    pub fn casual_pop(&mut self) -> Option<SchedHandle> {\n+        unsafe {\n+            let state = self.state.get();\n+            // NB: Unsynchronized check\n+            if (*state).count == 0 { return None; }\n+            do (*state).lock.lock {\n+                if !(*state).stack.is_empty() {\n+                    // NB: count is also protected by the lock\n+                    (*state).count -= 1;\n+                    Some((*state).stack.pop())\n                 } else {\n                     None\n                 }\n@@ -53,7 +88,7 @@ impl SleeperList {\n impl Clone for SleeperList {\n     fn clone(&self) -> SleeperList {\n         SleeperList {\n-            stack: self.stack.clone()\n+            state: self.state.clone()\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "9c2a6e646d2ce2e31fee2ff27c604995d6e6c9d1", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -59,7 +59,7 @@ pub struct Task {\n }\n \n pub enum TaskType {\n-    GreenTask(Option<~SchedHome>),\n+    GreenTask(Option<SchedHome>),\n     SchedTask\n }\n \n@@ -173,7 +173,7 @@ impl Task {\n             name: None,\n             coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n             sched: None,\n-            task_type: GreenTask(Some(~home)),\n+            task_type: GreenTask(Some(home)),\n             borrow_list: None\n         }\n     }\n@@ -196,15 +196,15 @@ impl Task {\n             name: None,\n             coroutine: Some(Coroutine::new(stack_pool, stack_size, start)),\n             sched: None,\n-            task_type: GreenTask(Some(~home)),\n+            task_type: GreenTask(Some(home)),\n             borrow_list: None\n         }\n     }\n \n     pub fn give_home(&mut self, new_home: SchedHome) {\n         match self.task_type {\n             GreenTask(ref mut home) => {\n-                *home = Some(~new_home);\n+                *home = Some(new_home);\n             }\n             SchedTask => {\n                 rtabort!(\"type error: used SchedTask as GreenTask\");\n@@ -216,7 +216,7 @@ impl Task {\n         match self.task_type {\n             GreenTask(ref mut home) => {\n                 let out = home.take_unwrap();\n-                return *out;\n+                return out;\n             }\n             SchedTask => {\n                 rtabort!(\"type error: used SchedTask as GreenTask\");\n@@ -275,8 +275,8 @@ impl Task {\n \n     pub fn is_home_no_tls(&self, sched: &~Scheduler) -> bool {\n         match self.task_type {\n-            GreenTask(Some(~AnySched)) => { false }\n-            GreenTask(Some(~Sched(SchedHandle { sched_id: ref id, _}))) => {\n+            GreenTask(Some(AnySched)) => { false }\n+            GreenTask(Some(Sched(SchedHandle { sched_id: ref id, _}))) => {\n                 *id == sched.sched_id()\n             }\n             GreenTask(None) => {\n@@ -291,8 +291,8 @@ impl Task {\n \n     pub fn homed(&self) -> bool {\n         match self.task_type {\n-            GreenTask(Some(~AnySched)) => { false }\n-            GreenTask(Some(~Sched(SchedHandle { _ }))) => { true }\n+            GreenTask(Some(AnySched)) => { false }\n+            GreenTask(Some(Sched(SchedHandle { _ }))) => { true }\n             GreenTask(None) => {\n                 rtabort!(\"task without home\");\n             }\n@@ -309,11 +309,11 @@ impl Task {\n             let sched_id = task.sched.get_ref().sched_id();\n             let sched_run_anything = task.sched.get_ref().run_anything;\n             match task.task_type {\n-                GreenTask(Some(~AnySched)) => {\n+                GreenTask(Some(AnySched)) => {\n                     rtdebug!(\"anysched task in sched check ****\");\n                     sched_run_anything\n                 }\n-                GreenTask(Some(~Sched(SchedHandle { sched_id: ref id, _ }))) => {\n+                GreenTask(Some(Sched(SchedHandle { sched_id: ref id, _ }))) => {\n                     rtdebug!(\"homed task in sched check ****\");\n                     *id == sched_id\n                 }"}, {"sha": "9113f03ffee1cd9402574ea4db971ffbd30be56c", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -19,6 +19,10 @@ use unstable::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n #[cfg(target_os=\"macos\")]\n use unstable::running_on_valgrind;\n \n+// Indicates whether we should perform expensive sanity checks, including rtassert!\n+// XXX: Once the runtime matures remove the `true` below to turn off rtassert, etc.\n+pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) || cfg!(rtassert);\n+\n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n     #[fixed_stack_segment]; #[inline(never)];"}, {"sha": "6fa0e0eb8c13207bf47212df45082599ffc16040", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -281,20 +281,24 @@ impl<T> Drop for UnsafeAtomicRcBox<T>{\n  */\n // FIXME(#8140) should not be pub\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    use rt::task::Task;\n+    use rt::task::{Task, GreenTask, SchedTask};\n     use rt::local::Local;\n-    use rt::in_green_task_context;\n-\n-    if in_green_task_context() {\n-        let t = Local::unsafe_borrow::<Task>();\n-        do (|| {\n-            (*t).death.inhibit_deschedule();\n-            f()\n-        }).finally {\n-            (*t).death.allow_deschedule();\n+\n+    match Local::try_unsafe_borrow::<Task>() {\n+        Some(t) => {\n+            match (*t).task_type {\n+                GreenTask(_) => {\n+                    do (|| {\n+                        (*t).death.inhibit_deschedule();\n+                        f()\n+                    }).finally {\n+                        (*t).death.allow_deschedule();\n+                    }\n+                }\n+                SchedTask => f()\n+            }\n         }\n-    } else {\n-        f()\n+        None => f()\n     }\n }\n "}, {"sha": "10dc1b5409e57c23929b75a5691cf8bb48dd9afd", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -1401,7 +1401,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let self_len = self.len();\n         let rhs_len = rhs.len();\n         let new_len = self_len + rhs_len;\n-        self.reserve(new_len);\n+        self.reserve_at_least(new_len);\n         unsafe { // Note: infallible.\n             let self_p = vec::raw::to_mut_ptr(*self);\n             let rhs_p = vec::raw::to_ptr(rhs);"}, {"sha": "27cc486c39efc2bfd48e09c7868269045b791a02", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -447,19 +447,14 @@ rust_readdir() {\n #endif\n \n #ifndef _WIN32\n-pthread_key_t rt_key = -1;\n+typedef pthread_key_t tls_key;\n #else\n-DWORD rt_key = -1;\n+typedef DWORD tls_key;\n #endif\n \n-extern \"C\" void*\n-rust_get_rt_tls_key() {\n-    return &rt_key;\n-}\n-\n // Initialize the TLS key used by the new scheduler\n extern \"C\" CDECL void\n-rust_initialize_rt_tls_key() {\n+rust_initialize_rt_tls_key(tls_key *key) {\n \n     static lock_and_signal init_lock;\n     static bool initialized = false;\n@@ -469,10 +464,10 @@ rust_initialize_rt_tls_key() {\n     if (!initialized) {\n \n #ifndef _WIN32\n-        assert(!pthread_key_create(&rt_key, NULL));\n+        assert(!pthread_key_create(key, NULL));\n #else\n-        rt_key = TlsAlloc();\n-        assert(rt_key != TLS_OUT_OF_INDEXES);\n+        *key = TlsAlloc();\n+        assert(*key != TLS_OUT_OF_INDEXES);\n #endif\n \n         initialized = true;"}, {"sha": "b668d3944066252084add406d8c8043e66f6e0e8", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/8c25b7f0e8c01d3946e7e7e6912e225b30b60f89/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=8c25b7f0e8c01d3946e7e7e6912e225b30b60f89", "patch": "@@ -143,7 +143,6 @@ linenoiseHistoryLoad\n rust_raw_thread_start\n rust_raw_thread_join\n rust_raw_thread_delete\n-rust_get_rt_tls_key\n swap_registers\n rust_readdir\n rust_opendir"}]}