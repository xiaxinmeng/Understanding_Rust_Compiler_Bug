{"sha": "b7a6cf8f104ed103f0ec75916abdc801a18b7257", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YTZjZjhmMTA0ZWQxMDNmMGVjNzU5MTZhYmRjODAxYTE4YjcyNTc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2016-10-29T10:14:14Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2016-11-29T12:04:27Z"}, "message": "rustc_typeck: fix compilation", "tree": {"sha": "d9c21f8eef00bf2c0d8572493245e374c50a8e47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9c21f8eef00bf2c0d8572493245e374c50a8e47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7a6cf8f104ed103f0ec75916abdc801a18b7257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7a6cf8f104ed103f0ec75916abdc801a18b7257", "html_url": "https://github.com/rust-lang/rust/commit/b7a6cf8f104ed103f0ec75916abdc801a18b7257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7a6cf8f104ed103f0ec75916abdc801a18b7257/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c8257a8c630610618b5c64a989a3d0c785b2e47", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8257a8c630610618b5c64a989a3d0c785b2e47", "html_url": "https://github.com/rust-lang/rust/commit/8c8257a8c630610618b5c64a989a3d0c785b2e47"}], "stats": {"total": 164, "additions": 94, "deletions": 70}, "files": [{"sha": "0854ca3d1bb26577c9dac211c3ed1c49b25c71e9", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b7a6cf8f104ed103f0ec75916abdc801a18b7257", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &hir::Expr,\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n-                              body: &'gcx hir::Expr,\n+                              body_id: hir::ExprId,\n                               expected: Expectation<'tcx>)\n                               -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n@@ -37,6 +37,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n             None => (None, None),\n         };\n+        let body = self.tcx.map.expr(body_id);\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n "}, {"sha": "cb9d098d2a527b9f39e4695c5df5b9b9cddaecd8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b7a6cf8f104ed103f0ec75916abdc801a18b7257", "patch": "@@ -119,7 +119,7 @@ use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span};\n \n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitMode};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n@@ -538,6 +538,10 @@ struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.ccx.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_type(self.ccx, i);\n         intravisit::walk_item(self, i);\n@@ -630,9 +634,11 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n-                           body: &'tcx hir::Expr,\n+                           body_id: hir::ExprId,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n+    let body = ccx.tcx.map.expr(body_id);\n+\n     let raw_fty = ccx.tcx.item_type(ccx.tcx.map.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n@@ -643,13 +649,13 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     ccx.inherited(fn_id).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n-        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body.id);\n+        let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id());\n         let fn_sig =\n             fn_ty.sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n         let fn_sig =\n             inh.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n         let fn_sig =\n-            inh.normalize_associated_types_in(body.span, body.id, &fn_sig);\n+            inh.normalize_associated_types_in(body.span, body_id.node_id(), &fn_sig);\n \n         let fcx = check_fn(&inh, fn_ty.unsafety, fn_id, &fn_sig, decl, fn_id, body);\n \n@@ -659,7 +665,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n-        fcx.regionck_fn(fn_id, decl, body);\n+        fcx.regionck_fn(fn_id, decl, body_id);\n         fcx.resolve_type_vars_in_fn(decl, body, fn_id);\n     });\n }\n@@ -750,7 +756,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                _: &'gcx hir::Expr, _: Span, _: ast::NodeId) { }\n+                _: hir::ExprId, _: Span, _: ast::NodeId) { }\n }\n \n /// Helper used by check_bare_fn and check_expr_fn. Does the grungy work of checking a function\n@@ -911,8 +917,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n            ccx.tcx.item_path_str(ccx.tcx.map.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n-      hir::ItemFn(ref decl, .., ref body) => {\n-        check_bare_fn(ccx, &decl, &body, it.id, it.span);\n+      hir::ItemFn(ref decl, .., body_id) => {\n+        check_bare_fn(ccx, &decl, body_id, it.id, it.span);\n       }\n       hir::ItemImpl(.., ref impl_item_refs) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n@@ -923,8 +929,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n                     check_const(ccx, &expr, impl_item.id)\n                 }\n-                hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    check_bare_fn(ccx, &sig.decl, body, impl_item.id, impl_item.span);\n+                hir::ImplItemKind::Method(ref sig, body_id) => {\n+                    check_bare_fn(ccx, &sig.decl, body_id, impl_item.id, impl_item.span);\n                 }\n                 hir::ImplItemKind::Type(_) => {\n                     // Nothing to do here.\n@@ -938,8 +944,8 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n                     check_const(ccx, &expr, trait_item.id)\n                 }\n-                hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    check_bare_fn(ccx, &sig.decl, body, trait_item.id, trait_item.span);\n+                hir::MethodTraitItem(ref sig, Some(body_id)) => {\n+                    check_bare_fn(ccx, &sig.decl, body_id, trait_item.id, trait_item.span);\n                 }\n                 hir::MethodTraitItem(_, None) |\n                 hir::ConstTraitItem(_, None) |\n@@ -1102,14 +1108,14 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                          err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::Method(_, ref body) => {\n+                hir::ImplItemKind::Method(_, body_id) => {\n                     let trait_span = tcx.map.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n                         compare_impl_method(ccx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n-                                            body.id,\n+                                            body_id.node_id(),\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n                                             trait_span,\n@@ -1119,7 +1125,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             compare_impl_method(ccx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n-                                                body.id,\n+                                                body_id.node_id(),\n                                                 &ty_trait_item,\n                                                 impl_trait_ref,\n                                                 trait_span,\n@@ -3791,8 +3797,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n             self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n-          hir::ExprClosure(capture, ref decl, ref body, _) => {\n-              self.check_expr_closure(expr, capture, &decl, &body, expected)\n+          hir::ExprClosure(capture, ref decl, body_id, _) => {\n+              self.check_expr_closure(expr, capture, &decl, body_id, expected)\n           }\n           hir::ExprBlock(ref b) => {\n             self.check_block_with_expected(&b, expected)"}, {"sha": "d11a8c75c603c4738422b0d46e9d56893dae8491", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b7a6cf8f104ed103f0ec75916abdc801a18b7257", "patch": "@@ -99,7 +99,7 @@ use std::mem;\n use std::ops::Deref;\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitMode};\n use rustc::hir::{self, PatKind};\n \n use self::SubjectNode::Subject;\n@@ -113,7 +113,7 @@ macro_rules! ignore_err {\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn regionck_expr(&self, e: &hir::Expr) {\n+    pub fn regionck_expr(&self, e: &'gcx hir::Expr) {\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n@@ -141,13 +141,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n                        decl: &hir::FnDecl,\n-                       body: &hir::Expr) {\n+                       body_id: hir::ExprId) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(body.id), body.id, Subject(fn_id));\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(body_id.node_id()), body_id.node_id(), Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, body, self.tcx.map.span(fn_id));\n+            rcx.visit_fn_body(fn_id, decl, body_id, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates(\n@@ -267,14 +267,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n                      fn_decl: &hir::FnDecl,\n-                     body: &hir::Expr,\n+                     body_id: hir::ExprId,\n                      span: Span)\n     {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n         let call_site = self.tcx.region_maps.lookup_code_extent(\n-            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n+            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -300,19 +300,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                          .chain(Some(fn_sig.output))\n                          .collect();\n \n-        let old_body_id = self.set_body_id(body.id);\n-        self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n-        self.link_fn_args(self.tcx.region_maps.node_extent(body.id),\n+        let old_body_id = self.set_body_id(body_id.node_id());\n+        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id(), span);\n+        self.link_fn_args(self.tcx.region_maps.node_extent(body_id.node_id()),\n                           &fn_decl.inputs[..]);\n+        let body = self.tcx.map.expr(body_id);\n         self.visit_expr(body);\n-        self.visit_region_obligations(body.id);\n+        self.visit_region_obligations(body_id.node_id());\n \n         let call_site_scope = self.call_site_scope.unwrap();\n         debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n                body.id, call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body.id,\n+                                       body_id.node_id(),\n                                        call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n@@ -469,7 +470,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n@@ -478,29 +479,33 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n \n-    fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'gcx>, NestedVisitMode)> {\n+        Some((&self.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, fd: &'gcx hir::FnDecl,\n+                b: hir::ExprId, span: Span, id: ast::NodeId) {\n         self.visit_fn_body(id, fd, b, span)\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n \n-    fn visit_arm(&mut self, arm: &hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'gcx hir::Arm) {\n         // see above\n         for p in &arm.pats {\n             self.constrain_bindings_in_pat(p);\n         }\n         intravisit::walk_arm(self, arm);\n     }\n \n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'gcx hir::Local) {\n         // see above\n         self.constrain_bindings_in_pat(&l.pat);\n         self.link_local(l);\n         intravisit::walk_local(self, l);\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n                expr, self.repeating_scope);\n \n@@ -737,8 +742,8 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprClosure(.., ref body, _) => {\n-                self.check_expr_fn_block(expr, &body);\n+            hir::ExprClosure(.., body_id, _) => {\n+                self.check_expr_fn_block(expr, body_id);\n             }\n \n             hir::ExprLoop(ref body, _, _) => {\n@@ -823,9 +828,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_expr_fn_block(&mut self,\n-                           expr: &hir::Expr,\n-                           body: &hir::Expr) {\n-        let repeating_scope = self.set_repeating_scope(body.id);\n+                           expr: &'gcx hir::Expr,\n+                           body_id: hir::ExprId) {\n+        let repeating_scope = self.set_repeating_scope(body_id.node_id());\n         intravisit::walk_expr(self, expr);\n         self.set_repeating_scope(repeating_scope);\n     }"}, {"sha": "796d3016b0bb1315ae433f649c15ec9a81c9840f", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b7a6cf8f104ed103f0ec75916abdc801a18b7257", "patch": "@@ -50,14 +50,14 @@ use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitMode};\n use rustc::util::nodemap::NodeMap;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn closure_analyze(&self, body: &hir::Expr) {\n+    pub fn closure_analyze(&self, body: &'gcx hir::Expr) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_expr(body);\n \n@@ -77,11 +77,15 @@ struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     temp_closure_kinds: NodeMap<ty::ClosureKind>,\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'gcx>, NestedVisitMode)> {\n+        Some((&self.fcx.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, ref body, _) => {\n-                self.check_closure(expr, cc, &body);\n+            hir::ExprClosure(cc, _, body_id, _) => {\n+                self.check_closure(expr, cc, body_id);\n             }\n \n             _ => { }\n@@ -99,7 +103,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn check_closure(&mut self,\n                      expr: &hir::Expr,\n                      capture_clause: hir::CaptureClause,\n-                     _body: &hir::Expr)\n+                     _body_id: hir::ExprId)\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n@@ -153,14 +157,15 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                        id: ast::NodeId,\n                        span: Span,\n                        decl: &hir::FnDecl,\n-                       body: &hir::Expr) {\n+                       body_id: hir::ExprId) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id);\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body_id);\n \n         {\n+            let body = self.fcx.tcx.map.expr(body_id);\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n@@ -484,11 +489,15 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'gcx>, NestedVisitMode)> {\n+        Some((&self.fcx.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n     fn visit_fn(&mut self,\n-                fn_kind: intravisit::FnKind<'v>,\n-                decl: &'v hir::FnDecl,\n-                body: &'v hir::Expr,\n+                fn_kind: intravisit::FnKind<'gcx>,\n+                decl: &'gcx hir::FnDecl,\n+                body: hir::ExprId,\n                 span: Span,\n                 id: ast::NodeId)\n     {"}, {"sha": "ef3ac5da6cc4aca1d6b8c1dd6bc6f55b0b36dd3a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b7a6cf8f104ed103f0ec75916abdc801a18b7257", "patch": "@@ -127,8 +127,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     }\n                 }\n             }\n-            hir::ItemFn(.., ref body) => {\n-                self.check_item_fn(item, body);\n+            hir::ItemFn(.., body_id) => {\n+                self.check_item_fn(item, body_id);\n             }\n             hir::ItemStatic(..) => {\n                 self.check_item_type(item);\n@@ -347,7 +347,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn check_item_fn(&mut self,\n                      item: &hir::Item,\n-                     body: &hir::Expr)\n+                     body_id: hir::ExprId)\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n@@ -364,7 +364,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body.id);\n+            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body_id.node_id());\n             this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n                                     free_id_outlive, &mut implied_bounds);\n             implied_bounds"}, {"sha": "3906722aaab38c5925759087dbb282911fffd3fa", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b7a6cf8f104ed103f0ec75916abdc801a18b7257", "patch": "@@ -27,14 +27,14 @@ use syntax::ast;\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc::hir::print::pat_to_string;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitMode};\n use rustc::hir::{self, PatKind};\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point functions\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr, item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_expr(&self, e: &'gcx hir::Expr, item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n         wbcx.visit_expr(e);\n@@ -47,8 +47,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_in_fn(&self,\n-                                   decl: &hir::FnDecl,\n-                                   body: &hir::Expr,\n+                                   decl: &'gcx hir::FnDecl,\n+                                   body: &'gcx hir::Expr,\n                                    item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n@@ -186,8 +186,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n // below. In general, a function is made into a `visitor` if it must\n // traffic in node-ids or update tables in the type context etc.\n \n-impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn visit_stmt(&mut self, s: &hir::Stmt) {\n+impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'gcx>, NestedVisitMode)> {\n+        Some((&self.fcx.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'gcx hir::Stmt) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -196,7 +200,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_stmt(self, s);\n     }\n \n-    fn visit_expr(&mut self, e: &hir::Expr) {\n+    fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -216,7 +220,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_expr(self, e);\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'gcx hir::Block) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -225,7 +229,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_block(self, b);\n     }\n \n-    fn visit_pat(&mut self, p: &hir::Pat) {\n+    fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -240,7 +244,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_pat(self, p);\n     }\n \n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'gcx hir::Local) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -251,7 +255,7 @@ impl<'cx, 'gcx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'gcx, 'tcx> {\n         intravisit::walk_local(self, l);\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'gcx hir::Ty) {\n         match t.node {\n             hir::TyArray(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);"}, {"sha": "abbf5601484bc46641a6e51e557cb8ca4daa4a36", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7a6cf8f104ed103f0ec75916abdc801a18b7257/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=b7a6cf8f104ed103f0ec75916abdc801a18b7257", "patch": "@@ -385,7 +385,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n         self.check_item(item);\n     }\n \n-\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }"}]}