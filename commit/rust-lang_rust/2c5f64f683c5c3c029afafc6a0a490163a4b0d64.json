{"sha": "2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNWY2NGY2ODNjNWMzYzAyOWFmYWZjNmEwYTQ5MDE2M2E0YjBkNjQ=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-16T09:21:23Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-22T07:39:24Z"}, "message": "BTreeMap/Set: merge the implementations of MergeIter", "tree": {"sha": "252e44b433c8e9059ee07351598c00141550c5cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/252e44b433c8e9059ee07351598c00141550c5cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "html_url": "https://github.com/rust-lang/rust/commit/2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f0fa9d51ff4ad2c0869e660856cd327e79915e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f0fa9d51ff4ad2c0869e660856cd327e79915e9", "html_url": "https://github.com/rust-lang/rust/commit/8f0fa9d51ff4ad2c0869e660856cd327e79915e9"}], "stats": {"total": 208, "additions": 111, "deletions": 97}, "files": [{"sha": "b45b6f80f11c853de8c10ee71010b6f767c729b8", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "patch": "@@ -2,13 +2,14 @@ use core::borrow::Borrow;\n use core::cmp::Ordering;\n use core::fmt::{self, Debug};\n use core::hash::{Hash, Hasher};\n-use core::iter::{FromIterator, FusedIterator, Peekable};\n+use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n+use super::merge_iter::MergeIterInner;\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n@@ -454,10 +455,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n }\n \n // An iterator for merging two sorted sequences into one\n-struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n-    left: Peekable<I>,\n-    right: Peekable<I>,\n-}\n+struct MergeIter<K, V, I: Iterator<Item = (K, V)>>(MergeIterInner<I>);\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap.\n@@ -909,7 +907,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         // First, we merge `self` and `other` into a sorted sequence in linear time.\n         let self_iter = mem::take(self).into_iter();\n         let other_iter = mem::take(other).into_iter();\n-        let iter = MergeIter { left: self_iter.peekable(), right: other_iter.peekable() };\n+        let iter = MergeIter(MergeIterInner::new(self_iter, other_iter));\n \n         // Second, we build a tree from the sorted sequence in linear time.\n         self.from_sorted_iter(iter);\n@@ -2216,27 +2214,16 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n+impl<K: Ord, V, I> Iterator for MergeIter<K, V, I>\n+where\n+    I: Iterator<Item = (K, V)> + ExactSizeIterator + FusedIterator,\n+{\n     type Item = (K, V);\n \n+    /// If two keys are equal, returns the key/value-pair from the right source.\n     fn next(&mut self) -> Option<(K, V)> {\n-        let res = match (self.left.peek(), self.right.peek()) {\n-            (Some(&(ref left_key, _)), Some(&(ref right_key, _))) => left_key.cmp(right_key),\n-            (Some(_), None) => Ordering::Less,\n-            (None, Some(_)) => Ordering::Greater,\n-            (None, None) => return None,\n-        };\n-\n-        // Check which elements comes first and only advance the corresponding iterator.\n-        // If two keys are equal, take the value from `right`.\n-        match res {\n-            Ordering::Less => self.left.next(),\n-            Ordering::Greater => self.right.next(),\n-            Ordering::Equal => {\n-                self.left.next();\n-                self.right.next()\n-            }\n-        }\n+        let (a_next, b_next) = self.0.nexts(|a: &(K, V), b: &(K, V)| K::cmp(&a.0, &b.0));\n+        b_next.or(a_next)\n     }\n }\n "}, {"sha": "88e6f86c2c6f5bb5da7e4924773004271660eafa", "filename": "library/alloc/src/collections/btree/merge_iter.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmerge_iter.rs?ref=2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "patch": "@@ -0,0 +1,96 @@\n+use core::cmp::Ordering;\n+use core::fmt::{self, Debug};\n+use core::iter::FusedIterator;\n+\n+/// Core of an iterator that merges the output of two ascending iterators,\n+/// for instance a union or a symmetric difference.\n+pub struct MergeIterInner<I>\n+where\n+    I: Iterator,\n+{\n+    a: I,\n+    b: I,\n+    peeked: Option<Peeked<I>>,\n+}\n+\n+/// Benchmarks faster than wrapping both iterators in a Peekable.\n+#[derive(Clone, Debug)]\n+enum Peeked<I: Iterator> {\n+    A(I::Item),\n+    B(I::Item),\n+}\n+\n+impl<I> Clone for MergeIterInner<I>\n+where\n+    I: Clone + Iterator,\n+    I::Item: Clone,\n+{\n+    fn clone(&self) -> Self {\n+        Self { a: self.a.clone(), b: self.b.clone(), peeked: self.peeked.clone() }\n+    }\n+}\n+\n+impl<I> Debug for MergeIterInner<I>\n+where\n+    I: Iterator + Debug,\n+    I::Item: Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MergeIterInner\").field(&self.a).field(&self.b).finish()\n+    }\n+}\n+\n+impl<I> MergeIterInner<I>\n+where\n+    I: ExactSizeIterator + FusedIterator,\n+{\n+    /// Creates a new core for an iterator merging a pair of sources.\n+    pub fn new(a: I, b: I) -> Self {\n+        MergeIterInner { a, b, peeked: None }\n+    }\n+\n+    /// Returns the next pair of items stemming from the pair of sources\n+    /// being merged. If both returned options contain a value, that value\n+    /// is equal and occurs in both sources. If one of the returned options\n+    /// contains a value, that value doesn't occur in the other source.\n+    /// If neither returned option contains a value, iteration has finished\n+    /// and subsequent calls will return the same empty pair.\n+    pub fn nexts<Cmp: Fn(&I::Item, &I::Item) -> Ordering>(\n+        &mut self,\n+        cmp: Cmp,\n+    ) -> (Option<I::Item>, Option<I::Item>) {\n+        let mut a_next;\n+        let mut b_next;\n+        match self.peeked.take() {\n+            Some(Peeked::A(next)) => {\n+                a_next = Some(next);\n+                b_next = self.b.next();\n+            }\n+            Some(Peeked::B(next)) => {\n+                b_next = Some(next);\n+                a_next = self.a.next();\n+            }\n+            None => {\n+                a_next = self.a.next();\n+                b_next = self.b.next();\n+            }\n+        }\n+        if let (Some(ref a1), Some(ref b1)) = (&a_next, &b_next) {\n+            match cmp(a1, b1) {\n+                Ordering::Less => self.peeked = b_next.take().map(Peeked::B),\n+                Ordering::Greater => self.peeked = a_next.take().map(Peeked::A),\n+                Ordering::Equal => (),\n+            }\n+        }\n+        (a_next, b_next)\n+    }\n+\n+    /// Returns a pair of upper bounds for the `size_hint` of the final iterator.\n+    pub fn lens(&self) -> (usize, usize) {\n+        match self.peeked {\n+            Some(Peeked::A(_)) => (1 + self.a.len(), self.b.len()),\n+            Some(Peeked::B(_)) => (self.a.len(), 1 + self.b.len()),\n+            _ => (self.a.len(), self.b.len()),\n+        }\n+    }\n+}"}, {"sha": "3f475898e0fbfaa30004df325484eb7a670f11b6", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "patch": "@@ -1,5 +1,6 @@\n mod borrow;\n pub mod map;\n+mod merge_iter;\n mod navigate;\n mod node;\n mod remove;"}, {"sha": "3ad74969bec33b4a6b72a1e1fa8e4781a18c7a8b", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 73, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c5f64f683c5c3c029afafc6a0a490163a4b0d64/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=2c5f64f683c5c3c029afafc6a0a490163a4b0d64", "patch": "@@ -9,6 +9,7 @@ use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n use super::map::{BTreeMap, Keys};\n+use super::merge_iter::MergeIterInner;\n use super::Recover;\n \n // FIXME(conventions): implement bounded iterators\n@@ -114,77 +115,6 @@ pub struct Range<'a, T: 'a> {\n     iter: super::map::Range<'a, T, ()>,\n }\n \n-/// Core of SymmetricDifference and Union.\n-/// More efficient than btree.map.MergeIter,\n-/// and crucially for SymmetricDifference, nexts() reports on both sides.\n-#[derive(Clone)]\n-struct MergeIterInner<I>\n-where\n-    I: Iterator,\n-    I::Item: Copy,\n-{\n-    a: I,\n-    b: I,\n-    peeked: Option<MergeIterPeeked<I>>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-enum MergeIterPeeked<I: Iterator> {\n-    A(I::Item),\n-    B(I::Item),\n-}\n-\n-impl<I> MergeIterInner<I>\n-where\n-    I: ExactSizeIterator + FusedIterator,\n-    I::Item: Copy + Ord,\n-{\n-    fn new(a: I, b: I) -> Self {\n-        MergeIterInner { a, b, peeked: None }\n-    }\n-\n-    fn nexts(&mut self) -> (Option<I::Item>, Option<I::Item>) {\n-        let mut a_next = match self.peeked {\n-            Some(MergeIterPeeked::A(next)) => Some(next),\n-            _ => self.a.next(),\n-        };\n-        let mut b_next = match self.peeked {\n-            Some(MergeIterPeeked::B(next)) => Some(next),\n-            _ => self.b.next(),\n-        };\n-        let ord = match (a_next, b_next) {\n-            (None, None) => Equal,\n-            (_, None) => Less,\n-            (None, _) => Greater,\n-            (Some(a1), Some(b1)) => a1.cmp(&b1),\n-        };\n-        self.peeked = match ord {\n-            Less => b_next.take().map(MergeIterPeeked::B),\n-            Equal => None,\n-            Greater => a_next.take().map(MergeIterPeeked::A),\n-        };\n-        (a_next, b_next)\n-    }\n-\n-    fn lens(&self) -> (usize, usize) {\n-        match self.peeked {\n-            Some(MergeIterPeeked::A(_)) => (1 + self.a.len(), self.b.len()),\n-            Some(MergeIterPeeked::B(_)) => (self.a.len(), 1 + self.b.len()),\n-            _ => (self.a.len(), self.b.len()),\n-        }\n-    }\n-}\n-\n-impl<I> Debug for MergeIterInner<I>\n-where\n-    I: Iterator + Debug,\n-    I::Item: Copy + Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MergeIterInner\").field(&self.a).field(&self.b).finish()\n-    }\n-}\n-\n /// A lazy iterator producing elements in the difference of `BTreeSet`s.\n ///\n /// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n@@ -1461,7 +1391,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            let (a_next, b_next) = self.0.nexts();\n+            let (a_next, b_next) = self.0.nexts(Self::Item::cmp);\n             if a_next.and(b_next).is_none() {\n                 return a_next.or(b_next);\n             }\n@@ -1555,7 +1485,7 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        let (a_next, b_next) = self.0.nexts();\n+        let (a_next, b_next) = self.0.nexts(Self::Item::cmp);\n         a_next.or(b_next)\n     }\n "}]}