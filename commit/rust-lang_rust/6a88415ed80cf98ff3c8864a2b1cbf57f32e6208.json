{"sha": "6a88415ed80cf98ff3c8864a2b1cbf57f32e6208", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhODg0MTVlZDgwY2Y5OGZmM2M4ODY0YTJiMWNiZjU3ZjMyZTYyMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-18T03:12:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-18T03:12:02Z"}, "message": "auto merge of #8544 : dim-an/rust/fix-match-pipes, r=pcwalton\n\nPointers to bound variables shouldn't be stored before checking pattern,\r\notherwise piped patterns can conflict with each other (issue #6338).\r\n\r\nCloses #6338.", "tree": {"sha": "ced0f156f473226dea5317bf0db2bdf852b38897", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ced0f156f473226dea5317bf0db2bdf852b38897"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208", "html_url": "https://github.com/rust-lang/rust/commit/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "679102109fd72c2560de0988324c14af3ae27c7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/679102109fd72c2560de0988324c14af3ae27c7a", "html_url": "https://github.com/rust-lang/rust/commit/679102109fd72c2560de0988324c14af3ae27c7a"}, {"sha": "f4b88547ad8233c69f024b67e0a6bbd98b28c6e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b88547ad8233c69f024b67e0a6bbd98b28c6e1", "html_url": "https://github.com/rust-lang/rust/commit/f4b88547ad8233c69f024b67e0a6bbd98b28c6e1"}], "stats": {"total": 114, "additions": 94, "deletions": 20}, "files": [{"sha": "1eeafeacc6f05a75b395d59360ec0c572d0e94c4", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=6a88415ed80cf98ff3c8864a2b1cbf57f32e6208", "patch": "@@ -399,10 +399,17 @@ struct ArmData<'self> {\n     bindings_map: @BindingsMap\n }\n \n+/**\n+ * Info about Match.\n+ * If all `pats` are matched then arm `data` will be executed.\n+ * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n+ * these pointers are stored in llmatch variables just before executing `data` arm.\n+ */\n #[deriving(Clone)]\n struct Match<'self> {\n     pats: ~[@ast::pat],\n-    data: ArmData<'self>\n+    data: ArmData<'self>,\n+    bound_ptrs: ~[(ident, ValueRef)]\n }\n \n impl<'self> Repr for Match<'self> {\n@@ -447,14 +454,13 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                 br.pats.slice(col + 1u,\n                                            br.pats.len())));\n \n-                let binding_info =\n-                    br.data.bindings_map.get(&path_to_ident(path));\n-\n-                Store(bcx, val, binding_info.llmatch);\n-                Match {\n+                let mut res = Match {\n                     pats: pats,\n-                    data: br.data.clone()\n-                }\n+                    data: br.data.clone(),\n+                    bound_ptrs: br.bound_ptrs.clone()\n+                };\n+                res.bound_ptrs.push((path_to_ident(path), val));\n+                res\n             }\n             _ => (*br).clone(),\n         }\n@@ -496,21 +502,20 @@ fn enter_match<'r>(bcx: @mut Block,\n                         br.pats.slice(col + 1u, br.pats.len()));\n \n                 let this = br.pats[col];\n+                let mut bound_ptrs = br.bound_ptrs.clone();\n                 match this.node {\n                     ast::pat_ident(_, ref path, None) => {\n                         if pat_is_binding(dm, this) {\n-                            let binding_info =\n-                                br.data.bindings_map.get(\n-                                    &path_to_ident(path));\n-                            Store(bcx, val, binding_info.llmatch);\n+                            bound_ptrs.push((path_to_ident(path), val));\n                         }\n                     }\n                     _ => {}\n                 }\n \n                 result.push(Match {\n                     pats: pats,\n-                    data: br.data.clone()\n+                    data: br.data.clone(),\n+                    bound_ptrs: bound_ptrs\n                 });\n             }\n             None => ()\n@@ -1294,18 +1299,14 @@ fn store_non_ref_bindings(bcx: @mut Block,\n \n fn insert_lllocals(bcx: @mut Block,\n                    bindings_map: &BindingsMap,\n-                   binding_mode: IrrefutablePatternBindingMode,\n                    add_cleans: bool) -> @mut Block {\n     /*!\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n      * the bindings.\n      */\n \n-    let llmap = match binding_mode {\n-        BindLocal => bcx.fcx.lllocals,\n-        BindArgument => bcx.fcx.llargs\n-    };\n+    let llmap = bcx.fcx.lllocals;\n \n     for (&ident, &binding_info) in bindings_map.iter() {\n         let llval = match binding_info.trmode {\n@@ -1358,7 +1359,7 @@ fn compile_guard(bcx: @mut Block,\n     bcx = store_non_ref_bindings(bcx,\n                                  data.bindings_map,\n                                  Some(&mut temp_cleanups));\n-    bcx = insert_lllocals(bcx, data.bindings_map, BindLocal, false);\n+    bcx = insert_lllocals(bcx, data.bindings_map, false);\n \n     let val = unpack_result!(bcx, {\n         do with_scope_result(bcx, guard_expr.info(),\n@@ -1418,6 +1419,10 @@ fn compile_submatch(bcx: @mut Block,\n     }\n     if m[0].pats.len() == 0u {\n         let data = &m[0].data;\n+        for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n+            let llmatch = data.bindings_map.get(ident).llmatch;\n+            Store(bcx, *value_ptr, llmatch);\n+        }\n         match data.arm.guard {\n             Some(guard_expr) => {\n                 bcx = compile_guard(bcx,\n@@ -1843,6 +1848,7 @@ fn trans_match_inner(scope_cx: @mut Block,\n             matches.push(Match {\n                 pats: ~[*p],\n                 data: arm_data.clone(),\n+                bound_ptrs: ~[],\n             });\n         }\n     }\n@@ -1875,7 +1881,7 @@ fn trans_match_inner(scope_cx: @mut Block,\n         }\n \n         // insert bindings into the lllocals map and add cleanups\n-        bcx = insert_lllocals(bcx, arm_data.bindings_map, BindLocal, true);\n+        bcx = insert_lllocals(bcx, arm_data.bindings_map, true);\n \n         bcx = controlflow::trans_block(bcx, &arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));"}, {"sha": "b4933773c03e25b41bb8acdd4ff08b5f1ff6c304", "filename": "src/test/run-pass/match-pipe-binding.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a88415ed80cf98ff3c8864a2b1cbf57f32e6208/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs?ref=6a88415ed80cf98ff3c8864a2b1cbf57f32e6208", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn test1() {\n+    // from issue 6338\n+    match ((1, ~\"a\"), (2, ~\"b\")) {\n+        ((1, a), (2, b)) | ((2, b), (1, a)) => {\n+                assert_eq!(a, ~\"a\");\n+                assert_eq!(b, ~\"b\");\n+            },\n+            _ => fail!(),\n+    }\n+}\n+\n+fn test2() {\n+    match (1, 2, 3) {\n+        (1, a, b) | (2, b, a) => {\n+            assert_eq!(a, 2);\n+            assert_eq!(b, 3);\n+        },\n+        _ => fail!(),\n+    }\n+}\n+\n+fn test3() {\n+    match (1, 2, 3) {\n+        (1, ref a, ref b) | (2, ref b, ref a) => {\n+            assert_eq!(*a, 2);\n+            assert_eq!(*b, 3);\n+        },\n+        _ => fail!(),\n+    }\n+}\n+\n+fn test4() {\n+    match (1, 2, 3) {\n+        (1, a, b) | (2, b, a) if a == 2 => {\n+            assert_eq!(a, 2);\n+            assert_eq!(b, 3);\n+        },\n+        _ => fail!(),\n+    }\n+}\n+\n+fn test5() {\n+    match (1, 2, 3) {\n+        (1, ref a, ref b) | (2, ref b, ref a) if *a == 2 => {\n+            assert_eq!(*a, 2);\n+            assert_eq!(*b, 3);\n+        },\n+        _ => fail!(),\n+    }\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+    test3();\n+    test4();\n+    test5();\n+}"}]}