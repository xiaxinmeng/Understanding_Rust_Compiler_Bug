{"sha": "07ce659dd03523b526cb4804b9ef882f31e9ecf3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Y2U2NTlkZDAzNTIzYjUyNmNiNDgwNGI5ZWY4ODJmMzFlOWVjZjM=", "commit": {"author": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-03-14T16:22:40Z"}, "committer": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-03-14T16:22:40Z"}, "message": "expose ordered/unordered/nanless intirnsics", "tree": {"sha": "59bfa5b8c609b58e320e827b79347fd466ffb797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59bfa5b8c609b58e320e827b79347fd466ffb797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07ce659dd03523b526cb4804b9ef882f31e9ecf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07ce659dd03523b526cb4804b9ef882f31e9ecf3", "html_url": "https://github.com/rust-lang/rust/commit/07ce659dd03523b526cb4804b9ef882f31e9ecf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07ce659dd03523b526cb4804b9ef882f31e9ecf3/comments", "author": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "url": "https://api.github.com/repos/rust-lang/rust/commits/01cc5b3e195bb01088fdd59638f0d8c6d0a78142", "html_url": "https://github.com/rust-lang/rust/commit/01cc5b3e195bb01088fdd59638f0d8c6d0a78142"}], "stats": {"total": 431, "additions": 202, "deletions": 229}, "files": [{"sha": "371f53013b903a57e5412315a75795e19cd11be5", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=07ce659dd03523b526cb4804b9ef882f31e9ecf3", "patch": "@@ -958,6 +958,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn vector_reduce_fadd_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n         self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n             let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n@@ -966,6 +969,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn vector_reduce_fmul_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n         self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n             let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n@@ -1001,6 +1007,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src)\n         }\n     }\n+    pub fn vector_reduce_fmin(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmin\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, true)\n+        }\n+    }\n+    pub fn vector_reduce_fmax(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmax\");\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, true)\n+        }\n+    }\n     pub fn vector_reduce_fmin_fast(&self, src: ValueRef) -> ValueRef {\n         self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {"}, {"sha": "8b62a1be80c3d8e47dd152344dabefab33f6220e", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 112, "deletions": 188, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=07ce659dd03523b526cb4804b9ef882f31e9ecf3", "patch": "@@ -1150,210 +1150,134 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()))\n     }\n \n-    if name == \"simd_reduce_add\" {\n-        require!(ret_ty == in_elem,\n-                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                 in_elem, in_ty, ret_ty);\n-        return match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                Ok(bx.vector_reduce_add(args[0].immediate()))\n-            },\n-            ty::TyUint(_u) => {\n-                Ok(bx.vector_reduce_add(args[0].immediate()))\n-            },\n-            ty::TyFloat(f) => {\n-                // undef as accumulator makes the reduction unordered:\n-                let acc = match f.bit_width() {\n-                    32 => C_undef(Type::f32(bx.cx)),\n-                    64 => C_undef(Type::f64(bx.cx)),\n-                    v => {\n-                        return_error!(\n-                            \"unsupported {} from `{}` with element `{}` of size `{}` to `{}`\",\n-                            \"simd_reduce_add\", in_ty, in_elem, v, ret_ty)\n+    macro_rules! arith_red {\n+        ($name:tt : $integer_reduce:ident, $float_reduce:ident, $ordered:expr) => {\n+            if name == $name {\n+                require!(ret_ty == in_elem,\n+                         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                         in_elem, in_ty, ret_ty);\n+                return match in_elem.sty {\n+                    ty::TyInt(_) | ty::TyUint(_) => {\n+                        let r = bx.$integer_reduce(args[0].immediate());\n+                        if $ordered {\n+                            // if overflow occurs, the result is the\n+                            // mathematical result modulo 2^n:\n+                            if name.contains(\"mul\") {\n+                                Ok(bx.mul(args[1].immediate(), r))\n+                            } else {\n+                                Ok(bx.add(args[1].immediate(), r))\n+                            }\n+                        } else {\n+                            Ok(bx.$integer_reduce(args[0].immediate()))\n+                        }\n+                    },\n+                    ty::TyFloat(f) => {\n+                        // ordered arithmetic reductions take an accumulator\n+                        let acc = if $ordered {\n+                            args[1].immediate()\n+                        } else {\n+                            // unordered arithmetic reductions do not:\n+                            match f.bit_width() {\n+                                32 => C_undef(Type::f32(bx.cx)),\n+                                64 => C_undef(Type::f64(bx.cx)),\n+                                v => {\n+                                    return_error!(\n+                                        \"unsupported {} from `{}` with element `{}` of size `{}` to `{}`\",\n+                                        $name, in_ty, in_elem, v, ret_ty\n+                                    )\n+                                }\n+                            }\n+\n+                        };\n+                        Ok(bx.$float_reduce(acc, args[0].immediate()))\n                     }\n-                };\n-                Ok(bx.vector_reduce_fadd_fast(acc, args[0].immediate()))\n+                    _ => {\n+                        return_error!(\n+                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                            $name, in_ty, in_elem, ret_ty\n+                        )\n+                    },\n+                }\n             }\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_add\", in_ty, in_elem, ret_ty)\n-            },\n         }\n     }\n \n-    if name == \"simd_reduce_mul\" {\n-        require!(ret_ty == in_elem,\n-                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                 in_elem, in_ty, ret_ty);\n-        return match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                Ok(bx.vector_reduce_mul(args[0].immediate()))\n-            },\n-            ty::TyUint(_u) => {\n-                Ok(bx.vector_reduce_mul(args[0].immediate()))\n-            },\n-            ty::TyFloat(f) => {\n-                // undef as accumulator makes the reduction unordered:\n-                let acc = match f.bit_width() {\n-                    32 => C_undef(Type::f32(bx.cx)),\n-                    64 => C_undef(Type::f64(bx.cx)),\n-                    v => {\n-                        return_error!(\n-                            \"unsupported {} from `{}` with element `{}` of size `{}` to `{}`\",\n-                            \"simd_reduce_mul\", in_ty, in_elem, v, ret_ty)\n+    arith_red!(\"simd_reduce_add_ordered\": vector_reduce_add, vector_reduce_fadd_fast, true);\n+    arith_red!(\"simd_reduce_mul_ordered\": vector_reduce_mul, vector_reduce_fmul_fast, true);\n+    arith_red!(\"simd_reduce_add_unordered\": vector_reduce_add, vector_reduce_fadd_fast, false);\n+    arith_red!(\"simd_reduce_mul_unordered\": vector_reduce_mul, vector_reduce_fmul_fast, false);\n+\n+    macro_rules! minmax_red {\n+        ($name:tt: $int_red:ident, $float_red:ident) => {\n+            if name == $name {\n+                require!(ret_ty == in_elem,\n+                         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                         in_elem, in_ty, ret_ty);\n+                return match in_elem.sty {\n+                    ty::TyInt(_i) => {\n+                        Ok(bx.$int_red(args[0].immediate(), true))\n+                    },\n+                    ty::TyUint(_u) => {\n+                        Ok(bx.$int_red(args[0].immediate(), false))\n+                    },\n+                    ty::TyFloat(_f) => {\n+                        Ok(bx.$float_red(args[0].immediate()))\n                     }\n-                };\n-                Ok(bx.vector_reduce_fmul_fast(acc, args[0].immediate()))\n+                    _ => {\n+                        return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                      $name, in_ty, in_elem, ret_ty)\n+                    },\n+                }\n             }\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_mul\", in_ty, in_elem, ret_ty)\n-            },\n-        }\n-    }\n \n-    if name == \"simd_reduce_min\" {\n-        require!(ret_ty == in_elem,\n-                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                 in_elem, in_ty, ret_ty);\n-        return match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                Ok(bx.vector_reduce_min(args[0].immediate(), true))\n-            },\n-            ty::TyUint(_u) => {\n-                Ok(bx.vector_reduce_min(args[0].immediate(), false))\n-            },\n-            ty::TyFloat(_f) => {\n-                Ok(bx.vector_reduce_fmin_fast(args[0].immediate()))\n-            }\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_min\", in_ty, in_elem, ret_ty)\n-            },\n         }\n     }\n \n-    if name == \"simd_reduce_max\" {\n-        require!(ret_ty == in_elem,\n-                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                 in_elem, in_ty, ret_ty);\n-        return match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                Ok(bx.vector_reduce_max(args[0].immediate(), true))\n-            },\n-            ty::TyUint(_u) => {\n-                Ok(bx.vector_reduce_max(args[0].immediate(), false))\n-            },\n-            ty::TyFloat(_f) => {\n-                Ok(bx.vector_reduce_fmax_fast(args[0].immediate()))\n-            }\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_max\", in_ty, in_elem, ret_ty)\n-            },\n-        }\n-    }\n+    minmax_red!(\"simd_reduce_min\": vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(\"simd_reduce_max\": vector_reduce_max, vector_reduce_fmax);\n \n-    if name == \"simd_reduce_and\" {\n-        require!(ret_ty == in_elem,\n-                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                 in_elem, in_ty, ret_ty);\n-        return match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                Ok(bx.vector_reduce_and(args[0].immediate()))\n-            },\n-            ty::TyUint(_u) => {\n-                Ok(bx.vector_reduce_and(args[0].immediate()))\n-            },\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_and\", in_ty, in_elem, ret_ty)\n-            },\n-        }\n-    }\n+    minmax_red!(\"simd_reduce_min_nanless\": vector_reduce_min, vector_reduce_fmin_fast);\n+    minmax_red!(\"simd_reduce_max_nanless\": vector_reduce_max, vector_reduce_fmax_fast);\n \n-    if name == \"simd_reduce_or\" {\n-        require!(ret_ty == in_elem,\n-                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                 in_elem, in_ty, ret_ty);\n-        return match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                Ok(bx.vector_reduce_or(args[0].immediate()))\n-            },\n-            ty::TyUint(_u) => {\n-                Ok(bx.vector_reduce_or(args[0].immediate()))\n-            },\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_or\", in_ty, in_elem, ret_ty)\n-            },\n-        }\n-    }\n-\n-    if name == \"simd_reduce_xor\" {\n-        require!(ret_ty == in_elem,\n-                 \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                 in_elem, in_ty, ret_ty);\n-        return match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                Ok(bx.vector_reduce_xor(args[0].immediate()))\n-            },\n-            ty::TyUint(_u) => {\n-                Ok(bx.vector_reduce_xor(args[0].immediate()))\n-            },\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_xor\", in_ty, in_elem, ret_ty)\n-            },\n+    macro_rules! bitwise_red {\n+        ($name:tt : $red:ident, $boolean:expr) => {\n+            if name == $name {\n+                let input = if !$boolean {\n+                    require!(ret_ty == in_elem,\n+                             \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                             in_elem, in_ty, ret_ty);\n+                    args[0].immediate()\n+                } else {\n+                    // boolean reductions operate on vectors of i1s:\n+                    let i1 = Type::i1(bx.cx);\n+                    let i1xn = Type::vector(&i1, in_len as u64);\n+                    bx.trunc(args[0].immediate(), i1xn)\n+                };\n+                return match in_elem.sty {\n+                    ty::TyInt(_) | ty::TyUint(_) => {\n+                        let r = bx.$red(input);\n+                        Ok(\n+                            if !$boolean {\n+                                r\n+                            } else {\n+                                bx.zext(r, Type::bool(bx.cx))\n+                            }\n+                        )\n+                    },\n+                    _ => {\n+                        return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                      $name, in_ty, in_elem, ret_ty)\n+                    },\n+                }\n+            }\n         }\n     }\n \n-    if name == \"simd_reduce_all\" {\n-        //require!(ret_ty == in_elem,\n-        //         \"expected return type `{}` (element of input `{}`), found `{}`\",\n-        //         in_elem, in_ty, ret_ty);\n-        let i1 = Type::i1(bx.cx);\n-        let i1xn = Type::vector(&i1, in_len as u64);\n-        let v = bx.trunc(args[0].immediate(), i1xn);\n-\n-        let red = match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                bx.vector_reduce_and(v)\n-            },\n-            ty::TyUint(_u) => {\n-                bx.vector_reduce_and(v)\n-            },\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_and\", in_ty, in_elem, ret_ty)\n-            },\n-        };\n-        return Ok(bx.zext(red, Type::bool(bx.cx)));\n-    }\n-\n-    if name == \"simd_reduce_any\" {\n-        //require!(ret_ty == in_elem,\n-        //         \"expected return type `{}` (element of input `{}`), found `{}`\",\n-        //         in_elem, in_ty, ret_ty);\n-        let i1 = Type::i1(bx.cx);\n-        let i1xn = Type::vector(&i1, in_len as u64);\n-        let v = bx.trunc(args[0].immediate(), i1xn);\n-\n-        let red = match in_elem.sty {\n-            ty::TyInt(_i) => {\n-                bx.vector_reduce_or(v)\n-            },\n-            ty::TyUint(_u) => {\n-                bx.vector_reduce_or(v)\n-            },\n-            _ => {\n-                return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n-                              \"simd_reduce_and\", in_ty, in_elem, ret_ty)\n-            },\n-        };\n-        return Ok(bx.zext(red, Type::bool(bx.cx)));\n-    }\n-\n+    bitwise_red!(\"simd_reduce_and\": vector_reduce_and, false);\n+    bitwise_red!(\"simd_reduce_or\": vector_reduce_or, false);\n+    bitwise_red!(\"simd_reduce_xor\": vector_reduce_xor, false);\n+    bitwise_red!(\"simd_reduce_all\": vector_reduce_and, true);\n+    bitwise_red!(\"simd_reduce_any\": vector_reduce_or, true);\n \n     if name == \"simd_cast\" {\n         require_simd!(ret_ty, \"return\");"}, {"sha": "b87b8aa0bdb6566a792acd915002492647601744", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=07ce659dd03523b526cb4804b9ef882f31e9ecf3", "patch": "@@ -362,9 +362,12 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n         \"simd_cast\" => (2, vec![param(0)], param(1)),\n         \"simd_reduce_all\" | \"simd_reduce_any\" => (1, vec![param(0)], tcx.types.bool),\n-        \"simd_reduce_add\" | \"simd_reduce_mul\" |\n+        \"simd_reduce_add_ordered\" | \"simd_reduce_mul_ordered\"\n+            => (2, vec![param(0), param(1)], param(1)),\n+        \"simd_reduce_add_unordered\" | \"simd_reduce_mul_unordered\" |\n         \"simd_reduce_and\" | \"simd_reduce_or\"  | \"simd_reduce_xor\" |\n-        \"simd_reduce_min\" | \"simd_reduce_max\"\n+        \"simd_reduce_min\" | \"simd_reduce_max\" |\n+        \"simd_reduce_min_nanless\" | \"simd_reduce_max_nanless\"\n             => (2, vec![param(0)], param(1)),\n         name if name.starts_with(\"simd_shuffle\") => {\n             match name[\"simd_shuffle\".len()..].parse() {"}, {"sha": "9d5f9042f1878978faa7a501742283b4835917bf", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=07ce659dd03523b526cb4804b9ef882f31e9ecf3", "patch": "@@ -1397,6 +1397,7 @@ LLVMRustModuleCost(LLVMModuleRef M) {\n }\n \n // Vector reductions:\n+#if LLVM_VERSION_GE(6, 0)\n extern \"C\" LLVMValueRef\n LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n     return wrap(unwrap(B)->CreateFAddReduce(unwrap(Acc),unwrap(Src)));\n@@ -1441,3 +1442,4 @@ extern \"C\" LLVMValueRef\n LLVMRustBuildVectorReduceFMax(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n   return wrap(unwrap(B)->CreateFPMaxReduce(unwrap(Src), NoNaN));\n }\n+#endif"}, {"sha": "6755c92961b121814312a26d7bc2b749d809434d", "filename": "src/test/run-pass/simd-intrinsic-generic-reduction.rs", "status": "modified", "additions": 65, "deletions": 39, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ce659dd03523b526cb4804b9ef882f31e9ecf3/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs?ref=07ce659dd03523b526cb4804b9ef882f31e9ecf3", "patch": "@@ -39,10 +39,14 @@ struct b8x16(\n );\n \n extern \"platform-intrinsic\" {\n-    fn simd_reduce_add<T, U>(x: T) -> U;\n-    fn simd_reduce_mul<T, U>(x: T) -> U;\n+    fn simd_reduce_add_unordered<T, U>(x: T) -> U;\n+    fn simd_reduce_mul_unordered<T, U>(x: T) -> U;\n+    fn simd_reduce_add_ordered<T, U>(x: T, acc: U) -> U;\n+    fn simd_reduce_mul_ordered<T, U>(x: T, acc: U) -> U;\n     fn simd_reduce_min<T, U>(x: T) -> U;\n     fn simd_reduce_max<T, U>(x: T) -> U;\n+    fn simd_reduce_min_nanless<T, U>(x: T) -> U;\n+    fn simd_reduce_max_nanless<T, U>(x: T) -> U;\n     fn simd_reduce_and<T, U>(x: T) -> U;\n     fn simd_reduce_or<T, U>(x: T) -> U;\n     fn simd_reduce_xor<T, U>(x: T) -> U;\n@@ -53,91 +57,113 @@ extern \"platform-intrinsic\" {\n fn main() {\n     unsafe {\n         let x = i32x4(1, -2, 3, 4);\n-        let r: i32 = simd_reduce_add(x);\n-        assert!(r == 6_i32);\n-        let r: i32 = simd_reduce_mul(x);\n-        assert!(r == -24_i32);\n+        let r: i32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 6_i32);\n+        let r: i32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, -24_i32);\n+        let r: i32 = simd_reduce_add_ordered(x, -1);\n+        assert_eq!(r, 5_i32);\n+        let r: i32 = simd_reduce_mul_ordered(x, -1);\n+        assert_eq!(r, 24_i32);\n+\n         let r: i32 = simd_reduce_min(x);\n-        assert!(r == -21_i32);\n+        assert_eq!(r, -2_i32);\n         let r: i32 = simd_reduce_max(x);\n-        assert!(r == 4_i32);\n+        assert_eq!(r, 4_i32);\n \n         let x = i32x4(-1, -1, -1, -1);\n         let r: i32 = simd_reduce_and(x);\n-        assert!(r == -1_i32);\n+        assert_eq!(r, -1_i32);\n         let r: i32 = simd_reduce_or(x);\n-        assert!(r == -1_i32);\n+        assert_eq!(r, -1_i32);\n         let r: i32 = simd_reduce_xor(x);\n-        assert!(r == 0_i32);\n+        assert_eq!(r, 0_i32);\n \n         let x = i32x4(-1, -1, 0, -1);\n         let r: i32 = simd_reduce_and(x);\n-        assert!(r == 0_i32);\n+        assert_eq!(r, 0_i32);\n         let r: i32 = simd_reduce_or(x);\n-        assert!(r == -1_i32);\n+        assert_eq!(r, -1_i32);\n         let r: i32 = simd_reduce_xor(x);\n-        assert!(r == -1_i32);\n+        assert_eq!(r, -1_i32);\n     }\n \n     unsafe {\n         let x = u32x4(1, 2, 3, 4);\n-        let r: u32 = simd_reduce_add(x);\n-        assert!(r == 10_u32);\n-        let r: u32 = simd_reduce_mul(x);\n-        assert!(r == 24_u32);\n+        let r: u32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 10_u32);\n+        let r: u32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, 24_u32);\n+        let r: u32 = simd_reduce_add_ordered(x, 1);\n+        assert_eq!(r, 11_u32);\n+        let r: u32 = simd_reduce_mul_ordered(x, 2);\n+        assert_eq!(r, 48_u32);\n+\n         let r: u32 = simd_reduce_min(x);\n-        assert!(r == 1_u32);\n+        assert_eq!(r, 1_u32);\n         let r: u32 = simd_reduce_max(x);\n-        assert!(r == 4_u32);\n+        assert_eq!(r, 4_u32);\n \n         let t = u32::max_value();\n         let x = u32x4(t, t, t, t);\n         let r: u32 = simd_reduce_and(x);\n-        assert!(r == t);\n+        assert_eq!(r, t);\n         let r: u32 = simd_reduce_or(x);\n-        assert!(r == t);\n+        assert_eq!(r, t);\n         let r: u32 = simd_reduce_xor(x);\n-        assert!(r == 0_u32);\n+        assert_eq!(r, 0_u32);\n \n         let x = u32x4(t, t, 0, t);\n         let r: u32 = simd_reduce_and(x);\n-        assert!(r == 0_u32);\n+        assert_eq!(r, 0_u32);\n         let r: u32 = simd_reduce_or(x);\n-        assert!(r == t);\n+        assert_eq!(r, t);\n         let r: u32 = simd_reduce_xor(x);\n-        assert!(r == t);\n+        assert_eq!(r, t);\n     }\n \n     unsafe {\n         let x = f32x4(1., -2., 3., 4.);\n-        let r: f32 = simd_reduce_add(x);\n-        assert!(r == 6_f32);\n-        let r: f32 = simd_reduce_mul(x);\n-        assert!(r == -24_f32);\n+        let r: f32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 6_f32);\n+        let r: f32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, -24_f32);\n+        // FIXME: only works correctly for accumulator, 0:\n+        // https://bugs.llvm.org/show_bug.cgi?id=36734\n+        let r: f32 = simd_reduce_add_ordered(x, 0.);\n+        assert_eq!(r, 6_f32);\n+        // FIXME: only works correctly for accumulator, 1:\n+        // https://bugs.llvm.org/show_bug.cgi?id=36734\n+        let r: f32 = simd_reduce_mul_ordered(x, 1.);\n+        assert_eq!(r, -24_f32);\n+\n         let r: f32 = simd_reduce_min(x);\n-        assert!(r == -2_f32);\n+        assert_eq!(r, -2_f32);\n         let r: f32 = simd_reduce_max(x);\n-        assert!(r == 4_f32);\n+        assert_eq!(r, 4_f32);\n+        let r: f32 = simd_reduce_min_nanless(x);\n+        assert_eq!(r, -2_f32);\n+        let r: f32 = simd_reduce_max_nanless(x);\n+        assert_eq!(r, 4_f32);\n     }\n \n     unsafe {\n         let x = b8x4(!0, !0, !0, !0);\n         let r: bool = simd_reduce_all(x);\n-        //let r: bool = foobar(x);\n-        assert!(r);\n+        assert_eq!(r, true);\n         let r: bool = simd_reduce_any(x);\n-        assert!(r);\n+        assert_eq!(r, true);\n \n         let x = b8x4(!0, !0, 0, !0);\n         let r: bool = simd_reduce_all(x);\n-        assert!(!r);\n+        assert_eq!(r, false);\n         let r: bool = simd_reduce_any(x);\n-        assert!(r);\n+        assert_eq!(r, true);\n \n         let x = b8x4(0, 0, 0, 0);\n         let r: bool = simd_reduce_all(x);\n-        assert!(!r);\n+        assert_eq!(r, false);\n         let r: bool = simd_reduce_any(x);\n-        assert!(!r);\n+        assert_eq!(r, false);\n     }\n }"}]}