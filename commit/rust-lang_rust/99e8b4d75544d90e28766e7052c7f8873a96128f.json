{"sha": "99e8b4d75544d90e28766e7052c7f8873a96128f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZThiNGQ3NTU0NGQ5MGUyODc2NmU3MDUyYzdmODg3M2E5NjEyOGY=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-12T13:20:18Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-19T13:14:04Z"}, "message": "[MIR] Implement extern call support", "tree": {"sha": "c248b7b0b3cfb8280d41d3766559487f2323d4fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c248b7b0b3cfb8280d41d3766559487f2323d4fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99e8b4d75544d90e28766e7052c7f8873a96128f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99e8b4d75544d90e28766e7052c7f8873a96128f", "html_url": "https://github.com/rust-lang/rust/commit/99e8b4d75544d90e28766e7052c7f8873a96128f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99e8b4d75544d90e28766e7052c7f8873a96128f/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4e317e45349eb2d3c853e96bfd24dd574b36d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4e317e45349eb2d3c853e96bfd24dd574b36d1", "html_url": "https://github.com/rust-lang/rust/commit/1f4e317e45349eb2d3c853e96bfd24dd574b36d1"}], "stats": {"total": 122, "additions": 109, "deletions": 13}, "files": [{"sha": "47370a80072675bfbde61bc5471891923979f160", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=99e8b4d75544d90e28766e7052c7f8873a96128f", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use llvm::{BasicBlockRef, ValueRef};\n+use rustc::middle::ty;\n use rustc::mir::repr as mir;\n+use syntax::abi::Abi;\n use trans::adt;\n+use trans::attributes;\n use trans::base;\n use trans::build;\n-use trans::attributes;\n use trans::common::{self, Block};\n use trans::debuginfo::DebugLoc;\n+use trans::foreign;\n use trans::type_of;\n use trans::type_::Type;\n \n@@ -57,7 +60,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // The else branch of the Switch can't be hit, so branch to an unreachable\n                 // instruction so LLVM knows that\n                 let unreachable_blk = self.unreachable_block();\n-\n                 let switch = build::Switch(bcx, discr, unreachable_blk.llbb, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n@@ -98,12 +100,24 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let debugloc = DebugLoc::None;\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let mut llargs = Vec::with_capacity(args.len() + 1);\n+                // Types of the arguments. We do not preallocate, because this vector is only\n+                // filled when `is_foreign` is `true` and foreign calls are minority of the cases.\n+                let mut arg_tys = Vec::new();\n+\n+                // Foreign-ABI functions are translated differently\n+                let is_foreign = if let ty::TyBareFn(_, ref f) = callee.ty.sty {\n+                    // We do not translate intrinsics here (they shouldn\u2019t be functions)\n+                    assert!(f.abi != Abi::RustIntrinsic && f.abi != Abi::PlatformIntrinsic);\n+                    f.abi != Abi::Rust && f.abi != Abi::RustCall\n+                } else {\n+                    false\n+                };\n \n                 // Prepare the return value destination\n                 let (ret_dest_ty, must_copy_dest) = if let Some(d) = kind.destination() {\n                     let dest = self.trans_lvalue(bcx, d);\n                     let ret_ty = dest.ty.to_ty(bcx.tcx());\n-                    if type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n+                    if !is_foreign && type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n                         llargs.push(dest.llval);\n                         (Some((dest, ret_ty)), false)\n                     } else {\n@@ -115,30 +129,35 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Process the rest of the args.\n                 for arg in args {\n-                    match self.trans_operand(bcx, arg).val {\n+                    let operand = self.trans_operand(bcx, arg);\n+                    match operand.val {\n                         Ref(llval) | Immediate(llval) => llargs.push(llval),\n                         FatPtr(b, e) => {\n                             llargs.push(b);\n                             llargs.push(e);\n                         }\n                     }\n+                    if is_foreign {\n+                        arg_tys.push(operand.ty);\n+                    }\n                 }\n \n                 // Many different ways to call a function handled here\n-                match (base::avoid_invoke(bcx), kind) {\n+                match (is_foreign, base::avoid_invoke(bcx), kind) {\n                     // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n-                    (false, &mir::CallKind::DivergingCleanup(cleanup)) => {\n+                    (false, false, &mir::CallKind::DivergingCleanup(cleanup)) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n+                        let unreachable_blk = self.unreachable_block();\n                         build::Invoke(bcx,\n                                       callee.immediate(),\n                                       &llargs[..],\n-                                      self.unreachable_block().llbb,\n+                                      unreachable_blk.llbb,\n                                       landingpad.llbb,\n                                       Some(attrs),\n                                       debugloc);\n                     },\n-                    (false, &mir::CallKind::ConvergingCleanup { ref targets, .. }) => {\n+                    (false, false, &mir::CallKind::ConvergingCleanup { ref targets, .. }) => {\n                         let cleanup = self.bcx(targets.1);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let (target, postinvoke) = if must_copy_dest {\n@@ -184,14 +203,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             build::Br(target, postinvoketarget.llbb, debugloc);\n                         }\n                     },\n-                    (_, &mir::CallKind::DivergingCleanup(_)) |\n-                    (_, &mir::CallKind::Diverging) => {\n+                    (false, _, &mir::CallKind::DivergingCleanup(_)) |\n+                    (false, _, &mir::CallKind::Diverging) => {\n                         build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n                         build::Unreachable(bcx);\n                     }\n-                    (_, k@&mir::CallKind::ConvergingCleanup { .. }) |\n-                    (_, k@&mir::CallKind::Converging { .. }) => {\n-                        // Bug #20046\n+                    (false, _, k@&mir::CallKind::ConvergingCleanup { .. }) |\n+                    (false, _, k@&mir::CallKind::Converging { .. }) => {\n+                        // FIXME: Bug #20046\n                         let target = match *k {\n                             mir::CallKind::ConvergingCleanup { targets, .. } => targets.0,\n                             mir::CallKind::Converging { target, .. } => target,\n@@ -209,6 +228,25 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                         build::Br(bcx, self.llblock(target), debugloc);\n                     }\n+                    // Foreign functions\n+                    (true, _, k) => {\n+                        let (dest, _) = ret_dest_ty\n+                            .expect(\"return destination is not set\");\n+                        bcx = foreign::trans_native_call(bcx,\n+                                                   callee.ty,\n+                                                   callee.immediate(),\n+                                                   dest.llval,\n+                                                   &llargs[..],\n+                                                   arg_tys,\n+                                                   debugloc);\n+                        match *k {\n+                            mir::CallKind::ConvergingCleanup { targets, .. } =>\n+                                build::Br(bcx, self.llblock(targets.0), debugloc),\n+                            mir::CallKind::Converging { target, .. } =>\n+                                build::Br(bcx, self.llblock(target), debugloc),\n+                            _ => ()\n+                        };\n+                    },\n                 }\n             }\n         }"}, {"sha": "320cd3dbd851a4e638f5c008da30c4de74413c46", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=99e8b4d75544d90e28766e7052c7f8873a96128f", "patch": "@@ -12,6 +12,7 @@\n \n #include <stdint.h>\n #include <assert.h>\n+#include <stdarg.h>\n \n // These functions are used in the unit tests for C ABI calls.\n \n@@ -222,3 +223,18 @@ uint64_t get_z(struct S s) {\n uint64_t get_c_many_params(void *a, void *b, void *c, void *d, struct quad f) {\n     return f.c;\n }\n+\n+// Calculates the average of `(x + y) / n` where x: i64, y: f64. There must be exactly n pairs\n+// passed as variadic arguments.\n+double rust_interesting_average(uint64_t n, ...) {\n+    va_list pairs;\n+    double sum = 0.0;\n+    int i;\n+    va_start(pairs, n);\n+    for(i = 0; i < n; i += 1) {\n+        sum += (double)va_arg(pairs, int64_t);\n+        sum += va_arg(pairs, double);\n+    }\n+    va_end(pairs);\n+    return sum / n;\n+}"}, {"sha": "8fdedb6581fab9541ec8bc91bc777909549381a9", "filename": "src/test/run-pass/mir_trans_calls.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs?ref=99e8b4d75544d90e28766e7052c7f8873a96128f", "patch": "@@ -88,6 +88,15 @@ fn test8() -> isize {\n     Two::two()\n }\n \n+extern fn simple_extern(x: u32, y: (u32, u32)) -> u32 {\n+    x + y.0 * y.1\n+}\n+\n+#[rustc_mir]\n+fn test9() -> u32 {\n+    simple_extern(41, (42, 43))\n+}\n+\n #[rustc_mir]\n fn test_closure<F>(f: &F, x: i32, y: i32) -> i32\n     where F: Fn(i32, i32) -> i32\n@@ -117,6 +126,7 @@ fn main() {\n     assert_eq!(test6(&Foo, 12367), 12367);\n     assert_eq!(test7(), 1);\n     assert_eq!(test8(), 2);\n+    assert_eq!(test9(), 41 + 42 * 43);\n \n     let closure = |x: i32, y: i32| { x + y };\n     assert_eq!(test_closure(&closure, 100, 1), 101);"}, {"sha": "ff66daace385294766986b0008a9653e36d8a017", "filename": "src/test/run-pass/mir_trans_calls_variadic.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e8b4d75544d90e28766e7052c7f8873a96128f/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs?ref=99e8b4d75544d90e28766e7052c7f8873a96128f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[link(name = \"rust_test_helpers\")]\n+extern {\n+    fn rust_interesting_average(_: i64, ...) -> f64;\n+}\n+\n+#[rustc_mir]\n+fn test(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64) -> i64 {\n+    unsafe {\n+        rust_interesting_average(6, a, a as f64,\n+                                    b, b as f64,\n+                                    c, c as f64,\n+                                    d, d as f64,\n+                                    e, e as f64,\n+                                    f, f as f64) as i64\n+    }\n+}\n+\n+fn main(){\n+    assert_eq!(test(10, 20, 30, 40, 50, 60), 70);\n+}"}]}