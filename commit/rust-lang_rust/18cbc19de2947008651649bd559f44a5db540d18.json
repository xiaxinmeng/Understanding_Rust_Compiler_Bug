{"sha": "18cbc19de2947008651649bd559f44a5db540d18", "node_id": "C_kwDOAAsO6NoAKDE4Y2JjMTlkZTI5NDcwMDg2NTE2NDliZDU1OWY0NGE1ZGI1NDBkMTg", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-06-13T13:19:18Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-06-28T20:09:29Z"}, "message": "ctfe: clarify skipping the interning walk\n\nReorganizes the previous commits to have a single exit-point to avoid doing the\npotentially costly walk. Also moves the relocations tests before the interior\nmutability test: only references are important when checking for `UnsafeCell`s\nand we're checking if there are any to decide to avoid the walk anyways.", "tree": {"sha": "5035fc426b3fb7eaab7f3412499586d1b525046b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5035fc426b3fb7eaab7f3412499586d1b525046b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18cbc19de2947008651649bd559f44a5db540d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18cbc19de2947008651649bd559f44a5db540d18", "html_url": "https://github.com/rust-lang/rust/commit/18cbc19de2947008651649bd559f44a5db540d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18cbc19de2947008651649bd559f44a5db540d18/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "266bab2ab0659d2c29666e0161238cb4c5abd763", "url": "https://api.github.com/repos/rust-lang/rust/commits/266bab2ab0659d2c29666e0161238cb4c5abd763", "html_url": "https://github.com/rust-lang/rust/commit/266bab2ab0659d2c29666e0161238cb4c5abd763"}], "stats": {"total": 41, "additions": 30, "deletions": 11}, "files": [{"sha": "b243f07edff6ad43bf61ba15482cbf04498d52c9", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/18cbc19de2947008651649bd559f44a5db540d18/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cbc19de2947008651649bd559f44a5db540d18/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=18cbc19de2947008651649bd559f44a5db540d18", "patch": "@@ -173,17 +173,41 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n         //\n         // As an optimization, however, if the allocation does not contain any pointers: we don't\n         // need to do the walk. It can be costly for big arrays for example (e.g. issue #93215).\n+        let is_walk_needed = |mplace: &MPlaceTy<'tcx>| -> InterpResult<'tcx, bool> {\n+            // ZSTs cannot contain pointers, we can avoid the interning walk.\n+            if mplace.layout.is_zst() {\n+                return Ok(false);\n+            }\n+\n+            // Now, check whether this alloc contains reference types (as relocations).\n+\n+            // FIXME(lqd): checking the size and alignment could be expensive here, only do the\n+            // following for the potentially bigger aggregates like arrays and slices.\n+            let Some((size, align)) = self.ecx.size_and_align_of_mplace(&mplace)? else {\n+                // We do the walk if we can't determine the size of the mplace: we may be dealing\n+                // with extern types here in the future.\n+                return Ok(true);\n+            };\n \n-        let Some((size, align)) = self.ecx.size_and_align_of_mplace(&mplace)? else {\n-            // We could be dealing with an extern type here in the future, so we do the regular\n+            // If there are no refs or relocations in this allocation, we can avoid the interning\n             // walk.\n-            return self.walk_aggregate(mplace, fields);\n+            if let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)?\n+                && !alloc.has_relocations() {\n+                return Ok(false);\n+            }\n+\n+            // In the general case, we do the walk.\n+            Ok(true)\n         };\n \n-        let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)? else {\n-            // ZSTs cannot contain pointers, so we can skip them.\n+        // If this allocation contains no references to intern, we avoid the potentially costly\n+        // walk.\n+        //\n+        // We can do this before the checks for interior mutability below, because only references\n+        // are relevant in that situation, and we're checking if there are any here.\n+        if !is_walk_needed(mplace)? {\n             return Ok(());\n-        };\n+        }\n \n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did()) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n@@ -198,11 +222,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             }\n         }\n \n-        if !alloc.has_relocations() {\n-            // There are no refs or relocations in this allocation, we can skip the interning walk.\n-            return Ok(());\n-        }\n-\n         self.walk_aggregate(mplace, fields)\n     }\n "}]}