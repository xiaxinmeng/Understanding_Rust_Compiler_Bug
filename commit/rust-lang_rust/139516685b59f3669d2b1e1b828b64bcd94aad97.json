{"sha": "139516685b59f3669d2b1e1b828b64bcd94aad97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOTUxNjY4NWI1OWYzNjY5ZDJiMWUxYjgyOGI2NGJjZDk0YWFkOTc=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-07T22:17:57Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-20T22:41:24Z"}, "message": "Guide: unsafe", "tree": {"sha": "3f20b30e9fc4245f224c2ed9d0664cf77c7ed849", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f20b30e9fc4245f224c2ed9d0664cf77c7ed849"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/139516685b59f3669d2b1e1b828b64bcd94aad97", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/139516685b59f3669d2b1e1b828b64bcd94aad97", "html_url": "https://github.com/rust-lang/rust/commit/139516685b59f3669d2b1e1b828b64bcd94aad97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/139516685b59f3669d2b1e1b828b64bcd94aad97/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1681f43b91e6d09469e6bddf5d99b1b8e5227911", "url": "https://api.github.com/repos/rust-lang/rust/commits/1681f43b91e6d09469e6bddf5d99b1b8e5227911", "html_url": "https://github.com/rust-lang/rust/commit/1681f43b91e6d09469e6bddf5d99b1b8e5227911"}], "stats": {"total": 200, "additions": 151, "deletions": 49}, "files": [{"sha": "2974ef018c6d3e60ad8b070cd9f31cb745960f89", "filename": "src/doc/guide.md", "status": "modified", "additions": 151, "deletions": 49, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/139516685b59f3669d2b1e1b828b64bcd94aad97/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/139516685b59f3669d2b1e1b828b64bcd94aad97/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=139516685b59f3669d2b1e1b828b64bcd94aad97", "patch": "@@ -535,7 +535,7 @@ arguments we pass to functions and macros, if you're passing more than one.\n When you just use the curly braces, Rust will attempt to display the\n value in a meaningful way by checking out its type. If you want to specify the\n format in a more detailed manner, there are a [wide number of options\n-available](/std/fmt/index.html). For now, we'll just stick to the default:\n+available](std/fmt/index.html). For now, we'll just stick to the default:\n integers aren't very complicated to print.\n \n So, we've cleared up all of the confusion around bindings, with one exception:\n@@ -3520,15 +3520,15 @@ out.\n In systems programming, pointers are an incredibly important topic. Rust has a\n very rich set of pointers, and they operate differently than in many other\n languages. They are important enough that we have a specific [Pointer\n-Guide](/guide-pointers.html) that goes into pointers in much detail. In fact,\n+Guide](guide-pointers.html) that goes into pointers in much detail. In fact,\n while you're currently reading this guide, which covers the language in broad\n overview, there are a number of other guides that put a specific topic under a\n microscope. You can find the list of guides on the [documentation index\n-page](/index.html#guides).\n+page](index.html#guides).\n \n In this section, we'll assume that you're familiar with pointers as a general\n concept. If you aren't, please read the [introduction to\n-pointers](/guide-pointers.html#an-introduction) section of the Pointer Guide,\n+pointers](guide-pointers.html#an-introduction) section of the Pointer Guide,\n and then come back here. We'll wait.\n \n Got the gist? Great. Let's talk about pointers in Rust.\n@@ -4711,75 +4711,177 @@ fail.\n \n # Macros\n \n-One of Rust's most advanced features is is system of **macro**s. While\n+One of Rust's most advanced features is its system of **macro**s. While\n functions allow you to provide abstractions over values and operations, macros\n allow you to provide abstractions over syntax. Do you wish Rust had the ability\n to do something that it can't currently do? You may be able to write a macro\n to extend Rust's capabilities.\n \n-You've already used one macro extensively: `println!`.  When we invoke\n+You've already used one macro extensively: `println!`. When we invoke\n a Rust macro, we need to use the exclamation mark (`!`). There's two reasons\n that this is true: the first is that it makes it clear when you're using a\n macro. The second is that macros allow for flexible syntax, and so Rust must\n be able to tell where a macro starts and ends. The `!(...)` helps with this.\n \n-An example of even more advanced macro usage is in Rust's `regex` crate.  This\n-implements **regular expressions* for Rust. Regular expressions provide a\n-powerful way to determine if a string matches a certain pattern, but they also\n-have their own syntax. Therefore, they're a perfect fit for Rust's macros.\n-\n-Here's an example of using a regular expression in Rust:\n+Let's talk some more about `println!`. We could have implemented `println!` as\n+a function, but it would be worse. Why? Well, what macros allow you to do\n+is write code that generates more code. So when we call `println!` like this:\n \n ```{rust}\n-#![feature(phase)]\n-#[phase(plugin)]\n-extern crate regex_macros;\n-extern crate regex;\n+let x = 5i;\n+println!(\"x is: {}\", x);\n+```\n+\n+The `println!` macro does a few things:\n+\n+1. It parses the string to find any `{}`s\n+2. It checks that the number of `{}`s matches the number of other arguments.\n+3. It generates a bunch of Rust code, taking this in mind.\n+\n+What this means is that you get type checking at compile time, because\n+Rust will generate code that takes all of the types into account. If\n+`println!` was a function, it could still do this type checking, but it\n+would happen at run time rather than compile time.\n \n+We can check this out using a special flag to `rustc`. This code, in a file\n+`print.rs`:\n+\n+```{rust}\n fn main() {\n-    let re = regex!(r\"^\\d{4}-\\d{2}-\\d{2}$\");\n-    println!(\"Does our expression match? {}\", re.is_match(\"2014-01-01\"));\n+    let x = \"Hello\";\n+    println!(\"x is: {:s}\", x);\n }\n ```\n \n-This will print \"Does our expression match? true\". Now, we won't learn\n-everything there is to know about regular expressions in this tutorial. We can\n-consult [the regex crate's documentation](/regex/index.html) for more on that\n-later. For now, here's the important parts:\n+Can have its macros expanded like this: `rustc print.rs --pretty=expanded`, will\n+give us this huge result:\n \n-```{rust}\n+```{rust,ignore}\n #![feature(phase)]\n-#[phase(plugin)]\n-extern crate regex_macros;\n-# fn main() {}\n+#![no_std]\n+#![feature(globs)]\n+#[phase(plugin, link)]\n+extern crate std = \"std\";\n+extern crate rt = \"native\";\n+use std::prelude::*;\n+fn main() {\n+    let x = \"Hello\";\n+    match (&x,) {\n+        (__arg0,) => {\n+            #[inline]\n+            #[allow(dead_code)]\n+            static __STATIC_FMTSTR: [::std::fmt::rt::Piece<'static>, ..2u] =\n+                [::std::fmt::rt::String(\"x is: \"),\n+                 ::std::fmt::rt::Argument(::std::fmt::rt::Argument{position:\n+                                                                       ::std::fmt::rt::ArgumentNext,\n+                                                                   format:\n+                                                                       ::std::fmt::rt::FormatSpec{fill:\n+                                                                                                      ' ',\n+                                                                                                  align:\n+                                                                                                      ::std::fmt::rt::AlignUnknown,\n+                                                                                                  flags:\n+                                                                                                      0u,\n+                                                                                                  precision:\n+                                                                                                      ::std::fmt::rt::CountImplied,\n+                                                                                                  width:\n+                                                                                                      ::std::fmt::rt::CountImplied,},})];\n+            let __args_vec =\n+                &[::std::fmt::argument(::std::fmt::secret_string, __arg0)];\n+            let __args =\n+                unsafe {\n+                    ::std::fmt::Arguments::new(__STATIC_FMTSTR, __args_vec)\n+                };\n+            ::std::io::stdio::println_args(&__args)\n+        }\n+    };\n+}\n ```\n \n-These attributes allow the `regex_macros` crate to actually hook in to the\n-compiler itself and extend it with the regular expression syntax. Macros\n-are serious business!\n+Intense. Here's a trimmed down version that's a bit easier to read:\n \n-Next, let's look at the actual invocation:\n-\n-```{rust}\n-# #![feature(phase)]\n-# #[phase(plugin)]\n-# extern crate regex_macros;\n-# extern crate regex;\n-# fn main() {\n-let re = regex!(r\"^\\d{4}-\\d{2}-\\d{2}$\");\n-# }\n+```{rust,ignore}\n+fn main() {\n+    let x = 5i;\n+    match (&x,) {\n+        (__arg0,) => {\n+            static __STATIC_FMTSTR:  =\n+                [String(\"x is: \"),\n+                 Argument(Argument {\n+                    position: ArgumentNext,\n+                    format: FormatSpec {\n+                        fill: ' ',\n+                        align: AlignUnknown,\n+                        flags: 0u,\n+                        precision: CountImplied,\n+                        width: CountImplied,\n+                    },\n+                },\n+               ];\n+            let __args_vec = &[argument(secret_string, __arg0)];\n+            let __args = unsafe { Arguments::new(__STATIC_FMTSTR, __args_vec) };\n+\n+            println_args(&__args)\n+        }\n+    };\n+}\n ```\n \n-The `regex!` macro allows us to define a macro. inside of the `()`s, we have a\n-`r\"\"` construct. This is a 'raw' string literal, that does no escaping of its\n-contents.  This is a Rust feature, not a macros feature. Finally, the rest of\n-the insides, which is the regular expression itself. This regular expression\n-roughly translates to \"four digits, followed by a hypen, followed by two\n-digits, followed by a hypen, followed by two digits.\"\n+Whew! This isn't too terrible. You can see that we still `let x = 5i`, \n+but then things get a little bit hairy. Three more bindings get set: a\n+static format string, an argument vector, and the aruments. We then\n+invoke the `println_args` function with the generated arguments.\n+\n+This is the code (well, the full version) that Rust actually compiles. You can\n+see all of the extra information that's here. We get all of the type safety and\n+options that it provides, but at compile time, and without needing to type all\n+of this out. This is how macros are powerful. Without them, you would need to\n+type all of this by hand to get a type checked `println`.\n \n-For more on macros, please consult [the Macros Guide](/guide-macros.html).\n-Macros are a very advanced and still slightly experimental feature, and don't\n-require a deep understanding to use. The Guide can help you if you want to\n-write your own.\n+For more on macros, please consult [the Macros Guide](guide-macros.html).\n+Macros are a very advanced and still slightly experimental feature, but don't\n+require a deep understanding to call, since they look just like functions. The\n+Guide can help you if you want to write your own.\n \n # Unsafe\n+\n+Finally, there's one more concept that you should be aware in Rust: `unsafe`.\n+There are two circumstances where Rust's safety provisions don't work well.\n+The first is when interfacing with C code, and the second is when building\n+certain kinds of abstractions.\n+\n+Rust has support for FFI, (which you can read about in the [FFI\n+Guide](guide-ffi.html)) but Rust can't guarantee that the C code will be safe,\n+like Rust's will. Therefore, Rust marks such functions with the `unsafe`\n+keyword, which indicates that the function may not behave properly.\n+\n+Second, if you'd like to create some sort of shared-memory data structure, Rust\n+won't allow it, because memory must be owned by a single owner. However, if\n+you're planning on making access to that shared memory safe, such as with a\n+mutex, _you_ know that it's safe, but Rust can't know. Writing an `unsafe`\n+block allows you to ask the compiler to trust you. In this case, the _internal_\n+implementation of the mutex is considered unsafe, but the _external_ interface\n+we present is safe. This allows it to be effectively used in normal Rust, while\n+being able to implement functionality that the compiler can't double check for\n+us.\n+\n+Doesn't an escape hatch undermine the safety of the entire system? Well, if\n+Rust code segfaults, it _must_ be because of unsafe code somewhere. By\n+annotating exactly where that is, you have a significantly smaller area to\n+search.\n+\n+We haven't even talked about any examples here, and that's because I want to\n+emphasize that you should not be writing unsafe code unless you know exactly\n+what you're doing. The vast majority of Rust developers will only interact with\n+it when doing FFI, and advanced library authors may use it to build certain\n+kinds of abstraction.\n+\n+# Conclusion\n+\n+We covered a lot of ground here. When you've mastered everything in this Guide,\n+you will have a firm grasp of basic Rust development. There's a whole lot more\n+out there, we've just covered the surface. There's tons of topics that you can\n+dig deeper into, and we've built specialized guides for many of them. To learn\n+more, dig into the [full documentation\n+index](http://doc.rust-lang.org/index.html).\n+\n+Happy hacking!"}]}