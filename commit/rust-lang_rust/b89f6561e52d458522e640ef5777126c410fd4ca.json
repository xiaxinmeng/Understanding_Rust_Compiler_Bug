{"sha": "b89f6561e52d458522e640ef5777126c410fd4ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4OWY2NTYxZTUyZDQ1ODUyMmU2NDBlZjU3NzcxMjZjNDEwZmQ0Y2E=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-09-24T22:52:17Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-09-28T17:44:45Z"}, "message": "Move things around", "tree": {"sha": "fbd890b4090039897c7984509ff6c248d182e106", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbd890b4090039897c7984509ff6c248d182e106"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b89f6561e52d458522e640ef5777126c410fd4ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl9yIQ0ACgkQtAh+UQ6Y\nsWQJyRAAjaUDGzpiwxSz0zt/pbm5cTtCBhLbjgz4FdUYziSwaxpT4zBL0lgeyvUV\n67CiJXthudLKY5hmPoB5rgHMoP59cbd0uRbwjR8kuruUj3VXOIXkGNuHVM0htti3\nnBdnVaXa1rVpXuN6nUv4s5jZaM06al0BaTH2N0uvYo3VzCj488+EcV3eOAZHoowY\n+ASe3iwmowWGfeI3vnTPKB8SHUEjl1K9hB84UT9Dsse2KJtAqdPi2MidA68KROoi\nTk0zxHtfn+rvyiYpD5/aiwZo/TDXlax3mH9RqvG3+k+92MR6SmPS97G/0sY9Tx5t\nXf8h0SB83sasP9Gfu/xFBdTlYpiYGrFc5Rev0ZF/R6RMV0hCatA8q/ZX63LXYFz6\ntfY8To6D18DjVd+p3EWVOlqzdzCLB9N9AVpmjjeZ/DmnNjNg6t3Lroxq46BsnmEC\nI9/vHIsXY5FFnixNlpVbWC/WJOQJwXQ2kVDyWaLET3qNlj5KGLYwjoHp0IzIagAF\nDPE147iZWSpsVZEqvkhjVveUnVYRIzbs2jTGzNxnHaDQSV9P3AdBSuuAv60eLTzP\nMZUdC+fUvr4n3UfRA/TGGq3oQclUN62RvpigvIed0KGIVKYe7S4GCf+be3Dcf8MG\nAc5NeobdcNc0eGY/EdGcyVJl+feHwSDHFTE+o5i66fN+ilJWKtk=\n=ruwO\n-----END PGP SIGNATURE-----", "payload": "tree fbd890b4090039897c7984509ff6c248d182e106\nparent 9fc384fcf9e8d028aec1dd11da15c702667e4205\nauthor Aaron Hill <aa1ronham@gmail.com> 1600987937 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1601315085 -0400\n\nMove things around\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b89f6561e52d458522e640ef5777126c410fd4ca", "html_url": "https://github.com/rust-lang/rust/commit/b89f6561e52d458522e640ef5777126c410fd4ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b89f6561e52d458522e640ef5777126c410fd4ca/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fc384fcf9e8d028aec1dd11da15c702667e4205", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fc384fcf9e8d028aec1dd11da15c702667e4205", "html_url": "https://github.com/rust-lang/rust/commit/9fc384fcf9e8d028aec1dd11da15c702667e4205"}], "stats": {"total": 203, "additions": 120, "deletions": 83}, "files": [{"sha": "2b360cb85a6eb68f113d5f40b5fe7e29bfd7f67b", "filename": "src/shims/backtrace.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b89f6561e52d458522e640ef5777126c410fd4ca/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89f6561e52d458522e640ef5777126c410fd4ca/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=b89f6561e52d458522e640ef5777126c410fd4ca", "patch": "@@ -0,0 +1,110 @@\n+use crate::*;\n+use helpers::check_arg_count;\n+use rustc_middle::ty::TypeAndMut;\n+use rustc_ast::ast::Mutability;\n+use rustc_span::BytePos;\n+use rustc_target::abi::Size;\n+use std::convert::TryInto as _;\n+use crate::rustc_target::abi::LayoutOf as _;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+\n+    fn handle_miri_get_backtrace(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx;\n+        let &[flags] = check_arg_count(args)?;\n+\n+        let flags = this.read_scalar(flags)?.to_u64()?;\n+        if flags != 0 {\n+            throw_unsup_format!(\"unknown `miri_get_backtrace` flags {}\", flags);\n+        }\n+\n+        let mut data = Vec::new();\n+        for frame in this.active_thread_stack().iter().rev() {\n+            data.push((frame.instance, frame.current_span().lo()));\n+        }\n+\n+        let ptrs: Vec<_> = data.into_iter().map(|(instance, pos)| {\n+            let mut fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n+            fn_ptr.offset = Size::from_bytes(pos.0);\n+            Scalar::Ptr(fn_ptr)\n+        }).collect();\n+\n+        let len = ptrs.len();\n+\n+        let ptr_ty = tcx.mk_ptr(TypeAndMut {\n+            ty: tcx.types.unit,\n+            mutbl: Mutability::Mut\n+        });\n+\n+        let array_ty = tcx.mk_array(ptr_ty, ptrs.len().try_into().unwrap());\n+\n+        // Write pointers into array\n+        let alloc = this.allocate(this.layout_of(array_ty).unwrap(), MiriMemoryKind::Rust.into());\n+        for (i, ptr) in ptrs.into_iter().enumerate() {\n+            let place = this.mplace_index(alloc, i as u64)?;\n+            this.write_immediate_to_mplace(ptr.into(), place)?;\n+        }\n+\n+        this.write_immediate(Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this), dest)?;\n+        Ok(())\n+    }\n+\n+    fn handle_miri_resolve_frame(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = this.tcx;\n+        let &[ptr, flags] = check_arg_count(args)?;\n+\n+        let flags = this.read_scalar(flags)?.to_u64()?;\n+        if flags != 0 {\n+            throw_unsup_format!(\"unknown `miri_resolve_frame` flags {}\", flags);\n+        }\n+\n+        let ptr = match this.read_scalar(ptr)?.check_init()? {\n+            Scalar::Ptr(ptr) => ptr,\n+            Scalar::Raw { .. } => throw_ub_format!(\"Expected a pointer in `rust_miri_resolve_frame`, found {:?}\", ptr)\n+        };\n+\n+        let fn_instance = if let Some(GlobalAlloc::Function(instance)) = this.tcx.get_global_alloc(ptr.alloc_id) {\n+            instance\n+        } else {\n+            throw_ub_format!(\"expected function pointer, found {:?}\", ptr);\n+        };\n+\n+        if dest.layout.layout.fields.count() != 4 {\n+            throw_ub_format!(\"Bad declaration of miri_resolve_frame - should return a struct with 4 fields\");\n+        }\n+\n+        let pos = BytePos(ptr.offset.bytes().try_into().unwrap());\n+        let name = fn_instance.to_string();\n+\n+        let lo = tcx.sess.source_map().lookup_char_pos(pos);\n+\n+        let filename = lo.file.name.to_string();\n+        let lineno: u32 = lo.line as u32;\n+        // `lo.col` is 0-based - add 1 to make it 1-based for the caller.\n+        let colno: u32 = lo.col.0 as u32 + 1;\n+\n+        let name_alloc = this.allocate_str(&name, MiriMemoryKind::Rust.into());\n+        let filename_alloc = this.allocate_str(&filename, MiriMemoryKind::Rust.into());\n+        let lineno_alloc = Scalar::from_u32(lineno);\n+        let colno_alloc = Scalar::from_u32(colno);\n+\n+        let dest = this.force_allocation_maybe_sized(dest, MemPlaceMeta::None)?.0;\n+\n+        this.write_immediate(name_alloc.to_ref(), this.mplace_field(dest, 0)?.into())?;\n+        this.write_immediate(filename_alloc.to_ref(), this.mplace_field(dest, 1)?.into())?;\n+        this.write_scalar(lineno_alloc, this.mplace_field(dest, 2)?.into())?;\n+        this.write_scalar(colno_alloc, this.mplace_field(dest, 3)?.into())?;\n+        Ok(())\n+    }\n+}"}, {"sha": "7118fbda2403a21ef6c6cc564fbe93ae944dc5dd", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b89f6561e52d458522e640ef5777126c410fd4ca/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89f6561e52d458522e640ef5777126c410fd4ca/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=b89f6561e52d458522e640ef5777126c410fd4ca", "patch": "@@ -5,13 +5,12 @@ use log::trace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir;\n use rustc_target::{abi::{Align, Size}, spec::PanicStrategy};\n-use rustc_middle::ty::{self, ParamEnv, TypeAndMut};\n-use rustc_ast::ast::Mutability;\n+use rustc_middle::ty;\n use rustc_apfloat::Float;\n use rustc_span::symbol::sym;\n-use rustc_span::BytePos;\n \n use crate::*;\n+use super::backtrace::EvalContextExt as _;\n use helpers::check_arg_count;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -216,84 +215,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Obtains a Miri backtrace. See the README for details.\n             \"miri_get_backtrace\" => {\n-                let tcx = this.tcx;\n-                let mut data = Vec::new();\n-                for frame in this.active_thread_stack().iter().rev() {\n-                    data.push((frame.instance, frame.current_span().lo()));\n-                }\n-\n-                let ptrs: Vec<_> = data.into_iter().map(|(instance, pos)| {\n-                    let mut fn_ptr = this.memory.create_fn_alloc(FnVal::Instance(instance));\n-                    fn_ptr.offset = Size::from_bytes(pos.0);\n-                    Scalar::Ptr(fn_ptr)\n-                }).collect();\n-\n-                let len = ptrs.len();\n-\n-                let ptr_ty = tcx.mk_ptr(TypeAndMut {\n-                    ty: tcx.types.unit,\n-                    mutbl: Mutability::Mut\n-                });\n-\n-                let array_ty = tcx.mk_array(ptr_ty, ptrs.len().try_into().unwrap());\n-                let array_ty_and_env = ParamEnv::empty().and(array_ty);\n-\n-                // Write pointers into array\n-                let alloc = this.allocate(tcx.layout_of(array_ty_and_env).unwrap(), MiriMemoryKind::Rust.into());\n-                for (i, ptr) in ptrs.into_iter().enumerate() {\n-                    let place = this.mplace_index(alloc, i as u64)?;\n-                    this.write_immediate_to_mplace(ptr.into(), place)?;\n-                }\n-\n-                this.write_immediate(Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this), dest)?;\n+                this.handle_miri_get_backtrace(args, dest)?;\n             }\n \n             // Resolves a Miri backtrace frame. See the README for details.\n             \"miri_resolve_frame\" => {\n-                let tcx = this.tcx;\n-                let &[ptr, flags] = check_arg_count(args)?;\n-\n-                let flags = this.read_scalar(flags)?.to_u64()?;\n-                if flags != 0 {\n-                    throw_ub_format!(\"Unknown `miri_resolve_frame` flags {}\", flags);\n-                }\n-\n-                let ptr = match this.read_scalar(ptr)?.check_init()? {\n-                    Scalar::Ptr(ptr) => ptr,\n-                    Scalar::Raw { .. } => throw_ub_format!(\"Expected a pointer in `rust_miri_resolve_frame`, found {:?}\", ptr)\n-                };\n-\n-                let fn_instance = if let Some(GlobalAlloc::Function(instance)) = this.tcx.get_global_alloc(ptr.alloc_id) {\n-                    instance\n-                } else {\n-                    throw_ub_format!(\"Expect function pointer, found {:?}\", ptr);\n-                };\n-\n-                if dest.layout.layout.fields.count() != 4 {\n-                    throw_ub_format!(\"Bad declaration of miri_resolve_frame - should return a struct with 4 fields\");\n-                }\n-\n-                let pos = BytePos(ptr.offset.bytes().try_into().unwrap());\n-                let name = fn_instance.to_string();\n-\n-                let lo = tcx.sess.source_map().lookup_char_pos(pos);\n-\n-                let filename = lo.file.name.to_string();\n-                let lineno: u32 = lo.line as u32;\n-                // `lo.col` is 0-based - add 1 to make it 1-based for the caller.\n-                let colno: u32 = lo.col.0 as u32 + 1;\n-\n-                let name_alloc = this.allocate_str(&name, MiriMemoryKind::Rust.into());\n-                let filename_alloc = this.allocate_str(&filename, MiriMemoryKind::Rust.into());\n-                let lineno_alloc = Scalar::from_u32(lineno);\n-                let colno_alloc = Scalar::from_u32(colno);\n-\n-                let dest = this.force_allocation_maybe_sized(dest, MemPlaceMeta::None)?.0;\n-\n-                this.write_immediate(name_alloc.to_ref(), this.mplace_field(dest, 0)?.into())?;\n-                this.write_immediate(filename_alloc.to_ref(), this.mplace_field(dest, 1)?.into())?;\n-                this.write_scalar(lineno_alloc, this.mplace_field(dest, 2)?.into())?;\n-                this.write_scalar(colno_alloc, this.mplace_field(dest, 3)?.into())?;\n+                this.handle_miri_resolve_frame(args, dest)?;\n             }\n \n "}, {"sha": "90dcc4d8ff1e4d35f4e737b2b42b9381b401eedb", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b89f6561e52d458522e640ef5777126c410fd4ca/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89f6561e52d458522e640ef5777126c410fd4ca/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=b89f6561e52d458522e640ef5777126c410fd4ca", "patch": "@@ -1,4 +1,4 @@\n-\n+mod backtrace;\n pub mod foreign_items;\n pub mod intrinsics;\n pub mod posix;"}, {"sha": "bccc7063af7190468c6937bbb73dc14b62cfe439", "filename": "tests/compile-fail/backtrace/bad-backtrace-decl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b89f6561e52d458522e640ef5777126c410fd4ca/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89f6561e52d458522e640ef5777126c410fd4ca/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-decl.rs?ref=b89f6561e52d458522e640ef5777126c410fd4ca", "patch": "@@ -1,10 +1,10 @@\n extern \"Rust\" {\n-    fn miri_get_backtrace() -> Box<[*mut ()]>;\n+    fn miri_get_backtrace(flags: u64) -> Box<[*mut ()]>;\n     fn miri_resolve_frame(ptr: *mut (), flags: u64);\n }\n \n fn main() {\n-    let frames = unsafe { miri_get_backtrace() };\n+    let frames = unsafe { miri_get_backtrace(0) };\n     for frame in frames.into_iter() {\n         unsafe {\n             miri_resolve_frame(*frame, 0); //~ ERROR Undefined Behavior: Bad declaration of miri_resolve_frame - should return a struct with 4 fields"}, {"sha": "4579b5d0ade89bd1830a98e6a87ab6c1b54eb63a", "filename": "tests/compile-fail/backtrace/bad-backtrace-version.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b89f6561e52d458522e640ef5777126c410fd4ca/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89f6561e52d458522e640ef5777126c410fd4ca/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbacktrace%2Fbad-backtrace-version.rs?ref=b89f6561e52d458522e640ef5777126c410fd4ca", "patch": "@@ -4,6 +4,6 @@ extern \"Rust\" {\n \n fn main() {\n     unsafe {\n-        miri_resolve_frame(0 as *mut _, 1); //~ ERROR  Undefined Behavior: Unknown `miri_resolve_frame` flags 1\n+        miri_resolve_frame(0 as *mut _, 1); //~ ERROR  unsupported operation: unknown `miri_resolve_frame` flags 1\n     }\n }"}, {"sha": "655a52c7fc7d0ca9f89c07a30a37596614ca0a61", "filename": "tests/run-pass/backtrace-api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b89f6561e52d458522e640ef5777126c410fd4ca/tests%2Frun-pass%2Fbacktrace-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b89f6561e52d458522e640ef5777126c410fd4ca/tests%2Frun-pass%2Fbacktrace-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbacktrace-api.rs?ref=b89f6561e52d458522e640ef5777126c410fd4ca", "patch": "@@ -2,7 +2,7 @@\n // normalize-stderr-test \"RUSTLIB/(.*):\\d+:\\d+ \"-> \"RUSTLIB/$1:LL:COL \"\n \n extern \"Rust\" {\n-    fn miri_get_backtrace() -> Box<[*mut ()]>;\n+    fn miri_get_backtrace(flags: u64) -> Box<[*mut ()]>;\n     fn miri_resolve_frame(ptr: *mut (), flags: u64) -> MiriFrame;\n }\n \n@@ -16,7 +16,7 @@ struct MiriFrame {\n \n fn func_a() -> Box<[*mut ()]> { func_b::<u8>() }\n fn func_b<T>() -> Box<[*mut ()]> { func_c() }\n-fn func_c() -> Box<[*mut ()]> { unsafe { miri_get_backtrace() } }\n+fn func_c() -> Box<[*mut ()]> { unsafe { miri_get_backtrace(0) } }\n \n fn main() {\n     let mut seen_main = false;"}]}