{"sha": "07e7804110c77d572012f913a341523bdbaac4dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZTc4MDQxMTBjNzdkNTcyMDEyZjkxM2EzNDE1MjNiZGJhYWM0ZGQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-12T12:26:53Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-24T10:36:31Z"}, "message": "Adjust rustc_mir::interpret to changes in `Allocation`/`Memory` methods", "tree": {"sha": "cd804d6dc91e4bd8cab4fc7186c97bb5a3c6a6b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd804d6dc91e4bd8cab4fc7186c97bb5a3c6a6b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07e7804110c77d572012f913a341523bdbaac4dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07e7804110c77d572012f913a341523bdbaac4dd", "html_url": "https://github.com/rust-lang/rust/commit/07e7804110c77d572012f913a341523bdbaac4dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07e7804110c77d572012f913a341523bdbaac4dd/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ecde5712ec5b393c7a0bb0074c957446ed9886b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ecde5712ec5b393c7a0bb0074c957446ed9886b", "html_url": "https://github.com/rust-lang/rust/commit/9ecde5712ec5b393c7a0bb0074c957446ed9886b"}], "stats": {"total": 222, "additions": 146, "deletions": 76}, "files": [{"sha": "6ef7a5a266d37812a6bca44612ba9901558ac935", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 69, "deletions": 43, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=07e7804110c77d572012f913a341523bdbaac4dd", "patch": "@@ -10,9 +10,12 @@\n \n //! The virtual memory representation of the MIR interpreter\n \n-use super::{Pointer, EvalResult, AllocId};\n+use super::{\n+    Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n+    truncate,\n+};\n \n-use ty::layout::{Size, Align};\n+use ty::layout::{self, Size, Align};\n use syntax::ast::Mutability;\n use std::iter;\n use mir;\n@@ -88,24 +91,28 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n \n /// Reading and writing\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n-    pub fn read_c_str(&self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx, &[u8]> {\n-        let alloc = self.get(ptr.alloc_id)?;\n+    pub fn read_c_str(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+    ) -> EvalResult<'tcx, &[u8]> {\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n-        match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n+        match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n                 let p1 = Size::from_bytes((size + 1) as u64);\n-                self.check_relocations(ptr, p1)?;\n+                self.check_relocations(cx, ptr, p1)?;\n                 self.check_defined(ptr, p1)?;\n-                Ok(&alloc.bytes[offset..offset + size])\n+                Ok(&self.bytes[offset..offset + size])\n             }\n             None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n \n     pub fn check_bytes(\n         &self,\n-        ptr: Scalar<M::PointerTag>,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n         size: Size,\n         allow_ptr_and_undef: bool,\n     ) -> EvalResult<'tcx> {\n@@ -115,42 +122,54 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             self.check_align(ptr, align)?;\n             return Ok(());\n         }\n-        let ptr = ptr.to_ptr()?;\n         // Check bounds, align and relocations on the edges\n-        self.get_bytes_with_undef_and_ptr(ptr, size, align)?;\n+        self.get_bytes_with_undef_and_ptr(cx, ptr, size, align)?;\n         // Check undef and ptr\n         if !allow_ptr_and_undef {\n             self.check_defined(ptr, size)?;\n-            self.check_relocations(ptr, size)?;\n+            self.check_relocations(cx, ptr, size)?;\n         }\n         Ok(())\n     }\n \n-    pub fn read_bytes(&self, ptr: Scalar<M::PointerTag>, size: Size) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1).unwrap();\n         if size.bytes() == 0 {\n             self.check_align(ptr, align)?;\n             return Ok(&[]);\n         }\n-        self.get_bytes(ptr.to_ptr()?, size, align)\n+        self.get_bytes(cx, ptr, size, align)\n     }\n \n-    pub fn write_bytes(&mut self, ptr: Scalar<M::PointerTag>, src: &[u8]) -> EvalResult<'tcx> {\n+    pub fn write_bytes(\n+        &mut self,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n+        src: &[u8],\n+    ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n         let align = Align::from_bytes(1).unwrap();\n         if src.is_empty() {\n             self.check_align(ptr, align)?;\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, Size::from_bytes(src.len() as u64), align)?;\n+        let bytes = self.get_bytes_mut(\n+            cx, ptr, Size::from_bytes(src.len() as u64), align,\n+        )?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(\n         &mut self,\n-        ptr: Scalar<M::PointerTag>,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n         val: u8,\n         count: Size\n     ) -> EvalResult<'tcx> {\n@@ -160,7 +179,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             self.check_align(ptr, align)?;\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, align)?;\n+        let bytes = self.get_bytes_mut(cx, ptr, count, align)?;\n         for b in bytes {\n             *b = val;\n         }\n@@ -170,13 +189,14 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Read a *non-ZST* scalar\n     pub fn read_scalar(\n         &self,\n-        ptr: Pointer<M::PointerTag>,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n         ptr_align: Align,\n         size: Size\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n         // get_bytes_unchecked tests alignment and relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(\n-            ptr, size, ptr_align.min(self.int_align(size))\n+            cx, ptr, size, ptr_align.min(self.int_align(cx, size))\n         )?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n@@ -186,14 +206,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading\n-        let bits = read_target_uint(self.tcx.data_layout.endian, bytes).unwrap();\n+        let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n         // See if we got a pointer\n-        if size != self.pointer_size() {\n+        if size != cx.data_layout().pointer_size {\n             // *Now* better make sure that the inside also is free of relocations.\n-            self.check_relocations(ptr, size)?;\n+            self.check_relocations(cx, ptr, size)?;\n         } else {\n-            let alloc = self.get(ptr.alloc_id)?;\n-            match alloc.relocations.get(&ptr.offset) {\n+            match self.relocations.get(&ptr.offset) {\n                 Some(&(tag, alloc_id)) => {\n                     let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits as u64), tag);\n                     return Ok(ScalarMaybeUndef::Scalar(ptr.into()))\n@@ -207,18 +226,20 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     pub fn read_ptr_sized(\n         &self,\n-        ptr: Pointer<M::PointerTag>,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n         ptr_align: Align\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n-        self.read_scalar(ptr, ptr_align, self.pointer_size())\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n+        self.read_scalar(cx, ptr, ptr_align, cx.data_layout().pointer_size)\n     }\n \n     /// Write a *non-ZST* scalar\n     pub fn write_scalar(\n         &mut self,\n-        ptr: Pointer<M::PointerTag>,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n         ptr_align: Align,\n-        val: ScalarMaybeUndef<M::PointerTag>,\n+        val: ScalarMaybeUndef<Tag>,\n         type_size: Size,\n     ) -> EvalResult<'tcx> {\n         let val = match val {\n@@ -228,7 +249,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n         let bytes = match val {\n             Scalar::Ptr(val) => {\n-                assert_eq!(type_size, self.pointer_size());\n+                assert_eq!(type_size, cx.data_layout().pointer_size);\n                 val.offset.bytes() as u128\n             }\n \n@@ -242,15 +263,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n         {\n             // get_bytes_mut checks alignment\n-            let endian = self.tcx.data_layout.endian;\n-            let dst = self.get_bytes_mut(ptr, type_size, ptr_align)?;\n+            let endian = cx.data_layout().endian;\n+            let dst = self.get_bytes_mut(cx, ptr, type_size, ptr_align)?;\n             write_target_uint(endian, dst, bytes).unwrap();\n         }\n \n         // See if we have to also write a relocation\n         match val {\n             Scalar::Ptr(val) => {\n-                self.get_mut(ptr.alloc_id)?.relocations.insert(\n+                self.relocations.insert(\n                     ptr.offset,\n                     (val.tag, val.alloc_id),\n                 );\n@@ -263,15 +284,20 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     pub fn write_ptr_sized(\n         &mut self,\n-        ptr: Pointer<M::PointerTag>,\n+        cx: &impl HasDataLayout,\n+        ptr: Pointer<Tag>,\n         ptr_align: Align,\n-        val: ScalarMaybeUndef<M::PointerTag>\n+        val: ScalarMaybeUndef<Tag>\n     ) -> EvalResult<'tcx> {\n-        let ptr_size = self.pointer_size();\n-        self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n+        let ptr_size = cx.data_layout().pointer_size;\n+        self.write_scalar(cx, ptr.into(), ptr_align, val, ptr_size)\n     }\n \n-    fn int_align(&self, size: Size) -> Align {\n+    fn int_align(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        size: Size,\n+    ) -> Align {\n         // We assume pointer-sized integers have the same alignment as pointers.\n         // We also assume signed and unsigned integers of the same size have the same alignment.\n         let ity = match size.bytes() {\n@@ -282,7 +308,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             16 => layout::I128,\n             _ => bug!(\"bad integer size: {}\", size.bytes()),\n         };\n-        ity.align(self).abi\n+        ity.align(cx).abi\n     }\n }\n \n@@ -337,7 +363,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n     #[inline]\n-    fn get_bytes_with_undef_and_ptr(\n+    pub fn get_bytes_with_undef_and_ptr(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -349,7 +375,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Just calling this already marks everything as defined and removes relocations,\n     /// so be sure to actually put data there!\n-    fn get_bytes_mut(\n+    pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -375,7 +401,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Return all relocations overlapping with the given ptr-offset pair.\n-    fn relocations(\n+    pub fn relocations(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,"}, {"sha": "3119d9ed0ffa33f286a2c11b9f0ba2326a6d8050", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=07e7804110c77d572012f913a341523bdbaac4dd", "patch": "@@ -21,7 +21,7 @@ use std::ptr;\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n-use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n+use rustc::ty::layout::{Align, TargetDataLayout, Size, HasDataLayout};\n pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n@@ -30,7 +30,7 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra, InboundsCheck,\n     EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n+    Machine, AllocMap, MayLeak, ErrorHandled,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -655,7 +655,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // (`get_bytes_with_undef_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n         let relocations = {\n-            let relocations = self.relocations(src, size)?;\n+            let relocations = self.get(src.alloc_id)?.relocations(self, src, size)?;\n             let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n             for i in 0..length {\n                 new_relocations.extend(\n@@ -671,9 +671,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_relocations\n         };\n \n+        let tcx = self.tcx.tcx;\n+\n         // This also checks alignment, and relocation edges on the src.\n-        let src_bytes = self.get_bytes_with_undef_and_ptr(src, size, src_align)?.as_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n+        let src_bytes = self.get(src.alloc_id)?\n+            .get_bytes_with_undef_and_ptr(&tcx, src, size, src_align)?\n+            .as_ptr();\n+        let dest_bytes = self.get_mut(dest.alloc_id)?\n+            .get_bytes_mut(&tcx, dest, size * length, dest_align)?\n+            .as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and"}, {"sha": "3f5f0ebed72d0f197692eb846c08ad5a77310f4e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=07e7804110c77d572012f913a341523bdbaac4dd", "patch": "@@ -278,7 +278,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let ptr = ptr.to_ptr()?;\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n-                let scalar = self.memory.read_scalar(ptr, ptr_align, mplace.layout.size)?;\n+                let scalar = self.memory\n+                    .get(ptr.alloc_id)?\n+                    .read_scalar(self, ptr, ptr_align, mplace.layout.size)?;\n                 Ok(Some(Immediate::Scalar(scalar)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n@@ -288,8 +290,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n-                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n-                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n+                let a_val = self.memory\n+                    .get(ptr.alloc_id)?\n+                    .read_scalar(self, a_ptr, ptr_align, a_size)?;\n+                let b_val = self.memory\n+                    .get(ptr.alloc_id)?\n+                    .read_scalar(self, b_ptr, ptr_align, b_size)?;\n                 Ok(Some(Immediate::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),\n@@ -345,7 +351,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n+        let ptr = mplace.ptr.to_ptr()?;\n+        let bytes = self.memory\n+            .get(ptr.alloc_id)?\n+            .read_bytes(self, ptr, Size::from_bytes(len as u64))?;\n         let str = ::std::str::from_utf8(bytes)\n             .map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n         Ok(str)"}, {"sha": "e2b6c00ba382c4c22863f3eefc3cdebe57b154d1", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=07e7804110c77d572012f913a341523bdbaac4dd", "patch": "@@ -718,6 +718,7 @@ where\n         }\n \n         let ptr = ptr.to_ptr()?;\n+        let tcx = &*self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n@@ -729,8 +730,8 @@ where\n                             dest.layout)\n                 }\n \n-                self.memory.write_scalar(\n-                    ptr, ptr_align.min(dest.layout.align.abi), scalar, dest.layout.size\n+                self.memory.get_mut(ptr.alloc_id)?.write_scalar(\n+                    tcx, ptr, ptr_align.min(dest.layout.align.abi), scalar, dest.layout.size\n                 )\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n@@ -742,14 +743,18 @@ where\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let (a_align, b_align) = (a.align(self).abi, b.align(self).abi);\n                 let b_offset = a_size.align_to(b_align);\n-                let b_ptr = ptr.offset(b_offset, self)?.into();\n+                let b_ptr = ptr.offset(b_offset, self)?;\n \n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory.write_scalar(ptr, ptr_align.min(a_align), a_val, a_size)?;\n-                self.memory.write_scalar(b_ptr, ptr_align.min(b_align), b_val, b_size)\n+                self.memory\n+                    .get_mut(ptr.alloc_id)?\n+                    .write_scalar(tcx, ptr, ptr_align.min(a_align), a_val, a_size)?;\n+                self.memory\n+                    .get_mut(b_ptr.alloc_id)?\n+                    .write_scalar(tcx, b_ptr, ptr_align.min(b_align), b_val, b_size)\n             }\n         }\n     }"}, {"sha": "9e59611125d92a3f0555d6f273560e0d82728cf1", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=07e7804110c77d572012f913a341523bdbaac4dd", "patch": "@@ -404,7 +404,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let ptr_align = self.tcx.data_layout.pointer_align.abi;\n                 let ptr = self.deref_operand(args[0])?;\n                 let vtable = ptr.vtable()?;\n-                let fn_ptr = self.memory.read_ptr_sized(\n+                let fn_ptr = self.memory.get(vtable.alloc_id)?.read_ptr_sized(\n+                    self,\n                     vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n                     ptr_align\n                 )?.to_ptr()?;"}, {"sha": "8e39574c01e984905245e9b02662b32346f901f0", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=07e7804110c77d572012f913a341523bdbaac4dd", "patch": "@@ -55,23 +55,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ptr_align,\n             MemoryKind::Vtable,\n         )?.with_default_tag();\n+        let tcx = &*self.tcx;\n \n-        let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n+        let drop = ::monomorphize::resolve_drop_in_place(*tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop).with_default_tag();\n-        self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n+        self.memory\n+            .get_mut(vtable.alloc_id)?\n+            .write_ptr_sized(tcx, vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, self)?;\n-        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::from_uint(size, ptr_size).into())?;\n+        self.memory\n+            .get_mut(size_ptr.alloc_id)?\n+            .write_ptr_sized(tcx, size_ptr, ptr_align, Scalar::from_uint(size, ptr_size).into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, self)?;\n-        self.memory.write_ptr_sized(align_ptr, ptr_align,\n-            Scalar::from_uint(align, ptr_size).into())?;\n+        self.memory\n+            .get_mut(align_ptr.alloc_id)?\n+            .write_ptr_sized(tcx, align_ptr, ptr_align, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n-                self.memory.write_ptr_sized(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n+                self.memory\n+                    .get_mut(method_ptr.alloc_id)?\n+                    .write_ptr_sized(tcx, method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n             }\n         }\n \n@@ -88,7 +96,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     ) -> EvalResult<'tcx, (ty::Instance<'tcx>, ty::Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align.abi;\n-        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.to_ptr()?;\n+        let drop_fn = self.memory\n+            .get(vtable.alloc_id)?\n+            .read_ptr_sized(self, vtable, pointer_align)?\n+            .to_ptr()?;\n         let drop_instance = self.memory.get_fn(drop_fn)?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n@@ -104,9 +115,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align.abi;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n+        let alloc = self.memory.get(vtable.alloc_id)?;\n+        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?, pointer_align)?\n             .to_bits(pointer_size)? as u64;\n-        let align = self.memory.read_ptr_sized(\n+        let align = alloc.read_ptr_sized(\n+            self,\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n         )?.to_bits(pointer_size)? as u64;"}, {"sha": "b3a82cd70232aa35db9b3ef1068980fbbdf48b8d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e7804110c77d572012f913a341523bdbaac4dd/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=07e7804110c77d572012f913a341523bdbaac4dd", "patch": "@@ -21,7 +21,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    OpTy, MPlaceTy, Machine, EvalContext, ValueVisitor\n+    OpTy, MPlaceTy, Machine, EvalContext, ValueVisitor, Operand,\n };\n \n macro_rules! validation_failure {\n@@ -396,7 +396,9 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         // Maintain the invariant that the place we are checking is\n                         // already verified to be in-bounds.\n                         try_validation!(\n-                            self.ecx.memory.check_bounds(ptr, size, InboundsCheck::Live),\n+                            self.ecx.memory\n+                                .get(ptr.alloc_id)?\n+                                .check_bounds(self.ecx, ptr, size),\n                             \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination\n@@ -520,12 +522,14 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     _ => false,\n                 }\n             } => {\n-                let mplace = if op.layout.is_zst() {\n+                let mplace = match *op {\n                     // it's a ZST, the memory content cannot matter\n-                    MPlaceTy::dangling(op.layout, self.ecx)\n-                } else {\n-                    // non-ZST array/slice/str cannot be immediate\n-                    op.to_mem_place()\n+                    Operand::Immediate(_) if op.layout.is_zst() =>\n+                        // invent an aligned mplace\n+                        MPlaceTy::dangling(op.layout, self.ecx),\n+                    // FIXME: what about single element arrays? They can be Scalar layout I think\n+                    Operand::Immediate(_) => bug!(\"non-ZST array/slice cannot be immediate\"),\n+                    Operand::Indirect(_) => op.to_mem_place(),\n                 };\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n@@ -534,6 +538,11 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 // This is the size in bytes of the whole array.\n                 let size = ty_size * len;\n \n+                if op.layout.is_zst() {\n+                    return self.ecx.memory.check_align(mplace.ptr, op.layout.align);\n+                }\n+                let ptr = mplace.ptr.to_ptr()?;\n+\n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n                 // In run-time mode, we accept pointers in here.  This is actually more\n@@ -543,8 +552,9 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept undef, for consistency with the type-based checks.\n-                match self.ecx.memory.check_bytes(\n-                    mplace.ptr,\n+                match self.ecx.memory.get(ptr.alloc_id)?.check_bytes(\n+                    self.ecx,\n+                    ptr,\n                     size,\n                     /*allow_ptr_and_undef*/!self.const_mode,\n                 ) {"}]}