{"sha": "05c991c4bb87a0c964c517aa8d3d7a2388b91c35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1Yzk5MWM0YmI4N2EwYzk2NGM1MTdhYThkM2Q3YTIzODhiOTFjMzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-13T16:46:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-13T16:50:19Z"}, "message": "collections: Don't recurse in hashmap robin_hood\n\nThis switches a \"tail call\" to a manual loop to get around LLVM not optimizing\nto a tail call.\n\nClose #12860", "tree": {"sha": "25cfdfa0d49e2435657daee6255193b67554d1a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25cfdfa0d49e2435657daee6255193b67554d1a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05c991c4bb87a0c964c517aa8d3d7a2388b91c35", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05c991c4bb87a0c964c517aa8d3d7a2388b91c35", "html_url": "https://github.com/rust-lang/rust/commit/05c991c4bb87a0c964c517aa8d3d7a2388b91c35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05c991c4bb87a0c964c517aa8d3d7a2388b91c35/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05975a49282355ab2d7ddfa54c23294ae271d544", "url": "https://api.github.com/repos/rust-lang/rust/commits/05975a49282355ab2d7ddfa54c23294ae271d544", "html_url": "https://github.com/rust-lang/rust/commit/05975a49282355ab2d7ddfa54c23294ae271d544"}], "stats": {"total": 130, "additions": 99, "deletions": 31}, "files": [{"sha": "d92e31efb9d6df26f7b49ac277b0e218f68e2f3f", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/05c991c4bb87a0c964c517aa8d3d7a2388b91c35/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c991c4bb87a0c964c517aa8d3d7a2388b91c35/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=05c991c4bb87a0c964c517aa8d3d7a2388b91c35", "patch": "@@ -1069,41 +1069,49 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// so we have some sort of upper bound on the number of probes to do.\n     ///\n     /// 'hash', 'k', and 'v' are the elements to robin hood into the hashtable.\n-    fn robin_hood(&mut self, index: table::FullIndex, dib_param: uint,\n-                  hash: table::SafeHash, k: K, v: V) {\n-        let (old_hash, old_key, old_val) = {\n-            let (old_hash_ref, old_key_ref, old_val_ref) = self.table.read_all_mut(&index);\n-\n-            let old_hash = replace(old_hash_ref, hash);\n-            let old_key  = replace(old_key_ref,  k);\n-            let old_val  = replace(old_val_ref,  v);\n-\n-            (old_hash, old_key, old_val)\n-        };\n-\n-        let mut probe = self.probe_next(index.raw_index());\n-\n-        for dib in range(dib_param + 1, self.table.size()) {\n-            let full_index = match self.table.peek(probe) {\n-                table::Empty(idx) => {\n-                    // Finally. A hole!\n-                    self.table.put(idx, old_hash, old_key, old_val);\n-                    return;\n-                },\n-                table::Full(idx) => idx\n+    fn robin_hood(&mut self, mut index: table::FullIndex, mut dib_param: uint,\n+                  mut hash: table::SafeHash, mut k: K, mut v: V) {\n+        'outer: loop {\n+            let (old_hash, old_key, old_val) = {\n+                let (old_hash_ref, old_key_ref, old_val_ref) =\n+                        self.table.read_all_mut(&index);\n+\n+                let old_hash = replace(old_hash_ref, hash);\n+                let old_key  = replace(old_key_ref,  k);\n+                let old_val  = replace(old_val_ref,  v);\n+\n+                (old_hash, old_key, old_val)\n             };\n \n-            let probe_dib = self.bucket_distance(&full_index);\n+            let mut probe = self.probe_next(index.raw_index());\n+\n+            for dib in range(dib_param + 1, self.table.size()) {\n+                let full_index = match self.table.peek(probe) {\n+                    table::Empty(idx) => {\n+                        // Finally. A hole!\n+                        self.table.put(idx, old_hash, old_key, old_val);\n+                        return;\n+                    },\n+                    table::Full(idx) => idx\n+                };\n+\n+                let probe_dib = self.bucket_distance(&full_index);\n+\n+                // Robin hood! Steal the spot.\n+                if probe_dib < dib {\n+                    index = full_index;\n+                    dib_param = probe_dib;\n+                    hash = old_hash;\n+                    k = old_key;\n+                    v = old_val;\n+                    continue 'outer;\n+                }\n \n-            if probe_dib < dib {\n-                // Robin hood! Steal the spot. This had better be tail call.\n-                return self.robin_hood(full_index, probe_dib, old_hash, old_key, old_val);\n+                probe = self.probe_next(probe);\n             }\n \n-            probe = self.probe_next(probe);\n+            fail!(\"HashMap fatal error: 100% load factor?\");\n         }\n-\n-        fail!(\"HashMap fatal error: 100% load factor?\");\n     }\n \n     /// Manually insert a pre-hashed key-value pair, without first checking\n@@ -1948,7 +1956,6 @@ mod test_map {\n \n #[cfg(test)]\n mod test_set {\n-    use super::HashMap;\n     use super::HashSet;\n     use std::container::Container;\n     use std::vec::ImmutableEqVector;\n@@ -2193,7 +2200,6 @@ mod test_set {\n mod bench {\n     extern crate test;\n     use self::test::BenchHarness;\n-    use std::iter;\n     use std::iter::{range_inclusive};\n \n     #[bench]"}, {"sha": "52eafaadfd427906dd6ce367ef49ade98c24429d", "filename": "src/test/run-pass/issue-12860.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/05c991c4bb87a0c964c517aa8d3d7a2388b91c35/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c991c4bb87a0c964c517aa8d3d7a2388b91c35/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=05c991c4bb87a0c964c517aa8d3d7a2388b91c35", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+\n+extern crate collections;\n+\n+use collections::HashSet;\n+\n+#[deriving(Eq, Hash)]\n+struct XYZ {\n+    x: int,\n+    y: int,\n+    z: int\n+}\n+\n+fn main() {\n+    let mut connected = HashSet::new();\n+    let mut border = HashSet::new();\n+\n+    let middle = XYZ{x: 0, y: 0, z: 0};\n+    border.insert(middle);\n+\n+    while border.len() > 0 && connected.len() < 10000 {\n+        let choice = *(border.iter().next().unwrap());\n+        border.remove(&choice);\n+        connected.insert(choice);\n+\n+        let cxp = XYZ{x: choice.x + 1, y: choice.y, z: choice.z};\n+        let cxm = XYZ{x: choice.x - 1, y: choice.y, z: choice.z};\n+        let cyp = XYZ{x: choice.x, y: choice.y + 1, z: choice.z};\n+        let cym = XYZ{x: choice.x, y: choice.y - 1, z: choice.z};\n+        let czp = XYZ{x: choice.x, y: choice.y, z: choice.z + 1};\n+        let czm = XYZ{x: choice.x, y: choice.y, z: choice.z - 1};\n+\n+        if !connected.contains(&cxp) {\n+            border.insert(cxp);\n+        }\n+        if  !connected.contains(&cxm){\n+            border.insert(cxm);\n+        }\n+        if !connected.contains(&cyp){\n+            border.insert(cyp);\n+        }\n+        if !connected.contains(&cym) {\n+            border.insert(cym);\n+        }\n+        if !connected.contains(&czp){\n+            border.insert(czp);\n+        }\n+        if !connected.contains(&czm) {\n+            border.insert(czm);\n+        }\n+    }\n+}"}]}