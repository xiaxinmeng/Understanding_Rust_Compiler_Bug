{"sha": "c4f836ad1aceb83507810d9499f56988fd24578d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZjgzNmFkMWFjZWI4MzUwNzgxMGQ5NDk5ZjU2OTg4ZmQyNDU3OGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-18T03:56:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-18T03:56:18Z"}, "message": "Auto merge of #77820 - jyn514:from-inner, r=petrochenkov\n\nAdd `Item::from_def_id_and_kind` to reduce duplication in rustdoc\n\nThis makes it harder to make typos, and also makes it much more clear what's intentionally different rather than a typo (look for `what_rustc_thinks`).\n\nFound this while working on https://github.com/rust-lang/rust/issues/76998, I really didn't want to add `const_visibility` in 20 different places.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "ed1552bf5690ad74cf86d8819d139662d85bf95e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed1552bf5690ad74cf86d8819d139662d85bf95e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4f836ad1aceb83507810d9499f56988fd24578d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f836ad1aceb83507810d9499f56988fd24578d", "html_url": "https://github.com/rust-lang/rust/commit/c4f836ad1aceb83507810d9499f56988fd24578d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4f836ad1aceb83507810d9499f56988fd24578d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87776d7d5322422e5239e153e793b687f7f9c379", "url": "https://api.github.com/repos/rust-lang/rust/commits/87776d7d5322422e5239e153e793b687f7f9c379", "html_url": "https://github.com/rust-lang/rust/commit/87776d7d5322422e5239e153e793b687f7f9c379"}, {"sha": "0e1a302f599ea1714f1ffa1a34dfb71ce2682c4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e1a302f599ea1714f1ffa1a34dfb71ce2682c4c", "html_url": "https://github.com/rust-lang/rust/commit/0e1a302f599ea1714f1ffa1a34dfb71ce2682c4c"}], "stats": {"total": 720, "additions": 274, "deletions": 446}, "files": [{"sha": "37ec3d3d1cab923b4d57aff61ffb318562131e61", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -806,25 +806,34 @@ impl<'hir> Map<'hir> {\n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n-        let attrs = match self.find_entry(id).map(|entry| entry.node) {\n-            Some(Node::Param(a)) => Some(&a.attrs[..]),\n-            Some(Node::Local(l)) => Some(&l.attrs[..]),\n-            Some(Node::Item(i)) => Some(&i.attrs[..]),\n-            Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n-            Some(Node::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n-            Some(Node::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n-            Some(Node::Variant(ref v)) => Some(&v.attrs[..]),\n-            Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n-            Some(Node::Expr(ref e)) => Some(&*e.attrs),\n-            Some(Node::Stmt(ref s)) => Some(s.kind.attrs(|id| self.item(id.id))),\n-            Some(Node::Arm(ref a)) => Some(&*a.attrs),\n-            Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n+        let attrs = self.find_entry(id).map(|entry| match entry.node {\n+            Node::Param(a) => &a.attrs[..],\n+            Node::Local(l) => &l.attrs[..],\n+            Node::Item(i) => &i.attrs[..],\n+            Node::ForeignItem(fi) => &fi.attrs[..],\n+            Node::TraitItem(ref ti) => &ti.attrs[..],\n+            Node::ImplItem(ref ii) => &ii.attrs[..],\n+            Node::Variant(ref v) => &v.attrs[..],\n+            Node::Field(ref f) => &f.attrs[..],\n+            Node::Expr(ref e) => &*e.attrs,\n+            Node::Stmt(ref s) => s.kind.attrs(|id| self.item(id.id)),\n+            Node::Arm(ref a) => &*a.attrs,\n+            Node::GenericParam(param) => &param.attrs[..],\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n-            Some(Node::Ctor(..)) => return self.attrs(self.get_parent_item(id)),\n-            Some(Node::Crate(item)) => Some(&item.attrs[..]),\n-            _ => None,\n-        };\n+            Node::Ctor(..) => self.attrs(self.get_parent_item(id)),\n+            Node::Crate(item) => &item.attrs[..],\n+            Node::MacroDef(def) => def.attrs,\n+            Node::AnonConst(..)\n+            | Node::PathSegment(..)\n+            | Node::Ty(..)\n+            | Node::Pat(..)\n+            | Node::Binding(..)\n+            | Node::TraitRef(..)\n+            | Node::Block(..)\n+            | Node::Lifetime(..)\n+            | Node::Visibility(..) => &[],\n+        });\n         attrs.unwrap_or(&[])\n     }\n "}, {"sha": "cc3e8707e52768fcbf981d0a07509d963d378274", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -124,16 +124,8 @@ crate fn try_inline(\n     let attrs = merge_attrs(cx, Some(parent_module), target_attrs, attrs_clone);\n \n     cx.renderinfo.borrow_mut().inlined.insert(did);\n-    ret.push(clean::Item {\n-        source: cx.tcx.def_span(did).clean(cx),\n-        name: Some(name.clean(cx)),\n-        attrs,\n-        kind,\n-        visibility: clean::Public,\n-        stability: cx.tcx.lookup_stability(did).cloned(),\n-        deprecation: cx.tcx.lookup_deprecation(did).clean(cx),\n-        def_id: did,\n-    });\n+    let what_rustc_thinks = clean::Item::from_def_id_and_parts(did, Some(name), kind, cx);\n+    ret.push(clean::Item { attrs, ..what_rustc_thinks });\n     Some(ret)\n }\n \n@@ -443,8 +435,10 @@ crate fn build_impl(\n \n     debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n \n-    ret.push(clean::Item {\n-        kind: clean::ImplItem(clean::Impl {\n+    ret.push(clean::Item::from_def_id_and_parts(\n+        did,\n+        None,\n+        clean::ImplItem(clean::Impl {\n             unsafety: hir::Unsafety::Normal,\n             generics,\n             provided_trait_methods: provided,\n@@ -455,14 +449,8 @@ crate fn build_impl(\n             synthetic: false,\n             blanket_impl: None,\n         }),\n-        source: tcx.def_span(did).clean(cx),\n-        name: None,\n-        attrs,\n-        visibility: clean::Inherited,\n-        stability: tcx.lookup_stability(did).cloned(),\n-        deprecation: tcx.lookup_deprecation(did).clean(cx),\n-        def_id: did,\n-    });\n+        cx,\n+    ));\n }\n \n fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {"}, {"sha": "9d84089eb405c46633a543e8458c463ee0ee2416", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 144, "deletions": 241, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -223,12 +223,6 @@ impl Clean<ExternalCrate> for CrateNum {\n \n impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let name = if self.name.is_some() {\n-            self.name.expect(\"No name provided\").clean(cx)\n-        } else {\n-            String::new()\n-        };\n-\n         // maintain a stack of mod ids, for doc comment path resolution\n         // but we also need to resolve the module's own docs based on whether its docs were written\n         // inside or outside the module, so check for that\n@@ -268,15 +262,17 @@ impl Clean<Item> for doctree::Module<'_> {\n             }\n         };\n \n+        let what_rustc_thinks = Item::from_hir_id_and_parts(\n+            self.id,\n+            self.name,\n+            ModuleItem(Module { is_crate: self.is_crate, items }),\n+            cx,\n+        );\n         Item {\n-            name: Some(name),\n+            name: Some(what_rustc_thinks.name.unwrap_or_default()),\n             attrs,\n             source: span.clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            kind: ModuleItem(Module { is_crate: self.is_crate, items }),\n+            ..what_rustc_thinks\n         }\n     }\n }\n@@ -897,31 +893,26 @@ impl Clean<Item> for doctree::Function<'_> {\n         let (generics, decl) =\n             enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n \n-        let did = cx.tcx.hir().local_def_id(self.id);\n-        let constness = if is_const_fn(cx.tcx, did.to_def_id())\n-            && !is_unstable_const_fn(cx.tcx, did.to_def_id()).is_some()\n+        let did = cx.tcx.hir().local_def_id(self.id).to_def_id();\n+        let constness = if is_const_fn(cx.tcx, did) && !is_unstable_const_fn(cx.tcx, did).is_some()\n         {\n             hir::Constness::Const\n         } else {\n             hir::Constness::NotConst\n         };\n         let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: did.to_def_id(),\n-            kind: FunctionItem(Function {\n+        Item::from_def_id_and_parts(\n+            did,\n+            Some(self.name),\n+            FunctionItem(Function {\n                 decl,\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n                 all_types,\n                 ret_types,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -1013,42 +1004,33 @@ impl Clean<Item> for doctree::Trait<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs,\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: TraitItem(Trait {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            TraitItem(Trait {\n                 unsafety: self.unsafety,\n                 items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n                 is_spotlight,\n                 is_auto: self.is_auto.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::TraitAlias<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let attrs = self.attrs.clean(cx);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs,\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: TraitAliasItem(TraitAlias {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            TraitAliasItem(TraitAlias {\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -1098,15 +1080,15 @@ impl Clean<TypeKind> for hir::def::DefKind {\n \n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let kind = match self.kind {\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n+        let inner = match self.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 let mut m = (sig, &self.generics, body).clean(cx);\n                 if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n+                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                 {\n                     m.header.constness = hir::Constness::NotConst;\n                 }\n@@ -1119,7 +1101,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 let mut t = Function { header: sig.header, decl, generics, all_types, ret_types };\n                 if t.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n+                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                 {\n                     t.header.constness = hir::Constness::NotConst;\n                 }\n@@ -1129,30 +1111,21 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                 AssocTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n-        Item {\n-            name: Some(self.ident.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: local_did.to_def_id(),\n-            visibility: Visibility::Inherited,\n-            stability: get_stability(cx, local_did.to_def_id()),\n-            deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            kind,\n-        }\n+        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n     }\n }\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let kind = match self.kind {\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n+        let inner = match self.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 let mut m = (sig, &self.generics, body).clean(cx);\n                 if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n+                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                 {\n                     m.header.constness = hir::Constness::NotConst;\n                 }\n@@ -1164,16 +1137,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n         };\n-        Item {\n-            name: Some(self.ident.name.clean(cx)),\n-            source: self.span.clean(cx),\n-            attrs: self.attrs.clean(cx),\n-            def_id: local_did.to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did.to_def_id()),\n-            deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            kind,\n-        }\n+        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n     }\n }\n \n@@ -1329,21 +1293,7 @@ impl Clean<Item> for ty::AssocItem {\n             }\n         };\n \n-        let visibility = match self.container {\n-            ty::ImplContainer(_) => self.vis.clean(cx),\n-            ty::TraitContainer(_) => Inherited,\n-        };\n-\n-        Item {\n-            name: Some(self.ident.name.clean(cx)),\n-            visibility,\n-            stability: get_stability(cx, self.def_id),\n-            deprecation: get_deprecation(cx, self.def_id),\n-            def_id: self.def_id,\n-            attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n-            source: cx.tcx.def_span(self.def_id).clean(cx),\n-            kind,\n-        }\n+        Item::from_def_id_and_parts(self.def_id, Some(self.ident.name), kind, cx)\n     }\n }\n \n@@ -1773,33 +1723,27 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n \n impl Clean<Item> for hir::StructField<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-\n-        Item {\n-            name: Some(self.ident.name).clean(cx),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did.to_def_id()),\n-            deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            def_id: local_did.to_def_id(),\n-            kind: StructFieldItem(self.ty.clean(cx)),\n-        }\n+        let what_rustc_thinks = Item::from_hir_id_and_parts(\n+            self.hir_id,\n+            Some(self.ident.name),\n+            StructFieldItem(self.ty.clean(cx)),\n+            cx,\n+        );\n+        // Don't show `pub` for fields on enum variants; they are always public\n+        Item { visibility: self.vis.clean(cx), ..what_rustc_thinks }\n     }\n }\n \n impl Clean<Item> for ty::FieldDef {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.ident.name).clean(cx),\n-            attrs: cx.tcx.get_attrs(self.did).clean(cx),\n-            source: cx.tcx.def_span(self.did).clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, self.did),\n-            deprecation: get_deprecation(cx, self.did),\n-            def_id: self.did,\n-            kind: StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n-        }\n+        let what_rustc_thinks = Item::from_def_id_and_parts(\n+            self.did,\n+            Some(self.ident.name),\n+            StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n+            cx,\n+        );\n+        // Don't show `pub` for fields on enum variants; they are always public\n+        Item { visibility: self.vis.clean(cx), ..what_rustc_thinks }\n     }\n }\n \n@@ -1808,59 +1752,60 @@ impl Clean<Visibility> for hir::Visibility<'_> {\n         match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n-            hir::VisibilityKind::Crate(_) => Visibility::Crate,\n+            hir::VisibilityKind::Crate(_) => {\n+                let krate = DefId::local(CRATE_DEF_INDEX);\n+                Visibility::Restricted(krate, cx.tcx.def_path(krate))\n+            }\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = path.clean(cx);\n                 let did = register_res(cx, path.res);\n-                Visibility::Restricted(did, path)\n+                Visibility::Restricted(did, cx.tcx.def_path(did))\n             }\n         }\n     }\n }\n \n impl Clean<Visibility> for ty::Visibility {\n-    fn clean(&self, _: &DocContext<'_>) -> Visibility {\n-        if *self == ty::Visibility::Public { Public } else { Inherited }\n+    fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n+        match *self {\n+            ty::Visibility::Public => Visibility::Public,\n+            ty::Visibility::Invisible => Visibility::Inherited,\n+            ty::Visibility::Restricted(module) => {\n+                Visibility::Restricted(module, cx.tcx.def_path(module))\n+            }\n+        }\n     }\n }\n \n impl Clean<Item> for doctree::Struct<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: StructItem(Struct {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            StructItem(Struct {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::Union<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: UnionItem(Union {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            UnionItem(Union {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -1876,35 +1821,29 @@ impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n \n impl Clean<Item> for doctree::Enum<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: EnumItem(Enum {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            EnumItem(Enum {\n                 variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 variants_stripped: false,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: Inherited,\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            kind: VariantItem(Variant { kind: self.def.clean(cx) }),\n-        }\n+        let what_rustc_thinks = Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            VariantItem(Variant { kind: self.def.clean(cx) }),\n+            cx,\n+        );\n+        // don't show `pub` for variants, which are always public\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n     }\n }\n \n@@ -1925,7 +1864,7 @@ impl Clean<Item> for ty::VariantDef {\n                         source: cx.tcx.def_span(field.did).clean(cx),\n                         name: Some(field.ident.name.clean(cx)),\n                         attrs: cx.tcx.get_attrs(field.did).clean(cx),\n-                        visibility: field.vis.clean(cx),\n+                        visibility: Visibility::Inherited,\n                         def_id: field.did,\n                         stability: get_stability(cx, field.did),\n                         deprecation: get_deprecation(cx, field.did),\n@@ -1934,16 +1873,14 @@ impl Clean<Item> for ty::VariantDef {\n                     .collect(),\n             }),\n         };\n-        Item {\n-            name: Some(self.ident.clean(cx)),\n-            attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n-            source: cx.tcx.def_span(self.def_id).clean(cx),\n-            visibility: Inherited,\n-            def_id: self.def_id,\n-            kind: VariantItem(Variant { kind }),\n-            stability: get_stability(cx, self.def_id),\n-            deprecation: get_deprecation(cx, self.def_id),\n-        }\n+        let what_rustc_thinks = Item::from_def_id_and_parts(\n+            self.def_id,\n+            Some(self.ident.name),\n+            VariantItem(Variant { kind }),\n+            cx,\n+        );\n+        // don't show `pub` for fields, which are always public\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n     }\n }\n \n@@ -2048,34 +1985,26 @@ impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let type_ = self.ty.clean(cx);\n         let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n-        }\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::OpaqueTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: OpaqueTyItem(OpaqueTy {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            OpaqueTyItem(OpaqueTy {\n                 bounds: self.opaque_ty.bounds.clean(cx),\n                 generics: self.opaque_ty.generics.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -2091,42 +2020,34 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n impl Clean<Item> for doctree::Static<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: StaticItem(Static {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability,\n                 expr: print_const_expr(cx, self.expr),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::Constant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let def_id = cx.tcx.hir().local_def_id(self.id);\n+        let def_id = cx.tcx.hir().local_def_id(self.id).to_def_id();\n \n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: def_id.to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: ConstantItem(Constant {\n+        Item::from_def_id_and_parts(\n+            def_id,\n+            Some(self.name),\n+            ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n                 expr: print_const_expr(cx, self.expr),\n-                value: print_evaluated_const(cx, def_id.to_def_id()),\n+                value: print_evaluated_const(cx, def_id),\n                 is_literal: is_literal_expr(cx, self.expr.hir_id),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -2355,57 +2276,39 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n         };\n \n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind,\n-        }\n+        Item::from_hir_id_and_parts(self.id, Some(self.name), kind, cx)\n     }\n }\n \n-impl Clean<Item> for doctree::Macro<'_> {\n+impl Clean<Item> for doctree::Macro {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let name = self.name.clean(cx);\n-        Item {\n-            name: Some(name.clone()),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: Public,\n-            stability: cx.stability(self.hid),\n-            deprecation: cx.deprecation(self.hid).clean(cx),\n-            def_id: self.def_id,\n-            kind: MacroItem(Macro {\n+        Item::from_def_id_and_parts(\n+            self.def_id,\n+            Some(self.name),\n+            MacroItem(Macro {\n                 source: format!(\n                     \"macro_rules! {} {{\\n{}}}\",\n-                    name,\n+                    self.name,\n                     self.matchers\n                         .iter()\n                         .map(|span| { format!(\"    {} => {{ ... }};\\n\", span.to_src(cx)) })\n                         .collect::<String>()\n                 ),\n                 imported_from: self.imported_from.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n-impl Clean<Item> for doctree::ProcMacro<'_> {\n+impl Clean<Item> for doctree::ProcMacro {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: Public,\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            kind: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n-        }\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n+            cx,\n+        )\n     }\n }\n "}, {"sha": "43b986aae1c321155e1ea5880814717db7824d34", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -112,6 +112,48 @@ impl Item {\n         self.attrs.doc_value()\n     }\n \n+    /// Convenience wrapper around [`Self::from_def_id_and_parts`] which converts\n+    /// `hir_id` to a [`DefId`]\n+    pub fn from_hir_id_and_parts(\n+        hir_id: hir::HirId,\n+        name: Option<Symbol>,\n+        kind: ItemKind,\n+        cx: &DocContext<'_>,\n+    ) -> Item {\n+        Item::from_def_id_and_parts(cx.tcx.hir().local_def_id(hir_id).to_def_id(), name, kind, cx)\n+    }\n+\n+    pub fn from_def_id_and_parts(\n+        def_id: DefId,\n+        name: Option<Symbol>,\n+        kind: ItemKind,\n+        cx: &DocContext<'_>,\n+    ) -> Item {\n+        use super::Clean;\n+\n+        debug!(\"name={:?}, def_id={:?}\", name, def_id);\n+\n+        // `span_if_local()` lies about functions and only gives the span of the function signature\n+        let source = def_id.as_local().map_or_else(\n+            || cx.tcx.def_span(def_id),\n+            |local| {\n+                let hir = cx.tcx.hir();\n+                hir.span_with_body(hir.local_def_id_to_hir_id(local))\n+            },\n+        );\n+\n+        Item {\n+            def_id,\n+            kind,\n+            name: name.clean(cx),\n+            source: source.clean(cx),\n+            attrs: cx.tcx.get_attrs(def_id).clean(cx),\n+            visibility: cx.tcx.visibility(def_id).clean(cx),\n+            stability: cx.tcx.lookup_stability(def_id).cloned(),\n+            deprecation: cx.tcx.lookup_deprecation(def_id).clean(cx),\n+        }\n+    }\n+\n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n     crate fn collapsed_doc_value(&self) -> Option<String> {\n@@ -1460,12 +1502,17 @@ impl From<hir::PrimTy> for PrimitiveType {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, Debug)]\n crate enum Visibility {\n     Public,\n     Inherited,\n-    Crate,\n-    Restricted(DefId, Path),\n+    Restricted(DefId, rustc_hir::definitions::DefPath),\n+}\n+\n+impl Visibility {\n+    crate fn is_public(&self) -> bool {\n+        matches!(self, Visibility::Public)\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "bd9262191356f5e577fda51d1c59ffa1cbe5de21", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 5, "deletions": 47, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -28,25 +28,19 @@ crate struct Module<'hir> {\n     crate statics: Vec<Static<'hir>>,\n     crate constants: Vec<Constant<'hir>>,\n     crate traits: Vec<Trait<'hir>>,\n-    crate vis: &'hir hir::Visibility<'hir>,\n     crate impls: Vec<Impl<'hir>>,\n     crate foreigns: Vec<ForeignItem<'hir>>,\n-    crate macros: Vec<Macro<'hir>>,\n-    crate proc_macros: Vec<ProcMacro<'hir>>,\n+    crate macros: Vec<Macro>,\n+    crate proc_macros: Vec<ProcMacro>,\n     crate trait_aliases: Vec<TraitAlias<'hir>>,\n     crate is_crate: bool,\n }\n \n impl Module<'hir> {\n-    crate fn new(\n-        name: Option<Symbol>,\n-        attrs: &'hir [ast::Attribute],\n-        vis: &'hir hir::Visibility<'hir>,\n-    ) -> Module<'hir> {\n+    crate fn new(name: Option<Symbol>, attrs: &'hir [ast::Attribute]) -> Module<'hir> {\n         Module {\n             name,\n             id: hir::CRATE_HIR_ID,\n-            vis,\n             where_outer: rustc_span::DUMMY_SP,\n             where_inner: rustc_span::DUMMY_SP,\n             attrs,\n@@ -83,53 +77,39 @@ crate enum StructType {\n }\n \n crate struct Struct<'hir> {\n-    crate vis: &'hir hir::Visibility<'hir>,\n     crate id: hir::HirId,\n     crate struct_type: StructType,\n     crate name: Symbol,\n     crate generics: &'hir hir::Generics<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n     crate fields: &'hir [hir::StructField<'hir>],\n-    crate span: Span,\n }\n \n crate struct Union<'hir> {\n-    crate vis: &'hir hir::Visibility<'hir>,\n     crate id: hir::HirId,\n     crate struct_type: StructType,\n     crate name: Symbol,\n     crate generics: &'hir hir::Generics<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n     crate fields: &'hir [hir::StructField<'hir>],\n-    crate span: Span,\n }\n \n crate struct Enum<'hir> {\n-    crate vis: &'hir hir::Visibility<'hir>,\n     crate variants: Vec<Variant<'hir>>,\n     crate generics: &'hir hir::Generics<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n     crate id: hir::HirId,\n-    crate span: Span,\n     crate name: Symbol,\n }\n \n crate struct Variant<'hir> {\n     crate name: Symbol,\n     crate id: hir::HirId,\n-    crate attrs: &'hir [ast::Attribute],\n     crate def: &'hir hir::VariantData<'hir>,\n-    crate span: Span,\n }\n \n crate struct Function<'hir> {\n     crate decl: &'hir hir::FnDecl<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n     crate id: hir::HirId,\n     crate name: Symbol,\n-    crate vis: &'hir hir::Visibility<'hir>,\n     crate header: hir::FnHeader,\n-    crate span: Span,\n     crate generics: &'hir hir::Generics<'hir>,\n     crate body: hir::BodyId,\n }\n@@ -139,18 +119,12 @@ crate struct Typedef<'hir> {\n     crate gen: &'hir hir::Generics<'hir>,\n     crate name: Symbol,\n     crate id: hir::HirId,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n-    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n crate struct OpaqueTy<'hir> {\n     crate opaque_ty: &'hir hir::OpaqueTy<'hir>,\n     crate name: Symbol,\n     crate id: hir::HirId,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n-    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n@@ -169,10 +143,7 @@ crate struct Constant<'hir> {\n     crate type_: &'hir hir::Ty<'hir>,\n     crate expr: hir::BodyId,\n     crate name: Symbol,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate vis: &'hir hir::Visibility<'hir>,\n     crate id: hir::HirId,\n-    crate span: Span,\n }\n \n crate struct Trait<'hir> {\n@@ -184,18 +155,13 @@ crate struct Trait<'hir> {\n     crate bounds: &'hir [hir::GenericBound<'hir>],\n     crate attrs: &'hir [ast::Attribute],\n     crate id: hir::HirId,\n-    crate span: Span,\n-    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n crate struct TraitAlias<'hir> {\n     crate name: Symbol,\n     crate generics: &'hir hir::Generics<'hir>,\n     crate bounds: &'hir [hir::GenericBound<'hir>],\n-    crate attrs: &'hir [ast::Attribute],\n     crate id: hir::HirId,\n-    crate span: Span,\n-    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n@@ -215,22 +181,16 @@ crate struct Impl<'hir> {\n }\n \n crate struct ForeignItem<'hir> {\n-    crate vis: &'hir hir::Visibility<'hir>,\n     crate id: hir::HirId,\n     crate name: Symbol,\n     crate kind: &'hir hir::ForeignItemKind<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n }\n \n // For Macro we store the DefId instead of the NodeId, since we also create\n // these imported macro_rules (which only have a DUMMY_NODE_ID).\n-crate struct Macro<'hir> {\n+crate struct Macro {\n     crate name: Symbol,\n-    crate hid: hir::HirId,\n     crate def_id: hir::def_id::DefId,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n     crate matchers: Vec<Span>,\n     crate imported_from: Option<Symbol>,\n }\n@@ -256,13 +216,11 @@ crate struct Import<'hir> {\n     crate span: Span,\n }\n \n-crate struct ProcMacro<'hir> {\n+crate struct ProcMacro {\n     crate name: Symbol,\n     crate id: hir::HirId,\n     crate kind: MacroKind,\n     crate helpers: Vec<Symbol>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n }\n \n crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {"}, {"sha": "536c2e08fdef84a7b868e8547bb31072f887f143", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -11,7 +11,7 @@ use std::fmt;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{self, PrimitiveType};\n@@ -1089,19 +1089,31 @@ impl Function<'_> {\n \n impl clean::Visibility {\n     crate fn print_with_space(&self) -> impl fmt::Display + '_ {\n+        use rustc_span::symbol::kw;\n+\n         display_fn(move |f| match *self {\n             clean::Public => f.write_str(\"pub \"),\n             clean::Inherited => Ok(()),\n-            clean::Visibility::Crate => write!(f, \"pub(crate) \"),\n+            // If this is `pub(crate)`, `path` will be empty.\n+            clean::Visibility::Restricted(did, _) if did.index == CRATE_DEF_INDEX => {\n+                write!(f, \"pub(crate) \")\n+            }\n             clean::Visibility::Restricted(did, ref path) => {\n                 f.write_str(\"pub(\")?;\n-                if path.segments.len() != 1\n-                    || (path.segments[0].name != \"self\" && path.segments[0].name != \"super\")\n+                debug!(\"path={:?}\", path);\n+                let first_name =\n+                    path.data[0].data.get_opt_name().expect(\"modules are always named\");\n+                if path.data.len() != 1 || (first_name != kw::SelfLower && first_name != kw::Super)\n                 {\n                     f.write_str(\"in \")?;\n                 }\n-                resolved_path(f, did, path, true, false)?;\n-                f.write_str(\") \")\n+                // modified from `resolved_path()` to work with `DefPathData`\n+                let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n+                for seg in &path.data[..path.data.len() - 1] {\n+                    write!(f, \"{}::\", seg.data.get_opt_name().unwrap())?;\n+                }\n+                let path = anchor(did, &last_name.as_str()).to_string();\n+                write!(f, \"{}) \", path)\n             }\n         })\n     }"}, {"sha": "eb5a61a9d202a669ad45b8639e4aa61953ac1d0e", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -50,13 +50,13 @@ impl<'a> DocFolder for Stripper<'a> {\n             }\n \n             clean::StructFieldItem(..) => {\n-                if i.visibility != clean::Public {\n+                if !i.visibility.is_public() {\n                     return StripItem(i).strip();\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.def_id.is_local() && i.visibility != clean::Public {\n+                if i.def_id.is_local() && !i.visibility.is_public() {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n@@ -163,9 +163,7 @@ crate struct ImportStripper;\n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.kind {\n-            clean::ExternCrateItem(..) | clean::ImportItem(..) if i.visibility != clean::Public => {\n-                None\n-            }\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) if !i.visibility.is_public() => None,\n             _ => self.fold_item_recur(i),\n         }\n     }"}, {"sha": "76fae11291805604cb88cc0ccd6adbd2b42ad74e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 11, "deletions": 98, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -91,16 +91,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     ) -> Struct<'tcx> {\n         debug!(\"visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n-        Struct {\n-            id: item.hir_id,\n-            struct_type,\n-            name,\n-            vis: &item.vis,\n-            attrs: &item.attrs,\n-            generics,\n-            fields: sd.fields(),\n-            span: item.span,\n-        }\n+        Struct { id: item.hir_id, struct_type, name, generics, fields: sd.fields() }\n     }\n \n     fn visit_union_data(\n@@ -112,16 +103,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     ) -> Union<'tcx> {\n         debug!(\"visiting union\");\n         let struct_type = struct_type_from_def(&*sd);\n-        Union {\n-            id: item.hir_id,\n-            struct_type,\n-            name,\n-            vis: &item.vis,\n-            attrs: &item.attrs,\n-            generics,\n-            fields: sd.fields(),\n-            span: item.span,\n-        }\n+        Union { id: item.hir_id, struct_type, name, generics, fields: sd.fields() }\n     }\n \n     fn visit_enum_def(\n@@ -137,19 +119,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             variants: def\n                 .variants\n                 .iter()\n-                .map(|v| Variant {\n-                    name: v.ident.name,\n-                    id: v.id,\n-                    attrs: &v.attrs,\n-                    def: &v.data,\n-                    span: v.span,\n-                })\n+                .map(|v| Variant { name: v.ident.name, id: v.id, def: &v.data })\n                 .collect(),\n-            vis: &it.vis,\n             generics,\n-            attrs: &it.attrs,\n             id: it.hir_id,\n-            span: it.span,\n         }\n     }\n \n@@ -202,27 +175,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                 }\n \n-                om.proc_macros.push(ProcMacro {\n-                    name,\n-                    id: item.hir_id,\n-                    kind,\n-                    helpers,\n-                    attrs: &item.attrs,\n-                    span: item.span,\n-                });\n+                om.proc_macros.push(ProcMacro { name, id: item.hir_id, kind, helpers });\n             }\n             None => {\n-                om.fns.push(Function {\n-                    id: item.hir_id,\n-                    vis: &item.vis,\n-                    attrs: &item.attrs,\n-                    decl,\n-                    name,\n-                    span: item.span,\n-                    generics,\n-                    header,\n-                    body,\n-                });\n+                om.fns.push(Function { id: item.hir_id, decl, name, generics, header, body });\n             }\n         }\n     }\n@@ -236,7 +192,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         m: &'tcx hir::Mod<'tcx>,\n         name: Option<Symbol>,\n     ) -> Module<'tcx> {\n-        let mut om = Module::new(name, attrs, vis);\n+        let mut om = Module::new(name, attrs);\n         om.where_outer = span;\n         om.where_inner = m.inner;\n         om.id = id;\n@@ -471,26 +427,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 self.visit_fn(om, item, ident.name, &sig.decl, sig.header, gen, body)\n             }\n             hir::ItemKind::TyAlias(ty, ref gen) => {\n-                let t = Typedef {\n-                    ty,\n-                    gen,\n-                    name: ident.name,\n-                    id: item.hir_id,\n-                    attrs: &item.attrs,\n-                    span: item.span,\n-                    vis: &item.vis,\n-                };\n+                let t = Typedef { ty, gen, name: ident.name, id: item.hir_id };\n                 om.typedefs.push(t);\n             }\n             hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n-                let t = OpaqueTy {\n-                    opaque_ty,\n-                    name: ident.name,\n-                    id: item.hir_id,\n-                    attrs: &item.attrs,\n-                    span: item.span,\n-                    vis: &item.vis,\n-                };\n+                let t = OpaqueTy { opaque_ty, name: ident.name, id: item.hir_id };\n                 om.opaque_tys.push(t);\n             }\n             hir::ItemKind::Static(type_, mutability, expr) => {\n@@ -510,15 +451,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if ident.name != kw::Underscore {\n-                    let s = Constant {\n-                        type_,\n-                        expr,\n-                        id: item.hir_id,\n-                        name: ident.name,\n-                        attrs: &item.attrs,\n-                        span: item.span,\n-                        vis: &item.vis,\n-                    };\n+                    let s = Constant { type_, expr, id: item.hir_id, name: ident.name };\n                     om.constants.push(s);\n                 }\n             }\n@@ -533,21 +466,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     bounds,\n                     id: item.hir_id,\n                     attrs: &item.attrs,\n-                    span: item.span,\n-                    vis: &item.vis,\n                 };\n                 om.traits.push(t);\n             }\n             hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                let t = TraitAlias {\n-                    name: ident.name,\n-                    generics,\n-                    bounds,\n-                    id: item.hir_id,\n-                    attrs: &item.attrs,\n-                    span: item.span,\n-                    vis: &item.vis,\n-                };\n+                let t = TraitAlias { name: ident.name, generics, bounds, id: item.hir_id };\n                 om.trait_aliases.push(t);\n             }\n \n@@ -602,29 +525,19 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             id: item.hir_id,\n             name: renamed.unwrap_or(item.ident).name,\n             kind: &item.kind,\n-            vis: &item.vis,\n-            attrs: &item.attrs,\n-            span: item.span,\n         });\n     }\n \n     // Convert each `exported_macro` into a doc item.\n-    fn visit_local_macro(\n-        &self,\n-        def: &'tcx hir::MacroDef<'_>,\n-        renamed: Option<Symbol>,\n-    ) -> Macro<'tcx> {\n+    fn visit_local_macro(&self, def: &'tcx hir::MacroDef<'_>, renamed: Option<Symbol>) -> Macro {\n         debug!(\"visit_local_macro: {}\", def.ident);\n         let tts = def.ast.body.inner_tokens().trees().collect::<Vec<_>>();\n         // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n         let matchers = tts.chunks(4).map(|arm| arm[0].span()).collect();\n \n         Macro {\n-            hid: def.hir_id,\n             def_id: self.cx.tcx.hir().local_def_id(def.hir_id).to_def_id(),\n-            attrs: &def.attrs,\n             name: renamed.unwrap_or(def.ident.name),\n-            span: def.span,\n             matchers,\n             imported_from: None,\n         }"}, {"sha": "13468c153132e7b602c9243b14b5e52f993db57a", "filename": "src/test/rustdoc/issue-32395.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Ftest%2Frustdoc%2Fissue-32395.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Ftest%2Frustdoc%2Fissue-32395.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-32395.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -4,10 +4,12 @@\n \n // @has variant_struct/enum.Foo.html\n // @!has - 'pub qux'\n+// @!has - 'pub(crate) qux'\n // @!has - 'pub Bar'\n extern crate variant_struct;\n \n // @has issue_32395/enum.Foo.html\n // @!has - 'pub qux'\n+// @!has - 'pub(crate) qux'\n // @!has - 'pub Bar'\n pub use variant_struct::Foo;"}, {"sha": "6720d848ac3b59e50947fa087a3a8b15a54aa475", "filename": "src/test/rustdoc/pub-restricted.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Ftest%2Frustdoc%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4f836ad1aceb83507810d9499f56988fd24578d/src%2Ftest%2Frustdoc%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fpub-restricted.rs?ref=c4f836ad1aceb83507810d9499f56988fd24578d", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n // compile-flags: --document-private-items\n \n #![feature(crate_visibility_modifier)]\n@@ -12,21 +10,21 @@ pub struct FooPublic;\n crate struct FooJustCrate;\n // @has 'foo/struct.FooPubCrate.html' '//pre' 'pub(crate) struct FooPubCrate'\n pub(crate) struct FooPubCrate;\n-// @has 'foo/struct.FooSelf.html' '//pre' 'pub(self) struct FooSelf'\n+// @has 'foo/struct.FooSelf.html' '//pre' 'pub(crate) struct FooSelf'\n pub(self) struct FooSelf;\n-// @has 'foo/struct.FooInSelf.html' '//pre' 'pub(self) struct FooInSelf'\n+// @has 'foo/struct.FooInSelf.html' '//pre' 'pub(crate) struct FooInSelf'\n pub(in self) struct FooInSelf;\n mod a {\n-    // @has 'foo/a/struct.FooSuper.html' '//pre' 'pub(super) struct FooSuper'\n+    // @has 'foo/a/struct.FooSuper.html' '//pre' 'pub(crate) struct FooSuper'\n     pub(super) struct FooSuper;\n-    // @has 'foo/a/struct.FooInSuper.html' '//pre' 'pub(super) struct FooInSuper'\n+    // @has 'foo/a/struct.FooInSuper.html' '//pre' 'pub(crate) struct FooInSuper'\n     pub(in super) struct FooInSuper;\n     // @has 'foo/a/struct.FooInA.html' '//pre' 'pub(in a) struct FooInA'\n     pub(in a) struct FooInA;\n     mod b {\n-        // @has 'foo/a/b/struct.FooInSelfSuperB.html' '//pre' 'pub(in self::super::b) struct FooInSelfSuperB'\n-        pub(in self::super::b) struct FooInSelfSuperB;\n-        // @has 'foo/a/b/struct.FooInSuperSuper.html' '//pre' 'pub(in super::super) struct FooInSuperSuper'\n+        // @has 'foo/a/b/struct.FooInSelfSuperB.html' '//pre' 'pub(in a::b) struct FooInSelfSuperB'\n+        pub(in a::b) struct FooInSelfSuperB;\n+        // @has 'foo/a/b/struct.FooInSuperSuper.html' '//pre' 'pub(crate) struct FooInSuperSuper'\n         pub(in super::super) struct FooInSuperSuper;\n         // @has 'foo/a/b/struct.FooInAB.html' '//pre' 'pub(in a::b) struct FooInAB'\n         pub(in a::b) struct FooInAB;"}]}