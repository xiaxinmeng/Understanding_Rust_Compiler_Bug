{"sha": "936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNmM5MzNmZDhiN2JiNzFiOGE3ZmQ4NDVmMjdjZjUwYjNmYTA0MDI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-16T11:44:24Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-16T11:44:24Z"}, "message": "Move emacs mode into tree", "tree": {"sha": "1156dedcad52e061fd4369b9801c38c75d82b759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1156dedcad52e061fd4369b9801c38c75d82b759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "html_url": "https://github.com/rust-lang/rust/commit/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1375b31c1c9f18b8f9348e96c9fa66ae670b1f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/1375b31c1c9f18b8f9348e96c9fa66ae670b1f13", "html_url": "https://github.com/rust-lang/rust/commit/1375b31c1c9f18b8f9348e96c9fa66ae670b1f13"}], "stats": {"total": 514, "additions": 512, "deletions": 2}, "files": [{"sha": "f85052961a05b11ac706ffecb5d5b0ab37d0cd43", "filename": "doc/tutorial/setup.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/doc%2Ftutorial%2Fsetup.md", "raw_url": "https://github.com/rust-lang/rust/raw/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/doc%2Ftutorial%2Fsetup.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsetup.md?ref=936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "patch": "@@ -47,8 +47,8 @@ detail [later on](mod.html).\n ## Editing Rust code\n \n There are Vim highlighting and indentation scrips in the Rust source\n-distribution under `src/etc/vim/`. An Emacs mode can be found at\n-[https://github.com/marijnh/rust-mode][rust-mode].\n+distribution under `src/etc/vim/`, and an emacs mode under\n+`src/etc/emacs/`.\n \n [rust-mode]: https://github.com/marijnh/rust-mode\n "}, {"sha": "c79e7a9719bdc697324d7252d91838259ff6df95", "filename": "src/etc/emacs/Makefile", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FMakefile?ref=936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "patch": "@@ -0,0 +1,14 @@\n+E=@echo\n+TEMP=temp.el\n+\n+EMACS ?= emacs\n+\n+all: $(TEMP)\n+\t$(EMACS) -batch -q -no-site-file -l ./$(TEMP) -f rustmode-compile\n+\trm -f $(TEMP)\n+$(TEMP):\n+\t$(E) '(setq load-path (cons \".\" load-path))' >> $(TEMP)\n+\t$(E) '(defun rustmode-compile () (mapcar (lambda (x) (byte-compile-file x))' >> $(TEMP)\n+\t$(E) ' (list \"cm-mode.el\" \"rust-mode.el\")))' >> $(TEMP)\n+clean:\n+\trm -f *.elc $(TEMP)"}, {"sha": "7bfeebeef6ba79eb51661874d2c50c5b1cd45e9b", "filename": "src/etc/emacs/README.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FREADME.md?ref=936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "patch": "@@ -0,0 +1,27 @@\n+rust-mode: A major emacs mode for editing Rust source code\n+==========================================================\n+\n+`rust-mode` makes editing [Rust](http://rust-lang.org) code with emacs\n+enjoyable.\n+\n+To install, check out this repository and add this to your .emacs\n+file:\n+\n+    (add-to-list 'load-path \"/path/to/rust-mode/\")\n+    (require 'rust-mode)\n+\n+Make sure you byte-compile the .el files first, or the mode will be\n+painfully slow. There is an included `Makefile` which will do it for\n+you, so in the simplest case you can just run `make` and everything\n+should Just Work.\n+\n+If for some reason that doesn't work, you can byte compile manually,\n+by pasting this in your `*scratch*` buffer, moving the cursor below\n+it, and pressing `C-j`:\n+\n+    (progn\n+      (byte-compile-file \"/path/to/rust-mode/cm-mode.el\" t)\n+      (byte-compile-file \"/path/to/rust-mode/rust-mode.el\" t))\n+\n+Rust mode will automatically be associated with .rs and .rc files. To\n+enable it explicitly, do `M-x rust-mode`."}, {"sha": "469bded047ac04ce92ebcf60466a6ec1868d175d", "filename": "src/etc/emacs/cm-mode.el", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2Fcm-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2Fcm-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Fcm-mode.el?ref=936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "patch": "@@ -0,0 +1,186 @@\n+;; Wrapper for CodeMirror-style emacs modes. Highlighting is done by\n+;; running a stateful parser (with first-class state object) over the\n+;; buffer, line by line, using the output to add 'face properties, and\n+;; storing the parser state at the end of each line. Indentation is\n+;; done based on the parser state at the start of the line.\n+\n+(eval-when-compile (require 'cl))\n+\n+;; Mode data structure\n+\n+(defun make-cm-mode (token &optional start-state copy-state\n+                           compare-state indent)\n+  (vector token\n+          (or start-state (lambda () 'null))\n+          (or copy-state 'cm-default-copy-state)\n+          (or compare-state 'eq)\n+          indent))\n+(defmacro cm-mode-token (x) `(aref ,x 0))\n+(defmacro cm-mode-start-state (x) `(aref ,x 1))\n+(defmacro cm-mode-copy-state (x) `(aref ,x 2))\n+(defmacro cm-mode-compare-state (x) `(aref ,x 3))\n+(defmacro cm-mode-indent (x) `(aref ,x 4))\n+\n+(defvar cm-cur-mode nil)\n+(defvar cm-worklist nil)\n+\n+(defun cm-default-copy-state (state)\n+  (if (consp state) (copy-sequence state) state))\n+\n+(defun cm-clear-work-items (from to)\n+  (let ((prev-cons nil)\n+        (rem cm-worklist))\n+    (while rem\n+      (let ((pos (marker-position (car rem))))\n+        (cond ((or (< pos from) (> pos to)) (setf prev-cons rem))\n+              (prev-cons (setf (cdr prev-cons) (cdr rem)))\n+              (t (setf cm-worklist (cdr rem))))\n+        (setf rem (cdr rem))))))\n+\n+(defun cm-min-worklist-item ()\n+  (let ((rest cm-worklist) (min most-positive-fixnum))\n+    (while rest\n+      (let ((pos (marker-position (car rest))))\n+        (when (< pos min) (setf min pos)))\n+      (setf rest (cdr rest)))\n+    min))\n+\n+;; Indentation\n+\n+(defun cm-indent ()\n+  (let (indent-pos)\n+    (save-excursion\n+      (beginning-of-line)\n+      (let* ((buf (current-buffer))\n+             (state (cm-preserve-state buf 'cm-state-for-point))\n+             (old-indent (current-indentation)))\n+        (back-to-indentation)\n+        (setf indent-pos (point))\n+        (let ((new-indent (funcall (cm-mode-indent cm-cur-mode) state)))\n+          (unless (= old-indent new-indent)\n+            (indent-line-to new-indent)\n+            (setf indent-pos (point))\n+            (beginning-of-line)\n+            (cm-preserve-state buf\n+             (lambda ()\n+               (cm-highlight-line state)\n+               (when (< (point) (point-max))\n+                 (put-text-property (point) (+ (point) 1) 'cm-parse-state state))))))))\n+    (when (< (point) indent-pos)\n+      (goto-char indent-pos))))\n+\n+(defun cm-backtrack-to-state ()\n+  (let ((backtracked 0)\n+        (min-indent most-positive-fixnum)\n+        min-indented)\n+    (loop\n+     (when (= (point) (point-min))\n+       (return (funcall (cm-mode-start-state cm-cur-mode))))\n+     (let ((st (get-text-property (- (point) 1) 'cm-parse-state)))\n+       (when (and st (save-excursion\n+                       (backward-char)\n+                       (beginning-of-line)\n+                       (not (looking-at \"[\t ]*$\"))))\n+         (return (funcall (cm-mode-copy-state cm-cur-mode) st))))\n+     (let ((i (current-indentation)))\n+       (when (< i min-indent)\n+         (setf min-indent i min-indented (point))))\n+     (when (> (incf backtracked) 30)\n+       (goto-char min-indented)\n+       (return (funcall (cm-mode-start-state cm-cur-mode))))\n+     (forward-line -1))))\n+\n+(defun cm-state-for-point ()\n+  (let ((pos (point))\n+        (state (cm-backtrack-to-state)))\n+    (while (< (point) pos)\n+      (cm-highlight-line state)\n+      (put-text-property (point) (+ (point) 1) 'cm-parse-state\n+                         (funcall (cm-mode-copy-state cm-cur-mode) state))\n+      (forward-char))\n+    state))\n+\n+;; Highlighting\n+\n+(defun cm-highlight-line (state)\n+  (let ((eol (point-at-eol)))\n+    (remove-text-properties (point) eol '(face))\n+    (loop\n+     (let ((p (point)))\n+       (when (= p eol) (return))\n+       (let ((style (funcall (cm-mode-token cm-cur-mode) state)))\n+         (when (= p (point)) (print (point)) (error \"Nothing consumed.\"))\n+         (when (> p eol) (error \"Parser moved past EOL\"))\n+         (when style\n+           (put-text-property p (point) 'face style)))))))\n+\n+(defun cm-find-state-before-point ()\n+  (loop\n+   (beginning-of-line)\n+   (when (= (point) 1)\n+     (return (funcall (cm-mode-start-state cm-cur-mode))))\n+   (let ((cur (get-text-property (- (point) 1) 'cm-parse-state)))\n+     (when cur (return (funcall (cm-mode-copy-state cm-cur-mode) cur))))\n+   (backward-char)))\n+\n+(defun cm-schedule-work (delay)\n+  (run-with-idle-timer delay nil 'cm-preserve-state (current-buffer) 'cm-do-some-work))\n+\n+(defun cm-preserve-state (buffer f &rest args)\n+  (with-current-buffer buffer\n+    (let ((modified (buffer-modified-p))\n+          (buffer-undo-list t)\n+          (inhibit-read-only t)\n+          (inhibit-point-motion-hooks t)\n+          (inhibit-modification-hooks t))\n+      (unwind-protect (apply f args)\n+        (unless modified\n+          (restore-buffer-modified-p nil))))))\n+\n+(defun cm-do-some-work-inner ()\n+  (let ((end-time (time-add (current-time) (list 0 0 500)))\n+        (quitting nil))\n+    (while (and (not quitting) cm-worklist)\n+      (goto-char (cm-min-worklist-item))\n+      (let ((state (cm-find-state-before-point))\n+            (startpos (point))\n+            (timer-idle-list nil))\n+        (loop\n+         (cm-highlight-line state)\n+         (when (= (point) (point-max)) (return))\n+         (let ((old (get-text-property (point) 'cm-parse-state)))\n+           (when (and old (funcall (cm-mode-compare-state cm-cur-mode) state old))\n+             (return))\n+           (put-text-property (point) (+ (point) 1) 'cm-parse-state\n+                              (funcall (cm-mode-copy-state cm-cur-mode) state)))\n+         (when (or (let ((timer-idle-list nil)) (input-pending-p))\n+                   (time-less-p end-time (current-time)))\n+           (setf quitting t) (return))\n+         (forward-char))\n+        (cm-clear-work-items startpos (point)))\n+      (when quitting\n+        (push (copy-marker (+ (point) 1)) cm-worklist)\n+        (cm-schedule-work 0.05)))))\n+\n+(defun cm-do-some-work ()\n+  (save-excursion \n+    (condition-case cnd (cm-do-some-work-inner)\n+      (error (print cnd) (error cnd)))))\n+\n+(defun cm-after-change-function (from to oldlen)\n+  (cm-preserve-state (current-buffer) 'remove-text-properties from to '(cm-parse-state))\n+  (push (copy-marker from) cm-worklist)\n+  (cm-schedule-work 0.2))\n+\n+;; Entry function\n+\n+(defun cm-mode (mode)\n+  (set (make-local-variable 'cm-cur-mode) mode)\n+  (set (make-local-variable 'cm-worklist) (list (copy-marker 1)))\n+  (when (cm-mode-indent mode)\n+    (set (make-local-variable 'indent-line-function) 'cm-indent))\n+  (add-hook 'after-change-functions 'cm-after-change-function t t)\n+  (add-hook 'after-revert-hook (lambda () (cm-after-change-function 1 (point-max) nil)) t t)\n+  (cm-schedule-work 0.05))\n+\n+(provide 'cm-mode)"}, {"sha": "e4f0ee6c62f9b2396fa423818942e8bc396d3193", "filename": "src/etc/emacs/rust-mode.el", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/936c933fd8b7bb71b8a7fd845f27cf50b3fa0402/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=936c933fd8b7bb71b8a7fd845f27cf50b3fa0402", "patch": "@@ -0,0 +1,283 @@\n+(require 'cm-mode)\n+(require 'cc-mode)\n+\n+(defun rust-electric-brace (arg)\n+  (interactive \"*P\")\n+  (self-insert-command (prefix-numeric-value arg))\n+  (when (and c-electric-flag\n+             (not (member (get-text-property (point) 'face)\n+                          '(font-lock-comment-face font-lock-string-face))))\n+    (cm-indent)))\n+\n+(defvar rust-indent-unit 4)\n+(defvar rust-syntax-table (let ((table (make-syntax-table)))\n+                            (c-populate-syntax-table table)\n+                            table))\n+\n+(add-to-list 'auto-mode-alist '(\"\\\\.rs$\" . rust-mode))\n+(add-to-list 'auto-mode-alist '(\"\\\\.rc$\" . rust-mode))\n+\n+(defun make-rust-state ()\n+  (vector 'rust-token-base\n+          (list (vector 'top (- rust-indent-unit) nil nil nil))\n+          0\n+          nil))\n+(defmacro rust-state-tokenize (x) `(aref ,x 0))\n+(defmacro rust-state-context (x) `(aref ,x 1))\n+(defmacro rust-state-indent (x) `(aref ,x 2))\n+(defmacro rust-state-last-token (x) `(aref ,x 3))\n+\n+(defmacro rust-context-type (x) `(aref ,x 0))\n+(defmacro rust-context-indent (x) `(aref ,x 1))\n+(defmacro rust-context-column (x) `(aref ,x 2))\n+(defmacro rust-context-align (x) `(aref ,x 3))\n+(defmacro rust-context-info (x) `(aref ,x 4))\n+\n+(defun rust-push-context (st type &optional align-column auto-align)\n+  (let ((ctx (vector type (rust-state-indent st) align-column\n+                     (if align-column (if auto-align t 'unset) nil) nil)))\n+    (push ctx (rust-state-context st))\n+    ctx))\n+(defun rust-pop-context (st)\n+  (let ((old (pop (rust-state-context st))))\n+    (setf (rust-state-indent st) (rust-context-indent old))\n+    old))\n+(defun rust-dup-context (st)\n+  (let* ((list (rust-state-context st))\n+         (dup (copy-sequence (car list))))\n+    (setf (rust-state-context st) (cons dup (cdr list)))\n+    dup))\n+\n+(defvar rust-operator-chars \"-+/%=<>!*&|@~^\")\n+(defvar rust-punc-chars \"()[].,{}:;\")\n+(defvar rust-value-keywords\n+  (let ((table (make-hash-table :test 'equal)))\n+    (dolist (word '(\"mod\" \"type\" \"resource\" \"fn\" \"tag\" \"iface\" \"impl\"))\n+      (puthash word 'def table))\n+    (dolist (word '(\"if\" \"else\" \"while\" \"do\" \"for\" \"break\" \"cont\" \"ret\" \"be\" \"fail\" \"const\"\n+                    \"check\" \"assert\" \"claim\" \"prove\" \"native\" \"import\" \"export\" \"let\" \"log\"\n+                    \"use\" \"pure\" \"unsafe\"))\n+      (puthash word t table))\n+    (puthash \"alt\" 'alt table)\n+    (dolist (word '(\"true\" \"false\")) (puthash word 'atom table))\n+    table))\n+;; FIXME type-context keywords\n+\n+(defvar rust-tcat nil \"Kludge for multiple returns without consing\")\n+\n+(defmacro rust-eat-re (re)\n+  `(when (looking-at ,re) (goto-char (match-end 0)) t))\n+\n+(defvar rust-char-table\n+  (let ((table (make-char-table 'syntax-table)))\n+    (macrolet ((def (range &rest body)\n+                    `(let ((--b (lambda (st) ,@body)))\n+                       ,@(mapcar (lambda (elt)\n+\t                           (if (consp elt)\n+                                       `(loop for ch from ,(car elt) to ,(cdr elt) collect\n+                                              (set-char-table-range table ch --b))\n+                                     `(set-char-table-range table ',elt --b)))\n+                                 (if (consp range) range (list range))))))\n+      (def t (forward-char) nil)\n+      (def (32 ?\\t) (skip-chars-forward \" \\t\") nil)\n+      (def ?\\\" (forward-char)\n+           (rust-push-context st 'string (current-column) t)\n+           (setf (rust-state-tokenize st) 'rust-token-string)\n+           (rust-token-string st))\n+      (def ?\\' (forward-char)\n+           (setf rust-tcat 'atom)\n+           (let ((is-escape (eq (char-after) ?\\\\))\n+                 (start (point)))\n+             (if (not (rust-eat-until-unescaped ?\\'))\n+                 'font-lock-warning-face\n+               (if (or is-escape (= (point) (+ start 2)))\n+                   'font-lock-string-face 'font-lock-warning-face))))\n+      (def ?/ (forward-char)\n+           (case (char-after)\n+             (?/ (end-of-line) 'font-lock-comment-face)\n+             (?* (forward-char)\n+                 (rust-push-context st 'comment)\n+                 (setf (rust-state-tokenize st) 'rust-token-comment)\n+                 (rust-token-comment st))\n+             (t (skip-chars-forward rust-operator-chars) (setf rust-tcat 'op) nil)))\n+      (def ?# (forward-char)\n+           (cond ((eq (char-after) ?\\[) (forward-char) (setf rust-tcat 'open-attr))\n+                 ((rust-eat-re \"[a-z_]+\") (setf rust-tcat 'macro)))\n+           'font-lock-preprocessor-face)\n+      (def ((?a . ?z) (?A . ?Z) ?_)\n+           (rust-eat-re \"[a-zA-Z_][a-zA-Z0-9_]*\")\n+           (setf rust-tcat 'ident)\n+           (if (and (eq (char-after) ?:) (eq (char-after (+ (point) 1)) ?:)\n+                    (not (eq (char-after (+ (point) 2)) ?:)))\n+               (progn (forward-char 2) 'font-lock-builtin-face)\n+             (match-string 0)))\n+      (def ((?0 . ?9))\n+           (rust-eat-re \"0x[0-9a-fA-F_]+\\\\|0b[01_]+\\\\|[0-9_]+\\\\(\\\\.[0-9_]+\\\\)?\\\\(e[+\\\\-]?[0-9_]+\\\\)?\")\n+           (setf rust-tcat 'atom)\n+           (rust-eat-re \"[iuf][0-9_]*\")\n+           'font-lock-constant-face)\n+      (def ?. (forward-char)\n+           (cond ((rust-eat-re \"[0-9]+\\\\(e[+\\\\-]?[0-9]+\\\\)?\")\n+                  (setf rust-tcat 'atom)\n+                  (rust-eat-re \"f[0-9]+\")\n+                  'font-lock-constant-face)\n+                 (t (setf rust-tcat (char-before)) nil)))\n+      (def (?\\( ?\\) ?\\[ ?\\] ?\\{ ?\\} ?: ?\\; ?,)\n+           (forward-char)\n+           (setf rust-tcat (char-before)) nil)\n+      (def ?|\n+           (skip-chars-forward rust-operator-chars)\n+           (setf rust-tcat 'pipe) nil)\n+      (def (?+ ?- ?% ?= ?< ?> ?! ?* ?& ?@ ?~)\n+           (skip-chars-forward rust-operator-chars)\n+           (setf rust-tcat 'op) nil)\n+      table)))\n+\n+(defun rust-token-base (st)\n+  (funcall (char-table-range rust-char-table (char-after)) st))\n+\n+(defun rust-eat-until-unescaped (ch)\n+  (let (escaped)\n+    (loop\n+     (let ((cur (char-after)))\n+       (when (or (eq cur ?\\n) (not cur)) (return nil))\n+       (forward-char)\n+       (when (and (eq cur ch) (not escaped)) (return t))\n+       (setf escaped (and (not escaped) (eq cur ?\\\\)))))))\n+\n+(defun rust-token-string (st)\n+  (setf rust-tcat 'atom)\n+  (cond ((rust-eat-until-unescaped ?\\\")\n+         (setf (rust-state-tokenize st) 'rust-token-base)\n+         (rust-pop-context st))\n+        (t (let ((align (eq (char-before) ?\\\\)))\n+             (unless (eq align (rust-context-align (car (rust-state-context st))))\n+               (setf (rust-context-align (rust-dup-context st)) align)))))\n+  'font-lock-string-face)\n+\n+(defun rust-token-comment (st)\n+  (let ((eol (point-at-eol)))\n+    (loop\n+     (unless (re-search-forward \"\\\\(/\\\\*\\\\)\\\\|\\\\(\\\\*/\\\\)\" eol t)\n+       (goto-char eol)\n+       (return))\n+     (if (match-beginning 1)\n+         (push (car (rust-state-context st)) (rust-state-context st))\n+       (rust-pop-context st)\n+       (unless (eq (rust-context-type (car (rust-state-context st))) 'comment)\n+         (setf (rust-state-tokenize st) 'rust-token-base)\n+         (return))))\n+    'font-lock-comment-face))\n+\n+(defun rust-next-block-info (st)\n+  (dolist (cx (rust-state-context st))\n+    (when (eq (rust-context-type cx) ?\\}) (return (rust-context-info cx)))))\n+\n+(defun rust-token (st)\n+  (let ((cx (car (rust-state-context st))))\n+    (when (bolp)\n+      (setf (rust-state-indent st) (current-indentation))\n+      (when (eq (rust-context-align cx) 'unset)\n+        (setf (rust-context-align cx) nil)))\n+    (setf rust-tcat nil)\n+    (let* ((tok (funcall (rust-state-tokenize st) st))\n+           (tok-id (or tok rust-tcat))\n+           (cur-cx (rust-context-type cx))\n+           (cx-info (rust-context-info cx)))\n+      (when (stringp tok)\n+        (setf tok-id (gethash tok rust-value-keywords nil))\n+        (setf tok (cond ((eq tok-id 'atom) 'font-lock-constant-face)\n+                        (tok-id 'font-lock-keyword-face)\n+                        ((equal (rust-state-last-token st) 'def) 'font-lock-function-name-face)\n+                        (t nil))))\n+      (when rust-tcat\n+        (when (eq (rust-context-align cx) 'unset)\n+          (setf (rust-context-align cx) t))\n+        (when (eq cx-info 'alt-1)\n+          (setf cx (rust-dup-context st))\n+          (setf (rust-context-info cx) 'alt-2))\n+        (when (and (eq rust-tcat 'pipe) (eq (rust-state-last-token st) ?{))\n+          (setf cx (rust-dup-context st))\n+          (setf (rust-context-info cx) 'block))\n+        (case rust-tcat\n+          ((?\\; ?,) (when (eq cur-cx 'statement) (rust-pop-context st)))\n+          (?\\{\n+           (when (and (eq cur-cx 'statement) (not (member cx-info '(alt-1 alt-2))))\n+             (rust-pop-context st))\n+           (when (eq cx-info 'alt-2)\n+             (setf cx (rust-dup-context st))\n+             (setf (rust-context-info cx) nil))\n+           (let ((next-info (rust-next-block-info st))\n+                 (newcx (rust-push-context st ?\\} (current-column))))\n+             (cond ((eq cx-info 'alt-2) (setf (rust-context-info newcx) 'alt-outer))\n+                   ((eq next-info 'alt-outer) (setf (rust-context-info newcx) 'alt-inner)))))\n+          ((?\\[ open-attr)\n+           (let ((newcx (rust-push-context st ?\\] (current-column))))\n+             (when (eq rust-tcat 'open-attr)\n+               (setf (rust-context-info newcx) 'attr))))\n+          (?\\( (rust-push-context st ?\\) (current-column))\n+               (when (eq (rust-context-info cx) 'attr)\n+                 (setf (rust-context-info (car (rust-state-context st))) 'attr)))\n+          (?\\} (when (eq cur-cx 'statement) (rust-pop-context st))\n+               (when (eq (rust-context-type (car (rust-state-context st))) ?})\n+                 (rust-pop-context st))\n+               (setf cx (car (rust-state-context st)))\n+               (when (and (eq (rust-context-type cx) 'statement)\n+                          (not (eq (rust-context-info cx) 'alt-2)))\n+                 (rust-pop-context st)))\n+          (t (cond ((eq cur-cx rust-tcat)\n+                    (when (eq (rust-context-info (rust-pop-context st)) 'attr)\n+                      (setf tok 'font-lock-preprocessor-face)\n+                      (when (eq (rust-context-type (car (rust-state-context st))) 'statement)\n+                        (rust-pop-context st))))\n+                   ((or (and (eq cur-cx ?\\}) (not (eq (rust-context-info cx) 'alt-outer)))\n+                        (eq cur-cx 'top))\n+                    (rust-push-context st 'statement)))))\n+        (setf (rust-state-last-token st) tok-id))\n+      (setf cx (car (rust-state-context st)))\n+      (when (and (eq tok-id 'alt) (eq (rust-context-type cx) 'statement))\n+        (setf (rust-context-info cx) 'alt-1))\n+      (when (and (eq (rust-state-last-token st) 'pipe)\n+                 (eq (rust-next-block-info st) 'block) (eolp))\n+        (when (eq (rust-context-type cx) 'statement) (rust-pop-context st))\n+        (setf cx (rust-dup-context st)\n+              (rust-context-info cx) nil\n+              (rust-context-align cx) nil))\n+      (if (eq (rust-context-info cx) 'attr)\n+          'font-lock-preprocessor-face\n+        tok))))\n+\n+(defun rust-indent (st)\n+  (let ((cx (car (rust-state-context st)))\n+        (parent (cadr (rust-state-context st))))\n+    (when (and (eq (rust-context-type cx) 'statement)\n+               (or (eq (char-after) ?\\}) (looking-at \"with \\\\|{[ \t]*$\")))\n+      (setf cx parent parent (caddr (rust-state-context st))))\n+    (let* ((tp (rust-context-type cx))\n+           (closing (eq tp (char-after)))\n+           (unit (if (member (rust-context-info cx) '(alt-inner alt-outer))\n+                     (/ rust-indent-unit 2) rust-indent-unit))\n+           (base (if (and (eq tp 'statement) parent (rust-context-align parent))\n+                     (rust-context-column parent) (rust-context-indent cx))))\n+      (cond ((eq tp 'comment) base)\n+            ((eq tp 'string) (if (rust-context-align cx) (rust-context-column cx) 0))\n+            ((eq tp 'statement) (+ base (if (eq (char-after) ?\\}) 0 unit)))\n+            ((eq (rust-context-align cx) t) (+ (rust-context-column cx) (if closing -1 0)))\n+            (t (+ base (if closing 0 unit)))))))\n+\n+(define-derived-mode rust-mode fundamental-mode \"Rust\"\n+  \"Major mode for editing Rust source files.\"\n+  (set-syntax-table rust-syntax-table)\n+  (setq major-mode 'rust-mode mode-name \"Rust\")\n+  (run-hooks 'rust-mode-hook)\n+  (set (make-local-variable 'indent-tabs-mode) nil)\n+  (let ((par \"[ \t]*\\\\(//+\\\\|\\\\**\\\\)[ \t]*$\"))\n+    (set (make-local-variable 'paragraph-start) par)\n+    (set (make-local-variable 'paragraph-separate) par))\n+  (set (make-local-variable 'comment-start) \"//\")\n+  (cm-mode (make-cm-mode 'rust-token 'make-rust-state 'copy-sequence 'equal 'rust-indent)))\n+\n+(define-key rust-mode-map \"}\" 'rust-electric-brace)\n+(define-key rust-mode-map \"{\" 'rust-electric-brace)\n+\n+(provide 'rust-mode)"}]}