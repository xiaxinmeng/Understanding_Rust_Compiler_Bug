{"sha": "00ebebb25883a5f0c0af73c17152b6bfefdc3c74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZWJlYmIyNTg4M2E1ZjBjMGFmNzNjMTcxNTJiNmJmZWZkYzNjNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-01T13:27:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-01T13:27:24Z"}, "message": "auto merge of #17654 : gereeter/rust/no-unnecessary-cell, r=alexcrichton\n\nThere is more that could be done, but this was the low hanging fruit.", "tree": {"sha": "95503d726962b75abf00190b357a01b667e79533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95503d726962b75abf00190b357a01b667e79533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00ebebb25883a5f0c0af73c17152b6bfefdc3c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00ebebb25883a5f0c0af73c17152b6bfefdc3c74", "html_url": "https://github.com/rust-lang/rust/commit/00ebebb25883a5f0c0af73c17152b6bfefdc3c74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00ebebb25883a5f0c0af73c17152b6bfefdc3c74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ab6fce95e9b8a4ed27ecb7bee69784a02610e1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab6fce95e9b8a4ed27ecb7bee69784a02610e1d", "html_url": "https://github.com/rust-lang/rust/commit/8ab6fce95e9b8a4ed27ecb7bee69784a02610e1d"}, {"sha": "25b40841a5555dafe7f68189a725b6251ce1f992", "url": "https://api.github.com/repos/rust-lang/rust/commits/25b40841a5555dafe7f68189a725b6251ce1f992", "html_url": "https://github.com/rust-lang/rust/commit/25b40841a5555dafe7f68189a725b6251ce1f992"}], "stats": {"total": 166, "additions": 70, "deletions": 96}, "files": [{"sha": "de0c36f2af33a41594b4b82fc1a8354827dd0dfb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00ebebb25883a5f0c0af73c17152b6bfefdc3c74/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebebb25883a5f0c0af73c17152b6bfefdc3c74/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=00ebebb25883a5f0c0af73c17152b6bfefdc3c74", "patch": "@@ -538,7 +538,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-    match ecx.reexports2.borrow().find(&id) {\n+    match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {"}, {"sha": "22ac390602dfee9e20e4ee008860d67f12f7e0e1", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00ebebb25883a5f0c0af73c17152b6bfefdc3c74/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebebb25883a5f0c0af73c17152b6bfefdc3c74/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=00ebebb25883a5f0c0af73c17152b6bfefdc3c74", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -347,9 +347,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n-            let exp_map2 = self.exp_map2.borrow();\n-            assert!(exp_map2.contains_key(&id), \"wut {:?}\", id);\n-            for export in exp_map2.get(&id).iter() {\n+            assert!(self.exp_map2.contains_key(&id), \"wut {:?}\", id);\n+            for export in self.exp_map2.get(&id).iter() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }"}, {"sha": "42a98be0fb84e1a93db2f5d78c88128b3bd42133", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 66, "deletions": 91, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/00ebebb25883a5f0c0af73c17152b6bfefdc3c74/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00ebebb25883a5f0c0af73c17152b6bfefdc3c74/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=00ebebb25883a5f0c0af73c17152b6bfefdc3c74", "patch": "@@ -81,7 +81,7 @@ pub type TraitMap = NodeMap<Vec<DefId> >;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = RefCell<NodeMap<Vec<Export2> >>;\n+pub type ExportMap2 = NodeMap<Vec<Export2>>;\n \n pub struct Export2 {\n     pub name: String,        // The name of the target.\n@@ -360,14 +360,14 @@ enum DuplicateCheckingMode {\n \n /// One local scope.\n struct Rib {\n-    bindings: RefCell<HashMap<Name, DefLike>>,\n+    bindings: HashMap<Name, DefLike>,\n     kind: RibKind,\n }\n \n impl Rib {\n     fn new(kind: RibKind) -> Rib {\n         Rib {\n-            bindings: RefCell::new(HashMap::new()),\n+            bindings: HashMap::new(),\n             kind: kind\n         }\n     }\n@@ -856,7 +856,7 @@ struct Resolver<'a> {\n \n     graph_root: NameBindings,\n \n-    trait_item_map: RefCell<FnvHashMap<(Name, DefId), TraitItemKind>>,\n+    trait_item_map: FnvHashMap<(Name, DefId), TraitItemKind>,\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n@@ -868,13 +868,13 @@ struct Resolver<'a> {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: RefCell<Vec<Rib>>,\n+    value_ribs: Vec<Rib>,\n \n     // The current set of local scopes, for types.\n-    type_ribs: RefCell<Vec<Rib>>,\n+    type_ribs: Vec<Rib>,\n \n     // The current set of local scopes, for labels.\n-    label_ribs: RefCell<Vec<Rib>>,\n+    label_ribs: Vec<Rib>,\n \n     // The trait that the current context can refer to.\n     current_trait_ref: Option<(DefId, TraitRef)>,\n@@ -893,7 +893,7 @@ struct Resolver<'a> {\n     def_map: DefMap,\n     freevars: RefCell<FreevarMap>,\n     freevars_seen: RefCell<NodeMap<NodeSet>>,\n-    capture_mode_map: RefCell<CaptureModeMap>,\n+    capture_mode_map: CaptureModeMap,\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n@@ -980,15 +980,15 @@ impl<'a> Resolver<'a> {\n \n             graph_root: graph_root,\n \n-            trait_item_map: RefCell::new(FnvHashMap::new()),\n+            trait_item_map: FnvHashMap::new(),\n             structs: FnvHashMap::new(),\n \n             unresolved_imports: 0,\n \n             current_module: current_module,\n-            value_ribs: RefCell::new(Vec::new()),\n-            type_ribs: RefCell::new(Vec::new()),\n-            label_ribs: RefCell::new(Vec::new()),\n+            value_ribs: Vec::new(),\n+            type_ribs: Vec::new(),\n+            label_ribs: Vec::new(),\n \n             current_trait_ref: None,\n             current_self_type: None,\n@@ -1001,8 +1001,8 @@ impl<'a> Resolver<'a> {\n             def_map: RefCell::new(NodeMap::new()),\n             freevars: RefCell::new(NodeMap::new()),\n             freevars_seen: RefCell::new(NodeMap::new()),\n-            capture_mode_map: RefCell::new(NodeMap::new()),\n-            export_map2: RefCell::new(NodeMap::new()),\n+            capture_mode_map: NodeMap::new(),\n+            export_map2: NodeMap::new(),\n             trait_map: NodeMap::new(),\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n@@ -1516,9 +1516,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     };\n \n-                    self.trait_item_map\n-                        .borrow_mut()\n-                        .insert((ident.name, def_id), kind);\n+                    self.trait_item_map.insert((ident.name, def_id), kind);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n@@ -1850,10 +1848,7 @@ impl<'a> Resolver<'a> {\n                           adding trait item '{}'\",\n                          token::get_ident(trait_item_name));\n \n-                  self.trait_item_map\n-                      .borrow_mut()\n-                      .insert((trait_item_name.name, def_id),\n-                              trait_item_kind);\n+                  self.trait_item_map.insert((trait_item_name.name, def_id), trait_item_kind);\n \n                   if is_exported {\n                       self.external_exports\n@@ -3760,7 +3755,7 @@ impl<'a> Resolver<'a> {\n         self.add_exports_for_module(&mut exports2, module_);\n         match module_.def_id.get() {\n             Some(def_id) => {\n-                self.export_map2.borrow_mut().insert(def_id.node, exports2);\n+                self.export_map2.insert(def_id.node, exports2);\n                 debug!(\"(computing exports) writing exports for {} (some)\",\n                        def_id.node);\n             }\n@@ -4017,7 +4012,7 @@ impl<'a> Resolver<'a> {\n         // FIXME #4950: Try caching?\n \n         for (i, rib) in ribs.iter().enumerate().rev() {\n-            match rib.bindings.borrow().find_copy(&name) {\n+            match rib.bindings.find_copy(&name) {\n                 Some(def_like) => {\n                     return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n                 }\n@@ -4093,13 +4088,12 @@ impl<'a> Resolver<'a> {\n \n             ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n                 // Create a new rib for the self type.\n-                let self_type_rib = Rib::new(ItemRibKind);\n+                let mut self_type_rib = Rib::new(ItemRibKind);\n \n                 // plain insert (no renaming, types are not currently hygienic....)\n                 let name = self.type_self_name;\n-                self_type_rib.bindings.borrow_mut()\n-                             .insert(name, DlDef(DefSelfTy(item.id)));\n-                self.type_ribs.borrow_mut().push(self_type_rib);\n+                self_type_rib.bindings.insert(name, DlDef(DefSelfTy(item.id)));\n+                self.type_ribs.push(self_type_rib);\n \n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -4168,7 +4162,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 });\n \n-                self.type_ribs.borrow_mut().pop();\n+                self.type_ribs.pop();\n             }\n \n             ItemStruct(ref struct_def, ref generics) => {\n@@ -4236,7 +4230,7 @@ impl<'a> Resolver<'a> {\n             HasTypeParameters(generics, space, node_id,\n                               rib_kind) => {\n \n-                let function_type_rib = Rib::new(rib_kind);\n+                let mut function_type_rib = Rib::new(rib_kind);\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n                     let ident = type_parameter.ident;\n@@ -4250,10 +4244,9 @@ impl<'a> Resolver<'a> {\n                     self.record_def(type_parameter.id,\n                                     (DefTyParamBinder(node_id), LastMod(AllPublic)));\n                     // plain insert (no renaming)\n-                    function_type_rib.bindings.borrow_mut()\n-                                     .insert(ident.name, def_like);\n+                    function_type_rib.bindings.insert(ident.name, def_like);\n                 }\n-                self.type_ribs.borrow_mut().push(function_type_rib);\n+                self.type_ribs.push(function_type_rib);\n             }\n \n             NoTypeParameters => {\n@@ -4264,23 +4257,23 @@ impl<'a> Resolver<'a> {\n         f(self);\n \n         match type_parameters {\n-            HasTypeParameters(..) => { self.type_ribs.borrow_mut().pop(); }\n+            HasTypeParameters(..) => { self.type_ribs.pop(); }\n             NoTypeParameters => { }\n         }\n     }\n \n     fn with_label_rib(&mut self, f: |&mut Resolver|) {\n-        self.label_ribs.borrow_mut().push(Rib::new(NormalRibKind));\n+        self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n-        self.label_ribs.borrow_mut().pop();\n+        self.label_ribs.pop();\n     }\n \n     fn with_constant_rib(&mut self, f: |&mut Resolver|) {\n-        self.value_ribs.borrow_mut().push(Rib::new(ConstantItemRibKind));\n-        self.type_ribs.borrow_mut().push(Rib::new(ConstantItemRibKind));\n+        self.value_ribs.push(Rib::new(ConstantItemRibKind));\n+        self.type_ribs.push(Rib::new(ConstantItemRibKind));\n         f(self);\n-        self.type_ribs.borrow_mut().pop();\n-        self.value_ribs.borrow_mut().pop();\n+        self.type_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_function(&mut self,\n@@ -4290,11 +4283,11 @@ impl<'a> Resolver<'a> {\n                         block: &Block) {\n         // Create a value rib for the function.\n         let function_value_rib = Rib::new(rib_kind);\n-        self.value_ribs.borrow_mut().push(function_value_rib);\n+        self.value_ribs.push(function_value_rib);\n \n         // Create a label rib for the function.\n         let function_label_rib = Rib::new(rib_kind);\n-        self.label_ribs.borrow_mut().push(function_label_rib);\n+        self.label_ribs.push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n         self.with_type_parameter_rib(type_parameters, |this| {\n@@ -4336,8 +4329,8 @@ impl<'a> Resolver<'a> {\n             debug!(\"(resolving function) leaving function\");\n         });\n \n-        self.label_ribs.borrow_mut().pop();\n-        self.value_ribs.borrow_mut().pop();\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_type_parameters(&mut self,\n@@ -4680,7 +4673,7 @@ impl<'a> Resolver<'a> {\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n             let method_name = ident.name;\n \n-            if self.trait_item_map.borrow().find(&(method_name, did)).is_none() {\n+            if self.trait_item_map.find(&(method_name, did)).is_none() {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n@@ -4780,7 +4773,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n-        self.value_ribs.borrow_mut().push(Rib::new(NormalRibKind));\n+        self.value_ribs.push(Rib::new(NormalRibKind));\n \n         let mut bindings_list = HashMap::new();\n         for pattern in arm.pats.iter() {\n@@ -4794,12 +4787,12 @@ impl<'a> Resolver<'a> {\n         visit::walk_expr_opt(self, &arm.guard);\n         self.resolve_expr(&*arm.body);\n \n-        self.value_ribs.borrow_mut().pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n         debug!(\"(resolving block) entering block\");\n-        self.value_ribs.borrow_mut().push(Rib::new(NormalRibKind));\n+        self.value_ribs.push(Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module.clone();\n@@ -4818,7 +4811,7 @@ impl<'a> Resolver<'a> {\n         // Move back up.\n         self.current_module = orig_module;\n \n-        self.value_ribs.borrow_mut().pop();\n+        self.value_ribs.pop();\n         debug!(\"(resolving block) leaving block\");\n     }\n \n@@ -5061,12 +5054,8 @@ impl<'a> Resolver<'a> {\n \n                             if !bindings_list.contains_key(&renamed) {\n                                 let this = &mut *self;\n-                                let value_ribs = this.value_ribs.borrow();\n-                                let length = value_ribs.len();\n-                                let last_rib = value_ribs.get(\n-                                    length - 1);\n-                                last_rib.bindings.borrow_mut()\n-                                        .insert(renamed, DlDef(def));\n+                                let last_rib = this.value_ribs.last_mut().unwrap();\n+                                last_rib.bindings.insert(renamed, DlDef(def));\n                                 bindings_list.insert(renamed, pat_id);\n                             } else if bindings_list.find(&renamed) ==\n                                     Some(&pat_id) {\n@@ -5416,7 +5405,7 @@ impl<'a> Resolver<'a> {\n             TraitModuleKind | ImplModuleKind => {\n                 match containing_module.def_id.get() {\n                     Some(def_id) => {\n-                        match self.trait_item_map.borrow().find(&(ident.name, def_id)) {\n+                        match self.trait_item_map.find(&(ident.name, def_id)) {\n                             Some(&StaticMethodTraitItemKind) => (),\n                             Some(&TypeTraitItemKind) => (),\n                             None => (),\n@@ -5508,12 +5497,12 @@ impl<'a> Resolver<'a> {\n         let search_result = match namespace {\n             ValueNS => {\n                 let renamed = mtwt::resolve(ident);\n-                self.search_ribs(self.value_ribs.borrow().as_slice(),\n+                self.search_ribs(self.value_ribs.as_slice(),\n                                  renamed, span)\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(self.type_ribs.borrow().as_slice(), name, span)\n+                self.search_ribs(self.type_ribs.as_slice(), name, span)\n             }\n         };\n \n@@ -5688,12 +5677,11 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Look for a method in the current trait.\n-        let trait_item_map = self.trait_item_map.borrow();\n         match self.current_trait_ref {\n             Some((did, ref trait_ref)) => {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);\n \n-                match trait_item_map.find(&(name, did)) {\n+                match self.trait_item_map.find(&(name, did)) {\n                     Some(&StaticMethodTraitItemKind) => return StaticTraitMethod(path_str),\n                     Some(_) => return TraitItem,\n                     None => {}\n@@ -5712,12 +5700,8 @@ impl<'a> Resolver<'a> {\n         let mut maybes: Vec<token::InternedString> = Vec::new();\n         let mut values: Vec<uint> = Vec::new();\n \n-        let mut j = this.value_ribs.borrow().len();\n-        while j != 0 {\n-            j -= 1;\n-            let value_ribs = this.value_ribs.borrow();\n-            let bindings = value_ribs.get(j).bindings.borrow();\n-            for (&k, _) in bindings.iter() {\n+        for rib in this.value_ribs.iter().rev() {\n+            for (&k, _) in rib.bindings.iter() {\n                 maybes.push(token::get_name(k));\n                 values.push(uint::MAX);\n             }\n@@ -5807,7 +5791,7 @@ impl<'a> Resolver<'a> {\n                             }\n                             _ => {\n                                 let mut method_scope = false;\n-                                self.value_ribs.borrow().iter().rev().all(|rib| {\n+                                self.value_ribs.iter().rev().all(|rib| {\n                                     let res = match *rib {\n                                         Rib { bindings: _, kind: MethodRibKind(_, _) } => true,\n                                         Rib { bindings: _, kind: ItemRibKind } => false,\n@@ -5866,20 +5850,20 @@ impl<'a> Resolver<'a> {\n             ExprFnBlock(_, ref fn_decl, ref block) => {\n                 // NOTE(stage0): After snapshot, change to:\n                 //\n-                //self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n-                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByRef);\n+                //self.capture_mode_map.insert(expr.id, capture_clause);\n+                self.capture_mode_map.insert(expr.id, ast::CaptureByRef);\n                 self.resolve_function(ClosureRibKind(expr.id, ast::DUMMY_NODE_ID),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n             ExprProc(ref fn_decl, ref block) => {\n-                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByValue);\n+                self.capture_mode_map.insert(expr.id, ast::CaptureByValue);\n                 self.resolve_function(ClosureRibKind(expr.id, block.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n             ExprUnboxedFn(capture_clause, _, ref fn_decl, ref block) => {\n-                self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n+                self.capture_mode_map.insert(expr.id, capture_clause);\n                 self.resolve_function(ClosureRibKind(expr.id, block.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n@@ -5908,11 +5892,9 @@ impl<'a> Resolver<'a> {\n                     let def_like = DlDef(DefLabel(expr.id));\n \n                     {\n-                        let label_ribs = this.label_ribs.borrow();\n-                        let length = label_ribs.len();\n-                        let rib = label_ribs.get(length - 1);\n+                        let rib = this.label_ribs.last_mut().unwrap();\n                         let renamed = mtwt::resolve(label);\n-                        rib.bindings.borrow_mut().insert(renamed, def_like);\n+                        rib.bindings.insert(renamed, def_like);\n                     }\n \n                     visit::walk_expr(this, expr);\n@@ -5922,7 +5904,7 @@ impl<'a> Resolver<'a> {\n             ExprForLoop(ref pattern, ref head, ref body, optional_label) => {\n                 self.resolve_expr(&**head);\n \n-                self.value_ribs.borrow_mut().push(Rib::new(NormalRibKind));\n+                self.value_ribs.push(Rib::new(NormalRibKind));\n \n                 self.resolve_pattern(&**pattern,\n                                      LocalIrrefutableMode,\n@@ -5932,33 +5914,29 @@ impl<'a> Resolver<'a> {\n                     None => {}\n                     Some(label) => {\n                         self.label_ribs\n-                            .borrow_mut()\n                             .push(Rib::new(NormalRibKind));\n                         let def_like = DlDef(DefLabel(expr.id));\n \n                         {\n-                            let label_ribs = self.label_ribs.borrow();\n-                            let length = label_ribs.len();\n-                            let rib = label_ribs.get(length - 1);\n+                            let rib = self.label_ribs.last_mut().unwrap();\n                             let renamed = mtwt::resolve(label);\n-                            rib.bindings.borrow_mut().insert(renamed,\n-                                                             def_like);\n+                            rib.bindings.insert(renamed, def_like);\n                         }\n                     }\n                 }\n \n                 self.resolve_block(&**body);\n \n                 if optional_label.is_some() {\n-                    drop(self.label_ribs.borrow_mut().pop())\n+                    drop(self.label_ribs.pop())\n                 }\n \n-                self.value_ribs.borrow_mut().pop();\n+                self.value_ribs.pop();\n             }\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let renamed = mtwt::resolve(label);\n-                match self.search_ribs(self.label_ribs.borrow().as_slice(),\n+                match self.search_ribs(self.label_ribs.as_slice(),\n                                        renamed, expr.span) {\n                     None => {\n                         self.resolve_error(\n@@ -6027,9 +6005,7 @@ impl<'a> Resolver<'a> {\n             // Look for the current trait.\n             match self.current_trait_ref {\n                 Some((trait_def_id, _)) => {\n-                    let trait_item_map = self.trait_item_map.borrow();\n-\n-                    if trait_item_map.contains_key(&(name, trait_def_id)) {\n+                    if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n                         add_trait_info(&mut found_traits, trait_def_id, name);\n                     }\n                 }\n@@ -6040,7 +6016,6 @@ impl<'a> Resolver<'a> {\n             self.populate_module_if_necessary(&search_module);\n \n             {\n-                let trait_item_map = self.trait_item_map.borrow();\n                 for (_, child_names) in search_module.children.borrow().iter() {\n                     let def = match child_names.def_for_namespace(TypeNS) {\n                         Some(def) => def,\n@@ -6050,7 +6025,7 @@ impl<'a> Resolver<'a> {\n                         DefTrait(trait_def_id) => trait_def_id,\n                         _ => continue,\n                     };\n-                    if trait_item_map.contains_key(&(name, trait_def_id)) {\n+                    if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n                         add_trait_info(&mut found_traits, trait_def_id, name);\n                     }\n                 }\n@@ -6066,7 +6041,7 @@ impl<'a> Resolver<'a> {\n                     Some(DefTrait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n-                if self.trait_item_map.borrow().contains_key(&(name, did)) {\n+                if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n                     self.used_imports.insert((import.type_id, TypeNS));\n                     match target.target_module.def_id.get() {\n@@ -6331,7 +6306,7 @@ pub fn resolve_crate(session: &Session,\n     CrateMap {\n         def_map: resolver.def_map,\n         freevars: resolver.freevars,\n-        capture_mode_map: resolver.capture_mode_map,\n+        capture_mode_map: RefCell::new(resolver.capture_mode_map),\n         exp_map2: resolver.export_map2,\n         trait_map: resolver.trait_map,\n         external_exports: resolver.external_exports,"}]}