{"sha": "53c2933d4406bc43b55d490722bf4ca062ab64eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYzI5MzNkNDQwNmJjNDNiNTVkNDkwNzIyYmY0Y2EwNjJhYjY0ZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-29T03:41:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-29T03:41:44Z"}, "message": "Auto merge of #30900 - michaelwoerister:trans_item_collect, r=nikomatsakis\n\nThe purpose of the translation item collector is to find all monomorphic instances of functions, methods and statics that need to be translated into LLVM IR in order to compile the current crate.\n\nSo far these instances have been discovered lazily during the trans path. For incremental compilation we want to know the set of these instances in advance, and that is what the trans::collect module provides.\nIn the future, incremental and regular translation will be driven by the collector implemented here.\n\nr? @nikomatsakis\ncc @rust-lang/compiler\n\nTranslation Item Collection\n===========================\n\nThis module is responsible for discovering all items that will contribute to\nto code generation of the crate. The important part here is that it not only\nneeds to find syntax-level items (functions, structs, etc) but also all\ntheir monomorphized instantiations. Every non-generic, non-const function\nmaps to one LLVM artifact. Every generic function can produce\nfrom zero to N artifacts, depending on the sets of type arguments it\nis instantiated with.\nThis also applies to generic items from other crates: A generic definition\nin crate X might produce monomorphizations that are compiled into crate Y.\nWe also have to collect these here.\n\nThe following kinds of \"translation items\" are handled here:\n\n - Functions\n - Methods\n - Closures\n - Statics\n - Drop glue\n\nThe following things also result in LLVM artifacts, but are not collected\nhere, since we instantiate them locally on demand when needed in a given\ncodegen unit:\n\n - Constants\n - Vtables\n - Object Shims\n\nGeneral Algorithm\n-----------------\nLet's define some terms first:\n\n - A \"translation item\" is something that results in a function or global in\n   the LLVM IR of a codegen unit. Translation items do not stand on their\n   own, they can reference other translation items. For example, if function\n   `foo()` calls function `bar()` then the translation item for `foo()`\n   references the translation item for function `bar()`. In general, the\n   definition for translation item A referencing a translation item B is that\n   the LLVM artifact produced for A references the LLVM artifact produced\n   for B.\n\n - Translation items and the references between them for a directed graph,\n   where the translation items are the nodes and references form the edges.\n   Let's call this graph the \"translation item graph\".\n\n - The translation item graph for a program contains all translation items\n   that are needed in order to produce the complete LLVM IR of the program.\n\nThe purpose of the algorithm implemented in this module is to build the\ntranslation item graph for the current crate. It runs in two phases:\n\n 1. Discover the roots of the graph by traversing the HIR of the crate.\n 2. Starting from the roots, find neighboring nodes by inspecting the MIR\n    representation of the item corresponding to a given node, until no more\n    new nodes are found.\n\nThe roots of the translation item graph correspond to the non-generic\nsyntactic items in the source code. We find them by walking the HIR of the\ncrate, and whenever we hit upon a function, method, or static item, we\ncreate a translation item consisting of the items DefId and, since we only\nconsider non-generic items, an empty type-substitution set.\n\nGiven a translation item node, we can discover neighbors by inspecting its\nMIR. We walk the MIR and any time we hit upon something that signifies a\nreference to another translation item, we have found a neighbor. Since the\ntranslation item we are currently at is always monomorphic, we also know the\nconcrete type arguments of its neighbors, and so all neighbors again will be\nmonomorphic. The specific forms a reference to a neighboring node can take\nin MIR are quite diverse. Here is an overview:\n\nThe most obvious form of one translation item referencing another is a\nfunction or method call (represented by a CALL terminator in MIR). But\ncalls are not the only thing that might introduce a reference between two\nfunction translation items, and as we will see below, they are just a\nspecialized of the form described next, and consequently will don't get any\nspecial treatment in the algorithm.\n\nA function does not need to actually be called in order to be a neighbor of\nanother function. It suffices to just take a reference in order to introduce\nan edge. Consider the following example:\n\n```rust\nfn print_val<T: Display>(x: T) {\n    println!(\"{}\", x);\n}\n\nfn call_fn(f: &Fn(i32), x: i32) {\n    f(x);\n}\n\nfn main() {\n    let print_i32 = print_val::<i32>;\n    call_fn(&print_i32, 0);\n}\n```\nThe MIR of none of these functions will contain an explicit call to\n`print_val::<i32>`. Nonetheless, in order to translate this program, we need\nan instance of this function. Thus, whenever we encounter a function or\nmethod in operand position, we treat it as a neighbor of the current\ntranslation item. Calls are just a special case of that.\n\nIn a way, closures are a simple case. Since every closure object needs to be\nconstructed somewhere, we can reliably discover them by observing\n`RValue::Aggregate` expressions with `AggregateKind::Closure`. This is also\ntrue for closures inlined from other crates.\n\nDrop glue translation items are introduced by MIR drop-statements. The\ngenerated translation item will again have drop-glue item neighbors if the\ntype to be dropped contains nested values that also need to be dropped. It\nmight also have a function item neighbor for the explicit `Drop::drop`\nimplementation of its type.\n\nA subtle way of introducing neighbor edges is by casting to a trait object.\nSince the resulting fat-pointer contains a reference to a vtable, we need to\ninstantiate all object-save methods of the trait, as we need to store\npointers to these functions even if they never get called anywhere. This can\nbe seen as a special case of taking a function reference.\n\nSince `Box` expression have special compiler support, no explicit calls to\n`exchange_malloc()` and `exchange_free()` may show up in MIR, even if the\ncompiler will generate them. We have to observe `Rvalue::Box` expressions\nand Box-typed drop-statements for that purpose.\n\nInteraction with Cross-Crate Inlining\n-------------------------------------\nThe binary of a crate will not only contain machine code for the items\ndefined in the source code of that crate. It will also contain monomorphic\ninstantiations of any extern generic functions and of functions marked with\nThe collection algorithm handles this more or less transparently. When\nconstructing a neighbor node for an item, the algorithm will always call\n`inline::get_local_instance()` before proceeding. If no local instance can\nbe acquired (e.g. for a function that is just linked to) no node is created;\nwhich is exactly what we want, since no machine code should be generated in\nthe current crate for such an item. On the other hand, if we can\nsuccessfully inline the function, we subsequently can just treat it like a\nlocal item, walking it's MIR et cetera.\n\nEager and Lazy Collection Mode\n------------------------------\nTranslation item collection can be performed in one of two modes:\n\n - Lazy mode means that items will only be instantiated when actually\n   referenced. The goal is to produce the least amount of machine code\n   possible.\n\n - Eager mode is meant to be used in conjunction with incremental compilation\n   where a stable set of translation items is more important than a minimal\n   one. Thus, eager mode will instantiate drop-glue for every drop-able type\n   in the crate, even of no drop call for that type exists (yet). It will\n   also instantiate default implementations of trait methods, something that\n   otherwise is only done on demand.\n\nOpen Issues\n-----------\nSome things are not yet fully implemented in the current version of this\nmodule.\n\nSince no MIR is constructed yet for initializer expressions of constants and\nstatics we cannot inspect these properly.\n\nIdeally, no translation item should be generated for const fns unless there\nis a call to them that cannot be evaluated at compile time. At the moment\nthis is not implemented however: a translation item will be produced\nregardless of whether it is actually needed or not.\n\n<!-- Reviewable:start -->\n[<img src=\"https://reviewable.io/review_button.png\" height=40 alt=\"Review on Reviewable\"/>](https://reviewable.io/reviews/rust-lang/rust/30900)\n<!-- Reviewable:end -->", "tree": {"sha": "95bfd44e198834dfc1d9ac7fd007101a61e81af1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95bfd44e198834dfc1d9ac7fd007101a61e81af1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53c2933d4406bc43b55d490722bf4ca062ab64eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53c2933d4406bc43b55d490722bf4ca062ab64eb", "html_url": "https://github.com/rust-lang/rust/commit/53c2933d4406bc43b55d490722bf4ca062ab64eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53c2933d4406bc43b55d490722bf4ca062ab64eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "142214d1f2232a4e88ff7bd99951b01f36052c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/142214d1f2232a4e88ff7bd99951b01f36052c61", "html_url": "https://github.com/rust-lang/rust/commit/142214d1f2232a4e88ff7bd99951b01f36052c61"}, {"sha": "4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2", "html_url": "https://github.com/rust-lang/rust/commit/4d074b8c4cbaf113d01a5da09f3c6d2e6dd9f5c2"}], "stats": {"total": 3416, "additions": 3342, "deletions": 74}, "files": [{"sha": "2693e9bcd236a3e35341da8402ac0c0db3a77d42", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/configure", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -1409,6 +1409,7 @@ do\n     make_dir $h/test/debuginfo-gdb\n     make_dir $h/test/debuginfo-lldb\n     make_dir $h/test/codegen\n+    make_dir $h/test/codegen-units\n     make_dir $h/test/rustdoc\n done\n "}, {"sha": "5ca27c489ed9ad3f2d2b56ed30eea1c09165bcf8", "filename": "mk/tests.mk", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -310,6 +310,7 @@ check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-gdb-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-lldb-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-codegen-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-codegen-units-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-exec\n \n@@ -473,6 +474,7 @@ DEBUGINFO_GDB_RS := $(wildcard $(S)src/test/debuginfo/*.rs)\n DEBUGINFO_LLDB_RS := $(wildcard $(S)src/test/debuginfo/*.rs)\n CODEGEN_RS := $(wildcard $(S)src/test/codegen/*.rs)\n CODEGEN_CC := $(wildcard $(S)src/test/codegen/*.cc)\n+CODEGEN_UNITS_RS := $(wildcard $(S)src/test/codegen-units/*.rs)\n RUSTDOCCK_RS := $(wildcard $(S)src/test/rustdoc/*.rs)\n \n RPASS_TESTS := $(RPASS_RS)\n@@ -488,6 +490,7 @@ PRETTY_TESTS := $(PRETTY_RS)\n DEBUGINFO_GDB_TESTS := $(DEBUGINFO_GDB_RS)\n DEBUGINFO_LLDB_TESTS := $(DEBUGINFO_LLDB_RS)\n CODEGEN_TESTS := $(CODEGEN_RS) $(CODEGEN_CC)\n+CODEGEN_UNITS_TESTS := $(CODEGEN_UNITS_RS)\n RUSTDOCCK_TESTS := $(RUSTDOCCK_RS)\n \n CTEST_SRC_BASE_rpass = run-pass\n@@ -550,6 +553,11 @@ CTEST_BUILD_BASE_codegen = codegen\n CTEST_MODE_codegen = codegen\n CTEST_RUNTOOL_codegen = $(CTEST_RUNTOOL)\n \n+CTEST_SRC_BASE_codegen-units = codegen-units\n+CTEST_BUILD_BASE_codegen-units = codegen-units\n+CTEST_MODE_codegen-units = codegen-units\n+CTEST_RUNTOOL_codegen-units = $(CTEST_RUNTOOL)\n+\n CTEST_SRC_BASE_rustdocck = rustdoc\n CTEST_BUILD_BASE_rustdocck = rustdoc\n CTEST_MODE_rustdocck = rustdoc\n@@ -673,6 +681,7 @@ CTEST_DEPS_debuginfo-lldb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_LLDB_TESTS) \\\n                                                $(S)src/etc/lldb_batchmode.py \\\n                                                $(S)src/etc/lldb_rust_formatters.py\n CTEST_DEPS_codegen_$(1)-T-$(2)-H-$(3) = $$(CODEGEN_TESTS)\n+CTEST_DEPS_codegen-units_$(1)-T-$(2)-H-$(3) = $$(CODEGEN_UNITS_TESTS)\n CTEST_DEPS_rustdocck_$(1)-T-$(2)-H-$(3) = $$(RUSTDOCCK_TESTS) \\\n         $$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n \t$(S)src/etc/htmldocck.py\n@@ -739,7 +748,7 @@ endif\n endef\n \n CTEST_NAMES = rpass rpass-valgrind rpass-full rfail-full cfail-full rfail cfail pfail \\\n-\tbench debuginfo-gdb debuginfo-lldb codegen rustdocck\n+\tbench debuginfo-gdb debuginfo-lldb codegen codegen-units rustdocck\n \n $(foreach host,$(CFG_HOST), \\\n  $(eval $(foreach target,$(CFG_TARGET), \\\n@@ -917,6 +926,7 @@ TEST_GROUPS = \\\n \tdebuginfo-gdb \\\n \tdebuginfo-lldb \\\n \tcodegen \\\n+\tcodegen-units \\\n \tdoc \\\n \t$(foreach docname,$(DOC_NAMES),doc-$(docname)) \\\n \tpretty \\"}, {"sha": "e66094dc3954b9d4bf7c13a0e8c3b6f3980e9373", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -25,6 +25,7 @@ pub enum Mode {\n     DebugInfoLldb,\n     Codegen,\n     Rustdoc,\n+    CodegenUnits\n }\n \n impl FromStr for Mode {\n@@ -41,6 +42,7 @@ impl FromStr for Mode {\n           \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n           \"codegen\" => Ok(Codegen),\n           \"rustdoc\" => Ok(Rustdoc),\n+          \"codegen-units\" => Ok(CodegenUnits),\n           _ => Err(()),\n         }\n     }\n@@ -59,6 +61,7 @@ impl fmt::Display for Mode {\n             DebugInfoLldb => \"debuginfo-lldb\",\n             Codegen => \"codegen\",\n             Rustdoc => \"rustdoc\",\n+            CodegenUnits => \"codegen-units\",\n         }, f)\n     }\n }"}, {"sha": "c7561248eb7fb4397b74b9c98193b9bda76c8447", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -10,14 +10,15 @@\n \n use common::Config;\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n-use common::{Codegen, DebugInfoLldb, DebugInfoGdb, Rustdoc};\n+use common::{Codegen, DebugInfoLldb, DebugInfoGdb, Rustdoc, CodegenUnits};\n use errors;\n use header::TestProps;\n use header;\n use procsrv;\n use util::logv;\n \n use std::env;\n+use std::collections::HashSet;\n use std::fmt;\n use std::fs::{self, File};\n use std::io::BufReader;\n@@ -56,6 +57,7 @@ pub fn run(config: Config, testfile: &Path) {\n         DebugInfoLldb => run_debuginfo_lldb_test(&config, &props, &testfile),\n         Codegen => run_codegen_test(&config, &props, &testfile),\n         Rustdoc => run_rustdoc_test(&config, &props, &testfile),\n+        CodegenUnits => run_codegen_units_test(&config, &props, &testfile),\n     }\n }\n \n@@ -1747,3 +1749,44 @@ fn run_rustdoc_test(config: &Config, props: &TestProps, testfile: &Path) {\n         fatal_proc_rec(\"htmldocck failed!\", &res);\n     }\n }\n+\n+fn run_codegen_units_test(config: &Config, props: &TestProps, testfile: &Path) {\n+    let proc_res = compile_test(config, props, testfile);\n+\n+    if !proc_res.status.success() {\n+        fatal_proc_rec(\"compilation failed!\", &proc_res);\n+    }\n+\n+    check_no_compiler_crash(&proc_res);\n+\n+    let prefix = \"TRANS_ITEM \";\n+\n+    let actual: HashSet<String> = proc_res\n+        .stdout\n+        .lines()\n+        .filter(|line| line.starts_with(prefix))\n+        .map(|s| (&s[prefix.len()..]).to_string())\n+        .collect();\n+\n+    let expected: HashSet<String> = errors::load_errors(testfile)\n+        .iter()\n+        .map(|e| e.msg.trim().to_string())\n+        .collect();\n+\n+    if actual != expected {\n+        let mut missing: Vec<_> = expected.difference(&actual).collect();\n+        missing.sort();\n+\n+        let mut too_much: Vec<_> = actual.difference(&expected).collect();\n+        too_much.sort();\n+\n+        println!(\"Expected and actual sets of codegen-items differ.\\n\\\n+                  These items should have been contained but were not:\\n\\n\\\n+                  {}\\n\\n\\\n+                  These items were contained but should not have been:\\n\\n\\\n+                  {}\\n\\n\",\n+            missing.iter().fold(\"\".to_string(), |s1, s2| s1 + \"\\n\" + s2),\n+            too_much.iter().fold(\"\".to_string(), |s1, s2| s1 + \"\\n\" + s2));\n+        panic!();\n+    }\n+}"}, {"sha": "10c1372cd86e42e67b8054d80df19e8071e05f60", "filename": "src/librustc/front/map/definitions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fdefinitions.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -196,33 +196,33 @@ impl DefPathData {\n \n             PositionalField |\n             Field(hir::StructFieldKind::UnnamedField(_)) => {\n-                InternedString::new(\"<field>\")\n+                InternedString::new(\"{{field}}\")\n             }\n \n             // note that this does not show up in user printouts\n             CrateRoot => {\n-                InternedString::new(\"<root>\")\n+                InternedString::new(\"{{root}}\")\n             }\n \n             // note that this does not show up in user printouts\n             InlinedRoot(_) => {\n-                InternedString::new(\"<inlined-root>\")\n+                InternedString::new(\"{{inlined-root}}\")\n             }\n \n             Misc => {\n-                InternedString::new(\"?\")\n+                InternedString::new(\"{{?}}\")\n             }\n \n             ClosureExpr => {\n-                InternedString::new(\"<closure>\")\n+                InternedString::new(\"{{closure}}\")\n             }\n \n             StructCtor => {\n-                InternedString::new(\"<constructor>\")\n+                InternedString::new(\"{{constructor}}\")\n             }\n \n             Initializer => {\n-                InternedString::new(\"<initializer>\")\n+                InternedString::new(\"{{initializer}}\")\n             }\n         }\n     }"}, {"sha": "8355154ad21a50ec60f439778119fc7363656046", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -223,6 +223,8 @@ pub trait CrateStore<'tcx> : Any {\n                           -> FoundAst<'tcx>;\n     fn maybe_get_item_mir(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                           -> Option<Mir<'tcx>>;\n+    fn is_item_mir_available(&self, def: DefId) -> bool;\n+\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<ast::CrateNum>;\n@@ -401,6 +403,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                           -> FoundAst<'tcx> { unimplemented!() }\n     fn maybe_get_item_mir(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                           -> Option<Mir<'tcx>> { unimplemented!() }\n+    fn is_item_mir_available(&self, def: DefId) -> bool {\n+        unimplemented!()\n+    }\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that."}, {"sha": "0fd6b933ed528280bdf3c53938c8e3b30c6d1a9c", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -563,7 +563,7 @@ impl<'tcx> ctxt<'tcx> {\n             const_qualif_map: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n-            fragment_infos: RefCell::new(DefIdMap()),\n+            fragment_infos: RefCell::new(DefIdMap())\n        }, f)\n     }\n }"}, {"sha": "8d8afc199f59edd99972f16b3b18178d85f209d8", "filename": "src/librustc/middle/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -13,7 +13,7 @@ use middle::def_id::DefId;\n use middle::ty;\n use std::marker::PhantomData;\n use std::rc::Rc;\n-use syntax::attr;\n+use syntax::{attr, ast};\n \n macro_rules! dep_map_ty {\n     ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n@@ -42,3 +42,4 @@ dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n+dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }"}, {"sha": "0fe39dcb7f9ec5d8458d4e7f6a74c2f3a7ea0555", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -25,7 +25,7 @@ use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n \n /// Lowered representation of a single function.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -146,7 +146,7 @@ pub enum BorrowKind {\n \n // A \"variable\" is a binding declared by the user as part of the fn\n // decl, a let, etc.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct VarDecl<'tcx> {\n     pub mutability: Mutability,\n     pub name: Name,\n@@ -155,7 +155,7 @@ pub struct VarDecl<'tcx> {\n \n // A \"temp\" is a temporary that we place on the stack. They are\n // anonymous, always mutable, and have only a type.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TempDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -171,7 +171,7 @@ pub struct TempDecl<'tcx> {\n //\n // there is only one argument, of type `(i32, u32)`, but two bindings\n // (`x` and `y`).\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -207,14 +207,14 @@ impl Debug for BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock and Terminator\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct BasicBlockData<'tcx> {\n     pub statements: Vec<Statement<'tcx>>,\n     pub terminator: Option<Terminator<'tcx>>,\n     pub is_cleanup: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum Terminator<'tcx> {\n     /// block should have one successor in the graph; we jump there\n     Goto {\n@@ -481,13 +481,13 @@ impl<'tcx> Terminator<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Statement<'tcx> {\n     pub span: Span,\n     pub kind: StatementKind<'tcx>,\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n     Drop(DropKind, Lvalue<'tcx>),\n@@ -721,7 +721,7 @@ pub enum Rvalue<'tcx> {\n     InlineAsm(InlineAsm),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CastKind {\n     Misc,\n "}, {"sha": "6956ee8eac2de77d9a2bd20e7ee84482087dc731", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -643,6 +643,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"keep the AST after lowering it to HIR\"),\n     show_span: Option<String> = (None, parse_opt_string,\n           \"show spans for compiler debugging (expr|pat|ty)\"),\n+    print_trans_items: Option<String> = (None, parse_opt_string,\n+          \"print the result of the translation item collection pass\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "cdbb6844703148d871bbba334ac99b231bff26e6", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -177,6 +177,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n           }\n           _ => { }\n         }\n+\n         Ok(ii)\n       }\n     }"}, {"sha": "bc52921e1b8ca530bd10d513ce1402239ce41eb7", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -445,6 +445,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::maybe_get_item_mir(&*cdata, tcx, def.index)\n     }\n \n+    fn is_item_mir_available(&self, def: DefId) -> bool {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::is_item_mir_available(&*cdata, def.index)\n+    }\n+\n     fn crates(&self) -> Vec<ast::CrateNum>\n     {\n         let mut result = vec![];"}, {"sha": "326f68561b09d1692970c5d6e766faa422a8e1a2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -830,6 +830,14 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd,\n     }\n }\n \n+pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n+    if let Some(item_doc) = cdata.get_item(id) {\n+        return reader::maybe_get_doc(item_doc, tag_mir as usize).is_some();\n+    }\n+\n+    false\n+}\n+\n pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n                                 tcx: &ty::ctxt<'tcx>,\n                                 id: DefIndex)\n@@ -849,6 +857,8 @@ pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n             })\n         }).unwrap();\n \n+        assert!(decoder.position() == mir_doc.end);\n+\n         let mut def_id_and_span_translator = MirDefIdAndSpanTranslator {\n             crate_metadata: cdata,\n             codemap: tcx.sess.codemap(),"}, {"sha": "76b1bad12146989c51b5681b0faa1d6ff7f95bd8", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 102, "deletions": 3, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -41,8 +41,10 @@ use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::pat_util::simple_name;\n-use middle::subst::Substs;\n+use middle::subst::{self, Substs};\n+use middle::traits;\n use middle::ty::{self, Ty, TypeFoldable};\n+use middle::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n use rustc::util::common::time;\n@@ -59,10 +61,11 @@ use trans::callee;\n use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n+use trans::collector::{self, TransItem, TransItemState, TransItemCollectionMode};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan, VariantInfo};\n-use trans::common::{node_id_type, return_type_is_void};\n+use trans::common::{node_id_type, return_type_is_void, fulfill_obligation};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n use trans::common;\n use trans::consts;\n@@ -98,7 +101,7 @@ use std::collections::{HashMap, HashSet};\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax::abi::{Rust, RustCall, RustIntrinsic, PlatformIntrinsic, Abi};\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::InternedString;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -736,6 +739,29 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n+pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n+                                             source_ty: Ty<'tcx>,\n+                                             target_ty: Ty<'tcx>)\n+                                             -> CustomCoerceUnsized {\n+    let trait_substs = Substs::erased(subst::VecPerParamSpace::new(vec![target_ty],\n+                                                                   vec![source_ty],\n+                                                                   Vec::new()));\n+    let trait_ref = ty::Binder(ty::TraitRef {\n+        def_id: ccx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n+        substs: ccx.tcx().mk_substs(trait_substs)\n+    });\n+\n+    match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+        traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n+            ccx.tcx().custom_coerce_unsized_kind(impl_def_id)\n+        }\n+        vtable => {\n+            ccx.sess().bug(&format!(\"invalid CoerceUnsized vtable: {:?}\",\n+                                    vtable));\n+        }\n+    }\n+}\n+\n pub fn cast_shift_expr_rhs(cx: Block, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs, |a, b| Trunc(cx, a, b), |a, b| ZExt(cx, a, b))\n }\n@@ -1965,6 +1991,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    closure_env: closure::ClosureEnv<'b>) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n+    record_translation_item_as_generated(ccx, fn_ast_id, param_substs);\n+\n     let _icx = push_ctxt(\"trans_closure\");\n     attributes::emit_uwtable(llfndecl, true);\n \n@@ -2078,6 +2106,28 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n+\n+    fn record_translation_item_as_generated<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                      node_id: ast::NodeId,\n+                                                      param_substs: &'tcx Substs<'tcx>) {\n+        if !collector::collecting_debug_information(ccx) {\n+            return;\n+        }\n+\n+        let def_id = match ccx.tcx().node_id_to_type(node_id).sty {\n+            ty::TyClosure(def_id, _) => def_id,\n+            _ => ccx.external_srcs()\n+                    .borrow()\n+                    .get(&node_id)\n+                    .map(|did| *did)\n+                    .unwrap_or_else(|| ccx.tcx().map.local_def_id(node_id)),\n+        };\n+\n+        ccx.record_translation_item_as_generated(TransItem::Fn{\n+            def_id: def_id,\n+            substs: ccx.tcx().mk_substs(ccx.tcx().erase_regions(param_substs)),\n+        });\n+    }\n }\n \n /// Creates an LLVM function corresponding to a source language function.\n@@ -3161,13 +3211,17 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // First, verify intrinsics.\n         intrinsic::check_intrinsics(&ccx);\n \n+        collect_translation_items(&ccx);\n+\n         // Next, translate all items. See `TransModVisitor` for\n         // details on why we walk in this particular way.\n         {\n             let _icx = push_ctxt(\"text\");\n             intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n             krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n         }\n+\n+        collector::print_collection_results(&ccx);\n     }\n \n     for ccx in shared_ccx.iter() {\n@@ -3339,3 +3393,48 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n         }\n     }\n }\n+\n+fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n+    let time_passes = ccx.sess().time_passes();\n+\n+    let collection_mode = match ccx.sess().opts.debugging_opts.print_trans_items {\n+        Some(ref s) => {\n+            let mode_string = s.to_lowercase();\n+            let mode_string = mode_string.trim();\n+            if mode_string == \"eager\" {\n+                TransItemCollectionMode::Eager\n+            } else {\n+                if mode_string != \"lazy\" {\n+                    let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n+                                           Falling back to 'lazy' mode.\",\n+                                           mode_string);\n+                    ccx.sess().warn(&message);\n+                }\n+\n+                TransItemCollectionMode::Lazy\n+            }\n+        }\n+        None => TransItemCollectionMode::Lazy\n+    };\n+\n+    let items = time(time_passes, \"translation item collection\", || {\n+        collector::collect_crate_translation_items(&ccx, collection_mode)\n+    });\n+\n+    if ccx.sess().opts.debugging_opts.print_trans_items.is_some() {\n+        let mut item_keys: Vec<_> = items.iter()\n+                                         .map(|i| i.to_string(ccx))\n+                                         .collect();\n+        item_keys.sort();\n+\n+        for item in item_keys {\n+            println!(\"TRANS_ITEM {}\", item);\n+        }\n+\n+        let mut ccx_map = ccx.translation_items().borrow_mut();\n+\n+        for cgi in items {\n+            ccx_map.insert(cgi, TransItemState::PredictedButNotGenerated);\n+        }\n+    }\n+}"}, {"sha": "6ec73788598485566d1c1d0eb9e8267d308cdc5e", "filename": "src/librustc_trans/trans/collector.rs", "status": "added", "additions": 1597, "deletions": 0, "changes": 1597, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,1597 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Translation Item Collection\n+//! ===========================\n+//!\n+//! This module is responsible for discovering all items that will contribute to\n+//! to code generation of the crate. The important part here is that it not only\n+//! needs to find syntax-level items (functions, structs, etc) but also all\n+//! their monomorphized instantiations. Every non-generic, non-const function\n+//! maps to one LLVM artifact. Every generic function can produce\n+//! from zero to N artifacts, depending on the sets of type arguments it\n+//! is instantiated with.\n+//! This also applies to generic items from other crates: A generic definition\n+//! in crate X might produce monomorphizations that are compiled into crate Y.\n+//! We also have to collect these here.\n+//!\n+//! The following kinds of \"translation items\" are handled here:\n+//!\n+//! - Functions\n+//! - Methods\n+//! - Closures\n+//! - Statics\n+//! - Drop glue\n+//!\n+//! The following things also result in LLVM artifacts, but are not collected\n+//! here, since we instantiate them locally on demand when needed in a given\n+//! codegen unit:\n+//!\n+//! - Constants\n+//! - Vtables\n+//! - Object Shims\n+//!\n+//!\n+//! General Algorithm\n+//! -----------------\n+//! Let's define some terms first:\n+//!\n+//! - A \"translation item\" is something that results in a function or global in\n+//!   the LLVM IR of a codegen unit. Translation items do not stand on their\n+//!   own, they can reference other translation items. For example, if function\n+//!   `foo()` calls function `bar()` then the translation item for `foo()`\n+//!   references the translation item for function `bar()`. In general, the\n+//!   definition for translation item A referencing a translation item B is that\n+//!   the LLVM artifact produced for A references the LLVM artifact produced\n+//!   for B.\n+//!\n+//! - Translation items and the references between them for a directed graph,\n+//!   where the translation items are the nodes and references form the edges.\n+//!   Let's call this graph the \"translation item graph\".\n+//!\n+//! - The translation item graph for a program contains all translation items\n+//!   that are needed in order to produce the complete LLVM IR of the program.\n+//!\n+//! The purpose of the algorithm implemented in this module is to build the\n+//! translation item graph for the current crate. It runs in two phases:\n+//!\n+//! 1. Discover the roots of the graph by traversing the HIR of the crate.\n+//! 2. Starting from the roots, find neighboring nodes by inspecting the MIR\n+//!    representation of the item corresponding to a given node, until no more\n+//!    new nodes are found.\n+//!\n+//! ### Discovering roots\n+//!\n+//! The roots of the translation item graph correspond to the non-generic\n+//! syntactic items in the source code. We find them by walking the HIR of the\n+//! crate, and whenever we hit upon a function, method, or static item, we\n+//! create a translation item consisting of the items DefId and, since we only\n+//! consider non-generic items, an empty type-substitution set.\n+//!\n+//! ### Finding neighbor nodes\n+//! Given a translation item node, we can discover neighbors by inspecting its\n+//! MIR. We walk the MIR and any time we hit upon something that signifies a\n+//! reference to another translation item, we have found a neighbor. Since the\n+//! translation item we are currently at is always monomorphic, we also know the\n+//! concrete type arguments of its neighbors, and so all neighbors again will be\n+//! monomorphic. The specific forms a reference to a neighboring node can take\n+//! in MIR are quite diverse. Here is an overview:\n+//!\n+//! #### Calling Functions/Methods\n+//! The most obvious form of one translation item referencing another is a\n+//! function or method call (represented by a CALL terminator in MIR). But\n+//! calls are not the only thing that might introduce a reference between two\n+//! function translation items, and as we will see below, they are just a\n+//! specialized of the form described next, and consequently will don't get any\n+//! special treatment in the algorithm.\n+//!\n+//! #### Taking a reference to a function or method\n+//! A function does not need to actually be called in order to be a neighbor of\n+//! another function. It suffices to just take a reference in order to introduce\n+//! an edge. Consider the following example:\n+//!\n+//! ```rust\n+//! fn print_val<T: Display>(x: T) {\n+//!     println!(\"{}\", x);\n+//! }\n+//!\n+//! fn call_fn(f: &Fn(i32), x: i32) {\n+//!     f(x);\n+//! }\n+//!\n+//! fn main() {\n+//!     let print_i32 = print_val::<i32>;\n+//!     call_fn(&print_i32, 0);\n+//! }\n+//! ```\n+//! The MIR of none of these functions will contain an explicit call to\n+//! `print_val::<i32>`. Nonetheless, in order to translate this program, we need\n+//! an instance of this function. Thus, whenever we encounter a function or\n+//! method in operand position, we treat it as a neighbor of the current\n+//! translation item. Calls are just a special case of that.\n+//!\n+//! #### Closures\n+//! In a way, closures are a simple case. Since every closure object needs to be\n+//! constructed somewhere, we can reliably discover them by observing\n+//! `RValue::Aggregate` expressions with `AggregateKind::Closure`. This is also\n+//! true for closures inlined from other crates.\n+//!\n+//! #### Drop glue\n+//! Drop glue translation items are introduced by MIR drop-statements. The\n+//! generated translation item will again have drop-glue item neighbors if the\n+//! type to be dropped contains nested values that also need to be dropped. It\n+//! might also have a function item neighbor for the explicit `Drop::drop`\n+//! implementation of its type.\n+//!\n+//! #### Unsizing Casts\n+//! A subtle way of introducing neighbor edges is by casting to a trait object.\n+//! Since the resulting fat-pointer contains a reference to a vtable, we need to\n+//! instantiate all object-save methods of the trait, as we need to store\n+//! pointers to these functions even if they never get called anywhere. This can\n+//! be seen as a special case of taking a function reference.\n+//!\n+//! #### Boxes\n+//! Since `Box` expression have special compiler support, no explicit calls to\n+//! `exchange_malloc()` and `exchange_free()` may show up in MIR, even if the\n+//! compiler will generate them. We have to observe `Rvalue::Box` expressions\n+//! and Box-typed drop-statements for that purpose.\n+//!\n+//!\n+//! Interaction with Cross-Crate Inlining\n+//! -------------------------------------\n+//! The binary of a crate will not only contain machine code for the items\n+//! defined in the source code of that crate. It will also contain monomorphic\n+//! instantiations of any extern generic functions and of functions marked with\n+//! #[inline].\n+//! The collection algorithm handles this more or less transparently. If it is\n+//! about to create a translation item for something with an external `DefId`,\n+//! it will take a look if the MIR for that item is available, and if so just\n+//! proceed normally. If the MIR is not available, it assumes that that item is\n+//! just linked to and no node is created; which is exactly what we want, since\n+//! no machine code should be generated in the current crate for such an item.\n+//!\n+//! Eager and Lazy Collection Mode\n+//! ------------------------------\n+//! Translation item collection can be performed in one of two modes:\n+//!\n+//! - Lazy mode means that items will only be instantiated when actually\n+//!   referenced. The goal is to produce the least amount of machine code\n+//!   possible.\n+//!\n+//! - Eager mode is meant to be used in conjunction with incremental compilation\n+//!   where a stable set of translation items is more important than a minimal\n+//!   one. Thus, eager mode will instantiate drop-glue for every drop-able type\n+//!   in the crate, even of no drop call for that type exists (yet). It will\n+//!   also instantiate default implementations of trait methods, something that\n+//!   otherwise is only done on demand.\n+//!\n+//!\n+//! Open Issues\n+//! -----------\n+//! Some things are not yet fully implemented in the current version of this\n+//! module.\n+//!\n+//! ### Initializers of Constants and Statics\n+//! Since no MIR is constructed yet for initializer expressions of constants and\n+//! statics we cannot inspect these properly.\n+//!\n+//! ### Const Fns\n+//! Ideally, no translation item should be generated for const fns unless there\n+//! is a call to them that cannot be evaluated at compile time. At the moment\n+//! this is not implemented however: a translation item will be produced\n+//! regardless of whether it is actually needed or not.\n+\n+use rustc_front::hir;\n+use rustc_front::intravisit as hir_visit;\n+\n+use rustc::front::map as hir_map;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n+use rustc::middle::{ty, traits};\n+use rustc::middle::subst::{self, Substs, Subst};\n+use rustc::middle::ty::adjustment::CustomCoerceUnsized;\n+use rustc::middle::ty::fold::TypeFoldable;\n+use rustc::mir::repr as mir;\n+use rustc::mir::visit as mir_visit;\n+use rustc::mir::visit::Visitor as MirVisitor;\n+\n+use syntax::ast::{self, NodeId};\n+use syntax::codemap::DUMMY_SP;\n+use syntax::errors;\n+use syntax::parse::token;\n+\n+use trans::base::custom_coerce_unsize_info;\n+use trans::context::CrateContext;\n+use trans::common::{fulfill_obligation, normalize_and_test_predicates,\n+                    type_is_sized};\n+use trans::glue;\n+use trans::meth;\n+use trans::monomorphize;\n+use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n+\n+use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n+pub enum TransItemCollectionMode {\n+    Eager,\n+    Lazy\n+}\n+\n+#[derive(Eq, Clone, Copy, Debug)]\n+pub enum TransItem<'tcx> {\n+    DropGlue(ty::Ty<'tcx>),\n+    Fn {\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>\n+    },\n+    Static(NodeId)\n+}\n+\n+impl<'tcx> Hash for TransItem<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        match *self {\n+            TransItem::DropGlue(t) => {\n+                0u8.hash(s);\n+                t.hash(s);\n+            },\n+            TransItem::Fn { def_id, substs } => {\n+                1u8.hash(s);\n+                def_id.hash(s);\n+                (substs as *const Substs<'tcx> as usize).hash(s);\n+            }\n+            TransItem::Static(node_id) => {\n+                3u8.hash(s);\n+                node_id.hash(s);\n+            }\n+        };\n+    }\n+}\n+\n+impl<'tcx> PartialEq for TransItem<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (*self, *other) {\n+            (TransItem::DropGlue(t1), TransItem::DropGlue(t2)) => t1 == t2,\n+            (TransItem::Fn { def_id: def_id1, substs: substs1 },\n+             TransItem::Fn { def_id: def_id2, substs: substs2 }) => {\n+                def_id1 == def_id2 && substs1 == substs2\n+            },\n+            (TransItem::Static(node_id1), TransItem::Static(node_id2)) => {\n+                node_id1 == node_id2\n+            },\n+            _ => false\n+        }\n+    }\n+}\n+\n+pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                 mode: TransItemCollectionMode)\n+                                                 -> FnvHashSet<TransItem<'tcx>> {\n+    // We are not tracking dependencies of this pass as it has to be re-executed\n+    // every time no matter what.\n+    ccx.tcx().dep_graph.with_ignore(|| {\n+        let roots = collect_roots(ccx, mode);\n+\n+        debug!(\"Building translation item graph, beginning at roots\");\n+        let mut visited = FnvHashSet();\n+        let mut recursion_depths = DefIdMap();\n+        let mut mir_cache = DefIdMap();\n+\n+        for root in roots {\n+            collect_items_rec(ccx,\n+                              root,\n+                              &mut visited,\n+                              &mut recursion_depths,\n+                              &mut mir_cache);\n+        }\n+\n+        visited\n+    })\n+}\n+\n+// Find all non-generic items by walking the HIR. These items serve as roots to\n+// start monomorphizing from.\n+fn collect_roots<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           mode: TransItemCollectionMode)\n+                           -> Vec<TransItem<'tcx>> {\n+    debug!(\"Collecting roots\");\n+    let mut roots = Vec::new();\n+\n+    {\n+        let mut visitor = RootCollector {\n+            ccx: ccx,\n+            mode: mode,\n+            output: &mut roots,\n+            enclosing_item: None,\n+            trans_empty_substs: ccx.tcx().mk_substs(Substs::trans_empty()),\n+        };\n+\n+        ccx.tcx().map.krate().visit_all_items(&mut visitor);\n+    }\n+\n+    roots\n+}\n+\n+#[derive(Clone)]\n+enum CachedMir<'mir, 'tcx: 'mir> {\n+    Ref(&'mir mir::Mir<'tcx>),\n+    Owned(Rc<mir::Mir<'tcx>>)\n+}\n+\n+impl<'mir, 'tcx: 'mir> CachedMir<'mir, 'tcx> {\n+    fn get_ref<'a>(&'a self) -> &'a mir::Mir<'tcx> {\n+        match *self {\n+            CachedMir::Ref(r) => r,\n+            CachedMir::Owned(ref rc) => &**rc,\n+        }\n+    }\n+}\n+\n+// Collect all monomorphized translation items reachable from `starting_point`\n+fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n+                                   starting_point: TransItem<'tcx>,\n+                                   visited: &mut FnvHashSet<TransItem<'tcx>>,\n+                                   recursion_depths: &mut DefIdMap<usize>,\n+                                   mir_cache: &mut DefIdMap<CachedMir<'a, 'tcx>>) {\n+    if !visited.insert(starting_point.clone()) {\n+        // We've been here already, no need to search again.\n+        return;\n+    }\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(ccx));\n+\n+    let mut neighbors = Vec::new();\n+    let recursion_depth_reset;\n+\n+    match starting_point {\n+        TransItem::DropGlue(t) => {\n+            find_drop_glue_neighbors(ccx, t, &mut neighbors);\n+            recursion_depth_reset = None;\n+        }\n+        TransItem::Static(_) => {\n+            recursion_depth_reset = None;\n+        }\n+        TransItem::Fn { def_id, substs: ref param_substs } => {\n+            // Keep track of the monomorphization recursion depth\n+            recursion_depth_reset = Some(check_recursion_limit(ccx,\n+                                                               def_id,\n+                                                               recursion_depths));\n+\n+            // Scan the MIR in order to find function calls, closures, and\n+            // drop-glue\n+            let mir = load_mir(ccx, def_id, mir_cache);\n+\n+            let mut visitor = MirNeighborCollector {\n+                ccx: ccx,\n+                mir: mir.get_ref(),\n+                output: &mut neighbors,\n+                param_substs: param_substs\n+            };\n+\n+            visitor.visit_mir(mir.get_ref());\n+        }\n+    }\n+\n+    for neighbour in neighbors {\n+        collect_items_rec(ccx, neighbour, visited, recursion_depths, mir_cache);\n+    }\n+\n+    if let Some((def_id, depth)) = recursion_depth_reset {\n+        recursion_depths.insert(def_id, depth);\n+    }\n+\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n+}\n+\n+fn load_mir<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n+                          def_id: DefId,\n+                          mir_cache: &mut DefIdMap<CachedMir<'a, 'tcx>>)\n+                          -> CachedMir<'a, 'tcx> {\n+    let mir_not_found_error_message = || {\n+        format!(\"Could not find MIR for function: {}\",\n+                ccx.tcx().item_path_str(def_id))\n+    };\n+\n+    if def_id.is_local() {\n+        let node_id = ccx.tcx().map.as_local_node_id(def_id).unwrap();\n+        let mir_opt = ccx.mir_map().get(&node_id);\n+        let mir = errors::expect(ccx.sess().diagnostic(),\n+                             mir_opt,\n+                             mir_not_found_error_message);\n+        CachedMir::Ref(mir)\n+    } else {\n+        if let Some(mir) = mir_cache.get(&def_id) {\n+            return mir.clone();\n+        }\n+\n+        let mir_opt = ccx.sess().cstore.maybe_get_item_mir(ccx.tcx(), def_id);\n+        let mir = errors::expect(ccx.sess().diagnostic(),\n+                                 mir_opt,\n+                                 mir_not_found_error_message);\n+        let cached = CachedMir::Owned(Rc::new(mir));\n+        mir_cache.insert(def_id, cached.clone());\n+        cached\n+    }\n+}\n+\n+fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n+                                       def_id: DefId,\n+                                       recursion_depths: &mut DefIdMap<usize>)\n+                                       -> (DefId, usize) {\n+    let recursion_depth = recursion_depths.get(&def_id)\n+                                          .map(|x| *x)\n+                                          .unwrap_or(0);\n+    debug!(\" => recursion depth={}\", recursion_depth);\n+\n+    // Code that needs to instantiate the same function recursively\n+    // more than the recursion limit is assumed to be causing an\n+    // infinite expansion.\n+    if recursion_depth > ccx.sess().recursion_limit.get() {\n+        if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n+            ccx.sess().span_fatal(ccx.tcx().map.span(node_id),\n+                \"reached the recursion limit during monomorphization\");\n+        } else {\n+            let error = format!(\"reached the recursion limit during \\\n+                                monomorphization of '{}'\",\n+                                ccx.tcx().item_path_str(def_id));\n+            ccx.sess().fatal(&error[..]);\n+        }\n+    }\n+\n+    recursion_depths.insert(def_id, recursion_depth + 1);\n+\n+    (def_id, recursion_depth)\n+}\n+\n+struct MirNeighborCollector<'a, 'tcx: 'a> {\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    mir: &'a mir::Mir<'tcx>,\n+    output: &'a mut Vec<TransItem<'tcx>>,\n+    param_substs: &'tcx Substs<'tcx>\n+}\n+\n+impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n+\n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>) {\n+        debug!(\"visiting rvalue {:?}\", *rvalue);\n+\n+        match *rvalue {\n+            mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n+                                                               ref substs), _) => {\n+                assert!(can_have_local_instance(self.ccx, def_id));\n+                let trans_item = create_fn_trans_item(self.ccx,\n+                                                      def_id,\n+                                                      substs.func_substs,\n+                                                      self.param_substs);\n+                self.output.push(trans_item);\n+            }\n+            // When doing an cast from a regular pointer to a fat pointer, we\n+            // have to instantiate all methods of the trait being cast to, so we\n+            // can build the appropriate vtable.\n+            mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n+                let target_ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                                                 self.param_substs,\n+                                                                 &target_ty);\n+                let source_ty = self.mir.operand_ty(self.ccx.tcx(), operand);\n+                let source_ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                                                 self.param_substs,\n+                                                                 &source_ty);\n+                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.ccx,\n+                                                                            source_ty,\n+                                                                            target_ty);\n+                // This could also be a different Unsize instruction, like\n+                // from a fixed sized array to a slice. But we are only\n+                // interested in things that produce a vtable.\n+                if target_ty.is_trait() && !source_ty.is_trait() {\n+                    create_trans_items_for_vtable_methods(self.ccx,\n+                                                          target_ty,\n+                                                          source_ty,\n+                                                          self.output);\n+                }\n+            }\n+            mir::Rvalue::Box(_) => {\n+                let exchange_malloc_fn_def_id =\n+                    self.ccx\n+                        .tcx()\n+                        .lang_items\n+                        .require(ExchangeMallocFnLangItem)\n+                        .expect(\"Could not find ExchangeMallocFnLangItem\");\n+\n+                assert!(can_have_local_instance(self.ccx, exchange_malloc_fn_def_id));\n+                let exchange_malloc_fn_trans_item =\n+                    create_fn_trans_item(self.ccx,\n+                                         exchange_malloc_fn_def_id,\n+                                         &Substs::trans_empty(),\n+                                         self.param_substs);\n+\n+                self.output.push(exchange_malloc_fn_trans_item);\n+            }\n+            _ => { /* not interesting */ }\n+        }\n+\n+        self.super_rvalue(rvalue);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mir::Lvalue<'tcx>,\n+                    context: mir_visit::LvalueContext) {\n+        debug!(\"visiting lvalue {:?}\", *lvalue);\n+\n+        if let mir_visit::LvalueContext::Drop = context {\n+            let ty = self.mir.lvalue_ty(self.ccx.tcx(), lvalue)\n+                             .to_ty(self.ccx.tcx());\n+\n+            let ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                                      self.param_substs,\n+                                                      &ty);\n+            let ty = self.ccx.tcx().erase_regions(&ty);\n+            let ty = glue::get_drop_glue_type(self.ccx, ty);\n+            self.output.push(TransItem::DropGlue(ty));\n+        }\n+\n+        self.super_lvalue(lvalue, context);\n+    }\n+\n+    fn visit_operand(&mut self, operand: &mir::Operand<'tcx>) {\n+        debug!(\"visiting operand {:?}\", *operand);\n+\n+        let callee = match *operand {\n+            mir::Operand::Constant(mir::Constant {\n+                literal: mir::Literal::Item {\n+                    def_id,\n+                    kind,\n+                    substs\n+                },\n+                ..\n+            }) if is_function_or_method(kind) => Some((def_id, substs)),\n+            _ => None\n+        };\n+\n+        if let Some((callee_def_id, callee_substs)) = callee {\n+            debug!(\" => operand is callable\");\n+\n+            // `callee_def_id` might refer to a trait method instead of a\n+            // concrete implementation, so we have to find the actual\n+            // implementation. For example, the call might look like\n+            //\n+            // std::cmp::partial_cmp(0i32, 1i32)\n+            //\n+            // Calling do_static_dispatch() here will map the def_id of\n+            // `std::cmp::partial_cmp` to the def_id of `i32::partial_cmp<i32>`\n+            let dispatched = do_static_dispatch(self.ccx,\n+                                                callee_def_id,\n+                                                callee_substs,\n+                                                self.param_substs);\n+\n+            if let Some((callee_def_id, callee_substs)) = dispatched {\n+                // if we have a concrete impl (which we might not have\n+                // in the case of something compiler generated like an\n+                // object shim or a closure that is handled differently),\n+                // we check if the callee is something that will actually\n+                // result in a translation item ...\n+                if can_result_in_trans_item(self.ccx, callee_def_id) {\n+                    // ... and create one if it does.\n+                    let trans_item = create_fn_trans_item(self.ccx,\n+                                                          callee_def_id,\n+                                                          callee_substs,\n+                                                          self.param_substs);\n+                    self.output.push(trans_item);\n+                }\n+            }\n+        }\n+\n+        self.super_operand(operand);\n+\n+        fn is_function_or_method(item_kind: mir::ItemKind) -> bool {\n+            match item_kind {\n+                mir::ItemKind::Constant => false,\n+                mir::ItemKind::Function |\n+                mir::ItemKind::Method   => true\n+            }\n+        }\n+\n+        fn can_result_in_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                              def_id: DefId)\n+                                              -> bool {\n+            if !match ccx.tcx().lookup_item_type(def_id).ty.sty {\n+                ty::TyBareFn(Some(def_id), _) => {\n+                    // Some constructors also have type TyBareFn but they are\n+                    // always instantiated inline and don't result in\n+                    // translation item.\n+                    match ccx.tcx().map.get_if_local(def_id) {\n+                        Some(hir_map::NodeVariant(_))    |\n+                        Some(hir_map::NodeStructCtor(_)) => false,\n+                        Some(_) => true,\n+                        None => {\n+                            ccx.sess().cstore.variant_kind(def_id).is_none()\n+                        }\n+                    }\n+                }\n+                ty::TyClosure(..) => true,\n+                _ => false\n+            } {\n+                return false;\n+            }\n+\n+            can_have_local_instance(ccx, def_id)\n+        }\n+    }\n+}\n+\n+fn can_have_local_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     def_id: DefId)\n+                                     -> bool {\n+    // Take a look if we have the definition available. If not, we\n+    // will not emit code for this item in the local crate, and thus\n+    // don't create a translation item for it.\n+    def_id.is_local() || ccx.sess().cstore.is_item_mir_available(def_id)\n+}\n+\n+fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                      ty: ty::Ty<'tcx>,\n+                                      output: &mut Vec<TransItem<'tcx>>)\n+{\n+    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(ccx, ty));\n+\n+    // Make sure the exchange_free_fn() lang-item gets translated if\n+    // there is a boxed value.\n+    if let ty::TyBox(_) = ty.sty {\n+        let exchange_free_fn_def_id = ccx.tcx()\n+                                         .lang_items\n+                                         .require(ExchangeFreeFnLangItem)\n+                                         .expect(\"Could not find ExchangeFreeFnLangItem\");\n+\n+        assert!(can_have_local_instance(ccx, exchange_free_fn_def_id));\n+        let exchange_free_fn_trans_item =\n+            create_fn_trans_item(ccx,\n+                                 exchange_free_fn_def_id,\n+                                 &Substs::trans_empty(),\n+                                 &Substs::trans_empty());\n+\n+        output.push(exchange_free_fn_trans_item);\n+    }\n+\n+    // If the type implements Drop, also add a translation item for the\n+    // monomorphized Drop::drop() implementation.\n+    let destructor_did = match ty.sty {\n+        ty::TyStruct(def, _) |\n+        ty::TyEnum(def, _)   => def.destructor(),\n+        _ => None\n+    };\n+\n+    if let Some(destructor_did) = destructor_did {\n+        use rustc::middle::ty::ToPolyTraitRef;\n+\n+        let drop_trait_def_id = ccx.tcx()\n+                                   .lang_items\n+                                   .drop_trait()\n+                                   .unwrap();\n+\n+        let self_type_substs = ccx.tcx().mk_substs(\n+            Substs::trans_empty().with_self_ty(ty));\n+\n+        let trait_ref = ty::TraitRef {\n+            def_id: drop_trait_def_id,\n+            substs: self_type_substs,\n+        }.to_poly_trait_ref();\n+\n+        let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+            traits::VtableImpl(data) => data.substs,\n+            _ => unreachable!()\n+        };\n+\n+        if can_have_local_instance(ccx, destructor_did) {\n+            let trans_item = create_fn_trans_item(ccx,\n+                                                  destructor_did,\n+                                                  ccx.tcx().mk_substs(substs),\n+                                                  &Substs::trans_empty());\n+            output.push(trans_item);\n+        }\n+    }\n+\n+    // Finally add the types of nested values\n+    match ty.sty {\n+        ty::TyBool       |\n+        ty::TyChar       |\n+        ty::TyInt(_)     |\n+        ty::TyUint(_)    |\n+        ty::TyStr        |\n+        ty::TyFloat(_)   |\n+        ty::TyRawPtr(_)  |\n+        ty::TyRef(..)    |\n+        ty::TyBareFn(..) |\n+        ty::TySlice(_)   |\n+        ty::TyTrait(_)   => {\n+            /* nothing to do */\n+        }\n+        ty::TyStruct(ref adt_def, substs) |\n+        ty::TyEnum(ref adt_def, substs) => {\n+            for field in adt_def.all_fields() {\n+                let field_type = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                                  substs,\n+                                                                  &field.unsubst_ty());\n+                let field_type = glue::get_drop_glue_type(ccx, field_type);\n+\n+                if glue::type_needs_drop(ccx.tcx(), field_type) {\n+                    output.push(TransItem::DropGlue(field_type));\n+                }\n+            }\n+        }\n+        ty::TyClosure(_, ref substs) => {\n+            for upvar_ty in &substs.upvar_tys {\n+                let upvar_ty = glue::get_drop_glue_type(ccx, upvar_ty);\n+                if glue::type_needs_drop(ccx.tcx(), upvar_ty) {\n+                    output.push(TransItem::DropGlue(upvar_ty));\n+                }\n+            }\n+        }\n+        ty::TyBox(inner_type)      |\n+        ty::TyArray(inner_type, _) => {\n+            let inner_type = glue::get_drop_glue_type(ccx, inner_type);\n+            if glue::type_needs_drop(ccx.tcx(), inner_type) {\n+                output.push(TransItem::DropGlue(inner_type));\n+            }\n+        }\n+        ty::TyTuple(ref args) => {\n+            for arg in args {\n+                let arg = glue::get_drop_glue_type(ccx, arg);\n+                if glue::type_needs_drop(ccx.tcx(), arg) {\n+                    output.push(TransItem::DropGlue(arg));\n+                }\n+            }\n+        }\n+        ty::TyProjection(_) |\n+        ty::TyParam(_)      |\n+        ty::TyInfer(_)      |\n+        ty::TyError         => {\n+            ccx.sess().bug(\"encountered unexpected type\");\n+        }\n+    }\n+}\n+\n+fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                fn_def_id: DefId,\n+                                fn_substs: &'tcx Substs<'tcx>,\n+                                param_substs: &'tcx Substs<'tcx>)\n+                                -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+    debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n+           def_id_to_string(ccx, fn_def_id, None),\n+           fn_substs,\n+           param_substs);\n+\n+    let is_trait_method = ccx.tcx().trait_of_item(fn_def_id).is_some();\n+\n+    if is_trait_method {\n+        match ccx.tcx().impl_or_trait_item(fn_def_id) {\n+            ty::MethodTraitItem(ref method) => {\n+                match method.container {\n+                    ty::TraitContainer(trait_def_id) => {\n+                        debug!(\" => trait method, attempting to find impl\");\n+                        do_static_trait_method_dispatch(ccx,\n+                                                        method,\n+                                                        trait_def_id,\n+                                                        fn_substs,\n+                                                        param_substs)\n+                    }\n+                    ty::ImplContainer(_) => {\n+                        // This is already a concrete implementation\n+                        debug!(\" => impl method\");\n+                        Some((fn_def_id, fn_substs))\n+                    }\n+                }\n+            }\n+            _ => unreachable!()\n+        }\n+    } else {\n+        debug!(\" => regular function\");\n+        // The function is not part of an impl or trait, no dispatching\n+        // to be done\n+        Some((fn_def_id, fn_substs))\n+    }\n+}\n+\n+// Given a trait-method and substitution information, find out the actual\n+// implementation of the trait method.\n+fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                             trait_method: &ty::Method,\n+                                             trait_id: DefId,\n+                                             callee_substs: &'tcx Substs<'tcx>,\n+                                             param_substs: &'tcx Substs<'tcx>)\n+                                             -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+    let tcx = ccx.tcx();\n+    debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n+                                            trait_id={}, \\\n+                                            callee_substs={:?}, \\\n+                                            param_substs={:?}\",\n+           def_id_to_string(ccx, trait_method.def_id, None),\n+           def_id_to_string(ccx, trait_id, None),\n+           callee_substs,\n+           param_substs);\n+\n+    let rcvr_substs = monomorphize::apply_param_substs(tcx,\n+                                                       param_substs,\n+                                                       callee_substs);\n+\n+    let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n+    let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+\n+    // Now that we know which impl is being used, we can dispatch to\n+    // the actual function:\n+    match vtbl {\n+        traits::VtableImpl(traits::VtableImplData {\n+            impl_def_id: impl_did,\n+            substs: impl_substs,\n+            nested: _ }) =>\n+        {\n+            let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n+            let impl_method = tcx.get_impl_method(impl_did,\n+                                                  callee_substs,\n+                                                  trait_method.name);\n+            Some((impl_method.method.def_id, tcx.mk_substs(impl_method.substs)))\n+        }\n+        // If we have a closure or a function pointer, we will also encounter\n+        // the concrete closure/function somewhere else (during closure or fn\n+        // pointer construction). That's where we track those things.\n+        traits::VtableClosure(..) |\n+        traits::VtableFnPointer(..) |\n+        traits::VtableObject(..) => {\n+            None\n+        }\n+        _ => {\n+            tcx.sess.bug(&format!(\"static call to invalid vtable: {:?}\", vtbl))\n+        }\n+    }\n+}\n+\n+/// For given pair of source and target type that occur in an unsizing coercion,\n+/// this function finds the pair of types that determines the vtable linking\n+/// them.\n+///\n+/// For example, the source type might be `&SomeStruct` and the target type\\\n+/// might be `&SomeTrait` in a cast like:\n+///\n+/// let src: &SomeStruct = ...;\n+/// let target = src as &SomeTrait;\n+///\n+/// Then the output of this function would be (SomeStruct, SomeTrait) since for\n+/// constructing the `target` fat-pointer we need the vtable for that pair.\n+///\n+/// Things can get more complicated though because there's also the case where\n+/// the unsized type occurs as a field:\n+///\n+/// ```rust\n+/// struct ComplexStruct<T: ?Sized> {\n+///    a: u32,\n+///    b: f64,\n+///    c: T\n+/// }\n+/// ```\n+///\n+/// In this case, if `T` is sized, `&ComplexStruct<T>` is a thin pointer. If `T`\n+/// is unsized, `&SomeStruct` is a fat pointer, and the vtable it points to is\n+/// for the pair of `T` (which is a trait) and the concrete type that `T` was\n+/// originally coerced from:\n+///\n+/// let src: &ComplexStruct<SomeStruct> = ...;\n+/// let target = src as &ComplexStruct<SomeTrait>;\n+///\n+/// Again, we want this `find_vtable_types_for_unsizing()` to provide the pair\n+/// `(SomeStruct, SomeTrait)`.\n+///\n+/// Finally, there is also the case of custom unsizing coercions, e.g. for\n+/// smart pointers such as `Rc` and `Arc`.\n+fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                            source_ty: ty::Ty<'tcx>,\n+                                            target_ty: ty::Ty<'tcx>)\n+                                            -> (ty::Ty<'tcx>, ty::Ty<'tcx>) {\n+    match (&source_ty.sty, &target_ty.sty) {\n+        (&ty::TyBox(a), &ty::TyBox(b)) |\n+        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+            let (inner_source, inner_target) = (a, b);\n+\n+            if !type_is_sized(ccx.tcx(), inner_source) {\n+                (inner_source, inner_target)\n+            } else {\n+                ccx.tcx().struct_lockstep_tails(inner_source, inner_target)\n+            }\n+        }\n+\n+        (&ty::TyStruct(source_adt_def, source_substs),\n+         &ty::TyStruct(target_adt_def, target_substs)) => {\n+            assert_eq!(source_adt_def, target_adt_def);\n+\n+            let kind = custom_coerce_unsize_info(ccx, source_ty, target_ty);\n+\n+            let coerce_index = match kind {\n+                CustomCoerceUnsized::Struct(i) => i\n+            };\n+\n+            let source_fields = &source_adt_def.struct_variant().fields;\n+            let target_fields = &target_adt_def.struct_variant().fields;\n+\n+            assert!(coerce_index < source_fields.len() &&\n+                    source_fields.len() == target_fields.len());\n+\n+            find_vtable_types_for_unsizing(ccx,\n+                                           source_fields[coerce_index].ty(ccx.tcx(),\n+                                                                          source_substs),\n+                                           target_fields[coerce_index].ty(ccx.tcx(),\n+                                                                          target_substs))\n+        }\n+        _ => ccx.sess()\n+                .bug(&format!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n+                               source_ty,\n+                               target_ty))\n+    }\n+}\n+\n+fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  def_id: DefId,\n+                                  fn_substs: &Substs<'tcx>,\n+                                  param_substs: &Substs<'tcx>)\n+                                  -> TransItem<'tcx>\n+{\n+    debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n+            def_id_to_string(ccx, def_id, None),\n+            fn_substs,\n+            param_substs);\n+\n+    // We only get here, if fn_def_id either designates a local item or\n+    // an inlineable external item. Non-inlineable external items are\n+    // ignored because we don't want to generate any code for them.\n+    let concrete_substs = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                           param_substs,\n+                                                           fn_substs);\n+    let concrete_substs = ccx.tcx().erase_regions(&concrete_substs);\n+\n+    let trans_item = TransItem::Fn {\n+        def_id: def_id,\n+        substs: ccx.tcx().mk_substs(concrete_substs),\n+    };\n+\n+    return trans_item;\n+}\n+\n+/// Creates a `TransItem` for each method that is referenced by the vtable for\n+/// the given trait/impl pair.\n+fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                   trait_ty: ty::Ty<'tcx>,\n+                                                   impl_ty: ty::Ty<'tcx>,\n+                                                   output: &mut Vec<TransItem<'tcx>>) {\n+    assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n+\n+    if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n+        let poly_trait_ref = trait_ty.principal_trait_ref_with_self_ty(ccx.tcx(),\n+                                                                       impl_ty);\n+\n+        // Walk all methods of the trait, including those of its supertraits\n+        for trait_ref in traits::supertraits(ccx.tcx(), poly_trait_ref) {\n+            let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+            match vtable {\n+                traits::VtableImpl(\n+                    traits::VtableImplData {\n+                        impl_def_id,\n+                        substs,\n+                        nested: _ }) => {\n+                    let items = meth::get_vtable_methods(ccx, impl_def_id, substs)\n+                        .into_iter()\n+                        // filter out None values\n+                        .filter_map(|opt_impl_method| opt_impl_method)\n+                        // create translation items\n+                        .filter_map(|impl_method| {\n+                            if can_have_local_instance(ccx, impl_method.method.def_id) {\n+                                let substs = ccx.tcx().mk_substs(impl_method.substs);\n+                                Some(create_fn_trans_item(ccx,\n+                                                          impl_method.method.def_id,\n+                                                          substs,\n+                                                          &Substs::trans_empty()))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .collect::<Vec<_>>();\n+\n+                    output.extend(items.into_iter());\n+                }\n+                _ => { /* */ }\n+            }\n+        }\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// Root Collection\n+//=-----------------------------------------------------------------------------\n+\n+struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n+    ccx: &'b CrateContext<'a, 'tcx>,\n+    mode: TransItemCollectionMode,\n+    output: &'b mut Vec<TransItem<'tcx>>,\n+    enclosing_item: Option<&'tcx hir::Item>,\n+    trans_empty_substs: &'tcx Substs<'tcx>\n+}\n+\n+impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n+    fn visit_item(&mut self, item: &'v hir::Item) {\n+        let old_enclosing_item = self.enclosing_item;\n+        self.enclosing_item = Some(item);\n+\n+        match item.node {\n+            hir::ItemExternCrate(..) |\n+            hir::ItemUse(..)         |\n+            hir::ItemForeignMod(..)  |\n+            hir::ItemTy(..)          |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemTrait(..)       |\n+            hir::ItemConst(..)       |\n+            hir::ItemMod(..)         => {\n+                // Nothing to do, just keep recursing...\n+            }\n+\n+            hir::ItemImpl(..) => {\n+                if self.mode == TransItemCollectionMode::Eager {\n+                    create_trans_items_for_default_impls(self.ccx,\n+                                                         item,\n+                                                         self.trans_empty_substs,\n+                                                         self.output);\n+                }\n+            }\n+\n+            hir::ItemEnum(_, ref generics)        |\n+            hir::ItemStruct(_, ref generics)      => {\n+                if !generics.is_parameterized() {\n+                    let ty = {\n+                        let tables = self.ccx.tcx().tables.borrow();\n+                        tables.node_types[&item.id]\n+                    };\n+\n+                    if self.mode == TransItemCollectionMode::Eager {\n+                        debug!(\"RootCollector: ADT drop-glue for {}\",\n+                               def_id_to_string(self.ccx,\n+                                                self.ccx.tcx().map.local_def_id(item.id),\n+                                                None));\n+\n+                        let ty = glue::get_drop_glue_type(self.ccx, ty);\n+                        self.output.push(TransItem::DropGlue(ty));\n+                    }\n+                }\n+            }\n+            hir::ItemStatic(..) => {\n+                debug!(\"RootCollector: ItemStatic({})\",\n+                       def_id_to_string(self.ccx,\n+                                        self.ccx.tcx().map.local_def_id(item.id),\n+                                        None));\n+                self.output.push(TransItem::Static(item.id));\n+            }\n+            hir::ItemFn(_, _, constness, _, ref generics, _) => {\n+                if !generics.is_type_parameterized() &&\n+                   constness == hir::Constness::NotConst {\n+                    let def_id = self.ccx.tcx().map.local_def_id(item.id);\n+\n+                    debug!(\"RootCollector: ItemFn({})\",\n+                           def_id_to_string(self.ccx, def_id, None));\n+\n+                    self.output.push(TransItem::Fn {\n+                        def_id: def_id,\n+                        substs: self.trans_empty_substs\n+                    });\n+                }\n+            }\n+        }\n+\n+        hir_visit::walk_item(self, item);\n+        self.enclosing_item = old_enclosing_item;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n+        match ii.node {\n+            hir::ImplItemKind::Method(hir::MethodSig {\n+                ref generics,\n+                constness,\n+                ..\n+            }, _) if constness == hir::Constness::NotConst => {\n+                let hir_map = &self.ccx.tcx().map;\n+                let parent_node_id = hir_map.get_parent_node(ii.id);\n+                let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n+                    &hir::Item {\n+                        node: hir::ItemImpl(_, _, ref generics, _, _, _),\n+                        ..\n+                    } => {\n+                        generics.is_type_parameterized()\n+                    }\n+                    _ => {\n+                        unreachable!()\n+                    }\n+                };\n+\n+                if !generics.is_type_parameterized() && !is_impl_generic {\n+                    let def_id = self.ccx.tcx().map.local_def_id(ii.id);\n+\n+                    debug!(\"RootCollector: MethodImplItem({})\",\n+                           def_id_to_string(self.ccx, def_id, None));\n+\n+                    self.output.push(TransItem::Fn {\n+                        def_id: def_id,\n+                        substs: self.trans_empty_substs\n+                    });\n+                }\n+            }\n+            _ => { /* Nothing to do here */ }\n+        }\n+\n+        hir_visit::walk_impl_item(self, ii)\n+    }\n+}\n+\n+fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                  item: &'tcx hir::Item,\n+                                                  trans_empty_substs: &'tcx Substs<'tcx>,\n+                                                  output: &mut Vec<TransItem<'tcx>>) {\n+    match item.node {\n+        hir::ItemImpl(_,\n+                      _,\n+                      ref generics,\n+                      _,\n+                      _,\n+                      ref items) => {\n+            if generics.is_type_parameterized() {\n+                return\n+            }\n+\n+            let tcx = ccx.tcx();\n+            let impl_def_id = tcx.map.local_def_id(item.id);\n+\n+            debug!(\"create_trans_items_for_default_impls(item={})\",\n+                   def_id_to_string(ccx, impl_def_id, None));\n+\n+            if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+                let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n+                let callee_substs = tcx.mk_substs(tcx.erase_regions(trait_ref.substs));\n+                let overridden_methods: FnvHashSet<_> = items.iter()\n+                                                             .map(|item| item.name)\n+                                                             .collect();\n+                for default_impl in default_impls {\n+                    if overridden_methods.contains(&default_impl.name) {\n+                        continue;\n+                    }\n+\n+                    if default_impl.generics.has_type_params(subst::FnSpace) {\n+                        continue;\n+                    }\n+\n+                    // The substitutions we have are on the impl, so we grab\n+                    // the method type from the impl to substitute into.\n+                    let mth = tcx.get_impl_method(impl_def_id,\n+                                                  callee_substs.clone(),\n+                                                  default_impl.name);\n+\n+                    assert!(mth.is_provided);\n+\n+                    let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n+                    if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n+                        continue;\n+                    }\n+\n+                    if can_have_local_instance(ccx, default_impl.def_id) {\n+                        let item = create_fn_trans_item(ccx,\n+                                                        default_impl.def_id,\n+                                                        callee_substs,\n+                                                        trans_empty_substs);\n+                        output.push(item);\n+                    }\n+                }\n+            }\n+        }\n+        _ => {\n+            unreachable!()\n+        }\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// TransItem String Keys\n+//=-----------------------------------------------------------------------------\n+\n+// The code below allows for producing a unique string key for a trans item.\n+// These keys are used by the handwritten auto-tests, so they need to be\n+// predictable and human-readable.\n+//\n+// Note: A lot of this could looks very similar to what's already in the\n+//       ppaux module. It would be good to refactor things so we only have one\n+//       parameterizable implementation for printing types.\n+\n+/// Same as `unique_type_name()` but with the result pushed onto the given\n+/// `output` parameter.\n+pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                       t: ty::Ty<'tcx>,\n+                                       output: &mut String) {\n+    match t.sty {\n+        ty::TyBool              => output.push_str(\"bool\"),\n+        ty::TyChar              => output.push_str(\"char\"),\n+        ty::TyStr               => output.push_str(\"str\"),\n+        ty::TyInt(ast::TyIs)    => output.push_str(\"isize\"),\n+        ty::TyInt(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::TyInt(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::TyInt(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::TyInt(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::TyUint(ast::TyUs)   => output.push_str(\"usize\"),\n+        ty::TyUint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::TyUint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::TyUint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::TyUint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::TyFloat(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::TyFloat(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::TyStruct(adt_def, substs) |\n+        ty::TyEnum(adt_def, substs) => {\n+            push_item_name(cx, adt_def.did, output);\n+            push_type_params(cx, substs, &[], output);\n+        },\n+        ty::TyTuple(ref component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_unique_type_name(cx, component_type, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::TyBox(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_unique_type_name(cx, inner_type, output);\n+            output.push('>');\n+        },\n+        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                hir::MutImmutable => output.push_str(\"const \"),\n+                hir::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_unique_type_name(cx, inner_type, output);\n+        },\n+        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == hir::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_unique_type_name(cx, inner_type, output);\n+        },\n+        ty::TyArray(inner_type, len) => {\n+            output.push('[');\n+            push_unique_type_name(cx, inner_type, output);\n+            output.push_str(&format!(\"; {}\", len));\n+            output.push(']');\n+        },\n+        ty::TySlice(inner_type) => {\n+            output.push('[');\n+            push_unique_type_name(cx, inner_type, output);\n+            output.push(']');\n+        },\n+        ty::TyTrait(ref trait_data) => {\n+            push_item_name(cx, trait_data.principal.skip_binder().def_id, output);\n+            push_type_params(cx,\n+                             &trait_data.principal.skip_binder().substs,\n+                             &trait_data.bounds.projection_bounds,\n+                             output);\n+        },\n+        ty::TyBareFn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == hir::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::syntax::abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = cx.tcx().erase_late_bound_regions(sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_unique_type_name(cx, parameter_type, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if result_type.is_nil() => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_unique_type_name(cx, result_type, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::TyClosure(def_id, ref closure_substs) => {\n+            push_item_name(cx, def_id, output);\n+            output.push_str(\"{\");\n+            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n+            output.push_str(\"}\");\n+            push_type_params(cx, closure_substs.func_substs, &[], output);\n+        }\n+        ty::TyError |\n+        ty::TyInfer(_) |\n+        ty::TyProjection(..) |\n+        ty::TyParam(_) => {\n+            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {:?}\", t));\n+        }\n+    }\n+}\n+\n+fn push_item_name(ccx: &CrateContext,\n+                  def_id: DefId,\n+                  output: &mut String) {\n+    if def_id.is_local() {\n+        let node_id = ccx.tcx().map.as_local_node_id(def_id).unwrap();\n+        let inlined_from = ccx.external_srcs()\n+                              .borrow()\n+                              .get(&node_id)\n+                              .map(|def_id| *def_id);\n+\n+        if let Some(extern_def_id) = inlined_from {\n+            push_item_name(ccx, extern_def_id, output);\n+            return;\n+        }\n+\n+        output.push_str(&ccx.link_meta().crate_name);\n+        output.push_str(\"::\");\n+    }\n+\n+    for part in ccx.tcx().def_path(def_id) {\n+        output.push_str(&format!(\"{}[{}]::\",\n+                        part.data.as_interned_str(),\n+                        part.disambiguator));\n+    }\n+\n+    output.pop();\n+    output.pop();\n+}\n+\n+fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                              substs: &Substs<'tcx>,\n+                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                              output: &mut String) {\n+    if substs.types.is_empty() && projections.is_empty() {\n+        return;\n+    }\n+\n+    output.push('<');\n+\n+    for &type_parameter in &substs.types {\n+        push_unique_type_name(cx, type_parameter, output);\n+        output.push_str(\", \");\n+    }\n+\n+    for projection in projections {\n+        let projection = projection.skip_binder();\n+        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n+        output.push_str(&name[..]);\n+        output.push_str(\"=\");\n+        push_unique_type_name(cx, projection.ty, output);\n+        output.push_str(\", \");\n+    }\n+\n+    output.pop();\n+    output.pop();\n+\n+    output.push('>');\n+}\n+\n+fn push_def_id_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              def_id: DefId,\n+                              substs: Option<&Substs<'tcx>>,\n+                              output: &mut String) {\n+    push_item_name(ccx, def_id, output);\n+\n+    if let Some(substs) = substs {\n+        push_type_params(ccx, substs, &[], output);\n+    }\n+}\n+\n+fn def_id_to_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              def_id: DefId,\n+                              substs: Option<&Substs<'tcx>>)\n+                              -> String {\n+    let mut output = String::new();\n+    push_def_id_as_string(ccx, def_id, substs, &mut output);\n+    output\n+}\n+\n+fn type_to_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            ty: ty::Ty<'tcx>)\n+                            -> String {\n+    let mut output = String::new();\n+    push_unique_type_name(ccx, ty, &mut output);\n+    output\n+}\n+\n+impl<'tcx> TransItem<'tcx> {\n+\n+    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n+        let hir_map = &ccx.tcx().map;\n+\n+        return match *self {\n+            TransItem::DropGlue(t) => {\n+                let mut s = String::with_capacity(32);\n+                s.push_str(\"drop-glue \");\n+                push_unique_type_name(ccx, t, &mut s);\n+                s\n+            }\n+            TransItem::Fn { def_id, ref substs } => {\n+                to_string_internal(ccx, \"fn \", def_id, Some(substs))\n+            },\n+            TransItem::Static(node_id) => {\n+                let def_id = hir_map.local_def_id(node_id);\n+                to_string_internal(ccx, \"static \", def_id, None)\n+            },\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                        prefix: &str,\n+                                        def_id: DefId,\n+                                        substs: Option<&Substs<'tcx>>)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            push_def_id_as_string(ccx, def_id, substs, &mut result);\n+            result\n+        }\n+    }\n+\n+    fn to_raw_string(&self) -> String {\n+        match *self {\n+            TransItem::DropGlue(t) => {\n+                format!(\"DropGlue({})\", t as *const _ as usize)\n+            }\n+            TransItem::Fn { def_id, substs } => {\n+                format!(\"Fn({:?}, {})\",\n+                         def_id,\n+                         substs as *const _ as usize)\n+            }\n+            TransItem::Static(id) => {\n+                format!(\"Static({:?})\", id)\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum TransItemState {\n+    PredictedAndGenerated,\n+    PredictedButNotGenerated,\n+    NotPredictedButGenerated,\n+}\n+\n+pub fn collecting_debug_information(ccx: &CrateContext) -> bool {\n+    return cfg!(debug_assertions) &&\n+           ccx.sess().opts.debugging_opts.print_trans_items.is_some();\n+}\n+\n+pub fn print_collection_results<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n+    use std::hash::{Hash, SipHasher, Hasher};\n+\n+    if !collecting_debug_information(ccx) {\n+        return;\n+    }\n+\n+    fn hash<T: Hash>(t: &T) -> u64 {\n+        let mut s = SipHasher::new();\n+        t.hash(&mut s);\n+        s.finish()\n+    }\n+\n+    let trans_items = ccx.translation_items().borrow();\n+\n+    {\n+        // Check for duplicate item keys\n+        let mut item_keys = FnvHashMap();\n+\n+        for (item, item_state) in trans_items.iter() {\n+            let k = item.to_string(&ccx);\n+\n+            if item_keys.contains_key(&k) {\n+                let prev: (TransItem, TransItemState) = item_keys[&k];\n+                debug!(\"DUPLICATE KEY: {}\", k);\n+                debug!(\" (1) {:?}, {:?}, hash: {}, raw: {}\",\n+                       prev.0,\n+                       prev.1,\n+                       hash(&prev.0),\n+                       prev.0.to_raw_string());\n+\n+                debug!(\" (2) {:?}, {:?}, hash: {}, raw: {}\",\n+                       *item,\n+                       *item_state,\n+                       hash(item),\n+                       item.to_raw_string());\n+            } else {\n+                item_keys.insert(k, (*item, *item_state));\n+            }\n+        }\n+    }\n+\n+    let mut predicted_but_not_generated = FnvHashSet();\n+    let mut not_predicted_but_generated = FnvHashSet();\n+    let mut predicted = FnvHashSet();\n+    let mut generated = FnvHashSet();\n+\n+    for (item, item_state) in trans_items.iter() {\n+        let item_key = item.to_string(&ccx);\n+\n+        match *item_state {\n+            TransItemState::PredictedAndGenerated => {\n+                predicted.insert(item_key.clone());\n+                generated.insert(item_key);\n+            }\n+            TransItemState::PredictedButNotGenerated => {\n+                predicted_but_not_generated.insert(item_key.clone());\n+                predicted.insert(item_key);\n+            }\n+            TransItemState::NotPredictedButGenerated => {\n+                not_predicted_but_generated.insert(item_key.clone());\n+                generated.insert(item_key);\n+            }\n+        }\n+    }\n+\n+    debug!(\"Total number of translation items predicted: {}\", predicted.len());\n+    debug!(\"Total number of translation items generated: {}\", generated.len());\n+    debug!(\"Total number of translation items predicted but not generated: {}\",\n+           predicted_but_not_generated.len());\n+    debug!(\"Total number of translation items not predicted but generated: {}\",\n+           not_predicted_but_generated.len());\n+\n+    if generated.len() > 0 {\n+        debug!(\"Failed to predict {}% of translation items\",\n+               (100 * not_predicted_but_generated.len()) / generated.len());\n+    }\n+    if generated.len() > 0 {\n+        debug!(\"Predict {}% too many translation items\",\n+               (100 * predicted_but_not_generated.len()) / generated.len());\n+    }\n+\n+    debug!(\"\");\n+    debug!(\"Not predicted but generated:\");\n+    debug!(\"============================\");\n+    for item in not_predicted_but_generated {\n+        debug!(\" - {}\", item);\n+    }\n+\n+    debug!(\"\");\n+    debug!(\"Predicted but not generated:\");\n+    debug!(\"============================\");\n+    for item in predicted_but_not_generated {\n+        debug!(\" - {}\", item);\n+    }\n+}"}, {"sha": "0d6324f3e899aba5fd49b838599022ad270a918e", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -30,6 +30,7 @@ use middle::def::Def;\n use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n+use trans::collector::{self, TransItem};\n use trans::common::{self, type_is_sized, ExprOrMethodCall, node_id_substs, C_nil, const_get_elt};\n use trans::common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n use trans::common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n@@ -1016,6 +1017,11 @@ pub fn trans_static(ccx: &CrateContext,\n                     id: ast::NodeId,\n                     attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n+\n+    if collector::collecting_debug_information(ccx) {\n+        ccx.record_translation_item_as_generated(TransItem::Static(id));\n+    }\n+\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);"}, {"sha": "e8868cdbcc759232ef04739f75a4fcf6a508f1b4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -10,6 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n+use rustc::dep_graph::{DepNode, DepTrackingMap, DepTrackingMapConfig};\n use middle::cstore::LinkMeta;\n use middle::def::ExportMap;\n use middle::def_id::DefId;\n@@ -23,6 +24,7 @@ use trans::debuginfo;\n use trans::declare;\n use trans::glue::DropGlueKind;\n use trans::monomorphize::MonoId;\n+use trans::collector::{TransItem, TransItemState};\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n@@ -33,6 +35,7 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n+use std::marker::PhantomData;\n use std::ptr;\n use std::rc::Rc;\n use syntax::ast;\n@@ -75,6 +78,8 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n \n     available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n     use_dll_storage_attrs: bool,\n+\n+    translation_items: RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -161,8 +166,23 @@ pub struct LocalCrateContext<'tcx> {\n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n \n-    trait_cache: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n-                                    traits::Vtable<'tcx, ()>>>,\n+    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n+}\n+\n+// Implement DepTrackingMapConfig for `trait_cache`\n+pub struct TraitSelectionCache<'tcx> {\n+    data: PhantomData<&'tcx ()>\n+}\n+\n+impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n+    type Key = ty::PolyTraitRef<'tcx>;\n+    type Value = traits::Vtable<'tcx, ()>;\n+    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode {\n+        ty::tls::with(|tcx| {\n+            let lifted_key = tcx.lift(key).unwrap();\n+            lifted_key.to_poly_trait_predicate().dep_node()\n+        })\n+    }\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n@@ -228,7 +248,6 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n     }\n }\n \n-\n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let mod_name = CString::new(mod_name).unwrap();\n@@ -337,6 +356,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n             available_drop_glues: RefCell::new(FnvHashMap()),\n             use_dll_storage_attrs: use_dll_storage_attrs,\n+            translation_items: RefCell::new(FnvHashMap()),\n         };\n \n         for i in 0..local_count {\n@@ -478,7 +498,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n-                trait_cache: RefCell::new(FnvHashMap()),\n+                trait_cache: RefCell::new(DepTrackingMap::new(shared.tcx\n+                                                                    .dep_graph\n+                                                                    .clone())),\n             };\n \n             local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n@@ -752,8 +774,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n-                                                     traits::Vtable<'tcx, ()>>> {\n+    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n         &self.local.trait_cache\n     }\n \n@@ -811,6 +832,24 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn mir_map(&self) -> &'b MirMap<'tcx> {\n         self.shared.mir_map\n     }\n+\n+    pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n+        &self.shared.translation_items\n+    }\n+\n+    pub fn record_translation_item_as_generated(&self, cgi: TransItem<'tcx>) {\n+        if self.sess().opts.debugging_opts.print_trans_items.is_none() {\n+            return;\n+        }\n+\n+        let mut codegen_items = self.translation_items().borrow_mut();\n+\n+        if codegen_items.contains_key(&cgi) {\n+            codegen_items.insert(cgi, TransItemState::PredictedAndGenerated);\n+        } else {\n+            codegen_items.insert(cgi, TransItemState::NotPredictedButGenerated);\n+        }\n+    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);"}, {"sha": "3de6447f4ee8e08b132d7394e4f120db3d013068", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -55,9 +55,7 @@ use back::abi;\n use llvm::{self, ValueRef, TypeKind};\n use middle::const_qualif::ConstQualif;\n use middle::def::Def;\n-use middle::lang_items::CoerceUnsizedTraitLangItem;\n-use middle::subst::{Substs, VecPerParamSpace};\n-use middle::traits;\n+use middle::subst::Substs;\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n@@ -500,24 +498,7 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let source = unpack_datum!(bcx, source.to_ref_datum(bcx));\n             assert!(target.kind.is_by_ref());\n \n-            let trait_substs = Substs::erased(VecPerParamSpace::new(vec![target.ty],\n-                                                                    vec![source.ty],\n-                                                                    Vec::new()));\n-            let trait_ref = ty::Binder(ty::TraitRef {\n-                def_id: langcall(bcx, Some(span), \"coercion\",\n-                                 CoerceUnsizedTraitLangItem),\n-                substs: bcx.tcx().mk_substs(trait_substs)\n-            });\n-\n-            let kind = match fulfill_obligation(bcx.ccx(), span, trait_ref) {\n-                traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-                    bcx.tcx().custom_coerce_unsized_kind(impl_def_id)\n-                }\n-                vtable => {\n-                    bcx.sess().span_bug(span, &format!(\"invalid CoerceUnsized vtable: {:?}\",\n-                                                       vtable));\n-                }\n-            };\n+            let kind = custom_coerce_unsize_info(bcx.ccx(), source.ty, target.ty);\n \n             let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n             let src_fields = match &*repr_source {"}, {"sha": "de4867398b99eba46b3a4e5aeede0b980c38e0c7", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -28,6 +28,7 @@ use trans::build::*;\n use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n+use trans::collector::{self, TransItem};\n use trans::common::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n@@ -88,7 +89,7 @@ pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn type_needs_drop<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_needs_drop<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     tcx.type_needs_drop_given_env(ty, &tcx.empty_parameter_environment())\n }\n \n@@ -496,6 +497,13 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n     let t = g.ty();\n+\n+    if collector::collecting_debug_information(bcx.ccx()) {\n+        bcx.ccx()\n+           .record_translation_item_as_generated(TransItem::DropGlue(bcx.tcx()\n+                                                                        .erase_regions(&t)));\n+    }\n+\n     let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");"}, {"sha": "b8f577f654c68eeb5737ccab8ac1f8ff6477681f", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -495,7 +495,23 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     impl_def_id: id,\n                     substs,\n                     nested: _ }) => {\n-                emit_vtable_methods(ccx, id, substs, param_substs).into_iter()\n+                let nullptr = C_null(Type::nil(ccx).ptr_to());\n+                get_vtable_methods(ccx, id, substs)\n+                    .into_iter()\n+                    .map(|opt_mth| {\n+                        match opt_mth {\n+                            Some(mth) => {\n+                                trans_fn_ref_with_substs(ccx,\n+                                                         mth.method.def_id,\n+                                                         ExprId(0),\n+                                                         param_substs,\n+                                                         mth.substs).val\n+                            }\n+                            None => nullptr\n+                        }\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .into_iter()\n             }\n             traits::VtableClosure(\n                 traits::VtableClosureData {\n@@ -549,18 +565,14 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 impl_id: DefId,\n-                                 substs: subst::Substs<'tcx>,\n-                                 param_substs: &'tcx subst::Substs<'tcx>)\n-                                 -> Vec<ValueRef>\n+pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    impl_id: DefId,\n+                                    substs: subst::Substs<'tcx>)\n+                                    -> Vec<Option<ty::util::ImplMethod<'tcx>>>\n {\n     let tcx = ccx.tcx();\n \n-    debug!(\"emit_vtable_methods(impl_id={:?}, substs={:?}, param_substs={:?})\",\n-           impl_id,\n-           substs,\n-           param_substs);\n+    debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n \n     let trt_id = match tcx.impl_trait_ref(impl_id) {\n         Some(t_id) => t_id.def_id,\n@@ -570,7 +582,6 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     tcx.populate_implementations_for_trait_if_necessary(trt_id);\n \n-    let nullptr = C_null(Type::nil(ccx).ptr_to());\n     let trait_item_def_ids = tcx.trait_item_def_ids(trt_id);\n     trait_item_def_ids\n         .iter()\n@@ -587,7 +598,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // method could never be called from this object, just supply\n         // null.\n         .map(|trait_method_def_id| {\n-            debug!(\"emit_vtable_methods: trait_method_def_id={:?}\",\n+            debug!(\"get_vtable_methods: trait_method_def_id={:?}\",\n                    trait_method_def_id);\n \n             let trait_method_type = match tcx.impl_or_trait_item(trait_method_def_id) {\n@@ -598,18 +609,18 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // Some methods cannot be called on an object; skip those.\n             if !traits::is_vtable_safe_method(tcx, trt_id, &trait_method_type) {\n-                debug!(\"emit_vtable_methods: not vtable safe\");\n-                return nullptr;\n+                debug!(\"get_vtable_methods: not vtable safe\");\n+                return None;\n             }\n \n-            debug!(\"emit_vtable_methods: trait_method_type={:?}\",\n+            debug!(\"get_vtable_methods: trait_method_type={:?}\",\n                    trait_method_type);\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n             let mth = tcx.get_impl_method(impl_id, substs.clone(), name);\n \n-            debug!(\"emit_vtable_methods: mth={:?}\", mth);\n+            debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n             // If this is a default method, it's possible that it\n             // relies on where clauses that do not hold for this\n@@ -619,16 +630,12 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             if mth.is_provided {\n                 let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n-                    debug!(\"emit_vtable_methods: predicates do not hold\");\n-                    return nullptr;\n+                    debug!(\"get_vtable_methods: predicates do not hold\");\n+                    return None;\n                 }\n             }\n \n-            trans_fn_ref_with_substs(ccx,\n-                                     mth.method.def_id,\n-                                     ExprId(0),\n-                                     param_substs,\n-                                     mth.substs).val\n+            Some(mth)\n         })\n         .collect()\n }"}, {"sha": "898f260f8df43edf4813f9a6df9ddb6be49b07fe", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -58,6 +58,7 @@ mod _match;\n mod meth;\n mod mir;\n mod monomorphize;\n+mod collector;\n mod tvec;\n mod type_;\n mod type_of;"}, {"sha": "49b8e43836e5227540e192fef1ccc863a4660b08", "filename": "src/test/auxiliary/cgu_export_trait_method.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fauxiliary%2Fcgu_export_trait_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fauxiliary%2Fcgu_export_trait_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcgu_export_trait_method.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub trait Trait : Sized {\n+    fn without_self() -> u32;\n+    fn without_self_default() -> u32 { 0 }\n+\n+    fn with_default_impl(self) -> Self { self }\n+    fn with_default_impl_generic<T>(self, x: T) -> (Self, T) { (self, x) }\n+\n+    fn without_default_impl(x: u32) -> (Self, u32);\n+    fn without_default_impl_generic<T>(x: T) -> (Self, T);\n+}\n+\n+impl Trait for char {\n+    fn without_self() -> u32 { 2 }\n+    fn without_default_impl(x: u32) -> (Self, u32) { ('c', x) }\n+    fn without_default_impl_generic<T>(x: T) -> (Self, T) { ('c', x) }\n+}\n+\n+impl Trait for u32 {\n+    fn without_self() -> u32 { 1 }\n+    fn without_default_impl(x: u32) -> (Self, u32) { (0, x) }\n+    fn without_default_impl_generic<T>(x: T) -> (Self, T) { (0, x) }\n+}"}, {"sha": "944d85db508062ee56e99d84f1d4537aef54ff02", "filename": "src/test/auxiliary/cgu_extern_closures.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fauxiliary%2Fcgu_extern_closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fauxiliary%2Fcgu_extern_closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcgu_extern_closures.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+#[inline]\n+pub fn inlined_fn(x: i32, y: i32) -> i32 {\n+\n+    let closure = |a, b| { a + b };\n+\n+    closure(x, y)\n+}\n+\n+pub fn inlined_fn_generic<T>(x: i32, y: i32, z: T) -> (i32, T) {\n+\n+    let closure = |a, b| { a + b };\n+\n+    (closure(x, y), z)\n+}\n+\n+pub fn non_inlined_fn(x: i32, y: i32) -> i32 {\n+\n+    let closure = |a, b| { a + b };\n+\n+    closure(x, y)\n+}"}, {"sha": "83bb65bc2b7f0a917dc9d13e31a8d80660d0b629", "filename": "src/test/auxiliary/cgu_generic_function.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fauxiliary%2Fcgu_generic_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fauxiliary%2Fcgu_generic_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcgu_generic_function.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+struct Struct(u32);\n+\n+pub fn foo<T>(x: T) -> (T, u32, i8) {\n+    let (x, Struct(y)) = bar(x);\n+    (x, y, 2)\n+}\n+\n+\n+fn bar<T>(x: T) -> (T, Struct) {\n+    let _ = not_exported_and_not_generic(0);\n+    (x, Struct(1))\n+}\n+\n+// These should not contribute to the codegen items of other crates.\n+#[inline(never)]\n+pub fn exported_but_not_generic(x: i32) -> i64 {\n+    x as i64\n+}\n+\n+#[inline(never)]\n+fn not_exported_and_not_generic(x: u32) -> u64 {\n+    x as u64\n+}\n+"}, {"sha": "32b07d42fec44313da37dc77faa3c6e09782340b", "filename": "src/test/codegen-units/cross-crate-closures.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fcross-crate-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fcross-crate-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fcross-crate-closures.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+// aux-build:cgu_extern_closures.rs\n+extern crate cgu_extern_closures;\n+\n+//~ TRANS_ITEM fn cross_crate_closures::main[0]\n+fn main() {\n+\n+    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn[0]\n+    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn[0]::{{closure}}[0]\n+    let _ = cgu_extern_closures::inlined_fn(1, 2);\n+\n+    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn_generic[0]<i32>\n+    //~ TRANS_ITEM fn cgu_extern_closures[0]::inlined_fn_generic[0]::{{closure}}[0]<i32>\n+    let _ = cgu_extern_closures::inlined_fn_generic(3, 4, 5i32);\n+\n+    // Nothing should be generated for this call, we just link to the instance instance\n+    // in the extern crate.\n+    let _ = cgu_extern_closures::non_inlined_fn(6, 7);\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "82d940a15485251871bec35627077f4be9c115cc", "filename": "src/test/codegen-units/cross-crate-generic-functions.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fcross-crate-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fcross-crate-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fcross-crate-generic-functions.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+// aux-build:cgu_generic_function.rs\n+extern crate cgu_generic_function;\n+\n+//~ TRANS_ITEM fn cross_crate_generic_functions::main[0]\n+fn main()\n+{\n+    //~ TRANS_ITEM fn cgu_generic_function[0]::bar[0]<u32>\n+    //~ TRANS_ITEM fn cgu_generic_function[0]::foo[0]<u32>\n+    let _ = cgu_generic_function::foo(1u32);\n+\n+    //~ TRANS_ITEM fn cgu_generic_function[0]::bar[0]<u64>\n+    //~ TRANS_ITEM fn cgu_generic_function[0]::foo[0]<u64>\n+    let _ = cgu_generic_function::foo(2u64);\n+\n+    // This should not introduce a codegen item\n+    let _ = cgu_generic_function::exported_but_not_generic(3);\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "aa1f6b06c813594f9bb6beeec02a68673e38a32f", "filename": "src/test/codegen-units/cross-crate-trait-method.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fcross-crate-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fcross-crate-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fcross-crate-trait-method.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+// aux-build:cgu_export_trait_method.rs\n+extern crate cgu_export_trait_method;\n+\n+use cgu_export_trait_method::Trait;\n+\n+//~ TRANS_ITEM fn cross_crate_trait_method::main[0]\n+fn main()\n+{\n+    // The object code of these methods is contained in the external crate, so\n+    // calling them should *not* introduce codegen items in the current crate.\n+    let _: (u32, u32) = Trait::without_default_impl(0);\n+    let _: (char, u32) = Trait::without_default_impl(0);\n+\n+    // Currently, no object code is generated for trait methods with default\n+    // implemenations, unless they are actually called from somewhere. Therefore\n+    // we cannot import the implementations and have to create our own inline.\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl[0]<u32>\n+    let _ = Trait::with_default_impl(0u32);\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl[0]<char>\n+    let _ = Trait::with_default_impl('c');\n+\n+\n+\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<u32, &str>\n+    let _ = Trait::with_default_impl_generic(0u32, \"abc\");\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<u32, bool>\n+    let _ = Trait::with_default_impl_generic(0u32, false);\n+\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<char, i16>\n+    let _ = Trait::with_default_impl_generic('x', 1i16);\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::Trait[0]::with_default_impl_generic[0]<char, i32>\n+    let _ = Trait::with_default_impl_generic('y', 0i32);\n+\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::u32.Trait[0]::without_default_impl_generic[0]<char>\n+    let _: (u32, char) = Trait::without_default_impl_generic('c');\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::u32.Trait[0]::without_default_impl_generic[0]<bool>\n+    let _: (u32, bool) = Trait::without_default_impl_generic(false);\n+\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::char.Trait[0]::without_default_impl_generic[0]<char>\n+    let _: (char, char) = Trait::without_default_impl_generic('c');\n+    //~ TRANS_ITEM fn cgu_export_trait_method[0]::char.Trait[0]::without_default_impl_generic[0]<bool>\n+    let _: (char, bool) = Trait::without_default_impl_generic(false);\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "3a9d56c2a8bf70973235695e30709ee5574314e4", "filename": "src/test/codegen-units/function-as-argument.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ffunction-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ffunction-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ffunction-as-argument.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+fn take_fn_once<T1, T2, F: FnOnce(T1, T2)>(f: F, x: T1, y: T2) {\n+    (f)(x, y)\n+}\n+\n+fn function<T1, T2>(_: T1, _: T2) {}\n+\n+fn take_fn_pointer<T1, T2>(f: fn(T1, T2), x: T1, y: T2) {\n+    (f)(x, y)\n+}\n+\n+//~ TRANS_ITEM fn function_as_argument::main[0]\n+fn main() {\n+\n+    //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<u32, &str, fn(u32, &str)>\n+    //~ TRANS_ITEM fn function_as_argument::function[0]<u32, &str>\n+    take_fn_once(function, 0u32, \"abc\");\n+\n+    //~ TRANS_ITEM fn function_as_argument::take_fn_once[0]<char, f64, fn(char, f64)>\n+    //~ TRANS_ITEM fn function_as_argument::function[0]<char, f64>\n+    take_fn_once(function, 'c', 0f64);\n+\n+    //~ TRANS_ITEM fn function_as_argument::take_fn_pointer[0]<i32, ()>\n+    //~ TRANS_ITEM fn function_as_argument::function[0]<i32, ()>\n+    take_fn_pointer(function, 0i32, ());\n+\n+    //~ TRANS_ITEM fn function_as_argument::take_fn_pointer[0]<f32, i64>\n+    //~ TRANS_ITEM fn function_as_argument::function[0]<f32, i64>\n+    take_fn_pointer(function, 0f32, 0i64);\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "f89d6e61bc5527e9f34420b100513df0c5c914c2", "filename": "src/test/codegen-units/generic-drop-glue.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fgeneric-drop-glue.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+struct StructWithDrop<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+\n+impl<T1, T2> Drop for StructWithDrop<T1, T2> {\n+    fn drop(&mut self) {}\n+}\n+\n+struct StructNoDrop<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+\n+enum EnumWithDrop<T1, T2> {\n+    A(T1),\n+    B(T2)\n+}\n+\n+impl<T1, T2> Drop for EnumWithDrop<T1, T2> {\n+    fn drop(&mut self) {}\n+}\n+\n+enum EnumNoDrop<T1, T2> {\n+    A(T1),\n+    B(T2)\n+}\n+\n+\n+struct NonGenericNoDrop(i32);\n+\n+struct NonGenericWithDrop(i32);\n+//~ TRANS_ITEM drop-glue generic_drop_glue::NonGenericWithDrop[0]\n+\n+impl Drop for NonGenericWithDrop {\n+    fn drop(&mut self) {}\n+//~ TRANS_ITEM fn generic_drop_glue::NonGenericWithDrop.Drop[0]::drop[0]\n+}\n+\n+//~ TRANS_ITEM fn generic_drop_glue::main[0]\n+fn main() {\n+    //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<i8, char>\n+    //~ TRANS_ITEM fn generic_drop_glue::StructWithDrop<T1, T2>.Drop[0]::drop[0]<i8, char>\n+    let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n+\n+    //~ TRANS_ITEM drop-glue generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n+    //~ TRANS_ITEM fn generic_drop_glue::StructWithDrop<T1, T2>.Drop[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n+    let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n+\n+    // Should produce no drop glue\n+    let _ = StructNoDrop { x: 'a', y: 0u32 }.x;\n+\n+    // This is supposed to generate drop-glue because it contains a field that\n+    // needs to be dropped.\n+    //~ TRANS_ITEM drop-glue generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>\n+    let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n+\n+    //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<i32, i64>\n+    //~ TRANS_ITEM fn generic_drop_glue::EnumWithDrop<T1, T2>.Drop[0]::drop[0]<i32, i64>\n+    let _ = match EnumWithDrop::A::<i32, i64>(0) {\n+        EnumWithDrop::A(x) => x,\n+        EnumWithDrop::B(x) => x as i32\n+    };\n+\n+    //~ TRANS_ITEM drop-glue generic_drop_glue::EnumWithDrop[0]<f64, f32>\n+    //~ TRANS_ITEM fn generic_drop_glue::EnumWithDrop<T1, T2>.Drop[0]::drop[0]<f64, f32>\n+    let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n+        EnumWithDrop::A(x) => x,\n+        EnumWithDrop::B(x) => x as f64\n+    };\n+\n+    let _ = match EnumNoDrop::A::<i32, i64>(0) {\n+        EnumNoDrop::A(x) => x,\n+        EnumNoDrop::B(x) => x as i32\n+    };\n+\n+    let _ = match EnumNoDrop::B::<f64, f32>(1.0) {\n+        EnumNoDrop::A(x) => x,\n+        EnumNoDrop::B(x) => x as f64\n+    };\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "5ec1f7fbc3ca385addeb66aa98c9797c3beab8f9", "filename": "src/test/codegen-units/generic-functions.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fgeneric-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fgeneric-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fgeneric-functions.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+fn foo1<T1>(a: T1) -> (T1, u32) {\n+    (a, 1)\n+}\n+\n+fn foo2<T1, T2>(a: T1, b: T2) -> (T1, T2) {\n+    (a, b)\n+}\n+\n+fn foo3<T1, T2, T3>(a: T1, b: T2, c: T3) -> (T1, T2, T3) {\n+    (a, b, c)\n+}\n+\n+// This function should be instantiated even if no used\n+//~ TRANS_ITEM fn generic_functions::lifetime_only[0]\n+pub fn lifetime_only<'a>(a: &'a u32) -> &'a u32 {\n+    a\n+}\n+\n+//~ TRANS_ITEM fn generic_functions::main[0]\n+fn main() {\n+    //~ TRANS_ITEM fn generic_functions::foo1[0]<i32>\n+    let _ = foo1(2i32);\n+    //~ TRANS_ITEM fn generic_functions::foo1[0]<i64>\n+    let _ = foo1(2i64);\n+    //~ TRANS_ITEM fn generic_functions::foo1[0]<&str>\n+    let _ = foo1(\"abc\");\n+    //~ TRANS_ITEM fn generic_functions::foo1[0]<char>\n+    let _ = foo1('v');\n+\n+    //~ TRANS_ITEM fn generic_functions::foo2[0]<i32, i32>\n+    let _ = foo2(2i32, 2i32);\n+    //~ TRANS_ITEM fn generic_functions::foo2[0]<i64, &str>\n+    let _ = foo2(2i64, \"abc\");\n+    //~ TRANS_ITEM fn generic_functions::foo2[0]<&str, usize>\n+    let _ = foo2(\"a\", 2usize);\n+    //~ TRANS_ITEM fn generic_functions::foo2[0]<char, ()>\n+    let _ = foo2('v', ());\n+\n+    //~ TRANS_ITEM fn generic_functions::foo3[0]<i32, i32, i32>\n+    let _ = foo3(2i32, 2i32, 2i32);\n+    //~ TRANS_ITEM fn generic_functions::foo3[0]<i64, &str, char>\n+    let _ = foo3(2i64, \"abc\", 'c');\n+    //~ TRANS_ITEM fn generic_functions::foo3[0]<i16, &str, usize>\n+    let _ = foo3(0i16, \"a\", 2usize);\n+    //~ TRANS_ITEM fn generic_functions::foo3[0]<char, (), ()>\n+    let _ = foo3('v', (), ());\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "6e6bb5cbf53c867271c0b8e412dca1e676d497e4", "filename": "src/test/codegen-units/generic-impl.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fgeneric-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fgeneric-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fgeneric-impl.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+struct Struct<T> {\n+    x: T,\n+    f: fn(x: T) -> T,\n+}\n+\n+fn id<T>(x: T) -> T { x }\n+\n+impl<T> Struct<T> {\n+\n+    fn new(x: T) -> Struct<T> {\n+        Struct {\n+            x: x,\n+            f: id\n+        }\n+    }\n+\n+    fn get<T2>(self, x: T2) -> (T, T2) {\n+        (self.x, x)\n+    }\n+}\n+\n+pub struct LifeTimeOnly<'a> {\n+    _a: &'a u32\n+}\n+\n+impl<'a> LifeTimeOnly<'a> {\n+\n+    //~ TRANS_ITEM fn generic_impl::LifeTimeOnly<'a>[0]::foo[0]\n+    pub fn foo(&self) {}\n+    //~ TRANS_ITEM fn generic_impl::LifeTimeOnly<'a>[0]::bar[0]\n+    pub fn bar(&'a self) {}\n+    //~ TRANS_ITEM fn generic_impl::LifeTimeOnly<'a>[0]::baz[0]\n+    pub fn baz<'b>(&'b self) {}\n+\n+    pub fn non_instantiated<T>(&self) {}\n+}\n+\n+\n+//~ TRANS_ITEM fn generic_impl::main[0]\n+fn main() {\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<i32>\n+    //~ TRANS_ITEM fn generic_impl::id[0]<i32>\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<i32, i16>\n+    let _ = Struct::new(0i32).get(0i16);\n+\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<i64>\n+    //~ TRANS_ITEM fn generic_impl::id[0]<i64>\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<i64, i16>\n+    let _ = Struct::new(0i64).get(0i16);\n+\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<char>\n+    //~ TRANS_ITEM fn generic_impl::id[0]<char>\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<char, i16>\n+    let _ = Struct::new('c').get(0i16);\n+\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<&str>\n+    //~ TRANS_ITEM fn generic_impl::id[0]<&str>\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::get[0]<generic_impl::Struct[0]<&str>, i16>\n+    let _ = Struct::new(Struct::new(\"str\")).get(0i16);\n+\n+    //~ TRANS_ITEM fn generic_impl::Struct<T>[0]::new[0]<generic_impl::Struct[0]<&str>>\n+    //~ TRANS_ITEM fn generic_impl::id[0]<generic_impl::Struct[0]<&str>>\n+    let _ = (Struct::new(Struct::new(\"str\")).f)(Struct::new(\"str\"));\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "e17a1a7094f2fa0e881db4917c3b0e4758eb2751", "filename": "src/test/codegen-units/impl-in-non-instantiated-generic.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fimpl-in-non-instantiated-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fimpl-in-non-instantiated-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fimpl-in-non-instantiated-generic.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+trait SomeTrait {\n+    fn foo(&self);\n+}\n+\n+// This function is never instantiated but the contained impl must still be\n+// discovered.\n+pub fn generic_function<T>(x: T) -> (T, i32) {\n+    impl SomeTrait for i64 {\n+        //~ TRANS_ITEM fn impl_in_non_instantiated_generic::generic_function[0]::i64.SomeTrait[0]::foo[0]\n+        fn foo(&self) {}\n+    }\n+\n+    (x, 0)\n+}\n+\n+//~ TRANS_ITEM fn impl_in_non_instantiated_generic::main[0]\n+fn main() {\n+    0i64.foo();\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "46587b2b0a1b2b9c355558cb89809387945fa01d", "filename": "src/test/codegen-units/instantiation-through-vtable.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Finstantiation-through-vtable.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+trait Trait {\n+    fn foo(&self) -> u32;\n+    fn bar(&self);\n+}\n+\n+struct Struct<T> {\n+    _a: T\n+}\n+\n+impl<T> Trait for Struct<T> {\n+    fn foo(&self) -> u32 { 0 }\n+    fn bar(&self) {}\n+}\n+\n+//~ TRANS_ITEM fn instantiation_through_vtable::main[0]\n+fn main() {\n+    let s1 = Struct { _a: 0u32 };\n+\n+    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::foo[0]<u32>\n+    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::bar[0]<u32>\n+    let _ = &s1 as &Trait;\n+\n+    let s1 = Struct { _a: 0u64 };\n+    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::foo[0]<u64>\n+    //~ TRANS_ITEM fn instantiation_through_vtable::Struct<T>.Trait[0]::bar[0]<u64>\n+    let _ = &s1 as &Trait;\n+}"}, {"sha": "a2dcd81b6750c847a9143e08a93c2a934e8f026d", "filename": "src/test/codegen-units/items-within-generic-items.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fitems-within-generic-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fitems-within-generic-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitems-within-generic-items.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+fn generic_fn<T>(a: T) -> (T, i32) {\n+    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]::nested_fn[0]\n+    fn nested_fn(a: i32) -> i32 {\n+        a + 1\n+    }\n+\n+    let x = {\n+        //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]::nested_fn[1]\n+        fn nested_fn(a: i32) -> i32 {\n+            a + 2\n+        }\n+\n+        1 + nested_fn(1)\n+    };\n+\n+    return (a, x + nested_fn(0));\n+}\n+\n+//~ TRANS_ITEM fn items_within_generic_items::main[0]\n+fn main() {\n+    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<i64>\n+    let _ = generic_fn(0i64);\n+    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<u16>\n+    let _ = generic_fn(0u16);\n+    //~ TRANS_ITEM fn items_within_generic_items::generic_fn[0]<i8>\n+    let _ = generic_fn(0i8);\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "bf8804e12ce492d97ecabe44c71a228750eef4fd", "filename": "src/test/codegen-units/non-generic-closures.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fnon-generic-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fnon-generic-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fnon-generic-closures.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+//~ TRANS_ITEM fn non_generic_closures::temporary[0]\n+fn temporary() {\n+    //~ TRANS_ITEM fn non_generic_closures::temporary[0]::{{closure}}[0]\n+    (|a: u32| {\n+        let _ = a;\n+    })(4);\n+}\n+\n+//~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_but_not_executed[0]\n+fn assigned_to_variable_but_not_executed() {\n+    //~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_but_not_executed[0]::{{closure}}[0]\n+    let _x = |a: i16| {\n+        let _ = a + 1;\n+    };\n+}\n+\n+//~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_directly[0]\n+fn assigned_to_variable_executed_indirectly() {\n+    //~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_directly[0]::{{closure}}[0]\n+    let f = |a: i32| {\n+        let _ = a + 2;\n+    };\n+    run_closure(&f);\n+}\n+\n+//~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_indirectly[0]\n+fn assigned_to_variable_executed_directly() {\n+    //~ TRANS_ITEM fn non_generic_closures::assigned_to_variable_executed_indirectly[0]::{{closure}}[0]\n+    let f = |a: i64| {\n+        let _ = a + 3;\n+    };\n+    f(4);\n+}\n+\n+//~ TRANS_ITEM fn non_generic_closures::main[0]\n+fn main() {\n+    temporary();\n+    assigned_to_variable_but_not_executed();\n+    assigned_to_variable_executed_directly();\n+    assigned_to_variable_executed_indirectly();\n+}\n+\n+//~ TRANS_ITEM fn non_generic_closures::run_closure[0]\n+fn run_closure(f: &Fn(i32)) {\n+    f(3);\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "a82e85b7a5315c3fb4d8b34d3d13f281ef295557", "filename": "src/test/codegen-units/non-generic-drop-glue.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fnon-generic-drop-glue.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+//~ TRANS_ITEM drop-glue non_generic_drop_glue::StructWithDrop[0]\n+struct StructWithDrop {\n+    x: i32\n+}\n+\n+impl Drop for StructWithDrop {\n+    //~ TRANS_ITEM fn non_generic_drop_glue::StructWithDrop.Drop[0]::drop[0]\n+    fn drop(&mut self) {}\n+}\n+\n+struct StructNoDrop {\n+    x: i32\n+}\n+\n+//~ TRANS_ITEM drop-glue non_generic_drop_glue::EnumWithDrop[0]\n+enum EnumWithDrop {\n+    A(i32)\n+}\n+\n+impl Drop for EnumWithDrop {\n+    //~ TRANS_ITEM fn non_generic_drop_glue::EnumWithDrop.Drop[0]::drop[0]\n+    fn drop(&mut self) {}\n+}\n+\n+enum EnumNoDrop {\n+    A(i32)\n+}\n+\n+//~ TRANS_ITEM fn non_generic_drop_glue::main[0]\n+fn main() {\n+    let _ = StructWithDrop { x: 0 }.x;\n+    let _ = StructNoDrop { x: 0 }.x;\n+    let _ = match EnumWithDrop::A(0) {\n+        EnumWithDrop::A(x) => x\n+    };\n+    let _ = match EnumNoDrop::A(0) {\n+        EnumNoDrop::A(x) => x\n+    };\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "687ce7fa05cb45fd7d3891401a6d3e1ce0f4d132", "filename": "src/test/codegen-units/non-generic-functions.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fnon-generic-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fnon-generic-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fnon-generic-functions.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+//~ TRANS_ITEM fn non_generic_functions::foo[0]\n+fn foo() {\n+    {\n+        //~ TRANS_ITEM fn non_generic_functions::foo[0]::foo[0]\n+        fn foo() {}\n+        foo();\n+    }\n+\n+    {\n+        //~ TRANS_ITEM fn non_generic_functions::foo[0]::foo[1]\n+        fn foo() {}\n+        foo();\n+    }\n+}\n+\n+//~ TRANS_ITEM fn non_generic_functions::bar[0]\n+fn bar() {\n+    //~ TRANS_ITEM fn non_generic_functions::bar[0]::baz[0]\n+    fn baz() {}\n+    baz();\n+}\n+\n+struct Struct { _x: i32 }\n+\n+impl Struct {\n+    //~ TRANS_ITEM fn non_generic_functions::Struct[0]::foo[0]\n+    fn foo() {\n+        {\n+            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::foo[0]::foo[0]\n+            fn foo() {}\n+            foo();\n+        }\n+\n+        {\n+            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::foo[0]::foo[1]\n+            fn foo() {}\n+            foo();\n+        }\n+    }\n+\n+    //~ TRANS_ITEM fn non_generic_functions::Struct[0]::bar[0]\n+    fn bar(&self) {\n+        {\n+            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::bar[0]::foo[0]\n+            fn foo() {}\n+            foo();\n+        }\n+\n+        {\n+            //~ TRANS_ITEM fn non_generic_functions::Struct[0]::bar[0]::foo[1]\n+            fn foo() {}\n+            foo();\n+        }\n+    }\n+}\n+\n+//~ TRANS_ITEM fn non_generic_functions::main[0]\n+fn main() {\n+    foo();\n+    bar();\n+    Struct::foo();\n+    let x = Struct { _x: 0 };\n+    x.bar();\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "134110222f392433a8db5aac9e25181da6f3cb99", "filename": "src/test/codegen-units/overloaded-operators.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Foverloaded-operators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Foverloaded-operators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Foverloaded-operators.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+use std::ops::{Index, IndexMut, Add, Deref};\n+\n+pub struct Indexable {\n+    data: [u8; 3]\n+}\n+\n+impl Index<usize> for Indexable {\n+    type Output = u8;\n+\n+    //~ TRANS_ITEM fn overloaded_operators::Indexable.Index<usize>[0]::index[0]\n+    fn index(&self, index: usize) -> &Self::Output {\n+        if index >= 3 {\n+            &self.data[0]\n+        } else {\n+            &self.data[index]\n+        }\n+    }\n+}\n+\n+impl IndexMut<usize> for Indexable {\n+    //~ TRANS_ITEM fn overloaded_operators::Indexable.IndexMut<usize>[0]::index_mut[0]\n+    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n+        if index >= 3 {\n+            &mut self.data[0]\n+        } else {\n+            &mut self.data[index]\n+        }\n+    }\n+}\n+\n+\n+//~ TRANS_ITEM fn overloaded_operators::Equatable.::std::cmp::PartialEq[0]::eq[0]\n+//~ TRANS_ITEM fn overloaded_operators::Equatable.::std::cmp::PartialEq[0]::ne[0]\n+#[derive(PartialEq)]\n+pub struct Equatable(u32);\n+\n+\n+impl Add<u32> for Equatable {\n+    type Output = u32;\n+\n+    //~ TRANS_ITEM fn overloaded_operators::Equatable.Add<u32>[0]::add[0]\n+    fn add(self, rhs: u32) -> u32 {\n+        self.0 + rhs\n+    }\n+}\n+\n+impl Deref for Equatable {\n+    type Target = u32;\n+\n+    //~ TRANS_ITEM fn overloaded_operators::Equatable.Deref[0]::deref[0]\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "7c8b2b117ef7ce51fb1bed5d26a7a66155b497e4", "filename": "src/test/codegen-units/statics-and-consts.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fstatics-and-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Fstatics-and-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fstatics-and-consts.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+static STATIC1: i64 = {\n+    const STATIC1_CONST1: i64 = 2;\n+    1 + CONST1 as i64 + STATIC1_CONST1\n+};\n+\n+const CONST1: i64 = {\n+    const CONST1_1: i64 = {\n+        const CONST1_1_1: i64 = 2;\n+        CONST1_1_1 + 1\n+    };\n+    1 + CONST1_1 as i64\n+};\n+\n+fn foo() {\n+    let _ = {\n+        const CONST2: i64 = 0;\n+        static STATIC2: i64 = CONST2;\n+\n+        let x = {\n+            const CONST2: i64 = 1;\n+            static STATIC2: i64 = CONST2;\n+            STATIC2\n+        };\n+\n+        x + STATIC2\n+    };\n+\n+    let _ = {\n+        const CONST2: i64 = 0;\n+        static STATIC2: i64 = CONST2;\n+        STATIC2\n+    };\n+}\n+\n+fn main() {\n+    foo();\n+    let _ = STATIC1;\n+}\n+\n+//~ TRANS_ITEM static statics_and_consts::STATIC1[0]\n+\n+//~ TRANS_ITEM fn statics_and_consts::foo[0]\n+//~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[0]\n+//~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[1]\n+//~ TRANS_ITEM static statics_and_consts::foo[0]::STATIC2[2]\n+\n+//~ TRANS_ITEM fn statics_and_consts::main[0]\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "590859f15a3e1ce3a267e42f3f288101a075b2e1", "filename": "src/test/codegen-units/trait-implementations.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftrait-implementations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftrait-implementations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftrait-implementations.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+pub trait SomeTrait {\n+    fn foo(&self);\n+    fn bar<T>(&self, x: T);\n+}\n+\n+impl SomeTrait for i64 {\n+\n+    //~ TRANS_ITEM fn trait_implementations::i64.SomeTrait[0]::foo[0]\n+    fn foo(&self) {}\n+\n+    fn bar<T>(&self, _: T) {}\n+}\n+\n+impl SomeTrait for i32 {\n+\n+    //~ TRANS_ITEM fn trait_implementations::i32.SomeTrait[0]::foo[0]\n+    fn foo(&self) {}\n+\n+    fn bar<T>(&self, _: T) {}\n+}\n+\n+pub trait SomeGenericTrait<T> {\n+    fn foo(&self, x: T);\n+    fn bar<T2>(&self, x: T, y: T2);\n+}\n+\n+// Concrete impl of generic trait\n+impl SomeGenericTrait<u32> for f64 {\n+\n+    //~ TRANS_ITEM fn trait_implementations::f64.SomeGenericTrait<u32>[0]::foo[0]\n+    fn foo(&self, _: u32) {}\n+\n+    fn bar<T2>(&self, _: u32, _: T2) {}\n+}\n+\n+// Generic impl of generic trait\n+impl<T> SomeGenericTrait<T> for f32 {\n+\n+    fn foo(&self, _: T) {}\n+    fn bar<T2>(&self, _: T, _: T2) {}\n+}\n+\n+//~ TRANS_ITEM fn trait_implementations::main[0]\n+fn main() {\n+   //~ TRANS_ITEM fn trait_implementations::i32.SomeTrait[0]::bar[0]<char>\n+   0i32.bar('x');\n+\n+   //~ TRANS_ITEM fn trait_implementations::f64.SomeGenericTrait<u32>[0]::bar[0]<&str>\n+   0f64.bar(0u32, \"&str\");\n+\n+   //~ TRANS_ITEM fn trait_implementations::f64.SomeGenericTrait<u32>[0]::bar[0]<()>\n+   0f64.bar(0u32, ());\n+\n+   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::foo[0]<char>\n+   0f32.foo('x');\n+\n+   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::foo[0]<i64>\n+   0f32.foo(-1i64);\n+\n+   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::bar[0]<u32, ()>\n+   0f32.bar(0u32, ());\n+\n+   //~ TRANS_ITEM fn trait_implementations::f32.SomeGenericTrait<T>[0]::bar[0]<&str, &str>\n+   0f32.bar(\"&str\", \"&str\");\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "fdf63df5471110b90197e4c8b05db63111ed14f4", "filename": "src/test/codegen-units/trait-method-as-argument.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftrait-method-as-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftrait-method-as-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftrait-method-as-argument.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+trait Trait : Sized {\n+    fn foo(self) -> Self { self }\n+}\n+\n+impl Trait for u32 {\n+    fn foo(self) -> u32 { self }\n+}\n+\n+impl Trait for char {\n+}\n+\n+fn take_foo_once<T, F: FnOnce(T) -> T>(f: F, arg: T) -> T {\n+    (f)(arg)\n+}\n+\n+fn take_foo<T, F: Fn(T) -> T>(f: F, arg: T) -> T {\n+    (f)(arg)\n+}\n+\n+fn take_foo_mut<T, F: FnMut(T) -> T>(mut f: F, arg: T) -> T {\n+    (f)(arg)\n+}\n+\n+//~ TRANS_ITEM fn trait_method_as_argument::main[0]\n+fn main() {\n+    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<u32, fn(u32) -> u32>\n+    //~ TRANS_ITEM fn trait_method_as_argument::u32.Trait[0]::foo[0]\n+    take_foo_once(Trait::foo, 0u32);\n+\n+    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_once[0]<char, fn(char) -> char>\n+    //~ TRANS_ITEM fn trait_method_as_argument::Trait[0]::foo[0]<char>\n+    take_foo_once(Trait::foo, 'c');\n+\n+    //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<u32, fn(u32) -> u32>\n+    take_foo(Trait::foo, 0u32);\n+\n+    //~ TRANS_ITEM fn trait_method_as_argument::take_foo[0]<char, fn(char) -> char>\n+    take_foo(Trait::foo, 'c');\n+\n+    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<u32, fn(u32) -> u32>\n+    take_foo_mut(Trait::foo, 0u32);\n+\n+    //~ TRANS_ITEM fn trait_method_as_argument::take_foo_mut[0]<char, fn(char) -> char>\n+    take_foo_mut(Trait::foo, 'c');\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "2b3b83cb7ec631bca0e173ceccea19002a54f018", "filename": "src/test/codegen-units/trait-method-default-impl.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftrait-method-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftrait-method-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftrait-method-default-impl.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+trait SomeTrait {\n+    fn foo(&self) { }\n+    fn bar<T>(&self, x: T) -> T { x }\n+}\n+\n+impl SomeTrait for i8 {\n+    // take the default implementations\n+\n+    // For the non-generic foo(), we should generate a codegen-item even if it\n+    // is not called anywhere\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeTrait[0]::foo[0]<i8>\n+}\n+\n+trait SomeGenericTrait<T1> {\n+    fn foo(&self) { }\n+    fn bar<T2>(&self, x: T1, y: T2) {}\n+}\n+\n+// Non-generic impl of generic trait\n+impl SomeGenericTrait<u64> for i32 {\n+    // take the default implementations\n+\n+    // For the non-generic foo(), we should generate a codegen-item even if it\n+    // is not called anywhere\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::foo[0]<u64, i32>\n+}\n+\n+// Non-generic impl of generic trait\n+impl<T1> SomeGenericTrait<T1> for u32 {\n+    // take the default implementations\n+    // since nothing is monomorphic here, nothing should be generated unless used somewhere.\n+}\n+\n+//~ TRANS_ITEM fn trait_method_default_impl::main[0]\n+fn main() {\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeTrait[0]::bar[0]<i8, char>\n+    let _ = 1i8.bar('c');\n+\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeTrait[0]::bar[0]<i8, &str>\n+    let _ = 2i8.bar(\"&str\");\n+\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u64, i32, char>\n+    0i32.bar(0u64, 'c');\n+\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<u64, i32, &str>\n+    0i32.bar(0u64, \"&str\");\n+\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i8, u32, &[char; 1]>\n+    0u32.bar(0i8, &['c']);\n+\n+    //~ TRANS_ITEM fn trait_method_default_impl::SomeGenericTrait[0]::bar[0]<i16, u32, ()>\n+    0u32.bar(0i16, ());\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "6982cb9299a550997b5cacf07f630597e5735c3e", "filename": "src/test/codegen-units/transitive-drop-glue.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftransitive-drop-glue.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n+struct Root(Intermediate);\n+//~ TRANS_ITEM drop-glue transitive_drop_glue::Intermediate[0]\n+struct Intermediate(Leaf);\n+//~ TRANS_ITEM drop-glue transitive_drop_glue::Leaf[0]\n+struct Leaf;\n+\n+impl Drop for Leaf {\n+    //~ TRANS_ITEM fn transitive_drop_glue::Leaf.Drop[0]::drop[0]\n+    fn drop(&mut self) {}\n+}\n+\n+//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n+struct RootGen<T>(IntermediateGen<T>);\n+//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n+struct IntermediateGen<T>(LeafGen<T>);\n+//~ TRANS_ITEM drop-glue transitive_drop_glue::Root[0]\n+struct LeafGen<T>(T);\n+\n+impl<T> Drop for LeafGen<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+//~ TRANS_ITEM fn transitive_drop_glue::main[0]\n+fn main() {\n+\n+    let _ = Root(Intermediate(Leaf));\n+\n+    //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<u32>\n+    //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<u32>\n+    //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<u32>\n+    //~ TRANS_ITEM fn transitive_drop_glue::LeafGen<T>.Drop[0]::drop[0]<u32>\n+    let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n+\n+    //~ TRANS_ITEM drop-glue transitive_drop_glue::RootGen[0]<i16>\n+    //~ TRANS_ITEM drop-glue transitive_drop_glue::IntermediateGen[0]<i16>\n+    //~ TRANS_ITEM drop-glue transitive_drop_glue::LeafGen[0]<i16>\n+    //~ TRANS_ITEM fn transitive_drop_glue::LeafGen<T>.Drop[0]::drop[0]<i16>\n+    let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n+}"}, {"sha": "87fcb00eab8c2424dacdc168ef023763783acf4a", "filename": "src/test/codegen-units/tuple-drop-glue.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Ftuple-drop-glue.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+\n+//~ TRANS_ITEM drop-glue tuple_drop_glue::Dropped[0]\n+struct Dropped;\n+\n+impl Drop for Dropped {\n+    //~ TRANS_ITEM fn tuple_drop_glue::Dropped.Drop[0]::drop[0]\n+    fn drop(&mut self) {}\n+}\n+\n+//~ TRANS_ITEM fn tuple_drop_glue::main[0]\n+fn main() {\n+    //~ TRANS_ITEM drop-glue (u32, tuple_drop_glue::Dropped[0])\n+    let x = (0u32, Dropped);\n+\n+    //~ TRANS_ITEM drop-glue (i16, (tuple_drop_glue::Dropped[0], bool))\n+    //~ TRANS_ITEM drop-glue (tuple_drop_glue::Dropped[0], bool)\n+    let x = (0i16, (Dropped, true));\n+}"}, {"sha": "dd90d32858f110568a261774f12c050629cfe2cd", "filename": "src/test/codegen-units/unsizing.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Funsizing.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![deny(dead_code)]\n+#![feature(coerce_unsized)]\n+#![feature(unsize)]\n+\n+use std::marker::Unsize;\n+use std::ops::CoerceUnsized;\n+\n+trait Trait {\n+    fn foo(&self);\n+}\n+\n+// Simple Case\n+impl Trait for bool {\n+    fn foo(&self) {}\n+}\n+\n+impl Trait for char {\n+    fn foo(&self) {}\n+}\n+\n+// Struct Field Case\n+struct Struct<T: ?Sized> {\n+    _a: u32,\n+    _b: i32,\n+    _c: T\n+}\n+\n+impl Trait for f64 {\n+    fn foo(&self) {}\n+}\n+\n+// Custom Coercion Case\n+impl Trait for u32 {\n+    fn foo(&self) {}\n+}\n+\n+#[derive(Clone, Copy)]\n+struct Wrapper<T: ?Sized>(*const T);\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n+\n+//~ TRANS_ITEM fn unsizing::main[0]\n+fn main()\n+{\n+    // simple case\n+    let bool_sized = &true;\n+    //~ TRANS_ITEM fn unsizing::bool.Trait[0]::foo[0]\n+    let _bool_unsized = bool_sized as &Trait;\n+\n+    let char_sized = &true;\n+    //~ TRANS_ITEM fn unsizing::char.Trait[0]::foo[0]\n+    let _char_unsized = char_sized as &Trait;\n+\n+    // struct field\n+    let struct_sized = &Struct {\n+        _a: 1,\n+        _b: 2,\n+        _c: 3.0f64\n+    };\n+    //~ TRANS_ITEM fn unsizing::f64.Trait[0]::foo[0]\n+    let _struct_unsized = struct_sized as &Struct<Trait>;\n+\n+    // custom coercion\n+    let wrapper_sized = Wrapper(&0u32);\n+    //~ TRANS_ITEM fn unsizing::u32.Trait[0]::foo[0]\n+    let _wrapper_sized = wrapper_sized as Wrapper<Trait>;\n+}"}, {"sha": "a4c5099ab9751e4d223a5ec0c1c4a6766371a470", "filename": "src/test/codegen-units/unused-traits-and-generics.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Funused-traits-and-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c2933d4406bc43b55d490722bf4ca062ab64eb/src%2Ftest%2Fcodegen-units%2Funused-traits-and-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Funused-traits-and-generics.rs?ref=53c2933d4406bc43b55d490722bf4ca062ab64eb", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![crate_type=\"lib\"]\n+#![deny(dead_code)]\n+\n+// This test asserts that no codegen items are generated for generic items that\n+// are never instantiated in the local crate.\n+\n+pub trait Trait {\n+    fn foo() {}\n+    fn bar(&self) {}\n+}\n+\n+pub fn foo<T: Copy>(x: T) -> (T, T) {\n+    (x, x)\n+}\n+\n+pub struct Struct<T> {\n+    x: T\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn foo(self) -> T {\n+        self.x\n+    }\n+\n+    pub fn bar() {}\n+}\n+\n+pub enum Enum<T> {\n+    A(T),\n+    B { x: T }\n+}\n+\n+impl<T> Enum<T> {\n+    pub fn foo(self) -> T {\n+        match self {\n+            Enum::A(x) => x,\n+            Enum::B { x } => x,\n+        }\n+    }\n+\n+    pub fn bar() {}\n+}\n+\n+pub struct TupleStruct<T>(T);\n+\n+impl<T> TupleStruct<T> {\n+    pub fn foo(self) -> T {\n+        self.0\n+    }\n+\n+    pub fn bar() {}\n+}\n+\n+pub type Pair<T> = (T, T);\n+\n+pub struct NonGeneric {\n+    x: i32\n+}\n+\n+impl NonGeneric {\n+    pub fn foo(self) -> i32 {\n+        self.x\n+    }\n+\n+    pub fn generic_foo<T>(&self, x: T) -> (T, i32) {\n+        (x, self.x)\n+    }\n+\n+    pub fn generic_bar<T: Copy>(x: T) -> (T, T) {\n+        (x, x)\n+    }\n+}\n+\n+// Only the non-generic methods should be instantiated:\n+//~ TRANS_ITEM fn unused_traits_and_generics::NonGeneric[0]::foo[0]\n+//~ TRANS_ITEM drop-glue i8"}]}