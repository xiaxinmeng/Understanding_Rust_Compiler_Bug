{"sha": "a86f72d9a2adc6d65f2ba0990caca35c1a3f622d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NmY3MmQ5YTJhZGM2ZDY1ZjJiYTA5OTBjYWNhMzVjMWEzZjYyMmQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-06T17:32:32Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-26T01:41:25Z"}, "message": "libs: stabilize iter module\n\nThis is an initial pass at stabilizing the `iter` module. The module is\nfairly large, but is also pretty polished, so most of the stabilization\nleaves things as they are.\n\nSome changes:\n\n* Due to the new object safety rules, various traits needs to be split\n  into object-safe traits and extension traits. This includes `Iterator`\n  itself. While splitting up the traits adds some complexity, it will\n  also increase flexbility: once we have automatic impls of `Trait` for\n  trait objects over `Trait`, then things like the iterator adapters\n  will all work with trait objects.\n\n* Iterator adapters that use up the entire iterator now take it by\n  value, which makes the semantics more clear and helps catch bugs. Due\n  to the splitting of Iterator, this does not affect trait objects. If\n  the underlying iterator is still desired for some reason, `by_ref` can\n  be used. (Note: this change had no fallout in the Rust distro except\n  for the useless mut lint.)\n\n* In general, extension traits new and old are following an [in-progress\n  convention](https://github.com/rust-lang/rfcs/pull/445). As such, they\n  are marked `unstable`.\n\n* As usual, anything involving closures is `unstable` pending unboxed\n  closures.\n\n* A few of the more esoteric/underdeveloped iterator forms (like\n  `RandomAccessIterator` and `MutableDoubleEndedIterator`, along with\n  various unfolds) are left experimental for now.\n\n* The `order` submodule is left `experimental` because it will hopefully\n  be replaced by generalized comparison traits.\n\n* \"Leaf\" iterators (like `Repeat` and `Counter`) are uniformly\n  constructed by free fns at the module level. That's because the types\n  are not otherwise of any significance (if we had `impl Trait`, you\n  wouldn't want to define a type at all).\n\nCloses #17701\n\nDue to renamings and splitting of traits, this is a:\n\n[breaking-change]", "tree": {"sha": "4c2e9ea934e9a95fb7f3c098cf851e75019c786f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c2e9ea934e9a95fb7f3c098cf851e75019c786f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a86f72d9a2adc6d65f2ba0990caca35c1a3f622d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a86f72d9a2adc6d65f2ba0990caca35c1a3f622d", "html_url": "https://github.com/rust-lang/rust/commit/a86f72d9a2adc6d65f2ba0990caca35c1a3f622d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a86f72d9a2adc6d65f2ba0990caca35c1a3f622d/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eedfc077964b811315589d9a70293d3ff2eb0e1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eedfc077964b811315589d9a70293d3ff2eb0e1d", "html_url": "https://github.com/rust-lang/rust/commit/eedfc077964b811315589d9a70293d3ff2eb0e1d"}], "stats": {"total": 243, "additions": 199, "deletions": 44}, "files": [{"sha": "496e7979b726eeec3def4f13d6fee4ad05769d18", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 199, "deletions": 44, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/a86f72d9a2adc6d65f2ba0990caca35c1a3f622d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86f72d9a2adc6d65f2ba0990caca35c1a3f622d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a86f72d9a2adc6d65f2ba0990caca35c1a3f622d", "patch": "@@ -72,12 +72,14 @@ use uint;\n #[deprecated = \"renamed to Extend\"] pub use self::Extend as Extendable;\n \n /// Conversion from an `Iterator`\n+#[unstable = \"may be replaced by a more general conversion trait\"]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n     fn from_iter<T: Iterator<A>>(iterator: T) -> Self;\n }\n \n /// A type growable from an `Iterator` implementation\n+#[unstable = \"just renamed as part of collections reform\"]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n     fn extend<T: Iterator<A>>(&mut self, iterator: T);\n@@ -94,6 +96,7 @@ pub trait Extend<A> {\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n+#[unstable = \"just split up for object safety\"]\n pub trait Iterator<A> {\n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n     fn next(&mut self) -> Option<A>;\n@@ -104,7 +107,11 @@ pub trait Iterator<A> {\n     /// does not fit within a `uint`.\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n+}\n \n+#[unstable = \"new convention for extension traits\"]\n+/// An extension trait providing numerous methods applicable to all iterators.\n+pub trait IteratorExt<A>: Iterator<A> {\n     /// Chain this iterator with another, returning a new iterator which will\n     /// finish iterating over the current iterator, and then it will iterate\n     /// over the other specified iterator.\n@@ -120,6 +127,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> {\n         Chain{a: self, b: other, flag: false}\n     }\n@@ -140,6 +148,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> {\n         Zip{a: self, b: other}\n     }\n@@ -157,6 +166,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn map<'r, B>(self, f: |A|: 'r -> B) -> Map<'r, A, B, Self> {\n         Map{iter: self, f: f}\n     }\n@@ -174,6 +184,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn filter<'r>(self, predicate: |&A|: 'r -> bool) -> Filter<'r, A, Self> {\n         Filter{iter: self, predicate: predicate}\n     }\n@@ -191,6 +202,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn filter_map<'r, B>(self, f: |A|: 'r -> Option<B>) -> FilterMap<'r, A, B, Self> {\n         FilterMap { iter: self, f: f }\n     }\n@@ -209,6 +221,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn enumerate(self) -> Enumerate<Self> {\n         Enumerate{iter: self, count: 0}\n     }\n@@ -232,6 +245,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn peekable(self) -> Peekable<A, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n@@ -251,6 +265,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn skip_while<'r>(self, predicate: |&A|: 'r -> bool) -> SkipWhile<'r, A, Self> {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n@@ -269,6 +284,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures, may want to require peek\"]\n     fn take_while<'r>(self, predicate: |&A|: 'r -> bool) -> TakeWhile<'r, A, Self> {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n@@ -286,6 +302,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn skip(self, n: uint) -> Skip<Self> {\n         Skip{iter: self, n: n}\n     }\n@@ -304,6 +321,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[stable]\n     fn take(self, n: uint) -> Take<Self> {\n         Take{iter: self, n: n}\n     }\n@@ -329,6 +347,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn scan<'r, St, B>(self, initial_state: St, f: |&mut St, A|: 'r -> Option<B>)\n         -> Scan<'r, A, B, Self, St> {\n         Scan{iter: self, f: f, state: initial_state}\n@@ -353,6 +372,7 @@ pub trait Iterator<A> {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn flat_map<'r, B, U: Iterator<B>>(self, f: |A|: 'r -> U)\n         -> FlatMap<'r, A, Self, U> {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n@@ -386,6 +406,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n+    #[stable]\n     fn fuse(self) -> Fuse<Self> {\n         Fuse{iter: self, done: false}\n     }\n@@ -409,6 +430,7 @@ pub trait Iterator<A> {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn inspect<'r>(self, f: |&A|: 'r) -> Inspect<'r, A, Self> {\n         Inspect{iter: self, f: f}\n     }\n@@ -428,6 +450,7 @@ pub trait Iterator<A> {\n     /// // xs.next() is now `5`\n     /// assert!(xs.next() == Some(5));\n     /// ```\n+    #[stable]\n     fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n         ByRef{iter: self}\n     }\n@@ -443,8 +466,9 @@ pub trait Iterator<A> {\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n-    fn collect<B: FromIterator<A>>(&mut self) -> B {\n-        FromIterator::from_iter(self.by_ref())\n+    #[unstable = \"waiting for general conversion traits, just changed to take self by value\"]\n+    fn collect<B: FromIterator<A>>(self) -> B {\n+        FromIterator::from_iter(self)\n     }\n \n     /// Loops through `n` iterations, returning the `n`th element of the\n@@ -459,6 +483,7 @@ pub trait Iterator<A> {\n     /// assert!(it.nth(2) == None);\n     /// ```\n     #[inline]\n+    #[stable]\n     fn nth(&mut self, mut n: uint) -> Option<A> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n@@ -477,9 +502,10 @@ pub trait Iterator<A> {\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n-    fn last(&mut self) -> Option<A> {\n+    #[unstable = \"just changed to take self by value\"]\n+    fn last(mut self) -> Option<A> {\n         let mut last = None;\n-        for x in *self { last = Some(x); }\n+        for x in self { last = Some(x); }\n         last\n     }\n \n@@ -493,9 +519,10 @@ pub trait Iterator<A> {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B {\n+    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    fn fold<B>(mut self, init: B, f: |B, A| -> B) -> B {\n         let mut accum = init;\n-        for x in *self {\n+        for x in self {\n             accum = f(accum, x);\n         }\n         accum\n@@ -509,10 +536,10 @@ pub trait Iterator<A> {\n     /// let a = [1i, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.count() == 5);\n-    /// assert!(it.count() == 0);\n     /// ```\n     #[inline]\n-    fn count(&mut self) -> uint {\n+    #[unstable = \"just changed to take self by value\"]\n+    fn count(self) -> uint {\n         self.fold(0, |cnt, _x| cnt + 1)\n     }\n \n@@ -526,8 +553,9 @@ pub trait Iterator<A> {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    fn all(&mut self, f: |A| -> bool) -> bool {\n-        for x in *self { if !f(x) { return false; } }\n+    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    fn all(mut self, f: |A| -> bool) -> bool {\n+        for x in self { if !f(x) { return false; } }\n         true\n     }\n \n@@ -543,6 +571,7 @@ pub trait Iterator<A> {\n     /// assert!(!it.any(|x| *x == 3));\n     /// ```\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn any(&mut self, f: |A| -> bool) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -552,6 +581,7 @@ pub trait Iterator<A> {\n     ///\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn find(&mut self, predicate: |&A| -> bool) -> Option<A> {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n@@ -561,6 +591,7 @@ pub trait Iterator<A> {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n+    #[unstable = \"waiting for unboxed closures\"]\n     fn position(&mut self, predicate: |A| -> bool) -> Option<uint> {\n         let mut i = 0;\n         for x in *self {\n@@ -584,7 +615,8 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    fn max_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n+    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    fn max_by<B: Ord>(self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |max: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match max {\n@@ -610,7 +642,8 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    fn min_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n+    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    fn min_by<B: Ord>(self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |min: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match min {\n@@ -625,14 +658,22 @@ pub trait Iterator<A> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n+impl<A, I> IteratorExt<A> for I where I: Iterator<A> {}\n+\n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n+#[unstable = \"recently split into two traits\"]\n pub trait DoubleEndedIterator<A>: Iterator<A> {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n     fn next_back(&mut self) -> Option<A>;\n+}\n \n+/// Extension methods for double-ended iterators.\n+#[unstable = \"new extension trait convention\"]\n+pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> {\n     /// Change the direction of the iterator\n     ///\n     /// The flipped iterator swaps the ends on an iterator that can already\n@@ -646,18 +687,24 @@ pub trait DoubleEndedIterator<A>: Iterator<A> {\n     /// Note: Random access with flipped indices still only applies to the first\n     /// `uint::MAX` elements of the original iterator.\n     #[inline]\n+    #[stable]\n     fn rev(self) -> Rev<Self> {\n         Rev{iter: self}\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n+impl<A, I> DoubleEndedIteratorExt<A> for I where I: DoubleEndedIterator<A> {}\n+\n /// A double-ended iterator yielding mutable references\n+#[experimental = \"not widely used\"]\n pub trait MutableDoubleEndedIterator {\n     // FIXME: #5898: should be called `reverse`\n     /// Use an iterator to reverse a container in-place\n     fn reverse_(&mut self);\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, A:'a, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for T {\n     // FIXME: #5898: should be called `reverse`\n     /// Use an iterator to reverse a container in-place\n@@ -678,6 +725,7 @@ impl<'a, A:'a, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n+#[experimental = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n pub trait RandomAccessIterator<A>: Iterator<A> {\n     /// Return the number of indexable elements. At most `std::uint::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n@@ -694,15 +742,16 @@ pub trait RandomAccessIterator<A>: Iterator<A> {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n-pub trait ExactSize<A> : DoubleEndedIterator<A> {\n+#[unstable = \"could move DoubleEndedIterator bound onto rposition with method-level where clauses\"]\n+pub trait ExactSizeIterator<A> : DoubleEndedIterator<A> {\n     /// Return the index of the last element satisfying the specified predicate\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n     fn rposition(&mut self, predicate: |A| -> bool) -> Option<uint> {\n         let len = self.len();\n         for i in range(0, len).rev() {\n-            if predicate(self.next_back().expect(\"rposition: incorrect ExactSize\")) {\n+            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n                 return Some(i);\n             }\n         }\n@@ -724,31 +773,41 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-impl<A, T: ExactSize<A>> ExactSize<(uint, A)> for Enumerate<T> {}\n-impl<'a, A, T: ExactSize<A>> ExactSize<A> for Inspect<'a, A, T> {}\n-impl<A, T: ExactSize<A>> ExactSize<A> for Rev<T> {}\n-impl<'a, A, B, T: ExactSize<A>> ExactSize<B> for Map<'a, A, B, T> {}\n-impl<A, B, T: ExactSize<A>, U: ExactSize<B>> ExactSize<(A, B)> for Zip<T, U> {}\n+#[unstable = \"trait is unstable\"]\n+impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<(uint, A)> for Enumerate<T> {}\n+#[unstable = \"trait is unstable\"]\n+impl<'a, A, T: ExactSizeIterator<A>> ExactSizeIterator<A> for Inspect<'a, A, T> {}\n+#[unstable = \"trait is unstable\"]\n+impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<A> for Rev<T> {}\n+#[unstable = \"trait is unstable\"]\n+impl<'a, A, B, T: ExactSizeIterator<A>> ExactSizeIterator<B> for Map<'a, A, B, T> {}\n+#[unstable = \"trait is unstable\"]\n+impl<A, B, T, U> ExactSizeIterator<(A, B)> for Zip<T, U>\n+    where T: ExactSizeIterator<A>, U: ExactSizeIterator<B> {}\n \n /// An double-ended iterator with the direction inverted\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Rev<T> {\n     iter: T\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Rev<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Rev<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.iter.next() }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n     for Rev<T> {\n     #[inline]\n@@ -762,23 +821,27 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n \n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct ByRef<'a, T:'a> {\n     iter: &'a mut T\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: Iterator<A>+'a> Iterator<A> for ByRef<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.iter.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: DoubleEndedIterator<A>+'a> DoubleEndedIterator<A> for ByRef<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.iter.next_back() }\n }\n \n /// A trait for iterators over elements which can be added together\n+#[experimental = \"needs to be re-evaluated as part of numerics reform\"]\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n@@ -791,14 +854,15 @@ pub trait AdditiveIterator<A> {\n     /// let mut it = a.iter().map(|&x| x);\n     /// assert!(it.sum() == 15);\n     /// ```\n-    fn sum(&mut self) -> A;\n+    fn sum(self) -> A;\n }\n \n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n+        #[experimental = \"trait is experimental\"]\n         impl<T: Iterator<$A>> AdditiveIterator<$A> for T {\n             #[inline]\n-            fn sum(&mut self) -> $A {\n+            fn sum(self) -> $A {\n                 self.fold($init, |acc, x| acc + x)\n             }\n         }\n@@ -818,6 +882,7 @@ impl_additive!(f32,  0.0)\n impl_additive!(f64,  0.0)\n \n /// A trait for iterators over elements which can be multiplied together.\n+#[experimental = \"needs to be re-evaluated as part of numerics reform\"]\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n@@ -833,14 +898,15 @@ pub trait MultiplicativeIterator<A> {\n     /// assert!(factorial(1) == 1);\n     /// assert!(factorial(5) == 120);\n     /// ```\n-    fn product(&mut self) -> A;\n+    fn product(self) -> A;\n }\n \n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n+        #[experimental = \"trait is experimental\"]\n         impl<T: Iterator<$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n-            fn product(&mut self) -> $A {\n+            fn product(self) -> $A {\n                 self.fold($init, |acc, x| acc * x)\n             }\n         }\n@@ -860,7 +926,8 @@ impl_multiplicative!(f32,  1.0)\n impl_multiplicative!(f64,  1.0)\n \n /// A trait for iterators over elements which can be compared to one another.\n-pub trait OrdIterator<A> {\n+#[unstable = \"recently renamed for new extension trait conventions\"]\n+pub trait IteratorOrdExt<A> {\n     /// Consumes the entire iterator to return the maximum element.\n     ///\n     /// # Example\n@@ -869,7 +936,7 @@ pub trait OrdIterator<A> {\n     /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n-    fn max(&mut self) -> Option<A>;\n+    fn max(self) -> Option<A>;\n \n     /// Consumes the entire iterator to return the minimum element.\n     ///\n@@ -879,7 +946,7 @@ pub trait OrdIterator<A> {\n     /// let a = [1i, 2, 3, 4, 5];\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n-    fn min(&mut self) -> Option<A>;\n+    fn min(self) -> Option<A>;\n \n     /// `min_max` finds the minimum and maximum elements in the iterator.\n     ///\n@@ -914,12 +981,13 @@ pub trait OrdIterator<A> {\n     /// let v = [1i, 1, 1, 1];\n     /// assert!(v.iter().min_max() == MinMax(&1, &1));\n     /// ```\n-    fn min_max(&mut self) -> MinMaxResult<A>;\n+    fn min_max(self) -> MinMaxResult<A>;\n }\n \n-impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n+#[unstable = \"trait is unstable\"]\n+impl<A: Ord, T: Iterator<A>> IteratorOrdExt<A> for T {\n     #[inline]\n-    fn max(&mut self) -> Option<A> {\n+    fn max(self) -> Option<A> {\n         self.fold(None, |max, x| {\n             match max {\n                 None    => Some(x),\n@@ -929,7 +997,7 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n     }\n \n     #[inline]\n-    fn min(&mut self) -> Option<A> {\n+    fn min(self) -> Option<A> {\n         self.fold(None, |min, x| {\n             match min {\n                 None    => Some(x),\n@@ -938,7 +1006,7 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n         })\n     }\n \n-    fn min_max(&mut self) -> MinMaxResult<A> {\n+    fn min_max(mut self) -> MinMaxResult<A> {\n         let (mut min, mut max) = match self.next() {\n             None => return NoElements,\n             Some(x) => {\n@@ -982,8 +1050,9 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n     }\n }\n \n-/// `MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.\n+/// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[deriving(Clone, PartialEq, Show)]\n+#[unstable = \"waiting on namespaced enum conventions\"]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -995,6 +1064,7 @@ pub enum MinMaxResult<T> {\n     MinMax(T, T)\n }\n \n+#[stable]\n impl<T: Clone> MinMaxResult<T> {\n     /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n     /// `None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n@@ -1025,14 +1095,15 @@ impl<T: Clone> MinMaxResult<T> {\n }\n \n /// A trait for iterators that contain cloneable elements\n-pub trait CloneIteratorExt<A> {\n+#[unstable = \"recently renamed for extension trait conventions\"]\n+pub trait IteratorCloneExt<A> {\n     /// Creates an iterator that clones the elements it yields. Useful for converting an\n     /// Iterator<&T> to an Iterator<T>.\n     fn cloned(self) -> Cloned<Self>;\n }\n \n-\n-impl<A: Clone, D: Deref<A>, I: Iterator<D>> CloneIteratorExt<A> for I {\n+#[unstable = \"trait is unstable\"]\n+impl<A: Clone, D: Deref<A>, I: Iterator<D>> IteratorCloneExt<A> for I {\n     fn cloned(self) -> Cloned<I> {\n         Cloned { it: self }\n     }\n@@ -1060,40 +1131,45 @@ impl<A: Clone, D: Deref<A>, I: DoubleEndedIterator<D>>\n     }\n }\n \n-impl<A: Clone, D: Deref<A>, I: ExactSize<D>> ExactSize<A> for Cloned<I> {}\n+#[unstable = \"trait is unstable\"]\n+impl<A: Clone, D: Deref<A>, I: ExactSizeIterator<D>> ExactSizeIterator<A> for Cloned<I> {}\n \n-/// A trait for iterators that are cloneable.\n-pub trait CloneableIterator {\n+#[unstable = \"recently renamed for extension trait conventions\"]\n+/// An extension trait for cloneable iterators.\n+pub trait CloneIteratorExt {\n     /// Repeats an iterator endlessly\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::iter::{CloneableIterator, count};\n+    /// use std::iter::{CloneIteratorExt, count};\n     ///\n     /// let a = count(1i,1i).take(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n     /// ```\n+    #[stable]\n     fn cycle(self) -> Cycle<Self>;\n }\n \n-impl<A, T: Clone + Iterator<A>> CloneableIterator for T {\n+impl<A, I> CloneIteratorExt for I where I: Iterator<A> + Clone {\n     #[inline]\n-    fn cycle(self) -> Cycle<T> {\n+    fn cycle(self) -> Cycle<I> {\n         Cycle{orig: self.clone(), iter: self}\n     }\n }\n \n /// An iterator that repeats endlessly\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Cycle<T> {\n     orig: T,\n     iter: T,\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1114,6 +1190,7 @@ impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1141,12 +1218,14 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n /// An iterator which strings two iterators together\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Chain<T, U> {\n     a: T,\n     b: U,\n     flag: bool,\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1178,6 +1257,7 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: DoubleEndedIterator<A>, U: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n for Chain<T, U> {\n     #[inline]\n@@ -1189,6 +1269,7 @@ for Chain<T, U> {\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A, T: RandomAccessIterator<A>, U: RandomAccessIterator<A>> RandomAccessIterator<A>\n for Chain<T, U> {\n     #[inline]\n@@ -1211,11 +1292,13 @@ for Chain<T, U> {\n /// An iterator which iterates two other iterators simultaneously\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Zip<T, U> {\n     a: T,\n     b: U\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<(A, B)> {\n@@ -1246,7 +1329,8 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n     }\n }\n \n-impl<A, B, T: ExactSize<A>, U: ExactSize<B>> DoubleEndedIterator<(A, B)>\n+#[unstable = \"trait is unstable\"]\n+impl<A, B, T: ExactSizeIterator<A>, U: ExactSizeIterator<B>> DoubleEndedIterator<(A, B)>\n for Zip<T, U> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(A, B)> {\n@@ -1268,6 +1352,7 @@ for Zip<T, U> {\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A, B, T: RandomAccessIterator<A>, U: RandomAccessIterator<B>>\n RandomAccessIterator<(A, B)> for Zip<T, U> {\n     #[inline]\n@@ -1289,6 +1374,7 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n \n /// An iterator which maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Map<'a, A, B, T> {\n     iter: T,\n     f: |A|: 'a -> B\n@@ -1304,6 +1390,7 @@ impl<'a, A, B, T> Map<'a, A, B, T> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, B, T: Iterator<A>> Iterator<B> for Map<'a, A, B, T> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n@@ -1317,6 +1404,7 @@ impl<'a, A, B, T: Iterator<A>> Iterator<B> for Map<'a, A, B, T> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B> for Map<'a, A, B, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n@@ -1325,6 +1413,7 @@ impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B> for Map<'a, A,\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A, B, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1340,11 +1429,13 @@ impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A\n \n /// An iterator which filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Filter<'a, A, T> {\n     iter: T,\n     predicate: |&A|: 'a -> bool\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: Iterator<A>> Iterator<A> for Filter<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1365,6 +1456,7 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for Filter<'a, A, T> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'a, A, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -1379,11 +1471,13 @@ impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'a, A,\n \n /// An iterator which uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct FilterMap<'a, A, B, T> {\n     iter: T,\n     f: |A|: 'a -> Option<B>\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'a, A, B, T> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n@@ -1403,6 +1497,7 @@ impl<'a, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'a, A, B, T> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n for FilterMap<'a, A, B, T> {\n     #[inline]\n@@ -1420,11 +1515,13 @@ for FilterMap<'a, A, B, T> {\n /// An iterator which yields the current count and the element during iteration\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Enumerate<T> {\n     iter: T,\n     count: uint\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, A)> {\n@@ -1444,7 +1541,8 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n     }\n }\n \n-impl<A, T: ExactSize<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T> {\n+#[unstable = \"trait is unstable\"]\n+impl<A, T: ExactSizeIterator<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, A)> {\n         match self.iter.next_back() {\n@@ -1457,6 +1555,7 @@ impl<A, T: ExactSize<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T> {\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerate<T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1474,11 +1573,13 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Peekable<A, T> {\n     iter: T,\n     peeked: Option<A>,\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1502,6 +1603,7 @@ impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n     }\n }\n \n+#[stable]\n impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n@@ -1525,12 +1627,14 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n \n /// An iterator which rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct SkipWhile<'a, A, T> {\n     iter: T,\n     flag: bool,\n     predicate: |&A|: 'a -> bool\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1552,12 +1656,14 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n \n /// An iterator which only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct TakeWhile<'a, A, T> {\n     iter: T,\n     flag: bool,\n     predicate: |&A|: 'a -> bool\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: Iterator<A>> Iterator<A> for TakeWhile<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1588,11 +1694,13 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for TakeWhile<'a, A, T> {\n /// An iterator which skips over `n` elements of `iter`.\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Skip<T> {\n     iter: T,\n     n: uint\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1634,6 +1742,7 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1653,11 +1762,13 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n /// An iterator which only iterates over the first `n` iterations of `iter`.\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Take<T> {\n     iter: T,\n     n: uint\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1684,6 +1795,7 @@ impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1703,6 +1815,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[unstable = \"waiting for unboxed closures\"]\n pub struct Scan<'a, A, B, T, St> {\n     iter: T,\n     f: |&mut St, A|: 'a -> Option<B>,\n@@ -1711,6 +1824,7 @@ pub struct Scan<'a, A, B, T, St> {\n     pub state: St,\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'a, A, B, T, St> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n@@ -1728,13 +1842,15 @@ impl<'a, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'a, A, B, T, St> {\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[unstable = \"waiting for unboxed closures\"]\n pub struct FlatMap<'a, A, T, U> {\n     iter: T,\n     f: |A|: 'a -> U,\n     frontiter: Option<U>,\n     backiter: Option<U>,\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n@@ -1763,6 +1879,7 @@ impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T,\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a,\n      A, T: DoubleEndedIterator<A>,\n      B, U: DoubleEndedIterator<B>> DoubleEndedIterator<B>\n@@ -1788,11 +1905,13 @@ impl<'a,\n /// yields `None` once.\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[stable]\n pub struct Fuse<T> {\n     iter: T,\n     done: bool\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1819,6 +1938,7 @@ impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -1837,6 +1957,7 @@ impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n+#[experimental = \"trait is experimental\"]\n impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Fuse<T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1849,6 +1970,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Fuse<T> {\n     }\n }\n \n+#[experimental = \"seems marginal\"]\n impl<T> Fuse<T> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n@@ -1861,6 +1983,7 @@ impl<T> Fuse<T> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[unstable = \"waiting for unboxed closures\"]\n pub struct Inspect<'a, A, T> {\n     iter: T,\n     f: |&A|: 'a\n@@ -1878,6 +2001,7 @@ impl<'a, A, T> Inspect<'a, A, T> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: Iterator<A>> Iterator<A> for Inspect<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1891,6 +2015,7 @@ impl<'a, A, T: Iterator<A>> Iterator<A> for Inspect<'a, A, T> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n for Inspect<'a, A, T> {\n     #[inline]\n@@ -1900,6 +2025,7 @@ for Inspect<'a, A, T> {\n     }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<'a, A, T: RandomAccessIterator<A>> RandomAccessIterator<A>\n for Inspect<'a, A, T> {\n     #[inline]\n@@ -1915,12 +2041,14 @@ for Inspect<'a, A, T> {\n }\n \n /// An iterator which just modifies the contained state throughout iteration.\n+#[experimental]\n pub struct Unfold<'a, A, St> {\n     f: |&mut St|: 'a -> Option<A>,\n     /// Internal state that will be yielded on the next iteration\n     pub state: St,\n }\n \n+#[experimental]\n impl<'a, A, St> Unfold<'a, A, St> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the iterator\n@@ -1934,6 +2062,7 @@ impl<'a, A, St> Unfold<'a, A, St> {\n     }\n }\n \n+#[experimental]\n impl<'a, A, St> Iterator<A> for Unfold<'a, A, St> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1950,6 +2079,7 @@ impl<'a, A, St> Iterator<A> for Unfold<'a, A, St> {\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[deriving(Clone)]\n+#[unstable = \"may be renamed\"]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -1959,10 +2089,12 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n+#[unstable = \"may be renamed\"]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -1979,6 +2111,7 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[deriving(Clone)]\n+#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n@@ -2008,6 +2141,7 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n+#[unstable = \"trait is unstable\"]\n impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2055,6 +2189,7 @@ impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n+#[unstable = \"trait is unstable\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2069,20 +2204,23 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[deriving(Clone)]\n+#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n+#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n         done: false,\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2115,6 +2253,7 @@ impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2133,6 +2272,7 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[deriving(Clone)]\n+#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub struct RangeStep<A> {\n     state: A,\n     stop: A,\n@@ -2142,11 +2282,13 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n+#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A: Int> Iterator<A> for RangeStep<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2165,6 +2307,7 @@ impl<A: Int> Iterator<A> for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[deriving(Clone)]\n+#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub struct RangeStepInclusive<A> {\n     state: A,\n     stop: A,\n@@ -2175,6 +2318,7 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n+#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2186,6 +2330,7 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n@@ -2205,30 +2350,35 @@ impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n \n /// An iterator that repeats an element endlessly\n #[deriving(Clone)]\n+#[stable]\n pub struct Repeat<A> {\n     element: A\n }\n \n impl<A: Clone> Repeat<A> {\n     /// Create a new `Repeat` that endlessly repeats the element `elt`.\n     #[inline]\n+    #[deprecated = \"use iter::repeat instead\"]\n     pub fn new(elt: A) -> Repeat<A> {\n         Repeat{element: elt}\n     }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A: Clone> Iterator<A> for Repeat<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.idx(0) }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n+#[unstable = \"trait is unstable\"]\n impl<A: Clone> DoubleEndedIterator<A> for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n+#[experimental = \"trait is experimental\"]\n impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> uint { uint::MAX }\n@@ -2240,10 +2390,12 @@ type IterateState<'a, T> = (|T|: 'a -> T, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n+#[experimental]\n pub type Iterate<'a, T> = Unfold<'a, T, IterateState<'a, T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n+#[experimental]\n pub fn iterate<'a, T: Clone>(seed: T, f: |T|: 'a -> T) -> Iterate<'a, T> {\n     Unfold::new((f, Some(seed), true), |st| {\n         let &(ref mut f, ref mut val, ref mut first) = st;\n@@ -2262,8 +2414,10 @@ pub fn iterate<'a, T: Clone>(seed: T, f: |T|: 'a -> T) -> Iterate<'a, T> {\n }\n \n /// Create a new iterator that endlessly repeats the element `elt`.\n+#[inline]\n+#[stable]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n-    Repeat::new(elt)\n+    Repeat{element: elt}\n }\n \n /// Functions for lexicographical ordering of sequences.\n@@ -2273,6 +2427,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n+#[experimental = \"likely to be removed after cmp reform\"]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}]}