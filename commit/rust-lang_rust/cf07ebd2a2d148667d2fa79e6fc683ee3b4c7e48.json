{"sha": "cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMDdlYmQyYTJkMTQ4NjY3ZDJmYTc5ZTZmYzY4M2VlM2I0YzdlNDg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-30T09:35:48Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-03T10:10:53Z"}, "message": "move the on_unimplemented logic to its own file", "tree": {"sha": "a2ee26fc91d049b14a03e6acaaf74bf40761347b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2ee26fc91d049b14a03e6acaaf74bf40761347b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "html_url": "https://github.com/rust-lang/rust/commit/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "243aa12d6e7462382f8e145a953477bffce38cda", "url": "https://api.github.com/repos/rust-lang/rust/commits/243aa12d6e7462382f8e145a953477bffce38cda", "html_url": "https://github.com/rust-lang/rust/commit/243aa12d6e7462382f8e145a953477bffce38cda"}], "stats": {"total": 302, "additions": 160, "deletions": 142}, "files": [{"sha": "afd1d87f5983d2783d52de9cba627bb0dab89c99", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 141, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "patch": "@@ -15,6 +15,7 @@ use super::{\n     Obligation,\n     ObligationCause,\n     ObligationCauseCode,\n+    OnUnimplementedInfo,\n     OutputTypeParameterMismatch,\n     TraitNotObjectSafe,\n     PredicateObligation,\n@@ -25,7 +26,6 @@ use super::{\n };\n \n use errors::DiagnosticBuilder;\n-use fmt_macros::{Parser, Piece, Position};\n use hir;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n@@ -39,148 +39,9 @@ use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n use ty::SubtypePredicate;\n-use util::common::ErrorReported;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n use syntax_pos::{DUMMY_SP, Span};\n-use syntax_pos::symbol::InternedString;\n-\n-pub struct OnUnimplementedFormatString(InternedString);\n-pub struct OnUnimplementedInfo {\n-    note: OnUnimplementedFormatString\n-}\n-\n-impl<'a, 'gcx, 'tcx> OnUnimplementedInfo {\n-    pub fn of_item(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                   trait_def_id: DefId,\n-                   impl_def_id: DefId,\n-                   span: Span)\n-                   -> Result<Option<Self>, ErrorReported>\n-    {\n-        let attrs = tcx.get_attrs(impl_def_id);\n-\n-        let attr = if let Some(item) =\n-            attrs.into_iter().find(|a| a.check_name(\"rustc_on_unimplemented\"))\n-        {\n-            item\n-        } else {\n-            return Ok(None);\n-        };\n-\n-        let span = attr.span.substitute_dummy(span);\n-        if let Some(label) = attr.value_str() {\n-            Ok(Some(OnUnimplementedInfo {\n-                note: OnUnimplementedFormatString::try_parse(\n-                    tcx, trait_def_id, label.as_str(), span)?\n-            }))\n-        } else {\n-            struct_span_err!(\n-                tcx.sess, span, E0232,\n-                \"this attribute must have a value\")\n-                .span_label(attr.span, \"attribute requires a value\")\n-                .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n-                .emit();\n-            Err(ErrorReported)\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n-    pub fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     trait_def_id: DefId,\n-                     from: InternedString,\n-                     err_sp: Span)\n-                     -> Result<Self, ErrorReported>\n-    {\n-        let result = OnUnimplementedFormatString(from);\n-        result.verify(tcx, trait_def_id, err_sp)?;\n-        Ok(result)\n-    }\n-\n-    fn verify(&self,\n-              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              trait_def_id: DefId,\n-              span: Span)\n-              -> Result<(), ErrorReported>\n-    {\n-        let name = tcx.item_name(trait_def_id).as_str();\n-        let generics = tcx.generics_of(trait_def_id);\n-        let parser = Parser::new(&self.0);\n-        let types = &generics.types;\n-        let mut result = Ok(());\n-        for token in parser {\n-            match token {\n-                Piece::String(_) => (), // Normal string, no need to check it\n-                Piece::NextArgument(a) => match a.position {\n-                    // `{Self}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n-                    // `{ThisTraitsName}` is allowed\n-                    Position::ArgumentNamed(s) if s == name => (),\n-                    // So is `{A}` if A is a type parameter\n-                    Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                        t.name == s\n-                    }) {\n-                        Some(_) => (),\n-                        None => {\n-                            span_err!(tcx.sess, span, E0230,\n-                                      \"there is no type parameter \\\n-                                       {} on trait {}\",\n-                                      s, name);\n-                            result = Err(ErrorReported);\n-                        }\n-                    },\n-                    // `{:1}` and `{}` are not to be used\n-                    Position::ArgumentIs(_) => {\n-                        span_err!(tcx.sess, span, E0231,\n-                                  \"only named substitution \\\n-                                   parameters are allowed\");\n-                        result = Err(ErrorReported);\n-                    }\n-                }\n-            }\n-        }\n-\n-        result\n-    }\n-\n-    fn format(&self,\n-              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              trait_ref: ty::TraitRef<'tcx>)\n-              -> String\n-    {\n-        let name = tcx.item_name(trait_ref.def_id).as_str();\n-        let trait_str = tcx.item_path_str(trait_ref.def_id);\n-        let generics = tcx.generics_of(trait_ref.def_id);\n-        let generic_map = generics.types.iter().map(|param| {\n-            (param.name.as_str().to_string(),\n-             trait_ref.substs.type_for_def(param).to_string())\n-        }).collect::<FxHashMap<String, String>>();\n-\n-        let parser = Parser::new(&self.0);\n-        parser.map(|p| {\n-            match p {\n-                Piece::String(s) => s,\n-                Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                        Some(val) => val,\n-                        None if s == name => {\n-                            &trait_str\n-                        }\n-                        None => {\n-                            bug!(\"broken on_unimplemented {:?} for {:?}: \\\n-                                  no argument matching {:?}\",\n-                                 self.0, trait_ref, s)\n-                        }\n-                    },\n-                    _ => {\n-                        bug!(\"broken on_unimplemented {:?} - bad \\\n-                              format arg\", self.0)\n-                    }\n-                }\n-            }\n-        }).collect()\n-    }\n-}\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -465,7 +326,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         match OnUnimplementedInfo::of_item(\n             self.tcx, trait_ref.def_id, def_id, obligation.cause.span\n         ) {\n-            Ok(Some(info)) => Some(info.note.format(self.tcx, *trait_ref)),\n+            Ok(Some(info)) => Some(info.label.format(self.tcx, *trait_ref)),\n             _ => None\n         }\n     }"}, {"sha": "65dd4347564f395707f21c87befeb8b7ee8d681c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "patch": "@@ -31,13 +31,13 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n-pub use self::error_reporting::OnUnimplementedInfo;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n+pub use self::on_unimplemented::OnUnimplementedInfo;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n@@ -53,6 +53,7 @@ mod error_reporting;\n mod fulfill;\n mod project;\n mod object_safety;\n+mod on_unimplemented;\n mod select;\n mod specialize;\n mod structural_impls;"}, {"sha": "5d46809d9b0e64f10e246d7f9dfecbe956663306", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=cf07ebd2a2d148667d2fa79e6fc683ee3b4c7e48", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt_macros::{Parser, Piece, Position};\n+\n+use hir::def_id::DefId;\n+use ty::{self, TyCtxt};\n+use util::common::ErrorReported;\n+use util::nodemap::FxHashMap;\n+\n+use syntax_pos::Span;\n+use syntax_pos::symbol::InternedString;\n+\n+pub struct OnUnimplementedFormatString(InternedString);\n+pub struct OnUnimplementedInfo {\n+    pub label: OnUnimplementedFormatString\n+}\n+\n+impl<'a, 'gcx, 'tcx> OnUnimplementedInfo {\n+    pub fn of_item(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                   trait_def_id: DefId,\n+                   impl_def_id: DefId,\n+                   span: Span)\n+                   -> Result<Option<Self>, ErrorReported>\n+    {\n+        let attrs = tcx.get_attrs(impl_def_id);\n+\n+        let attr = if let Some(item) =\n+            attrs.into_iter().find(|a| a.check_name(\"rustc_on_unimplemented\"))\n+        {\n+            item\n+        } else {\n+            return Ok(None);\n+        };\n+\n+        let span = attr.span.substitute_dummy(span);\n+        if let Some(label) = attr.value_str() {\n+            Ok(Some(OnUnimplementedInfo {\n+                label: OnUnimplementedFormatString::try_parse(\n+                    tcx, trait_def_id, label.as_str(), span)?\n+            }))\n+        } else {\n+            struct_span_err!(\n+                tcx.sess, span, E0232,\n+                \"this attribute must have a value\")\n+                .span_label(attr.span, \"attribute requires a value\")\n+                .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n+                .emit();\n+            Err(ErrorReported)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n+    pub fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     trait_def_id: DefId,\n+                     from: InternedString,\n+                     err_sp: Span)\n+                     -> Result<Self, ErrorReported>\n+    {\n+        let result = OnUnimplementedFormatString(from);\n+        result.verify(tcx, trait_def_id, err_sp)?;\n+        Ok(result)\n+    }\n+\n+    fn verify(&self,\n+              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+              trait_def_id: DefId,\n+              span: Span)\n+              -> Result<(), ErrorReported>\n+    {\n+        let name = tcx.item_name(trait_def_id).as_str();\n+        let generics = tcx.generics_of(trait_def_id);\n+        let parser = Parser::new(&self.0);\n+        let types = &generics.types;\n+        let mut result = Ok(());\n+        for token in parser {\n+            match token {\n+                Piece::String(_) => (), // Normal string, no need to check it\n+                Piece::NextArgument(a) => match a.position {\n+                    // `{Self}` is allowed\n+                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                    // `{ThisTraitsName}` is allowed\n+                    Position::ArgumentNamed(s) if s == name => (),\n+                    // So is `{A}` if A is a type parameter\n+                    Position::ArgumentNamed(s) => match types.iter().find(|t| {\n+                        t.name == s\n+                    }) {\n+                        Some(_) => (),\n+                        None => {\n+                            span_err!(tcx.sess, span, E0230,\n+                                      \"there is no type parameter \\\n+                                       {} on trait {}\",\n+                                      s, name);\n+                            result = Err(ErrorReported);\n+                        }\n+                    },\n+                    // `{:1}` and `{}` are not to be used\n+                    Position::ArgumentIs(_) => {\n+                        span_err!(tcx.sess, span, E0231,\n+                                  \"only named substitution \\\n+                                   parameters are allowed\");\n+                        result = Err(ErrorReported);\n+                    }\n+                }\n+            }\n+        }\n+\n+        result\n+    }\n+\n+    pub fn format(&self,\n+                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                  trait_ref: ty::TraitRef<'tcx>)\n+                  -> String\n+    {\n+        let name = tcx.item_name(trait_ref.def_id).as_str();\n+        let trait_str = tcx.item_path_str(trait_ref.def_id);\n+        let generics = tcx.generics_of(trait_ref.def_id);\n+        let generic_map = generics.types.iter().map(|param| {\n+            (param.name.as_str().to_string(),\n+             trait_ref.substs.type_for_def(param).to_string())\n+        }).collect::<FxHashMap<String, String>>();\n+\n+        let parser = Parser::new(&self.0);\n+        parser.map(|p| {\n+            match p {\n+                Piece::String(s) => s,\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                        Some(val) => val,\n+                        None if s == name => {\n+                            &trait_str\n+                        }\n+                        None => {\n+                            bug!(\"broken on_unimplemented {:?} for {:?}: \\\n+                                  no argument matching {:?}\",\n+                                 self.0, trait_ref, s)\n+                        }\n+                    },\n+                    _ => {\n+                        bug!(\"broken on_unimplemented {:?} - bad \\\n+                              format arg\", self.0)\n+                    }\n+                }\n+            }\n+        }).collect()\n+    }\n+}"}]}