{"sha": "766ab78a1cb243293eb84efd073186aa28724802", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NmFiNzhhMWNiMjQzMjkzZWI4NGVmZDA3MzE4NmFhMjg3MjQ4MDI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-22T09:45:24Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T03:27:11Z"}, "message": "Simplify slice splitting a bit", "tree": {"sha": "8c733292cbdb55c88dd923546189a9be9a68f59b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c733292cbdb55c88dd923546189a9be9a68f59b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/766ab78a1cb243293eb84efd073186aa28724802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/766ab78a1cb243293eb84efd073186aa28724802", "html_url": "https://github.com/rust-lang/rust/commit/766ab78a1cb243293eb84efd073186aa28724802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/766ab78a1cb243293eb84efd073186aa28724802/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0", "html_url": "https://github.com/rust-lang/rust/commit/cd4c7144de75e4789dd6dac5f6020aecb1e8e0b0"}], "stats": {"total": 69, "additions": 28, "deletions": 41}, "files": [{"sha": "73f905647b94b2bedb3185f5cfb206afbb1b806e", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 28, "deletions": 41, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/766ab78a1cb243293eb84efd073186aa28724802/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766ab78a1cb243293eb84efd073186aa28724802/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=766ab78a1cb243293eb84efd073186aa28724802", "patch": "@@ -620,21 +620,17 @@ struct Slice {\n }\n \n impl Slice {\n-    /// Returns what patterns this constructor covers: either fixed-length patterns or\n-    /// variable-length patterns.\n-    fn kind(self) -> SliceKind {\n-        match self {\n-            Slice { array_len: Some(len), kind: VarLen(prefix, suffix) }\n-                if prefix + suffix == len =>\n-            {\n-                FixedLen(len)\n-            }\n-            _ => self.kind,\n-        }\n+    fn new(array_len: Option<u64>, kind: SliceKind) -> Self {\n+        let kind = match (array_len, kind) {\n+            // If the middle `..` is empty, we effectively have a fixed-length pattern.\n+            (Some(len), VarLen(prefix, suffix)) if prefix + suffix >= len => FixedLen(len),\n+            _ => kind,\n+        };\n+        Slice { array_len, kind }\n     }\n \n     fn arity(self) -> u64 {\n-        self.kind().arity()\n+        self.kind.arity()\n     }\n \n     /// The exhaustiveness-checking paper does not include any details on\n@@ -701,10 +697,8 @@ impl Slice {\n     /// witness of length \u22652 (say, `[false, false, true]`) can be\n     /// turned to a witness from any other length \u22652.\n     fn split<'p, 'tcx>(self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        let (array_len, self_prefix, self_suffix) = match self {\n-            Slice { array_len, kind: VarLen(self_prefix, self_suffix) } => {\n-                (array_len, self_prefix, self_suffix)\n-            }\n+        let (self_prefix, self_suffix) = match self.kind {\n+            VarLen(self_prefix, self_suffix) => (self_prefix, self_suffix),\n             _ => return smallvec![Slice(self)],\n         };\n \n@@ -716,7 +710,7 @@ impl Slice {\n \n         for ctor in head_ctors {\n             if let Slice(slice) = ctor {\n-                match slice.kind() {\n+                match slice.kind {\n                     FixedLen(len) => {\n                         max_fixed_len = cmp::max(max_fixed_len, len);\n                     }\n@@ -725,6 +719,8 @@ impl Slice {\n                         max_suffix_len = cmp::max(max_suffix_len, suffix);\n                     }\n                 }\n+            } else {\n+                bug!(\"unexpected ctor for slice type: {:?}\", ctor);\n             }\n         }\n \n@@ -738,27 +734,19 @@ impl Slice {\n             max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n         }\n \n-        match array_len {\n-            Some(len) => {\n-                let kind = if max_prefix_len + max_suffix_len < len {\n-                    VarLen(max_prefix_len, max_suffix_len)\n-                } else {\n-                    FixedLen(len)\n-                };\n-                smallvec![Slice(Slice { array_len, kind })]\n-            }\n+        let final_slice = VarLen(max_prefix_len, max_suffix_len);\n+        let final_slice = Slice::new(self.array_len, final_slice);\n+        match self.array_len {\n+            Some(_) => smallvec![Slice(final_slice)],\n             None => {\n-                // `ctor` originally covered the range `(self_prefix +\n-                // self_suffix..infinity)`. We now split it into two: lengths smaller than\n-                // `max_prefix_len + max_suffix_len` are treated independently as\n-                // fixed-lengths slices, and lengths above are captured by a final VarLen\n-                // constructor.\n-                let smaller_lengths =\n-                    (self_prefix + self_suffix..max_prefix_len + max_suffix_len).map(FixedLen);\n-                let final_slice = VarLen(max_prefix_len, max_suffix_len);\n+                // `self` originally covered the range `(self.arity()..infinity)`. We split that\n+                // range into two: lengths smaller than `final_slice.arity()` are treated\n+                // independently as fixed-lengths slices, and lengths above are captured by\n+                // `final_slice`.\n+                let smaller_lengths = (self.arity()..final_slice.arity()).map(FixedLen);\n                 smaller_lengths\n+                    .map(|kind| Slice::new(self.array_len, kind))\n                     .chain(Some(final_slice))\n-                    .map(|kind| Slice { array_len, kind })\n                     .map(Slice)\n                     .collect()\n             }\n@@ -767,7 +755,7 @@ impl Slice {\n \n     /// See `Constructor::is_covered_by`\n     fn is_covered_by(self, other: Self) -> bool {\n-        other.kind().covers_length(self.arity())\n+        other.kind.covers_length(self.arity())\n     }\n }\n \n@@ -934,7 +922,6 @@ impl<'tcx> Constructor<'tcx> {\n                     None => false,\n                 }\n             }\n-\n             (Slice(self_slice), Slice(other_slice)) => self_slice.is_covered_by(*other_slice),\n \n             // We are trying to inspect an opaque constant. Thus we skip the row.\n@@ -1029,7 +1016,7 @@ impl<'tcx> Constructor<'tcx> {\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, pcx.ty),\n                 _ => PatKind::Wild,\n             },\n-            Slice(slice) => match slice.kind() {\n+            Slice(slice) => match slice.kind {\n                 FixedLen(_) => {\n                     PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n                 }\n@@ -1533,13 +1520,13 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n-                vec![Slice(Slice { array_len: Some(len), kind: VarLen(0, 0) })]\n+                vec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n             }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n             let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n-            vec![Slice(Slice { array_len: None, kind })]\n+            vec![Slice(Slice::new(None, kind))]\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n             // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n@@ -2224,7 +2211,7 @@ fn pat_constructor<'p, 'tcx>(\n             let suffix = suffix.len() as u64;\n             let kind =\n                 if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n-            Slice(Slice { array_len, kind })\n+            Slice(Slice::new(array_len, kind))\n         }\n         PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n     }"}]}