{"sha": "4ca47b3432061883757ab9456ea2a4e9a33119cd", "node_id": "C_kwDOAAsO6NoAKDRjYTQ3YjM0MzIwNjE4ODM3NTdhYjk0NTZlYTJhNGU5YTMzMTE5Y2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-24T11:26:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-24T11:26:04Z"}, "message": "Auto merge of #12373 - Veykril:completion, r=Veykril\n\ninternal: Refactor our record pat/expr handling in completion context", "tree": {"sha": "7855d1146f6c38eac53d63ae6216cf0624790706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7855d1146f6c38eac53d63ae6216cf0624790706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ca47b3432061883757ab9456ea2a4e9a33119cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca47b3432061883757ab9456ea2a4e9a33119cd", "html_url": "https://github.com/rust-lang/rust/commit/4ca47b3432061883757ab9456ea2a4e9a33119cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ca47b3432061883757ab9456ea2a4e9a33119cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a4994d948264d80adf5e6dbefddaa8ed775f7eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4994d948264d80adf5e6dbefddaa8ed775f7eb", "html_url": "https://github.com/rust-lang/rust/commit/7a4994d948264d80adf5e6dbefddaa8ed775f7eb"}, {"sha": "6a8b8a60393f52de2df3d9ce81c0a303e535b80b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8b8a60393f52de2df3d9ce81c0a303e535b80b", "html_url": "https://github.com/rust-lang/rust/commit/6a8b8a60393f52de2df3d9ce81c0a303e535b80b"}], "stats": {"total": 280, "additions": 153, "deletions": 127}, "files": [{"sha": "ae7b42e3056f7dafbac0cc54cf1e59d2879361bf", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -5,7 +5,7 @@ use ide_db::FxHashSet;\n use syntax::T;\n \n use crate::{\n-    context::{PathCompletionCtx, PathKind, PathQualifierCtx},\n+    context::{NameRefContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n     CompletionContext, Completions,\n };\n \n@@ -15,14 +15,25 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n         return;\n     }\n \n-    let (is_absolute_path, qualifier, in_block_expr, in_loop_body, in_functional_update) =\n-        match ctx.path_context() {\n-            Some(&PathCompletionCtx {\n-                kind: PathKind::Expr { in_block_expr, in_loop_body, in_functional_update },\n-                is_absolute_path,\n-                ref qualifier,\n+    let (is_absolute_path, qualifier, in_block_expr, in_loop_body, is_func_update) =\n+        match ctx.nameref_ctx() {\n+            Some(NameRefContext {\n+                path_ctx:\n+                    Some(PathCompletionCtx {\n+                        kind: PathKind::Expr { in_block_expr, in_loop_body },\n+                        is_absolute_path,\n+                        qualifier,\n+                        ..\n+                    }),\n+                record_expr,\n                 ..\n-            }) => (is_absolute_path, qualifier, in_block_expr, in_loop_body, in_functional_update),\n+            }) => (\n+                *is_absolute_path,\n+                qualifier,\n+                *in_block_expr,\n+                *in_loop_body,\n+                record_expr.as_ref().map_or(false, |&(_, it)| it),\n+            ),\n             _ => return,\n         };\n \n@@ -165,7 +176,7 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n                 }\n             });\n \n-            if !in_functional_update {\n+            if !is_func_update {\n                 let mut add_keyword =\n                     |kw, snippet| super::keyword::add_keyword(acc, ctx, kw, snippet);\n "}, {"sha": "5917da9b7f317783db4cfdec6a77ebfe8b30f41d", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -5,12 +5,12 @@\n use syntax::T;\n \n use crate::{\n-    context::PathKind, patterns::ImmediateLocation, CompletionContext, CompletionItem,\n-    CompletionItemKind, Completions,\n+    context::{NameRefContext, PathKind},\n+    CompletionContext, CompletionItem, CompletionItemKind, Completions,\n };\n \n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n-    if matches!(ctx.completion_location, Some(ImmediateLocation::RecordExpr(_))) {\n+    if matches!(ctx.nameref_ctx(), Some(NameRefContext { record_expr: Some(_), .. })) {\n         cov_mark::hit!(no_keyword_completion_in_record_lit);\n         return;\n     }"}, {"sha": "ab35dadf92b49ee8243610ac10cac785091928e7", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -15,7 +15,6 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(ctx) => ctx,\n         _ => return,\n     };\n-    let refutable = patctx.refutability == PatternRefutability::Refutable;\n \n     if let Some(path_ctx) = ctx.path_context() {\n         pattern_path_completion(acc, ctx, path_ctx);\n@@ -47,6 +46,11 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n     }\n \n+    if patctx.record_pat.is_some() {\n+        return;\n+    }\n+\n+    let refutable = patctx.refutability == PatternRefutability::Refutable;\n     let single_variant_enum = |enum_: hir::Enum| ctx.db.enum_data(enum_.into()).variants.len() == 1;\n \n     if let Some(hir::Adt::Enum(e)) ="}, {"sha": "6717ca0a0e2b7de907d81c870585e5ffc622ce39", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -3,67 +3,65 @@ use ide_db::SymbolKind;\n use syntax::{ast::Expr, T};\n \n use crate::{\n-    patterns::ImmediateLocation, CompletionContext, CompletionItem, CompletionItemKind,\n-    CompletionRelevance, CompletionRelevancePostfixMatch, Completions,\n+    context::{NameRefContext, PatternContext},\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n+    CompletionRelevancePostfixMatch, Completions,\n };\n \n pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let missing_fields = match &ctx.completion_location {\n-        Some(\n-            ImmediateLocation::RecordExpr(record_expr)\n-            | ImmediateLocation::RecordExprUpdate(record_expr),\n-        ) => {\n-            let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n-\n-            if let Some(hir::Adt::Union(un)) = ty.as_ref().and_then(|t| t.original.as_adt()) {\n-                // ctx.sema.record_literal_missing_fields will always return\n-                // an empty Vec on a union literal. This is normally\n-                // reasonable, but here we'd like to present the full list\n-                // of fields if the literal is empty.\n-                let were_fields_specified = record_expr\n-                    .record_expr_field_list()\n-                    .and_then(|fl| fl.fields().next())\n-                    .is_some();\n-\n-                match were_fields_specified {\n-                    false => un.fields(ctx.db).into_iter().map(|f| (f, f.ty(ctx.db))).collect(),\n-                    true => vec![],\n-                }\n-            } else {\n-                let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-\n-                let default_trait = ctx.famous_defs().core_default_Default();\n-                let impl_default_trait =\n-                    default_trait.zip(ty.as_ref()).map_or(false, |(default_trait, ty)| {\n-                        ty.original.impls_trait(ctx.db, default_trait, &[])\n-                    });\n-\n-                if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n-                    let completion_text = \"..Default::default()\";\n-                    let mut item =\n-                        CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n-                    let completion_text =\n-                        completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);\n-                    item.insert_text(completion_text).set_relevance(CompletionRelevance {\n-                        postfix_match: Some(CompletionRelevancePostfixMatch::Exact),\n-                        ..Default::default()\n-                    });\n-                    item.add_to(acc);\n-                }\n-                if ctx.previous_token_is(T![.]) {\n-                    let mut item =\n-                        CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n-                    item.insert_text(\".\");\n-                    item.add_to(acc);\n-                    return None;\n-                }\n-                missing_fields\n+    let missing_fields = if let Some(PatternContext { record_pat: Some(record_pat), .. }) =\n+        &ctx.pattern_ctx\n+    {\n+        ctx.sema.record_pattern_missing_fields(record_pat)\n+    } else if let Some(NameRefContext { record_expr: Some((record_expr, _)), .. }) =\n+        ctx.nameref_ctx()\n+    {\n+        let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n+\n+        if let Some(hir::Adt::Union(un)) = ty.as_ref().and_then(|t| t.original.as_adt()) {\n+            // ctx.sema.record_literal_missing_fields will always return\n+            // an empty Vec on a union literal. This is normally\n+            // reasonable, but here we'd like to present the full list\n+            // of fields if the literal is empty.\n+            let were_fields_specified =\n+                record_expr.record_expr_field_list().and_then(|fl| fl.fields().next()).is_some();\n+\n+            match were_fields_specified {\n+                false => un.fields(ctx.db).into_iter().map(|f| (f, f.ty(ctx.db))).collect(),\n+                true => vec![],\n             }\n+        } else {\n+            let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n+\n+            let default_trait = ctx.famous_defs().core_default_Default();\n+            let impl_default_trait =\n+                default_trait.zip(ty.as_ref()).map_or(false, |(default_trait, ty)| {\n+                    ty.original.impls_trait(ctx.db, default_trait, &[])\n+                });\n+\n+            if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n+                let completion_text = \"..Default::default()\";\n+                let mut item =\n+                    CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n+                let completion_text =\n+                    completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);\n+                item.insert_text(completion_text).set_relevance(CompletionRelevance {\n+                    postfix_match: Some(CompletionRelevancePostfixMatch::Exact),\n+                    ..Default::default()\n+                });\n+                item.add_to(acc);\n+            }\n+            if ctx.previous_token_is(T![.]) {\n+                let mut item =\n+                    CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n+                item.insert_text(\".\");\n+                item.add_to(acc);\n+                return None;\n+            }\n+            missing_fields\n         }\n-        Some(ImmediateLocation::RecordPat(record_pat)) => {\n-            ctx.sema.record_pattern_missing_fields(record_pat)\n-        }\n-        _ => return None,\n+    } else {\n+        return None;\n     };\n \n     for (field, ty) in missing_fields {"}, {"sha": "4530d88af8c4ce5204e2ebdceafedb144984b544", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -48,7 +48,6 @@ pub(super) enum PathKind {\n     Expr {\n         in_block_expr: bool,\n         in_loop_body: bool,\n-        in_functional_update: bool,\n     },\n     Type,\n     Attr {\n@@ -115,6 +114,8 @@ pub(super) struct PatternContext {\n     pub(super) parent_pat: Option<ast::Pat>,\n     pub(super) ref_token: Option<SyntaxToken>,\n     pub(super) mut_token: Option<SyntaxToken>,\n+    /// The record pattern this name or ref is a field of\n+    pub(super) record_pat: Option<ast::RecordPat>,\n }\n \n #[derive(Debug)]\n@@ -166,8 +167,11 @@ pub(super) enum NameKind {\n pub(super) struct NameRefContext {\n     /// NameRef syntax in the original file\n     pub(super) nameref: Option<ast::NameRef>,\n+    // FIXME: these fields are actually disjoint -> enum\n     pub(super) dot_access: Option<DotAccess>,\n     pub(super) path_ctx: Option<PathCompletionCtx>,\n+    /// The record expression this nameref is a field of\n+    pub(super) record_expr: Option<(ast::RecordExpr, bool)>,\n }\n \n #[derive(Debug)]\n@@ -375,14 +379,15 @@ impl<'a> CompletionContext<'a> {\n     pub(crate) fn is_path_disallowed(&self) -> bool {\n         self.previous_token_is(T![unsafe])\n             || matches!(self.prev_sibling, Some(ImmediatePrevSibling::Visibility))\n-            || matches!(\n-                self.completion_location,\n-                Some(ImmediateLocation::RecordPat(_) | ImmediateLocation::RecordExpr(_))\n-            )\n             || matches!(\n                 self.name_ctx(),\n                 Some(NameContext { kind: NameKind::Module(_) | NameKind::Rename, .. })\n             )\n+            || matches!(self.pattern_ctx, Some(PatternContext { record_pat: Some(_), .. }))\n+            || matches!(\n+                self.nameref_ctx(),\n+                Some(NameRefContext { record_expr: Some((_, false)), .. })\n+            )\n     }\n \n     pub(crate) fn path_context(&self) -> Option<&PathCompletionCtx> {\n@@ -1023,14 +1028,13 @@ impl<'a> CompletionContext<'a> {\n                 ast::Enum(_) => NameKind::Enum,\n                 ast::Fn(_) => NameKind::Function,\n                 ast::IdentPat(bind_pat) => {\n-                    let is_name_in_field_pat = bind_pat\n-                        .syntax()\n-                        .parent()\n-                        .and_then(ast::RecordPatField::cast)\n-                        .map_or(false, |pat_field| pat_field.name_ref().is_none());\n-                    if !is_name_in_field_pat {\n-                        pat_ctx = Some(pattern_context_for(original_file, bind_pat.into()));\n-                    }\n+                    pat_ctx = Some({\n+                        let mut pat_ctx = pattern_context_for(original_file, bind_pat.into());\n+                        if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n+                            pat_ctx.record_pat = find_node_in_file_compensated(original_file, &record_field.parent_record_pat());\n+                        }\n+                        pat_ctx\n+                    });\n \n                     NameKind::IdentPat\n                 },\n@@ -1062,7 +1066,33 @@ impl<'a> CompletionContext<'a> {\n     ) -> (NameRefContext, Option<PatternContext>) {\n         let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n \n-        let mut nameref_ctx = NameRefContext { dot_access: None, path_ctx: None, nameref };\n+        let mut nameref_ctx =\n+            NameRefContext { dot_access: None, path_ctx: None, nameref, record_expr: None };\n+\n+        if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n+            nameref_ctx.record_expr =\n+                find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n+                    .zip(Some(false));\n+            return (nameref_ctx, None);\n+        }\n+        if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n+            let pat_ctx =\n+                pattern_context_for(original_file, record_field.parent_record_pat().clone().into());\n+            return (\n+                nameref_ctx,\n+                Some(PatternContext {\n+                    param_ctx: None,\n+                    has_type_ascription: false,\n+                    ref_token: None,\n+                    mut_token: None,\n+                    record_pat: find_node_in_file_compensated(\n+                        original_file,\n+                        &record_field.parent_record_pat(),\n+                    ),\n+                    ..pat_ctx\n+                }),\n+            );\n+        }\n \n         let segment = match_ast! {\n             match parent {\n@@ -1115,8 +1145,11 @@ impl<'a> CompletionContext<'a> {\n                 })\n                 .unwrap_or(false)\n         };\n-        let is_in_func_update = |it: &SyntaxNode| {\n-            it.parent().map_or(false, |it| ast::RecordExprFieldList::can_cast(it.kind()))\n+        let mut fill_record_expr = |syn: &SyntaxNode| {\n+            if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n+                nameref_ctx.record_expr =\n+                    find_node_in_file_compensated(original_file, &record_expr).zip(Some(true));\n+            }\n         };\n \n         let kind = path.syntax().ancestors().find_map(|it| {\n@@ -1125,11 +1158,12 @@ impl<'a> CompletionContext<'a> {\n                 match it {\n                     ast::PathType(_) => Some(PathKind::Type),\n                     ast::PathExpr(it) => {\n+                        fill_record_expr(it.syntax());\n+\n                         path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n                         let in_block_expr = is_in_block(it.syntax());\n                         let in_loop_body = is_in_loop_body(it.syntax());\n-                        let in_functional_update = is_in_func_update(it.syntax());\n-                        Some(PathKind::Expr { in_block_expr, in_loop_body, in_functional_update })\n+                        Some(PathKind::Expr { in_block_expr, in_loop_body })\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n@@ -1163,8 +1197,8 @@ impl<'a> CompletionContext<'a> {\n                                return Some(parent.and_then(ast::MacroExpr::cast).map(|it| {\n                                     let in_loop_body = is_in_loop_body(it.syntax());\n                                     let in_block_expr = is_in_block(it.syntax());\n-                                    let in_functional_update = is_in_func_update(it.syntax());\n-                                    PathKind::Expr { in_block_expr, in_loop_body, in_functional_update }\n+                                    fill_record_expr(it.syntax());\n+                                    PathKind::Expr { in_block_expr, in_loop_body }\n                                 }));\n                             },\n                         }\n@@ -1299,6 +1333,7 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n         parent_pat: pat.syntax().parent().and_then(ast::Pat::cast),\n         mut_token,\n         ref_token,\n+        record_pat: None,\n     }\n }\n "}, {"sha": "0e146df712d355bb2dc3ab1cba5192c7ae8f21b4", "filename": "crates/ide-completion/src/patterns.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -53,19 +53,6 @@ pub(crate) enum ImmediateLocation {\n     // Only set from a type arg\n     /// Original file ast node\n     GenericArgList(ast::GenericArgList),\n-    /// The record expr of the field name we are completing\n-    ///\n-    /// Original file ast node\n-    RecordExpr(ast::RecordExpr),\n-    /// The record expr of the functional update syntax we are completing\n-    ///\n-    /// Original file ast node\n-    RecordExprUpdate(ast::RecordExpr),\n-    /// The record pat of the field name we are completing\n-    ///\n-    /// Original file ast node\n-    // FIXME: This should be moved to pattern_ctx\n-    RecordPat(ast::RecordPat),\n }\n \n pub(crate) fn determine_prev_sibling(name_like: &ast::NameLike) -> Option<ImmediatePrevSibling> {\n@@ -136,27 +123,8 @@ pub(crate) fn determine_location(\n     name_like: &ast::NameLike,\n ) -> Option<ImmediateLocation> {\n     let node = match name_like {\n-        ast::NameLike::NameRef(name_ref) => {\n-            if ast::RecordExprField::for_field_name(name_ref).is_some() {\n-                return sema\n-                    .find_node_at_offset_with_macros(original_file, offset)\n-                    .map(ImmediateLocation::RecordExpr);\n-            }\n-            if ast::RecordPatField::for_field_name_ref(name_ref).is_some() {\n-                return sema\n-                    .find_node_at_offset_with_macros(original_file, offset)\n-                    .map(ImmediateLocation::RecordPat);\n-            }\n-            maximize_name_ref(name_ref)\n-        }\n-        ast::NameLike::Name(name) => {\n-            if ast::RecordPatField::for_field_name(name).is_some() {\n-                return sema\n-                    .find_node_at_offset_with_macros(original_file, offset)\n-                    .map(ImmediateLocation::RecordPat);\n-            }\n-            name.syntax().clone()\n-        }\n+        ast::NameLike::NameRef(name_ref) => maximize_name_ref(name_ref),\n+        ast::NameLike::Name(name) => name.syntax().clone(),\n         ast::NameLike::Lifetime(lt) => lt.syntax().clone(),\n     };\n \n@@ -199,9 +167,6 @@ pub(crate) fn determine_location(\n             ast::SourceFile(_) => ImmediateLocation::ItemList,\n             ast::ItemList(_) => ImmediateLocation::ItemList,\n             ast::RefExpr(_) => ImmediateLocation::RefExpr,\n-            ast::RecordExprFieldList(_) => sema\n-                .find_node_at_offset_with_macros(original_file, offset)\n-                .map(ImmediateLocation::RecordExprUpdate)?,\n             ast::TupleField(_) => ImmediateLocation::TupleField,\n             ast::TupleFieldList(_) => ImmediateLocation::TupleField,\n             ast::TypeBound(_) => ImmediateLocation::TypeBound,"}, {"sha": "bf88070769eb81181186800905038ff156b2c3ee", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -338,7 +338,10 @@ struct Foo { bar: Bar }\n struct Bar(u32);\n fn outer(Foo { bar$0 }: Foo) {}\n \"#,\n-        expect![[r#\"\"#]],\n+        expect![[r#\"\n+            kw mut\n+            kw ref\n+        \"#]],\n     )\n }\n "}, {"sha": "9e442dbbc56fb9d8091ea46f63c87ef1fac51420", "filename": "crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -41,6 +41,8 @@ fn foo(s: Struct) {\n \"#,\n         expect![[r#\"\n             fd bar u32\n+            kw mut\n+            kw ref\n         \"#]],\n     );\n }\n@@ -58,6 +60,8 @@ fn foo(e: Enum) {\n \"#,\n         expect![[r#\"\n             fd bar u32\n+            kw mut\n+            kw ref\n         \"#]],\n     );\n }\n@@ -93,6 +97,8 @@ fn foo(f: Struct) {\n \",\n         expect![[r#\"\n             fd field u32\n+            kw mut\n+            kw ref\n         \"#]],\n     );\n }"}, {"sha": "2a41d0a701f57a17c5a573af84c95cbb247ac26e", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ca47b3432061883757ab9456ea2a4e9a33119cd/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=4ca47b3432061883757ab9456ea2a4e9a33119cd", "patch": "@@ -510,6 +510,10 @@ impl ast::RecordPatField {\n         }\n     }\n \n+    pub fn parent_record_pat(&self) -> ast::RecordPat {\n+        self.syntax().ancestors().find_map(ast::RecordPat::cast).unwrap()\n+    }\n+\n     /// Deals with field init shorthand\n     pub fn field_name(&self) -> Option<NameOrNameRef> {\n         if let Some(name_ref) = self.name_ref() {"}]}