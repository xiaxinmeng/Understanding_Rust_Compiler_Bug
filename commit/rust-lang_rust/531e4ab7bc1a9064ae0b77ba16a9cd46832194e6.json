{"sha": "531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMWU0YWI3YmMxYTkwNjRhZTBiNzdiYTE2YTljZDQ2ODMyMTk0ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T07:15:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T07:15:34Z"}, "message": "Auto merge of #50798 - bobtwinkles:nll_facts_invalidate, r=nikomatsakis\n\nGenerate \"invalidates\" facts when -Znll-facts is passed\n\nMost of the new code is copied directly from the heart of the MIR borrowchecker. I was expecting more fundamental structural changes, hence the copying. This appears to work as it stands, but I'd like to submit a follow-up PR to reduce code duplication. I figured that could wait though, since this is blocking a large amount of work in the borrow check repository and I'm out of time for tonight =).\n\nr? @nikomatsakis", "tree": {"sha": "9f407094d4c2423ad127d40d75cae0396b2fcf70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f407094d4c2423ad127d40d75cae0396b2fcf70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "html_url": "https://github.com/rust-lang/rust/commit/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a4e5df12685e58ad42ce0152cdbe266373c6bf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4e5df12685e58ad42ce0152cdbe266373c6bf3", "html_url": "https://github.com/rust-lang/rust/commit/9a4e5df12685e58ad42ce0152cdbe266373c6bf3"}, {"sha": "965eef92c45297e2c54ca429e1c1bf7e324f3351", "url": "https://api.github.com/repos/rust-lang/rust/commits/965eef92c45297e2c54ca429e1c1bf7e324f3351", "html_url": "https://github.com/rust-lang/rust/commit/965eef92c45297e2c54ca429e1c1bf7e324f3351"}], "stats": {"total": 983, "additions": 983, "deletions": 0}, "files": [{"sha": "2b2aadba7f92e39db1cfab1487a2da4fe7c5a56a", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "patch": "@@ -38,6 +38,9 @@ crate struct AllFacts {\n \n     // `region_live_at(R, P)` when the region R appears in a live variable at P\n     crate region_live_at: Vec<(RegionVid, LocationIndex)>,\n+\n+    // `invalidates(P, B)` when the borrow B is invalidated at point P\n+    crate invalidates: Vec<(LocationIndex, BorrowIndex)>,\n }\n \n impl AllFacts {\n@@ -69,6 +72,7 @@ impl AllFacts {\n                 killed,\n                 outlives,\n                 region_live_at,\n+                invalidates,\n             ])\n         }\n         Ok(())"}, {"sha": "f6704648cb5f3591d80685eda6edccaf5d15e93e", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "added", "additions": 970, "deletions": 0, "changes": 970, "blob_url": "https://github.com/rust-lang/rust/blob/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "patch": "@@ -0,0 +1,970 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::borrow_set::{BorrowSet, BorrowData};\n+use borrow_check::location::LocationTable;\n+use borrow_check::{JustWrite, WriteAndRead};\n+use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n+use borrow_check::{Context, ContextKind};\n+use borrow_check::{LocalMutationIsAllowed, MutateMode};\n+use borrow_check::ArtificialField;\n+use borrow_check::{ReadKind, WriteKind, Overlap};\n+use borrow_check::nll::facts::AllFacts;\n+use dataflow::move_paths::indexes::BorrowIndex;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::InferCtxt;\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue, Projection};\n+use rustc::mir::{Local, ProjectionElem};\n+use rustc::mir::{Statement, StatementKind};\n+use rustc::mir::{Terminator, TerminatorKind};\n+use rustc::mir::{Field, Operand, BorrowKind};\n+use rustc::ty::{self, ParamEnv};\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::iter;\n+\n+pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n+    mir: &Mir<'tcx>,\n+    mir_def_id: DefId,\n+    borrow_set: &BorrowSet<'tcx>,\n+) {\n+    if !all_facts.is_some() {\n+        // Nothing to do if we don't have any facts\n+        return;\n+    }\n+\n+    let param_env = infcx.tcx.param_env(mir_def_id);\n+\n+    let mut all_facts_taken = all_facts.take().unwrap();\n+    {\n+        let mut ig = InvalidationGenerator {\n+            all_facts: &mut all_facts_taken,\n+            borrow_set,\n+            infcx,\n+            location_table,\n+            mir,\n+            param_env,\n+        };\n+        ig.visit_mir(mir);\n+    }\n+    *all_facts = Some(all_facts_taken);\n+}\n+\n+/// 'cg = the duration of the constraint generation process itself.\n+struct InvalidationGenerator<'cg, 'cx: 'cg, 'tcx: 'cx, 'gcx: 'tcx> {\n+    infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+    all_facts: &'cg mut AllFacts,\n+    location_table: &'cg LocationTable,\n+    mir: &'cg Mir<'tcx>,\n+    borrow_set: &'cg BorrowSet<'tcx>,\n+    param_env: ParamEnv<'gcx>,\n+}\n+\n+/// Visits the whole MIR and generates invalidates() facts\n+/// Most of the code implementing this was stolen from borrow_check/mod.rs\n+impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location) {\n+        match statement.kind {\n+            StatementKind::Assign(ref lhs, ref rhs) => {\n+                self.consume_rvalue(\n+                    ContextKind::AssignRhs.new(location),\n+                    rhs,\n+                );\n+\n+                self.mutate_place(\n+                    ContextKind::AssignLhs.new(location),\n+                    lhs,\n+                    Shallow(None),\n+                    JustWrite\n+                );\n+            }\n+            StatementKind::SetDiscriminant {\n+                ref place,\n+                variant_index: _,\n+            } => {\n+                self.mutate_place(\n+                    ContextKind::SetDiscrim.new(location),\n+                    place,\n+                    Shallow(Some(ArtificialField::Discriminant)),\n+                    JustWrite,\n+                );\n+            }\n+            StatementKind::InlineAsm {\n+                ref asm,\n+                ref outputs,\n+                ref inputs,\n+            } => {\n+                let context = ContextKind::InlineAsm.new(location);\n+                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                    if o.is_indirect {\n+                        // FIXME(eddyb) indirect inline asm outputs should\n+                        // be encoeded through MIR place derefs instead.\n+                        self.access_place(\n+                            context,\n+                            output,\n+                            (Deep, Read(ReadKind::Copy)),\n+                            LocalMutationIsAllowed::No,\n+                        );\n+                    } else {\n+                        self.mutate_place(\n+                            context,\n+                            output,\n+                            if o.is_rw { Deep } else { Shallow(None) },\n+                            if o.is_rw { WriteAndRead } else { JustWrite },\n+                        );\n+                    }\n+                }\n+                for input in inputs {\n+                    self.consume_operand(context, input);\n+                }\n+            }\n+            // EndRegion matters to older NLL/MIR AST borrowck, not to alias NLL\n+            StatementKind::EndRegion(..) |\n+            StatementKind::Nop |\n+            StatementKind::UserAssertTy(..) |\n+            StatementKind::Validate(..) |\n+            StatementKind::StorageLive(..) => {\n+                // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n+                // to borrow check.\n+            }\n+            StatementKind::StorageDead(local) => {\n+                self.access_place(\n+                    ContextKind::StorageDead.new(location),\n+                    &Place::Local(local),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                    LocalMutationIsAllowed::Yes,\n+                );\n+            }\n+        }\n+\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_terminator(\n+        &mut self,\n+        block: BasicBlock,\n+        terminator: &Terminator<'tcx>,\n+        location: Location\n+    ) {\n+        match terminator.kind {\n+            TerminatorKind::SwitchInt {\n+                ref discr,\n+                switch_ty: _,\n+                values: _,\n+                targets: _,\n+            } => {\n+                self.consume_operand(ContextKind::SwitchInt.new(location), discr);\n+            }\n+            TerminatorKind::Drop {\n+                location: ref drop_place,\n+                target: _,\n+                unwind: _,\n+            } => {\n+                let tcx = self.infcx.tcx;\n+                let gcx = tcx.global_tcx();\n+                let drop_place_ty = drop_place.ty(self.mir, tcx);\n+                let drop_place_ty = tcx.erase_regions(&drop_place_ty).to_ty(tcx);\n+                let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n+                self.visit_terminator_drop(location, terminator, drop_place, drop_place_ty);\n+            }\n+            TerminatorKind::DropAndReplace {\n+                location: ref drop_place,\n+                value: ref new_value,\n+                target: _,\n+                unwind: _,\n+            } => {\n+                self.mutate_place(\n+                    ContextKind::DropAndReplace.new(location),\n+                    drop_place,\n+                    Deep,\n+                    JustWrite,\n+                );\n+                self.consume_operand(\n+                    ContextKind::DropAndReplace.new(location),\n+                    new_value,\n+                );\n+            }\n+            TerminatorKind::Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                cleanup: _,\n+            } => {\n+                self.consume_operand(ContextKind::CallOperator.new(location), func);\n+                for arg in args {\n+                    self.consume_operand(ContextKind::CallOperand.new(location), arg);\n+                }\n+                if let Some((ref dest, _ /*bb*/)) = *destination {\n+                    self.mutate_place(\n+                        ContextKind::CallDest.new(location),\n+                        dest,\n+                        Deep,\n+                        JustWrite,\n+                    );\n+                }\n+            }\n+            TerminatorKind::Assert {\n+                ref cond,\n+                expected: _,\n+                ref msg,\n+                target: _,\n+                cleanup: _,\n+            } => {\n+                self.consume_operand(ContextKind::Assert.new(location), cond);\n+                use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+                if let BoundsCheck { ref len, ref index } = *msg {\n+                    self.consume_operand(ContextKind::Assert.new(location), len);\n+                    self.consume_operand(ContextKind::Assert.new(location), index);\n+                }\n+            }\n+            TerminatorKind::Yield {\n+                ref value,\n+                resume,\n+                drop: _,\n+            } => {\n+                self.consume_operand(ContextKind::Yield.new(location), value);\n+\n+                // Invalidate all borrows of local places\n+                let borrow_set = self.borrow_set.clone();\n+                let resume = self.location_table.start_index(resume.start_location());\n+                for i in borrow_set.borrows.indices() {\n+                    if borrow_of_local_data(&borrow_set.borrows[i].borrowed_place) {\n+                        self.all_facts.invalidates.push((resume, i));\n+                    }\n+                }\n+            }\n+            TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n+                // Invalidate all borrows of local places\n+                let borrow_set = self.borrow_set.clone();\n+                let start = self.location_table.start_index(location);\n+                for i in borrow_set.borrows.indices() {\n+                    if borrow_of_local_data(&borrow_set.borrows[i].borrowed_place) {\n+                        self.all_facts.invalidates.push((start, i));\n+                    }\n+                }\n+            }\n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::FalseEdges {\n+                real_target: _,\n+                imaginary_targets: _,\n+            }\n+            | TerminatorKind::FalseUnwind {\n+                real_target: _,\n+                unwind: _,\n+            } => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+\n+        self.super_terminator(block, terminator, location);\n+    }\n+}\n+\n+impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cg, 'cx, 'tcx, 'gcx> {\n+    /// Simulates dropping of a variable\n+    fn visit_terminator_drop(\n+        &mut self,\n+        loc: Location,\n+        term: &Terminator<'tcx>,\n+        drop_place: &Place<'tcx>,\n+        erased_drop_place_ty: ty::Ty<'gcx>,\n+    ) {\n+        let gcx = self.infcx.tcx.global_tcx();\n+        let drop_field = |\n+            ig: &mut InvalidationGenerator<'cg, 'cx, 'gcx, 'tcx>,\n+            (index, field): (usize, ty::Ty<'gcx>),\n+        | {\n+            let field_ty = gcx.normalize_erasing_regions(ig.param_env, field);\n+            let place = drop_place.clone().field(Field::new(index), field_ty);\n+\n+            ig.visit_terminator_drop(loc, term, &place, field_ty);\n+        };\n+\n+        match erased_drop_place_ty.sty {\n+            // When a struct is being dropped, we need to check\n+            // whether it has a destructor, if it does, then we can\n+            // call it, if it does not then we need to check the\n+            // individual fields instead. This way if `foo` has a\n+            // destructor but `bar` does not, we will only check for\n+            // borrows of `x.foo` and not `x.bar`. See #47703.\n+            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n+                def.all_fields()\n+                    .map(|field| field.ty(gcx, substs))\n+                    .enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            // Same as above, but for tuples.\n+            ty::TyTuple(tys) => {\n+                tys.iter().cloned().enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            // Closures and generators also have disjoint fields, but they are only\n+            // directly accessed in the body of the closure/generator.\n+            ty::TyGenerator(def, substs, ..)\n+                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n+            => {\n+                substs.upvar_tys(def, self.infcx.tcx).enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            ty::TyClosure(def, substs)\n+                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n+                => {\n+                    substs.upvar_tys(def, self.infcx.tcx).enumerate()\n+                        .for_each(|field| drop_field(self, field));\n+                }\n+            _ => {\n+                // We have now refined the type of the value being\n+                // dropped (potentially) to just the type of a\n+                // subfield; so check whether that field's type still\n+                // \"needs drop\". If so, we assume that the destructor\n+                // may access any data it likes (i.e., a Deep Write).\n+                if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n+                    self.access_place(\n+                        ContextKind::Drop.new(loc),\n+                        drop_place,\n+                        (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                        LocalMutationIsAllowed::Yes,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Simulates mutation of a place\n+    fn mutate_place(\n+        &mut self,\n+        context: Context,\n+        place: &Place<'tcx>,\n+        kind: ShallowOrDeep,\n+        _mode: MutateMode,\n+    ) {\n+        self.access_place(\n+            context,\n+            place,\n+            (kind, Write(WriteKind::Mutate)),\n+            LocalMutationIsAllowed::ExceptUpvars,\n+        );\n+    }\n+\n+    /// Simulates consumption of an operand\n+    fn consume_operand(\n+        &mut self,\n+        context: Context,\n+        operand: &Operand<'tcx>,\n+    ) {\n+        match *operand {\n+            Operand::Copy(ref place) => {\n+                self.access_place(\n+                    context,\n+                    place,\n+                    (Deep, Read(ReadKind::Copy)),\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n+            Operand::Move(ref place) => {\n+                self.access_place(\n+                    context,\n+                    place,\n+                    (Deep, Write(WriteKind::Move)),\n+                    LocalMutationIsAllowed::Yes,\n+                );\n+            }\n+            Operand::Constant(_) => {}\n+        }\n+    }\n+\n+    // Simulates consumption of an rvalue\n+    fn consume_rvalue(\n+        &mut self,\n+        context: Context,\n+        rvalue: &Rvalue<'tcx>,\n+    ) {\n+        match *rvalue {\n+            Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n+                let access_kind = match bk {\n+                    BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n+                    BorrowKind::Unique | BorrowKind::Mut { .. } => {\n+                        let wk = WriteKind::MutableBorrow(bk);\n+                        if self.allow_two_phase_borrow(bk) {\n+                            (Deep, Reservation(wk))\n+                        } else {\n+                            (Deep, Write(wk))\n+                        }\n+                    }\n+                };\n+\n+                self.access_place(\n+                    context,\n+                    place,\n+                    access_kind,\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n+\n+            Rvalue::Use(ref operand)\n+            | Rvalue::Repeat(ref operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n+                self.consume_operand(context, operand)\n+            }\n+\n+            Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n+                let af = match *rvalue {\n+                    Rvalue::Len(..) => ArtificialField::ArrayLength,\n+                    Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n+                    _ => unreachable!(),\n+                };\n+                self.access_place(\n+                    context,\n+                    place,\n+                    (Shallow(Some(af)), Read(ReadKind::Copy)),\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n+\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n+            | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+                self.consume_operand(context, operand1);\n+                self.consume_operand(context, operand2);\n+            }\n+\n+            Rvalue::NullaryOp(_op, _ty) => {\n+            }\n+\n+            Rvalue::Aggregate(_, ref operands) => {\n+                for operand in operands {\n+                    self.consume_operand(context, operand);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Simulates an access to a place\n+    fn access_place(\n+        &mut self,\n+        context: Context,\n+        place: &Place<'tcx>,\n+        kind: (ShallowOrDeep, ReadOrWrite),\n+        _is_local_mutation_allowed: LocalMutationIsAllowed,\n+    ) {\n+        let (sd, rw) = kind;\n+        // note: not doing check_access_permissions checks because they don't generate invalidates\n+        self.check_access_for_conflict(context, place, sd, rw);\n+    }\n+\n+    fn check_access_for_conflict(\n+        &mut self,\n+        context: Context,\n+        place: &Place<'tcx>,\n+        sd: ShallowOrDeep,\n+        rw: ReadOrWrite,\n+    ) {\n+        debug!(\n+            \"invalidation::check_access_for_conflict(context={:?}, place={:?}, sd={:?}, \\\n+             rw={:?})\",\n+            context,\n+            place,\n+            sd,\n+            rw,\n+        );\n+        self.each_borrow_involving_path(\n+            context,\n+            (sd, place),\n+            |this, borrow_index, borrow| match (rw, borrow.kind) {\n+                // Obviously an activation is compatible with its own\n+                // reservation (or even prior activating uses of same\n+                // borrow); so don't check if they interfere.\n+                //\n+                // NOTE: *reservations* do conflict with themselves;\n+                // thus aren't injecting unsoundenss w/ this check.)\n+                (Activation(_, activating), _) if activating == borrow_index => {\n+                    // Activating a borrow doesn't generate any invalidations, since we\n+                    // have already taken the reservation\n+                }\n+\n+                (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                    // Reads/reservations don't invalidate shared borrows\n+                }\n+\n+                (Read(_), BorrowKind::Unique) | (Read(_), BorrowKind::Mut { .. }) => {\n+                    // Reading from mere reservations of mutable-borrows is OK.\n+                    if !this.is_active(borrow, context.loc) {\n+                        // If the borrow isn't active yet, reads don't invalidate it\n+                        assert!(this.allow_two_phase_borrow(borrow.kind));\n+                        return;\n+                    }\n+\n+                    // Unique and mutable borrows are invalidated by reads from any\n+                    // involved path\n+                    this.generate_invalidates(borrow_index, context.loc);\n+                }\n+\n+                (Reservation(_), BorrowKind::Unique)\n+                | (Reservation(_), BorrowKind::Mut { .. })\n+                | (Activation(_, _), _)\n+                | (Write(_), _) => {\n+                    // unique or mutable borrows are invalidated by writes.\n+                    // Reservations count as writes since we need to check\n+                    // that activating the borrow will be OK\n+                    // TOOD(bob_twinkles) is this actually the right thing to do?\n+                    this.generate_invalidates(borrow_index, context.loc);\n+                }\n+            },\n+        );\n+    }\n+\n+    /// Returns true if the borrow represented by `kind` is\n+    /// allowed to be split into separate Reservation and\n+    /// Activation phases.\n+    fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n+        self.infcx.tcx.two_phase_borrows()\n+            && (kind.allows_two_phase_borrow()\n+                || self.infcx.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+    }\n+\n+    /// Generate a new invalidates(L, B) fact\n+    fn generate_invalidates(&mut self, b: BorrowIndex, l: Location) {\n+        let lidx = self.location_table.mid_index(l);\n+        self.all_facts.invalidates.push((lidx, b));\n+    }\n+\n+    /// This function iterates over all borrows that intersect with an\n+    /// an access to a place, invoking the `op` callback for each one.\n+    ///\n+    /// \"Current borrow\" here means a borrow that reaches the point in\n+    /// the control-flow where the access occurs.\n+    ///\n+    /// The borrow's phase is represented by the IsActive parameter\n+    /// passed to the callback.\n+    fn each_borrow_involving_path<F>(\n+        &mut self,\n+        _context: Context,\n+        access_place: (ShallowOrDeep, &Place<'tcx>),\n+        mut op: F,\n+    ) where\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>),\n+    {\n+        let (access, place) = access_place;\n+\n+        // FIXME: analogous code in check_loans first maps `place` to\n+        // its base_path.\n+\n+        // check for loan restricting path P being used. Accounts for\n+        // borrows of P, P.a.b, etc.\n+        let borrow_set = self.borrow_set.clone();\n+        for i in borrow_set.borrows.indices() {\n+            let borrowed = &borrow_set[i];\n+\n+            if self.places_conflict(&borrowed.borrowed_place, place, access) {\n+                debug!(\n+                    \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n+                    i, borrowed, place, access\n+                );\n+                op(self, i, borrowed);\n+            }\n+        }\n+    }\n+\n+    /// Determine if a given two-phase borrow is active using dominator information\n+    fn is_active(&self, borrow: &BorrowData, location: Location) -> bool {\n+        // If it's not two-phase, the borrow is definitely active\n+        if !self.allow_two_phase_borrow(borrow.kind) {\n+            return true;\n+        }\n+        if borrow.activation_location.is_none() {\n+            return false;\n+        }\n+        let activation_location = borrow.activation_location.unwrap();\n+        if activation_location.block == location.block {\n+            activation_location.statement_index >= location.statement_index\n+        } else {\n+            self.mir.dominators().is_dominated_by(location.block, activation_location.block)\n+        }\n+    }\n+\n+    /// Returns whether an access of kind `access` to `access_place` conflicts with\n+    /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n+    /// locations, this function is symmetric between `borrow_place` & `access_place`).\n+    fn places_conflict(\n+        &mut self,\n+        borrow_place: &Place<'tcx>,\n+        access_place: &Place<'tcx>,\n+        access: ShallowOrDeep,\n+    ) -> bool {\n+        debug!(\n+            \"places_conflict({:?},{:?},{:?})\",\n+            borrow_place, access_place, access\n+        );\n+\n+        // Return all the prefixes of `place` in reverse order, including\n+        // downcasts.\n+        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>> {\n+            let mut result = vec![];\n+            let mut place = place;\n+            loop {\n+                result.push(place);\n+                match place {\n+                    Place::Projection(interior) => {\n+                        place = &interior.base;\n+                    }\n+                    Place::Local(_) | Place::Static(_) => {\n+                        result.reverse();\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let borrow_components = place_elements(borrow_place);\n+        let access_components = place_elements(access_place);\n+        debug!(\n+            \"places_conflict: components {:?} / {:?}\",\n+            borrow_components, access_components\n+        );\n+\n+        let borrow_components = borrow_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n+        let access_components = access_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n+        // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+        // borrow forwards, iterating over \"similar\" projections in lockstep until\n+        // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+        // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+        //\n+        // At each step, if we didn't run out of borrow or place, we know that our elements\n+        // have the same type, and that they only overlap if they are the identical.\n+        //\n+        // For example, if we are comparing these:\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  (*x1[i].y).w.b\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+        //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+        //\n+        // Because `zip` does potentially bad things to the iterator inside, this loop\n+        // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+        //\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  x1[i].y\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //\n+        // -- here we run out of access - the borrow can access a part of it. If this\n+        // is a full deep access, then we *know* the borrow conflicts with it. However,\n+        // if the access is shallow, then we can proceed:\n+        //\n+        //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+        //                                     are disjoint\n+        //\n+        // Our invariant is, that at each step of the iteration:\n+        //  - If we didn't run out of access to match, our borrow and access are comparable\n+        //    and either equal or disjoint.\n+        //  - If we did run out of accesss, the borrow can access a part of it.\n+        for (borrow_c, access_c) in borrow_components.zip(access_components) {\n+            // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+            debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n+            match (borrow_c, access_c) {\n+                (None, _) => {\n+                    // If we didn't run out of access, the borrow can access all of our\n+                    // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n+                    // so we have a conflict.\n+                    //\n+                    // If we did, then we still know that the borrow can access a *part*\n+                    // of our place that our access cares about (a borrow of `a.b.c`\n+                    // with an access to `a.b`), so we still have a conflict.\n+                    //\n+                    // FIXME: Differs from AST-borrowck; includes drive-by fix\n+                    // to #38899. Will probably need back-compat mode flag.\n+                    debug!(\"places_conflict: full borrow, CONFLICT\");\n+                    return true;\n+                }\n+                (Some(borrow_c), None) => {\n+                    // We know that the borrow can access a part of our place. This\n+                    // is a conflict if that is a part our access cares about.\n+\n+                    let (base, elem) = match borrow_c {\n+                        Place::Projection(box Projection { base, elem }) => (base, elem),\n+                        _ => bug!(\"place has no base?\"),\n+                    };\n+                    let base_ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+\n+                    match (elem, &base_ty.sty, access) {\n+                        (_, _, Shallow(Some(ArtificialField::Discriminant)))\n+                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                            // The discriminant and array length are like\n+                            // additional fields on the type; they do not\n+                            // overlap any existing data there. Furthermore,\n+                            // they cannot actually be a prefix of any\n+                            // borrowed place (at least in MIR as it is\n+                            // currently.)\n+                            //\n+                            // e.g. a (mutable) borrow of `a[5]` while we read the\n+                            // array length of `a`.\n+                            debug!(\"places_conflict: implicit field\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Shallow(None)) => {\n+                            // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                            // prefix thereof - the shallow access can't touch anything behind\n+                            // the pointer.\n+                            debug!(\"places_conflict: shallow access behind ptr\");\n+                            return false;\n+                        }\n+                        (\n+                            ProjectionElem::Deref,\n+                            ty::TyRef( _, _, hir::MutImmutable),\n+                            _,\n+                        ) => {\n+                            // the borrow goes through a dereference of a shared reference.\n+                            //\n+                            // I'm not sure why we are tracking these borrows - shared\n+                            // references can *always* be aliased, which means the\n+                            // permission check already account for this borrow.\n+                            debug!(\"places_conflict: behind a shared ref\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Deep)\n+                        | (ProjectionElem::Field { .. }, _, _)\n+                        | (ProjectionElem::Index { .. }, _, _)\n+                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                        | (ProjectionElem::Subslice { .. }, _, _)\n+                        | (ProjectionElem::Downcast { .. }, _, _) => {\n+                            // Recursive case. This can still be disjoint on a\n+                            // further iteration if this a shallow access and\n+                            // there's a deref later on, e.g. a borrow\n+                            // of `*x.y` while accessing `x`.\n+                        }\n+                    }\n+                }\n+                (Some(borrow_c), Some(access_c)) => {\n+                    match self.place_element_conflict(&borrow_c, access_c) {\n+                        Overlap::Arbitrary => {\n+                            // We have encountered different fields of potentially\n+                            // the same union - the borrow now partially overlaps.\n+                            //\n+                            // There is no *easy* way of comparing the fields\n+                            // further on, because they might have different types\n+                            // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                            // `.y` come from different structs).\n+                            //\n+                            // We could try to do some things here - e.g. count\n+                            // dereferences - but that's probably not a good\n+                            // idea, at least for now, so just give up and\n+                            // report a conflict. This is unsafe code anyway so\n+                            // the user could always use raw pointers.\n+                            debug!(\"places_conflict: arbitrary -> conflict\");\n+                            return true;\n+                        }\n+                        Overlap::EqualOrDisjoint => {\n+                            // This is the recursive case - proceed to the next element.\n+                        }\n+                        Overlap::Disjoint => {\n+                            // We have proven the borrow disjoint - further\n+                            // projections will remain disjoint.\n+                            debug!(\"places_conflict: disjoint\");\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        unreachable!(\"iter::repeat returned None\")\n+    }\n+\n+    // Given that the bases of `elem1` and `elem2` are always either equal\n+    // or disjoint (and have the same type!), return the overlap situation\n+    // between `elem1` and `elem2`.\n+    fn place_element_conflict(&self, elem1: &Place<'tcx>, elem2: &Place<'tcx>) -> Overlap {\n+        match (elem1, elem2) {\n+            (Place::Local(l1), Place::Local(l2)) => {\n+                if l1 == l2 {\n+                    // the same local - base case, equal\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                    Overlap::EqualOrDisjoint\n+                } else {\n+                    // different locals - base case, disjoint\n+                    debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                    Overlap::Disjoint\n+                }\n+            }\n+            (Place::Static(static1), Place::Static(static2)) => {\n+                if static1.def_id != static2.def_id {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                    Overlap::Disjoint\n+                } else if self.infcx.tcx.is_static(static1.def_id) ==\n+                          Some(hir::Mutability::MutMutable) {\n+                    // We ignore mutable statics - they can only be unsafe code.\n+                    debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                    Overlap::Disjoint\n+                } else {\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+            }\n+            (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+            (Place::Projection(pi1), Place::Projection(pi2)) => {\n+                match (&pi1.elem, &pi2.elem) {\n+                    (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                        // derefs (e.g. `*x` vs. `*x`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+                    (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                        if f1 == f2 {\n+                            // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            let ty = pi1.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                            match ty.sty {\n+                                ty::TyAdt(def, _) if def.is_union() => {\n+                                    // Different fields of a union, we are basically stuck.\n+                                    debug!(\"place_element_conflict: STUCK-UNION\");\n+                                    Overlap::Arbitrary\n+                                }\n+                                _ => {\n+                                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                    Overlap::Disjoint\n+                                }\n+                            }\n+                        }\n+                    }\n+                    (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                        // different variants are treated as having disjoint fields,\n+                        // even if they occupy the same \"space\", because it's\n+                        // impossible for 2 variants of the same enum to exist\n+                        // (and therefore, to be borrowed) at the same time.\n+                        //\n+                        // Note that this is different from unions - we *do* allow\n+                        // this code to compile:\n+                        //\n+                        // ```\n+                        // fn foo(x: &mut Result<i32, i32>) {\n+                        //     let mut v = None;\n+                        //     if let Ok(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     // here, you would *think* that the\n+                        //     // *entirety* of `x` would be borrowed,\n+                        //     // but in fact only the `Ok` variant is,\n+                        //     // so the `Err` variant is *entirely free*:\n+                        //     if let Err(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     drop(v);\n+                        // }\n+                        // ```\n+                        if v1 == v2 {\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                            Overlap::Disjoint\n+                        }\n+                    }\n+                    (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+                    | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+                    | (\n+                        ProjectionElem::ConstantIndex { .. },\n+                        ProjectionElem::ConstantIndex { .. },\n+                    )\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                        // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                        // (if the indexes differ) or equal (if they are the same), so this\n+                        // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                        //\n+                        // Note that by construction, MIR at borrowck can't subdivide\n+                        // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                        // are only present in slice patterns, and we \"merge together\" nested\n+                        // slice patterns. That means we don't have to think about these. It's\n+                        // probably a good idea to assert this somewhere, but I'm too lazy.\n+                        //\n+                        // FIXME(#8636) we might want to return Disjoint if\n+                        // both projections are constant and disjoint.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+\n+                    (ProjectionElem::Deref, _)\n+                    | (ProjectionElem::Field(..), _)\n+                    | (ProjectionElem::Index(..), _)\n+                    | (ProjectionElem::ConstantIndex { .. }, _)\n+                    | (ProjectionElem::Subslice { .. }, _)\n+                    | (ProjectionElem::Downcast(..), _) => bug!(\n+                        \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+                        elem1,\n+                        elem2\n+                    ),\n+                }\n+            }\n+            (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n+                \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+                elem1,\n+                elem2\n+            ),\n+        }\n+    }\n+}\n+\n+\n+/// Determines if a given borrow is borrowing local data\n+/// This is called for all Yield statements on movable generators\n+fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n+    match place {\n+        Place::Static(..) => false,\n+        Place::Local(..) => true,\n+        Place::Projection(box proj) => {\n+            match proj.elem {\n+                // Reborrow of already borrowed data is ignored\n+                // Any errors will be caught on the initial borrow\n+                ProjectionElem::Deref => false,\n+\n+                // For interior references and downcasts, find out if the base is local\n+                ProjectionElem::Field(..)\n+                    | ProjectionElem::Index(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. }\n+                | ProjectionElem::Downcast(..) => borrow_of_local_data(&proj.base),\n+            }\n+        }\n+    }\n+}"}, {"sha": "04e23c6f041e809e9a73a588a80326a73252cef2", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "patch": "@@ -37,6 +37,7 @@ mod renumber;\n mod subtype_constraint_generation;\n crate mod type_check;\n mod universal_regions;\n+mod invalidation;\n \n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n@@ -130,6 +131,14 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         &mir,\n         borrow_set,\n     );\n+    invalidation::generate_invalidates(\n+        infcx,\n+        &mut all_facts,\n+        location_table,\n+        &mir,\n+        def_id,\n+        borrow_set\n+    );\n \n     // Dump facts if requested.\n     if let Some(all_facts) = all_facts {"}]}