{"sha": "34942331a3288bbebc5a00fef57b6976afc0eb75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0OTQyMzMxYTMyODhiYmViYzVhMDBmZWY1N2I2OTc2YWZjMGViNzU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-05T22:55:13Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-06T14:02:23Z"}, "message": "remove ty::{VariantInfo, FieldTy}", "tree": {"sha": "b33fd3c5db10d32786edb9225853a79815f55189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b33fd3c5db10d32786edb9225853a79815f55189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34942331a3288bbebc5a00fef57b6976afc0eb75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34942331a3288bbebc5a00fef57b6976afc0eb75", "html_url": "https://github.com/rust-lang/rust/commit/34942331a3288bbebc5a00fef57b6976afc0eb75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34942331a3288bbebc5a00fef57b6976afc0eb75/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49e7432b000424aba7bd0fc82f338f2d7f8570f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/49e7432b000424aba7bd0fc82f338f2d7f8570f8", "html_url": "https://github.com/rust-lang/rust/commit/49e7432b000424aba7bd0fc82f338f2d7f8570f8"}], "stats": {"total": 222, "additions": 10, "deletions": 212}, "files": [{"sha": "f0607010bf3f07d29d29907886e31bd0fb4e8c06", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=34942331a3288bbebc5a00fef57b6976afc0eb75", "patch": "@@ -113,13 +113,6 @@ pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId,\n     decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)\n }\n \n-pub fn get_enum_variants<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n-                               -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n-}\n-\n /// Returns information about the given implementation.\n pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n@@ -195,11 +188,9 @@ pub fn get_item_attrs(cstore: &cstore::CStore,\n     decoder::get_item_attrs(&*cdata, def_id.node)\n }\n \n-pub fn get_struct_fields(cstore: &cstore::CStore,\n-                         def: ast::DefId)\n-                      -> Vec<ty::FieldTy> {\n+pub fn get_struct_field_names(cstore: &cstore::CStore, def: ast::DefId) -> Vec<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_fields(cstore.intr.clone(), &*cdata, def.node)\n+    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.node)\n }\n \n pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: ast::DefId) -> HashMap<ast::NodeId,"}, {"sha": "38f90e682be06654e38d27397fb60baf72ce71a7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 78, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=34942331a3288bbebc5a00fef57b6976afc0eb75", "patch": "@@ -794,55 +794,6 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     }\n }\n \n-pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                               tcx: &ty::ctxt<'tcx>) -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-    let data = cdata.data();\n-    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n-    let item = find_item(id, items);\n-    let mut disr_val = 0;\n-    reader::tagged_docs(item, tag_items_data_item_variant).map(|p| {\n-        let did = translated_def_id(cdata, p);\n-        let item = find_item(did.node, items);\n-        let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n-                                item, tcx, cdata);\n-        let name = item_name(&*intr, item);\n-        let (ctor_ty, arg_tys, arg_names) = match ctor_ty.sty {\n-            ty::TyBareFn(_, ref f) =>\n-                (Some(ctor_ty), f.sig.0.inputs.clone(), None),\n-            _ => { // Nullary or struct enum variant.\n-                let mut arg_names = Vec::new();\n-                let arg_tys = get_struct_fields(intr.clone(), cdata, did.node)\n-                    .iter()\n-                    .map(|field_ty| {\n-                        arg_names.push(field_ty.name);\n-                        get_type(cdata, field_ty.id.node, tcx).ty\n-                    })\n-                    .collect();\n-                let arg_names = if arg_names.is_empty() { None } else { Some(arg_names) };\n-\n-                (None, arg_tys, arg_names)\n-            }\n-        };\n-        match variant_disr_val(item) {\n-            Some(val) => { disr_val = val; }\n-            _         => { /* empty */ }\n-        }\n-        let old_disr_val = disr_val;\n-        disr_val = disr_val.wrapping_add(1);\n-        Rc::new(ty::VariantInfo {\n-            args: arg_tys,\n-            arg_names: arg_names,\n-            ctor_ty: ctor_ty,\n-            name: name,\n-            // I'm not even sure if we encode visibility\n-            // for variants -- TEST -- tjc\n-            id: did,\n-            disr_val: old_disr_val,\n-            vis: ast::Inherited\n-        })\n-    }).collect()\n-}\n-\n fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n     fn get_mutability(ch: u8) -> ast::Mutability {\n         match ch as char {\n@@ -1136,37 +1087,14 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n     }\n }\n \n-pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n-    -> Vec<ty::FieldTy> {\n+pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId)\n+    -> Vec<ast::Name> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    reader::tagged_docs(item, tag_item_field).filter_map(|an_item| {\n-        let f = item_family(an_item);\n-        if f == PublicField || f == InheritedField {\n-            let name = item_name(&*intr, an_item);\n-            let did = item_def_id(an_item, cdata);\n-            let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n-            let origin_id =  translated_def_id(cdata, tagdoc);\n-            Some(ty::FieldTy {\n-                name: name,\n-                id: did,\n-                vis: struct_field_family_to_visibility(f),\n-                origin: origin_id,\n-            })\n-        } else {\n-            None\n-        }\n-    }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|an_item| {\n-        let did = item_def_id(an_item, cdata);\n-        let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n-        let f = item_family(an_item);\n-        let origin_id =  translated_def_id(cdata, tagdoc);\n-        ty::FieldTy {\n-            name: special_idents::unnamed_field.name,\n-            id: did,\n-            vis: struct_field_family_to_visibility(f),\n-            origin: origin_id,\n-        }\n+    reader::tagged_docs(item, tag_item_field).map(|an_item| {\n+        item_name(intr, an_item)\n+    }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n+        special_idents::unnamed_field.name\n     })).collect()\n }\n "}, {"sha": "733fa0e71b4eefa660435f81b4d601dcc1559430", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 111, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=34942331a3288bbebc5a00fef57b6976afc0eb75", "patch": "@@ -87,8 +87,7 @@ use std::collections::{HashMap, HashSet};\n use rustc_data_structures::ivar;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n-use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n-use syntax::ast::{StructField, UnnamedField, Visibility};\n+use syntax::ast::{MutImmutable, MutMutable, Name, NodeId, Visibility};\n use syntax::ast_util::{self, is_local, local_def};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n@@ -112,83 +111,6 @@ pub struct CrateAnalysis {\n     pub glob_map: Option<GlobMap>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Field<'tcx> {\n-    pub name: ast::Name,\n-    pub mt: TypeAndMut<'tcx>\n-}\n-\n-// Enum information\n-#[derive(Clone)]\n-pub struct VariantInfo<'tcx> {\n-    pub args: Vec<Ty<'tcx>>,\n-    pub arg_names: Option<Vec<ast::Name>>,\n-    pub ctor_ty: Option<Ty<'tcx>>,\n-    pub name: ast::Name,\n-    pub id: ast::DefId,\n-    pub disr_val: Disr,\n-    pub vis: Visibility\n-}\n-\n-impl<'tcx> VariantInfo<'tcx> {\n-\n-    /// Creates a new VariantInfo from the corresponding ast representation.\n-    ///\n-    /// Does not do any caching of the value in the type context.\n-    pub fn from_ast_variant(cx: &ctxt<'tcx>,\n-                            ast_variant: &ast::Variant,\n-                            discriminant: Disr) -> VariantInfo<'tcx> {\n-        let ctor_ty = cx.node_id_to_type(ast_variant.node.id);\n-\n-        match ast_variant.node.kind {\n-            ast::TupleVariantKind(ref args) => {\n-                let arg_tys = if !args.is_empty() {\n-                    // the regions in the argument types come from the\n-                    // enum def'n, and hence will all be early bound\n-                    cx.no_late_bound_regions(&ctor_ty.fn_args()).unwrap()\n-                } else {\n-                    Vec::new()\n-                };\n-\n-                return VariantInfo {\n-                    args: arg_tys,\n-                    arg_names: None,\n-                    ctor_ty: Some(ctor_ty),\n-                    name: ast_variant.node.name.name,\n-                    id: ast_util::local_def(ast_variant.node.id),\n-                    disr_val: discriminant,\n-                    vis: ast_variant.node.vis\n-                };\n-            },\n-            ast::StructVariantKind(ref struct_def) => {\n-                let fields: &[StructField] = &struct_def.fields;\n-\n-                assert!(!fields.is_empty());\n-\n-                let arg_tys = struct_def.fields.iter()\n-                    .map(|field| cx.node_id_to_type(field.node.id)).collect();\n-                let arg_names = fields.iter().map(|field| {\n-                    match field.node.kind {\n-                        NamedField(ident, _) => ident.name,\n-                        UnnamedField(..) => cx.sess.bug(\n-                            \"enum_variants: all fields in struct must have a name\")\n-                    }\n-                }).collect();\n-\n-                return VariantInfo {\n-                    args: arg_tys,\n-                    arg_names: Some(arg_names),\n-                    ctor_ty: None,\n-                    name: ast_variant.node.name.name,\n-                    id: ast_util::local_def(ast_variant.node.id),\n-                    disr_val: discriminant,\n-                    vis: ast_variant.node.vis\n-                };\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n@@ -495,14 +417,6 @@ pub struct TypeAndMut<'tcx> {\n     pub mutbl: ast::Mutability,\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct FieldTy {\n-    pub name: Name,\n-    pub id: DefId,\n-    pub vis: ast::Visibility,\n-    pub origin: ast::DefId,  // The DefId of the struct in which the field is declared.\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n@@ -5667,18 +5581,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn field_idx_strict(&self, name: ast::Name, fields: &[Field<'tcx>])\n-                            -> usize {\n-        let mut i = 0;\n-        for f in fields { if f.name == name { return i; } i += 1; }\n-        self.sess.bug(&format!(\n-            \"no field named `{}` found in the list of fields `{:?}`\",\n-            name,\n-            fields.iter()\n-                  .map(|f| f.name.to_string())\n-                  .collect::<Vec<String>>()));\n-    }\n-\n     pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n         use self::TypeError::*;\n \n@@ -7341,12 +7243,6 @@ impl<'tcx> HasTypeFlags for FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> HasTypeFlags for Field<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.mt.ty.has_type_flags(flags)\n-    }\n-}\n-\n impl<'tcx> HasTypeFlags for BareFnTy<'tcx> {\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self.sig.has_type_flags(flags)\n@@ -7377,12 +7273,6 @@ impl<'tcx> fmt::Debug for ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for Field<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"field({},{})\", self.name, self.mt)\n-    }\n-}\n-\n impl<'a, 'tcx> fmt::Debug for ParameterEnvironment<'a, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ParameterEnvironment(\\"}, {"sha": "cc1efeaea080f39e1e633bb4bad2e684b56b1381", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=34942331a3288bbebc5a00fef57b6976afc0eb75", "patch": "@@ -275,15 +275,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Field<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Field<'tcx> {\n-        ty::Field {\n-            name: self.name,\n-            mt: self.mt.fold_with(folder),\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)"}, {"sha": "190e217aac15dc2be9269d098748325be7f64886", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34942331a3288bbebc5a00fef57b6976afc0eb75/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=34942331a3288bbebc5a00fef57b6976afc0eb75", "patch": "@@ -791,9 +791,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-            let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n-                f.name\n-            }).collect::<Vec<_>>();\n+            let fields = csearch::get_struct_field_names(&self.session.cstore, def_id);\n \n             if fields.is_empty() {\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);"}]}