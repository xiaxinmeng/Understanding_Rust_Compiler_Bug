{"sha": "b6852428a8ea9728369b64b9964cad8e258403d3", "node_id": "C_kwDOAAsO6NoAKGI2ODUyNDI4YThlYTk3MjgzNjliNjRiOTk2NGNhZDhlMjU4NDAzZDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-06T12:29:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-06T12:29:38Z"}, "message": "Auto merge of #105365 - matthiaskrgr:rollup-g0mrrt7, r=matthiaskrgr\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #104439 (Add prototype to generate `COPYRIGHT` from REUSE metadata)\n - #105005 (On E0195 point at where clause lifetime bounds)\n - #105098 (propagate the error from parsing enum variant to the parser and emit out)\n - #105243 (remove no-op 'let _ = ')\n - #105254 (Recurse into nested impl-trait when computing variance.)\n - #105287 (Synthesize substitutions for bad auto traits in dyn types)\n - #105310 (Be more careful about unresolved exprs in suggestion)\n - #105318 (Make `get_impl_future_output_ty` work with AFIT)\n - #105339 (support `ConstKind::Expr` in `is_const_evaluatable` and `WfPredicates::compute`)\n - #105340 (Avoid ICE by accounting for missing type)\n - #105342 (Make `note_obligation_cause_code`  take a `impl ToPredicate` for predicate)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "07c892e607e39ad00b0420417dc7ec109c2e12ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07c892e607e39ad00b0420417dc7ec109c2e12ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6852428a8ea9728369b64b9964cad8e258403d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6852428a8ea9728369b64b9964cad8e258403d3", "html_url": "https://github.com/rust-lang/rust/commit/b6852428a8ea9728369b64b9964cad8e258403d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6852428a8ea9728369b64b9964cad8e258403d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db224fc908059986c179fc6ec433944e9cfce50", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db224fc908059986c179fc6ec433944e9cfce50", "html_url": "https://github.com/rust-lang/rust/commit/9db224fc908059986c179fc6ec433944e9cfce50"}, {"sha": "a9ffe7c738e4e9a9367726b591f3145c784391ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ffe7c738e4e9a9367726b591f3145c784391ed", "html_url": "https://github.com/rust-lang/rust/commit/a9ffe7c738e4e9a9367726b591f3145c784391ed"}], "stats": {"total": 1526, "additions": 1404, "deletions": 122}, "files": [{"sha": "150a70341f5859c37b4a11800a6a5acb064ae6d8", "filename": "Cargo.lock", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -581,6 +581,7 @@ dependencies = [\n  \"libc\",\n  \"num-integer\",\n  \"num-traits\",\n+ \"serde\",\n  \"time\",\n  \"winapi\",\n ]\n@@ -730,6 +731,16 @@ dependencies = [\n  \"rustc-semver\",\n ]\n \n+[[package]]\n+name = \"collect-license-metadata\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"spdx-rs\",\n+]\n+\n [[package]]\n name = \"color-eyre\"\n version = \"0.6.2\"\n@@ -1552,6 +1563,15 @@ dependencies = [\n  \"termcolor\",\n ]\n \n+[[package]]\n+name = \"generate-copyright\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"generic-array\"\n version = \"0.14.4\"\n@@ -4864,6 +4884,35 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"spdx-expression\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"53d7ac03c67c572d85049d6db815e20a4a19b41b3d5cca732ac582342021ad77\"\n+dependencies = [\n+ \"nom\",\n+ \"serde\",\n+ \"thiserror\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"spdx-rs\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3c02f6eb7e7b4100c272f685a9ccaccaab302324e8c7ec3e2ee72340fb29ff3\"\n+dependencies = [\n+ \"chrono\",\n+ \"log\",\n+ \"nom\",\n+ \"serde\",\n+ \"spdx-expression\",\n+ \"strum\",\n+ \"strum_macros\",\n+ \"thiserror\",\n+ \"uuid\",\n+]\n+\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.2.0\"\n@@ -4967,6 +5016,25 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n \n+[[package]]\n+name = \"strum\"\n+version = \"0.24.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"063e6045c0e62079840579a7e47a355ae92f60eb74daaf156fb1e84ba164e63f\"\n+\n+[[package]]\n+name = \"strum_macros\"\n+version = \"0.24.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e385be0d24f186b4ce2f9982191e7101bb737312ad61c1f2f984f34bcf85d59\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustversion\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"syn\"\n version = \"1.0.102\"\n@@ -5596,6 +5664,15 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n \n+[[package]]\n+name = \"uuid\"\n+version = \"0.8.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+]\n+\n [[package]]\n name = \"valuable\"\n version = \"0.1.0\""}, {"sha": "000c10a1f906d6c161f1835651754679e35c3bd9", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -39,6 +39,8 @@ members = [\n   \"src/tools/bump-stage0\",\n   \"src/tools/replace-version-placeholder\",\n   \"src/tools/lld-wrapper\",\n+  \"src/tools/collect-license-metadata\",\n+  \"src/tools/generate-copyright\",\n ]\n \n exclude = ["}, {"sha": "3617bf58be9dd48dd17c18c8738eb566024e18c9", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -121,9 +121,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     pub(super) fn prove_predicates(\n         &mut self,\n-        predicates: impl IntoIterator<\n-            Item = impl ToPredicate<'tcx, ty::Predicate<'tcx>> + std::fmt::Debug,\n-        >,\n+        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx> + std::fmt::Debug>,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {\n@@ -135,7 +133,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     pub(super) fn prove_predicate(\n         &mut self,\n-        predicate: impl ToPredicate<'tcx, ty::Predicate<'tcx>> + std::fmt::Debug,\n+        predicate: impl ToPredicate<'tcx> + std::fmt::Debug,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {"}, {"sha": "a5cb8a88819df2d09a4ecd141748f5c5000de062", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -17,6 +17,8 @@ hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n     lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n     .label = lifetimes do not match {$item_kind} in trait\n     .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n+    .where_label = this `where` clause might not match the one in the trait\n+    .bounds_label = this bound might be missing in the impl\n \n hir_analysis_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for local structs, enums, and unions"}, {"sha": "1d6f9b29176518a30f487dca7eab58e0610b3ccf", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -751,27 +751,56 @@ fn check_region_bounds_on_impl_item<'tcx>(\n             .get_generics(impl_m.def_id.expect_local())\n             .expect(\"expected impl item to have generics or else we can't compare them\")\n             .span;\n-        let generics_span = if let Some(local_def_id) = trait_m.def_id.as_local() {\n-            Some(\n-                tcx.hir()\n-                    .get_generics(local_def_id)\n-                    .expect(\"expected trait item to have generics or else we can't compare them\")\n-                    .span,\n-            )\n-        } else {\n-            None\n-        };\n \n+        let mut generics_span = None;\n+        let mut bounds_span = vec![];\n+        let mut where_span = None;\n+        if let Some(trait_node) = tcx.hir().get_if_local(trait_m.def_id)\n+            && let Some(trait_generics) = trait_node.generics()\n+        {\n+            generics_span = Some(trait_generics.span);\n+            // FIXME: we could potentially look at the impl's bounds to not point at bounds that\n+            // *are* present in the impl.\n+            for p in trait_generics.predicates {\n+                if let hir::WherePredicate::BoundPredicate(pred) = p {\n+                    for b in pred.bounds {\n+                        if let hir::GenericBound::Outlives(lt) = b {\n+                            bounds_span.push(lt.ident.span);\n+                        }\n+                    }\n+                }\n+            }\n+            if let Some(impl_node) = tcx.hir().get_if_local(impl_m.def_id)\n+                && let Some(impl_generics) = impl_node.generics()\n+            {\n+                let mut impl_bounds = 0;\n+                for p in impl_generics.predicates {\n+                    if let hir::WherePredicate::BoundPredicate(pred) = p {\n+                        for b in pred.bounds {\n+                            if let hir::GenericBound::Outlives(_) = b {\n+                                impl_bounds += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+                if impl_bounds == bounds_span.len() {\n+                    bounds_span = vec![];\n+                } else if impl_generics.has_where_clause_predicates {\n+                    where_span = Some(impl_generics.where_clause_span);\n+                }\n+            }\n+        }\n         let reported = tcx\n             .sess\n             .create_err(LifetimesOrBoundsMismatchOnTrait {\n                 span,\n                 item_kind: assoc_item_kind_str(impl_m),\n                 ident: impl_m.ident(tcx),\n                 generics_span,\n+                bounds_span,\n+                where_span,\n             })\n             .emit_unless(delay);\n-\n         return Err(reported);\n     }\n "}, {"sha": "5156d432b5b3720cbdfc7acdd57fcfbbc0ca2007", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -43,6 +43,10 @@ pub struct LifetimesOrBoundsMismatchOnTrait {\n     pub span: Span,\n     #[label(generics_label)]\n     pub generics_span: Option<Span>,\n+    #[label(where_label)]\n+    pub where_span: Option<Span>,\n+    #[label(bounds_label)]\n+    pub bounds_span: Vec<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }"}, {"sha": "8b2719c2f8aaaef1add2f372c81751f7b6bdc8c2", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -7,7 +7,8 @@ use rustc_arena::DroplessArena;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, CrateVariancesMap, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_middle::ty::{self, CrateVariancesMap, SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{DefIdTree, TypeSuperVisitable, TypeVisitable};\n use std::ops::ControlFlow;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n@@ -75,18 +76,50 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n     // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;\n     // ```\n     // we may not use `'c` in the hidden type.\n-    struct OpaqueTypeLifetimeCollector {\n+    struct OpaqueTypeLifetimeCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        root_def_id: DefId,\n         variances: Vec<ty::Variance>,\n     }\n \n-    impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector {\n+    impl<'tcx> OpaqueTypeLifetimeCollector<'tcx> {\n+        #[instrument(level = \"trace\", skip(self), ret)]\n+        fn visit_opaque(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) -> ControlFlow<!> {\n+            if def_id != self.root_def_id && self.tcx.is_descendant_of(def_id, self.root_def_id) {\n+                let child_variances = self.tcx.variances_of(def_id);\n+                for (a, v) in substs.iter().zip(child_variances) {\n+                    if *v != ty::Bivariant {\n+                        a.visit_with(self)?;\n+                    }\n+                }\n+                ControlFlow::CONTINUE\n+            } else {\n+                substs.visit_with(self)\n+            }\n+        }\n+    }\n+\n+    impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector<'tcx> {\n         #[instrument(level = \"trace\", skip(self), ret)]\n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if let ty::RegionKind::ReEarlyBound(ebr) = r.kind() {\n                 self.variances[ebr.index as usize] = ty::Invariant;\n             }\n             r.super_visit_with(self)\n         }\n+\n+        #[instrument(level = \"trace\", skip(self), ret)]\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            match t.kind() {\n+                ty::Opaque(def_id, substs) => self.visit_opaque(*def_id, substs),\n+                ty::Projection(proj)\n+                    if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+                {\n+                    self.visit_opaque(proj.item_def_id, proj.substs)\n+                }\n+                _ => t.super_visit_with(self),\n+            }\n+        }\n     }\n \n     // By default, RPIT are invariant wrt type and const generics, but they are bivariant wrt\n@@ -111,7 +144,8 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         }\n     }\n \n-    let mut collector = OpaqueTypeLifetimeCollector { variances };\n+    let mut collector =\n+        OpaqueTypeLifetimeCollector { tcx, root_def_id: item_def_id.to_def_id(), variances };\n     let id_substs = ty::InternalSubsts::identity_for_item(tcx, item_def_id.to_def_id());\n     for pred in tcx.bound_explicit_item_bounds(item_def_id.to_def_id()).transpose_iter() {\n         let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);"}, {"sha": "db93cfab2c0dbd6a45508b9c35607b642cfe6c51", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -1482,25 +1482,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ident_name: Symbol,\n         }\n \n+        // FIXME: This really should be taking scoping, etc into account.\n         impl<'v> Visitor<'v> for LetVisitor<'v> {\n             fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n-                if let hir::StmtKind::Local(hir::Local { pat, init, .. }) = &ex.kind {\n-                    if let Binding(_, _, ident, ..) = pat.kind &&\n-                        ident.name == self.ident_name {\n-                        self.result = *init;\n-                    }\n+                if let hir::StmtKind::Local(hir::Local { pat, init, .. }) = &ex.kind\n+                    && let Binding(_, _, ident, ..) = pat.kind\n+                    && ident.name == self.ident_name\n+                {\n+                    self.result = *init;\n+                } else {\n+                    hir::intravisit::walk_stmt(self, ex);\n                 }\n-                hir::intravisit::walk_stmt(self, ex);\n             }\n         }\n \n         let mut visitor = LetVisitor { result: None, ident_name: seg1.ident.name };\n         visitor.visit_body(&body);\n \n         let parent = self.tcx.hir().get_parent_node(seg1.hir_id);\n-        if let Some(Node::Expr(call_expr)) = self.tcx.hir().find(parent) &&\n-            let Some(expr) = visitor.result {\n-            let self_ty = self.node_ty(expr.hir_id);\n+        if let Some(Node::Expr(call_expr)) = self.tcx.hir().find(parent)\n+            && let Some(expr) = visitor.result\n+            && let Some(self_ty) = self.node_ty_opt(expr.hir_id)\n+        {\n             let probe = self.lookup_probe(\n                 seg2.ident,\n                 self_ty,\n@@ -1513,7 +1516,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     sm.span_extend_while(seg1.ident.span.shrink_to_hi(), |c| c == ':').unwrap(),\n                     \"you may have meant to call an instance method\",\n                     \".\".to_string(),\n-                    Applicability::MaybeIncorrect\n+                    Applicability::MaybeIncorrect,\n                 );\n             }\n         }"}, {"sha": "3256ca1fb20fbaff5fd3effea13ae9db8d415082", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -341,7 +341,15 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n \n impl<'tcx> InferCtxt<'tcx> {\n     pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-        let ty::Opaque(def_id, substs) = *ty.kind() else { return None; };\n+        let (def_id, substs) = match *ty.kind() {\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n+            ty::Projection(data)\n+                if self.tcx.def_kind(data.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            {\n+                (data.item_def_id, data.substs)\n+            }\n+            _ => return None,\n+        };\n \n         let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n         let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];"}, {"sha": "48329da3e63326049a5878ba502c28f0b1c73a19", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -101,6 +101,20 @@ impl GenericParamDef {\n             _ => None,\n         }\n     }\n+\n+    pub fn to_error<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        preceding_substs: &[ty::GenericArg<'tcx>],\n+    ) -> ty::GenericArg<'tcx> {\n+        match &self.kind {\n+            ty::GenericParamDefKind::Lifetime => tcx.lifetimes.re_static.into(),\n+            ty::GenericParamDefKind::Type { .. } => tcx.ty_error().into(),\n+            ty::GenericParamDefKind::Const { .. } => {\n+                tcx.const_error(tcx.bound_type_of(self.def_id).subst(tcx, preceding_substs)).into()\n+            }\n+        }\n+    }\n }\n \n #[derive(Default)]"}, {"sha": "f89a8cdfdeec3bbc317860916eaedfe2b4b6532d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -1150,8 +1150,8 @@ impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n     }\n }\n \n-pub trait ToPredicate<'tcx, Predicate> {\n-    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate;\n+pub trait ToPredicate<'tcx, P = Predicate<'tcx>> {\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> P;\n }\n \n impl<'tcx, T> ToPredicate<'tcx, T> for T {\n@@ -1160,21 +1160,21 @@ impl<'tcx, T> ToPredicate<'tcx, T> for T {\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, PredicateKind<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, PredicateKind<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(self)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Clause<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for Clause<'tcx> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::Clause(self)))\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for Binder<'tcx, TraitRef<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         let pred: PolyTraitPredicate<'tcx> = self.to_predicate(tcx);\n@@ -1193,25 +1193,25 @@ impl<'tcx> ToPredicate<'tcx, PolyTraitPredicate<'tcx>> for Binder<'tcx, TraitRef\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyTraitPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyTraitPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::Trait(p))).to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyRegionOutlivesPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::RegionOutlives(p))).to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyTypeOutlivesPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::TypeOutlives(p))).to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx, Predicate<'tcx>> for PolyProjectionPredicate<'tcx> {\n+impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.map_bound(|p| PredicateKind::Clause(Clause::Projection(p))).to_predicate(tcx)\n     }"}, {"sha": "1eec119616ea7cdee5eadc64d0ab86f92a8dfc05", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -722,8 +722,17 @@ impl<'tcx> PolyExistentialPredicate<'tcx> {\n                 self.rebind(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n-                let trait_ref = self.rebind(tcx.mk_trait_ref(did, [self_ty]));\n-                trait_ref.without_const().to_predicate(tcx)\n+                let generics = tcx.generics_of(did);\n+                let trait_ref = if generics.params.len() == 1 {\n+                    tcx.mk_trait_ref(did, [self_ty])\n+                } else {\n+                    // If this is an ill-formed auto trait, then synthesize\n+                    // new error substs for the missing generics.\n+                    let err_substs =\n+                        ty::InternalSubsts::extend_with_error(tcx, did, &[self_ty.into()]);\n+                    tcx.mk_trait_ref(did, err_substs)\n+                };\n+                self.rebind(trait_ref).without_const().to_predicate(tcx)\n             }\n         }\n     }"}, {"sha": "23507d280459230849d781b5f66205a8a12e7c6c", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -352,6 +352,22 @@ impl<'tcx> InternalSubsts<'tcx> {\n         }\n     }\n \n+    // Extend an `original_substs` list to the full number of substs expected by `def_id`,\n+    // filling in the missing parameters with error ty/ct or 'static regions.\n+    pub fn extend_with_error(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        original_substs: &[GenericArg<'tcx>],\n+    ) -> SubstsRef<'tcx> {\n+        ty::InternalSubsts::for_item(tcx, def_id, |def, substs| {\n+            if let Some(subst) = original_substs.get(def.index as usize) {\n+                *subst\n+            } else {\n+                def.to_error(tcx, substs)\n+            }\n+        })\n+    }\n+\n     #[inline]\n     pub fn types(&'tcx self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'tcx {\n         self.iter()"}, {"sha": "03f25392a7c1f90094ccf4fb2ce067a598f8210b", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -1414,7 +1414,10 @@ impl<'a> Parser<'a> {\n \n                 Ok((Some(vr), TrailingToken::MaybeComma))\n             },\n-        )\n+        ).map_err(|mut err|{\n+            err.help(\"enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\");\n+            err\n+        })\n     }\n \n     /// Parses `struct Foo { ... }`."}, {"sha": "bebb012660a16ae140a780bb5da5049761bc0faa", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -943,6 +943,10 @@ impl<'a> Parser<'a> {\n                                 Err(e) => {\n                                     // Parsing failed, therefore it must be something more serious\n                                     // than just a missing separator.\n+                                    for xx in &e.children {\n+                                        // propagate the help message from sub error 'e' to main error 'expect_err;\n+                                        expect_err.children.push(xx.clone());\n+                                    }\n                                     expect_err.emit();\n \n                                     e.cancel();"}, {"sha": "0102d268b42e18b51e558247d042f9120092fabd", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -70,7 +70,7 @@ pub fn codegen_select_candidate<'tcx>(\n         // `rustc_ty_utils::resolve_associated_item` doesn't return `None` post-monomorphization.\n         for err in errors {\n             if let FulfillmentErrorCode::CodeCycle(cycle) = err.code {\n-                infcx.err_ctxt().report_overflow_error_cycle(&cycle);\n+                infcx.err_ctxt().report_overflow_obligation_cycle(&cycle);\n             }\n         }\n         return Err(CodegenObligationError::FulfillmentError);"}, {"sha": "d01c6bac2963be6e0329a384d4bfc4957689d2e7", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -25,15 +25,13 @@ use crate::traits::ObligationCtxt;\n #[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n-    ct: ty::Const<'tcx>,\n+    unexpanded_ct: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n     let tcx = infcx.tcx;\n-    let uv = match ct.kind() {\n-        ty::ConstKind::Unevaluated(uv) => uv,\n-        // FIXME(generic_const_exprs): this seems wrong but I couldn't find a way to get this to trigger\n-        ty::ConstKind::Expr(_) => bug!(\"unexpected expr in `is_const_evaluatable: {ct:?}\"),\n+    match unexpanded_ct.kind() {\n+        ty::ConstKind::Unevaluated(_) | ty::ConstKind::Expr(_) => (),\n         ty::ConstKind::Param(_)\n         | ty::ConstKind::Bound(_, _)\n         | ty::ConstKind::Placeholder(_)\n@@ -43,7 +41,7 @@ pub fn is_const_evaluatable<'tcx>(\n     };\n \n     if tcx.features().generic_const_exprs {\n-        let ct = tcx.expand_abstract_consts(ct);\n+        let ct = tcx.expand_abstract_consts(unexpanded_ct);\n \n         let is_anon_ct = if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n             tcx.def_kind(uv.def.did) == DefKind::AnonConst\n@@ -62,18 +60,40 @@ pub fn is_const_evaluatable<'tcx>(\n             }\n         }\n \n-        let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n-        match concrete {\n-            Err(ErrorHandled::TooGeneric) => Err(NotConstEvaluatable::Error(\n-                infcx\n-                    .tcx\n-                    .sess\n-                    .delay_span_bug(span, \"Missing value for constant, but no error reported?\"),\n-            )),\n-            Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n-            Ok(_) => Ok(()),\n+        match unexpanded_ct.kind() {\n+            ty::ConstKind::Expr(_) => {\n+                // FIXME(generic_const_exprs): we have a `ConstKind::Expr` which is fully concrete, but\n+                // currently it is not possible to evaluate `ConstKind::Expr` so we are unable to tell if it\n+                // is evaluatable or not. For now we just ICE until this is implemented this.\n+                Err(NotConstEvaluatable::Error(tcx.sess.delay_span_bug(\n+                    span,\n+                    \"evaluating `ConstKind::Expr` is not currently supported\",\n+                )))\n+            }\n+            ty::ConstKind::Unevaluated(uv) => {\n+                let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n+                match concrete {\n+                    Err(ErrorHandled::TooGeneric) => {\n+                        Err(NotConstEvaluatable::Error(infcx.tcx.sess.delay_span_bug(\n+                            span,\n+                            \"Missing value for constant, but no error reported?\",\n+                        )))\n+                    }\n+                    Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n+                    Ok(_) => Ok(()),\n+                }\n+            }\n+            _ => bug!(\"unexpected constkind in `is_const_evalautable: {unexpanded_ct:?}`\"),\n         }\n     } else {\n+        let uv = match unexpanded_ct.kind() {\n+            ty::ConstKind::Unevaluated(uv) => uv,\n+            ty::ConstKind::Expr(_) => {\n+                bug!(\"`ConstKind::Expr` without `feature(generic_const_exprs)` enabled\")\n+            }\n+            _ => bug!(\"unexpected constkind in `is_const_evalautable: {unexpanded_ct:?}`\"),\n+        };\n+\n         // FIXME: We should only try to evaluate a given constant here if it is fully concrete\n         // as we don't want to allow things like `[u8; std::mem::size_of::<*mut T>()]`.\n         //\n@@ -92,7 +112,7 @@ pub fn is_const_evaluatable<'tcx>(\n                     && satisfied_from_param_env(\n                         tcx,\n                         infcx,\n-                        tcx.expand_abstract_consts(ct),\n+                        tcx.expand_abstract_consts(unexpanded_ct),\n                         param_env,\n                     ) =>\n             {\n@@ -152,6 +172,7 @@ fn satisfied_from_param_env<'tcx>(\n     impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n         type BreakTy = ();\n         fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            debug!(\"is_const_evaluatable: candidate={:?}\", c);\n             if let Ok(()) = self.infcx.commit_if_ok(|_| {\n                 let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n                 if let Ok(()) = ocx.eq(&ObligationCause::dummy(), self.param_env, c.ty(), self.ct.ty())\n@@ -187,13 +208,14 @@ fn satisfied_from_param_env<'tcx>(\n                 let result = b_ct.visit_with(&mut v);\n \n                 if let ControlFlow::Break(()) = result {\n-                    debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                    debug!(\"is_const_evaluatable: yes\");\n                     return true;\n                 }\n             }\n             _ => {} // don't care\n         }\n     }\n \n+    debug!(\"is_const_evaluatable: no\");\n     false\n }"}, {"sha": "dda7b2b2fa5b0b392ce3d19f080c236152a8284e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -99,26 +99,36 @@ pub trait InferCtxtExt<'tcx> {\n }\n \n pub trait TypeErrCtxtExt<'tcx> {\n+    fn report_overflow_error<T>(\n+        &self,\n+        predicate: &T,\n+        span: Span,\n+        suggest_increasing_limit: bool,\n+        mutate: impl FnOnce(&mut Diagnostic),\n+    ) -> !\n+    where\n+        T: fmt::Display\n+            + TypeFoldable<'tcx>\n+            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n+        <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug;\n+\n     fn report_fulfillment_errors(\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n         body_id: Option<hir::BodyId>,\n     ) -> ErrorGuaranteed;\n \n-    fn report_overflow_error<T>(\n+    fn report_overflow_obligation<T>(\n         &self,\n         obligation: &Obligation<'tcx, T>,\n         suggest_increasing_limit: bool,\n     ) -> !\n     where\n-        T: fmt::Display\n-            + TypeFoldable<'tcx>\n-            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n-        <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug;\n+        T: ToPredicate<'tcx> + Clone;\n \n     fn suggest_new_overflow_limit(&self, err: &mut Diagnostic);\n \n-    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n+    fn report_overflow_obligation_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n \n     /// The `root_obligation` parameter should be the `root_obligation` field\n     /// from a `FulfillmentError`. If no `FulfillmentError` is available,\n@@ -458,17 +468,20 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     /// occurrences in any case.\n     fn report_overflow_error<T>(\n         &self,\n-        obligation: &Obligation<'tcx, T>,\n+        predicate: &T,\n+        span: Span,\n         suggest_increasing_limit: bool,\n+        mutate: impl FnOnce(&mut Diagnostic),\n     ) -> !\n     where\n         T: fmt::Display\n             + TypeFoldable<'tcx>\n             + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n         <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug,\n     {\n-        let predicate = self.resolve_vars_if_possible(obligation.predicate.clone());\n+        let predicate = self.resolve_vars_if_possible(predicate.clone());\n         let mut pred_str = predicate.to_string();\n+\n         if pred_str.len() > 50 {\n             // We don't need to save the type to a file, we will be talking about this type already\n             // in a separate note when we explain the obligation, so it will be available that way.\n@@ -483,7 +496,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n-            obligation.cause.span,\n+            span,\n             E0275,\n             \"overflow evaluating the requirement `{}`\",\n             pred_str,\n@@ -493,20 +506,46 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             self.suggest_new_overflow_limit(&mut err);\n         }\n \n-        self.note_obligation_cause_code(\n-            &mut err,\n-            &obligation.predicate,\n-            obligation.param_env,\n-            obligation.cause.code(),\n-            &mut vec![],\n-            &mut Default::default(),\n-        );\n+        mutate(&mut err);\n \n         err.emit();\n         self.tcx.sess.abort_if_errors();\n         bug!();\n     }\n \n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    fn report_overflow_obligation<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: ToPredicate<'tcx> + Clone,\n+    {\n+        let predicate = obligation.predicate.clone().to_predicate(self.tcx);\n+        let predicate = self.resolve_vars_if_possible(predicate);\n+        self.report_overflow_error(\n+            &predicate,\n+            obligation.cause.span,\n+            suggest_increasing_limit,\n+            |err| {\n+                self.note_obligation_cause_code(\n+                    err,\n+                    &predicate,\n+                    obligation.param_env,\n+                    obligation.cause.code(),\n+                    &mut vec![],\n+                    &mut Default::default(),\n+                );\n+            },\n+        );\n+    }\n+\n     fn suggest_new_overflow_limit(&self, err: &mut Diagnostic) {\n         let suggested_limit = match self.tcx.recursion_limit() {\n             Limit(0) => Limit(2),\n@@ -521,19 +560,22 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n \n     /// Reports that a cycle was detected which led to overflow and halts\n-    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// compilation. This is equivalent to `report_overflow_obligation` except\n     /// that we can give a more helpful error message (and, in particular,\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n-    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+    fn report_overflow_obligation_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n         let cycle = self.resolve_vars_if_possible(cycle.to_owned());\n         assert!(!cycle.is_empty());\n \n         debug!(?cycle, \"report_overflow_error_cycle\");\n \n         // The 'deepest' obligation is most likely to have a useful\n         // cause 'backtrace'\n-        self.report_overflow_error(cycle.iter().max_by_key(|p| p.recursion_depth).unwrap(), false);\n+        self.report_overflow_obligation(\n+            cycle.iter().max_by_key(|p| p.recursion_depth).unwrap(),\n+            false,\n+        );\n     }\n \n     fn report_selection_error(\n@@ -1554,7 +1596,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 diag.emit();\n             }\n             FulfillmentErrorCode::CodeCycle(ref cycle) => {\n-                self.report_overflow_error_cycle(cycle);\n+                self.report_overflow_obligation_cycle(cycle);\n             }\n         }\n     }\n@@ -1607,7 +1649,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         | ObligationCauseCode::ObjectCastObligation(..)\n                         | ObligationCauseCode::OpaqueType\n                 );\n-                let expected_ty = data.term.ty().unwrap();\n+                let expected_ty = data.term.ty().unwrap_or_else(|| self.tcx.ty_error());\n \n                 // constrain inference variables a bit more to nested obligations from normalize so\n                 // we can have more helpful errors."}, {"sha": "6ea54b625bbc0f8e533de1fabf88c6ad5f9dcdbc", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -298,7 +298,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display + ToPredicate<'tcx, T>;\n+        T: fmt::Display + ToPredicate<'tcx>;\n \n     /// Suggest to await before try: future? => future.await?\n     fn suggest_await_before_try(\n@@ -2353,7 +2353,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n-        T: fmt::Display,\n+        T: fmt::Display + ToPredicate<'tcx>,\n     {\n         let tcx = self.tcx;\n         match *cause_code {"}, {"sha": "d3cfd61e1956d7d82fd433772f0dd2275995a6b2", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -150,7 +150,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n fn pred_known_to_hold_modulo_regions<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    pred: impl ToPredicate<'tcx, ty::Predicate<'tcx>> + TypeVisitable<'tcx>,\n+    pred: impl ToPredicate<'tcx> + TypeVisitable<'tcx>,\n     span: Span,\n ) -> bool {\n     let has_non_region_infer = pred.has_non_region_infer();"}, {"sha": "5789754e4fcefd6f19fa458f1f80cd5e4d7e5445", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -504,14 +504,12 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     Reveal::All => {\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.depth) {\n-                            let obligation = Obligation::with_depth(\n-                                self.tcx(),\n-                                self.cause.clone(),\n-                                recursion_limit.0,\n-                                self.param_env,\n-                                ty,\n+                            self.selcx.infcx.err_ctxt().report_overflow_error(\n+                                &ty,\n+                                self.cause.span,\n+                                true,\n+                                |_| {},\n                             );\n-                            self.selcx.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let substs = substs.fold_with(self);"}, {"sha": "7ad532d8a34645544996dd1930fbf45284d9d1b7", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -7,7 +7,7 @@ use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::{needs_normalization, BoundVarReplacer, PlaceholderReplacer};\n-use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n+use crate::traits::{ObligationCause, PredicateObligation, Reveal};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_infer::traits::Normalized;\n@@ -214,14 +214,12 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                         let substs = substs.try_fold_with(self)?;\n                         let recursion_limit = self.tcx().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n-                            let obligation = Obligation::with_depth(\n-                                self.tcx(),\n-                                self.cause.clone(),\n-                                recursion_limit.0,\n-                                self.param_env,\n-                                ty,\n+                            self.infcx.err_ctxt().report_overflow_error(\n+                                &ty,\n+                                self.cause.span,\n+                                true,\n+                                |_| {},\n                             );\n-                            self.infcx.err_ctxt().report_overflow_error(&obligation, true);\n                         }\n \n                         let generic_ty = self.tcx().bound_type_of(def_id);"}, {"sha": "035deb61639817c57d897a9ffdcb75db304aacaa", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -43,7 +43,6 @@ use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::print::{FmtPrinter, Print};\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, EarlyBinder, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n@@ -1313,18 +1312,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         error_obligation: &Obligation<'tcx, T>,\n     ) -> Result<(), OverflowError>\n     where\n-        T: fmt::Display\n-            + TypeFoldable<'tcx>\n-            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n-        <T as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug,\n+        T: ToPredicate<'tcx> + Clone,\n     {\n         if !self.infcx.tcx.recursion_limit().value_within_limit(depth) {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n                     if let Some(e) = self.infcx.tainted_by_errors() {\n                         return Err(OverflowError::Error(e));\n                     }\n-                    self.infcx.err_ctxt().report_overflow_error(error_obligation, true);\n+                    self.infcx.err_ctxt().report_overflow_obligation(error_obligation, true);\n                 }\n                 TraitQueryMode::Canonical => {\n                     return Err(OverflowError::Canonical);\n@@ -1345,10 +1341,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         error_obligation: &Obligation<'tcx, V>,\n     ) -> Result<(), OverflowError>\n     where\n-        V: fmt::Display\n-            + TypeFoldable<'tcx>\n-            + Print<'tcx, FmtPrinter<'tcx, 'tcx>, Output = FmtPrinter<'tcx, 'tcx>>,\n-        <V as Print<'tcx, FmtPrinter<'tcx, 'tcx>>>::Error: std::fmt::Debug,\n+        V: ToPredicate<'tcx> + Clone,\n     {\n         self.check_recursion_depth(obligation.recursion_depth, error_obligation)\n     }"}, {"sha": "e47ba64245f50732f0b95a7eddf143b5341bc555", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -476,9 +476,24 @@ impl<'tcx> WfPredicates<'tcx> {\n                                 ty::Binder::dummy(ty::PredicateKind::WellFormed(ct.into())),\n                             ));\n                         }\n-                        // FIXME(generic_const_exprs): This seems wrong but I could not find a way to get this to trigger\n                         ty::ConstKind::Expr(_) => {\n-                            bug!(\"checking wfness of `ConstKind::Expr` is unsupported\")\n+                            // FIXME(generic_const_exprs): this doesnt verify that given `Expr(N + 1)` the\n+                            // trait bound `typeof(N): Add<typeof(1)>` holds. This is currently unnecessary\n+                            // as `ConstKind::Expr` is only produced via normalization of `ConstKind::Unevaluated`\n+                            // which means that the `DefId` would have been typeck'd elsewhere. However in\n+                            // the future we may allow directly lowering to `ConstKind::Expr` in which case\n+                            // we would not be proving bounds we should.\n+\n+                            let predicate =\n+                                ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct));\n+                            let cause = self.cause(traits::WellFormed(None));\n+                            self.out.push(traits::Obligation::with_depth(\n+                                self.tcx(),\n+                                cause,\n+                                self.recursion_depth,\n+                                self.param_env,\n+                                predicate,\n+                            ));\n                         }\n \n                         ty::ConstKind::Error(_)"}, {"sha": "ca54cbd2d68dc213051f86673ddf3e7fa965cba7", "filename": "config.toml.example", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -255,6 +255,16 @@ changelog-seen = 2\n # Defaults to the Python interpreter used to execute x.py\n #python = \"python\"\n \n+# The path to the REUSE executable to use. Note that REUSE is not required in\n+# most cases, as our tooling relies on a cached (and shrinked) copy of the\n+# REUSE output present in the git repository and in our source tarballs.\n+#\n+# REUSE is only needed if your changes caused the overral licensing of the\n+# repository to change, and the cached copy has to be regenerated.\n+#\n+# Defaults to the \"reuse\" command in the system path.\n+#reuse = \"reuse\"\n+\n # Force Cargo to check that Cargo.lock describes the precise dependency\n # set that all the Cargo.toml files create, instead of updating it.\n #locked-deps = false"}, {"sha": "adb488d4378f0391140e6eadf604603720f8776f", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -629,9 +629,7 @@ impl<T> Clone for Sender<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Sender<T> {\n-    fn drop(&mut self) {\n-        let _ = self.inner;\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\n@@ -751,9 +749,7 @@ impl<T> Clone for SyncSender<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for SyncSender<T> {\n-    fn drop(&mut self) {\n-        let _ = self.inner;\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\n@@ -1094,9 +1090,7 @@ impl<T> IntoIterator for Receiver<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Receiver<T> {\n-    fn drop(&mut self) {\n-        let _ = self.inner;\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]"}, {"sha": "8ee6d49da8f0e419b4fc9ff2898a4e21f5c47bae", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -754,6 +754,8 @@ impl<'a> Builder<'a> {\n                 run::BumpStage0,\n                 run::ReplaceVersionPlaceholder,\n                 run::Miri,\n+                run::CollectLicenseMetadata,\n+                run::GenerateCopyright,\n             ),\n             // These commands either don't use paths, or they're special-cased in Build::build()\n             Kind::Clean | Kind::Format | Kind::Setup => vec![],"}, {"sha": "d8c15c76e2d615b3a936a0b4e8616077a92d3c87", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -213,6 +213,7 @@ pub struct Config {\n     pub npm: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n     pub python: Option<PathBuf>,\n+    pub reuse: Option<PathBuf>,\n     pub cargo_native_static: bool,\n     pub configure_args: Vec<String>,\n \n@@ -611,6 +612,7 @@ define_config! {\n         nodejs: Option<String> = \"nodejs\",\n         npm: Option<String> = \"npm\",\n         python: Option<String> = \"python\",\n+        reuse: Option<String> = \"reuse\",\n         locked_deps: Option<bool> = \"locked-deps\",\n         vendor: Option<bool> = \"vendor\",\n         full_bootstrap: Option<bool> = \"full-bootstrap\",\n@@ -1004,6 +1006,7 @@ impl Config {\n         config.npm = build.npm.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n         config.python = build.python.map(PathBuf::from);\n+        config.reuse = build.reuse.map(PathBuf::from);\n         config.submodules = build.submodules;\n         set(&mut config.low_priority, build.low_priority);\n         set(&mut config.compiler_docs, build.compiler_docs);"}, {"sha": "05de51f8cc57933b886fb6a7b1d2436e4c728316", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -1,3 +1,4 @@\n+use std::path::PathBuf;\n use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -189,3 +190,65 @@ impl Step for Miri {\n         builder.run(&mut miri);\n     }\n }\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct CollectLicenseMetadata;\n+\n+impl Step for CollectLicenseMetadata {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/collect-license-metadata\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(CollectLicenseMetadata);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let Some(reuse) = &builder.config.reuse else {\n+            panic!(\"REUSE is required to collect the license metadata\");\n+        };\n+\n+        // Temporary location, it will be moved to src/etc once it's accurate.\n+        let dest = builder.out.join(\"license-metadata.json\");\n+\n+        let mut cmd = builder.tool_cmd(Tool::CollectLicenseMetadata);\n+        cmd.env(\"REUSE_EXE\", reuse);\n+        cmd.env(\"DEST\", &dest);\n+        builder.run(&mut cmd);\n+\n+        dest\n+    }\n+}\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct GenerateCopyright;\n+\n+impl Step for GenerateCopyright {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/generate-copyright\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(GenerateCopyright);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let license_metadata = builder.ensure(CollectLicenseMetadata);\n+\n+        // Temporary location, it will be moved to the proper one once it's accurate.\n+        let dest = builder.out.join(\"COPYRIGHT.md\");\n+\n+        let mut cmd = builder.tool_cmd(Tool::GenerateCopyright);\n+        cmd.env(\"LICENSE_METADATA\", &license_metadata);\n+        cmd.env(\"DEST\", &dest);\n+        builder.run(&mut cmd);\n+\n+        dest\n+    }\n+}"}, {"sha": "8a40b0f64f4b6c5673ce6fc1c885f4622958c0e0", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -140,6 +140,13 @@ than building it.\n         .map(|p| cmd_finder.must_have(p))\n         .or_else(|| cmd_finder.maybe_have(\"gdb\"));\n \n+    build.config.reuse = build\n+        .config\n+        .reuse\n+        .take()\n+        .map(|p| cmd_finder.must_have(p))\n+        .or_else(|| cmd_finder.maybe_have(\"reuse\"));\n+\n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in &build.targets {"}, {"sha": "e0be4c432f168baceeb1a32666d3a1c482d94e90", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -380,6 +380,8 @@ bootstrap_tool!(\n     HtmlChecker, \"src/tools/html-checker\", \"html-checker\";\n     BumpStage0, \"src/tools/bump-stage0\", \"bump-stage0\";\n     ReplaceVersionPlaceholder, \"src/tools/replace-version-placeholder\", \"replace-version-placeholder\";\n+    CollectLicenseMetadata, \"src/tools/collect-license-metadata\", \"collect-license-metadata\";\n+    GenerateCopyright, \"src/tools/generate-copyright\", \"generate-copyright\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "3446761d119da5aa2ca703d8ee427324158e9633", "filename": "src/test/ui/async-await/in-trait/return-type-suggestion.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,14 @@\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+//~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+\n+trait A {\n+    async fn e() {\n+        Ok(())\n+        //~^ ERROR mismatched types\n+        //~| HELP consider using a semicolon here\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5a9b15e54a00869b35f5cb2974ad29d28b109ffe", "filename": "src/test/ui/async-await/in-trait/return-type-suggestion.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Freturn-type-suggestion.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,23 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/return-type-suggestion.rs:3:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-type-suggestion.rs:8:9\n+   |\n+LL |         Ok(())\n+   |         ^^^^^^- help: consider using a semicolon here: `;`\n+   |         |\n+   |         expected `()`, found enum `Result`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<(), _>`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3f8ac14c72d9538078dcf3317166b6e80a5f6750", "filename": "src/test/ui/auto-traits/bad-generics-on-dyn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,11 @@\n+#![feature(auto_traits)]\n+\n+auto trait Trait1<'a> {}\n+//~^ ERROR auto traits cannot have generic parameters\n+\n+fn f<'a>(x: &dyn Trait1<'a>)\n+{}\n+\n+fn main() {\n+    f(&1);\n+}"}, {"sha": "ade69ced6060d32cff0b96abcf4eafe1aa999d81", "filename": "src/test/ui/auto-traits/bad-generics-on-dyn.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fbad-generics-on-dyn.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,11 @@\n+error[E0567]: auto traits cannot have generic parameters\n+  --> $DIR/bad-generics-on-dyn.rs:3:18\n+   |\n+LL | auto trait Trait1<'a> {}\n+   |            ------^^^^ help: remove the parameters\n+   |            |\n+   |            auto trait cannot have generic parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0567`."}, {"sha": "6093fc70b16965c6153db11740f9e3a0efd02386", "filename": "src/test/ui/const-generics/generic_const_exprs/const_kind_expr/wf_obligation.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,22 @@\n+#![feature(generic_const_exprs, generic_arg_infer)]\n+#![allow(incomplete_features)]\n+\n+// minimized repro for #105205\n+//\n+// the `foo::<_, L>` call results in a `WellFormed(_)` obligation and a\n+// `ConstEvaluatable(Unevaluated(_ + 1 + L))` obligation. Attempting to fulfill the latter\n+// unifies the `_` with `Expr(L - 1)` from the paramenv which turns the `WellFormed`\n+// obligation into `WellFormed(Expr(L - 1))`\n+\n+fn foo<const N: usize, const M: usize>(_: [(); N + 1 + M]) {}\n+\n+fn ice<const L: usize>()\n+where\n+    [(); (L - 1) + 1 + L]:,\n+{\n+    foo::<_, L>([(); L + 1 + L]);\n+    //~^ ERROR: mismatched types\n+    //~^^ ERROR: unconstrained generic constant\n+}\n+\n+fn main() {}"}, {"sha": "da5194696e657bb032741d6d31fd29cf02847321", "filename": "src/test/ui/const-generics/generic_const_exprs/const_kind_expr/wf_obligation.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fconst_kind_expr%2Fwf_obligation.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/wf_obligation.rs:17:17\n+   |\n+LL |     foo::<_, L>([(); L + 1 + L]);\n+   |                 ^^^^^^^^^^^^^^^ expected `N + 1 + M`, found `L + 1 + L`\n+   |\n+   = note: expected constant `N + 1 + M`\n+              found constant `L + 1 + L`\n+\n+error: unconstrained generic constant\n+  --> $DIR/wf_obligation.rs:17:22\n+   |\n+LL |     foo::<_, L>([(); L + 1 + L]);\n+   |                      ^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); L + 1 + L]:`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "cec70bb1a0d9e5e9530820b574947071ebba9d67", "filename": "src/test/ui/impl-trait/nested-return-type4.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,8 @@\n+// edition: 2021\n+\n+fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized> {\n+    async move { let _s = s; }\n+    //~^ ERROR hidden type for `impl Future<Output = impl Sized>` captures lifetime that does not appear in bounds\n+}\n+\n+fn main() {}"}, {"sha": "e761a60e79c2751d5f1193d41fd5da610d8cf3fe", "filename": "src/test/ui/impl-trait/nested-return-type4.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type4.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,20 @@\n+error[E0700]: hidden type for `impl Future<Output = impl Sized>` captures lifetime that does not appear in bounds\n+  --> $DIR/nested-return-type4.rs:4:5\n+   |\n+LL | fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized> {\n+   |         -- hidden type `[async block@$DIR/nested-return-type4.rs:4:5: 4:31]` captures the lifetime `'s` as defined here\n+LL |     async move { let _s = s; }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: to declare that `impl Future<Output = impl Sized>` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized> + 's {\n+   |                                                                              ++++\n+help: to declare that `impl Sized` captures `'s`, you can add an explicit `'s` lifetime bound\n+   |\n+LL | fn test<'s: 's>(s: &'s str) -> impl std::future::Future<Output = impl Sized + 's> {\n+   |                                                                             ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "86e45f10b0e1615280a10d877293375f71163dfd", "filename": "src/test/ui/issues/issue-105330.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fissues%2Fissue-105330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fissues%2Fissue-105330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-105330.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,21 @@\n+pub trait TraitWAssocConst {\n+    const A:   usize;\n+}\n+pub struct Demo {}\n+\n+impl TraitWAssocConst for impl Demo { //~ ERROR E0404\n+    //~^ ERROR E0562\n+    pubconst A: str = 32; //~ ERROR expected one of\n+}\n+\n+fn foo<A: TraitWAssocConst<A=32>>() { //~ ERROR E0658\n+    foo::<Demo>()(); //~ ERROR E0271\n+    //~^ ERROR E0618\n+    //~| ERROR E0277\n+}\n+\n+fn main<A: TraitWAssocConst<A=32>>() { //~ ERROR E0131\n+    //~^ ERROR E0658\n+    foo::<Demo>(); //~ ERROR E0277\n+    //~^ ERROR E0271\n+}"}, {"sha": "92f2ccb6544b10c2ba81744c921b4b945fd91d15", "filename": "src/test/ui/issues/issue-105330.stderr", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fissues%2Fissue-105330.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fissues%2Fissue-105330.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-105330.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,109 @@\n+error: expected one of `!` or `::`, found `A`\n+  --> $DIR/issue-105330.rs:8:14\n+   |\n+LL | impl TraitWAssocConst for impl Demo {\n+   |                                     - while parsing this item list starting here\n+LL |\n+LL |     pubconst A: str = 32;\n+   |              ^ expected one of `!` or `::`\n+LL | }\n+   | - the item list ends here\n+\n+error[E0404]: expected trait, found struct `Demo`\n+  --> $DIR/issue-105330.rs:6:32\n+   |\n+LL | impl TraitWAssocConst for impl Demo {\n+   |                                ^^^^ not a trait\n+\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/issue-105330.rs:11:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |                            ^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0658]: associated const equality is incomplete\n+  --> $DIR/issue-105330.rs:17:29\n+   |\n+LL | fn main<A: TraitWAssocConst<A=32>>() {\n+   |                             ^^^^\n+   |\n+   = note: see issue #92827 <https://github.com/rust-lang/rust/issues/92827> for more information\n+   = help: add `#![feature(associated_const_equality)]` to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in type\n+  --> $DIR/issue-105330.rs:6:27\n+   |\n+LL | impl TraitWAssocConst for impl Demo {\n+   |                           ^^^^^^^^^\n+\n+error[E0277]: the trait bound `Demo: TraitWAssocConst` is not satisfied\n+  --> $DIR/issue-105330.rs:12:11\n+   |\n+LL |     foo::<Demo>()();\n+   |           ^^^^ the trait `TraitWAssocConst` is not implemented for `Demo`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:11\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error[E0271]: type mismatch resolving `<Demo as TraitWAssocConst>::A == 32`\n+  --> $DIR/issue-105330.rs:12:11\n+   |\n+LL |     foo::<Demo>()();\n+   |           ^^^^ types differ\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |                            ^^^^ required by this bound in `foo`\n+\n+error[E0618]: expected function, found `()`\n+  --> $DIR/issue-105330.rs:12:5\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   | ----------------------------------- `foo::<Demo>` defined here returns `()`\n+LL |     foo::<Demo>()();\n+   |     ^^^^^^^^^^^^^--\n+   |     |\n+   |     call expression requires function\n+\n+error[E0277]: the trait bound `Demo: TraitWAssocConst` is not satisfied\n+  --> $DIR/issue-105330.rs:19:11\n+   |\n+LL |     foo::<Demo>();\n+   |           ^^^^ the trait `TraitWAssocConst` is not implemented for `Demo`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:11\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error[E0271]: type mismatch resolving `<Demo as TraitWAssocConst>::A == 32`\n+  --> $DIR/issue-105330.rs:19:11\n+   |\n+LL |     foo::<Demo>();\n+   |           ^^^^ types differ\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/issue-105330.rs:11:28\n+   |\n+LL | fn foo<A: TraitWAssocConst<A=32>>() {\n+   |                            ^^^^ required by this bound in `foo`\n+\n+error[E0131]: `main` function is not allowed to have generic parameters\n+  --> $DIR/issue-105330.rs:17:8\n+   |\n+LL | fn main<A: TraitWAssocConst<A=32>>() {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `main` cannot have generic parameters\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0131, E0271, E0277, E0404, E0562, E0618, E0658.\n+For more information about an error, try `rustc --explain E0131`."}, {"sha": "c42ee9b295e1d365e4f07ff2b76200994470828c", "filename": "src/test/ui/macros/syntax-error-recovery.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsyntax-error-recovery.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -7,6 +7,7 @@ LL |                 $token $($inner)? = $value,\n LL | values!(STRING(1) as (String) => cfg(test),);\n    | -------------------------------------------- in this macro invocation\n    |\n+   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n    = note: this error originates in the macro `values` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: macro expansion ignores token `(String)` and any following"}, {"sha": "1edca391e8fd01eb9e6b7e877d7ce4f6ab64f2fe", "filename": "src/test/ui/parser/issue-101477-enum.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-101477-enum.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -3,6 +3,8 @@ error: unexpected `==`\n    |\n LL |     B == 2\n    |       ^^ help: try using `=` instead\n+   |\n+   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n \n error: expected item, found `==`\n   --> $DIR/issue-101477-enum.rs:6:7"}, {"sha": "28c442bdd632dd62ebaa7a5ef02f3419fbebda67", "filename": "src/test/ui/parser/issue-103869.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fissue-103869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fissue-103869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-103869.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,9 @@\n+enum VecOrMap{\n+    vec: Vec<usize>,\n+    //~^ ERROR expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n+    //~| HELP: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n+    //~| ERROR expected item, found `:`\n+    map: HashMap<String,usize>\n+}\n+\n+fn main() {}"}, {"sha": "0b8cd919a9de26a8f654648a36b211df25b6984b", "filename": "src/test/ui/parser/issue-103869.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fissue-103869.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fissue-103869.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-103869.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,16 @@\n+error: expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n+  --> $DIR/issue-103869.rs:2:8\n+   |\n+LL |     vec: Vec<usize>,\n+   |        ^ expected one of `(`, `,`, `=`, `{`, or `}`\n+   |\n+   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n+\n+error: expected item, found `:`\n+  --> $DIR/issue-103869.rs:2:8\n+   |\n+LL |     vec: Vec<usize>,\n+   |        ^ expected item\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "da9e743a0b44ffc73a4f45ef9eb3f2ee0535b63d", "filename": "src/test/ui/parser/macro/issue-37113.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-37113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-37113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fissue-37113.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -9,6 +9,7 @@ LL |             $( $t, )*\n LL |     test_macro!(String,);\n    |     -------------------- in this macro invocation\n    |\n+   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n    = note: this error originates in the macro `test_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "7f48f55fec93803d3e89f002ee57963edcfde507", "filename": "src/test/ui/structs/struct-fn-in-definition.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -28,6 +28,7 @@ enum E {\n     //~^ ERROR functions are not allowed in enum definitions\n     //~| HELP unlike in C++, Java, and C#, functions are declared in `impl` blocks\n     //~| HELP see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+    //~| HELP enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n }\n \n fn main() {}"}, {"sha": "439c86ec22b0eb9178e39fd2c5569be225a94a3b", "filename": "src/test/ui/structs/struct-fn-in-definition.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -33,6 +33,7 @@ LL |     fn foo() {}\n    |\n    = help: unlike in C++, Java, and C#, functions are declared in `impl` blocks\n    = help: see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "dcdbd02287371ba6bff58500c7f4cf4a5fbb6986", "filename": "src/test/ui/trait-bounds/impl-missing-where-clause-lifetimes-from-trait.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-missing-where-clause-lifetimes-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-missing-where-clause-lifetimes-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-missing-where-clause-lifetimes-from-trait.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,38 @@\n+trait Trait<T> {\n+    fn foo<'a, K>(self, _: T, _: K) where T: 'a, K: 'a;\n+}\n+\n+impl Trait<()> for () {\n+    fn foo<'a, K>(self, _: (), _: K) where { //~ ERROR E0195\n+        todo!();\n+    }\n+}\n+\n+struct State;\n+\n+trait Foo<T> {\n+    fn foo<'a>(&self, state: &'a State) -> &'a T\n+    where\n+        T: 'a;\n+}\n+\n+impl<F, T> Foo<T> for F\n+where\n+    F: Fn(&State) -> &T,\n+{\n+    fn foo<'a>(&self, state: &'a State) -> &'a T { //~ ERROR E0195\n+        self(state)\n+    }\n+}\n+\n+trait Bar {\n+    fn foo<'a>(&'a self) {}\n+}\n+\n+impl Bar for () {\n+    fn foo<'a: 'a>(&'a self) {} //~ ERROR E0195\n+}\n+\n+fn main() {\n+    ().foo((), ());\n+}"}, {"sha": "e26cb22163f1e78e61936d5ceee56af440f41bb2", "filename": "src/test/ui/trait-bounds/impl-missing-where-clause-lifetimes-from-trait.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-missing-where-clause-lifetimes-from-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-missing-where-clause-lifetimes-from-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-bounds%2Fimpl-missing-where-clause-lifetimes-from-trait.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,36 @@\n+error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n+  --> $DIR/impl-missing-where-clause-lifetimes-from-trait.rs:6:11\n+   |\n+LL |     fn foo<'a, K>(self, _: T, _: K) where T: 'a, K: 'a;\n+   |           -------                            --     -- this bound might be missing in the impl\n+   |           |                                  |\n+   |           |                                  this bound might be missing in the impl\n+   |           lifetimes in impl do not match this method in trait\n+...\n+LL |     fn foo<'a, K>(self, _: (), _: K) where {\n+   |           ^^^^^^^ lifetimes do not match method in trait\n+\n+error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n+  --> $DIR/impl-missing-where-clause-lifetimes-from-trait.rs:23:11\n+   |\n+LL |     fn foo<'a>(&self, state: &'a State) -> &'a T\n+   |           ---- lifetimes in impl do not match this method in trait\n+LL |     where\n+LL |         T: 'a;\n+   |            -- this bound might be missing in the impl\n+...\n+LL |     fn foo<'a>(&self, state: &'a State) -> &'a T {\n+   |           ^^^^ lifetimes do not match method in trait\n+\n+error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n+  --> $DIR/impl-missing-where-clause-lifetimes-from-trait.rs:33:11\n+   |\n+LL |     fn foo<'a>(&'a self) {}\n+   |           ---- lifetimes in impl do not match this method in trait\n+...\n+LL |     fn foo<'a: 'a>(&'a self) {}\n+   |           ^^^^^^^^ lifetimes do not match method in trait\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0195`."}, {"sha": "fb56b394493dc7f553887891d4bd53109e93ed3d", "filename": "src/test/ui/typeck/path-to-method-sugg-unresolved-expr.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftypeck%2Fpath-to-method-sugg-unresolved-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftypeck%2Fpath-to-method-sugg-unresolved-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fpath-to-method-sugg-unresolved-expr.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let page_size = page_size::get();\n+    //~^ ERROR failed to resolve: use of undeclared crate or module `page_size`\n+}"}, {"sha": "b01e30be54de0bde80173b4b4ee0cd8136e3f17d", "filename": "src/test/ui/typeck/path-to-method-sugg-unresolved-expr.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftypeck%2Fpath-to-method-sugg-unresolved-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftest%2Fui%2Ftypeck%2Fpath-to-method-sugg-unresolved-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fpath-to-method-sugg-unresolved-expr.stderr?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,9 @@\n+error[E0433]: failed to resolve: use of undeclared crate or module `page_size`\n+  --> $DIR/path-to-method-sugg-unresolved-expr.rs:2:21\n+   |\n+LL |     let page_size = page_size::get();\n+   |                     ^^^^^^^^^ use of undeclared crate or module `page_size`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "d0820cfc2a0e46b1b1919337824ea24c7b17ea51", "filename": "src/tools/collect-license-metadata/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"collect-license-metadata\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+anyhow = \"1.0.65\"\n+serde = { version = \"1.0.147\", features = [\"derive\"] }\n+serde_json = \"1.0.85\"\n+spdx-rs = \"0.5.1\""}, {"sha": "1c95b1bc8e96cdedb3b3a56b4b823ca85dcfc294", "filename": "src/tools/collect-license-metadata/src/licenses.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,65 @@\n+use std::collections::HashMap;\n+\n+const COPYRIGHT_PREFIXES: &[&str] = &[\"SPDX-FileCopyrightText:\", \"Copyright\", \"(c)\", \"(C)\", \"\u00a9\"];\n+\n+pub(crate) struct LicensesInterner {\n+    by_id: Vec<License>,\n+    by_struct: HashMap<License, usize>,\n+}\n+\n+impl LicensesInterner {\n+    pub(crate) fn new() -> Self {\n+        LicensesInterner { by_id: Vec::new(), by_struct: HashMap::new() }\n+    }\n+\n+    pub(crate) fn intern(&mut self, mut license: License) -> LicenseId {\n+        license.simplify();\n+        if let Some(id) = self.by_struct.get(&license) {\n+            LicenseId(*id)\n+        } else {\n+            let id = self.by_id.len();\n+            self.by_id.push(license.clone());\n+            self.by_struct.insert(license, id);\n+            LicenseId(id)\n+        }\n+    }\n+\n+    pub(crate) fn resolve(&self, id: LicenseId) -> &License {\n+        &self.by_id[id.0]\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize)]\n+#[serde(transparent)]\n+pub(crate) struct LicenseId(usize);\n+\n+#[derive(Clone, Hash, PartialEq, Eq, serde::Serialize)]\n+pub(crate) struct License {\n+    pub(crate) spdx: String,\n+    pub(crate) copyright: Vec<String>,\n+}\n+\n+impl License {\n+    fn simplify(&mut self) {\n+        self.remove_copyright_prefixes();\n+        self.copyright.sort();\n+        self.copyright.dedup();\n+    }\n+\n+    fn remove_copyright_prefixes(&mut self) {\n+        for copyright in &mut self.copyright {\n+            let mut stripped = copyright.trim();\n+            let mut previous_stripped;\n+            loop {\n+                previous_stripped = stripped;\n+                for pattern in COPYRIGHT_PREFIXES {\n+                    stripped = stripped.trim_start_matches(pattern).trim_start();\n+                }\n+                if stripped == previous_stripped {\n+                    break;\n+                }\n+            }\n+            *copyright = stripped.into();\n+        }\n+    }\n+}"}, {"sha": "ca2a6f4b8c8a28f72b33f57a211b7993d7181208", "filename": "src/tools/collect-license-metadata/src/main.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,30 @@\n+mod licenses;\n+mod path_tree;\n+mod reuse;\n+\n+use crate::licenses::LicensesInterner;\n+use anyhow::Error;\n+use std::path::PathBuf;\n+\n+fn main() -> Result<(), Error> {\n+    let reuse_exe: PathBuf = std::env::var_os(\"REUSE_EXE\").expect(\"Missing REUSE_EXE\").into();\n+    let dest: PathBuf = std::env::var_os(\"DEST\").expect(\"Missing DEST\").into();\n+\n+    let mut interner = LicensesInterner::new();\n+    let paths = crate::reuse::collect(&reuse_exe, &mut interner)?;\n+\n+    let mut tree = crate::path_tree::build(paths);\n+    tree.simplify();\n+\n+    if let Some(parent) = dest.parent() {\n+        std::fs::create_dir_all(parent)?;\n+    }\n+    std::fs::write(\n+        &dest,\n+        &serde_json::to_vec_pretty(&serde_json::json!({\n+            \"files\": crate::path_tree::expand_interned_licenses(tree, &interner),\n+        }))?,\n+    )?;\n+\n+    Ok(())\n+}"}, {"sha": "133ff6837378e0ff78150714b05d2da5aeeb9812", "filename": "src/tools/collect-license-metadata/src/path_tree.rs", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,294 @@\n+//! Tools like REUSE output per-file licensing information, but we need to condense it in the\n+//! minimum amount of data that still represents the same licensing metadata. This module is\n+//! responsible for that, by turning the list of paths into a tree and executing simplification\n+//! passes over the tree to remove redundant information.\n+\n+use crate::licenses::{License, LicenseId, LicensesInterner};\n+use std::collections::BTreeMap;\n+use std::path::{Path, PathBuf};\n+\n+#[derive(serde::Serialize)]\n+#[serde(rename_all = \"kebab-case\", tag = \"type\")]\n+pub(crate) enum Node<L> {\n+    Root { childs: Vec<Node<L>> },\n+    Directory { name: PathBuf, childs: Vec<Node<L>>, license: Option<L> },\n+    File { name: PathBuf, license: L },\n+    FileGroup { names: Vec<PathBuf>, license: L },\n+    Empty,\n+}\n+\n+impl Node<LicenseId> {\n+    pub(crate) fn simplify(&mut self) {\n+        self.merge_directories();\n+        self.collapse_in_licensed_directories();\n+        self.merge_directory_licenses();\n+        self.merge_file_groups();\n+        self.remove_empty();\n+    }\n+\n+    /// Initially, the build() function constructs a list of separate paths from the file\n+    /// system root down to each file, like so:\n+    ///\n+    /// ```text\n+    ///         \u250c\u2500\u25ba ./ \u2500\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u25ba src/ \u2500\u2500\u25ba main.rs\n+    ///         \u2502\n+    /// <root> \u2500\u253c\u2500\u25ba ./ \u2500\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u25ba Cargo.toml\n+    ///         \u2502\n+    ///         \u2514\u2500\u25ba ./ \u2500\u2500\u25ba library/ \u2500\u2500\u2500\u25ba std/ \u2500\u2500\u25ba Cargo.toml\n+    /// ```\n+    ///\n+    /// This pass is responsible for turning that into a proper directory tree:\n+    ///\n+    /// ```text\n+    ///                 \u250c\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u252c\u2500\u25ba src/ \u2500\u2500\u25ba main.rs\n+    ///                 \u2502                          \u2502\n+    /// <root> \u2500\u2500\u25ba ./ \u2500\u2500\u2524                          \u2514\u2500\u25ba Cargo.toml\n+    ///                 \u2502\n+    ///                 \u2514\u2500\u25ba library/ \u2500\u2500\u2500\u25ba std/ \u2500\u2500\u25ba Cargo.toml\n+    /// ```\n+    fn merge_directories(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, license: None, .. } => {\n+                let mut directories = BTreeMap::new();\n+                let mut files = Vec::new();\n+\n+                for child in childs.drain(..) {\n+                    match child {\n+                        Node::Directory { name, mut childs, license: None } => {\n+                            directories.entry(name).or_insert_with(Vec::new).append(&mut childs);\n+                        }\n+                        file @ Node::File { .. } => {\n+                            files.push(file);\n+                        }\n+                        Node::Empty => {}\n+                        Node::Root { .. } => {\n+                            panic!(\"can't have a root inside another element\");\n+                        }\n+                        Node::FileGroup { .. } => {\n+                            panic!(\"FileGroup should not be present at this stage\");\n+                        }\n+                        Node::Directory { license: Some(_), .. } => {\n+                            panic!(\"license should not be set at this stage\");\n+                        }\n+                    }\n+                }\n+\n+                childs.extend(directories.into_iter().map(|(name, childs)| Node::Directory {\n+                    name,\n+                    childs,\n+                    license: None,\n+                }));\n+                childs.append(&mut files);\n+\n+                for child in &mut *childs {\n+                    child.merge_directories();\n+                }\n+            }\n+            Node::Empty => {}\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {\n+                panic!(\"FileGroup should not be present at this stage\");\n+            }\n+            Node::Directory { license: Some(_), .. } => {\n+                panic!(\"license should not be set at this stage\");\n+            }\n+        }\n+    }\n+\n+    /// In our codebase, most files in a directory have the same license as the other files in that\n+    /// same directory, so it's redundant to store licensing metadata for all the files. Instead,\n+    /// we can add a license for a whole directory, and only record the exceptions to a directory\n+    /// licensing metadata.\n+    ///\n+    /// We cannot instead record only the difference to Rust's standard licensing, as the majority\n+    /// of the files in our repository are *not* licensed under Rust's standard licensing due to\n+    /// our inclusion of LLVM.\n+    fn collapse_in_licensed_directories(&mut self) {\n+        match self {\n+            Node::Directory { childs, license, .. } => {\n+                for child in &mut *childs {\n+                    child.collapse_in_licensed_directories();\n+                }\n+\n+                let mut licenses_count = BTreeMap::new();\n+                for child in &*childs {\n+                    let Some(license) = child.license() else { continue };\n+                    *licenses_count.entry(license).or_insert(0) += 1;\n+                }\n+\n+                let most_popular_license = licenses_count\n+                    .into_iter()\n+                    .max_by_key(|(_, count)| *count)\n+                    .map(|(license, _)| license);\n+\n+                if let Some(most_popular_license) = most_popular_license {\n+                    childs.retain(|child| child.license() != Some(most_popular_license));\n+                    *license = Some(most_popular_license);\n+                }\n+            }\n+            Node::Root { childs } => {\n+                for child in &mut *childs {\n+                    child.collapse_in_licensed_directories();\n+                }\n+            }\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {}\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    /// Reduce the depth of the tree by merging subdirectories with the same license as their\n+    /// parent directory into their parent, and adjusting the paths of the childs accordingly.\n+    fn merge_directory_licenses(&mut self) {\n+        match self {\n+            Node::Root { childs } => {\n+                for child in &mut *childs {\n+                    child.merge_directory_licenses();\n+                }\n+            }\n+            Node::Directory { childs, license, .. } => {\n+                let mut to_add = Vec::new();\n+                for child in &mut *childs {\n+                    child.merge_directory_licenses();\n+\n+                    let Node::Directory {\n+                        name: child_name,\n+                        childs: child_childs,\n+                        license: child_license,\n+                    } = child else { continue };\n+\n+                    if child_license != license {\n+                        continue;\n+                    }\n+                    for mut child_child in child_childs.drain(..) {\n+                        match &mut child_child {\n+                            Node::Root { .. } => {\n+                                panic!(\"can't have a root inside another element\");\n+                            }\n+                            Node::FileGroup { .. } => {\n+                                panic!(\"FileGroup should not be present at this stage\");\n+                            }\n+                            Node::Directory { name: child_child_name, .. } => {\n+                                *child_child_name = child_name.join(&child_child_name);\n+                            }\n+                            Node::File { name: child_child_name, .. } => {\n+                                *child_child_name = child_name.join(&child_child_name);\n+                            }\n+                            Node::Empty => {}\n+                        }\n+                        to_add.push(child_child);\n+                    }\n+\n+                    *child = Node::Empty;\n+                }\n+                childs.append(&mut to_add);\n+            }\n+            Node::Empty => {}\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {}\n+        }\n+    }\n+\n+    /// This pass groups multiple files in a directory with the same license into a single\n+    /// \"FileGroup\", so that the license of all those files can be reported as a group.\n+    ///\n+    /// Crucially this pass runs after collapse_in_licensed_directories, so the most common license\n+    /// will already be marked as the directory's license and won't be turned into a group.\n+    fn merge_file_groups(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, .. } => {\n+                let mut grouped = BTreeMap::new();\n+\n+                for child in &mut *childs {\n+                    child.merge_file_groups();\n+                    if let Node::File { name, license } = child {\n+                        grouped.entry(*license).or_insert_with(Vec::new).push(name.clone());\n+                        *child = Node::Empty;\n+                    }\n+                }\n+\n+                for (license, mut names) in grouped.into_iter() {\n+                    if names.len() == 1 {\n+                        childs.push(Node::File { license, name: names.pop().unwrap() });\n+                    } else {\n+                        childs.push(Node::FileGroup { license, names });\n+                    }\n+                }\n+            }\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => panic!(\"FileGroup should not be present at this stage\"),\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    /// Some nodes were replaced with Node::Empty to mark them for deletion. As the last step, make\n+    /// sure to remove them from the tree.\n+    fn remove_empty(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, .. } => {\n+                for child in &mut *childs {\n+                    child.remove_empty();\n+                }\n+                childs.retain(|child| !matches!(child, Node::Empty));\n+            }\n+            Node::FileGroup { .. } => {}\n+            Node::File { .. } => {}\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    fn license(&self) -> Option<LicenseId> {\n+        match self {\n+            Node::Directory { childs, license: Some(license), .. } if childs.is_empty() => {\n+                Some(*license)\n+            }\n+            Node::File { license, .. } => Some(*license),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub(crate) fn build(mut input: Vec<(PathBuf, LicenseId)>) -> Node<LicenseId> {\n+    let mut childs = Vec::new();\n+\n+    // Ensure reproducibility of all future steps.\n+    input.sort();\n+\n+    for (path, license) in input {\n+        let mut node = Node::File { name: path.file_name().unwrap().into(), license };\n+        for component in path.parent().unwrap_or_else(|| Path::new(\".\")).components().rev() {\n+            node = Node::Directory {\n+                name: component.as_os_str().into(),\n+                childs: vec![node],\n+                license: None,\n+            };\n+        }\n+\n+        childs.push(node);\n+    }\n+\n+    Node::Root { childs }\n+}\n+\n+/// Convert a `Node<LicenseId>` into a `Node<&License>`, expanding all interned license IDs with a\n+/// reference to the actual license metadata.\n+pub(crate) fn expand_interned_licenses(\n+    node: Node<LicenseId>,\n+    interner: &LicensesInterner,\n+) -> Node<&License> {\n+    match node {\n+        Node::Root { childs } => Node::Root {\n+            childs: childs.into_iter().map(|child| strip_interning(child, interner)).collect(),\n+        },\n+        Node::Directory { name, childs, license } => Node::Directory {\n+            childs: childs.into_iter().map(|child| strip_interning(child, interner)).collect(),\n+            license: license.map(|license| interner.resolve(license)),\n+            name,\n+        },\n+        Node::File { name, license } => Node::File { name, license: interner.resolve(license) },\n+        Node::FileGroup { names, license } => {\n+            Node::FileGroup { names, license: interner.resolve(license) }\n+        }\n+        Node::Empty => Node::Empty,\n+    }\n+}"}, {"sha": "d6b3772ba5159a9e4debcbdcecfdb20d05596668", "filename": "src/tools/collect-license-metadata/src/reuse.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,49 @@\n+use crate::licenses::{License, LicenseId, LicensesInterner};\n+use anyhow::Error;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Stdio};\n+use std::time::Instant;\n+\n+pub(crate) fn collect(\n+    reuse_exe: &Path,\n+    interner: &mut LicensesInterner,\n+) -> Result<Vec<(PathBuf, LicenseId)>, Error> {\n+    eprintln!(\"gathering license information from REUSE\");\n+    let start = Instant::now();\n+    let raw = &obtain_spdx_document(reuse_exe)?;\n+    eprintln!(\"finished gathering the license information from REUSE in {:.2?}\", start.elapsed());\n+\n+    let document = spdx_rs::parsers::spdx_from_tag_value(&raw)?;\n+\n+    let mut result = Vec::new();\n+    for file in document.file_information {\n+        let license = interner.intern(License {\n+            spdx: file.concluded_license.to_string(),\n+            copyright: file.copyright_text.split('\\n').map(|s| s.into()).collect(),\n+        });\n+\n+        result.push((file.file_name.into(), license));\n+    }\n+\n+    Ok(result)\n+}\n+\n+fn obtain_spdx_document(reuse_exe: &Path) -> Result<String, Error> {\n+    let output = Command::new(reuse_exe)\n+        .args(&[\"spdx\", \"--add-license-concluded\", \"--creator-person=bors\"])\n+        .stdout(Stdio::piped())\n+        .spawn()?\n+        .wait_with_output()?;\n+\n+    if !output.status.success() {\n+        eprintln!();\n+        eprintln!(\"Note that Rust requires some REUSE features that might not be present in the\");\n+        eprintln!(\"release you're using. Make sure your REUSE release includes these PRs:\");\n+        eprintln!();\n+        eprintln!(\" - https://github.com/fsfe/reuse-tool/pull/623\");\n+        eprintln!();\n+        anyhow::bail!(\"collecting licensing information with REUSE failed\");\n+    }\n+\n+    Ok(String::from_utf8(output.stdout)?)\n+}"}, {"sha": "899ef0f8a6c2650012a89523124e7f04baa96967", "filename": "src/tools/generate-copyright/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fgenerate-copyright%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fgenerate-copyright%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fgenerate-copyright%2FCargo.toml?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"generate-copyright\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+anyhow = \"1.0.65\"\n+serde = { version = \"1.0.147\", features = [\"derive\"] }\n+serde_json = \"1.0.85\""}, {"sha": "d172c9e157bc859a4df2858bde58a5cd6e13d275", "filename": "src/tools/generate-copyright/src/main.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6852428a8ea9728369b64b9964cad8e258403d3/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fgenerate-copyright%2Fsrc%2Fmain.rs?ref=b6852428a8ea9728369b64b9964cad8e258403d3", "patch": "@@ -0,0 +1,94 @@\n+use anyhow::Error;\n+use std::io::Write;\n+use std::path::PathBuf;\n+\n+fn main() -> Result<(), Error> {\n+    let dest = env_path(\"DEST\")?;\n+    let license_metadata = env_path(\"LICENSE_METADATA\")?;\n+\n+    let metadata: Metadata = serde_json::from_slice(&std::fs::read(&license_metadata)?)?;\n+\n+    let mut buffer = Vec::new();\n+    render_recursive(&metadata.files, &mut buffer, 0)?;\n+\n+    std::fs::write(&dest, &buffer)?;\n+\n+    Ok(())\n+}\n+\n+fn render_recursive(node: &Node, buffer: &mut Vec<u8>, depth: usize) -> Result<(), Error> {\n+    let prefix = std::iter::repeat(\"> \").take(depth + 1).collect::<String>();\n+\n+    match node {\n+        Node::Root { childs } => {\n+            for child in childs {\n+                render_recursive(child, buffer, depth)?;\n+            }\n+        }\n+        Node::Directory { name, childs, license } => {\n+            render_license(&prefix, std::iter::once(name), license, buffer)?;\n+            if !childs.is_empty() {\n+                writeln!(buffer, \"{prefix}\")?;\n+                writeln!(buffer, \"{prefix}*Exceptions:*\")?;\n+                for child in childs {\n+                    writeln!(buffer, \"{prefix}\")?;\n+                    render_recursive(child, buffer, depth + 1)?;\n+                }\n+            }\n+        }\n+        Node::FileGroup { names, license } => {\n+            render_license(&prefix, names.iter(), license, buffer)?;\n+        }\n+        Node::File { name, license } => {\n+            render_license(&prefix, std::iter::once(name), license, buffer)?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn render_license<'a>(\n+    prefix: &str,\n+    names: impl Iterator<Item = &'a String>,\n+    license: &License,\n+    buffer: &mut Vec<u8>,\n+) -> Result<(), Error> {\n+    for name in names {\n+        writeln!(buffer, \"{prefix}**`{name}`**  \")?;\n+    }\n+    writeln!(buffer, \"{prefix}License: `{}`  \", license.spdx)?;\n+    for (i, copyright) in license.copyright.iter().enumerate() {\n+        let suffix = if i == license.copyright.len() - 1 { \"\" } else { \"  \" };\n+        writeln!(buffer, \"{prefix}Copyright: {copyright}{suffix}\")?;\n+    }\n+\n+    Ok(())\n+}\n+\n+#[derive(serde::Deserialize)]\n+struct Metadata {\n+    files: Node,\n+}\n+\n+#[derive(serde::Deserialize)]\n+#[serde(rename_all = \"kebab-case\", tag = \"type\")]\n+pub(crate) enum Node {\n+    Root { childs: Vec<Node> },\n+    Directory { name: String, childs: Vec<Node>, license: License },\n+    File { name: String, license: License },\n+    FileGroup { names: Vec<String>, license: License },\n+}\n+\n+#[derive(serde::Deserialize)]\n+struct License {\n+    spdx: String,\n+    copyright: Vec<String>,\n+}\n+\n+fn env_path(var: &str) -> Result<PathBuf, Error> {\n+    if let Some(var) = std::env::var_os(var) {\n+        Ok(var.into())\n+    } else {\n+        anyhow::bail!(\"missing environment variable {var}\")\n+    }\n+}"}]}