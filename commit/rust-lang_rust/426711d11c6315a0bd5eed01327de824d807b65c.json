{"sha": "426711d11c6315a0bd5eed01327de824d807b65c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNjcxMWQxMWM2MzE1YTBiZDVlZWQwMTMyN2RlODI0ZDgwN2I2NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-25T02:43:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-25T02:43:20Z"}, "message": "Auto merge of #43786 - scalexm:issue-43784, r=nikomatsakis\n\nElaborate trait obligations when typechecking impls\n\nWhen typechecking trait impl declarations, we only checked that bounds explictly written on the trait declaration hold.\n\nWe now also check that bounds which would have been implied by the trait reference do hold.\n\nFixes #43784.", "tree": {"sha": "e1b7e8fe0410ddfd1902c00710908da04f27d328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1b7e8fe0410ddfd1902c00710908da04f27d328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/426711d11c6315a0bd5eed01327de824d807b65c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/426711d11c6315a0bd5eed01327de824d807b65c", "html_url": "https://github.com/rust-lang/rust/commit/426711d11c6315a0bd5eed01327de824d807b65c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/426711d11c6315a0bd5eed01327de824d807b65c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cbe6d8fd6b22a1cb87de43fddbb3100ab0af04d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cbe6d8fd6b22a1cb87de43fddbb3100ab0af04d", "html_url": "https://github.com/rust-lang/rust/commit/0cbe6d8fd6b22a1cb87de43fddbb3100ab0af04d"}, {"sha": "68fd322a957480db16f1ab0af9915056adbe07b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/68fd322a957480db16f1ab0af9915056adbe07b1", "html_url": "https://github.com/rust-lang/rust/commit/68fd322a957480db16f1ab0af9915056adbe07b1"}], "stats": {"total": 95, "additions": 90, "deletions": 5}, "files": [{"sha": "6d9e648452fd345fb8732a4660892e70fc06c705", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/426711d11c6315a0bd5eed01327de824d807b65c/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426711d11c6315a0bd5eed01327de824d807b65c/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=426711d11c6315a0bd5eed01327de824d807b65c", "patch": "@@ -58,7 +58,7 @@ pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                          -> Vec<traits::PredicateObligation<'tcx>>\n {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n-    wf.compute_trait_ref(trait_ref);\n+    wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n \n@@ -74,7 +74,7 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n         ty::Predicate::Trait(ref t) => {\n-            wf.compute_trait_ref(&t.skip_binder().trait_ref); // (*)\n+            wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n         ty::Predicate::Equate(ref t) => {\n             wf.compute(t.skip_binder().0);\n@@ -114,6 +114,35 @@ struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     out: Vec<traits::PredicateObligation<'tcx>>,\n }\n \n+/// Controls whether we \"elaborate\" supertraits and so forth on the WF\n+/// predicates. This is a kind of hack to address #43784. The\n+/// underlying problem in that issue was a trait structure like:\n+///\n+/// ```\n+/// trait Foo: Copy { }\n+/// trait Bar: Foo { }\n+/// impl<T: Bar> Foo for T { }\n+/// impl<T> Bar for T { }\n+/// ```\n+///\n+/// Here, in the `Foo` impl, we will check that `T: Copy` holds -- but\n+/// we decide that this is true because `T: Bar` is in the\n+/// where-clauses (and we can elaborate that to include `T:\n+/// Copy`). This wouldn't be a problem, except that when we check the\n+/// `Bar` impl, we decide that `T: Foo` must hold because of the `Foo`\n+/// impl. And so nowhere did we check that `T: Copy` holds!\n+///\n+/// To resolve this, we elaborate the WF requirements that must be\n+/// proven when checking impls. This means that (e.g.) the `impl Bar\n+/// for T` will be forced to prove not only that `T: Foo` but also `T:\n+/// Copy` (which it won't be able to do, because there is no `Copy`\n+/// impl for `T`).\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum Elaborate {\n+    All,\n+    None,\n+}\n+\n impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n@@ -135,12 +164,25 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into\n     /// `self.out`.\n-    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n+    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, elaborate: Elaborate) {\n         let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n-        self.out.extend(obligations);\n \n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n+\n+        if let Elaborate::All = elaborate {\n+            let predicates = obligations.iter()\n+                                        .map(|obligation| obligation.predicate.clone())\n+                                        .collect();\n+            let implied_obligations = traits::elaborate_predicates(self.infcx.tcx, predicates);\n+            let implied_obligations = implied_obligations.map(|pred| {\n+                traits::Obligation::new(cause.clone(), param_env, pred)\n+            });\n+            self.out.extend(implied_obligations);\n+        }\n+\n+        self.out.extend(obligations);\n+\n         self.out.extend(\n             trait_ref.substs.types()\n                             .filter(|ty| !ty.has_escaping_regions())\n@@ -156,7 +198,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         // WF and (b) the trait-ref holds.  (It may also be\n         // normalizable and be WF that way.)\n         let trait_ref = data.trait_ref(self.infcx.tcx);\n-        self.compute_trait_ref(&trait_ref);\n+        self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n         if !data.has_escaping_regions() {\n             let predicate = trait_ref.to_predicate();"}, {"sha": "94b5c0034a76deca5addf72a4af88fe64b2a54aa", "filename": "src/test/compile-fail/issue-43784-associated-type.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/426711d11c6315a0bd5eed01327de824d807b65c/src%2Ftest%2Fcompile-fail%2Fissue-43784-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426711d11c6315a0bd5eed01327de824d807b65c/src%2Ftest%2Fcompile-fail%2Fissue-43784-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43784-associated-type.rs?ref=426711d11c6315a0bd5eed01327de824d807b65c", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Partial<X: ?Sized>: Copy {\n+}\n+\n+pub trait Complete {\n+    type Assoc: Partial<Self>;\n+}\n+\n+impl<T> Partial<T> for T::Assoc where\n+    T: Complete\n+{\n+}\n+\n+impl<T> Complete for T { //~ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n+    type Assoc = T;\n+}"}, {"sha": "e70df113da33cfcb7e3b2e212e222789052f3602", "filename": "src/test/compile-fail/issue-43784-supertrait.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/426711d11c6315a0bd5eed01327de824d807b65c/src%2Ftest%2Fcompile-fail%2Fissue-43784-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426711d11c6315a0bd5eed01327de824d807b65c/src%2Ftest%2Fcompile-fail%2Fissue-43784-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43784-supertrait.rs?ref=426711d11c6315a0bd5eed01327de824d807b65c", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Partial: Copy {\n+}\n+\n+pub trait Complete: Partial {\n+}\n+\n+impl<T> Partial for T where T: Complete {}\n+impl<T> Complete for T {} //~ ERROR the trait bound `T: std::marker::Copy` is not satisfied"}]}