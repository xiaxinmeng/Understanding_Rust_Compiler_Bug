{"sha": "fe55eee9a55a1019a2398d22b91bc201e3d4fb94", "node_id": "C_kwDOAAsO6NoAKGZlNTVlZWU5YTU1YTEwMTlhMjM5OGQyMmI5MWJjMjAxZTNkNGZiOTQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-19T01:02:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-19T01:02:01Z"}, "message": "Rollup merge of #93263 - sunfishcode:sunfishcode/detatched-console-handle, r=dtolnay\n\nConsistently present absent stdio handles on Windows as NULL handles.\n\nThis addresses #90964 by making the std API consistent about presenting\nabsent stdio handles on Windows as NULL handles. Stdio handles may be\nabsent due to `#![windows_subsystem = \"windows\"]`, due to the console\nbeing detached, or due to a child process having been launched from a\nparent where stdio handles are absent.\n\nSpecifically, this fixes the case of child processes of parents with absent\nstdio, which previously ended up with `stdin().as_raw_handle()` returning\n`INVALID_HANDLE_VALUE`, which was surprising, and which overlapped with an\nunrelated valid handle value. With this patch, `stdin().as_raw_handle()`\nnow returns null in these situation, which is consistent with what it\ndoes in the parent process.\n\nAnd, document this in the \"Windows Portability Considerations\" sections of\nthe relevant documentation.", "tree": {"sha": "89100d757d7f76c3fbb68b0c44e2b691196d4567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89100d757d7f76c3fbb68b0c44e2b691196d4567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe55eee9a55a1019a2398d22b91bc201e3d4fb94", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiNSuJCRBK7hj4Ov3rIwAAHFIIACtIL6KPzbN+A6xme/1ug6nJ\n7zNbey/t4tDqKk73c6GuNW03QH70iMW+aWQZCSHeVcc1NuZkWHFtDzM8Sn9v27OW\ndB7+Rvf4cjw9uu5RwNaaq4aogNdNDKRsZwcMGZOTVTUTYA9wMU6iEwH/C0SSfh34\nMWLf8Ddk+co4ZvkYfiIW9Azu7Ey3KivULRzjr5xEQ3eoJXkR9TeknuOqu02tarxS\n+NAyVuRgoPkj6s8DHrpPmRfqSmZWSa6//Fa3b6ptLt1XtG3uvNhR6UtQHIotrtNo\nO2D8PDaqb8YSCRsuRs/1bLy4u4w/7SKv7/iU3EFOVHUjzELuZi1zZs1nuCT/6Co=\n=iVOV\n-----END PGP SIGNATURE-----\n", "payload": "tree 89100d757d7f76c3fbb68b0c44e2b691196d4567\nparent e9f63fdf86de2a515da26bb905c1470e6363caf3\nparent 7ddf41c7b10e46c231180cecbbb5e78e0dd12ff8\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1647651721 +0100\ncommitter GitHub <noreply@github.com> 1647651721 +0100\n\nRollup merge of #93263 - sunfishcode:sunfishcode/detatched-console-handle, r=dtolnay\n\nConsistently present absent stdio handles on Windows as NULL handles.\n\nThis addresses #90964 by making the std API consistent about presenting\nabsent stdio handles on Windows as NULL handles. Stdio handles may be\nabsent due to `#![windows_subsystem = \"windows\"]`, due to the console\nbeing detached, or due to a child process having been launched from a\nparent where stdio handles are absent.\n\nSpecifically, this fixes the case of child processes of parents with absent\nstdio, which previously ended up with `stdin().as_raw_handle()` returning\n`INVALID_HANDLE_VALUE`, which was surprising, and which overlapped with an\nunrelated valid handle value. With this patch, `stdin().as_raw_handle()`\nnow returns null in these situation, which is consistent with what it\ndoes in the parent process.\n\nAnd, document this in the \"Windows Portability Considerations\" sections of\nthe relevant documentation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe55eee9a55a1019a2398d22b91bc201e3d4fb94", "html_url": "https://github.com/rust-lang/rust/commit/fe55eee9a55a1019a2398d22b91bc201e3d4fb94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe55eee9a55a1019a2398d22b91bc201e3d4fb94/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9f63fdf86de2a515da26bb905c1470e6363caf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9f63fdf86de2a515da26bb905c1470e6363caf3", "html_url": "https://github.com/rust-lang/rust/commit/e9f63fdf86de2a515da26bb905c1470e6363caf3"}, {"sha": "7ddf41c7b10e46c231180cecbbb5e78e0dd12ff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ddf41c7b10e46c231180cecbbb5e78e0dd12ff8", "html_url": "https://github.com/rust-lang/rust/commit/7ddf41c7b10e46c231180cecbbb5e78e0dd12ff8"}], "stats": {"total": 116, "additions": 100, "deletions": 16}, "files": [{"sha": "ac6d41e13b009e8c2abbc743b6cee210a21155b0", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fe55eee9a55a1019a2398d22b91bc201e3d4fb94/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe55eee9a55a1019a2398d22b91bc201e3d4fb94/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=fe55eee9a55a1019a2398d22b91bc201e3d4fb94", "patch": "@@ -202,12 +202,18 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n ///\n /// [`io::stdin`]: stdin\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n ///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// ```no_run\n@@ -230,12 +236,18 @@ pub struct Stdin {\n /// This handle implements both the [`Read`] and [`BufRead`] traits, and\n /// is constructed via the [`Stdin::lock`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n ///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// ```no_run\n@@ -263,11 +275,18 @@ pub struct StdinLock<'a> {\n /// is synchronized via a mutex. If you need more explicit control over\n /// locking, see the [`Stdin::lock`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// Using implicit synchronization:\n@@ -490,11 +509,18 @@ impl fmt::Debug for StdinLock<'_> {\n ///\n /// Created by the [`io::stdout`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// [`lock`]: Stdout::lock\n /// [`io::stdout`]: stdout\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -510,10 +536,17 @@ pub struct Stdout {\n /// This handle implements the [`Write`] trait, and is constructed via\n /// the [`Stdout::lock`] method. See its documentation for more.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n #[must_use = \"if unused stdout will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n@@ -528,11 +561,18 @@ static STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Sy\n /// is synchronized via a mutex. If you need more explicit control over\n /// locking, see the [`Stdout::lock`] method.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// Using implicit synchronization:\n@@ -710,10 +750,17 @@ impl fmt::Debug for StdoutLock<'_> {\n ///\n /// [`io::stderr`]: stderr\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n     inner: Pin<&'static ReentrantMutex<RefCell<StderrRaw>>>,\n@@ -724,10 +771,17 @@ pub struct Stderr {\n /// This handle implements the [`Write`] trait and is constructed via\n /// the [`Stderr::lock`] method. See its documentation for more.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n+///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n #[must_use = \"if unused stderr will immediately unlock\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n@@ -738,11 +792,18 @@ pub struct StderrLock<'a> {\n ///\n /// This handle is not buffered.\n ///\n-/// ### Note: Windows Portability Consideration\n+/// ### Note: Windows Portability Considerations\n+///\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n ///\n+/// In a process with a detached console, such as one using\n+/// `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n+/// the contained handle will be null. In such cases, the standard library's `Read` and\n+/// `Write` will do nothing and silently succeed. All other I/O operations, via the\n+/// standard library or via raw Windows API calls, will fail.\n+///\n /// # Examples\n ///\n /// Using implicit synchronization:"}, {"sha": "be2ccbd98e9c227773bafda5c043323c634e2548", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe55eee9a55a1019a2398d22b91bc201e3d4fb94/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe55eee9a55a1019a2398d22b91bc201e3d4fb94/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=fe55eee9a55a1019a2398d22b91bc201e3d4fb94", "patch": "@@ -164,12 +164,22 @@ impl OwnedHandle {\n         inherit: bool,\n         options: c::DWORD,\n     ) -> io::Result<Self> {\n+        let handle = self.as_raw_handle();\n+\n+        // `Stdin`, `Stdout`, and `Stderr` can all hold null handles, such as\n+        // in a process with a detached console. `DuplicateHandle` would fail\n+        // if we passed it a null handle, but we can treat null as a valid\n+        // handle which doesn't do any I/O, and allow it to be duplicated.\n+        if handle.is_null() {\n+            return unsafe { Ok(Self::from_raw_handle(handle)) };\n+        }\n+\n         let mut ret = 0 as c::HANDLE;\n         cvt(unsafe {\n             let cur_proc = c::GetCurrentProcess();\n             c::DuplicateHandle(\n                 cur_proc,\n-                self.as_raw_handle(),\n+                handle,\n                 cur_proc,\n                 &mut ret,\n                 access,"}, {"sha": "68fa8918a56a08a4fc3ad0aef8fcedfb03387ad1", "filename": "library/std/src/os/windows/io/raw.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe55eee9a55a1019a2398d22b91bc201e3d4fb94/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe55eee9a55a1019a2398d22b91bc201e3d4fb94/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs?ref=fe55eee9a55a1019a2398d22b91bc201e3d4fb94", "patch": "@@ -9,6 +9,7 @@ use crate::net;\n use crate::os::windows::io::{AsHandle, AsSocket};\n use crate::os::windows::io::{OwnedHandle, OwnedSocket};\n use crate::os::windows::raw;\n+use crate::ptr;\n use crate::sys;\n use crate::sys::c;\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n@@ -96,45 +97,57 @@ impl AsRawHandle for fs::File {\n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stdin {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stdout {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stderr {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StdinLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StdoutLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StderrLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle }\n+        stdio_handle(unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle })\n     }\n }\n \n+// Translate a handle returned from `GetStdHandle` into a handle to return to\n+// the user.\n+fn stdio_handle(raw: RawHandle) -> RawHandle {\n+    // `GetStdHandle` isn't expected to actually fail, so when it returns\n+    // `INVALID_HANDLE_VALUE`, it means we were launched from a parent which\n+    // didn't provide us with stdio handles, such as a parent with a detached\n+    // console. In that case, return null to the user, which is consistent\n+    // with what they'd get in the parent, and which avoids the problem that\n+    // `INVALID_HANDLE_VALUE` aliases the current process handle.\n+    if raw == c::INVALID_HANDLE_VALUE { ptr::null_mut() } else { raw }\n+}\n+\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawHandle for fs::File {\n     #[inline]"}]}