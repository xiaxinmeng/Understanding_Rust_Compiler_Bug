{"sha": "f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5M2JiMmE1MGIzN2JjOGJhZmU0ZDk2MGUyYWZkODM5ZWFhODU0ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-25T17:14:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-25T17:14:44Z"}, "message": "Auto merge of #72575 - Dylan-DPC:rollup-zo679hv, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #72153 (exhaustively check `ty::Kind` during structural match checking)\n - #72308 (Emit a better diagnostic when function actually has a 'self' parameter)\n - #72560 (Enable `glacier` command via triagebot)\n - #72567 (Clean up E0608 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d1e3ebb520e2ccf6b1260505a4a1e8ea9da48a37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1e3ebb520e2ccf6b1260505a4a1e8ea9da48a37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "html_url": "https://github.com/rust-lang/rust/commit/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0f06d11ae7fe29c8e263e2a5d8cd41b372f0283", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f06d11ae7fe29c8e263e2a5d8cd41b372f0283", "html_url": "https://github.com/rust-lang/rust/commit/a0f06d11ae7fe29c8e263e2a5d8cd41b372f0283"}, {"sha": "aa8d64b005ab347477632bde4d33837385d39c80", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa8d64b005ab347477632bde4d33837385d39c80", "html_url": "https://github.com/rust-lang/rust/commit/aa8d64b005ab347477632bde4d33837385d39c80"}], "stats": {"total": 184, "additions": 173, "deletions": 11}, "files": [{"sha": "d0ebc3a26f082b82f58fea689130f23e15036bdf", "filename": "src/librustc_error_codes/error_codes/E0608.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_error_codes%2Ferror_codes%2FE0608.md", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_error_codes%2Ferror_codes%2FE0608.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0608.md?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -1,4 +1,4 @@\n-An attempt to index into a type which doesn't implement the `std::ops::Index`\n+An attempt to use index on a type which doesn't implement the `std::ops::Index`\n trait was performed.\n \n Erroneous code example:"}, {"sha": "9e3f75fdc078c41fffc64006e2b9821a7bc20b7a", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -124,8 +124,20 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     traits::NonStructuralMatchTy::Dynamic => {\n                         \"trait objects cannot be used in patterns\".to_string()\n                     }\n+                    traits::NonStructuralMatchTy::Opaque => {\n+                        \"opaque types cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTy::Generator => {\n+                        \"generators cannot be used in patterns\".to_string()\n+                    }\n                     traits::NonStructuralMatchTy::Param => {\n-                        bug!(\"use of constant whose type is a parameter inside a pattern\")\n+                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n+                    }\n+                    traits::NonStructuralMatchTy::Projection => {\n+                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n+                    }\n+                    traits::NonStructuralMatchTy::Foreign => {\n+                        bug!(\"use of a value of a foreign type inside a pattern\")\n                     }\n                 };\n "}, {"sha": "477e3be5cc2f89df6b8cc39cef04a1436da592df", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -347,7 +347,7 @@ struct DiagnosticMetadata<'ast> {\n     currently_processing_generics: bool,\n \n     /// The current enclosing function (used for better errors).\n-    current_function: Option<Span>,\n+    current_function: Option<(FnKind<'ast>, Span)>,\n \n     /// A list of labels as of yet unused. Labels will be removed from this map when\n     /// they are used (in a `break` or `continue` statement)\n@@ -466,7 +466,8 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             FnKind::Fn(FnCtxt::Free | FnCtxt::Foreign, ..) => FnItemRibKind,\n             FnKind::Fn(FnCtxt::Assoc(_), ..) | FnKind::Closure(..) => NormalRibKind,\n         };\n-        let previous_value = replace(&mut self.diagnostic_metadata.current_function, Some(sp));\n+        let previous_value =\n+            replace(&mut self.diagnostic_metadata.current_function, Some((fn_kind, sp)));\n         debug!(\"(resolving function) entering function\");\n         let declaration = fn_kind.decl();\n "}, {"sha": "b1a1f8725a1801024674d10a4c247696b226a1be", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -195,8 +195,15 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 _ => \"`self` value is a keyword only available in methods with a `self` parameter\"\n                      .to_string(),\n             });\n-            if let Some(span) = &self.diagnostic_metadata.current_function {\n-                err.span_label(*span, \"this function doesn't have a `self` parameter\");\n+            if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n+                // The current function has a `self' parameter, but we were unable to resolve\n+                // a reference to `self`. This can only happen if the `self` identifier we\n+                // are resolving came from a different hygiene context.\n+                if fn_kind.decl().inputs.get(0).map(|p| p.is_self()).unwrap_or(false) {\n+                    err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n+                } else {\n+                    err.span_label(*span, \"this function doesn't have a `self` parameter\");\n+                }\n             }\n             return (err, Vec::new());\n         }"}, {"sha": "b877049fcf667b4ea76ce20629bcc475c3835ae8", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -13,6 +13,10 @@ pub enum NonStructuralMatchTy<'tcx> {\n     Adt(&'tcx AdtDef),\n     Param,\n     Dynamic,\n+    Foreign,\n+    Opaque,\n+    Generator,\n+    Projection,\n }\n \n /// This method traverses the structure of `ty`, trying to find an\n@@ -143,6 +147,22 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 self.found = Some(NonStructuralMatchTy::Dynamic);\n                 return true; // Stop visiting.\n             }\n+            ty::Foreign(_) => {\n+                self.found = Some(NonStructuralMatchTy::Foreign);\n+                return true; // Stop visiting.\n+            }\n+            ty::Opaque(..) => {\n+                self.found = Some(NonStructuralMatchTy::Opaque);\n+                return true; // Stop visiting.\n+            }\n+            ty::Projection(..) => {\n+                self.found = Some(NonStructuralMatchTy::Projection);\n+                return true; // Stop visiting.\n+            }\n+            ty::Generator(..) | ty::GeneratorWitness(..) => {\n+                self.found = Some(NonStructuralMatchTy::Generator);\n+                return true; // Stop visiting.\n+            }\n             ty::RawPtr(..) => {\n                 // structural-match ignores substructure of\n                 // `*const _`/`*mut _`, so skip `super_visit_with`.\n@@ -159,32 +179,55 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 // structural equality on `T` does not recur into the raw\n                 // pointer. Therefore, one can still use `C` in a pattern.\n \n-                // (But still tell caller to continue search.)\n+                // (But still tell the caller to continue search.)\n                 return false;\n             }\n             ty::FnDef(..) | ty::FnPtr(..) => {\n-                // types of formals and return in `fn(_) -> _` are also irrelevant;\n+                // Types of formals and return in `fn(_) -> _` are also irrelevant;\n                 // so we do not recur into them via `super_visit_with`\n                 //\n-                // (But still tell caller to continue search.)\n+                // (But still tell the caller to continue search.)\n                 return false;\n             }\n             ty::Array(_, n)\n                 if { n.try_eval_usize(self.tcx(), ty::ParamEnv::reveal_all()) == Some(0) } =>\n             {\n                 // rust-lang/rust#62336: ignore type of contents\n                 // for empty array.\n+                //\n+                // (But still tell the caller to continue search.)\n                 return false;\n             }\n-            _ => {\n+            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => {\n+                // These primitive types are always structural match.\n+                //\n+                // `Never` is kind of special here, but as it is not inhabitable, this should be fine.\n+                //\n+                // (But still tell the caller to continue search.)\n+                return false;\n+            }\n+\n+            ty::Array(..) | ty::Slice(_) | ty::Ref(..) | ty::Tuple(..) => {\n+                // First check all contained types and then tell the caller to continue searching.\n                 ty.super_visit_with(self);\n                 return false;\n             }\n+            ty::Closure(..) | ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n+                bug!(\"unexpected type during structural-match checking: {:?}\", ty);\n+            }\n+            ty::Error => {\n+                self.tcx().sess.delay_span_bug(self.span, \"ty::Error in structural-match check\");\n+                // We still want to check other types after encountering an error,\n+                // as this may still emit relevant errors.\n+                //\n+                // So we continue searching here.\n+                return false;\n+            }\n         };\n \n         if !self.seen.insert(adt_def.did) {\n             debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-            // let caller continue its search\n+            // Let caller continue its search.\n             return false;\n         }\n "}, {"sha": "f934f793c7f2707b70a0a0fbad20682302a71f76", "filename": "src/test/ui/hygiene/missing-self-diag.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Fhygiene%2Fmissing-self-diag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Fhygiene%2Fmissing-self-diag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fmissing-self-diag.rs?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for issue #66898\n+// Tests that we don't emit a nonsensical error message\n+// when a macro invocation tries to access `self` from a function\n+// that has a 'self' parameter\n+\n+pub struct Foo;\n+\n+macro_rules! call_bar {\n+    () => {\n+        self.bar(); //~ ERROR expected value\n+    }\n+}\n+\n+impl Foo {\n+    pub fn foo(&self) {\n+        call_bar!();\n+    }\n+\n+    pub fn bar(&self) {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "075d6b76bb7b2bf017af7ed88353ed3e7dfc3ce9", "filename": "src/test/ui/hygiene/missing-self-diag.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Fhygiene%2Fmissing-self-diag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Fhygiene%2Fmissing-self-diag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fmissing-self-diag.stderr?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -0,0 +1,17 @@\n+error[E0424]: expected value, found module `self`\n+  --> $DIR/missing-self-diag.rs:10:9\n+   |\n+LL |           self.bar();\n+   |           ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n+...\n+LL | /     pub fn foo(&self) {\n+LL | |         call_bar!();\n+   | |         ------------ in this macro invocation\n+LL | |     }\n+   | |_____- this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0424`."}, {"sha": "479d6cd9af765b9bf4eae241faa4d67e3d7456c0", "filename": "src/test/ui/type-alias-impl-trait/structural-match-no-leak.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -0,0 +1,20 @@\n+#![feature(const_fn, type_alias_impl_trait)]\n+\n+type Bar = impl Send;\n+\n+// While i32 is structural-match, we do not want to leak this information.\n+// (See https://github.com/rust-lang/rust/issues/72156)\n+const fn leak_free() -> Bar {\n+    7i32\n+}\n+const LEAK_FREE: Bar = leak_free();\n+\n+fn leak_free_test() {\n+    match todo!() {\n+        LEAK_FREE => (),\n+        //~^ opaque types cannot be used in patterns\n+        _ => (),\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "ae0d8e8d4239c4a772bbdcc11fb1726670659a35", "filename": "src/test/ui/type-alias-impl-trait/structural-match-no-leak.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.stderr?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -0,0 +1,8 @@\n+error: opaque types cannot be used in patterns\n+  --> $DIR/structural-match-no-leak.rs:14:9\n+   |\n+LL |         LEAK_FREE => (),\n+   |         ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "481448d64b1aab64458e874deb5cbdbbc23c10a5", "filename": "src/test/ui/type-alias-impl-trait/structural-match.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -0,0 +1,21 @@\n+#![feature(const_fn, type_alias_impl_trait)]\n+\n+type Foo = impl Send;\n+\n+// This is not structural-match\n+struct A;\n+\n+const fn value() -> Foo {\n+    A\n+}\n+const VALUE: Foo = value();\n+\n+fn test() {\n+    match todo!() {\n+        VALUE => (),\n+        //~^ opaque types cannot be used in patterns\n+        _ => (),\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "ad9036a87d1d950071ccc8a0a024edec123244e4", "filename": "src/test/ui/type-alias-impl-trait/structural-match.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.stderr?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -0,0 +1,8 @@\n+error: opaque types cannot be used in patterns\n+  --> $DIR/structural-match.rs:15:9\n+   |\n+LL |         VALUE => (),\n+   |         ^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e43cff5538659074d81339c827b7b228fe745860", "filename": "triagebot.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f93bb2a50b37bc8bafe4d960e2afd839eaa854ed/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=f93bb2a50b37bc8bafe4d960e2afd839eaa854ed", "patch": "@@ -10,6 +10,8 @@ allow-unauthenticated = [\n \n [assign]\n \n+[glacier]\n+\n [ping.icebreakers-llvm]\n alias = [\"llvm\", \"llvms\"]\n message = \"\"\"\\"}]}