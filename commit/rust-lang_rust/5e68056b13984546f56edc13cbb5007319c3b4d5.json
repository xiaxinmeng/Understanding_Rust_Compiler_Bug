{"sha": "5e68056b13984546f56edc13cbb5007319c3b4d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNjgwNTZiMTM5ODQ1NDZmNTZlZGMxM2NiYjUwMDczMTljM2I0ZDU=", "commit": {"author": {"name": "Toby Scrace", "email": "toby.scrace@gmail.com", "date": "2015-11-09T09:15:39Z"}, "committer": {"name": "Toby Scrace", "email": "toby.scrace@gmail.com", "date": "2015-11-10T13:19:52Z"}, "message": "Add examples to methods on integer types", "tree": {"sha": "0a5f056103aa5c972c002111b4bfff7277c33b55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a5f056103aa5c972c002111b4bfff7277c33b55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e68056b13984546f56edc13cbb5007319c3b4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e68056b13984546f56edc13cbb5007319c3b4d5", "html_url": "https://github.com/rust-lang/rust/commit/5e68056b13984546f56edc13cbb5007319c3b4d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e68056b13984546f56edc13cbb5007319c3b4d5/comments", "author": null, "committer": null, "parents": [{"sha": "4b23a0962db486c8a96d673a1b17decc26a26b34", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b23a0962db486c8a96d673a1b17decc26a26b34", "html_url": "https://github.com/rust-lang/rust/commit/4b23a0962db486c8a96d673a1b17decc26a26b34"}], "stats": {"total": 373, "additions": 342, "deletions": 31}, "files": [{"sha": "3afc89c984142bc3a5550d5122cbb60564eb09a4", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 342, "deletions": 31, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/5e68056b13984546f56edc13cbb5007319c3b4d5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e68056b13984546f56edc13cbb5007319c3b4d5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5e68056b13984546f56edc13cbb5007319c3b4d5", "patch": "@@ -141,6 +141,8 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n+        /// Basic usage:\n+        ///\n         /// ```\n         /// assert_eq!(u32::from_str_radix(\"A\", 16), Ok(10));\n         /// ```\n@@ -153,7 +155,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -166,7 +170,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -182,7 +188,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -198,7 +206,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -214,7 +224,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -232,7 +244,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -248,7 +262,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -267,7 +283,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -289,7 +307,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -311,7 +331,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -333,7 +355,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -353,7 +377,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -368,7 +394,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -383,7 +411,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -398,7 +428,9 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -416,6 +448,15 @@ macro_rules! int_impl {\n \n         /// Saturating integer addition. Computes `self + other`, saturating at\n         /// the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.saturating_add(1), 101);\n+        /// assert_eq!(100i8.saturating_add(127), 127);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn saturating_add(self, other: Self) -> Self {\n@@ -428,6 +469,15 @@ macro_rules! int_impl {\n \n         /// Saturating integer subtraction. Computes `self - other`, saturating\n         /// at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.saturating_sub(127), -27);\n+        /// assert_eq!((-100i8).saturating_sub(127), -128);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn saturating_sub(self, other: Self) -> Self {\n@@ -440,6 +490,15 @@ macro_rules! int_impl {\n \n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_add(27), 127);\n+        /// assert_eq!(100i8.wrapping_add(127), -29);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn wrapping_add(self, rhs: Self) -> Self {\n@@ -450,6 +509,15 @@ macro_rules! int_impl {\n \n         /// Wrapping (modular) subtraction. Computes `self - other`,\n         /// wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(0i8.wrapping_sub(127), -127);\n+        /// assert_eq!((-2i8).wrapping_sub(127), 127);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn wrapping_sub(self, rhs: Self) -> Self {\n@@ -460,6 +528,15 @@ macro_rules! int_impl {\n \n         /// Wrapping (modular) multiplication. Computes `self *\n         /// other`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(10i8.wrapping_mul(12), 120);\n+        /// assert_eq!(11i8.wrapping_mul(12), -124);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn wrapping_mul(self, rhs: Self) -> Self {\n@@ -477,6 +554,15 @@ macro_rules! int_impl {\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n         /// itself.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100u8.wrapping_div(10), 10);\n+        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n@@ -490,6 +576,15 @@ macro_rules! int_impl {\n         /// implementation artifacts make `x % y` invalid for `MIN /\n         /// -1` on a signed type (where `MIN` is the negative\n         /// minimal value). In such a case, this function returns `0`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_rem(10), 0);\n+        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n@@ -504,6 +599,15 @@ macro_rules! int_impl {\n         /// negative minimal value for the type); this is a positive\n         /// value that is too large to represent in the type. In such\n         /// a case, this function returns `MIN` itself.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_neg(), -100);\n+        /// assert_eq!((-128i8).wrapping_neg(), -128);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_neg(self) -> Self {\n@@ -513,6 +617,15 @@ macro_rules! int_impl {\n         /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(1u8.wrapping_shl(7), 128);\n+        /// assert_eq!(1u8.wrapping_shl(8), 1);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n@@ -522,6 +635,15 @@ macro_rules! int_impl {\n         /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(128u8.wrapping_shr(7), 1);\n+        /// assert_eq!(128u8.wrapping_shr(8), 128);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n@@ -532,6 +654,8 @@ macro_rules! int_impl {\n         ///\n         /// # Examples\n         ///\n+        /// Basic usage:\n+        ///\n         /// ```\n         /// let x: i32 = 2; // or any other integer type\n         ///\n@@ -569,6 +693,15 @@ macro_rules! int_impl {\n         /// `i32`, and attempting to calculate it will cause an overflow. This\n         /// means that code in debug mode will trigger a panic on this case and\n         /// optimized code will return `i32::min_value()` without a panic.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(10i8.abs(), 10);\n+        /// assert_eq!((-10i8).abs(), 10);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn abs(self) -> Self {\n@@ -587,6 +720,16 @@ macro_rules! int_impl {\n         /// - `0` if the number is zero\n         /// - `1` if the number is positive\n         /// - `-1` if the number is negative\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(10i8.signum(), 1);\n+        /// assert_eq!(0i8.signum(), 0);\n+        /// assert_eq!((-10i8).signum(), -1);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn signum(self) -> Self {\n@@ -599,12 +742,30 @@ macro_rules! int_impl {\n \n         /// Returns `true` if `self` is positive and `false` if the number\n         /// is zero or negative.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert!(10i8.is_positive());\n+        /// assert!(!(-10i8).is_positive());\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_positive(self) -> bool { self > 0 }\n \n         /// Returns `true` if `self` is negative and `false` if the number\n         /// is zero or positive.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert!((-10i8).is_negative());\n+        /// assert!(!10i8.is_negative());\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_negative(self) -> bool { self < 0 }\n@@ -759,7 +920,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -774,7 +937,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -790,7 +955,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -825,7 +992,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -855,7 +1024,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -875,7 +1046,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -893,7 +1066,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -912,7 +1087,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -934,7 +1111,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -956,7 +1135,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -978,7 +1159,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -998,7 +1181,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -1013,7 +1198,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -1028,7 +1215,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -1043,7 +1232,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -1059,6 +1250,15 @@ macro_rules! uint_impl {\n \n         /// Saturating integer addition. Computes `self + other`, saturating at\n         /// the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.saturating_add(1), 101);\n+        /// assert_eq!(100i8.saturating_add(127), 127);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn saturating_add(self, other: Self) -> Self {\n@@ -1071,6 +1271,15 @@ macro_rules! uint_impl {\n \n         /// Saturating integer subtraction. Computes `self - other`, saturating\n         /// at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.saturating_sub(127), -27);\n+        /// assert_eq!((-100i8).saturating_sub(127), -128);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn saturating_sub(self, other: Self) -> Self {\n@@ -1083,6 +1292,15 @@ macro_rules! uint_impl {\n \n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_add(27), 127);\n+        /// assert_eq!(100i8.wrapping_add(127), -29);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn wrapping_add(self, rhs: Self) -> Self {\n@@ -1093,6 +1311,15 @@ macro_rules! uint_impl {\n \n         /// Wrapping (modular) subtraction. Computes `self - other`,\n         /// wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(0i8.wrapping_sub(127), -127);\n+        /// assert_eq!((-2i8).wrapping_sub(127), 127);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn wrapping_sub(self, rhs: Self) -> Self {\n@@ -1103,6 +1330,15 @@ macro_rules! uint_impl {\n \n         /// Wrapping (modular) multiplication. Computes `self *\n         /// other`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(10i8.wrapping_mul(12), 120);\n+        /// assert_eq!(11i8.wrapping_mul(12), -124);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn wrapping_mul(self, rhs: Self) -> Self {\n@@ -1120,6 +1356,15 @@ macro_rules! uint_impl {\n         /// to `-MIN`, a positive value that is too large to represent\n         /// in the type. In such a case, this function returns `MIN`\n         /// itself.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100u8.wrapping_div(10), 10);\n+        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n@@ -1133,6 +1378,15 @@ macro_rules! uint_impl {\n         /// implementation artifacts make `x % y` invalid for `MIN /\n         /// -1` on a signed type (where `MIN` is the negative\n         /// minimal value). In such a case, this function returns `0`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_rem(10), 0);\n+        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n@@ -1147,6 +1401,15 @@ macro_rules! uint_impl {\n         /// negative minimal value for the type); this is a positive\n         /// value that is too large to represent in the type. In such\n         /// a case, this function returns `MIN` itself.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(100i8.wrapping_neg(), -100);\n+        /// assert_eq!((-128i8).wrapping_neg(), -128);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_neg(self) -> Self {\n@@ -1156,6 +1419,15 @@ macro_rules! uint_impl {\n         /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(1u8.wrapping_shl(7), 128);\n+        /// assert_eq!(1u8.wrapping_shl(8), 1);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n@@ -1165,6 +1437,15 @@ macro_rules! uint_impl {\n         /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n         /// where `mask` removes any high-order bits of `rhs` that\n         /// would cause the shift to exceed the bitwidth of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(128u8.wrapping_shr(7), 1);\n+        /// assert_eq!(128u8.wrapping_shr(8), 128);\n+        /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n@@ -1175,7 +1456,9 @@ macro_rules! uint_impl {\n         ///\n         /// # Examples\n         ///\n-        /// ```rust\n+        /// Basic usage:\n+        ///\n+        /// ```\n         /// assert_eq!(2i32.pow(4), 16);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1207,6 +1490,15 @@ macro_rules! uint_impl {\n         }\n \n         /// Returns `true` if and only if `self == 2^k` for some `k`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert!(16u8.is_power_of_two());\n+        /// assert!(!10u8.is_power_of_two());\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_power_of_two(self) -> bool {\n@@ -1216,6 +1508,15 @@ macro_rules! uint_impl {\n \n         /// Returns the smallest power of two greater than or equal to `self`.\n         /// Unspecified behavior on overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(2u8.next_power_of_two(), 2);\n+        /// assert_eq!(3u8.next_power_of_two(), 4);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn next_power_of_two(self) -> Self {\n@@ -1227,6 +1528,16 @@ macro_rules! uint_impl {\n         /// Returns the smallest power of two greater than or equal to `n`. If\n         /// the next power of two is greater than the type's maximum value,\n         /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(2u8.checked_next_power_of_two(), Some(2));\n+        /// assert_eq!(3u8.checked_next_power_of_two(), Some(4));\n+        /// assert_eq!(200u8.checked_next_power_of_two(), None);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn checked_next_power_of_two(self) -> Option<Self> {\n             let npot = self.next_power_of_two();"}]}