{"sha": "4f437099d85be1c978de76ef3b3a02432ac0913d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNDM3MDk5ZDg1YmUxYzk3OGRlNzZlZjNiM2EwMjQzMmFjMDkxM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T21:37:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-02T21:37:08Z"}, "message": "Auto merge of #1202 - RalfJung:symbols, r=RalfJung\n\nswitch extern_statics map to symbols, and use FxHashMap everywhere\n\nCc @eddyb", "tree": {"sha": "a3dfaf701a43cffb91c835a16aabf1c087ae2e9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3dfaf701a43cffb91c835a16aabf1c087ae2e9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f437099d85be1c978de76ef3b3a02432ac0913d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f437099d85be1c978de76ef3b3a02432ac0913d", "html_url": "https://github.com/rust-lang/rust/commit/4f437099d85be1c978de76ef3b3a02432ac0913d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f437099d85be1c978de76ef3b3a02432ac0913d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "331175638f9ac30dc19c87f3a86521e3f1dea962", "url": "https://api.github.com/repos/rust-lang/rust/commits/331175638f9ac30dc19c87f3a86521e3f1dea962", "html_url": "https://github.com/rust-lang/rust/commit/331175638f9ac30dc19c87f3a86521e3f1dea962"}, {"sha": "92a28f8d8f139d0b6b0f8efa009fee0e72103d1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/92a28f8d8f139d0b6b0f8efa009fee0e72103d1e", "html_url": "https://github.com/rust-lang/rust/commit/92a28f8d8f139d0b6b0f8efa009fee0e72103d1e"}], "stats": {"total": 55, "additions": 28, "deletions": 27}, "files": [{"sha": "91d9f4e84ee3146904b5177f914deb3bb6729012", "filename": "src/intptrcast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=4f437099d85be1c978de76ef3b3a02432ac0913d", "patch": "@@ -1,9 +1,10 @@\n use std::cell::RefCell;\n use std::cmp::max;\n-use std::collections::{hash_map::Entry, HashMap};\n+use std::collections::hash_map::Entry;\n \n use rand::Rng;\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc::ty::layout::HasDataLayout;\n use rustc_mir::interpret::{AllocCheck, AllocId, InterpResult, Memory, Machine, Pointer, PointerArithmetic};\n use rustc_target::abi::Size;\n@@ -21,7 +22,7 @@ pub struct GlobalState {\n     /// `AllocExtra` because function pointers also have a base address, and\n     /// they do not have an `AllocExtra`.\n     /// This is the inverse of `int_to_ptr_map`.\n-    pub base_addr: HashMap<AllocId, u64>,\n+    pub base_addr: FxHashMap<AllocId, u64>,\n     /// This is used as a memory address when a new pointer is casted to an integer. It\n     /// is always larger than any address that was previously made part of a block.\n     pub next_base_addr: u64,\n@@ -31,7 +32,7 @@ impl Default for GlobalState {\n     fn default() -> Self {\n         GlobalState {\n             int_to_ptr_map: Vec::default(),\n-            base_addr: HashMap::default(),\n+            base_addr: FxHashMap::default(),\n             next_base_addr: STACK_ADDR,\n         }\n     }"}, {"sha": "0df567a2fa511418b43308f8c77754894191f069", "filename": "src/machine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=4f437099d85be1c978de76ef3b3a02432ac0913d", "patch": "@@ -3,20 +3,20 @@\n \n use std::borrow::Cow;\n use std::cell::RefCell;\n-use std::collections::HashMap;\n use std::num::NonZeroU64;\n use std::rc::Rc;\n \n use rand::rngs::StdRng;\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc::mir;\n use rustc::ty::{\n     self,\n     layout::{LayoutOf, Size},\n     Ty,\n };\n use rustc_ast::attr;\n-use rustc_span::{source_map::Span, symbol::sym};\n+use rustc_span::{source_map::Span, symbol::{sym, Symbol}};\n \n use crate::*;\n \n@@ -75,7 +75,7 @@ pub struct MemoryExtra {\n     pub intptrcast: intptrcast::MemoryExtra,\n \n     /// Mapping extern static names to their canonical allocation.\n-    pub(crate) extern_statics: HashMap<&'static str, AllocId>,\n+    pub(crate) extern_statics: FxHashMap<Symbol, AllocId>,\n \n     /// The random number generator used for resolving non-determinism.\n     /// Needs to be queried by ptr_to_int, hence needs interior mutability.\n@@ -92,7 +92,7 @@ impl MemoryExtra {\n         MemoryExtra {\n             stacked_borrows,\n             intptrcast: Default::default(),\n-            extern_statics: HashMap::default(),\n+            extern_statics: FxHashMap::default(),\n             rng: RefCell::new(rng),\n         }\n     }\n@@ -111,7 +111,7 @@ impl MemoryExtra {\n                 this.memory\n                     .extra\n                     .extern_statics\n-                    .insert(\"__cxa_thread_atexit_impl\", place.ptr.assert_ptr().alloc_id)\n+                    .insert(Symbol::intern(\"__cxa_thread_atexit_impl\"), place.ptr.assert_ptr().alloc_id)\n                     .unwrap_none();\n             }\n             _ => {} // No \"extern statics\" supported on this platform\n@@ -310,11 +310,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         };\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n-            Some(name) => name.as_str(),\n-            None => tcx.item_name(def_id).as_str(),\n+            Some(name) => name,\n+            None => tcx.item_name(def_id),\n         };\n         // Check if we know this one.\n-        if let Some(canonical_id) = mem.extra.extern_statics.get(&*link_name) {\n+        if let Some(canonical_id) = mem.extra.extern_statics.get(&link_name) {\n             trace!(\"canonical_alloc_id: {:?} ({}) -> {:?}\", id, link_name, canonical_id);\n             *canonical_id\n         } else {"}, {"sha": "fc33126aa2e71710ba98388c88e15b4ef8162058", "filename": "src/mono_hash_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_hash_map.rs?ref=4f437099d85be1c978de76ef3b3a02432ac0913d", "patch": "@@ -1,6 +1,6 @@\n-//! This is a \"monotonic `HashMap`\": A `HashMap` that, when shared, can be pushed to but not\n+//! This is a \"monotonic `FxHashMap`\": A `FxHashMap` that, when shared, can be pushed to but not\n //! otherwise mutated. We also box items in the map. This means we can safely provide\n-//! shared references into existing items in the `HashMap`, because they will not be dropped\n+//! shared references into existing items in the `FxHashMap`, because they will not be dropped\n //! (from being removed) or moved (because they are boxed).\n //! The API is is completely tailored to what `memory.rs` needs. It is still in\n //! a separate file to minimize the amount of code that has to care about the unsafety.\n@@ -21,8 +21,8 @@ impl<K: Hash + Eq, V> MonoHashMap<K, V> {\n     /// This function exists for priroda to be able to iterate over all evaluator memory.\n     ///\n     /// The function is somewhat roundabout with the closure argument because internally the\n-    /// `MonoHashMap` uses a `RefCell`. When iterating over the `HashMap` inside the `RefCell`,\n-    /// we need to keep a borrow to the `HashMap` inside the iterator. The borrow is only alive\n+    /// `MonoHashMap` uses a `RefCell`. When iterating over the `FxHashMap` inside the `RefCell`,\n+    /// we need to keep a borrow to the `FxHashMap` inside the iterator. The borrow is only alive\n     /// as long as the `Ref` returned by `RefCell::borrow()` is alive. So we can't return the\n     /// iterator, as that would drop the `Ref`. We can't return both, as it's not possible in Rust\n     /// to have a struct/tuple with a field that refers to another field."}, {"sha": "79f0c5b3d902af5994edb1ae3f24f18422a7aa6d", "filename": "src/shims/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=4f437099d85be1c978de76ef3b3a02432ac0913d", "patch": "@@ -1,18 +1,18 @@\n-use std::collections::HashMap;\n use std::ffi::{OsString, OsStr};\n use std::env;\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc::ty::layout::Size;\n use rustc_mir::interpret::Pointer;\n \n #[derive(Default)]\n pub struct EnvVars {\n     /// Stores pointers to the environment variables. These variables must be stored as\n     /// null-terminated C strings with the `\"{name}={value}\"` format.\n-    map: HashMap<OsString, Pointer<Tag>>,\n+    map: FxHashMap<OsString, Pointer<Tag>>,\n }\n \n impl EnvVars {"}, {"sha": "8a48518fa9bca398d58f65bafcc5d1595458b5cb", "filename": "src/shims/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=4f437099d85be1c978de76ef3b3a02432ac0913d", "patch": "@@ -1,11 +1,11 @@\n use std::collections::BTreeMap;\n-use std::collections::HashMap;\n use std::convert::{TryFrom, TryInto};\n use std::fs::{read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir};\n use std::io::{Read, Seek, SeekFrom, Write};\n use std::path::PathBuf;\n use std::time::SystemTime;\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc::ty::layout::{Align, LayoutOf, Size};\n \n use crate::stacked_borrows::Tag;\n@@ -212,10 +212,10 @@ pub struct DirHandler {\n     /// When opendir is called, a directory iterator is created on the host for the target\n     /// directory, and an entry is stored in this hash map, indexed by an ID which represents\n     /// the directory stream. When readdir is called, the directory stream ID is used to look up\n-    /// the corresponding ReadDir iterator from this HashMap, and information from the next\n+    /// the corresponding ReadDir iterator from this map, and information from the next\n     /// directory entry is returned. When closedir is called, the ReadDir iterator is removed from\n-    /// this HashMap.\n-    streams: HashMap<u64, ReadDir>,\n+    /// the map.\n+    streams: FxHashMap<u64, ReadDir>,\n     /// ID number to be used by the next call to opendir\n     next_id: u64,\n }\n@@ -232,7 +232,7 @@ impl DirHandler {\n impl Default for DirHandler {\n     fn default() -> DirHandler {\n         DirHandler {\n-            streams: HashMap::new(),\n+            streams: FxHashMap::default(),\n             // Skip 0 as an ID, because it looks like a null pointer to libc\n             next_id: 1,\n         }"}, {"sha": "6188d05780cb58e9ee19e5eb6aa98d2e13e9bd09", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f437099d85be1c978de76ef3b3a02432ac0913d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=4f437099d85be1c978de76ef3b3a02432ac0913d", "patch": "@@ -2,11 +2,11 @@\n //! for further information.\n \n use std::cell::RefCell;\n-use std::collections::{HashMap, HashSet};\n use std::fmt;\n use std::num::NonZeroU64;\n use std::rc::Rc;\n \n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc::mir::RetagKind;\n use rustc::ty::{self, layout::Size};\n use rustc_hir::Mutability;\n@@ -96,11 +96,11 @@ pub struct GlobalState {\n     /// Table storing the \"base\" tag for each allocation.\n     /// The base tag is the one used for the initial pointer.\n     /// We need this in a separate table to handle cyclic statics.\n-    base_ptr_ids: HashMap<AllocId, Tag>,\n+    base_ptr_ids: FxHashMap<AllocId, Tag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n     /// Those call IDs corresponding to functions that are still running.\n-    active_calls: HashSet<CallId>,\n+    active_calls: FxHashSet<CallId>,\n     /// The id to trace in this execution run\n     tracked_pointer_tag: Option<PtrId>,\n }\n@@ -153,9 +153,9 @@ impl GlobalState {\n     pub fn new(tracked_pointer_tag: Option<PtrId>) -> Self {\n         GlobalState {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n-            base_ptr_ids: HashMap::default(),\n+            base_ptr_ids: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n-            active_calls: HashSet::default(),\n+            active_calls: FxHashSet::default(),\n             tracked_pointer_tag,\n         }\n     }"}]}