{"sha": "ee3eb4b223f823b5bf7df7ece97621aa36315fdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlM2ViNGIyMjNmODIzYjViZjdkZjdlY2U5NzYyMWFhMzYzMTVmZGM=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-02T08:47:53Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-02T08:47:53Z"}, "message": "Add comments that document SYS_futex better.", "tree": {"sha": "2b39a0090aba97b69cc2b984605a3c8134390046", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b39a0090aba97b69cc2b984605a3c8134390046"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee3eb4b223f823b5bf7df7ece97621aa36315fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee3eb4b223f823b5bf7df7ece97621aa36315fdc", "html_url": "https://github.com/rust-lang/rust/commit/ee3eb4b223f823b5bf7df7ece97621aa36315fdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee3eb4b223f823b5bf7df7ece97621aa36315fdc/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "712e8006b3c3a055b53326196081df11da123d38", "url": "https://api.github.com/repos/rust-lang/rust/commits/712e8006b3c3a055b53326196081df11da123d38", "html_url": "https://github.com/rust-lang/rust/commit/712e8006b3c3a055b53326196081df11da123d38"}], "stats": {"total": 15, "additions": 15, "deletions": 0}, "files": [{"sha": "8da6921653cecbc1c9df0ba649a0f99c70e58d3d", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ee3eb4b223f823b5bf7df7ece97621aa36315fdc/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee3eb4b223f823b5bf7df7ece97621aa36315fdc/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=ee3eb4b223f823b5bf7df7ece97621aa36315fdc", "patch": "@@ -31,29 +31,44 @@ pub fn futex<'tcx>(\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n     let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n \n+    // FUTEX_PRIVATE enables an optimization that stops it from working across processes.\n+    // Miri doesn't support that anyway, so we ignore that flag.\n     match op & !futex_private {\n+        // FUTEX_WAIT: (int *addr, int op = FUTEX_WAIT, int val, const timespec *timeout)\n+        // Blocks the thread if *addr still equals val. Wakes up when FUTEX_WAKE is called on the same address,\n+        // or *timeout expires. `timeout == null` for an infinite timeout.\n         op if op == futex_wait => {\n             if args.len() < 5 {\n                 throw_ub_format!(\"incorrect number of arguments for FUTEX_WAIT syscall: got {}, expected at least 5\", args.len());\n             }\n             let timeout = this.read_scalar(args[4])?.check_init()?;\n             if !this.is_null(timeout)? {\n+                // FIXME: Implement timeouts. The condvar waiting code is probably a good example to start with.\n+                // Note that a triggered timeout should have this syscall return with -1 and errno set to ETIMEOUT.\n                 throw_ub_format!(\"miri does not support timeouts for futex operations\");\n             }\n             // Check the pointer for alignment. Atomic operations are only available for fully aligned values.\n             this.memory.check_ptr_access(addr.ptr.into(), Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n             // Read an `i32` through the pointer, regardless of any wrapper types (e.g. `AtomicI32`).\n             let futex_val = this.read_scalar(addr.offset(Size::ZERO, MemPlaceMeta::None, this.machine.layouts.i32, this)?.into())?.to_i32()?;\n             if val == futex_val {\n+                // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n                 this.futex_wait(futex_ptr, thread);\n+                // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_i32(0), dest)?;\n             } else {\n+                // The futex value doesn't match the expected value, so we return failure\n+                // right away without sleeping: -1 and errno set to EAGAIN.\n                 let eagain = this.eval_libc(\"EAGAIN\")?;\n                 this.set_last_error(eagain)?;\n                 this.write_scalar(Scalar::from_i32(-1), dest)?;\n             }\n         }\n+        // FUTEX_WAKE: (int *addr, int op = FUTEX_WAKE, int val)\n+        // Wakes at most `val` threads waiting on the futex at `addr`.\n+        // Returns the amount of threads woken up.\n+        // Does not access the futex value at *addr.\n         op if op == futex_wake => {\n             let mut n = 0;\n             for _ in 0..val {"}]}