{"sha": "11191279b721b326d545005b96ad9eecc7a95827", "node_id": "C_kwDOAAsO6NoAKDExMTkxMjc5YjcyMWIzMjZkNTQ1MDA1Yjk2YWQ5ZWVjYzdhOTU4Mjc", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-12-15T08:52:32Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-12-28T14:18:43Z"}, "message": "Update bootstrap cfg", "tree": {"sha": "5e941da49740433d18c1b29a88d1034d25e022f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e941da49740433d18c1b29a88d1034d25e022f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11191279b721b326d545005b96ad9eecc7a95827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11191279b721b326d545005b96ad9eecc7a95827", "html_url": "https://github.com/rust-lang/rust/commit/11191279b721b326d545005b96ad9eecc7a95827", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11191279b721b326d545005b96ad9eecc7a95827/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "060a6ead83ee545a50faed8282e0d5a19aab5c50", "url": "https://api.github.com/repos/rust-lang/rust/commits/060a6ead83ee545a50faed8282e0d5a19aab5c50", "html_url": "https://github.com/rust-lang/rust/commit/060a6ead83ee545a50faed8282e0d5a19aab5c50"}], "stats": {"total": 701, "additions": 38, "deletions": 663}, "files": [{"sha": "4932c7d8640e170eb3646ba17add4aad56b656f3", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -3609,16 +3609,9 @@ mod size_asserts {\n     static_assert_size!(Res, 12);\n     static_assert_size!(Stmt<'_>, 32);\n     static_assert_size!(StmtKind<'_>, 16);\n-    // tidy-alphabetical-end\n-    // FIXME: move the tidy directive to the end after the next bootstrap bump\n-    #[cfg(bootstrap)]\n-    static_assert_size!(TraitItem<'_>, 88);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(TraitItem<'_>, 80);\n-    #[cfg(bootstrap)]\n-    static_assert_size!(TraitItemKind<'_>, 48);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(TraitItemKind<'_>, 40);\n     static_assert_size!(Ty<'_>, 48);\n     static_assert_size!(TyKind<'_>, 32);\n+    // tidy-alphabetical-end\n }"}, {"sha": "10b2dc712a69e31f00a759e4237d63bc32b882a5", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -404,19 +404,6 @@ pub mod __alloc_error_handler {\n     pub unsafe fn __rdl_oom(size: usize, _align: usize) -> ! {\n         panic!(\"memory allocation of {size} bytes failed\")\n     }\n-\n-    #[cfg(bootstrap)]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n-        use crate::alloc::Layout;\n-\n-        let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n-        extern \"Rust\" {\n-            #[lang = \"oom\"]\n-            fn oom_impl(layout: Layout) -> !;\n-        }\n-        unsafe { oom_impl(layout) }\n-    }\n }\n \n /// Specialize clones into pre-allocated, uninitialized memory."}, {"sha": "a563b2587236c57abdec2689aac5f1e1127cbde4", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -158,7 +158,6 @@ use core::hash::{Hash, Hasher};\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n use core::iter::{FusedIterator, Iterator};\n-#[cfg(not(bootstrap))]\n use core::marker::Tuple;\n use core::marker::{Destruct, Unpin, Unsize};\n use core::mem;\n@@ -1981,17 +1980,6 @@ impl<I: ExactSizeIterator + ?Sized, A: Allocator> ExactSizeIterator for Box<I, A\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator + ?Sized, A: Allocator> FusedIterator for Box<I, A> {}\n \n-#[cfg(bootstrap)]\n-#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n-    type Output = <F as FnOnce<Args>>::Output;\n-\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output {\n-        <F as FnOnce<Args>>::call_once(*self, args)\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args: Tuple, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n     type Output = <F as FnOnce<Args>>::Output;\n@@ -2001,31 +1989,13 @@ impl<Args: Tuple, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F\n     }\n }\n \n-#[cfg(bootstrap)]\n-#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n-        <F as FnMut<Args>>::call_mut(self, args)\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args: Tuple, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n         <F as FnMut<Args>>::call_mut(self, args)\n     }\n }\n \n-#[cfg(bootstrap)]\n-#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n-impl<Args, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n-        <F as Fn<Args>>::call(self, args)\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args: Tuple, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {"}, {"sha": "c348aa843b8542d5ec0b818c653501ad0088c4b4", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -153,7 +153,7 @@\n #![feature(trusted_len)]\n #![feature(trusted_random_access)]\n #![feature(try_trait_v2)]\n-#![cfg_attr(not(bootstrap), feature(tuple_trait))]\n+#![feature(tuple_trait)]\n #![feature(unchecked_math)]\n #![feature(unicode_internals)]\n #![feature(unsize)]"}, {"sha": "fb5d86f0f2d88686fbfb43c85ddae1ca8238f195", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -363,7 +363,7 @@ use crate::vec::Vec;\n /// [`as_str()`]: String::as_str\n #[derive(PartialOrd, Eq, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(all(not(bootstrap), not(test)), lang = \"String\")]\n+#[cfg_attr(not(test), lang = \"String\")]\n pub struct String {\n     vec: Vec<u8>,\n }"}, {"sha": "6a6e30c01d6a7d476ea087000a56defd24a1345b", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -24,8 +24,6 @@\n \n use crate::const_closure::ConstFnMutClosure;\n use crate::marker::Destruct;\n-#[cfg(bootstrap)]\n-use crate::marker::StructuralPartialEq;\n \n use self::Ordering::*;\n \n@@ -333,7 +331,7 @@ pub struct AssertParamIsEq<T: Eq + ?Sized> {\n /// assert_eq!(Ordering::Greater, result);\n /// ```\n #[derive(Clone, Copy, Eq, Debug, Hash)]\n-#[cfg_attr(not(bootstrap), derive_const(PartialOrd, Ord, PartialEq))]\n+#[derive_const(PartialOrd, Ord, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(i8)]\n pub enum Ordering {\n@@ -879,40 +877,6 @@ pub macro Ord($item:item) {\n     /* compiler built-in */\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(bootstrap)]\n-impl StructuralPartialEq for Ordering {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-#[cfg(bootstrap)]\n-impl const PartialEq for Ordering {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        (*self as i32).eq(&(*other as i32))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-#[cfg(bootstrap)]\n-impl const Ord for Ordering {\n-    #[inline]\n-    fn cmp(&self, other: &Ordering) -> Ordering {\n-        (*self as i32).cmp(&(*other as i32))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-#[cfg(bootstrap)]\n-impl const PartialOrd for Ordering {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n-        (*self as i32).partial_cmp(&(*other as i32))\n-    }\n-}\n-\n /// Trait for types that form a [partial order](https://en.wikipedia.org/wiki/Partial_order).\n ///\n /// The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using"}, {"sha": "97900a4862f5653fc49c537fdc95c3690d71d9a0", "filename": "library/core/src/const_closure.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fconst_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fconst_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconst_closure.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -1,5 +1,4 @@\n use crate::marker::Destruct;\n-#[cfg(not(bootstrap))]\n use crate::marker::Tuple;\n \n /// Struct representing a closure with mutably borrowed data.\n@@ -46,33 +45,6 @@ impl<'a, CapturedData: ?Sized, Function> ConstFnMutClosure<&'a mut CapturedData,\n \n macro_rules! impl_fn_mut_tuple {\n     ($($var:ident)*) => {\n-        #[cfg(bootstrap)]\n-        #[allow(unused_parens)]\n-        impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n-            FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n-        where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments) -> ClosureReturnValue + ~const Destruct,\n-        {\n-            type Output = ClosureReturnValue;\n-\n-            extern \"rust-call\" fn call_once(mut self, args: ClosureArguments) -> Self::Output {\n-            self.call_mut(args)\n-            }\n-        }\n-        #[cfg(bootstrap)]\n-        #[allow(unused_parens)]\n-        impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n-            FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n-        where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments)-> ClosureReturnValue + ~const Destruct,\n-        {\n-            extern \"rust-call\" fn call_mut(&mut self, args: ClosureArguments) -> Self::Output {\n-                #[allow(non_snake_case)]\n-                let ($($var),*) = &mut self.data;\n-                (self.func)(($($var),*), args)\n-            }\n-        }\n-        #[cfg(not(bootstrap))]\n         #[allow(unused_parens)]\n         impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n             FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n@@ -85,7 +57,6 @@ macro_rules! impl_fn_mut_tuple {\n             self.call_mut(args)\n             }\n         }\n-        #[cfg(not(bootstrap))]\n         #[allow(unused_parens)]\n         impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n             FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>"}, {"sha": "5bfe001de46e3775f456a9c42c026b0b4230e253", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -44,7 +44,7 @@ pub use poll_fn::{poll_fn, PollFn};\n ///    non-Send/Sync as well, and we don't want that.\n ///\n /// It also simplifies the HIR lowering of `.await`.\n-#[cfg_attr(not(bootstrap), lang = \"ResumeTy\")]\n+#[lang = \"ResumeTy\"]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Debug, Copy, Clone)]\n@@ -61,7 +61,6 @@ unsafe impl Sync for ResumeTy {}\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n-#[cfg_attr(bootstrap, lang = \"from_generator\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[rustc_const_unstable(feature = \"gen_future\", issue = \"50547\")]\n@@ -113,10 +112,10 @@ pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n     unsafe { &mut *cx.0.as_ptr().cast() }\n }\n \n-#[cfg_attr(not(bootstrap), lang = \"identity_future\")]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n+#[lang = \"identity_future\"]\n pub const fn identity_future<O, Fut: Future<Output = O>>(f: Fut) -> Fut {\n     f\n }"}, {"sha": "a315a28fb0d943f24deb882e1cdf8937637c5315", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -55,7 +55,6 @@\n #![allow(missing_docs)]\n \n use crate::marker::DiscriminantKind;\n-#[cfg(not(bootstrap))]\n use crate::marker::Tuple;\n use crate::mem;\n \n@@ -2175,66 +2174,6 @@ extern \"rust-intrinsic\" {\n     /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n     /// which violates the principle that a `const fn` must behave the same at\n     /// compile-time and at run-time. The unsafe code in crate B is fine.\n-    #[cfg(bootstrap)]\n-    #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n-    pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n-    where\n-        G: FnOnce<ARG, Output = RET>,\n-        F: FnOnce<ARG, Output = RET>;\n-\n-    /// Selects which function to call depending on the context.\n-    ///\n-    /// If this function is evaluated at compile-time, then a call to this\n-    /// intrinsic will be replaced with a call to `called_in_const`. It gets\n-    /// replaced with a call to `called_at_rt` otherwise.\n-    ///\n-    /// # Type Requirements\n-    ///\n-    /// The two functions must be both function items. They cannot be function\n-    /// pointers or closures. The first function must be a `const fn`.\n-    ///\n-    /// `arg` will be the tupled arguments that will be passed to either one of\n-    /// the two functions, therefore, both functions must accept the same type of\n-    /// arguments. Both functions must return RET.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The two functions must behave observably equivalent. Safe code in other\n-    /// crates may assume that calling a `const fn` at compile-time and at run-time\n-    /// produces the same result. A function that produces a different result when\n-    /// evaluated at run-time, or has any other observable side-effects, is\n-    /// *unsound*.\n-    ///\n-    /// Here is an example of how this could cause a problem:\n-    /// ```no_run\n-    /// #![feature(const_eval_select)]\n-    /// #![feature(core_intrinsics)]\n-    /// use std::hint::unreachable_unchecked;\n-    /// use std::intrinsics::const_eval_select;\n-    ///\n-    /// // Crate A\n-    /// pub const fn inconsistent() -> i32 {\n-    ///     fn runtime() -> i32 { 1 }\n-    ///     const fn compiletime() -> i32 { 2 }\n-    ///\n-    ///     unsafe {\n-    //          // \u26a0 This code violates the required equivalence of `compiletime`\n-    ///         // and `runtime`.\n-    ///         const_eval_select((), compiletime, runtime)\n-    ///     }\n-    /// }\n-    ///\n-    /// // Crate B\n-    /// const X: i32 = inconsistent();\n-    /// let x = inconsistent();\n-    /// if x != X { unsafe { unreachable_unchecked(); }}\n-    /// ```\n-    ///\n-    /// This code causes Undefined Behavior when being run, since the\n-    /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n-    /// which violates the principle that a `const fn` must behave the same at\n-    /// compile-time and at run-time. The unsafe code in crate B is fine.\n-    #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n     pub fn const_eval_select<ARG: Tuple, F, G, RET>(\n         arg: ARG,"}, {"sha": "ab29f7bdeebdf613325dce81a4d0323e01f981cf", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -195,7 +195,7 @@\n #![feature(const_refs_to_cell)]\n #![feature(decl_macro)]\n #![feature(deprecated_suggestion)]\n-#![cfg_attr(not(bootstrap), feature(derive_const))]\n+#![feature(derive_const)]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]\n #![feature(rustdoc_internals)]"}, {"sha": "cfc1cabe229e59d45005e49120752a4998554421", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -1461,7 +1461,6 @@ pub(crate) mod builtin {\n     /// [the reference]: ../../../reference/attributes/derive.html\n     #[unstable(feature = \"derive_const\", issue = \"none\")]\n     #[rustc_builtin_macro]\n-    #[cfg(not(bootstrap))]\n     pub macro derive_const($item:item) {\n         /* compiler built-in */\n     }\n@@ -1516,7 +1515,6 @@ pub(crate) mod builtin {\n     /// Attribute macro applied to a function to register it as a handler for allocation failure.\n     ///\n     /// See also [`std::alloc::handle_alloc_error`](../../../std/alloc/fn.handle_alloc_error.html).\n-    #[cfg(not(bootstrap))]\n     #[unstable(feature = \"alloc_error_handler\", issue = \"51540\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n@@ -1553,7 +1551,6 @@ pub(crate) mod builtin {\n         issue = \"23416\",\n         reason = \"placeholder syntax for type ascription\"\n     )]\n-    #[cfg(not(bootstrap))]\n     pub macro type_ascribe($expr:expr, $ty:ty) {\n         /* compiler built-in */\n     }"}, {"sha": "c0fb954ce2d9d39c0a291902a021894ca820db2d", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -96,7 +96,7 @@ unsafe impl<T: Sync + ?Sized> Send for &T {}\n )]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n #[rustc_specialization_trait]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Sized {\n     // Empty.\n }\n@@ -128,7 +128,7 @@ pub trait Sized {\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"unsize\", issue = \"18598\")]\n #[lang = \"unsize\"]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n@@ -695,7 +695,7 @@ impl<T: ?Sized> StructuralEq for PhantomData<T> {}\n     reason = \"this trait is unlikely to ever be stabilized, use `mem::discriminant` instead\"\n )]\n #[lang = \"discriminant_kind\"]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait DiscriminantKind {\n     /// The type of the discriminant, which must satisfy the trait\n     /// bounds required by `mem::Discriminant`.\n@@ -796,7 +796,7 @@ impl<T: ?Sized> Unpin for *mut T {}\n #[lang = \"destruct\"]\n #[rustc_on_unimplemented(message = \"can't drop `{Self}`\", append_const_msg)]\n #[const_trait]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Destruct {}\n \n /// A marker for tuple types.\n@@ -806,12 +806,12 @@ pub trait Destruct {}\n #[unstable(feature = \"tuple_trait\", issue = \"none\")]\n #[lang = \"tuple_trait\"]\n #[rustc_on_unimplemented(message = \"`{Self}` is not a tuple\")]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Tuple {}\n \n /// A marker for things\n #[unstable(feature = \"pointer_sized_trait\", issue = \"none\")]\n-#[cfg_attr(not(bootstrap), lang = \"pointer_sized\")]\n+#[lang = \"pointer_sized\"]\n #[rustc_on_unimplemented(\n     message = \"`{Self}` needs to be a pointer-sized type\",\n     label = \"`{Self}` needs to be a pointer-sized type\""}, {"sha": "b7e1aee9d84d123be63137e0ea81b026e7d855c7", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -1,4 +1,3 @@\n-#[cfg(not(bootstrap))]\n use crate::marker::Tuple;\n \n /// The version of the call operator that takes an immutable receiver.\n@@ -54,87 +53,6 @@ use crate::marker::Tuple;\n /// let double = |x| x * 2;\n /// assert_eq!(call_with_one(double), 2);\n /// ```\n-#[cfg(bootstrap)]\n-#[lang = \"fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[rustc_on_unimplemented(\n-    on(\n-        Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n-    ),\n-    on(\n-        _Self = \"unsafe fn\",\n-        note = \"unsafe function cannot be called generically without an unsafe block\",\n-        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n-        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n-    ),\n-    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n-    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n-)]\n-#[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n-pub trait Fn<Args>: FnMut<Args> {\n-    /// Performs the call operation.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-}\n-\n-/// The version of the call operator that takes an immutable receiver.\n-///\n-/// Instances of `Fn` can be called repeatedly without mutating state.\n-///\n-/// *This trait (`Fn`) is not to be confused with [function pointers]\n-/// (`fn`).*\n-///\n-/// `Fn` is implemented automatically by closures which only take immutable\n-/// references to captured variables or don't capture anything at all, as well\n-/// as (safe) [function pointers] (with some caveats, see their documentation\n-/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n-/// implements `Fn`, too.\n-///\n-/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n-/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n-/// is expected.\n-///\n-/// Use `Fn` as a bound when you want to accept a parameter of function-like\n-/// type and need to call it repeatedly and without mutating state (e.g., when\n-/// calling it concurrently). If you do not need such strict requirements, use\n-/// [`FnMut`] or [`FnOnce`] as bounds.\n-///\n-/// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// some more information on this topic.\n-///\n-/// Also of note is the special syntax for `Fn` traits (e.g.\n-/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n-///\n-/// [book]: ../../book/ch13-01-closures.html\n-/// [function pointers]: fn\n-/// [nomicon]: ../../nomicon/hrtb.html\n-///\n-/// # Examples\n-///\n-/// ## Calling a closure\n-///\n-/// ```\n-/// let square = |x| x * x;\n-/// assert_eq!(square(5), 25);\n-/// ```\n-///\n-/// ## Using a `Fn` parameter\n-///\n-/// ```\n-/// fn call_with_one<F>(func: F) -> usize\n-///     where F: Fn(usize) -> usize {\n-///     func(1)\n-/// }\n-///\n-/// let double = |x| x * 2;\n-/// assert_eq!(call_with_one(double), 2);\n-/// ```\n-#[cfg(not(bootstrap))]\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -222,95 +140,6 @@ pub trait Fn<Args: Tuple>: FnMut<Args> {\n ///\n /// assert_eq!(x, 5);\n /// ```\n-#[cfg(bootstrap)]\n-#[lang = \"fn_mut\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[rustc_on_unimplemented(\n-    on(\n-        Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n-    ),\n-    on(\n-        _Self = \"unsafe fn\",\n-        note = \"unsafe function cannot be called generically without an unsafe block\",\n-        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n-        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n-    ),\n-    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n-    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n-)]\n-#[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n-pub trait FnMut<Args>: FnOnce<Args> {\n-    /// Performs the call operation.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-}\n-\n-/// The version of the call operator that takes a mutable receiver.\n-///\n-/// Instances of `FnMut` can be called repeatedly and may mutate state.\n-///\n-/// `FnMut` is implemented automatically by closures which take mutable\n-/// references to captured variables, as well as all types that implement\n-/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n-/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n-/// implements `FnMut`, too.\n-///\n-/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n-/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n-/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n-///\n-/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n-/// type and need to call it repeatedly, while allowing it to mutate state.\n-/// If you don't want the parameter to mutate state, use [`Fn`] as a\n-/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n-///\n-/// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// some more information on this topic.\n-///\n-/// Also of note is the special syntax for `Fn` traits (e.g.\n-/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n-///\n-/// [book]: ../../book/ch13-01-closures.html\n-/// [function pointers]: fn\n-/// [nomicon]: ../../nomicon/hrtb.html\n-///\n-/// # Examples\n-///\n-/// ## Calling a mutably capturing closure\n-///\n-/// ```\n-/// let mut x = 5;\n-/// {\n-///     let mut square_x = || x *= x;\n-///     square_x();\n-/// }\n-/// assert_eq!(x, 25);\n-/// ```\n-///\n-/// ## Using a `FnMut` parameter\n-///\n-/// ```\n-/// fn do_twice<F>(mut func: F)\n-///     where F: FnMut()\n-/// {\n-///     func();\n-///     func();\n-/// }\n-///\n-/// let mut x: usize = 1;\n-/// {\n-///     let add_two_to_x = || x += 2;\n-///     do_twice(add_two_to_x);\n-/// }\n-///\n-/// assert_eq!(x, 5);\n-/// ```\n-#[cfg(not(bootstrap))]\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -390,92 +219,6 @@ pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n ///\n /// // `consume_and_return_x` can no longer be invoked at this point\n /// ```\n-#[cfg(bootstrap)]\n-#[lang = \"fn_once\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_paren_sugar]\n-#[rustc_on_unimplemented(\n-    on(\n-        Args = \"()\",\n-        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n-    ),\n-    on(\n-        _Self = \"unsafe fn\",\n-        note = \"unsafe function cannot be called generically without an unsafe block\",\n-        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n-        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n-    ),\n-    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n-    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n-)]\n-#[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n-pub trait FnOnce<Args> {\n-    /// The returned type after the call operator is used.\n-    #[lang = \"fn_once_output\"]\n-    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n-    type Output;\n-\n-    /// Performs the call operation.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-}\n-\n-/// The version of the call operator that takes a by-value receiver.\n-///\n-/// Instances of `FnOnce` can be called, but might not be callable multiple\n-/// times. Because of this, if the only thing known about a type is that it\n-/// implements `FnOnce`, it can only be called once.\n-///\n-/// `FnOnce` is implemented automatically by closures that might consume captured\n-/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n-/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n-///\n-/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n-/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n-///\n-/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n-/// type and only need to call it once. If you need to call the parameter\n-/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n-/// state, use [`Fn`].\n-///\n-/// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// some more information on this topic.\n-///\n-/// Also of note is the special syntax for `Fn` traits (e.g.\n-/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n-///\n-/// [book]: ../../book/ch13-01-closures.html\n-/// [function pointers]: fn\n-/// [nomicon]: ../../nomicon/hrtb.html\n-///\n-/// # Examples\n-///\n-/// ## Using a `FnOnce` parameter\n-///\n-/// ```\n-/// fn consume_with_relish<F>(func: F)\n-///     where F: FnOnce() -> String\n-/// {\n-///     // `func` consumes its captured variables, so it cannot be run more\n-///     // than once.\n-///     println!(\"Consumed: {}\", func());\n-///\n-///     println!(\"Delicious!\");\n-///\n-///     // Attempting to invoke `func()` again will throw a `use of moved\n-///     // value` error for `func`.\n-/// }\n-///\n-/// let x = String::from(\"x\");\n-/// let consume_and_return_x = move || x;\n-/// consume_with_relish(consume_and_return_x);\n-///\n-/// // `consume_and_return_x` can no longer be invoked at this point\n-/// ```\n-#[cfg(not(bootstrap))]\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n@@ -507,68 +250,6 @@ pub trait FnOnce<Args: Tuple> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n-#[cfg(bootstrap)]\n-mod impls {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const Fn<A> for &F\n-    where\n-        F: ~const Fn<A>,\n-    {\n-        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n-            (**self).call(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnMut<A> for &F\n-    where\n-        F: ~const Fn<A>,\n-    {\n-        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n-            (**self).call(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnOnce<A> for &F\n-    where\n-        F: ~const Fn<A>,\n-    {\n-        type Output = F::Output;\n-\n-        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n-            (*self).call(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnMut<A> for &mut F\n-    where\n-        F: ~const FnMut<A>,\n-    {\n-        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n-            (*self).call_mut(args)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A, F: ?Sized> const FnOnce<A> for &mut F\n-    where\n-        F: ~const FnMut<A>,\n-    {\n-        type Output = F::Output;\n-        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n-            (*self).call_mut(args)\n-        }\n-    }\n-}\n-\n-#[cfg(not(bootstrap))]\n mod impls {\n     use crate::marker::Tuple;\n "}, {"sha": "10525a16f3a66ebd8970cf8a13afb23351c6d22a", "filename": "library/core/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fv1.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -75,14 +75,12 @@ pub use crate::macros::builtin::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use crate::macros::builtin::alloc_error_handler;\n-#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use crate::macros::builtin::{bench, derive, global_allocator, test, test_case};\n+pub use crate::macros::builtin::{\n+    alloc_error_handler, bench, derive, global_allocator, test, test_case,\n+};\n \n #[unstable(feature = \"derive_const\", issue = \"none\")]\n-#[cfg(not(bootstrap))]\n pub use crate::macros::builtin::derive_const;\n \n #[unstable(\n@@ -104,5 +102,4 @@ pub use crate::macros::builtin::cfg_eval;\n     issue = \"23416\",\n     reason = \"placeholder syntax for type ascription\"\n )]\n-#[cfg(not(bootstrap))]\n pub use crate::macros::builtin::type_ascribe;"}, {"sha": "2123147c7e44c1779226bf2b9bce9783bffb990a", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -10,8 +10,7 @@ use crate::{cmp, fmt, hash, mem, num};\n /// are likely not to be supported by actual allocators and linkers.\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(transparent)]\n pub struct Alignment(AlignmentEnum);\n \n@@ -203,8 +202,7 @@ type AlignmentEnum = AlignmentEnum32;\n type AlignmentEnum = AlignmentEnum64;\n \n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(u16)]\n enum AlignmentEnum16 {\n     _Align1Shl0 = 1 << 0,\n@@ -226,8 +224,7 @@ enum AlignmentEnum16 {\n }\n \n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(u32)]\n enum AlignmentEnum32 {\n     _Align1Shl0 = 1 << 0,\n@@ -265,8 +262,7 @@ enum AlignmentEnum32 {\n }\n \n #[derive(Copy, Clone, Eq)]\n-#[cfg_attr(bootstrap, derive(PartialEq))]\n-#[cfg_attr(not(bootstrap), derive_const(PartialEq))]\n+#[derive_const(PartialEq)]\n #[repr(u64)]\n enum AlignmentEnum64 {\n     _Align1Shl0 = 1 << 0,"}, {"sha": "9a18857d49ffadc2fc4bd927d35aef61d22972af", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -1350,26 +1350,6 @@ impl<T: ?Sized> *const T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n \n-        #[cfg(bootstrap)]\n-        {\n-            fn rt_impl<T>(p: *const T, align: usize) -> usize {\n-                // SAFETY: `align` has been checked to be a power of 2 above\n-                unsafe { align_offset(p, align) }\n-            }\n-\n-            const fn ctfe_impl<T>(_: *const T, _: usize) -> usize {\n-                usize::MAX\n-            }\n-\n-            // SAFETY:\n-            // It is permissible for `align_offset` to always return `usize::MAX`,\n-            // algorithm correctness can not depend on `align_offset` returning non-max values.\n-            //\n-            // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n-            unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n-        }\n-\n-        #[cfg(not(bootstrap))]\n         {\n             // SAFETY: `align` has been checked to be a power of 2 above\n             unsafe { align_offset(self, align) }\n@@ -1406,8 +1386,7 @@ impl<T: ?Sized> *const T {\n     /// is never aligned if cast to a type with a stricter alignment than the reference's\n     /// underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1433,8 +1412,7 @@ impl<T: ?Sized> *const T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1460,8 +1438,7 @@ impl<T: ?Sized> *const T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1537,8 +1514,7 @@ impl<T: ?Sized> *const T {\n     /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n     /// cannot be stricter aligned than the reference's underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1563,8 +1539,7 @@ impl<T: ?Sized> *const T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1588,8 +1563,7 @@ impl<T: ?Sized> *const T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///"}, {"sha": "2ea032d4affe052abb3898f2182ccccb241040b5", "filename": "library/core/src/ptr/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -50,7 +50,7 @@ use crate::hash::{Hash, Hasher};\n ///\n /// [`to_raw_parts`]: *const::to_raw_parts\n #[lang = \"pointee_trait\"]\n-#[cfg_attr(not(bootstrap), rustc_deny_explicit_impl)]\n+#[rustc_deny_explicit_impl]\n pub trait Pointee {\n     /// The type for metadata in pointers and references to `Self`.\n     #[lang = \"metadata_type\"]"}, {"sha": "8b9c1f7780ae4c3da09a3d1a028f361f0da2fd92", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -1618,26 +1618,6 @@ impl<T: ?Sized> *mut T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n \n-        #[cfg(bootstrap)]\n-        {\n-            fn rt_impl<T>(p: *mut T, align: usize) -> usize {\n-                // SAFETY: `align` has been checked to be a power of 2 above\n-                unsafe { align_offset(p, align) }\n-            }\n-\n-            const fn ctfe_impl<T>(_: *mut T, _: usize) -> usize {\n-                usize::MAX\n-            }\n-\n-            // SAFETY:\n-            // It is permissible for `align_offset` to always return `usize::MAX`,\n-            // algorithm correctness can not depend on `align_offset` returning non-max values.\n-            //\n-            // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n-            unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n-        }\n-\n-        #[cfg(not(bootstrap))]\n         {\n             // SAFETY: `align` has been checked to be a power of 2 above\n             unsafe { align_offset(self, align) }\n@@ -1674,8 +1654,7 @@ impl<T: ?Sized> *mut T {\n     /// is never aligned if cast to a type with a stricter alignment than the reference's\n     /// underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     /// #![feature(const_mut_refs)]\n@@ -1702,8 +1681,7 @@ impl<T: ?Sized> *mut T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1730,8 +1708,7 @@ impl<T: ?Sized> *mut T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1807,8 +1784,7 @@ impl<T: ?Sized> *mut T {\n     /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n     /// cannot be stricter aligned than the reference's underlying allocation.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     /// #![feature(const_mut_refs)]\n@@ -1834,8 +1810,7 @@ impl<T: ?Sized> *mut T {\n     /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n     /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n@@ -1860,8 +1835,7 @@ impl<T: ?Sized> *mut T {\n     /// If a pointer is created from a fixed address, this function behaves the same during\n     /// runtime and compiletime.\n     ///\n-    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n-    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// ```\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///"}, {"sha": "25b61c0e66641d9beaf8a11fd88afef387317ae4", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -9,7 +9,7 @@ use crate::task::Ready;\n /// scheduled to receive a wakeup instead.\n #[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-#[cfg_attr(not(bootstrap), lang = \"Poll\")]\n+#[lang = \"Poll\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready."}, {"sha": "a8f6b7ebb925029d799c1b74af314c2f815937c1", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -131,7 +131,6 @@ fn distinct_type_names() {\n     assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n }\n \n-#[cfg(not(bootstrap))]\n #[test]\n fn dyn_type_name() {\n     trait Foo {"}, {"sha": "f7740a114e738d84f86b87a083cd92b82d5dc1ad", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -77,7 +77,6 @@ fn align_of_val_basic() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))] // stage 0 doesn't have the fix yet, so the test fails\n fn align_of_val_raw_packed() {\n     #[repr(C, packed)]\n     struct B {"}, {"sha": "a71691a8115ba57273b5d190bd14058aa0418dfb", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -359,7 +359,6 @@ fn align_offset_zst() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_zst_const() {\n     const {\n         // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n@@ -397,7 +396,6 @@ fn align_offset_stride_one() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_stride_one_const() {\n     const {\n         // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n@@ -493,7 +491,6 @@ fn align_offset_various_strides() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_various_strides_const() {\n     const unsafe fn test_stride<T>(ptr: *const T, numptr: usize, align: usize) {\n         let mut expected = usize::MAX;\n@@ -561,7 +558,6 @@ fn align_offset_various_strides_const() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_with_provenance_const() {\n     const {\n         // On some platforms (e.g. msp430-none-elf), the alignment of `i32` is less than 4.\n@@ -681,7 +677,6 @@ fn align_offset_issue_103361() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn align_offset_issue_103361_const() {\n     #[cfg(target_pointer_width = \"64\")]\n     const SIZE: usize = 1 << 47;\n@@ -715,7 +710,6 @@ fn is_aligned() {\n }\n \n #[test]\n-#[cfg(not(bootstrap))]\n fn is_aligned_const() {\n     const {\n         let data = 42;\n@@ -734,18 +728,6 @@ fn is_aligned_const() {\n     }\n }\n \n-#[test]\n-#[cfg(bootstrap)]\n-fn is_aligned_const() {\n-    const {\n-        let data = 42;\n-        let ptr: *const i32 = &data;\n-        // The bootstrap compiler always returns false for is_aligned.\n-        assert!(!ptr.is_aligned());\n-        assert!(!ptr.is_aligned_to(1));\n-    }\n-}\n-\n #[test]\n fn offset_from() {\n     let mut a = [0; 5];"}, {"sha": "2aefd7c513dc8d88421600a69b408a23a5b10aa7", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -59,14 +59,12 @@ pub use core::prelude::v1::{RustcDecodable, RustcEncodable};\n \n // Do not `doc(no_inline)` so that they become doc items on their own\n // (no public module for them to be re-exported from).\n-#[cfg(not(bootstrap))]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use core::prelude::v1::alloc_error_handler;\n-#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-pub use core::prelude::v1::{bench, derive, global_allocator, test, test_case};\n+pub use core::prelude::v1::{\n+    alloc_error_handler, bench, derive, global_allocator, test, test_case,\n+};\n \n #[unstable(feature = \"derive_const\", issue = \"none\")]\n-#[cfg(not(bootstrap))]\n pub use core::prelude::v1::derive_const;\n \n // Do not `doc(no_inline)` either.\n@@ -91,7 +89,6 @@ pub use core::prelude::v1::cfg_eval;\n     issue = \"23416\",\n     reason = \"placeholder syntax for type ascription\"\n )]\n-#[cfg(not(bootstrap))]\n pub use core::prelude::v1::type_ascribe;\n \n // The file so far is equivalent to src/libcore/prelude/v1.rs,"}, {"sha": "f92d6052cc628314bcee716d12b0d7f4fd64b9bb", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/11191279b721b326d545005b96ad9eecc7a95827/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11191279b721b326d545005b96ad9eecc7a95827/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=11191279b721b326d545005b96ad9eecc7a95827", "patch": "@@ -29,7 +29,7 @@ use crate::ptr;\n use crate::sync::atomic::{self, AtomicPtr, Ordering};\n \n // We can use true weak linkage on ELF targets.\n-#[cfg(all(not(any(target_os = \"macos\", target_os = \"ios\")), not(bootstrap)))]\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n pub(crate) macro weak {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n         let ref $name: ExternWeak<unsafe extern \"C\" fn($($t),*) -> $ret> = {\n@@ -43,30 +43,14 @@ pub(crate) macro weak {\n     )\n }\n \n-#[cfg(all(not(any(target_os = \"macos\", target_os = \"ios\")), bootstrap))]\n-pub(crate) macro weak {\n-    (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n-        let ref $name: ExternWeak<unsafe extern \"C\" fn($($t),*) -> $ret> = {\n-            extern \"C\" {\n-                #[linkage = \"extern_weak\"]\n-                static $name: *const libc::c_void;\n-            }\n-            #[allow(unused_unsafe)]\n-            ExternWeak::new(unsafe { $name })\n-        };\n-    )\n-}\n-\n // On non-ELF targets, use the dlsym approximation of weak linkage.\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub(crate) use self::dlsym as weak;\n \n-#[cfg(not(bootstrap))]\n pub(crate) struct ExternWeak<F: Copy> {\n     weak_ptr: Option<F>,\n }\n \n-#[cfg(not(bootstrap))]\n impl<F: Copy> ExternWeak<F> {\n     #[inline]\n     pub(crate) fn new(weak_ptr: Option<F>) -> Self {\n@@ -79,34 +63,6 @@ impl<F: Copy> ExternWeak<F> {\n     }\n }\n \n-#[cfg(bootstrap)]\n-pub(crate) struct ExternWeak<F> {\n-    weak_ptr: *const libc::c_void,\n-    _marker: PhantomData<F>,\n-}\n-\n-#[cfg(bootstrap)]\n-impl<F> ExternWeak<F> {\n-    #[inline]\n-    pub(crate) fn new(weak_ptr: *const libc::c_void) -> Self {\n-        ExternWeak { weak_ptr, _marker: PhantomData }\n-    }\n-}\n-\n-#[cfg(bootstrap)]\n-impl<F> ExternWeak<F> {\n-    #[inline]\n-    pub(crate) fn get(&self) -> Option<F> {\n-        unsafe {\n-            if self.weak_ptr.is_null() {\n-                None\n-            } else {\n-                Some(mem::transmute_copy::<*const libc::c_void, F>(&self.weak_ptr))\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) macro dlsym {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n          dlsym!(fn $name($($t),*) -> $ret, stringify!($name));"}]}