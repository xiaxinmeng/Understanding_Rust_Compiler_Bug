{"sha": "66b0c97070f422cb82baaaafc79ee94cab4396c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YjBjOTcwNzBmNDIyY2I4MmJhYWFhZmM3OWVlOTRjYWI0Mzk2YzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-20T13:37:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-20T13:37:03Z"}, "message": "Auto merge of #68277 - michaelwoerister:re-export-dylib-instances, r=alexcrichton\n\nMake sure that all upstream generics get re-exported from Rust dylibs.\n\nThis PR contains a fix for #67276. Rust dylibs would not re-export all generic instances when compiling with `-Zshare-generics=on` (=default for debug builds) which could lead to situations where the compiler expected certain generic instances to be available but then the linker would not find them.\n\n### TODO\n- [x] Write a regression test based on the description [here](https://github.com/rust-lang/rust/issues/67276#issuecomment-574613457).\n- [x] Find out if this also fixes other issues related to https://github.com/rust-lang/rust/issues/64319.\n\nr? @alexcrichton ~~(once the TODOs are done)~~\ncc @pnkfelix @AlexKornitzer", "tree": {"sha": "c0b01b86925a5b57b15008e61dc1e05af427f55d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0b01b86925a5b57b15008e61dc1e05af427f55d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66b0c97070f422cb82baaaafc79ee94cab4396c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66b0c97070f422cb82baaaafc79ee94cab4396c5", "html_url": "https://github.com/rust-lang/rust/commit/66b0c97070f422cb82baaaafc79ee94cab4396c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66b0c97070f422cb82baaaafc79ee94cab4396c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900811e43047fc5593f39b0363373530b02c87e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/900811e43047fc5593f39b0363373530b02c87e0", "html_url": "https://github.com/rust-lang/rust/commit/900811e43047fc5593f39b0363373530b02c87e0"}, {"sha": "0a9bcb0adf191897612e96a66b97ec8e1cff7412", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a9bcb0adf191897612e96a66b97ec8e1cff7412", "html_url": "https://github.com/rust-lang/rust/commit/0a9bcb0adf191897612e96a66b97ec8e1cff7412"}], "stats": {"total": 315, "additions": 267, "deletions": 48}, "files": [{"sha": "a349b34eb1a0c18a45dd339565a99cf5f9eb02e8", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -32,7 +32,9 @@ pub enum ExportedSymbol<'tcx> {\n }\n \n impl<'tcx> ExportedSymbol<'tcx> {\n-    pub fn symbol_name(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n+    /// This is the symbol name of an instance if it is instantiated in the\n+    /// local crate.\n+    pub fn symbol_name_for_local_instance(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => tcx.symbol_name(ty::Instance::mono(tcx, def_id)),\n             ExportedSymbol::Generic(def_id, substs) => {\n@@ -50,9 +52,22 @@ impl<'tcx> ExportedSymbol<'tcx> {\n                 }\n                 ExportedSymbol::Generic(..) | ExportedSymbol::NoDefId(_) => cmp::Ordering::Less,\n             },\n-            ExportedSymbol::Generic(..) => match *other {\n+            ExportedSymbol::Generic(self_def_id, self_substs) => match *other {\n                 ExportedSymbol::NonGeneric(_) => cmp::Ordering::Greater,\n-                ExportedSymbol::Generic(..) => self.symbol_name(tcx).cmp(&other.symbol_name(tcx)),\n+                ExportedSymbol::Generic(other_def_id, other_substs) => {\n+                    // We compare the symbol names because they are cached as query\n+                    // results which makes them relatively cheap to access repeatedly.\n+                    //\n+                    // It might be even faster to build a local cache of stable IDs\n+                    // for sorting. Exported symbols are really only sorted once\n+                    // in order to make the `exported_symbols` query result stable.\n+                    let self_symbol_name =\n+                        tcx.symbol_name(ty::Instance::new(self_def_id, self_substs));\n+                    let other_symbol_name =\n+                        tcx.symbol_name(ty::Instance::new(other_def_id, other_substs));\n+\n+                    self_symbol_name.cmp(&other_symbol_name)\n+                }\n                 ExportedSymbol::NoDefId(_) => cmp::Ordering::Less,\n             },\n             ExportedSymbol::NoDefId(self_symbol_name) => match *other {"}, {"sha": "b7aef0c44d9ee397ae59454f98b08161bd590d8f", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -557,6 +557,9 @@ rustc_queries! {\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n \n+        /// The `symbol_name` query provides the symbol name for calling a\n+        /// given instance from the local crate. In particular, it will also\n+        /// look up the correct symbol name of instances from upstream crates.\n         query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n             no_force\n             desc { \"computing the symbol for `{}`\", key }\n@@ -971,6 +974,11 @@ rustc_queries! {\n     }\n \n     Linking {\n+        /// The list of symbols exported from the given crate.\n+        ///\n+        /// - All names contained in `exported_symbols(cnum)` are guaranteed to\n+        ///   correspond to a publicly visible symbol in `cnum` machine code.\n+        /// - The `exported_symbols` sets of different crates do not intersect.\n         query exported_symbols(_: CrateNum)\n             -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n             desc { \"exported_symbols\" }"}, {"sha": "4679f6501336cfcda6e2fff8185a57a4327a0712", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -1103,7 +1103,11 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n     let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);\n     for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n         if level.is_below_threshold(export_threshold) {\n-            symbols.push(symbol.symbol_name(tcx).to_string());\n+            symbols.push(symbol_export::symbol_name_for_instance_in_crate(\n+                tcx,\n+                symbol,\n+                LOCAL_CRATE,\n+            ));\n         }\n     }\n \n@@ -1124,12 +1128,7 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n                     continue;\n                 }\n \n-                // FIXME rust-lang/rust#64319, rust-lang/rust#64872:\n-                // We want to block export of generics from dylibs,\n-                // but we must fix rust-lang/rust#65890 before we can\n-                // do that robustly.\n-\n-                symbols.push(symbol.symbol_name(tcx).to_string());\n+                symbols.push(symbol_export::symbol_name_for_instance_in_crate(tcx, symbol, cnum));\n             }\n         }\n     }"}, {"sha": "bd44b4a38fd58c0c3572a23462214fab35b14610", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -8,6 +8,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::Instance;\n use rustc::ty::{SymbolName, TyCtxt};\n+use rustc_codegen_utils::symbol_names;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n@@ -358,3 +359,32 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         SymbolExportLevel::Rust\n     }\n }\n+\n+/// This is the symbol name of the given instance instantiated in a specific crate.\n+pub fn symbol_name_for_instance_in_crate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    symbol: ExportedSymbol<'tcx>,\n+    instantiating_crate: CrateNum,\n+) -> String {\n+    // If this is something instantiated in the local crate then we might\n+    // already have cached the name as a query result.\n+    if instantiating_crate == LOCAL_CRATE {\n+        return symbol.symbol_name_for_local_instance(tcx).to_string();\n+    }\n+\n+    // This is something instantiated in an upstream crate, so we have to use\n+    // the slower (because uncached) version of computing the symbol name.\n+    match symbol {\n+        ExportedSymbol::NonGeneric(def_id) => symbol_names::symbol_name_for_instance_in_crate(\n+            tcx,\n+            Instance::mono(tcx, def_id),\n+            instantiating_crate,\n+        ),\n+        ExportedSymbol::Generic(def_id, substs) => symbol_names::symbol_name_for_instance_in_crate(\n+            tcx,\n+            Instance::new(def_id, substs),\n+            instantiating_crate,\n+        ),\n+        ExportedSymbol::NoDefId(symbol_name) => symbol_name.to_string(),\n+    }\n+}"}, {"sha": "049faff7c49ee69609e4d191968c84fbcf90d8da", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -2,7 +2,7 @@ use super::command::Command;\n use super::link::{self, get_linker, remove};\n use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n-use super::symbol_export::ExportedSymbols;\n+use super::symbol_export::{symbol_name_for_instance_in_crate, ExportedSymbols};\n use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n     RLIB_BYTECODE_EXTENSION,\n@@ -956,7 +956,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             let symbols = tcx\n                 .exported_symbols(cnum)\n                 .iter()\n-                .map(|&(s, lvl)| (s.symbol_name(tcx).to_string(), lvl))\n+                .map(|&(s, lvl)| (symbol_name_for_instance_in_crate(tcx, s, cnum), lvl))\n                 .collect();\n             Arc::new(symbols)\n         };"}, {"sha": "96a74f96fcf6054ba64b5dbb3721e30d949d1251", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -91,8 +91,9 @@ use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::mir::mono::{InstantiationMode, MonoItem};\n use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::query::Providers;\n+use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Instance, TyCtxt};\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::Node;\n \n use rustc_span::symbol::Symbol;\n@@ -102,15 +103,70 @@ use log::debug;\n mod legacy;\n mod v0;\n \n+/// This function computes the symbol name for the given `instance` and the\n+/// given instantiating crate. That is, if you know that instance X is\n+/// instantiated in crate Y, this is the symbol name this instance would have.\n+pub fn symbol_name_for_instance_in_crate(\n+    tcx: TyCtxt<'tcx>,\n+    instance: Instance<'tcx>,\n+    instantiating_crate: CrateNum,\n+) -> String {\n+    compute_symbol_name(tcx, instance, || instantiating_crate)\n+}\n+\n pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        symbol_name: |tcx, instance| ty::SymbolName { name: symbol_name(tcx, instance) },\n+    *providers = Providers { symbol_name: symbol_name_provider, ..*providers };\n+}\n \n-        ..*providers\n-    };\n+// The `symbol_name` query provides the symbol name for calling a given\n+// instance from the local crate. In particular, it will also look up the\n+// correct symbol name of instances from upstream crates.\n+fn symbol_name_provider(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n+    let symbol_name = compute_symbol_name(tcx, instance, || {\n+        // This closure determines the instantiating crate for instances that\n+        // need an instantiating-crate-suffix for their symbol name, in order\n+        // to differentiate between local copies.\n+        //\n+        // For generics we might find re-usable upstream instances. For anything\n+        // else we rely on their being a local copy available.\n+\n+        if is_generic(instance.substs) {\n+            let def_id = instance.def_id();\n+\n+            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n+                // If we are re-using a monomorphization from another crate,\n+                // we have to compute the symbol hash accordingly.\n+                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n+\n+                upstream_monomorphizations\n+                    .and_then(|monos| monos.get(&instance.substs).cloned())\n+                    // If there is no instance available upstream, there'll be\n+                    // one in the current crate.\n+                    .unwrap_or(LOCAL_CRATE)\n+            } else {\n+                // For generic functions defined in the current crate, there\n+                // can be no upstream instances. Also, if we don't share\n+                // generics, we'll instantiate a local copy too.\n+                LOCAL_CRATE\n+            }\n+        } else {\n+            // For non-generic things that need to avoid naming conflicts, we\n+            // always instantiate a copy in the local crate.\n+            LOCAL_CRATE\n+        }\n+    });\n+\n+    ty::SymbolName { name: Symbol::intern(&symbol_name) }\n }\n \n-fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n+/// Computes the symbol name for the given instance. This function will call\n+/// `compute_instantiating_crate` if it needs to factor the instantiating crate\n+/// into the symbol name.\n+fn compute_symbol_name(\n+    tcx: TyCtxt<'tcx>,\n+    instance: Instance<'tcx>,\n+    compute_instantiating_crate: impl FnOnce() -> CrateNum,\n+) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -121,11 +177,11 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n     if def_id.is_local() {\n         if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return Symbol::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator));\n+            return tcx.sess.generate_plugin_registrar_symbol(disambiguator);\n         }\n         if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return Symbol::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator));\n+            return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n     }\n \n@@ -162,29 +218,28 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n             || !tcx.wasm_import_module_map(def_id.krate).contains_key(&def_id)\n         {\n             if let Some(name) = attrs.link_name {\n-                return name;\n+                return name.to_string();\n             }\n-            return tcx.item_name(def_id);\n+            return tcx.item_name(def_id).to_string();\n         }\n     }\n \n     if let Some(name) = attrs.export_name {\n         // Use provided name\n-        return name;\n+        return name.to_string();\n     }\n \n     if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n         // Don't mangle\n-        return tcx.item_name(def_id);\n+        return tcx.item_name(def_id).to_string();\n     }\n \n-    let is_generic = substs.non_erasable_generics().next().is_some();\n     let avoid_cross_crate_conflicts =\n         // If this is an instance of a generic function, we also hash in\n         // the ID of the instantiating crate. This avoids symbol conflicts\n         // in case the same instances is emitted in two crates of the same\n         // project.\n-        is_generic ||\n+        is_generic(substs) ||\n \n         // If we're dealing with an instance of a function that's inlined from\n         // another crate but we're marking it as globally shared to our\n@@ -197,25 +252,8 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n             _ => false,\n         };\n \n-    let instantiating_crate = if avoid_cross_crate_conflicts {\n-        Some(if is_generic {\n-            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n-                // If we are re-using a monomorphization from another crate,\n-                // we have to compute the symbol hash accordingly.\n-                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n-\n-                upstream_monomorphizations\n-                    .and_then(|monos| monos.get(&substs).cloned())\n-                    .unwrap_or(LOCAL_CRATE)\n-            } else {\n-                LOCAL_CRATE\n-            }\n-        } else {\n-            LOCAL_CRATE\n-        })\n-    } else {\n-        None\n-    };\n+    let instantiating_crate =\n+        if avoid_cross_crate_conflicts { Some(compute_instantiating_crate()) } else { None };\n \n     // Pick the crate responsible for the symbol mangling version, which has to:\n     // 1. be stable for each instance, whether it's being defined or imported\n@@ -232,10 +270,12 @@ fn symbol_name(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Symbol {\n         tcx.symbol_mangling_version(mangling_version_crate)\n     };\n \n-    let mangled = match mangling_version {\n+    match mangling_version {\n         SymbolManglingVersion::Legacy => legacy::mangle(tcx, instance, instantiating_crate),\n         SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate),\n-    };\n+    }\n+}\n \n-    Symbol::intern(&mangled)\n+fn is_generic(substs: SubstsRef<'_>) -> bool {\n+    substs.non_erasable_generics().next().is_some()\n }"}, {"sha": "5592f5a71fff1030c13dc63f9d1f5e6787392b2f", "filename": "src/test/run-make-fulldeps/issue64319/Makefile", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2FMakefile?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,39 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+# Different optimization levels imply different values for `-Zshare-generics`,\n+# so try out a whole bunch of combinations to make sure everything is compatible\n+all:\n+\t# First up, try some defaults\n+\t$(RUSTC) --crate-type rlib foo.rs\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n+\n+\t# Next try mixing up some things explicitly\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type rlib foo.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\n+\t# Now combine a whole bunch of options together\n+\t$(RUSTC) --crate-type rlib foo.rs\n+\t$(RUSTC) --crate-type dylib bar.rs\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=1 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=2 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=3 -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=s -Z share-generics=yes\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=no\n+\t$(RUSTC) --crate-type dylib bar.rs -C opt-level=z -Z share-generics=yes"}, {"sha": "3895c0b6cdbb3d760b7df23c8934eca5da0210e8", "filename": "src/test/run-make-fulldeps/issue64319/bar.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2Fbar.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,5 @@\n+extern crate foo;\n+\n+pub fn bar() {\n+    foo::foo();\n+}"}, {"sha": "c54a238e9add7f8ae13a1602df43d48467bf2b57", "filename": "src/test/run-make-fulldeps/issue64319/foo.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue64319%2Ffoo.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,9 @@\n+pub fn foo() {\n+    bar::<usize>();\n+}\n+\n+pub fn bar<T>() {\n+    baz();\n+}\n+\n+fn baz() {}"}, {"sha": "c6b5efcb4cdd8269ff14e1370dbc9dacf47568b7", "filename": "src/test/run-make-fulldeps/share-generics-dylib/Makefile", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2FMakefile?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,22 @@\n+# This test makes sure all generic instances get re-exported from Rust dylibs for use by\n+# `-Zshare-generics`. There are two rlibs (`instance_provider_a` and `instance_provider_b`)\n+# which both provide an instance of `Cell<i32>::set`. There is `instance_user_dylib` which is\n+# supposed to re-export both these instances, and then there are `instance_user_a_rlib` and\n+# `instance_user_b_rlib` which each rely on a specific instance to be available.\n+#\n+# In the end everything is linked together into `linked_leaf`. If `instance_user_dylib` does\n+# not export both then we'll get an `undefined reference` error for one of the instances.\n+#\n+# This is regression test for https://github.com/rust-lang/rust/issues/67276.\n+\n+-include ../../run-make-fulldeps/tools.mk\n+\n+COMMON_ARGS=-Cprefer-dynamic -Zshare-generics=yes -Ccodegen-units=1 -Zsymbol-mangling-version=v0\n+\n+all:\n+\t$(RUSTC) instance_provider_a.rs $(COMMON_ARGS) --crate-type=rlib\n+\t$(RUSTC) instance_provider_b.rs $(COMMON_ARGS) --crate-type=rlib\n+\t$(RUSTC) instance_user_dylib.rs $(COMMON_ARGS) --crate-type=dylib\n+\t$(RUSTC) instance_user_a_rlib.rs $(COMMON_ARGS) --crate-type=rlib\n+\t$(RUSTC) instance_user_b_rlib.rs $(COMMON_ARGS) --crate-type=rlib\n+\t$(RUSTC) linked_leaf.rs $(COMMON_ARGS) --crate-type=bin"}, {"sha": "b4e125ac0523ae72b491238fa0fe43afd5c68057", "filename": "src/test/run-make-fulldeps/share-generics-dylib/instance_provider_a.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_provider_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_provider_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_provider_a.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,6 @@\n+use std::cell::Cell;\n+\n+pub fn foo() {\n+    let a: Cell<i32> = Cell::new(1);\n+    a.set(123);\n+}"}, {"sha": "f613db873e6c6c41d6e1380db7fcf755a4328f34", "filename": "src/test/run-make-fulldeps/share-generics-dylib/instance_provider_b.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_provider_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_provider_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_provider_b.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,6 @@\n+use std::cell::Cell;\n+\n+pub fn foo() {\n+    let b: Cell<i32> = Cell::new(1);\n+    b.set(123);\n+}"}, {"sha": "c8e6ab95cf9ceccf9e40bf25005b1c1952098a44", "filename": "src/test/run-make-fulldeps/share-generics-dylib/instance_user_a_rlib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_a_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_a_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_a_rlib.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,9 @@\n+extern crate instance_provider_a as upstream;\n+use std::cell::Cell;\n+\n+pub fn foo() {\n+    upstream::foo();\n+\n+    let b: Cell<i32> = Cell::new(1);\n+    b.set(123);\n+}"}, {"sha": "7c34af6d0dc8705842175a0be2ca1bc0024d57be", "filename": "src/test/run-make-fulldeps/share-generics-dylib/instance_user_b_rlib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_b_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_b_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_b_rlib.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,9 @@\n+extern crate instance_provider_b as upstream;\n+use std::cell::Cell;\n+\n+pub fn foo() {\n+    upstream::foo();\n+\n+    let b: Cell<i32> = Cell::new(1);\n+    b.set(123);\n+}"}, {"sha": "7c8368eec654b4e8f5d256871d90a0f96048dc97", "filename": "src/test/run-make-fulldeps/share-generics-dylib/instance_user_dylib.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_dylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_dylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Finstance_user_dylib.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,7 @@\n+extern crate instance_provider_a;\n+extern crate instance_provider_b;\n+\n+pub fn foo() {\n+    instance_provider_a::foo();\n+    instance_provider_b::foo();\n+}"}, {"sha": "e510dad691c572e97b37348c28b69652e3087ba7", "filename": "src/test/run-make-fulldeps/share-generics-dylib/linked_leaf.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Flinked_leaf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b0c97070f422cb82baaaafc79ee94cab4396c5/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Flinked_leaf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fshare-generics-dylib%2Flinked_leaf.rs?ref=66b0c97070f422cb82baaaafc79ee94cab4396c5", "patch": "@@ -0,0 +1,15 @@\n+extern crate instance_user_dylib;\n+extern crate instance_user_a_rlib;\n+extern crate instance_user_b_rlib;\n+\n+use std::cell::Cell;\n+\n+fn main() {\n+\n+    instance_user_a_rlib::foo();\n+    instance_user_b_rlib::foo();\n+    instance_user_dylib::foo();\n+\n+    let a: Cell<i32> = Cell::new(1);\n+    a.set(123);\n+}"}]}