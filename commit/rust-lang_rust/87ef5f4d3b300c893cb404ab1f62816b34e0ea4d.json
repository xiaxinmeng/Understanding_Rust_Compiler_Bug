{"sha": "87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZWY1ZjRkM2IzMDBjODkzY2I0MDRhYjFmNjI4MTZiMzRlMGVhNGQ=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-03-11T09:51:16Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-03-11T20:30:35Z"}, "message": "Lint against indexing and slicing\n\nThis can be useful to prevent panics in a codebase. ATM it is a pedantic\nlint, but in the future it should be added to the restricions group.", "tree": {"sha": "657775ecdef93b16cb82d1844ae7a47295ac3a1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/657775ecdef93b16cb82d1844ae7a47295ac3a1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "html_url": "https://github.com/rust-lang/rust/commit/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84587d1266ab1643229d6fe1ecb381d7977e1b58", "url": "https://api.github.com/repos/rust-lang/rust/commits/84587d1266ab1643229d6fe1ecb381d7977e1b58", "html_url": "https://github.com/rust-lang/rust/commit/84587d1266ab1643229d6fe1ecb381d7977e1b58"}], "stats": {"total": 139, "additions": 128, "deletions": 11}, "files": [{"sha": "48a106e3591d3a8b6f8d8c573eccef5efc6fc26a", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "patch": "@@ -11,7 +11,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to link with clippy-service](#link-with-clippy-service)\n \n ##Lints\n-There are 133 lints included in this crate:\n+There are 134 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -58,6 +58,7 @@ name\n [if_not_else](https://github.com/Manishearth/rust-clippy/wiki#if_not_else)                                           | warn    | finds if branches that could be swapped so no negation operation is necessary on the condition\n [if_same_then_else](https://github.com/Manishearth/rust-clippy/wiki#if_same_then_else)                               | warn    | if with the same *then* and *else* blocks\n [ifs_same_cond](https://github.com/Manishearth/rust-clippy/wiki#ifs_same_cond)                                       | warn    | consecutive `ifs` with the same condition\n+[indexing_slicing](https://github.com/Manishearth/rust-clippy/wiki#indexing_slicing)                                 | allow   | indexing/slicing usage\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                         | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n [inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                       | warn    | `#[inline(always)]` is a bad idea in most cases\n [invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                       | deny    | finds invalid regular expressions in `Regex::new(_)` invocations"}, {"sha": "abce04f0b774cfa11db50e0ceab5512c55083601", "filename": "src/array_indexing.rs", "status": "modified", "additions": 103, "deletions": 7, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/src%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/src%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farray_indexing.rs?ref=87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "patch": "@@ -3,7 +3,8 @@ use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n use rustc::middle::ty::TyArray;\n use rustc_front::hir::*;\n-use utils::span_lint;\n+use syntax::ast::RangeLimits;\n+use utils;\n \n /// **What it does:** Check for out of bounds array indexing with a constant index.\n ///\n@@ -17,35 +18,130 @@ use utils::span_lint;\n /// let x = [1,2,3,4];\n /// ...\n /// x[9];\n+/// &x[2..9];\n /// ```\n declare_lint! {\n     pub OUT_OF_BOUNDS_INDEXING,\n     Deny,\n     \"out of bound constant indexing\"\n }\n \n+/// **What it does:** Check for usage of indexing or slicing.\n+///\n+/// **Why is this bad?** Usually, this can be safely allowed. However,\n+/// in some domains such as kernel development, a panic can cause the\n+/// whole operating system to crash.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// ...\n+/// x[2];\n+/// &x[0..2];\n+/// ```\n+declare_lint! {\n+    pub INDEXING_SLICING,\n+    Allow,\n+    \"indexing/slicing usage\"\n+}\n+\n #[derive(Copy,Clone)]\n pub struct ArrayIndexing;\n \n impl LintPass for ArrayIndexing {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OUT_OF_BOUNDS_INDEXING)\n+        lint_array!(INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING)\n     }\n }\n \n impl LateLintPass for ArrayIndexing {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprIndex(ref array, ref index) = e.node {\n+            // Array with known size can be checked statically\n             let ty = cx.tcx.expr_ty(array);\n-\n             if let TyArray(_, size) = ty.sty {\n-                let index = eval_const_expr_partial(cx.tcx, &index, ExprTypeChecked, None);\n-                if let Ok(ConstVal::Uint(index)) = index {\n-                    if size as u64 <= index {\n-                        span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index-expr is out of bounds\");\n+                let size = size as u64;\n+\n+                // Index is a constant uint\n+                let const_index = eval_const_expr_partial(cx.tcx, &index, ExprTypeChecked, None);\n+                if let Ok(ConstVal::Uint(const_index)) = const_index {\n+                    if size <= const_index {\n+                        utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n+                        utils::span_lint(cx, INDEXING_SLICING, e.span, \"indexing may panic\");\n+                    } else {\n+                        // Index is within bounds\n+                        return;\n                     }\n                 }\n+\n+                // Index is a constant range\n+                if let Some(range) = utils::unsugar_range(index) {\n+                    let start = range.start.map(|start|\n+                        eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None));\n+                    let end = range.end.map(|end|\n+                        eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None));\n+\n+                    if let Some((start, end)) = to_const_range(start, end, range.limits, size) {\n+                        if start >= size && end >= size {\n+                            utils::span_lint(cx,\n+                                             OUT_OF_BOUNDS_INDEXING,\n+                                             e.span,\n+                                             \"range is out of bounds\");\n+                            utils::span_lint(cx,\n+                                             INDEXING_SLICING,\n+                                             e.span,\n+                                             \"slicing may panic\");\n+                        } else {\n+                            // Range is within bounds\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if let Some(range) = utils::unsugar_range(index) {\n+                // Full ranges are always valid\n+                if range.start.is_none() && range.end.is_none() {\n+                    return;\n+                }\n+\n+                // Impossible to know if indexing or slicing is correct\n+                utils::span_lint(cx, INDEXING_SLICING, e.span, \"slicing may panic\");\n+            } else {\n+                utils::span_lint(cx, INDEXING_SLICING, e.span, \"indexing may panic\");\n             }\n         }\n     }\n }\n+\n+/// Returns an option containing a tuple with the start and end (exclusive) of the range\n+///\n+/// Note: we assume the start and the end of the range are unsigned, since array slicing\n+/// works only on usize\n+fn to_const_range<T>(start: Option<Result<ConstVal, T>>,\n+                    end: Option<Result<ConstVal, T>>,\n+                    limits: RangeLimits,\n+                    array_size: u64)\n+                    -> Option<(u64, u64)> {\n+    let start = match start {\n+        Some(Ok(ConstVal::Uint(x))) => x,\n+        Some(_) => return None,\n+        None => 0,\n+    };\n+\n+    let end = match end {\n+        Some(Ok(ConstVal::Uint(x))) => {\n+            if limits == RangeLimits::Closed {\n+                x\n+            } else {\n+                x - 1\n+            }\n+        }\n+        Some(_) => return None,\n+        None => array_size - 1,\n+    };\n+\n+    Some((start, end))\n+}"}, {"sha": "664819b97ecbe2e10e04b441a4f2e1c73277bfee", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "patch": "@@ -181,6 +181,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box new_without_default::NewWithoutDefault);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n+        array_indexing::INDEXING_SLICING,\n         enum_glob_use::ENUM_GLOB_USE,\n         matches::SINGLE_MATCH_ELSE,\n         methods::OPTION_UNWRAP_USED,"}, {"sha": "bcd25f5bf06dbc54358b576bc1ca0db96d2891ec", "filename": "tests/compile-fail/array_indexing.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/tests%2Fcompile-fail%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ef5f4d3b300c893cb404ab1f62816b34e0ea4d/tests%2Fcompile-fail%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Farray_indexing.rs?ref=87ef5f4d3b300c893cb404ab1f62816b34e0ea4d", "patch": "@@ -1,13 +1,32 @@\n-#![feature(plugin)]\n+#![feature(inclusive_range_syntax, plugin)]\n #![plugin(clippy)]\n \n+#![deny(indexing_slicing)]\n #![deny(out_of_bounds_indexing)]\n #![allow(no_effect)]\n \n fn main() {\n     let x = [1,2,3,4];\n     x[0];\n     x[3];\n-    x[4]; //~ERROR: const index-expr is out of bounds\n-    x[1 << 3]; //~ERROR: const index-expr is out of bounds\n+    x[4]; //~ERROR: indexing may panic\n+          //~^ ERROR: const index is out of bounds\n+    x[1 << 3]; //~ERROR: indexing may panic\n+               //~^ ERROR: const index is out of bounds\n+    &x[1..5]; //~ERROR: slicing may panic\n+              //~^ ERROR: range is out of bounds\n+    &x[0..3];\n+    &x[0...4]; //~ERROR: slicing may panic\n+               //~^ ERROR: range is out of bounds\n+    &x[..];\n+    &x[1..];\n+    &x[..4];\n+    &x[..5]; //~ERROR: slicing may panic\n+             //~^ ERROR: range is out of bounds\n+\n+    let y = &x;\n+    y[0]; //~ERROR: indexing may panic\n+    &y[1..2]; //~ERROR: slicing may panic\n+    &y[..];\n+    &y[0...4]; //~ERROR: slicing may panic\n }"}]}