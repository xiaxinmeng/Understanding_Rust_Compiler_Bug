{"sha": "2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlODhjMzZlYmNlYzEwMWM3ZGU2MzEzYzRkNDVmZmU2NjEyM2ZkM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-26T14:48:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-26T14:48:56Z"}, "message": "Auto merge of #28642 - petrochenkov:name3, r=nrc\n\nThis PR removes random remaining `Ident`s outside of libsyntax and performs general cleanup\r\nIn particular, interfaces of `Name` and `Ident` are tidied up, `Name`s and `Ident`s being small `Copy` aggregates are always passed to functions by value, and `Ident`s are never used as keys in maps, because `Ident` comparisons are tricky.\r\n\r\nAlthough this PR closes https://github.com/rust-lang/rust/issues/6993 there's still work related to it:\r\n- `Name` can be made `NonZero` to compress numerous `Option<Name>`s and `Option<Ident>`s but it requires const unsafe functions.\r\n- Implementation of `PartialEq` on `Ident` should be eliminated and replaced with explicit hygienic, non-hygienic or member-wise comparisons.\r\n- Finally, large parts of AST can potentially be converted to `Name`s in the same way as HIR to clearly separate identifiers used in hygienic and non-hygienic contexts.\r\n\r\nr? @nrc", "tree": {"sha": "918c785754a57678d6c9c63e97171273fa2a56ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/918c785754a57678d6c9c63e97171273fa2a56ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "html_url": "https://github.com/rust-lang/rust/commit/2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9169e6c53c53999d0ca176067a36c57aef84757b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9169e6c53c53999d0ca176067a36c57aef84757b", "html_url": "https://github.com/rust-lang/rust/commit/9169e6c53c53999d0ca176067a36c57aef84757b"}, {"sha": "f284cbc7af06a941de0cdd06291dc78d37268b9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f284cbc7af06a941de0cdd06291dc78d37268b9f", "html_url": "https://github.com/rust-lang/rust/commit/f284cbc7af06a941de0cdd06291dc78d37268b9f"}], "stats": {"total": 734, "additions": 335, "deletions": 399}, "files": [{"sha": "b7714a7e3c5dd96ec94ec4c2e9e86f2310d2d247", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -35,7 +35,7 @@ use syntax::parse::lexer::TokenAndSpan;\n \n fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n     fn id() -> token::Token {\n-        token::Ident(ast::Ident { name: Name(0), ctxt: 0, }, token::Plain)\n+        token::Ident(ast::Ident::with_empty_ctxt(Name(0))), token::Plain)\n     }\n \n     let mut res = HashMap::new();\n@@ -75,7 +75,7 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"RPAREN\"            => token::CloseDelim(token::Paren),\n             \"SLASH\"             => token::BinOp(token::Slash),\n             \"COMMA\"             => token::Comma,\n-            \"LIFETIME\"          => token::Lifetime(ast::Ident { name: Name(0), ctxt: 0 }),\n+            \"LIFETIME\"          => token::Lifetime(ast::Ident::with_empty_ctxt(Name(0))),\n             \"CARET\"             => token::BinOp(token::Caret),\n             \"TILDE\"             => token::Tilde,\n             \"IDENT\"             => id(),\n@@ -208,9 +208,9 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n         token::Literal(token::ByteStr(..), n)    => token::Literal(token::ByteStr(nm), n),\n         token::Literal(token::ByteStrRaw(..), n) => token::Literal(token::ByteStrRaw(fix(content),\n                                                                                 count(content)), n),\n-        token::Ident(..)           => token::Ident(ast::Ident { name: nm, ctxt: 0 },\n+        token::Ident(..)           => token::Ident(ast::Ident::with_empty_ctxt(nm)),\n                                                    token::ModName),\n-        token::Lifetime(..)        => token::Lifetime(ast::Ident { name: nm, ctxt: 0 }),\n+        token::Lifetime(..)        => token::Lifetime(ast::Ident::with_empty_ctxt(nm)),\n         ref t => t.clone()\n     };\n "}, {"sha": "9acd13f0a043906cc9e14e2e8a700705e00085e9", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -482,7 +482,7 @@ impl<'a> CrateReader<'a> {\n                 let span = mk_sp(lo, p.last_span.hi);\n                 p.abort_if_errors();\n                 macros.push(ast::MacroDef {\n-                    ident: name.ident(),\n+                    ident: ast::Ident::with_empty_ctxt(name),\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: span,"}, {"sha": "8addc06c8840db570a63db993846f2ecd619d9a8", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -520,9 +520,9 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n \n         if let hir::ItemImpl(..) = item.node {\n-            let (ident, did) = (item.name, item.id);\n+            let (name, did) = (item.name, item.id);\n             debug!(\"(encoding info for module) ... encoding impl {} ({}/{})\",\n-                   ident,\n+                   name,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(DefId::local(did)));"}, {"sha": "abc0429e7d29784ad21333cd194f8fe6d1fde7ca", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -184,8 +184,8 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             '[' => {\n                 let def = self.parse_def(RegionParameter);\n-                let ident = token::str_to_ident(&self.parse_str(']'));\n-                ty::BrNamed(def, ident.name)\n+                let name = token::intern(&self.parse_str(']'));\n+                ty::BrNamed(def, name)\n             }\n             'f' => {\n                 let id = self.parse_u32();\n@@ -219,12 +219,12 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n-                let nm = token::str_to_ident(&self.parse_str(']'));\n+                let name = token::intern(&self.parse_str(']'));\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n                     param_id: node_id,\n                     space: space,\n                     index: index,\n-                    name: nm.name\n+                    name: name\n                 })\n             }\n             'f' => {\n@@ -598,7 +598,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         ty::ProjectionPredicate {\n             projection_ty: ty::ProjectionTy {\n                 trait_ref: self.parse_trait_ref(),\n-                item_name: token::str_to_ident(&self.parse_str('|')).name,\n+                item_name: token::intern(&self.parse_str('|')),\n             },\n             ty: self.parse_ty(),\n         }"}, {"sha": "3b04dc3fb9b1a91399919b2c20918a6c736f3574", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -284,15 +284,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprBreak(label) => {\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label.map(|l| l.node.name));\n                 let b = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(label) => {\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label.map(|l| l.node.name));\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n@@ -585,7 +585,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn find_scope(&self,\n                   expr: &hir::Expr,\n-                  label: Option<ast::Ident>) -> LoopScope {\n+                  label: Option<ast::Name>) -> LoopScope {\n         if label.is_none() {\n             return *self.loop_scopes.last().unwrap();\n         }"}, {"sha": "caedc811842a0757cfc1a82a23e877f75fb3e65c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeIdent(_) | pprust::NodeName(_) => 0,\n+            pprust::NodeName(_) => 0,\n             pprust::NodeExpr(expr) => expr.id,\n             pprust::NodeBlock(blk) => blk.id,\n             pprust::NodeItem(_) | pprust::NodeSubItem(_) => 0,"}, {"sha": "3cfcb52f9030fd6ac152e6f453639a202734b378", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -85,7 +85,7 @@ fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.name == \"main\" {\n+            } else if item.name.as_str() == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "802b09a1a65e8394fea9503f912c468bda23cc14", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -1015,12 +1015,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             },\n             None => None\n         };\n-        let (fn_decl, generics, unsafety, constness, ident, expl_self, span)\n+        let (fn_decl, generics, unsafety, constness, name, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(&fn_decl, unsafety, constness, ident,\n+        self.give_expl_lifetime_param(&fn_decl, unsafety, constness, name,\n                                       expl_self.as_ref(), &generics, span);\n     }\n }\n@@ -1127,7 +1127,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(&names[0]).name;\n+            let name = token::intern(&names[0]);\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1938,8 +1938,7 @@ impl LifeGiver {\n             let mut s = String::from(\"'\");\n             s.push_str(&num_to_string(self.counter.get()));\n             if !self.taken.contains(&s) {\n-                lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(&s[..]).name);\n+                lifetime = name_to_dummy_lifetime(token::intern(&s[..]));\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "b3e287f6d7d5d7cf13e39ac7194dbe006093d130", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n             ty::TyBareFn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.tcx.item_name(def_id) == \"transmute\"\n+        intrinsic && self.tcx.item_name(def_id).as_str() == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {"}, {"sha": "f3a3b5369511b6f39f1f1158538a223aca1b5a20", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -383,7 +383,7 @@ fn visit_fn(ir: &mut IrMaps,\n                                &*arg.pat,\n                                |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n-            let name = path1.node.name;\n+            let name = path1.node;\n             fn_maps.add_variable(Arg(arg_id, name));\n         })\n     };\n@@ -416,7 +416,7 @@ fn visit_fn(ir: &mut IrMaps,\n fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n     pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n-        let name = path1.node.name;\n+        let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n         ir.add_variable(Local(LocalInfo {\n           id: p_id,\n@@ -431,7 +431,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n-            let name = path1.node.name;\n+            let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n             ir.add_variable(Local(LocalInfo {\n                 id: p_id,\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn find_loop_scope(&self,\n-                       opt_label: Option<ast::Ident>,\n+                       opt_label: Option<ast::Name>,\n                        id: NodeId,\n                        sp: Span)\n                        -> NodeId {\n@@ -1049,7 +1049,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprBreak(opt_label) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label.map(|l| l.node.name), expr.id, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1063,7 +1063,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label.map(|l| l.node.name), expr.id, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n@@ -1553,8 +1553,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                                    |_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n-                let ident = path1.node;\n-                if ident.name != special_idents::self_.name {\n+                let name = path1.node;\n+                if name != special_idents::self_.name {\n                     self.warn_about_unused(sp, p_id, entry_ln, var);\n                 }\n             })"}, {"sha": "0ffa5d7a5e338620849353c73df08bb178c75c08", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -16,9 +16,9 @@ use util::nodemap::FnvHashMap;\n use syntax::ast;\n use rustc_front::hir;\n use rustc_front::util::walk_pat;\n-use syntax::codemap::{Span, Spanned, DUMMY_SP};\n+use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n \n-pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n+pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n@@ -109,12 +109,26 @@ pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n+    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+{\n+    walk_pat(pat, |p| {\n+        match p.node {\n+          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n+            it(binding_mode, p.id, p.span, &respan(pth.span, pth.node.name));\n+          }\n+          _ => {}\n+        }\n+        true\n+    });\n+}\n+\n+pub fn pat_bindings_hygienic<I>(dm: &DefMap, pat: &hir::Pat, mut it: I) where\n     I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Ident>),\n {\n     walk_pat(pat, |p| {\n         match p.node {\n           hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n-            it(binding_mode, p.id, p.span, pth);\n+            it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n           }\n           _ => {}\n         }\n@@ -182,10 +196,10 @@ pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     contains_bindings\n }\n \n-pub fn simple_identifier<'a>(pat: &'a hir::Pat) -> Option<&'a ast::Ident> {\n+pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     match pat.node {\n         hir::PatIdent(hir::BindByValue(_), ref path1, None) => {\n-            Some(&path1.node)\n+            Some(path1.node.name)\n         }\n         _ => {\n             None\n@@ -197,7 +211,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n     tcx.with_path(id, |path| hir::Path {\n         global: false,\n         segments: path.last().map(|elem| hir::PathSegment {\n-            identifier: ast::Ident::new(elem.name()),\n+            identifier: ast::Ident::with_empty_ctxt(elem.name()),\n             parameters: hir::PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,"}, {"sha": "6fbdd90217658da22026411a8a14a6a95589dedb", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -73,7 +73,7 @@ struct LifetimeContext<'a> {\n     trait_ref_hack: bool,\n \n     // List of labels in the function/method currently under analysis.\n-    labels_in_fn: Vec<(ast::Ident, Span)>,\n+    labels_in_fn: Vec<(ast::Name, Span)>,\n }\n \n enum ScopeChain<'a> {\n@@ -381,7 +381,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n-        labels_in_fn: &'a mut Vec<(ast::Ident, Span)>,\n+        labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n     }\n \n     let mut gather = GatherLabels {\n@@ -403,9 +403,9 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n             if let Some(label) = expression_label(ex) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if label.name == prior.name {\n+                    if label == prior {\n                         signal_shadowing_problem(self.sess,\n-                                                 label.name,\n+                                                 label,\n                                                  original_label(prior_span),\n                                                  shadower_label(ex.span));\n                     }\n@@ -426,17 +426,17 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n         }\n     }\n \n-    fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n+    fn expression_label(ex: &hir::Expr) -> Option<ast::Name> {\n         match ex.node {\n             hir::ExprWhile(_, _, Some(label)) |\n-            hir::ExprLoop(_, Some(label)) => Some(label),\n+            hir::ExprLoop(_, Some(label)) => Some(label.name),\n             _ => None,\n         }\n     }\n \n     fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n                                            mut scope: Scope<'a>,\n-                                           label: ast::Ident,\n+                                           label: ast::Name,\n                                            label_span: Span) {\n         loop {\n             match *scope {\n@@ -447,10 +447,10 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n                 LateScope(lifetimes, s) => {\n                     for lifetime_def in lifetimes {\n                         // FIXME (#24278): non-hygienic comparison\n-                        if label.name == lifetime_def.lifetime.name {\n+                        if label == lifetime_def.lifetime.name {\n                             signal_shadowing_problem(\n                                 sess,\n-                                label.name,\n+                                label,\n                                 original_lifetime(&lifetime_def.lifetime),\n                                 shadower_label(label_span));\n                             return;\n@@ -703,7 +703,7 @@ impl<'a> LifetimeContext<'a> {\n     {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n-            if lifetime.name == label.name {\n+            if lifetime.name == label {\n                 signal_shadowing_problem(self.sess,\n                                          lifetime.name,\n                                          original_label(label_span),"}, {"sha": "596686f32cbc33a8282fd8352e484f869af05ac5", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.name.as_str() == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));"}, {"sha": "83fac73b7f9dfd86b2232a7dd75fa457c59f13a7", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -99,7 +99,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let pat_span_path_opt = match move_pat.node {\n         hir::PatIdent(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n-                                 ident: path1.node})\n+                                 name: path1.node.name})\n         },\n         _ => None,\n     };"}, {"sha": "59f914895ae59e34183a7a7622ccfe4a792d2a51", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -15,7 +15,6 @@ use rustc::middle::ty;\n use std::cell::RefCell;\n use syntax::ast;\n use syntax::codemap;\n-use rustc_front::print::pprust;\n use rustc_front::hir;\n \n pub struct MoveErrorCollector<'tcx> {\n@@ -57,7 +56,7 @@ impl<'tcx> MoveError<'tcx> {\n #[derive(Clone)]\n pub struct MoveSpanAndPath {\n     pub span: codemap::Span,\n-    pub ident: ast::Ident\n+    pub name: ast::Name,\n }\n \n pub struct GroupedMoveErrors<'tcx> {\n@@ -73,7 +72,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         let mut is_first_note = true;\n         for move_to in &error.move_to_places {\n             note_move_destination(bccx, move_to.span,\n-                                  &move_to.ident, is_first_note);\n+                                  move_to.name, is_first_note);\n             is_first_note = false;\n         }\n     }\n@@ -157,9 +156,8 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n fn note_move_destination(bccx: &BorrowckCtxt,\n                          move_to_span: codemap::Span,\n-                         pat_ident: &ast::Ident,\n+                         pat_name: ast::Name,\n                          is_first_note: bool) {\n-    let pat_name = pprust::ident_to_string(pat_ident);\n     if is_first_note {\n         bccx.span_note(\n             move_to_span,"}, {"sha": "f0fa1ff70c6f398dc55581fb712fa082cc60c3ac", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -330,8 +330,7 @@ impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n             s: &mut pprust_hir::State,\n             node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust_hir::NodeIdent(_) | pprust_hir::NodeName(_) => Ok(()),\n-\n+            pprust_hir::NodeName(_) => Ok(()),\n             pprust_hir::NodeItem(item) => {\n                 try!(pp::space(&mut s.s));\n                 s.synth_comment(item.id.to_string())\n@@ -381,7 +380,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n                 try!(pp::space(&mut s.s));\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}#{}\", nm, ctxt))\n+                s.synth_comment(format!(\"{}#{}\", nm, ctxt.0))\n             }\n             pprust::NodeName(&ast::Name(nm)) => {\n                 try!(pp::space(&mut s.s));"}, {"sha": "7ae68894f1cb9c89c74efe61416e351a2b834856", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -296,8 +296,8 @@ pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T\n pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n     view_path.map(|Spanned {node, span}| Spanned {\n         node: match node {\n-            ViewPathSimple(ident, path) => {\n-                ViewPathSimple(ident, fld.fold_path(path))\n+            ViewPathSimple(name, path) => {\n+                ViewPathSimple(name, fld.fold_path(path))\n             }\n             ViewPathGlob(path) => {\n                 ViewPathGlob(fld.fold_path(path))\n@@ -520,11 +520,11 @@ pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mu\n                                                      -> ExplicitSelf_ {\n     match es {\n         SelfStatic | SelfValue(_) => es,\n-        SelfRegion(lifetime, m, ident) => {\n-            SelfRegion(fld.fold_opt_lifetime(lifetime), m, ident)\n+        SelfRegion(lifetime, m, name) => {\n+            SelfRegion(fld.fold_opt_lifetime(lifetime), m, name)\n         }\n-        SelfExplicit(typ, ident) => {\n-            SelfExplicit(fld.fold_ty(typ), ident)\n+        SelfExplicit(typ, name) => {\n+            SelfExplicit(fld.fold_ty(typ), name)\n         }\n     }\n }\n@@ -1111,10 +1111,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                           respan(folder.new_span(name.span),\n                                  folder.fold_name(name.node)))\n             }\n-            ExprTupField(el, ident) => {\n+            ExprTupField(el, index) => {\n                 ExprTupField(folder.fold_expr(el),\n-                             respan(folder.new_span(ident.span),\n-                                    folder.fold_usize(ident.node)))\n+                             respan(folder.new_span(index.span),\n+                                    folder.fold_usize(index.node)))\n             }\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))"}, {"sha": "49107edb9d3cd3c8953ca11421162f83cab7bd61", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -629,15 +629,13 @@ pub enum Expr_ {\n     ///\n     /// `if expr { block } else { expr }`\n     ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind."}, {"sha": "36916967fcb3b9c3d4dbb41fb5b4c95cd9dd92fe", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -30,7 +30,6 @@ use hir::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use std::io::{self, Write, Read};\n \n pub enum AnnNode<'a> {\n-    NodeIdent(&'a ast::Ident),\n     NodeName(&'a ast::Name),\n     NodeBlock(&'a hir::Block),\n     NodeItem(&'a hir::Item),\n@@ -264,8 +263,8 @@ pub fn path_to_string(p: &hir::Path) -> String {\n     to_string(|s| s.print_path(p, false, 0))\n }\n \n-pub fn ident_to_string(id: &ast::Ident) -> String {\n-    to_string(|s| s.print_ident(*id))\n+pub fn name_to_string(name: ast::Name) -> String {\n+    to_string(|s| s.print_name(name))\n }\n \n pub fn fun_to_string(decl: &hir::FnDecl,\n@@ -1346,7 +1345,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprWhile(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    try!(self.print_ident(ident));\n+                    try!(self.print_name(ident.name));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while\"));\n@@ -1356,7 +1355,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprLoop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    try!(self.print_ident(ident));\n+                    try!(self.print_name(ident.name));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"loop\"));\n@@ -1461,15 +1460,15 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n-                    try!(self.print_ident(ident.node));\n+                    try!(self.print_name(ident.node.name));\n                     try!(space(&mut self.s));\n                 }\n             }\n             hir::ExprAgain(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n-                    try!(self.print_ident(ident.node));\n+                    try!(self.print_name(ident.node.name));\n                     try!(space(&mut self.s))\n                 }\n             }\n@@ -1582,11 +1581,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n-        try!(word(&mut self.s, &ident.name.as_str()));\n-        self.ann.post(self, NodeIdent(&ident))\n-    }\n-\n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n         word(&mut self.s, &i.to_string())\n     }\n@@ -1620,7 +1614,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"::\"))\n             }\n \n-            try!(self.print_ident(segment.identifier));\n+            try!(self.print_name(segment.identifier.name));\n \n             try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n         }\n@@ -1645,7 +1639,7 @@ impl<'a> State<'a> {\n         try!(word(&mut self.s, \">\"));\n         try!(word(&mut self.s, \"::\"));\n         let item_segment = path.segments.last().unwrap();\n-        try!(self.print_ident(item_segment.identifier));\n+        try!(self.print_name(item_segment.identifier.name));\n         self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }\n \n@@ -1741,7 +1735,7 @@ impl<'a> State<'a> {\n                         try!(self.word_nbsp(\"mut\"));\n                     }\n                 }\n-                try!(self.print_ident(path1.node));\n+                try!(self.print_name(path1.node.name));\n                 match *sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n@@ -2168,7 +2162,6 @@ impl<'a> State<'a> {\n             hir::ViewPathSimple(name, ref path) => {\n                 try!(self.print_path(path, false, 0));\n \n-                // FIXME(#6993) can't compare identifiers directly here\n                 if path.segments.last().unwrap().identifier.name != name {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"as\"));\n@@ -2183,14 +2176,14 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \"::*\")\n             }\n \n-            hir::ViewPathList(ref path, ref idents) => {\n+            hir::ViewPathList(ref path, ref segments) => {\n                 if path.segments.is_empty() {\n                     try!(word(&mut self.s, \"{\"));\n                 } else {\n                     try!(self.print_path(path, false, 0));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n-                try!(self.commasep(Inconsistent, &idents[..], |s, w| {\n+                try!(self.commasep(Inconsistent, &segments[..], |s, w| {\n                     match w.node {\n                         hir::PathListIdent { name, .. } => {\n                             s.print_name(name)\n@@ -2268,7 +2261,7 @@ impl<'a> State<'a> {\n                        abi: abi::Abi,\n                        unsafety: hir::Unsafety,\n                        decl: &hir::FnDecl,\n-                       name: Option<ast::Ident>,\n+                       name: Option<ast::Name>,\n                        generics: &hir::Generics,\n                        opt_explicit_self: Option<&hir::ExplicitSelf_>)\n                        -> io::Result<()> {\n@@ -2289,7 +2282,7 @@ impl<'a> State<'a> {\n                            unsafety,\n                            hir::Constness::NotConst,\n                            abi,\n-                           name.map(|x| x.name),\n+                           name,\n                            &generics,\n                            opt_explicit_self,\n                            hir::Inherited));"}, {"sha": "c2382a92ec723732b7b1e0bf66fcf24c90431379", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -354,13 +354,13 @@ pub fn empty_generics() -> Generics {\n \n // convert a span and an identifier to the corresponding\n // 1-segment path\n-pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n+pub fn ident_to_path(s: Span, ident: Ident) -> Path {\n     hir::Path {\n         span: s,\n         global: false,\n         segments: vec!(\n             hir::PathSegment {\n-                identifier: identifier,\n+                identifier: ident,\n                 parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n                     lifetimes: Vec::new(),\n                     types: OwnedSlice::empty(),"}, {"sha": "d12cd082cab7e587de08c867ada749e4ac16c3a4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -761,9 +761,6 @@ impl LintPass for UnconditionalRecursion {\n impl LateLintPass for UnconditionalRecursion {\n     fn check_fn(&mut self, cx: &LateContext, fn_kind: FnKind, _: &hir::FnDecl,\n                 blk: &hir::Block, sp: Span, id: ast::NodeId) {\n-        type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n-                              ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n-\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {"}, {"sha": "dca4a81c56feb08e31b093a97baa2db7f68474f3", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -47,10 +47,10 @@ impl UnusedMut {\n         let mut mutables = FnvHashMap();\n         for p in pats {\n             pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n-                let ident = path1.node;\n+                let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n-                    if !ident.name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(ident.name.usize()) {\n+                    if !name.as_str().starts_with(\"_\") {\n+                        match mutables.entry(name.0 as usize) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }"}, {"sha": "2ff57a187123d8eb4d8e6f6e00c34f4821f3751c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -199,7 +199,7 @@ struct Candidate<H:Hair> {\n struct Binding<H:Hair> {\n     span: H::Span,\n     source: Lvalue<H>,\n-    name: H::Ident,\n+    name: H::Name,\n     var_id: H::VarId,\n     var_ty: H::Ty,\n     mutability: Mutability,\n@@ -376,7 +376,7 @@ impl<H:Hair> Builder<H> {\n     fn declare_binding(&mut self,\n                        var_extent: H::CodeExtent,\n                        mutability: Mutability,\n-                       name: H::Ident,\n+                       name: H::Name,\n                        var_id: H::VarId,\n                        var_ty: H::Ty,\n                        span: H::Span)"}, {"sha": "cb094ad49055f010bd83e9bfa9f08d96f0a6ffb9", "filename": "src/librustc_mir/hair.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -29,7 +29,6 @@ pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n     type DefId: Copy+Debug+Eq+Hash;                              // e.g., DefId\n     type AdtDef: Copy+Debug+Eq+Hash;                             // e.g., AdtDef<'tcx>\n     type Name: Copy+Debug+Eq+Hash;                               // e.g., ast::Name\n-    type Ident: Copy+Debug+Eq+Hash;                              // e.g., ast::Ident\n     type InternedString: Clone+Debug+Eq+Hash;                    // e.g., InternedString\n     type Bytes: Clone+Debug+Eq+Hash;                             // e.g., Rc<Vec<u8>>\n     type Span: Copy+Debug+Eq;                                    // e.g., syntax::codemap::Span\n@@ -248,7 +247,7 @@ pub enum PatternKind<H:Hair> {\n \n     // x, ref x, x @ P, etc\n     Binding { mutability: Mutability,\n-              name: H::Ident,\n+              name: H::Name,\n               mode: BindingMode<H>,\n               var: H::VarId,\n               ty: H::Ty,"}, {"sha": "a1b891ab090867ffe421ac2cb10c73e3561d15db", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -113,7 +113,7 @@ pub enum BorrowKind {\n // decl, a let, etc.\n pub struct VarDecl<H:Hair> {\n     pub mutability: Mutability,\n-    pub name: H::Ident,\n+    pub name: H::Name,\n     pub ty: H::Ty,\n }\n "}, {"sha": "6c9713b003b64555d4eb345c6c901a354c95586d", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -286,9 +286,9 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n             hir::ExprField(ref source, name) =>\n                 ExprKind::Field { lhs: source.to_ref(),\n                                   name: Field::Named(name.node) },\n-            hir::ExprTupField(ref source, ident) =>\n+            hir::ExprTupField(ref source, index) =>\n                 ExprKind::Field { lhs: source.to_ref(),\n-                                  name: Field::Indexed(ident.node) },\n+                                  name: Field::Indexed(index.node) },\n             hir::ExprCast(ref source, _) =>\n                 ExprKind::Cast { source: source.to_ref() },\n             hir::ExprBox(ref value) =>"}, {"sha": "9c0ef55b3d83acf4f4e329ef426d4963b9b0c80e", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -47,7 +47,6 @@ impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n     type DefId = DefId;\n     type AdtDef = ty::AdtDef<'tcx>;\n     type Name = ast::Name;\n-    type Ident = ast::Ident;\n     type InternedString = InternedString;\n     type Bytes = Rc<Vec<u8>>;\n     type Span = Span;"}, {"sha": "d80fbfa7fe89702a60b353a44207436893ba4625", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -39,12 +39,12 @@ use tcx::to_ref::ToRef;\n #[derive(Clone, Debug)]\n pub struct PatNode<'tcx> {\n     pat: &'tcx hir::Pat,\n-    binding_map: Option<Rc<FnvHashMap<ast::Ident, ast::NodeId>>>\n+    binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>\n }\n \n impl<'tcx> PatNode<'tcx> {\n     pub fn new(pat: &'tcx hir::Pat,\n-               binding_map: Option<Rc<FnvHashMap<ast::Ident, ast::NodeId>>>)\n+               binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>)\n                -> PatNode<'tcx> {\n         PatNode {\n             pat: pat,\n@@ -220,7 +220,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for PatNode<'tcx> {\n             {\n                 let id = match self.binding_map {\n                     None => self.pat.id,\n-                    Some(ref map) => map[&ident.node],\n+                    Some(ref map) => map[&ident.node.name],\n                 };\n                 let var_ty = cx.tcx.node_id_to_type(self.pat.id);\n                 let region = match var_ty.sty {\n@@ -240,7 +240,7 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for PatNode<'tcx> {\n                 PatternKind::Binding {\n                     mutability: mutability,\n                     mode: mode,\n-                    name: ident.node,\n+                    name: ident.node.name,\n                     var: id,\n                     ty: var_ty,\n                     subpattern: self.opt_pat_ref(sub),"}, {"sha": "cf964107d16b38e201fb933e3d8418380efe356f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -392,7 +392,6 @@ enum PrivacyResult {\n \n enum FieldName {\n     UnnamedField(usize), // index\n-    // (Name, not Ident, because struct fields are not macro-hygienic)\n     NamedField(ast::Name),\n }\n "}, {"sha": "8a15eabd61419700d60ec6d48a1741acf8ae0aa9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -281,14 +281,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     ViewPathSimple(_, ref full_path) => {\n                         full_path.segments\n                             .split_last().unwrap().1\n-                            .iter().map(|ident| ident.identifier.name)\n+                            .iter().map(|seg| seg.identifier.name)\n                             .collect()\n                     }\n \n                     ViewPathGlob(ref module_ident_path) |\n                     ViewPathList(ref module_ident_path, _) => {\n                         module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier.name).collect()\n+                            .iter().map(|seg| seg.identifier.name).collect()\n                     }\n                 };\n "}, {"sha": "c61f75723c7bd937c13e7d8f0e3fc72ab3a2ca24", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -57,7 +57,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::pat_util::pat_bindings;\n+use rustc::middle::pat_util::pat_bindings_hygienic;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n@@ -2559,7 +2559,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut result = HashMap::new();\n-        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n+        pat_bindings_hygienic(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n             let name = mtwt::resolve(path1.node);\n             result.insert(name, BindingInfo {\n                 span: sp,\n@@ -3710,7 +3710,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope && special_names::self_ == path_name {\n+                            if method_scope && special_names::self_.as_str() == &path_name[..] {\n                                 resolve_error(\n                                     self,\n                                     expr.span,"}, {"sha": "99d7685f7c8f290dbd770a4685fdecdfb172f3f7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -537,7 +537,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         fn get_binding(this: &mut Resolver,\n                                        import_resolution: &ImportResolution,\n                                        namespace: Namespace,\n-                                       source: &Name)\n+                                       source: Name)\n                                     -> NamespaceResult {\n \n                             // Import resolutions must be declared with \"pub\"\n@@ -560,7 +560,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n-                                    this.record_import_use(id, *source);\n+                                    this.record_import_use(id, source);\n                                     match target_module.def_id.get() {\n                                         Some(DefId{krate: kid, ..}) => {\n                                             this.used_crates.insert(kid);\n@@ -578,14 +578,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             value_result = get_binding(self.resolver,\n                                                        import_resolution,\n                                                        ValueNS,\n-                                                       &source);\n+                                                       source);\n                             value_used_reexport = import_resolution.is_public;\n                         }\n                         if type_result.is_unknown() {\n                             type_result = get_binding(self.resolver,\n                                                       import_resolution,\n                                                       TypeNS,\n-                                                      &source);\n+                                                      source);\n                             type_used_reexport = import_resolution.is_public;\n                         }\n \n@@ -793,10 +793,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     )));\n         }\n \n-        for (ident, target_import_resolution) in import_resolutions.iter() {\n+        for (name, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n-                   *ident,\n+                   *name,\n                    module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n@@ -806,7 +806,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             // Here we merge two import resolutions.\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            match import_resolutions.get_mut(ident) {\n+            match import_resolutions.get_mut(name) {\n                 Some(dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n@@ -818,7 +818,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         Some(ref value_target) => {\n                             self.check_for_conflicting_import(&dest_import_resolution,\n                                                               import_directive.span,\n-                                                              *ident,\n+                                                              *name,\n                                                               ValueNS);\n                             dest_import_resolution.value_target = Some(value_target.clone());\n                         }\n@@ -830,7 +830,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         Some(ref type_target) => {\n                             self.check_for_conflicting_import(&dest_import_resolution,\n                                                               import_directive.span,\n-                                                              *ident,\n+                                                              *name,\n                                                               TypeNS);\n                             dest_import_resolution.type_target = Some(type_target.clone());\n                         }\n@@ -848,7 +848,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             new_import_resolution.type_target =\n                 target_import_resolution.type_target.clone();\n \n-            import_resolutions.insert(*ident, new_import_resolution);\n+            import_resolutions.insert(*name, new_import_resolution);\n         }\n \n         // Add all children from the containing module."}, {"sha": "f25429ee904693becb24f525214fa5686b6f7976", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -444,7 +444,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     fn process_const(&mut self,\n                      id: ast::NodeId,\n-                     ident: &ast::Ident,\n+                     name: ast::Name,\n                      span: Span,\n                      typ: &ast::Ty,\n                      expr: &ast::Expr) {\n@@ -456,7 +456,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         self.fmt.static_str(span,\n                             sub_span,\n                             id,\n-                            &ident.name.as_str(),\n+                            &name.as_str(),\n                             &qualname,\n                             &self.span.snippet(expr.span),\n                             &ty_to_string(&*typ),\n@@ -988,7 +988,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n             ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                self.process_const(trait_item.id, &trait_item.ident,\n+                self.process_const(trait_item.id, trait_item.ident.name,\n                                    trait_item.span, &*ty, &*expr);\n             }\n             ast::MethodTraitItem(ref sig, ref body) => {\n@@ -1006,7 +1006,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n             ast::ConstImplItem(ref ty, ref expr) => {\n-                self.process_const(impl_item.id, &impl_item.ident,\n+                self.process_const(impl_item.id, impl_item.ident.name,\n                                    impl_item.span, &ty, &expr);\n             }\n             ast::MethodImplItem(ref sig, ref body) => {"}, {"sha": "cdc102b2e7a0921ab17565e88c9d7e5fdbf3a007", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -375,7 +375,7 @@ pub struct BindingInfo<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-type BindingsMap<'tcx> = FnvHashMap<ast::Ident, BindingInfo<'tcx>>;\n+type BindingsMap<'tcx> = FnvHashMap<ast::Name, BindingInfo<'tcx>>;\n \n struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bodycx: Block<'blk, 'tcx>,\n@@ -390,7 +390,7 @@ struct ArmData<'p, 'blk, 'tcx: 'blk> {\n struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p hir::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n-    bound_ptrs: Vec<(ast::Ident, ValueRef)>,\n+    bound_ptrs: Vec<(ast::Name, ValueRef)>,\n     // Thread along renamings done by the check_match::StaticInliner, so we can\n     // map back to original NodeIds\n     pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n@@ -464,7 +464,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         loop {\n             pat = match pat.node {\n                 hir::PatIdent(_, ref path, Some(ref inner)) => {\n-                    bound_ptrs.push((path.node, val.val));\n+                    bound_ptrs.push((path.node.name, val.val));\n                     &**inner\n                 },\n                 _ => break\n@@ -505,15 +505,15 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             match this.node {\n                 hir::PatIdent(_, ref path, None) => {\n                     if pat_is_binding(dm, &*this) {\n-                        bound_ptrs.push((path.node, val.val));\n+                        bound_ptrs.push((path.node.name, val.val));\n                     }\n                 }\n                 hir::PatVec(ref before, Some(ref slice), ref after) => {\n                     if let hir::PatIdent(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n-                        bound_ptrs.push((path.node, subslice_val));\n+                        bound_ptrs.push((path.node.name, subslice_val));\n                     }\n                 }\n                 _ => {}\n@@ -943,7 +943,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                bindings_map: &BindingsMap<'tcx>,\n                                cs: Option<cleanup::ScopeId>)\n                                -> Block<'blk, 'tcx> {\n-    for (&ident, &binding_info) in bindings_map {\n+    for (&name, &binding_info) in bindings_map {\n         let (llval, aliases_other_state) = match binding_info.trmode {\n             // By value mut binding for a copy type: load from the ptr\n             // into the matched value and copy to our alloca\n@@ -1021,7 +1021,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n-        debuginfo::create_match_binding_metadata(bcx, ident.name, binding_info);\n+        debuginfo::create_match_binding_metadata(bcx, name, binding_info);\n     }\n     bcx\n }\n@@ -1510,8 +1510,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = FnvHashMap();\n     pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n-        let ident = path1.node;\n-        let name = ident.name;\n+        let name = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();\n@@ -1543,7 +1542,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n                 trmode = TrByRef;\n             }\n         };\n-        bindings_map.insert(ident, BindingInfo {\n+        bindings_map.insert(name, BindingInfo {\n             llmatch: llmatch,\n             trmode: trmode,\n             id: p_id,\n@@ -1656,7 +1655,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n-                bcx, p_id, path1.node.name, scope, (),\n+                bcx, p_id, path1.node, scope, (),\n                 \"_match::store_local::create_dummy_locals\",\n                 |(), bcx, Datum { val: llval, ty, kind }| {\n                     // Dummy-locals start out uninitialized, so set their\n@@ -1693,11 +1692,11 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             //\n             // In such cases, the more general path is unsafe, because\n             // it assumes it is matching against a valid value.\n-            match simple_identifier(&*pat) {\n-                Some(ident) => {\n+            match simple_name(pat) {\n+                Some(name) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n-                        bcx, pat.id, ident.name, var_scope, (),\n+                        bcx, pat.id, name, var_scope, (),\n                         \"_match::store_local\",\n                         |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &**init_expr,\n                                                                          expr::SaveIn(v)));"}, {"sha": "894e0af9cce6b0293cb86b911d305ae6a986d0de", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -40,7 +40,7 @@ use middle::cfg;\n use middle::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n-use middle::pat_util::simple_identifier;\n+use middle::pat_util::simple_name;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::front::map as hir_map;\n@@ -1447,10 +1447,10 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n         };\n \n         let pat = &*args[i].pat;\n-        bcx = if let Some(ident) = simple_identifier(&*pat) {\n+        bcx = if let Some(name) = simple_name(pat) {\n             // Generate nicer LLVM for the common case of fn a pattern\n             // like `x: T`\n-            set_value_name(arg_datum.val, &bcx.name(ident.name));\n+            set_value_name(arg_datum.val, &bcx.name(name));\n             bcx.fcx.lllocals.borrow_mut().insert(pat.id, arg_datum);\n             bcx\n         } else {"}, {"sha": "78f631371c093f980070834ec7acffef13dbe3cd", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -168,7 +168,7 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> PathElem {\n-    let num = token::gensym(name).usize();\n+    let num = token::gensym(name).0;\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n     PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n@@ -829,7 +829,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let sym = format!(\"str{}\", gsym.usize());\n+        let sym = format!(\"str{}\", gsym.0);\n         let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n             cx.sess().bug(&format!(\"symbol `{}` is already defined\", sym));\n         });"}, {"sha": "5988f95aedf6c35c9c398ea0fefedc2447636f30", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -116,7 +116,7 @@ fn addr_of_mut(ccx: &CrateContext,\n         // FIXME: this totally needs a better name generation scheme, perhaps a simple global\n         // counter? Also most other uses of gensym in trans.\n         let gsym = token::gensym(\"_\");\n-        let name = format!(\"{}{}\", kind, gsym.usize());\n+        let name = format!(\"{}{}\", kind, gsym.0);\n         let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n             ccx.sess().bug(&format!(\"symbol `{}` is already defined\", name));\n         });"}, {"sha": "875eb353cf7e349bf341289e045e6d7e662eb965", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -305,7 +305,7 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     expr: &hir::Expr,\n-                                    opt_label: Option<ast::Ident>,\n+                                    opt_label: Option<ast::Name>,\n                                     exit: usize)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n@@ -338,14 +338,14 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &hir::Expr,\n-                               label_opt: Option<ast::Ident>)\n+                               label_opt: Option<ast::Name>)\n                                -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_BREAK);\n }\n \n pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               expr: &hir::Expr,\n-                              label_opt: Option<ast::Ident>)\n+                              label_opt: Option<ast::Name>)\n                               -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_LOOP);\n }"}, {"sha": "7597d5f92aec05b6128c5e7e4f82f600e31a4b0e", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -49,7 +49,7 @@ pub fn create_scope_map(cx: &CrateContext,\n     for arg in args {\n         pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               name: Some(path1.node.name) });\n+                                               name: Some(path1.node) });\n             scope_map.insert(node_id, fn_metadata);\n         })\n     }"}, {"sha": "1d35b51a5f81c086ca98c354dc04b0138fefcd18", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -1925,7 +1925,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n     let def_map = &cx.tcx().def_map;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n@@ -1943,7 +1943,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident.node.name,\n+                      var_name.node,\n                       datum.ty,\n                       scope_metadata,\n                       VariableAccess::DirectVariable { alloca: datum.val },\n@@ -2105,7 +2105,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n                          .fn_metadata;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {\n@@ -2132,7 +2132,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n         };\n \n         declare_local(bcx,\n-                      var_ident.node.name,\n+                      var_name.node,\n                       datum.ty,\n                       scope_metadata,\n                       VariableAccess::DirectVariable { alloca: datum.val },"}, {"sha": "722089e42f9be42aa9056af04e06e87e966e9599", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -963,10 +963,10 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match expr.node {\n         hir::ExprBreak(label_opt) => {\n-            controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node))\n+            controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node.name))\n         }\n         hir::ExprAgain(label_opt) => {\n-            controlflow::trans_cont(bcx, expr, label_opt.map(|l| l.node))\n+            controlflow::trans_cont(bcx, expr, label_opt.map(|l| l.node.name))\n         }\n         hir::ExprRet(ref ex) => {\n             // Check to see if the return expression itself is reachable.\n@@ -1114,7 +1114,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // trans. Shudder.\n             fn make_field(field_name: &str, expr: P<hir::Expr>) -> hir::Field {\n                 hir::Field {\n-                    name: codemap::dummy_spanned(token::str_to_ident(field_name).name),\n+                    name: codemap::dummy_spanned(token::intern(field_name)),\n                     expr: expr,\n                     span: codemap::DUMMY_SP,\n                 }"}, {"sha": "546e337d746d992a7dcbcd743e9b45e19ecc7a21", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -179,7 +179,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = *pcx.map.get(&path.node).unwrap();\n+            let canon_id = *pcx.map.get(&path.node.name).unwrap();\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n                 demand::eqtype(fcx, pat.span, ct, typ);"}, {"sha": "419fb7aea6c6e436bd44f5b2f91814d8d883511f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -682,7 +682,7 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n }\n \n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n-    debug!(\"check_item_type(it.id={}, it.ident={})\",\n+    debug!(\"check_item_type(it.id={}, it.name={})\",\n            it.id,\n            ccx.tcx.item_path_str(DefId::local(it.id)));\n     let _indenter = indenter();\n@@ -750,7 +750,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n }\n \n pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n-    debug!(\"check_item_body(it.id={}, it.ident={})\",\n+    debug!(\"check_item_body(it.id={}, it.name={})\",\n            it.id,\n            ccx.tcx.item_path_str(DefId::local(it.id)));\n     let _indenter = indenter();\n@@ -838,7 +838,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n                         Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.name == s\n+                            t.name.as_str() == s\n                         }) {\n                             Some(_) => (),\n                             None => {"}, {"sha": "70983b89ed5c820af31228e032d26fc829e4ec27", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -55,7 +55,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     /// the types first.\n     fn check_item_well_formed(&mut self, item: &hir::Item) {\n         let ccx = self.ccx;\n-        debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n+        debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n                ccx.tcx.item_path_str(DefId::local(item.id)));\n "}, {"sha": "2c6879891b1c909929adfbfc562508dbb9d21966", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -61,7 +61,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     /// the types first.\n     fn check_item_well_formed(&mut self, item: &hir::Item) {\n         let ccx = self.ccx;\n-        debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n+        debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n                ccx.tcx.item_path_str(DefId::local(item.id)));\n "}, {"sha": "9e1b20258f07b05d68135178a1dda0dd246aac63", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -699,12 +699,12 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n            rcvr_ty_generics,\n            rcvr_ty_predicates);\n \n-    for (sig, id, ident, vis, _span) in methods {\n+    for (sig, id, name, vis, _span) in methods {\n         convert_method(ccx,\n                        container,\n                        sig,\n                        id,\n-                       ident,\n+                       name,\n                        vis,\n                        untransformed_rcvr_ty,\n                        rcvr_ty_generics,"}, {"sha": "89020b011a955b4a2f727974dbcadc7e68d2196e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -1583,7 +1583,7 @@ impl Clean<Type> for hir::Ty {\n                 let mut trait_path = p.clone();\n                 trait_path.segments.pop();\n                 Type::QPath {\n-                    name: p.segments.last().unwrap().identifier.clean(cx),\n+                    name: p.segments.last().unwrap().identifier.name.clean(cx),\n                     self_type: box qself.ty.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -2044,7 +2044,7 @@ pub struct PathSegment {\n impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n-            name: self.identifier.clean(cx),\n+            name: self.identifier.name.clean(cx),\n             params: self.parameters.clean(cx)\n         }\n     }\n@@ -2064,12 +2064,6 @@ fn path_to_string(p: &hir::Path) -> String {\n     s\n }\n \n-impl Clean<String> for ast::Ident {\n-    fn clean(&self, _: &DocContext) -> String {\n-        self.to_string()\n-    }\n-}\n-\n impl Clean<String> for ast::Name {\n     fn clean(&self, _: &DocContext) -> String {\n         self.to_string()"}, {"sha": "75a976296489565aaa6e54e8f0c45c43deae4418", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 51, "deletions": 88, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -67,46 +67,67 @@ use std::fmt;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-// FIXME #6993: in librustc, uses of \"ident\" should be replaced\n-// by just \"Name\".\n+/// A name is a part of an identifier, representing a string or gensym. It's\n+/// the result of interning.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Name(pub u32);\n+\n+/// A SyntaxContext represents a chain of macro-expandings\n+/// and renamings. Each macro expansion corresponds to\n+/// a fresh u32. This u32 is a reference to a table stored\n+// in thread-local storage.\n+// The special value EMPTY_CTXT is used to indicate an empty\n+// syntax context.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct SyntaxContext(pub u32);\n \n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n-/// macro expansion per Flatt et al., \"Macros\n-/// That Work Together\"\n-#[derive(Clone, Copy, Hash, PartialOrd, Eq, Ord)]\n+/// macro expansion per Flatt et al., \"Macros That Work Together\"\n+#[derive(Clone, Copy, Eq, Hash)]\n pub struct Ident {\n     pub name: Name,\n     pub ctxt: SyntaxContext\n }\n \n-impl Ident {\n-    /// Construct an identifier with the given name and an empty context:\n-    pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: EMPTY_CTXT}}\n+impl Name {\n+    pub fn as_str(self) -> token::InternedString {\n+        token::InternedString::new_from_name(self)\n+    }\n }\n \n-impl fmt::Debug for Ident {\n+impl fmt::Debug for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}#{}\", self.name, self.ctxt)\n+        write!(f, \"{}({})\", self, self.0)\n     }\n }\n \n-impl fmt::Display for Ident {\n+impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.name, f)\n+        fmt::Display::fmt(&self.as_str(), f)\n     }\n }\n \n-impl fmt::Debug for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Name(nm) = *self;\n-        write!(f, \"{}({})\", self, nm)\n+impl Encodable for Name {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.as_str())\n     }\n }\n \n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.as_str(), f)\n+impl Decodable for Name {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n+        Ok(token::intern(&try!(d.read_str())[..]))\n+    }\n+}\n+\n+pub const EMPTY_CTXT : SyntaxContext = SyntaxContext(0);\n+\n+impl Ident {\n+    pub fn new(name: Name, ctxt: SyntaxContext) -> Ident {\n+        Ident {name: name, ctxt: ctxt}\n+    }\n+    pub fn with_empty_ctxt(name: Name) -> Ident {\n+        Ident {name: name, ctxt: EMPTY_CTXT}\n     }\n }\n \n@@ -119,74 +140,27 @@ impl PartialEq for Ident {\n             // idents that have different contexts. You can't fix this without\n             // knowing whether the comparison should be hygienic or non-hygienic.\n             // if it should be non-hygienic (most things are), just compare the\n-            // 'name' fields of the idents. Or, even better, replace the idents\n-            // with Name's.\n+            // 'name' fields of the idents.\n             //\n             // On the other hand, if the comparison does need to be hygienic,\n             // one example and its non-hygienic counterpart would be:\n             //      syntax::parse::token::Token::mtwt_eq\n             //      syntax::ext::tt::macro_parser::token_name_eq\n-            panic!(\"not allowed to compare these idents: {:?}, {:?}. \\\n-                   Probably related to issue \\\\#6993\", self, other);\n+            panic!(\"idents with different contexts are compared with operator `==`: \\\n+                {:?}, {:?}.\", self, other);\n         }\n     }\n }\n \n-/// A SyntaxContext represents a chain of macro-expandings\n-/// and renamings. Each macro expansion corresponds to\n-/// a fresh u32\n-\n-// I'm representing this syntax context as an index into\n-// a table, in order to work around a compiler bug\n-// that's causing unreleased memory to cause core dumps\n-// and also perhaps to save some work in destructor checks.\n-// the special uint '0' will be used to indicate an empty\n-// syntax context.\n-\n-// this uint is a reference to a table stored in thread-local\n-// storage.\n-pub type SyntaxContext = u32;\n-pub const EMPTY_CTXT : SyntaxContext = 0;\n-pub const ILLEGAL_CTXT : SyntaxContext = 1;\n-\n-/// A name is a part of an identifier, representing a string or gensym. It's\n-/// the result of interning.\n-#[derive(Eq, Ord, PartialEq, PartialOrd, Hash, Clone, Copy)]\n-pub struct Name(pub u32);\n-\n-impl<T: AsRef<str>> PartialEq<T> for Name {\n-    fn eq(&self, other: &T) -> bool {\n-        self.as_str() == other.as_ref()\n-    }\n-}\n-\n-impl Name {\n-    pub fn as_str(&self) -> token::InternedString {\n-        token::InternedString::new_from_name(*self)\n-    }\n-\n-    pub fn usize(&self) -> usize {\n-        let Name(nm) = *self;\n-        nm as usize\n-    }\n-\n-    pub fn ident(&self) -> Ident {\n-        Ident { name: *self, ctxt: 0 }\n-    }\n-}\n-\n-/// A mark represents a unique id associated with a macro expansion\n-pub type Mrk = u32;\n-\n-impl Encodable for Name {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.as_str())\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}#{}\", self.name, self.ctxt.0)\n     }\n }\n \n-impl Decodable for Name {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n-        Ok(token::intern(&try!(d.read_str())[..]))\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, f)\n     }\n }\n \n@@ -202,8 +176,8 @@ impl Decodable for Ident {\n     }\n }\n \n-/// Function name (not all functions have names)\n-pub type FnIdent = Option<Ident>;\n+/// A mark represents a unique id associated with a macro expansion\n+pub type Mrk = u32;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n@@ -841,19 +815,16 @@ pub enum Expr_ {\n     ///\n     /// This is desugared to a `match` expression.\n     ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n     ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n@@ -863,7 +834,6 @@ pub enum Expr_ {\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n@@ -1223,13 +1193,6 @@ pub struct MutTy {\n     pub mutbl: Mutability,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TypeField {\n-    pub ident: Ident,\n-    pub mt: MutTy,\n-    pub span: Span,\n-}\n-\n /// Represents a method's signature in a trait declaration,\n /// or in an implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "a7c496a0f7b9d164550ac5eee84414f73d1e821c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -576,21 +576,21 @@ mod tests {\n     use ast::*;\n     use super::*;\n \n-    fn ident_to_segment(id : &Ident) -> PathSegment {\n-        PathSegment {identifier: id.clone(),\n+    fn ident_to_segment(id: Ident) -> PathSegment {\n+        PathSegment {identifier: id,\n                      parameters: PathParameters::none()}\n     }\n \n     #[test] fn idents_name_eq_test() {\n         assert!(segments_name_eq(\n-            &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n-            &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n+            &[Ident::new(Name(3),SyntaxContext(4)), Ident::new(Name(78),SyntaxContext(82))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n+            &[Ident::new(Name(3),SyntaxContext(104)), Ident::new(Name(78),SyntaxContext(182))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n         assert!(!segments_name_eq(\n-            &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n-            &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n+            &[Ident::new(Name(3),SyntaxContext(4)), Ident::new(Name(78),SyntaxContext(82))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n+            &[Ident::new(Name(3),SyntaxContext(104)), Ident::new(Name(77),SyntaxContext(182))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n     }\n }"}, {"sha": "1f8c726bf6880d4ab8c51ee30cc945b151331535", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -1083,7 +1083,6 @@ pub struct MalformedCodemapPositions {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use std::rc::Rc;\n \n     #[test]\n     fn t1 () {"}, {"sha": "6b4a5538501866b4aa8f613c6537d7d80f7bbb99", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -842,7 +842,7 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n #[cfg(test)]\n mod test {\n     use super::{EmitterWriter, Level};\n-    use codemap::{mk_sp, CodeMap, BytePos};\n+    use codemap::{mk_sp, CodeMap};\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n     use std::str::from_utf8;"}, {"sha": "a276765e2161692ab636ec3ea164ad443219b32e", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -138,7 +138,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n             ));\n         }\n     });\n-    let sym = Ident::new(token::gensym(&format!(\n+    let sym = Ident::with_empty_ctxt(token::gensym(&format!(\n         \"__register_diagnostic_{}\", code\n     )));\n     MacEager::items(SmallVector::many(vec!["}, {"sha": "ddc4443a77c9d7aa290aeb0511613560de3d5179", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -28,7 +28,7 @@ pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.ident.name.as_str() == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "aaaca8bd4d8e2229d922832ceddda8df0ed6d0fe", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -646,7 +646,7 @@ impl<'a> ExtCtxt<'a> {\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n                 info.map_or(None, |i| {\n-                    if i.callee.name() == \"include\" {\n+                    if i.callee.name().as_str() == \"include\" {\n                         // Stop going up the backtrace once include! is encountered\n                         return None;\n                     }\n@@ -899,9 +899,9 @@ impl SyntaxEnv {\n         unreachable!()\n     }\n \n-    pub fn find(&self, k: &Name) -> Option<Rc<SyntaxExtension>> {\n+    pub fn find(&self, k: Name) -> Option<Rc<SyntaxExtension>> {\n         for frame in self.chain.iter().rev() {\n-            match frame.map.get(k) {\n+            match frame.map.get(&k) {\n                 Some(v) => return Some(v.clone()),\n                 None => {}\n             }"}, {"sha": "5b35b870c305a879d6664ad9c84f868fda071a93", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -73,7 +73,6 @@ pub trait AstBuilder {\n \n     fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n-    fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n \n     fn typaram(&self,\n                span: Span,\n@@ -443,14 +442,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                           Vec::new()))\n     }\n \n-    fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {\n-        ast::TypeField {\n-            ident: name,\n-            mt: ast::MutTy { ty: ty, mutbl: ast::MutImmutable },\n-            span: span,\n-        }\n-    }\n-\n     fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n         self.ty(span, ast::TyInfer)\n     }"}, {"sha": "6173630175a1b9f8c66606482c5c897b159d5f54", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -524,7 +524,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n         return None;\n     }\n     let extname = pth.segments[0].identifier.name;\n-    match fld.cx.syntax_env.find(&extname) {\n+    match fld.cx.syntax_env.find(extname) {\n         None => {\n             fld.cx.span_err(\n                 pth.span,\n@@ -593,7 +593,7 @@ fn expand_loop_block(loop_block: P<Block>,\n                      fld: &mut MacroExpander) -> (P<Block>, Option<Ident>) {\n     match opt_ident {\n         Some(label) => {\n-            let new_label = fresh_name(&label);\n+            let new_label = fresh_name(label);\n             let rename = (label, new_label);\n \n             // The rename *must not* be added to the pending list of current\n@@ -689,7 +689,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n \n     let fm = fresh_mark();\n     let items = {\n-        let expanded = match fld.cx.syntax_env.find(&extname) {\n+        let expanded = match fld.cx.syntax_env.find(extname) {\n             None => {\n                 fld.cx.span_err(path_span,\n                                 &format!(\"macro undefined: '{}!'\",\n@@ -892,7 +892,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                     // generate fresh names, push them to a new pending list\n                     let idents = pattern_bindings(&*expanded_pat);\n                     let mut new_pending_renames =\n-                        idents.iter().map(|ident| (*ident, fresh_name(ident))).collect();\n+                        idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n                     // rewrite the pattern using the new names (the old\n                     // ones have already been applied):\n                     let rewritten_pat = {\n@@ -951,7 +951,7 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n     let idents = pattern_bindings(&*expanded_pats[0]);\n-    let new_renames = idents.into_iter().map(|id| (id, fresh_name(&id))).collect();\n+    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n     let rewritten_pats = expanded_pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n@@ -1061,7 +1061,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             return DummyResult::raw_pat(span);\n         }\n         let extname = pth.segments[0].identifier.name;\n-        let marked_after = match fld.cx.syntax_env.find(&extname) {\n+        let marked_after = match fld.cx.syntax_env.find(extname) {\n             None => {\n                 fld.cx.span_err(pth.span,\n                                 &format!(\"macro undefined: '{}!'\",\n@@ -1134,10 +1134,7 @@ pub struct IdentRenamer<'a> {\n \n impl<'a> Folder for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n-        Ident {\n-            name: id.name,\n-            ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n-        }\n+        Ident::new(id.name, mtwt::apply_renames(self.renames, id.ctxt))\n     }\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n@@ -1161,8 +1158,8 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n \n         pat.map(|ast::Pat {id, node, span}| match node {\n             ast::PatIdent(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n-                let new_ident = Ident{name: ident.name,\n-                                      ctxt: mtwt::apply_renames(self.renames, ident.ctxt)};\n+                let new_ident = Ident::new(ident.name,\n+                                           mtwt::apply_renames(self.renames, ident.ctxt));\n                 let new_node =\n                     ast::PatIdent(binding_mode,\n                                   Spanned{span: self.new_span(sp), node: new_ident},\n@@ -1254,7 +1251,7 @@ macro_rules! partition {\n                     fld: &MacroExpander)\n                      -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n             attrs.iter().cloned().partition(|attr| {\n-                match fld.cx.syntax_env.find(&intern(&attr.name())) {\n+                match fld.cx.syntax_env.find(intern(&attr.name())) {\n                     Some(rc) => match *rc {\n                         $variant(..) => true,\n                         _ => false\n@@ -1276,7 +1273,7 @@ fn expand_decorators(a: Annotatable,\n {\n     for attr in a.attrs() {\n         let mname = intern(&attr.name());\n-        match fld.cx.syntax_env.find(&mname) {\n+        match fld.cx.syntax_env.find(mname) {\n             Some(rc) => match *rc {\n                 MultiDecorator(ref dec) => {\n                     attr::mark_used(&attr);\n@@ -1327,7 +1324,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     for attr in &modifiers {\n         let mname = intern(&attr.name());\n \n-        match fld.cx.syntax_env.find(&mname) {\n+        match fld.cx.syntax_env.find(mname) {\n             Some(rc) => match *rc {\n                 MultiModifier(ref mac) => {\n                     attr::mark_used(attr);\n@@ -1407,7 +1404,7 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n     let idents = fn_decl_arg_bindings(&*expanded_decl);\n     let renames =\n-        idents.iter().map(|id : &ast::Ident| (*id,fresh_name(id))).collect();\n+        idents.iter().map(|id| (*id,fresh_name(*id))).collect();\n     // first, a renamer for the PatIdents, for the fn_decl:\n     let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n     let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n@@ -1628,10 +1625,7 @@ struct Marker { mark: Mrk }\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n-        ast::Ident {\n-            name: id.name,\n-            ctxt: mtwt::apply_mark(self.mark, id.ctxt)\n-        }\n+        ast::Ident::new(id.name, mtwt::apply_mark(self.mark, id.ctxt))\n     }\n     fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n         Spanned {\n@@ -2104,7 +2098,7 @@ foo_module!();\n         // find the xx binding\n         let bindings = crate_bindings(&cr);\n         let cxbinds: Vec<&ast::Ident> =\n-            bindings.iter().filter(|b| b.name == \"xx\").collect();\n+            bindings.iter().filter(|b| b.name.as_str() == \"xx\").collect();\n         let cxbinds: &[&ast::Ident] = &cxbinds[..];\n         let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n             (1, Some(b)) => *b,\n@@ -2116,7 +2110,7 @@ foo_module!();\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && p.segments[0].identifier.name == \"xx\"\n+            && p.segments[0].identifier.name.as_str() == \"xx\"\n         }).enumerate() {\n             if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");"}, {"sha": "21b4c77b9f867283591338bd0199bcb81524b2fa", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -35,7 +35,7 @@ use std::collections::HashMap;\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n     mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n+    rename_memo: RefCell<HashMap<(SyntaxContext,Name,SyntaxContext,Name),SyntaxContext>>,\n }\n \n #[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n@@ -66,8 +66,9 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, m);\n-    * table.mark_memo.borrow_mut().entry(key)\n-        .or_insert_with(|| idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt)))\n+    *table.mark_memo.borrow_mut().entry(key).or_insert_with(|| {\n+        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt)))\n+    })\n }\n \n /// Extend a syntax context with a given rename\n@@ -81,10 +82,11 @@ fn apply_rename_internal(id: Ident,\n                        to: Name,\n                        ctxt: SyntaxContext,\n                        table: &SCTable) -> SyntaxContext {\n-    let key = (ctxt, id, to);\n+    let key = (ctxt, id.name, id.ctxt, to);\n \n-    * table.rename_memo.borrow_mut().entry(key)\n-        .or_insert_with(|| idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt)))\n+    *table.rename_memo.borrow_mut().entry(key).or_insert_with(|| {\n+            SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt)))\n+    })\n }\n \n /// Apply a list of renamings to a context\n@@ -185,20 +187,20 @@ fn resolve_internal(id: Ident,\n     }\n \n     let resolved = {\n-        let result = (*table.table.borrow())[id.ctxt as usize];\n+        let result = (*table.table.borrow())[id.ctxt.0 as usize];\n         match result {\n             EmptyCtxt => id.name,\n             // ignore marks here:\n             Mark(_,subctxt) =>\n-                resolve_internal(Ident{name:id.name, ctxt: subctxt},\n+                resolve_internal(Ident::new(id.name, subctxt),\n                                  table, resolve_table),\n             // do the rename if necessary:\n             Rename(Ident{name, ctxt}, toname, subctxt) => {\n                 let resolvedfrom =\n-                    resolve_internal(Ident{name:name, ctxt:ctxt},\n+                    resolve_internal(Ident::new(name, ctxt),\n                                      table, resolve_table);\n                 let resolvedthis =\n-                    resolve_internal(Ident{name:id.name, ctxt:subctxt},\n+                    resolve_internal(Ident::new(id.name, subctxt),\n                                      table, resolve_table);\n                 if (resolvedthis == resolvedfrom)\n                     && (marksof_internal(ctxt, resolvedthis, table)\n@@ -229,7 +231,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n     let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n-        let table_entry = (*table.table.borrow())[loopvar as usize];\n+        let table_entry = (*table.table.borrow())[loopvar.0 as usize];\n         match table_entry {\n             EmptyCtxt => {\n                 return result;\n@@ -256,7 +258,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n-        match (*sctable.table.borrow())[ctxt as usize] {\n+        match (*sctable.table.borrow())[ctxt.0 as usize] {\n             Mark(mrk, _) => mrk,\n             _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n@@ -302,7 +304,7 @@ mod tests {\n     }\n \n     fn id(n: u32, s: SyntaxContext) -> Ident {\n-        Ident {name: Name(n), ctxt: s}\n+        Ident::new(Name(n), s)\n     }\n \n     // because of the SCTable, I now need a tidy way of\n@@ -328,7 +330,7 @@ mod tests {\n         let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match (*table)[sc as usize] {\n+            match (*table)[sc.0 as usize] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -349,15 +351,15 @@ mod tests {\n     fn test_unfold_refold(){\n         let mut t = new_sctable_internal();\n \n-        let test_sc = vec!(M(3),R(id(101,0),Name(14)),M(9));\n-        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n+        let test_sc = vec!(M(3),R(id(101,EMPTY_CTXT),Name(14)),M(9));\n+        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),SyntaxContext(4));\n         {\n             let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(9,0));\n-            assert!((*table)[3] == Rename(id(101,0),Name(14),2));\n-            assert!((*table)[4] == Mark(3,3));\n+            assert!((*table)[2] == Mark(9,EMPTY_CTXT));\n+            assert!((*table)[3] == Rename(id(101,EMPTY_CTXT),Name(14),SyntaxContext(2)));\n+            assert!((*table)[4] == Mark(3,SyntaxContext(3)));\n         }\n-        assert_eq!(refold_test_sc(4,&t),test_sc);\n+        assert_eq!(refold_test_sc(SyntaxContext(4),&t),test_sc);\n     }\n \n     // extend a syntax context with a sequence of marks given\n@@ -371,11 +373,11 @@ mod tests {\n     #[test] fn unfold_marks_test() {\n         let mut t = new_sctable_internal();\n \n-        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n+        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(3));\n         {\n             let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(7,0));\n-            assert!((*table)[3] == Mark(3,2));\n+            assert!((*table)[2] == Mark(7,EMPTY_CTXT));\n+            assert!((*table)[3] == Mark(3,SyntaxContext(2)));\n         }\n     }\n \n@@ -396,7 +398,7 @@ mod tests {\n          assert_eq! (marksof_internal (ans, stopname,&t), [16]);}\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n-                        R(id(name1.usize() as u32,\n+                        R(id(name1.0,\n                              apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           Name(100101102)),\n                         M(14));\n@@ -405,7 +407,7 @@ mod tests {\n         // rename where stop does match\n         { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n-                       R(id(name1.usize() as u32, name1sc),\n+                       R(id(name1.0, name1sc),\n                          stopname),\n                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n@@ -474,10 +476,10 @@ mod tests {\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n-        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),3);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n+        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(3));\n         // using the same one again should result in the same index:\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n         // I'm assuming that the rename table will behave the same....\n     }\n \n@@ -496,10 +498,10 @@ mod tests {\n \n     #[test]\n     fn new_resolves_test() {\n-        let renames = vec!((Ident{name:Name(23),ctxt:EMPTY_CTXT},Name(24)),\n-                           (Ident{name:Name(29),ctxt:EMPTY_CTXT},Name(29)));\n+        let renames = vec!((Ident::with_empty_ctxt(Name(23)),Name(24)),\n+                           (Ident::with_empty_ctxt(Name(29)),Name(29)));\n         let new_ctxt1 = apply_renames(&renames,EMPTY_CTXT);\n-        assert_eq!(resolve(Ident{name:Name(23),ctxt:new_ctxt1}),Name(24));\n-        assert_eq!(resolve(Ident{name:Name(29),ctxt:new_ctxt1}),Name(29));\n+        assert_eq!(resolve(Ident::new(Name(23),new_ctxt1)),Name(24));\n+        assert_eq!(resolve(Ident::new(Name(29),new_ctxt1)),Name(29));\n     }\n }"}, {"sha": "e9a5d9148241d3fdc70505dfd394bdc23eb5e339", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -464,7 +464,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         ($name: expr, $suffix: expr, $($args: expr),*) => {{\n             let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![$($args),*]);\n             let suffix = match $suffix {\n-                Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::new(name))),\n+                Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::with_empty_ctxt(name))),\n                 None => cx.expr_none(sp)\n             };\n             cx.expr_call(sp, mk_token_path(cx, sp, \"Literal\"), vec![inner, suffix])\n@@ -489,31 +489,32 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         }\n \n         token::Literal(token::Byte(i), suf) => {\n-            let e_byte = mk_name(cx, sp, i.ident());\n+            let e_byte = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n             return mk_lit!(\"Byte\", suf, e_byte);\n         }\n \n         token::Literal(token::Char(i), suf) => {\n-            let e_char = mk_name(cx, sp, i.ident());\n+            let e_char = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n             return mk_lit!(\"Char\", suf, e_char);\n         }\n \n         token::Literal(token::Integer(i), suf) => {\n-            let e_int = mk_name(cx, sp, i.ident());\n+            let e_int = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n             return mk_lit!(\"Integer\", suf, e_int);\n         }\n \n         token::Literal(token::Float(fident), suf) => {\n-            let e_fident = mk_name(cx, sp, fident.ident());\n+            let e_fident = mk_name(cx, sp, ast::Ident::with_empty_ctxt(fident));\n             return mk_lit!(\"Float\", suf, e_fident);\n         }\n \n         token::Literal(token::Str_(ident), suf) => {\n-            return mk_lit!(\"Str_\", suf, mk_name(cx, sp, ident.ident()))\n+            return mk_lit!(\"Str_\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)))\n         }\n \n         token::Literal(token::StrRaw(ident, n), suf) => {\n-            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ident.ident()), cx.expr_usize(sp, n))\n+            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)),\n+                           cx.expr_usize(sp, n))\n         }\n \n         token::Ident(ident, style) => {\n@@ -535,7 +536,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::DocComment(ident) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"DocComment\"),\n-                                vec!(mk_name(cx, sp, ident.ident())));\n+                                vec!(mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident))));\n         }\n \n         token::MatchNt(name, kind, namep, kindp) => {"}, {"sha": "01fd4608ecb361cbd8e5de12de4f8e445dd39875", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -79,7 +79,7 @@ pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n use ast;\n-use ast::{TokenTree, Ident};\n+use ast::{TokenTree, Name};\n use ast::{TtDelimited, TtSequence, TtToken};\n use codemap::{BytePos, mk_sp, Span};\n use codemap;\n@@ -202,9 +202,9 @@ pub enum NamedMatch {\n }\n \n pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n-            -> HashMap<Ident, Rc<NamedMatch>> {\n+            -> HashMap<Name, Rc<NamedMatch>> {\n     fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n-             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut usize) {\n+             ret_val: &mut HashMap<Name, Rc<NamedMatch>>, idx: &mut usize) {\n         match m {\n             &TtSequence(_, ref seq) => {\n                 for next_m in &seq.tts {\n@@ -217,7 +217,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                 }\n             }\n             &TtToken(sp, MatchNt(bind_name, _, _, _)) => {\n-                match ret_val.entry(bind_name) {\n+                match ret_val.entry(bind_name.name) {\n                     Vacant(spot) => {\n                         spot.insert(res[*idx].clone());\n                         *idx += 1;\n@@ -246,7 +246,7 @@ pub enum ParseResult<T> {\n     Error(codemap::Span, String)\n }\n \n-pub type NamedParseResult = ParseResult<HashMap<Ident, Rc<NamedMatch>>>;\n+pub type NamedParseResult = ParseResult<HashMap<Name, Rc<NamedMatch>>>;\n pub type PositionalParseResult = ParseResult<Vec<Rc<NamedMatch>>>;\n \n /// Perform a token equality check, ignoring syntax context (that is, an"}, {"sha": "0a95f24a7210df8eb63c6ea86f913ccbc3036a8c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -282,7 +282,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     };\n \n     // Extract the arguments:\n-    let lhses = match **argument_map.get(&lhs_nm).unwrap() {\n+    let lhses = match **argument_map.get(&lhs_nm.name).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n@@ -291,7 +291,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         check_lhs_nt_follows(cx, &**lhs, def.span);\n     }\n \n-    let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n+    let rhses = match **argument_map.get(&rhs_nm.name).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n@@ -510,14 +510,14 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n             \"pat\" => {\n                 match *tok {\n                     FatArrow | Comma | Eq => Ok(true),\n-                    Ident(i, _) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n+                    Ident(i, _) if i.name.as_str() == \"if\" || i.name.as_str() == \"in\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n                     Comma | FatArrow | Colon | Eq | Gt | Semi => Ok(true),\n-                    Ident(i, _) if i.name == \"as\" => Ok(true),\n+                    Ident(i, _) if i.name.as_str() == \"as\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },"}, {"sha": "d1e48eda4ffd2f46b774fe6c3e5e39dd022767df", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -10,7 +10,7 @@\n use self::LockstepIterSize::*;\n \n use ast;\n-use ast::{TokenTree, TtDelimited, TtToken, TtSequence, Ident};\n+use ast::{TokenTree, TtDelimited, TtToken, TtSequence, Ident, Name};\n use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n@@ -38,7 +38,7 @@ pub struct TtReader<'a> {\n     /// the unzipped tree:\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n-    interpolations: HashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: HashMap<Name, Rc<NamedMatch>>,\n     imported_from: Option<Ident>,\n \n     // Some => return imported_from as the next token\n@@ -56,7 +56,7 @@ pub struct TtReader<'a> {\n /// `src` contains no `TtSequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n-                         interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n+                         interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                          imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree>)\n                          -> TtReader<'a> {\n@@ -70,7 +70,7 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n /// `src` contains no `TtSequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a SpanHandler,\n-                                       interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n+                                       interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                                        imported_from: Option<Ident>,\n                                        src: Vec<ast::TokenTree>,\n                                        desugar_doc_comments: bool)\n@@ -117,7 +117,7 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<Name\n }\n \n fn lookup_cur_matched(r: &TtReader, name: Ident) -> Option<Rc<NamedMatch>> {\n-    let matched_opt = r.interpolations.get(&name).cloned();\n+    let matched_opt = r.interpolations.get(&name.name).cloned();\n     matched_opt.map(|s| lookup_cur_matched_by_matched(r, s))\n }\n "}, {"sha": "18c6d74d62ec25bd8be6e0dc99b5fce2f1634e4a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -35,7 +35,7 @@ use codemap::{CodeMap, Span};\n use diagnostic::SpanHandler;\n use visit;\n use visit::{FnKind, Visitor};\n-use parse::token::{self, InternedString};\n+use parse::token::InternedString;\n \n use std::ascii::AsciiExt;\n use std::cmp;\n@@ -673,7 +673,7 @@ struct MacroVisitor<'a> {\n impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n     fn visit_mac(&mut self, mac: &ast::Mac) {\n         let path = &mac.node.path;\n-        let id = path.segments.last().unwrap().identifier;\n+        let name = path.segments.last().unwrap().identifier.name.as_str();\n \n         // Issue 22234: If you add a new case here, make sure to also\n         // add code to catch the macro during or after expansion.\n@@ -683,19 +683,19 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n         // catch uses of these macros within conditionally-compiled\n         // code, e.g. `#[cfg]`-guarded functions.\n \n-        if id == token::str_to_ident(\"asm\") {\n+        if name == \"asm\" {\n             self.context.gate_feature(\"asm\", path.span, EXPLAIN_ASM);\n         }\n \n-        else if id == token::str_to_ident(\"log_syntax\") {\n+        else if name == \"log_syntax\" {\n             self.context.gate_feature(\"log_syntax\", path.span, EXPLAIN_LOG_SYNTAX);\n         }\n \n-        else if id == token::str_to_ident(\"trace_macros\") {\n+        else if name == \"trace_macros\" {\n             self.context.gate_feature(\"trace_macros\", path.span, EXPLAIN_TRACE_MACROS);\n         }\n \n-        else if id == token::str_to_ident(\"concat_idents\") {\n+        else if name == \"concat_idents\" {\n             self.context.gate_feature(\"concat_idents\", path.span, EXPLAIN_CONCAT_IDENTS);\n         }\n     }"}, {"sha": "015cf60f0cfdb4c9b50cd99c1e7881f8a0c95fbf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -40,7 +40,7 @@ impl<'a> ParserAttr for Parser<'a> {\n               token::DocComment(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                     attr::mk_attr_id(),\n-                    self.id_to_interned_str(s.ident()),\n+                    self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)),\n                     self.span.lo,\n                     self.span.hi\n                 );\n@@ -137,9 +137,8 @@ impl<'a> ParserAttr for Parser<'a> {\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(),\n-                                                         self.id_to_interned_str(s.ident()),\n-                                                         lo, hi);\n+                    let str = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n                     if attr.node.style == ast::AttrInner {\n                         attrs.push(attr);\n                         panictry!(self.bump());"}, {"sha": "5beec702f8cfb1ab08412bc32a898debab885e86", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -744,8 +744,8 @@ mod tests {\n                 Some(&ast::TtToken(_, token::Ident(name_zip, token::Plain))),\n                 Some(&ast::TtDelimited(_, ref macro_delimed)),\n             )\n-            if name_macro_rules.name == \"macro_rules\"\n-            && name_zip.name == \"zip\" => {\n+            if name_macro_rules.name.as_str() == \"macro_rules\"\n+            && name_zip.name.as_str() == \"zip\" => {\n                 let tts = &macro_delimed.tts[..];\n                 match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                     (\n@@ -763,7 +763,7 @@ mod tests {\n                                 Some(&ast::TtToken(_, token::Ident(ident, token::Plain))),\n                             )\n                             if first_delimed.delim == token::Paren\n-                            && ident.name == \"a\" => {},\n+                            && ident.name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n@@ -774,7 +774,7 @@ mod tests {\n                                 Some(&ast::TtToken(_, token::Ident(ident, token::Plain))),\n                             )\n                             if second_delimed.delim == token::Paren\n-                            && ident.name == \"a\" => {},\n+                            && ident.name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),\n                         }\n                     },"}, {"sha": "f47dfeb1d34679df56a14526ada66b747d4ea961", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -4658,7 +4658,7 @@ impl<'a> Parser<'a> {\n             (fields, None)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n-            let fields = try!(self.parse_tuple_struct_body(&class_name, &mut generics));\n+            let fields = try!(self.parse_tuple_struct_body(class_name, &mut generics));\n             (fields, Some(ast::DUMMY_NODE_ID))\n         } else {\n             let token_str = self.this_token_to_string();\n@@ -4693,7 +4693,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_tuple_struct_body(&mut self,\n-                                   class_name: &ast::Ident,\n+                                   class_name: ast::Ident,\n                                    generics: &mut ast::Generics)\n                                    -> PResult<Vec<StructField>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n@@ -5723,10 +5723,10 @@ impl<'a> Parser<'a> {\n                                                  Option<ast::Name>)>> {\n         let ret = match self.token {\n             token::Literal(token::Str_(s), suf) => {\n-                (self.id_to_interned_str(s.ident()), ast::CookedStr, suf)\n+                (self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)), ast::CookedStr, suf)\n             }\n             token::Literal(token::StrRaw(s, n), suf) => {\n-                (self.id_to_interned_str(s.ident()), ast::RawStr(n), suf)\n+                (self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)), ast::RawStr(n), suf)\n             }\n             _ => return Ok(None)\n         };"}, {"sha": "ba24dc3c0a74ec155fbc4d870741374560da667d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -453,7 +453,7 @@ macro_rules! declare_special_idents_and_keywords {(\n             #[allow(non_upper_case_globals)]\n             pub const $si_static: ast::Ident = ast::Ident {\n                 name: ast::Name($si_name),\n-                ctxt: 0,\n+                ctxt: ast::EMPTY_CTXT,\n             };\n          )*\n     }\n@@ -462,7 +462,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         use ast;\n         $(\n             #[allow(non_upper_case_globals)]\n-            pub const $si_static: ast::Name =  ast::Name($si_name);\n+            pub const $si_static: ast::Name = ast::Name($si_name);\n         )*\n     }\n \n@@ -729,19 +729,19 @@ pub fn gensym(s: &str) -> ast::Name {\n /// Maps a string to an identifier with an empty syntax context.\n #[inline]\n pub fn str_to_ident(s: &str) -> ast::Ident {\n-    ast::Ident::new(intern(s))\n+    ast::Ident::with_empty_ctxt(intern(s))\n }\n \n /// Maps a string to a gensym'ed identifier.\n #[inline]\n pub fn gensym_ident(s: &str) -> ast::Ident {\n-    ast::Ident::new(gensym(s))\n+    ast::Ident::with_empty_ctxt(gensym(s))\n }\n \n // create a fresh name that maps to the same string as the old one.\n // note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n // that is, that the new name and the old one are connected to ptr_eq strings.\n-pub fn fresh_name(src: &ast::Ident) -> ast::Name {\n+pub fn fresh_name(src: ast::Ident) -> ast::Name {\n     let interner = get_ident_interner();\n     interner.gensym_copy(src.name)\n     // following: debug version. Could work in final except that it's incompatible with\n@@ -753,7 +753,7 @@ pub fn fresh_name(src: &ast::Ident) -> ast::Name {\n \n // create a fresh mark.\n pub fn fresh_mark() -> ast::Mrk {\n-    gensym(\"mark\").usize() as u32\n+    gensym(\"mark\").0\n }\n \n #[cfg(test)]\n@@ -763,7 +763,7 @@ mod tests {\n     use ext::mtwt;\n \n     fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident { name: id.name, ctxt:mtwt::apply_mark(m, id.ctxt) }\n+        ast::Ident::new(id.name, mtwt::apply_mark(m, id.ctxt))\n     }\n \n     #[test] fn mtwt_token_eq_test() {"}, {"sha": "49b6dbed27e8c2991fe8a9cad3b85cf55e385603", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -297,7 +297,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtBlock(ref e)       => block_to_string(&**e),\n             token::NtStmt(ref e)        => stmt_to_string(&**e),\n             token::NtPat(ref e)         => pat_to_string(&**e),\n-            token::NtIdent(ref e, _)    => ident_to_string(&**e),\n+            token::NtIdent(ref e, _)    => ident_to_string(**e),\n             token::NtTT(ref e)          => tt_to_string(&**e),\n             token::NtArm(ref e)         => arm_to_string(&*e),\n             token::NtImplItem(ref e)    => impl_item_to_string(&**e),\n@@ -376,8 +376,8 @@ pub fn path_to_string(p: &ast::Path) -> String {\n     to_string(|s| s.print_path(p, false, 0))\n }\n \n-pub fn ident_to_string(id: &ast::Ident) -> String {\n-    to_string(|s| s.print_ident(*id))\n+pub fn ident_to_string(id: ast::Ident) -> String {\n+    to_string(|s| s.print_ident(id))\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n@@ -2857,7 +2857,6 @@ impl<'a> State<'a> {\n             ast::ViewPathSimple(ident, ref path) => {\n                 try!(self.print_path(path, false, 0));\n \n-                // FIXME(#6993) can't compare identifiers directly here\n                 if path.segments.last().unwrap().identifier.name !=\n                         ident.name {\n                     try!(space(&mut self.s));"}, {"sha": "6e9c161293de27359ef5fb91e3a79ff1f93242e2", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -69,7 +69,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n \n     pub fn get(&self, idx: Name) -> T {\n         let vect = self.vect.borrow();\n-        (*vect)[idx.usize()].clone()\n+        (*vect)[idx.0 as usize].clone()\n     }\n \n     pub fn len(&self) -> usize {\n@@ -196,13 +196,13 @@ impl StrInterner {\n         let new_idx = Name(self.len() as u32);\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect)[idx.usize()].clone();\n+        let existing = (*vect)[idx.0 as usize].clone();\n         vect.push(existing);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> RcStr {\n-        (*self.vect.borrow())[idx.usize()].clone()\n+        (*self.vect.borrow())[idx.0 as usize].clone()\n     }\n \n     pub fn len(&self) -> usize {"}, {"sha": "a0036745d90a432f3be9ea1d83780e5bf1a0e5e3", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -35,7 +35,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name == \"lintme\" {\n+        if it.ident.name.as_str() == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "296d1e431f4ca20dcd037189745db0c130cff6d0", "filename": "src/test/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e88c36ebcec101c7de6313c4d45ffe66123fd3a/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=2e88c36ebcec101c7de6313c4d45ffe66123fd3a", "patch": "@@ -33,7 +33,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n \n     let mac_expr = match TokenTree::parse(cx, &mbe_matcher[..], args) {\n         Success(map) => {\n-            match (&*map[&str_to_ident(\"matched\")], &*map[&str_to_ident(\"pat\")]) {\n+            match (&*map[&str_to_ident(\"matched\").name], &*map[&str_to_ident(\"pat\").name]) {\n                 (&MatchedNonterminal(NtExpr(ref matched_expr)),\n                  &MatchedSeq(ref pats, seq_sp)) => {\n                     let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt|"}]}