{"sha": "d2d35db570f0d5da1b0b829e38b495e763a0a60b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZDM1ZGI1NzBmMGQ1ZGExYjBiODI5ZTM4YjQ5NWU3NjNhMGE2MGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-11T06:55:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-11T06:55:33Z"}, "message": "auto merge of #20755 : dotdash/rust/fca, r=Aatch\n\nCurrently, small aggregates are passed to functions as immediate values\r\nas is. This has two consequences.\r\n    \r\nOne is that aggregates are passed component-wise by LLVM, so e.g. a\r\nstruct containing four u8 values (e.g. an RGBA struct) will be passed as\r\nfour individual values.\r\n    \r\nThe other is that LLVM isn't very good at optimizing loads/stores of\r\nfirst class attributes. What clang does is converting the aggregate to\r\nan appropriately sized integer type (e.g. i32 for the four u8 values),\r\nand using that for the function argument. This allows LLVM to create\r\ncode that is a lot better.\r\n    \r\nFixes #20450 #20149 #16506 #13927", "tree": {"sha": "35c4b1d18e353655ce37f975a3a4a9bdf00ad3e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c4b1d18e353655ce37f975a3a4a9bdf00ad3e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2d35db570f0d5da1b0b829e38b495e763a0a60b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d35db570f0d5da1b0b829e38b495e763a0a60b", "html_url": "https://github.com/rust-lang/rust/commit/d2d35db570f0d5da1b0b829e38b495e763a0a60b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2d35db570f0d5da1b0b829e38b495e763a0a60b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "431105a70acaf6e0a1d64b6dd3f69563d6694287", "url": "https://api.github.com/repos/rust-lang/rust/commits/431105a70acaf6e0a1d64b6dd3f69563d6694287", "html_url": "https://github.com/rust-lang/rust/commit/431105a70acaf6e0a1d64b6dd3f69563d6694287"}, {"sha": "6f1b06eb6546ab4808614dfe7807277419b485aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f1b06eb6546ab4808614dfe7807277419b485aa", "html_url": "https://github.com/rust-lang/rust/commit/6f1b06eb6546ab4808614dfe7807277419b485aa"}], "stats": {"total": 72, "additions": 59, "deletions": 13}, "files": [{"sha": "ea98d6bb74e9504b502c5f41e8aff2424aede395", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d2d35db570f0d5da1b0b829e38b495e763a0a60b", "patch": "@@ -1054,6 +1054,11 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         C_undef(type_of::type_of(cx.ccx(), t))\n     } else if ty::type_is_bool(t) {\n         Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n+    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n+        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n+        // and we have to convert it\n+        Load(cx, BitCast(cx, ptr, type_of::arg_type_of(cx.ccx(), t).ptr_to()))\n     } else if ty::type_is_char(t) {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n@@ -1065,9 +1070,14 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty(cx: Block, v: ValueRef, dst: ValueRef, t: Ty) {\n+pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     if ty::type_is_bool(t) {\n         Store(cx, ZExt(cx, v, Type::i8(cx.ccx())), dst);\n+    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n+        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n+        // and we have to convert it\n+        Store(cx, v, BitCast(cx, dst, type_of::arg_type_of(cx.ccx(), t).ptr_to()));\n     } else {\n         Store(cx, v, dst);\n     };"}, {"sha": "f59e70d099a638342005c300f5c02ed8e3574abe", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=d2d35db570f0d5da1b0b829e38b495e763a0a60b", "patch": "@@ -222,10 +222,7 @@ fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match ty.sty {\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n-            fields.len() == 1 &&\n-                fields[0].name ==\n-                    token::special_idents::unnamed_field.name &&\n-                type_is_immediate(ccx, fields[0].mt.ty)\n+            fields.len() == 1 && type_is_immediate(ccx, fields[0].mt.ty)\n         }\n         _ => false\n     }\n@@ -247,7 +244,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         return false;\n     }\n     match ty.sty {\n-        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n+        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) | ty::ty_vec(_, Some(_)) |\n         ty::ty_unboxed_closure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())"}, {"sha": "fb61bab6ade2c4e18e432bc61aa95c73e1682b82", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=d2d35db570f0d5da1b0b829e38b495e763a0a60b", "patch": "@@ -736,6 +736,13 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 if ty::type_is_bool(rust_ty) {\n                     let tmp = builder.load_range_assert(llforeign_arg, 0, 2, llvm::False);\n                     builder.trunc(tmp, Type::i1(ccx))\n+                } else if type_of::type_of(ccx, rust_ty).is_aggregate() {\n+                    // We want to pass small aggregates as immediate values, but using an aggregate\n+                    // LLVM type for this leads to bad optimizations, so its arg type is an\n+                    // appropriately sized integer and we have to convert it\n+                    let tmp = builder.bitcast(llforeign_arg,\n+                                              type_of::arg_type_of(ccx, rust_ty).ptr_to());\n+                    builder.load(tmp)\n                 } else {\n                     builder.load(llforeign_arg)\n                 }\n@@ -834,10 +841,10 @@ fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                fn_sig: &ty::FnSig<'tcx>,\n                                arg_tys: &[Ty<'tcx>])\n                                -> LlvmSignature {\n-    let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n+    let llarg_tys = arg_tys.iter().map(|&arg| foreign_arg_type_of(ccx, arg)).collect();\n     let (llret_ty, ret_def) = match fn_sig.output {\n         ty::FnConverging(ret_ty) =>\n-            (type_of::arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n+            (type_of::foreign_arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n         ty::FnDiverging =>\n             (Type::nil(ccx), false)\n     };"}, {"sha": "a79bb6ca1647068f5887056cd13f3590af614439", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d2d35db570f0d5da1b0b829e38b495e763a0a60b", "patch": "@@ -138,7 +138,7 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n-    Store(bcx, v, vp);\n+    store_ty(bcx, v, vp, t);\n     drop_ty(bcx, vp, t, source_location)\n }\n "}, {"sha": "91c7409182df6827a14836a9ea17f16cec99d8b6", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=d2d35db570f0d5da1b0b829e38b495e763a0a60b", "patch": "@@ -357,11 +357,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 &ccx.link_meta().crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     the intrinsic module\n-            C_named_struct(llret_ty, &[C_u64(ccx, hash)])\n+            C_u64(ccx, hash)\n         }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let lltp_ty = type_of::arg_type_of(ccx, tp_ty);\n             if return_type_is_void(ccx, tp_ty) {\n                 C_nil(ccx)\n             } else {\n@@ -686,6 +686,11 @@ fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, name: &'static st\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n     let ret = InsertValue(bcx, ret, result, 0);\n     let ret = InsertValue(bcx, ret, overflow, 1);\n-\n-    ret\n+    if type_is_immediate(bcx.ccx(), t) {\n+        let tmp = alloc_ty(bcx, t, \"tmp\");\n+        Store(bcx, ret, tmp);\n+        load_ty(bcx, tmp, t)\n+    } else {\n+        ret\n+    }\n }"}, {"sha": "9cae142c03ac14ae6f402f6991ae43100a69e256", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=d2d35db570f0d5da1b0b829e38b495e763a0a60b", "patch": "@@ -82,6 +82,11 @@ impl Type {\n         ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n     }\n \n+    // Creates an integer type with the given number of bits, e.g. i24\n+    pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), num_bits as c_uint))\n+    }\n+\n     pub fn f32(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMFloatTypeInContext(ccx.llcx()))\n     }\n@@ -260,6 +265,13 @@ impl Type {\n         ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n     }\n \n+    pub fn is_aggregate(&self) -> bool {\n+        match self.kind() {\n+            TypeKind::Struct | TypeKind::Array => true,\n+            _ =>  false\n+        }\n+    }\n+\n     pub fn is_packed(&self) -> bool {\n         unsafe {\n             llvm::LLVMIsPackedStruct(self.to_ref()) == True"}, {"sha": "76e0e0d0545572bfade131cbde87b8b53c259f71", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d35db570f0d5da1b0b829e38b495e763a0a60b/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=d2d35db570f0d5da1b0b829e38b495e763a0a60b", "patch": "@@ -243,9 +243,24 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     llsizingty\n }\n \n+pub fn foreign_arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n+    if ty::type_is_bool(t) {\n+        Type::i1(cx)\n+    } else {\n+        type_of(cx, t)\n+    }\n+}\n+\n pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     if ty::type_is_bool(t) {\n         Type::i1(cx)\n+    } else if type_is_immediate(cx, t) && type_of(cx, t).is_aggregate() {\n+        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n+        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n+        match machine::llsize_of_alloc(cx, sizing_type_of(cx, t)) {\n+            0 => type_of(cx, t),\n+            n => Type::ix(cx, n * 8),\n+        }\n     } else {\n         type_of(cx, t)\n     }"}]}