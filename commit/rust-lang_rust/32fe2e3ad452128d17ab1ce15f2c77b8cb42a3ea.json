{"sha": "32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZmUyZTNhZDQ1MjEyOGQxN2FiMWNlMTVmMmM3N2I4Y2I0MmEzZWE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-05-14T12:04:49Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-05-19T14:42:14Z"}, "message": "Address review commets\n\nI think I didn't run tests properly - my second call to\nselect_all_obligations_or_error has made 3 tests fail. However, this is\njust an error message change - integer fallback never worked with casts.", "tree": {"sha": "bca08ed0c097aa5c2e0c1f3b91a873f3e3366be1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bca08ed0c097aa5c2e0c1f3b91a873f3e3366be1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "html_url": "https://github.com/rust-lang/rust/commit/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de4b0e996192d6784e0a65c66d095a6198894c47", "url": "https://api.github.com/repos/rust-lang/rust/commits/de4b0e996192d6784e0a65c66d095a6198894c47", "html_url": "https://github.com/rust-lang/rust/commit/de4b0e996192d6784e0a65c66d095a6198894c47"}], "stats": {"total": 226, "additions": 123, "deletions": 103}, "files": [{"sha": "c534a3ca0389fdafa3818743bf49a69805949863", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -15,7 +15,7 @@ use middle::ty::{self, Ty};\n \n use syntax::ast;\n \n-\n+/// Types that are represented as ints.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum IntTy {\n     U(ast::UintTy),\n@@ -28,10 +28,16 @@ pub enum IntTy {\n // Valid types for the result of a non-coercion cast\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum CastTy<'tcx> {\n+    /// Various types that are represented as ints and handled mostly\n+    /// in the same way, merged for easier matching.\n     Int(IntTy),\n+    /// Floating-Point types\n     Float,\n-    FPtr,\n+    /// Function Pointers\n+    FnPtr,\n+    /// Raw pointers\n     Ptr(&'tcx ty::mt<'tcx>),\n+    /// References\n     RPtr(&'tcx ty::mt<'tcx>),\n }\n \n@@ -47,13 +53,13 @@ pub enum CastKind {\n     PrimIntCast,\n     U8CharCast,\n     ArrayPtrCast,\n-    FPtrPtrCast,\n-    FPtrAddrCast\n+    FnPtrPtrCast,\n+    FnPtrAddrCast\n }\n \n impl<'tcx> CastTy<'tcx> {\n-    pub fn recognize(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>)\n-                     -> Option<CastTy<'tcx>> {\n+    pub fn from_ty(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>)\n+                   -> Option<CastTy<'tcx>> {\n         match t.sty {\n             ty::ty_bool => Some(CastTy::Int(IntTy::Bool)),\n             ty::ty_char => Some(CastTy::Int(IntTy::Char)),\n@@ -64,7 +70,7 @@ impl<'tcx> CastTy<'tcx> {\n                 tcx, t) => Some(CastTy::Int(IntTy::CEnum)),\n             ty::ty_ptr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::ty_rptr(_, ref mt) => Some(CastTy::RPtr(mt)),\n-            ty::ty_bare_fn(..) => Some(CastTy::FPtr),\n+            ty::ty_bare_fn(..) => Some(CastTy::FnPtr),\n             _ => None,\n         }\n     }"}, {"sha": "794cc4ff38d341c3eb0c5519fbee623fb366a510", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -443,11 +443,11 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tcx.cast_kinds.borrow().get(&from.id) {\n                 None => v.tcx.sess.span_bug(e.span, \"no kind for cast\"),\n-                Some(&CastKind::PtrAddrCast) | Some(&CastKind::FPtrAddrCast) => {\n+                Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n                         span_err!(v.tcx.sess, e.span, E0018,\n-                                  \"can not cast a pointer to an integer in {}s\", v.msg());\n+                                  \"can't cast a pointer to an integer in {}s\", v.msg());\n                     }\n                 }\n                 _ => {}"}, {"sha": "828e4bcc65c4f7965ef3af7f3d239c5fc2722cb1", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -617,41 +617,41 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n           }\n           ast::ExprCast(ref base, _) => {\n-            let t_1 = ety;\n-            let llty = type_of::type_of(cx, t_1);\n-            let (v, t_e) = const_expr(cx, &**base, param_substs);\n-            debug!(\"trans_const_cast({} as {})\", t_e.repr(cx.tcx()), t_1.repr(cx.tcx()));\n-            if expr::cast_is_noop(cx.tcx(), base, t_e, t_1) {\n+            let t_cast = ety;\n+            let llty = type_of::type_of(cx, t_cast);\n+            let (v, t_expr) = const_expr(cx, &**base, param_substs);\n+            debug!(\"trans_const_cast({} as {})\", t_expr.repr(cx.tcx()), t_cast.repr(cx.tcx()));\n+            if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return v;\n             }\n-            if type_is_fat_ptr(cx.tcx(), t_e) {\n+            if type_is_fat_ptr(cx.tcx(), t_expr) {\n                 // Fat pointer casts.\n-                let t_1_inner = ty::deref(t_1, true).expect(\"cast to non-pointer\").ty;\n-                let ptr_ty = type_of::in_memory_type_of(cx, t_1_inner).ptr_to();\n+                let t_cast_inner = ty::deref(t_cast, true).expect(\"cast to non-pointer\").ty;\n+                let ptr_ty = type_of::in_memory_type_of(cx, t_cast_inner).ptr_to();\n                 let addr = ptrcast(const_get_elt(cx, v, &[abi::FAT_PTR_ADDR as u32]),\n                                    ptr_ty);\n-                if type_is_fat_ptr(cx.tcx(), t_1) {\n+                if type_is_fat_ptr(cx.tcx(), t_cast) {\n                     let info = const_get_elt(cx, v, &[abi::FAT_PTR_EXTRA as u32]);\n                     return C_struct(cx, &[addr, info], false)\n                 } else {\n                     return addr;\n                 }\n             }\n-            match (CastTy::recognize(cx.tcx(), t_e).expect(\"bad input type for cast\"),\n-                   CastTy::recognize(cx.tcx(), t_1).expect(\"bad output type for cast\")) {\n+            match (CastTy::from_ty(cx.tcx(), t_expr).expect(\"bad input type for cast\"),\n+                   CastTy::from_ty(cx.tcx(), t_cast).expect(\"bad output type for cast\")) {\n               (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n-                let repr = adt::represent_type(cx, t_e);\n+                let repr = adt::represent_type(cx, t_expr);\n                 let discr = adt::const_get_discrim(cx, &*repr, v);\n                 let iv = C_integral(cx.int_type(), discr, false);\n                 let s = adt::is_discr_signed(&*repr) as Bool;\n                 llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n               }\n               (CastTy::Int(_), CastTy::Int(_)) => {\n-                let s = ty::type_is_signed(t_e) as Bool;\n+                let s = ty::type_is_signed(t_expr) as Bool;\n                 llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n               }\n               (CastTy::Int(_), CastTy::Float) => {\n-                if ty::type_is_signed(t_e) {\n+                if ty::type_is_signed(t_expr) {\n                     llvm::LLVMConstSIToFP(v, llty.to_ref())\n                 } else {\n                     llvm::LLVMConstUIToFP(v, llty.to_ref())\n@@ -661,18 +661,18 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMConstFPCast(v, llty.to_ref())\n               }\n               (CastTy::Float, CastTy::Int(_)) => {\n-                if ty::type_is_signed(t_1) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n+                if ty::type_is_signed(t_expr) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n                 else { llvm::LLVMConstFPToUI(v, llty.to_ref()) }\n               }\n-              (CastTy::Ptr(_), CastTy::Ptr(_)) | (CastTy::FPtr, CastTy::Ptr(_))\n+              (CastTy::Ptr(_), CastTy::Ptr(_)) | (CastTy::FnPtr, CastTy::Ptr(_))\n                     | (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n                 ptrcast(v, llty)\n               }\n-              (CastTy::FPtr, CastTy::FPtr) => ptrcast(v, llty), // isn't this a coercion?\n+              (CastTy::FnPtr, CastTy::FnPtr) => ptrcast(v, llty), // isn't this a coercion?\n               (CastTy::Int(_), CastTy::Ptr(_)) => {\n                 llvm::LLVMConstIntToPtr(v, llty.to_ref())\n               }\n-              (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FPtr, CastTy::Int(_)) => {\n+              (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FnPtr, CastTy::Int(_)) => {\n                 llvm::LLVMConstPtrToInt(v, llty.to_ref())\n               }\n               _ => {"}, {"sha": "90741d1d58fbc3e32f4e2f0c886368c8b454b089", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -2086,8 +2086,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let r_t_in = CastTy::recognize(bcx.tcx(), t_in).expect(\"bad input type for cast\");\n-    let r_t_out = CastTy::recognize(bcx.tcx(), t_out).expect(\"bad output type for cast\");\n+    let r_t_in = CastTy::from_ty(bcx.tcx(), t_in).expect(\"bad input type for cast\");\n+    let r_t_out = CastTy::from_ty(bcx.tcx(), t_out).expect(\"bad output type for cast\");\n \n     let (llexpr, signed) = if let Int(CEnum) = r_t_in {\n         let repr = adt::represent_type(ccx, t_in);\n@@ -2102,8 +2102,10 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let newval = match (r_t_in, r_t_out) {\n-        (Ptr(_), Ptr(_)) | (FPtr, Ptr(_)) | (RPtr(_), Ptr(_)) => PointerCast(bcx, llexpr, ll_t_out),\n-        (Ptr(_), Int(_)) | (FPtr, Int(_)) => PtrToInt(bcx, llexpr, ll_t_out),\n+        (Ptr(_), Ptr(_)) | (FnPtr, Ptr(_)) | (RPtr(_), Ptr(_)) => {\n+            PointerCast(bcx, llexpr, ll_t_out)\n+        }\n+        (Ptr(_), Int(_)) | (FnPtr, Int(_)) => PtrToInt(bcx, llexpr, ll_t_out),\n         (Int(_), Ptr(_)) => IntToPtr(bcx, llexpr, ll_t_out),\n \n         (Int(_), Int(_)) => int_cast(bcx, ll_t_out, ll_t_in, llexpr, signed),"}, {"sha": "5258a77204d60e3f25f949df3ecbced0b7e72ee0", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -56,11 +56,16 @@ pub struct CastCheck<'tcx> {\n     span: Span,\n }\n \n+/// The kind of the unsize info (length or vtable) - we only allow casts between\n+/// fat pointers if their unsize-infos have the same kind.\n #[derive(Copy, Clone, PartialEq, Eq)]\n enum UnsizeKind<'tcx> {\n     Vtable,\n     Length,\n-    OfTy(Ty<'tcx>)\n+    /// The unsize info of this projection\n+    OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n+    /// The unsize info of this parameter\n+    OfParam(&'tcx ty::ParamTy)\n }\n \n /// Returns the kind of unsize information of t, or None\n@@ -77,8 +82,9 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 Some(f) => unsize_kind(fcx, f.mt.ty)\n             }\n         }\n-        ty::ty_projection(..) | ty::ty_param(..) =>\n-            Some(UnsizeKind::OfTy(t)),\n+        // We should really try to normalize here.\n+        ty::ty_projection(ref pi) => Some(UnsizeKind::OfProjection(pi)),\n+        ty::ty_param(ref p) => Some(UnsizeKind::OfParam(p)),\n         _ => None\n     }\n }\n@@ -164,26 +170,26 @@ impl<'tcx> CastCheck<'tcx> {\n     }\n \n     fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n-        let t_1 = self.cast_ty;\n-        let t_e = self.expr_ty;\n-        if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n+        let t_cast = self.cast_ty;\n+        let t_expr = self.expr_ty;\n+        if ty::type_is_numeric(t_cast) && ty::type_is_numeric(t_expr) {\n             fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n                                     self.expr.id,\n                                     self.span,\n                                     format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n                                              replaced by coercion, this might require type \\\n                                              ascription or a temporary variable\",\n-                                            fcx.infcx().ty_to_string(t_e),\n-                                            fcx.infcx().ty_to_string(t_1)));\n+                                            fcx.infcx().ty_to_string(t_expr),\n+                                            fcx.infcx().ty_to_string(t_cast)));\n         } else {\n             fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n                                     self.expr.id,\n                                     self.span,\n                                     format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n                                              replaced by coercion, this might require type \\\n                                              ascription or a temporary variable\",\n-                                            fcx.infcx().ty_to_string(t_e),\n-                                            fcx.infcx().ty_to_string(t_1)));\n+                                            fcx.infcx().ty_to_string(t_expr),\n+                                            fcx.infcx().ty_to_string(t_cast)));\n         }\n \n     }\n@@ -211,24 +217,24 @@ impl<'tcx> CastCheck<'tcx> {\n         };}\n     }\n \n-    /// Check a cast, and report an error if one exists. In some cases,\n-    /// this can return Ok and create type errors rather than returning\n+    /// Check a cast, and report an error if one exists. In some cases, this\n+    /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n     fn do_check<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n         use middle::cast::IntTy::*;\n         use middle::cast::CastTy::*;\n \n-        let (t_e, t_1) = match (CastTy::recognize(fcx.tcx(), self.expr_ty),\n-                                CastTy::recognize(fcx.tcx(), self.cast_ty)) {\n-            (Some(t_e), Some(t_1)) => (t_e, t_1),\n+        let (t_from, t_cast) = match (CastTy::from_ty(fcx.tcx(), self.expr_ty),\n+                                      CastTy::from_ty(fcx.tcx(), self.cast_ty)) {\n+            (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             _ => {\n                 return Err(CastError::NonScalar)\n             }\n         };\n \n-        match (t_e, t_1) {\n+        match (t_from, t_cast) {\n             // These types have invariants! can't cast into them.\n-            (_, RPtr(_)) | (_, Int(CEnum)) | (_, FPtr) => Err(CastError::NonScalar),\n+            (_, RPtr(_)) | (_, Int(CEnum)) | (_, FnPtr) => Err(CastError::NonScalar),\n \n             // * -> Bool\n             (_, Int(Bool)) => Err(CastError::CastToBool),\n@@ -244,14 +250,14 @@ impl<'tcx> CastCheck<'tcx> {\n                 => Err(CastError::NeedViaUsize),\n \n             // ptr -> *\n-            (Ptr(m1), Ptr(m2)) => self.check_ptr_ptr_cast(fcx, m1, m2), // ptr-ptr-cast\n-            (Ptr(m_e), Int(_)) => self.check_ptr_addr_cast(fcx, m_e), // ptr-addr-cast\n-            (Ptr(_), Float) | (FPtr, Float) => Err(CastError::NeedViaUsize),\n-            (FPtr, Int(_)) => Ok(CastKind::FPtrAddrCast),\n+            (Ptr(m_e), Ptr(m_c)) => self.check_ptr_ptr_cast(fcx, m_e, m_c), // ptr-ptr-cast\n+            (Ptr(m_expr), Int(_)) => self.check_ptr_addr_cast(fcx, m_expr), // ptr-addr-cast\n+            (Ptr(_), Float) | (FnPtr, Float) => Err(CastError::NeedViaUsize),\n+            (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n             (RPtr(_), Int(_)) | (RPtr(_), Float) => Err(CastError::NeedViaPtr),\n             // * -> ptr\n             (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n-            (FPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n+            (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n             (Float, Ptr(_)) => Err(CastError::NeedViaUsize),\n             (RPtr(rmt), Ptr(mt)) => self.check_ref_cast(fcx, rmt, mt), // array-ptr-cast\n \n@@ -269,53 +275,53 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_ptr_ptr_cast<'a>(&self,\n                               fcx: &FnCtxt<'a, 'tcx>,\n-                              m_e: &'tcx ty::mt<'tcx>,\n-                              m_1: &'tcx ty::mt<'tcx>)\n+                              m_expr: &'tcx ty::mt<'tcx>,\n+                              m_cast: &'tcx ty::mt<'tcx>)\n                               -> Result<CastKind, CastError>\n     {\n-        debug!(\"check_ptr_ptr_cast m_e={} m_1={}\",\n-               m_e.repr(fcx.tcx()), m_1.repr(fcx.tcx()));\n+        debug!(\"check_ptr_ptr_cast m_expr={} m_cast={}\",\n+               m_expr.repr(fcx.tcx()), m_cast.repr(fcx.tcx()));\n         // ptr-ptr cast. vtables must match.\n \n         // Cast to sized is OK\n-        if fcx.type_is_known_to_be_sized(m_1.ty, self.span) {\n+        if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n             return Ok(CastKind::PtrPtrCast);\n         }\n \n         // sized -> unsized? report illegal cast (don't complain about vtable kinds)\n-        if fcx.type_is_known_to_be_sized(m_e.ty, self.span) {\n+        if fcx.type_is_known_to_be_sized(m_expr.ty, self.span) {\n             return Err(CastError::IllegalCast);\n         }\n \n         // vtable kinds must match\n-        match (unsize_kind(fcx, m_1.ty), unsize_kind(fcx, m_e.ty)) {\n+        match (unsize_kind(fcx, m_cast.ty), unsize_kind(fcx, m_expr.ty)) {\n             (Some(a), Some(b)) if a == b => Ok(CastKind::PtrPtrCast),\n             _ => Err(CastError::DifferingKinds)\n         }\n     }\n \n     fn check_fptr_ptr_cast<'a>(&self,\n                                fcx: &FnCtxt<'a, 'tcx>,\n-                               m_1: &'tcx ty::mt<'tcx>)\n+                               m_cast: &'tcx ty::mt<'tcx>)\n                                -> Result<CastKind, CastError>\n     {\n         // fptr-ptr cast. must be to sized ptr\n \n-        if fcx.type_is_known_to_be_sized(m_1.ty, self.span) {\n-            Ok(CastKind::FPtrPtrCast)\n+        if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n+            Ok(CastKind::FnPtrPtrCast)\n         } else {\n             Err(CastError::IllegalCast)\n         }\n     }\n \n     fn check_ptr_addr_cast<'a>(&self,\n                                fcx: &FnCtxt<'a, 'tcx>,\n-                               m_e: &'tcx ty::mt<'tcx>)\n+                               m_expr: &'tcx ty::mt<'tcx>)\n                                -> Result<CastKind, CastError>\n     {\n         // ptr-addr cast. must be from sized ptr\n \n-        if fcx.type_is_known_to_be_sized(m_e.ty, self.span) {\n+        if fcx.type_is_known_to_be_sized(m_expr.ty, self.span) {\n             Ok(CastKind::PtrAddrCast)\n         } else {\n             Err(CastError::NeedViaPtr)\n@@ -324,14 +330,14 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_ref_cast<'a>(&self,\n                           fcx: &FnCtxt<'a, 'tcx>,\n-                          m_e: &'tcx ty::mt<'tcx>,\n-                          m_1: &'tcx ty::mt<'tcx>)\n+                          m_expr: &'tcx ty::mt<'tcx>,\n+                          m_cast: &'tcx ty::mt<'tcx>)\n                           -> Result<CastKind, CastError>\n     {\n         // array-ptr-cast.\n \n-        if m_e.mutbl == ast::MutImmutable && m_1.mutbl == ast::MutImmutable {\n-            if let ty::ty_vec(ety, Some(_)) = m_e.ty.sty {\n+        if m_expr.mutbl == ast::MutImmutable && m_cast.mutbl == ast::MutImmutable {\n+            if let ty::ty_vec(ety, Some(_)) = m_expr.ty.sty {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of\n                 // vector elements instead of the original values.\n@@ -340,7 +346,7 @@ impl<'tcx> CastCheck<'tcx> {\n                 // from a region pointer to a vector.\n \n                 // this will report a type mismatch if needed\n-                demand::eqtype(fcx, self.span, ety, m_1.ty);\n+                demand::eqtype(fcx, self.span, ety, m_cast.ty);\n                 return Ok(CastKind::ArrayPtrCast);\n             }\n         }\n@@ -350,11 +356,11 @@ impl<'tcx> CastCheck<'tcx> {\n \n     fn check_addr_ptr_cast<'a>(&self,\n                                fcx: &FnCtxt<'a, 'tcx>,\n-                               m_1: &'tcx ty::mt<'tcx>)\n+                               m_cast: &'tcx ty::mt<'tcx>)\n                                -> Result<CastKind, CastError>\n     {\n         // ptr-addr cast. pointer must be thin.\n-        if fcx.type_is_known_to_be_sized(m_1.ty, self.span) {\n+        if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n            Ok(CastKind::AddrPtrCast)\n         } else {\n            Err(CastError::IllegalCast)"}, {"sha": "0e64063d6a402f9981cf9de84f8a5e14b0cd1209", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -1115,20 +1115,20 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          span: Span,\n                                          t_span: Span,\n                                          e_span: Span,\n-                                         t_1: Ty<'tcx>,\n-                                         t_e: Ty<'tcx>,\n+                                         t_cast: Ty<'tcx>,\n+                                         t_expr: Ty<'tcx>,\n                                          id: ast::NodeId) {\n-    let tstr = fcx.infcx().ty_to_string(t_1);\n+    let tstr = fcx.infcx().ty_to_string(t_cast);\n     fcx.type_error_message(span, |actual| {\n         format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-    }, t_e, None);\n-    match t_e.sty {\n+    }, t_expr, None);\n+    match t_expr.sty {\n         ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n             let mtstr = match mt {\n                 ast::MutMutable => \"mut \",\n                 ast::MutImmutable => \"\"\n             };\n-            if ty::type_is_trait(t_1) {\n+            if ty::type_is_trait(t_cast) {\n                 match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                     Ok(s) => {\n                         fcx.tcx().sess.span_suggestion(t_span,\n@@ -3404,24 +3404,24 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Find the type of `e`. Supply hints based on the type we are casting to,\n         // if appropriate.\n-        let t_1 = fcx.to_ty(t);\n-        let t_1 = structurally_resolved_type(fcx, expr.span, t_1);\n-        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n-        let t_e = fcx.expr_ty(e);\n+        let t_cast = fcx.to_ty(t);\n+        let t_cast = structurally_resolved_type(fcx, expr.span, t_cast);\n+        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_cast));\n+        let t_expr = fcx.expr_ty(e);\n \n         // Eagerly check for some obvious errors.\n-        if ty::type_is_error(t_e) {\n+        if ty::type_is_error(t_expr) {\n             fcx.write_error(id);\n-        } else if !fcx.type_is_known_to_be_sized(t_1, expr.span) {\n-            report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_1, t_e, id);\n+        } else if !fcx.type_is_known_to_be_sized(t_cast, expr.span) {\n+            report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_cast, t_expr, id);\n         } else {\n             // Write a type for the whole expression, assuming everything is going\n             // to work out Ok.\n-            fcx.write_ty(id, t_1);\n+            fcx.write_ty(id, t_cast);\n \n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n-            let cast_check = cast::CastCheck::new((**e).clone(), t_e, t_1, expr.span);\n+            let cast_check = cast::CastCheck::new((**e).clone(), t_expr, t_cast, expr.span);\n             deferred_cast_checks.push(cast_check);\n         }\n       }"}, {"sha": "c1feb8ac45900a052d0ae393029bd71787c9e5ac", "filename": "src/test/compile-fail/associated-types-incomplete-object.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -28,15 +28,15 @@ impl Foo for isize {\n }\n \n pub fn main() {\n-    let a = &42 as &Foo<A=usize, B=char>;\n+    let a = &42isize as &Foo<A=usize, B=char>;\n \n-    let b = &42 as &Foo<A=usize>;\n+    let b = &42isize as &Foo<A=usize>;\n     //~^ ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n \n-    let c = &42 as &Foo<B=char>;\n+    let c = &42isize as &Foo<B=char>;\n     //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n \n-    let d = &42 as &Foo;\n+    let d = &42isize as &Foo;\n     //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n     //~| ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n }"}, {"sha": "f3537e54135084fcef980615feae4c084c75a10e", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -65,6 +65,10 @@ fn main()\n     let _ = &f as *const f64; //~ ERROR illegal cast\n     let _ = fat_v as usize; //~ ERROR through a raw pointer first\n \n+    let a : *const str = \"hello\";\n+    let _ = a as *const Foo;\n+    //~^ ERROR `core::marker::Sized` is not implemented for the type `str`\n+\n     // check no error cascade\n     let _ = main.f as *const u32; //~ ERROR attempted access of field\n "}, {"sha": "08db643df00e4736003e083e012f3e9898fbb587", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -28,29 +28,29 @@ fn main() {\n     // if n > m, it's a type mismatch error.\n \n     // n < m\n-    let &x = &(&1 as &T);\n-    let &x = &&(&1 as &T);\n-    let &&x = &&(&1 as &T);\n+    let &x = &(&1isize as &T);\n+    let &x = &&(&1isize as &T);\n+    let &&x = &&(&1isize as &T);\n \n     // n == m\n-    let &x = &1 as &T;      //~ ERROR type `&T` cannot be dereferenced\n-    let &&x = &(&1 as &T);  //~ ERROR type `&T` cannot be dereferenced\n-    let box x = box 1 as Box<T>; //~ ERROR the trait `core::marker::Sized` is not implemented\n+    let &x = &1isize as &T;      //~ ERROR type `&T` cannot be dereferenced\n+    let &&x = &(&1isize as &T);  //~ ERROR type `&T` cannot be dereferenced\n+    let box x = box 1isize as Box<T>; //~ ERROR the trait `core::marker::Sized` is not implemented\n \n     // n > m\n-    let &&x = &1 as &T;\n+    let &&x = &1isize as &T;\n     //~^ ERROR mismatched types\n     //~| expected `T`\n     //~| found `&_`\n     //~| expected trait T\n     //~| found &-ptr\n-    let &&&x = &(&1 as &T);\n+    let &&&x = &(&1isize as &T);\n     //~^ ERROR mismatched types\n     //~| expected `T`\n     //~| found `&_`\n     //~| expected trait T\n     //~| found &-ptr\n-    let box box x = box 1 as Box<T>;\n+    let box box x = box 1isize as Box<T>;\n     //~^ ERROR mismatched types\n     //~| expected `T`\n     //~| found `Box<_>`"}, {"sha": "a3a9e17cb3c0676592539fbc1fd525f5f269deb8", "filename": "src/test/compile-fail/issue-17458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n static X: usize = 0 as *const usize as usize;\n-//~^ ERROR: can not cast a pointer to an integer in statics\n+//~^ ERROR: can't cast a pointer to an integer in statics\n \n fn main() {\n     assert_eq!(X, 0);"}, {"sha": "b1d96f9b5277885dbb62dea04ef58c23e3b11f34", "filename": "src/test/compile-fail/issue-5153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -17,6 +17,6 @@ impl Foo for isize {\n }\n \n fn main() {\n-    (&5 as &Foo).foo();\n+    (&5isize as &Foo).foo();\n     //~^ ERROR: no method named `foo` found for type `&Foo` in the current scope\n }"}, {"sha": "988a7837b59bf13d15c3ffe041701eb17db1d12d", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -28,7 +28,6 @@ fn f<T>(val: T) {\n     let a = &t as &Gettable<T>;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n     //~^^ ERROR the trait `core::marker::Copy` is not implemented\n-    //~^^^ ERROR the parameter type `T` may not live long enough\n }\n \n fn g<T>(val: T) {"}, {"sha": "0bc1e33ce46956fa2d100ca62c5c4871a79b5bbd", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "previous_filename": "src/test/run-pass/cast-enum-with-dtor.rs"}, {"sha": "e53d4af8e36cbda323ba468a4f565d78f7678117", "filename": "src/test/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=32fe2e3ad452128d17ab1ce15f2c77b8cb42a3ea", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Check that you can cast between different pointers to trait objects\n+// whose vtable have the same kind (both lengths, or both trait pointers).\n+\n trait Foo<T> {\n     fn foo(&self, _: T) -> u32 { 42 }\n }"}]}