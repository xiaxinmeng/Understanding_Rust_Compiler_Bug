{"sha": "abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZDY5NTUxYmY4Yjg3NTViNWUwMGQ0ZjRkNDVhZTVkNGEwY2QxN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-22T00:16:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-22T00:16:40Z"}, "message": "Auto merge of #66282 - Centril:simplify-try, r=oli-obk\n\n[mir-opt] asking `?`s in a more optimized fashion\n\nThis PR works towards https://github.com/rust-lang/rust/issues/66234 by providing two optimization passes meant to run in sequence:\n\n- `SimplifyArmIdentity` which transforms something like:\n  ```rust\n  _LOCAL_TMP = ((_LOCAL_1 as Variant ).FIELD: TY );\n  ((_LOCAL_0 as Variant).FIELD: TY) = move _LOCAL_TMP;\n  discriminant(_LOCAL_0) = VAR_IDX;\n  ```\n\n  into:\n\n  ```rust\n  _LOCAL_0 = move _LOCAL_1\n  ```\n\n- `SimplifyBranchSame` which transforms `SwitchInt`s to identical basic blocks into a `goto` to the first reachable target.\n\nTogether, these are meant to simplify the following into just `res`:\n```rust\nmatch res {\n    Ok(x) => Ok(x),\n    Err(x) => Err(x),\n}\n```\n\nIt should be noted however that the desugaring of `?` includes a function call and so the first pass in this PR relies on inlining to substitute that function call for identity on `x`. Inlining requires `mir-opt-level=2` so this might not have any effect in perf-bot but let's find out.\n\nr? @oli-obk -- This is WIP, but I'd appreciate feedback. :)", "tree": {"sha": "6cd22524b2a19f2abff2c9aedba0c086411b1644", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cd22524b2a19f2abff2c9aedba0c086411b1644"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "html_url": "https://github.com/rust-lang/rust/commit/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f11759d38c70d3df67135f88a682701c1cf9762a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f11759d38c70d3df67135f88a682701c1cf9762a", "html_url": "https://github.com/rust-lang/rust/commit/f11759d38c70d3df67135f88a682701c1cf9762a"}, {"sha": "2f00e86cb5cbb4d4cfe17abc6136aacadbe02382", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f00e86cb5cbb4d4cfe17abc6136aacadbe02382", "html_url": "https://github.com/rust-lang/rust/commit/2f00e86cb5cbb4d4cfe17abc6136aacadbe02382"}], "stats": {"total": 444, "additions": 432, "deletions": 12}, "files": [{"sha": "4f2df2ee9450bd6e8d2ce7f6fcc40afabe83a21e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -3709,6 +3709,7 @@ dependencies = [\n  \"arena\",\n  \"either\",\n  \"graphviz\",\n+ \"itertools 0.8.0\",\n  \"log\",\n  \"log_settings\",\n  \"polonius-engine\","}, {"sha": "1f605711c8a8e97bc6630ac20dc30e3f0b77de67", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -2053,7 +2053,7 @@ pub enum TyKind {\n     Err,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n@@ -2063,7 +2063,7 @@ pub struct InlineAsmOutput {\n \n // NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n // it needs to be `Clone` and use plain `Vec<T>` instead of `HirVec<T>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n pub struct InlineAsmInner {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,"}, {"sha": "4fe82f03b036eee2846573d585028c711a0b22e3", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n pub enum PanicInfo<O> {\n     Panic {\n         msg: Symbol,"}, {"sha": "c66075e81b84f686b811a3cf3b14e5331d3125b7", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -999,7 +999,7 @@ pub struct Terminator<'tcx> {\n     pub kind: TerminatorKind<'tcx>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n     /// Block should have one successor in the graph; we jump there.\n     Goto { target: BasicBlock },\n@@ -1528,7 +1528,7 @@ impl Statement<'_> {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n@@ -1594,7 +1594,7 @@ pub enum RetagKind {\n }\n \n /// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n     /// code.\n@@ -1636,7 +1636,7 @@ pub enum FakeReadCause {\n     ForIndex,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub struct InlineAsm<'tcx> {\n     pub asm: hir::InlineAsmInner,\n     pub outputs: Box<[Place<'tcx>]>,\n@@ -2068,7 +2068,7 @@ impl<'tcx> Operand<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n pub enum Rvalue<'tcx> {\n     /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),\n@@ -2444,7 +2444,7 @@ impl<'tcx> UserTypeProjections {\n /// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionKind>,"}, {"sha": "4afbb4d85d025c561a4400517a7146b83049ec99", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -13,6 +13,7 @@ doctest = false\n arena = { path = \"../libarena\" }\n either = \"1.5.0\"\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n+itertools = \"0.8\"\n log = \"0.4\"\n log_settings = \"0.1.1\"\n polonius-engine  = \"0.10.0\""}, {"sha": "f2707969517fe132b93fed06c760cb3ed8dd303e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -16,6 +16,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n #![feature(exhaustive_patterns)]\n+#![feature(iter_order_by)]\n #![cfg_attr(bootstrap, feature(never_type))]\n #![feature(specialization)]\n #![feature(try_trait)]"}, {"sha": "2b2b52971ef0f7fde5ff9b06e89838534de944ee", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -18,6 +18,7 @@ pub mod cleanup_post_borrowck;\n pub mod check_consts;\n pub mod check_unsafety;\n pub mod simplify_branches;\n+pub mod simplify_try;\n pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n@@ -305,6 +306,9 @@ fn run_optimization_passes<'tcx>(\n         &copy_prop::CopyPropagation,\n         &simplify_branches::SimplifyBranches::new(\"after-copy-prop\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n+        &simplify::SimplifyCfg::new(\"after-remove-noop-landing-pads\"),\n+        &simplify_try::SimplifyArmIdentity,\n+        &simplify_try::SimplifyBranchSame,\n         &simplify::SimplifyCfg::new(\"final\"),\n         &simplify::SimplifyLocals,\n "}, {"sha": "de5c2ebb571ef5ec8b1be3ef7870933e72c09dd4", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -0,0 +1,201 @@\n+//! The general point of the optimizations provided here is to simplify something like:\n+//!\n+//! ```rust\n+//! match x {\n+//!     Ok(x) => Ok(x),\n+//!     Err(x) => Err(x)\n+//! }\n+//! ```\n+//!\n+//! into just `x`.\n+\n+use crate::transform::{MirPass, MirSource, simplify};\n+use rustc::ty::{TyCtxt, Ty};\n+use rustc::mir::*;\n+use rustc_target::abi::VariantIdx;\n+use itertools::Itertools as _;\n+\n+/// Simplifies arms of form `Variant(x) => Variant(x)` to just a move.\n+///\n+/// This is done by transforming basic blocks where the statements match:\n+///\n+/// ```rust\n+/// _LOCAL_TMP = ((_LOCAL_1 as Variant ).FIELD: TY );\n+/// ((_LOCAL_0 as Variant).FIELD: TY) = move _LOCAL_TMP;\n+/// discriminant(_LOCAL_0) = VAR_IDX;\n+/// ```\n+///\n+/// into:\n+///\n+/// ```rust\n+/// _LOCAL_0 = move _LOCAL_1\n+/// ```\n+pub struct SimplifyArmIdentity;\n+\n+impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        for bb in body.basic_blocks_mut() {\n+            // Need 3 statements:\n+            let (s0, s1, s2) = match &mut *bb.statements {\n+                [s0, s1, s2] => (s0, s1, s2),\n+                _ => continue,\n+            };\n+\n+            // Pattern match on the form we want:\n+            let (local_tmp_s0, local_1, vf_s0) = match match_get_variant_field(s0) {\n+                None => continue,\n+                Some(x) => x,\n+            };\n+            let (local_tmp_s1, local_0, vf_s1) = match match_set_variant_field(s1) {\n+                None => continue,\n+                Some(x) => x,\n+            };\n+            if local_tmp_s0 != local_tmp_s1\n+                || vf_s0 != vf_s1\n+                || Some((local_0, vf_s0.var_idx)) != match_set_discr(s2)\n+            {\n+                continue;\n+            }\n+\n+            // Right shape; transform!\n+            match &mut s0.kind {\n+                StatementKind::Assign(box (place, rvalue)) => {\n+                    *place = local_0.into();\n+                    *rvalue = Rvalue::Use(Operand::Move(local_1.into()));\n+                }\n+                _ => unreachable!(),\n+            }\n+            s1.make_nop();\n+            s2.make_nop();\n+        }\n+    }\n+}\n+\n+/// Match on:\n+/// ```rust\n+/// _LOCAL_INTO = ((_LOCAL_FROM as Variant).FIELD: TY);\n+/// ```\n+fn match_get_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local, VarField<'tcx>)> {\n+    match &stmt.kind {\n+        StatementKind::Assign(box (place_into, rvalue_from)) => match rvalue_from {\n+            Rvalue::Use(Operand::Copy(pf)) | Rvalue::Use(Operand::Move(pf)) => {\n+                let local_into = place_into.as_local()?;\n+                let (local_from, vf) = match_variant_field_place(&pf)?;\n+                Some((local_into, local_from, vf))\n+            }\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Match on:\n+/// ```rust\n+/// ((_LOCAL_FROM as Variant).FIELD: TY) = move _LOCAL_INTO;\n+/// ```\n+fn match_set_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local, VarField<'tcx>)> {\n+    match &stmt.kind {\n+        StatementKind::Assign(box (place_from, rvalue_into)) => match rvalue_into {\n+            Rvalue::Use(Operand::Move(place_into)) => {\n+                let local_into = place_into.as_local()?;\n+                let (local_from, vf) = match_variant_field_place(&place_from)?;\n+                Some((local_into, local_from, vf))\n+            }\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Match on:\n+/// ```rust\n+/// discriminant(_LOCAL_TO_SET) = VAR_IDX;\n+/// ```\n+fn match_set_discr<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, VariantIdx)> {\n+    match &stmt.kind {\n+        StatementKind::SetDiscriminant { place, variant_index } => Some((\n+            place.as_local()?,\n+            *variant_index\n+        )),\n+        _ => None,\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+struct VarField<'tcx> {\n+    field: Field,\n+    field_ty: Ty<'tcx>,\n+    var_idx: VariantIdx,\n+}\n+\n+/// Match on `((_LOCAL as Variant).FIELD: TY)`.\n+fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n+    match place.as_ref() {\n+        PlaceRef {\n+            base: &PlaceBase::Local(local),\n+            projection: &[ProjectionElem::Downcast(_, var_idx), ProjectionElem::Field(field, ty)],\n+        } => Some((local, VarField { field, field_ty: ty, var_idx })),\n+        _ => None,\n+    }\n+}\n+\n+/// Simplifies `SwitchInt(_) -> [targets]`,\n+/// where all the `targets` have the same form,\n+/// into `goto -> target_first`.\n+pub struct SimplifyBranchSame;\n+\n+impl<'tcx> MirPass<'tcx> for SimplifyBranchSame {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        let mut did_remove_blocks = false;\n+        let bbs = body.basic_blocks_mut();\n+        for bb_idx in bbs.indices() {\n+            let targets = match &bbs[bb_idx].terminator().kind {\n+                TerminatorKind::SwitchInt { targets, .. } => targets,\n+                _ => continue,\n+            };\n+\n+            let mut iter_bbs_reachable = targets\n+                .iter()\n+                .map(|idx| (*idx, &bbs[*idx]))\n+                .filter(|(_, bb)| {\n+                    // Reaching `unreachable` is UB so assume it doesn't happen.\n+                    bb.terminator().kind != TerminatorKind::Unreachable\n+                    // But `asm!(...)` could abort the program,\n+                    // so we cannot assume that the `unreachable` terminator itself is reachable.\n+                    // FIXME(Centril): use a normalization pass instead of a check.\n+                    || bb.statements.iter().any(|stmt| match stmt.kind {\n+                        StatementKind::InlineAsm(..) => true,\n+                        _ => false,\n+                    })\n+                })\n+                .peekable();\n+\n+            // We want to `goto -> bb_first`.\n+            let bb_first = iter_bbs_reachable\n+                .peek()\n+                .map(|(idx, _)| *idx)\n+                .unwrap_or(targets[0]);\n+\n+            // All successor basic blocks should have the exact same form.\n+            let all_successors_equivalent = iter_bbs_reachable\n+                .map(|(_, bb)| bb)\n+                .tuple_windows()\n+                .all(|(bb_l, bb_r)| {\n+                    bb_l.is_cleanup == bb_r.is_cleanup\n+                    && bb_l.terminator().kind == bb_r.terminator().kind\n+                    && bb_l.statements.iter().eq_by(&bb_r.statements, |x, y| x.kind == y.kind)\n+                });\n+\n+            if all_successors_equivalent {\n+                // Replace `SwitchInt(..) -> [bb_first, ..];` with a `goto -> bb_first;`.\n+                bbs[bb_idx].terminator_mut().kind = TerminatorKind::Goto { target: bb_first };\n+                did_remove_blocks = true;\n+            }\n+        }\n+\n+        if did_remove_blocks {\n+            // We have dead blocks now, so remove those.\n+            simplify::remove_dead_blocks(body);\n+        }\n+    }\n+}"}, {"sha": "b5ee5ba2394d93b24774eb0c35d14f9e05b42b07", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -9,19 +9,21 @@ pub enum E {\n \n // CHECK-LABEL: @exhaustive_match\n #[no_mangle]\n-pub fn exhaustive_match(e: E, unit: ()) {\n+pub fn exhaustive_match(e: E) -> u8 {\n // CHECK: switch{{.*}}, label %[[OTHERWISE:[a-zA-Z0-9_]+]] [\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: ]\n // CHECK: [[B]]:\n+// CHECK-NEXT: store i8 1, i8* %1, align 1\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n // CHECK: [[OTHERWISE]]:\n // CHECK-NEXT: unreachable\n // CHECK: [[A]]:\n+// CHECK-NEXT: store i8 0, i8* %1, align 1\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n     match e {\n-        E::A => unit,\n-        E::B => unit,\n+        E::A => 0,\n+        E::B => 1,\n     }\n }"}, {"sha": "30e7adfddf765a28f4ab73a75d784c0aae2666b3", "filename": "src/test/codegen/try_identity.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Ftest%2Fcodegen%2Ftry_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Ftest%2Fcodegen%2Ftry_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftry_identity.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -C no-prepopulate-passes -Z mir-opt-level=2\n+\n+// Ensure that `x?` has no overhead on `Result<T, E>` due to identity `match`es in lowering.\n+// This requires inlining to trigger the MIR optimizations in `SimplifyArmIdentity`.\n+\n+#![crate_type = \"lib\"]\n+\n+type R = Result<u64, i32>;\n+\n+#[no_mangle]\n+fn try_identity(x: R) -> R {\n+// CHECK: start:\n+// CHECK-NOT: br {{.*}}\n+// CHECK ret void\n+    let y = x?;\n+    Ok(y)\n+}"}, {"sha": "7911fbd0a984d5a93fa792840d871a1053a197d9", "filename": "src/test/mir-opt/simplify_try.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs?ref=abd69551bf8b8755b5e00d4f4d45ae5d4a0cd17d", "patch": "@@ -0,0 +1,193 @@\n+fn try_identity(x: Result<u32, i32>) -> Result<u32, i32> {\n+    let y = x?;\n+    Ok(y)\n+}\n+\n+fn main() {\n+    let _ = try_identity(Ok(0));\n+}\n+\n+// END RUST SOURCE\n+// START rustc.try_identity.SimplifyArmIdentity.before.mir\n+// fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     let mut _0: std::result::Result<u32, i32>;\n+//     let _2: u32;\n+//     let mut _3: std::result::Result<u32, i32>;\n+//     let mut _4: std::result::Result<u32, i32>;\n+//     let mut _5: isize;\n+//     let _6: i32;\n+//     let mut _7: !;\n+//     let mut _8: i32;\n+//     let mut _9: i32;\n+//     let _10: u32;\n+//     let mut _11: u32;\n+//     scope 1 {\n+//     }\n+//     scope 2 {\n+//         scope 3 {\n+//             scope 7 {\n+//             }\n+//             scope 8 {\n+//                 let mut _12: i32;\n+//             }\n+//         }\n+//     }\n+//     scope 4 {\n+//         scope 5 {\n+//         }\n+//     }\n+//     scope 6 {\n+//     }\n+//     bb0: {\n+//         _5 = discriminant(_1);\n+//         switchInt(move _5) -> [0isize: bb4, 1isize: bb2, otherwise: bb1];\n+//     }\n+//     bb1: {\n+//         unreachable;\n+//     }\n+//     bb2: {\n+//         _6 = ((_1 as Err).0: i32);\n+//         ((_0 as Err).0: i32) = move _6;\n+//         discriminant(_0) = 1;\n+//         goto -> bb3;\n+//     }\n+//     bb3: {\n+//         return;\n+//     }\n+//     bb4: {\n+//         _10 = ((_1 as Ok).0: u32);\n+//         ((_0 as Ok).0: u32) = move _10;\n+//         discriminant(_0) = 0;\n+//         goto -> bb3;\n+//     }\n+// }\n+// END rustc.try_identity.SimplifyArmIdentity.before.mir\n+\n+// START rustc.try_identity.SimplifyArmIdentity.after.mir\n+// fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     let mut _0: std::result::Result<u32, i32>;\n+//     let _2: u32;\n+//     let mut _3: std::result::Result<u32, i32>;\n+//     let mut _4: std::result::Result<u32, i32>;\n+//     let mut _5: isize;\n+//     let _6: i32;\n+//     let mut _7: !;\n+//     let mut _8: i32;\n+//     let mut _9: i32;\n+//     let _10: u32;\n+//     let mut _11: u32;\n+//     scope 1 {\n+//     }\n+//     scope 2 {\n+//         scope 3 {\n+//             scope 7 {\n+//             }\n+//             scope 8 {\n+//                 let mut _12: i32;\n+//             }\n+//         }\n+//     }\n+//     scope 4 {\n+//         scope 5 {\n+//         }\n+//     }\n+//     scope 6 {\n+//     }\n+//     bb0: {\n+//         _5 = discriminant(_1);\n+//         switchInt(move _5) -> [0isize: bb4, 1isize: bb2, otherwise: bb1];\n+//     }\n+//     bb1: {\n+//         unreachable;\n+//     }\n+//     bb2: {\n+//         _0 = move _1;\n+//         nop;\n+//         nop;\n+//         goto -> bb3;\n+//     }\n+//     bb3: {\n+//         return;\n+//     }\n+//     bb4: {\n+//         _0 = move _1;\n+//         nop;\n+//         nop;\n+//         goto -> bb3;\n+//     }\n+// }\n+// END rustc.try_identity.SimplifyArmIdentity.after.mir\n+\n+// START rustc.try_identity.SimplifyBranchSame.after.mir\n+// fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     let mut _0: std::result::Result<u32, i32>;\n+//     let _2: u32;\n+//     let mut _3: std::result::Result<u32, i32>;\n+//     let mut _4: std::result::Result<u32, i32>;\n+//     let mut _5: isize;\n+//     let _6: i32;\n+//     let mut _7: !;\n+//     let mut _8: i32;\n+//     let mut _9: i32;\n+//     let _10: u32;\n+//     let mut _11: u32;\n+//     scope 1 {\n+//     }\n+//     scope 2 {\n+//         scope 3 {\n+//             scope 7 {\n+//             }\n+//             scope 8 {\n+//                 let mut _12: i32;\n+//             }\n+//         }\n+//     }\n+//     scope 4 {\n+//         scope 5 {\n+//         }\n+//     }\n+//     scope 6 {\n+//     }\n+//     bb0: {\n+//         _5 = discriminant(_1);\n+//         goto -> bb2;\n+//     }\n+//     bb1: {\n+//         return;\n+//     }\n+//     bb2: {\n+//         _0 = move _1;\n+//         nop;\n+//         nop;\n+//         goto -> bb1;\n+//     }\n+// }\n+// END rustc.try_identity.SimplifyBranchSame.after.mir\n+\n+// START rustc.try_identity.SimplifyLocals.after.mir\n+// fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+//     let mut _0: std::result::Result<u32, i32>;\n+//     let mut _2: isize;\n+//     scope 1 {\n+//     }\n+//     scope 2 {\n+//         scope 3 {\n+//             scope 7 {\n+//             }\n+//             scope 8 {\n+//             }\n+//         }\n+//     }\n+//     scope 4 {\n+//         scope 5 {\n+//         }\n+//     }\n+//     scope 6 {\n+//     }\n+//     bb0: {\n+//         _2 = discriminant(_1);\n+//         _0 = move _1;\n+//         return;\n+//     }\n+// }\n+// END rustc.try_identity.SimplifyLocals.after.mir"}]}