{"sha": "226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNmNkNjhmMTMzMzlhZTAyZTYwNjk1N2ViZDFkMmEzZmIxZTdhYWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T02:10:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T18:43:12Z"}, "message": "librustc: De-implicit-self the visitor. r=graydon", "tree": {"sha": "5212b8e9597b8e5f651bc0bff5ab13e05dd325ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5212b8e9597b8e5f651bc0bff5ab13e05dd325ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "html_url": "https://github.com/rust-lang/rust/commit/226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ce74460e6a5c8045a7b43b86a656f28354f4b0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce74460e6a5c8045a7b43b86a656f28354f4b0c", "html_url": "https://github.com/rust-lang/rust/commit/6ce74460e6a5c8045a7b43b86a656f28354f4b0c"}], "stats": {"total": 1155, "additions": 956, "deletions": 199}, "files": [{"sha": "64bf8ef05ba2459e1a21fe39a695bf8767421ccb", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -35,6 +35,7 @@\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n #[allow(deprecated_pattern)];\n+#[allow(deprecated_self)];\n \n extern mod core(vers = \"0.6\");\n extern mod std(vers = \"0.6\");"}, {"sha": "1ac0bf4c0c5c053d36a83953cf53e5a31065cd70", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -52,6 +52,7 @@ Implicitly, all crates behave as if they included the following prologue:\n #[warn(deprecated_pattern)];\n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n+#[allow(deprecated_self)];\n \n /* The Prelude. */\n "}, {"sha": "94fc9e37a751904d06b899d44e8f43ae3c4339fc", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 436, "deletions": 4, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -75,6 +75,7 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V> {\n }\n \n /// Abstract type-directed pointer-movement using the MovePtr trait\n+#[cfg(stage0)]\n impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n     fn visit_bot() -> bool {\n         self.align_to::<()>();\n@@ -325,7 +326,8 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_enter_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_class(n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_class(n_fields, sz, align) {\n             return false;\n@@ -343,7 +345,8 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_leave_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_class(n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n         if ! self.inner.visit_leave_class(n_fields, sz, align) {\n             return false;\n         }\n@@ -394,7 +397,8 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint)\n+                     -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_enum(n_variants, sz, align) {\n             return false;\n@@ -433,7 +437,8 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_leave_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_enum(n_variants: uint, sz: uint, align: uint)\n+                     -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, sz, align) {\n             return false;\n         }\n@@ -494,3 +499,430 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n         true\n     }\n }\n+\n+/// Abstract type-directed pointer-movement using the MovePtr trait\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n+    fn visit_bot(&self) -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_bot() { return false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n+\n+    fn visit_nil(&self) -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_nil() { return false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n+\n+    fn visit_bool(&self) -> bool {\n+        self.align_to::<bool>();\n+        if ! self.inner.visit_bool() { return false; }\n+        self.bump_past::<bool>();\n+        true\n+    }\n+\n+    fn visit_int(&self) -> bool {\n+        self.align_to::<int>();\n+        if ! self.inner.visit_int() { return false; }\n+        self.bump_past::<int>();\n+        true\n+    }\n+\n+    fn visit_i8(&self) -> bool {\n+        self.align_to::<i8>();\n+        if ! self.inner.visit_i8() { return false; }\n+        self.bump_past::<i8>();\n+        true\n+    }\n+\n+    fn visit_i16(&self) -> bool {\n+        self.align_to::<i16>();\n+        if ! self.inner.visit_i16() { return false; }\n+        self.bump_past::<i16>();\n+        true\n+    }\n+\n+    fn visit_i32(&self) -> bool {\n+        self.align_to::<i32>();\n+        if ! self.inner.visit_i32() { return false; }\n+        self.bump_past::<i32>();\n+        true\n+    }\n+\n+    fn visit_i64(&self) -> bool {\n+        self.align_to::<i64>();\n+        if ! self.inner.visit_i64() { return false; }\n+        self.bump_past::<i64>();\n+        true\n+    }\n+\n+    fn visit_uint(&self) -> bool {\n+        self.align_to::<uint>();\n+        if ! self.inner.visit_uint() { return false; }\n+        self.bump_past::<uint>();\n+        true\n+    }\n+\n+    fn visit_u8(&self) -> bool {\n+        self.align_to::<u8>();\n+        if ! self.inner.visit_u8() { return false; }\n+        self.bump_past::<u8>();\n+        true\n+    }\n+\n+    fn visit_u16(&self) -> bool {\n+        self.align_to::<u16>();\n+        if ! self.inner.visit_u16() { return false; }\n+        self.bump_past::<u16>();\n+        true\n+    }\n+\n+    fn visit_u32(&self) -> bool {\n+        self.align_to::<u32>();\n+        if ! self.inner.visit_u32() { return false; }\n+        self.bump_past::<u32>();\n+        true\n+    }\n+\n+    fn visit_u64(&self) -> bool {\n+        self.align_to::<u64>();\n+        if ! self.inner.visit_u64() { return false; }\n+        self.bump_past::<u64>();\n+        true\n+    }\n+\n+    fn visit_float(&self) -> bool {\n+        self.align_to::<float>();\n+        if ! self.inner.visit_float() { return false; }\n+        self.bump_past::<float>();\n+        true\n+    }\n+\n+    fn visit_f32(&self) -> bool {\n+        self.align_to::<f32>();\n+        if ! self.inner.visit_f32() { return false; }\n+        self.bump_past::<f32>();\n+        true\n+    }\n+\n+    fn visit_f64(&self) -> bool {\n+        self.align_to::<f64>();\n+        if ! self.inner.visit_f64() { return false; }\n+        self.bump_past::<f64>();\n+        true\n+    }\n+\n+    fn visit_char(&self) -> bool {\n+        self.align_to::<char>();\n+        if ! self.inner.visit_char() { return false; }\n+        self.bump_past::<char>();\n+        true\n+    }\n+\n+    fn visit_str(&self) -> bool {\n+        self.align_to::<~str>();\n+        if ! self.inner.visit_str() { return false; }\n+        self.bump_past::<~str>();\n+        true\n+    }\n+\n+    fn visit_estr_box(&self) -> bool {\n+        self.align_to::<@str>();\n+        if ! self.inner.visit_estr_box() { return false; }\n+        self.bump_past::<@str>();\n+        true\n+    }\n+\n+    fn visit_estr_uniq(&self) -> bool {\n+        self.align_to::<~str>();\n+        if ! self.inner.visit_estr_uniq() { return false; }\n+        self.bump_past::<~str>();\n+        true\n+    }\n+\n+    fn visit_estr_slice(&self) -> bool {\n+        self.align_to::<&static/str>();\n+        if ! self.inner.visit_estr_slice() { return false; }\n+        self.bump_past::<&static/str>();\n+        true\n+    }\n+\n+    fn visit_estr_fixed(&self, n: uint,\n+                        sz: uint,\n+                        align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_box(mtbl, inner) { return false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n+    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<*u8>();\n+        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n+        self.bump_past::<*u8>();\n+        true\n+    }\n+\n+    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<&static/u8>();\n+        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n+        self.bump_past::<&static/u8>();\n+        true\n+    }\n+\n+    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<vec::UnboxedVecRepr>();\n+        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[u8]>();\n+        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        self.bump_past::<~[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<@[u8]>();\n+        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n+        self.bump_past::<@[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[u8]>();\n+        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n+        self.bump_past::<~[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<&static/[u8]>();\n+        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n+        self.bump_past::<&static/[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n+            return false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_enter_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_rec_field(&self, i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n+            return false;\n+        }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_enter_class(&self, n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_class(n_fields, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_class_field(&self, i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n+            return false;\n+        }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_class(&self, n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n+        if ! self.inner.visit_leave_class(n_fields, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_tup_field(i, inner) { return false; }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_enter_fn(&self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n+            return false\n+        }\n+        true\n+    }\n+\n+    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_leave_fn(&self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_enum(&self, n_variants: uint, sz: uint, align: uint)\n+                     -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_enum(n_variants, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_enum_variant(&self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        self.inner.push_ptr();\n+        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_enum_variant_field(i, inner) { return false; }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_enum_variant(&self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            return false;\n+        }\n+        self.inner.pop_ptr();\n+        true\n+    }\n+\n+    fn visit_leave_enum(&self, n_variants: uint, sz: uint, align: uint)\n+                     -> bool {\n+        if ! self.inner.visit_leave_enum(n_variants, sz, align) {\n+            return false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_trait(&self) -> bool {\n+        self.align_to::<TyVisitor>();\n+        if ! self.inner.visit_trait() { return false; }\n+        self.bump_past::<TyVisitor>();\n+        true\n+    }\n+\n+    fn visit_var(&self) -> bool {\n+        if ! self.inner.visit_var() { return false; }\n+        true\n+    }\n+\n+    fn visit_var_integral(&self) -> bool {\n+        if ! self.inner.visit_var_integral() { return false; }\n+        true\n+    }\n+\n+    fn visit_param(&self, i: uint) -> bool {\n+        if ! self.inner.visit_param(i) { return false; }\n+        true\n+    }\n+\n+    fn visit_self(&self) -> bool {\n+        self.align_to::<&static/u8>();\n+        if ! self.inner.visit_self() { return false; }\n+        self.align_to::<&static/u8>();\n+        true\n+    }\n+\n+    fn visit_type(&self) -> bool {\n+        if ! self.inner.visit_type() { return false; }\n+        true\n+    }\n+\n+    fn visit_opaque_box(&self) -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_opaque_box() { return false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_constr(&self, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_constr(inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_closure_ptr(&self, ck: uint) -> bool {\n+        self.align_to::<fn@()>();\n+        if ! self.inner.visit_closure_ptr(ck) { return false; }\n+        self.bump_past::<fn@()>();\n+        true\n+    }\n+}"}, {"sha": "75a572fa46444e07a7dac967580c4173db297e3e", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -265,6 +265,7 @@ impl ReprVisitor {\n \n }\n \n+#[cfg(stage0)]\n impl ReprVisitor : TyVisitor {\n     fn visit_bot() -> bool {\n         self.writer.write_str(\"!\");\n@@ -559,6 +560,310 @@ impl ReprVisitor : TyVisitor {\n     fn visit_closure_ptr(_ck: uint) -> bool { true }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl ReprVisitor : TyVisitor {\n+    fn visit_bot(&self) -> bool {\n+        self.writer.write_str(\"!\");\n+        true\n+    }\n+    fn visit_nil(&self) -> bool { self.write::<()>() }\n+    fn visit_bool(&self) -> bool { self.write::<bool>() }\n+    fn visit_int(&self) -> bool { self.write::<int>() }\n+    fn visit_i8(&self) -> bool { self.write::<i8>() }\n+    fn visit_i16(&self) -> bool { self.write::<i16>() }\n+    fn visit_i32(&self) -> bool { self.write::<i32>()  }\n+    fn visit_i64(&self) -> bool { self.write::<i64>() }\n+\n+    fn visit_uint(&self) -> bool { self.write::<uint>() }\n+    fn visit_u8(&self) -> bool { self.write::<u8>() }\n+    fn visit_u16(&self) -> bool { self.write::<u16>() }\n+    fn visit_u32(&self) -> bool { self.write::<u32>() }\n+    fn visit_u64(&self) -> bool { self.write::<u64>() }\n+\n+    fn visit_float(&self) -> bool { self.write::<float>() }\n+    fn visit_f32(&self) -> bool { self.write::<f32>() }\n+    fn visit_f64(&self) -> bool { self.write::<f64>() }\n+\n+    fn visit_char(&self) -> bool {\n+        do self.get::<char> |&ch| {\n+            self.writer.write_char('\\'');\n+            self.writer.write_escaped_char(ch);\n+            self.writer.write_char('\\'');\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_str(&self) -> bool { fail; }\n+\n+    fn visit_estr_box(&self) -> bool {\n+        do self.get::<@str> |s| {\n+            self.writer.write_char('@');\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+    fn visit_estr_uniq(&self) -> bool {\n+        do self.get::<~str> |s| {\n+            self.writer.write_char('~');\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+    fn visit_estr_slice(&self) -> bool {\n+        do self.get::<&str> |s| {\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_estr_fixed(&self, _n: uint, _sz: uint,\n+                        _align: uint) -> bool { fail; }\n+\n+    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('@');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<&managed::raw::BoxRepr> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, inner);\n+        }\n+    }\n+\n+    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('~');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<&managed::raw::BoxRepr> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, inner);\n+        }\n+    }\n+\n+    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool {\n+        do self.get::<*c_void> |p| {\n+            self.writer.write_str(fmt!(\"(0x%x as *())\",\n+                                       *p as uint));\n+        }\n+    }\n+\n+    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('&');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<*c_void> |p| {\n+            self.visit_ptr_inner(*p, inner);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { fail; }\n+\n+\n+    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<vec::UnboxedVecRepr> |b| {\n+            self.write_unboxed_vec_repr(mtbl, b, inner);\n+        }\n+    }\n+\n+    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&VecRepr> |b| {\n+            self.writer.write_char('@');\n+            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n+        }\n+    }\n+\n+    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&VecRepr> |b| {\n+            self.writer.write_char('~');\n+            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n+        }\n+    }\n+\n+    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<SliceRepr> |s| {\n+            self.writer.write_char('&');\n+            self.write_vec_range(mtbl, s.data, s.len, inner);\n+        }\n+    }\n+\n+    fn visit_evec_fixed(&self, _n: uint, sz: uint, _align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<u8> |b| {\n+            self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n+        }\n+    }\n+\n+    fn visit_enter_rec(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('{');\n+        true\n+    }\n+\n+    fn visit_rec_field(&self, i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.write_mut_qualifier(mtbl);\n+        self.writer.write_str(name);\n+        self.writer.write_str(\": \");\n+        self.visit_inner(inner);\n+        true\n+    }\n+\n+    fn visit_leave_rec(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('}');\n+        true\n+    }\n+\n+    fn visit_enter_class(&self, _n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('{');\n+        true\n+    }\n+    fn visit_class_field(&self, i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.write_mut_qualifier(mtbl);\n+        self.writer.write_str(name);\n+        self.writer.write_str(\": \");\n+        self.visit_inner(inner);\n+        true\n+    }\n+    fn visit_leave_class(&self, _n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('}');\n+        true\n+    }\n+\n+    fn visit_enter_tup(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('(');\n+        true\n+    }\n+    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.visit_inner(inner);\n+        true\n+    }\n+    fn visit_leave_tup(&self, _n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char(')');\n+        true\n+    }\n+\n+    fn visit_enter_enum(&self, n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool {\n+        if n_variants == 1 {\n+            self.var_stk.push(Degenerate)\n+        } else {\n+            self.var_stk.push(TagMatch)\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_enum_variant(&self, _variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        let mut write = false;\n+        match self.var_stk.pop() {\n+            Degenerate => {\n+                write = true;\n+                self.var_stk.push(Degenerate);\n+            }\n+            TagMatch | TagMismatch => {\n+                do self.get::<int>() |t| {\n+                    if disr_val == *t {\n+                        write = true;\n+                        self.var_stk.push(TagMatch);\n+                    } else {\n+                        self.var_stk.push(TagMismatch);\n+                    }\n+                };\n+                self.bump_past::<int>();\n+            }\n+        }\n+\n+        if write {\n+            self.writer.write_str(name);\n+            if n_fields > 0 {\n+                self.writer.write_char('(');\n+            }\n+        }\n+        true\n+    }\n+\n+    fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n+        match self.var_stk.last() {\n+            Degenerate | TagMatch => {\n+                if i != 0 {\n+                    self.writer.write_str(\", \");\n+                }\n+                if ! self.visit_inner(inner) {\n+                    return false;\n+                }\n+            }\n+            TagMismatch => ()\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum_variant(&self, _variant: uint,\n+                                _disr_val: int,\n+                                n_fields: uint,\n+                                _name: &str) -> bool {\n+        match self.var_stk.last() {\n+            Degenerate | TagMatch => {\n+                if n_fields > 0 {\n+                    self.writer.write_char(')');\n+                }\n+            }\n+            TagMismatch => ()\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum(&self, _n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool {\n+        self.var_stk.pop();\n+        true\n+    }\n+\n+    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n+        true\n+    }\n+    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool {\n+        true\n+    }\n+    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+\n+\n+    fn visit_trait(&self) -> bool { true }\n+    fn visit_var(&self) -> bool { true }\n+    fn visit_var_integral(&self) -> bool { true }\n+    fn visit_param(&self, _i: uint) -> bool { true }\n+    fn visit_self(&self) -> bool { true }\n+    fn visit_type(&self) -> bool { true }\n+\n+    fn visit_opaque_box(&self) -> bool {\n+        self.writer.write_char('@');\n+        do self.get::<&managed::raw::BoxRepr> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, b.header.type_desc);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_constr(&self, _inner: *TyDesc) -> bool { fail; }\n+\n+    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n+}\n+\n pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;"}, {"sha": "5ccac6f091accc7b99b6e2336eac6288b25aba4f", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -31,97 +31,97 @@ mod intrinsic {\n     };\n \n     trait TyVisitor {\n-        fn visit_bot() -> bool;\n-        fn visit_nil() -> bool;\n-        fn visit_bool() -> bool;\n-\n-        fn visit_int() -> bool;\n-        fn visit_i8() -> bool;\n-        fn visit_i16() -> bool;\n-        fn visit_i32() -> bool;\n-        fn visit_i64() -> bool;\n-\n-        fn visit_uint() -> bool;\n-        fn visit_u8() -> bool;\n-        fn visit_u16() -> bool;\n-        fn visit_u32() -> bool;\n-        fn visit_u64() -> bool;\n-\n-        fn visit_float() -> bool;\n-        fn visit_f32() -> bool;\n-        fn visit_f64() -> bool;\n-\n-        fn visit_char() -> bool;\n-        fn visit_str() -> bool;\n-\n-        fn visit_estr_box() -> bool;\n-        fn visit_estr_uniq() -> bool;\n-        fn visit_estr_slice() -> bool;\n-        fn visit_estr_fixed(n: uint, sz: uint, align: uint) -> bool;\n-\n-        fn visit_box(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_ptr(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool;\n-\n-        fn visit_vec(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_fixed(n: uint, sz: uint, align: uint,\n+        fn visit_bot(&self) -> bool;\n+        fn visit_nil(&self) -> bool;\n+        fn visit_bool(&self) -> bool;\n+\n+        fn visit_int(&self) -> bool;\n+        fn visit_i8(&self) -> bool;\n+        fn visit_i16(&self) -> bool;\n+        fn visit_i32(&self) -> bool;\n+        fn visit_i64(&self) -> bool;\n+\n+        fn visit_uint(&self) -> bool;\n+        fn visit_u8(&self) -> bool;\n+        fn visit_u16(&self) -> bool;\n+        fn visit_u32(&self) -> bool;\n+        fn visit_u64(&self) -> bool;\n+\n+        fn visit_float(&self) -> bool;\n+        fn visit_f32(&self) -> bool;\n+        fn visit_f64(&self) -> bool;\n+\n+        fn visit_char(&self) -> bool;\n+        fn visit_str(&self) -> bool;\n+\n+        fn visit_estr_box(&self) -> bool;\n+        fn visit_estr_uniq(&self) -> bool;\n+        fn visit_estr_slice(&self) -> bool;\n+        fn visit_estr_fixed(&self, n: uint, sz: uint, align: uint) -> bool;\n+\n+        fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+\n+        fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+        fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n                             mtbl: uint, inner: *TyDesc) -> bool;\n \n-        fn visit_enter_rec(n_fields: uint,\n+        fn visit_enter_rec(&self, n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n-        fn visit_rec_field(i: uint, name: &str,\n+        fn visit_rec_field(&self, i: uint, name: &str,\n                            mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_rec(n_fields: uint,\n+        fn visit_leave_rec(&self, n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_class(n_fields: uint,\n+        fn visit_enter_class(&self, n_fields: uint,\n                              sz: uint, align: uint) -> bool;\n-        fn visit_class_field(i: uint, name: &str,\n+        fn visit_class_field(&self, i: uint, name: &str,\n                              mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_class(n_fields: uint,\n+        fn visit_leave_class(&self, n_fields: uint,\n                              sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_tup(n_fields: uint,\n+        fn visit_enter_tup(&self, n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n-        fn visit_tup_field(i: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_tup(n_fields: uint,\n+        fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool;\n+        fn visit_leave_tup(&self, n_fields: uint,\n                            sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_enum(n_variants: uint,\n+        fn visit_enter_enum(&self, n_variants: uint,\n                             sz: uint, align: uint) -> bool;\n-        fn visit_enter_enum_variant(variant: uint,\n+        fn visit_enter_enum_variant(&self, variant: uint,\n                                     disr_val: int,\n                                     n_fields: uint,\n                                     name: &str) -> bool;\n-        fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_enum_variant(variant: uint,\n+        fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool;\n+        fn visit_leave_enum_variant(&self, variant: uint,\n                                     disr_val: int,\n                                     n_fields: uint,\n                                     name: &str) -> bool;\n-        fn visit_leave_enum(n_variants: uint,\n+        fn visit_leave_enum(&self, n_variants: uint,\n                             sz: uint, align: uint) -> bool;\n \n-        fn visit_enter_fn(purity: uint, proto: uint,\n+        fn visit_enter_fn(&self, purity: uint, proto: uint,\n                           n_inputs: uint, retstyle: uint) -> bool;\n-        fn visit_fn_input(i: uint, mode: uint, inner: *TyDesc) -> bool;\n-        fn visit_fn_output(retstyle: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_fn(purity: uint, proto: uint,\n+        fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n+        fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool;\n+        fn visit_leave_fn(&self, purity: uint, proto: uint,\n                           n_inputs: uint, retstyle: uint) -> bool;\n \n-        fn visit_trait() -> bool;\n-        fn visit_var() -> bool;\n-        fn visit_var_integral() -> bool;\n-        fn visit_param(i: uint) -> bool;\n-        fn visit_self() -> bool;\n-        fn visit_type() -> bool;\n-        fn visit_opaque_box() -> bool;\n-        fn visit_constr(inner: *TyDesc) -> bool;\n-        fn visit_closure_ptr(ck: uint) -> bool;\n+        fn visit_trait(&self) -> bool;\n+        fn visit_var(&self) -> bool;\n+        fn visit_var_integral(&self) -> bool;\n+        fn visit_param(&self, i: uint) -> bool;\n+        fn visit_self(&self) -> bool;\n+        fn visit_type(&self) -> bool;\n+        fn visit_opaque_box(&self) -> bool;\n+        fn visit_constr(&self, inner: *TyDesc) -> bool;\n+        fn visit_closure_ptr(&self, ck: uint) -> bool;\n     }\n \n     #[abi = \"rust-intrinsic\"]"}, {"sha": "af490aef3f470f2ca7209eeab8eaeef00185e577", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -233,7 +233,7 @@ fn get_lint_dict() -> lint_dict {\n         (~\"deprecated_self\",\n          @{lint: deprecated_self,\n            desc: \"warn about deprecated uses of `self`\",\n-           default: allow}),\n+           default: warn}),\n \n         /* FIXME(#3266)--make liveness warnings lintable\n         (~\"unused_variable\",\n@@ -631,13 +631,18 @@ fn check_item_deprecated_self(cx: ty::ctxt, item: @ast::item) {\n     fn maybe_warn(cx: ty::ctxt,\n                   item: @ast::item,\n                   self_ty: ast::self_ty) {\n-        cx.sess.span_lint(\n-            deprecated_self,\n-            item.id,\n-            item.id,\n-            self_ty.span,\n-            ~\"this method form is deprecated; use an explicit `self` \\\n-              parameter or mark the method as static\");\n+        match self_ty.node {\n+            ast::sty_by_ref => {\n+                cx.sess.span_lint(\n+                    deprecated_self,\n+                    item.id,\n+                    item.id,\n+                    self_ty.span,\n+                    ~\"this method form is deprecated; use an explicit `self` \\\n+                      parameter or mark the method as static\");\n+            }\n+            _ => {}\n+        }\n     }\n \n     match /*bad*/copy item.node {"}, {"sha": "ba9ff3a4f98bb043511100abb5398f67952de595", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -105,7 +105,8 @@ impl reflector {\n                                                       mth_idx,\n                                                       v,\n                                                       ty::vstore_box,\n-                                                      ast::sty_by_ref),\n+                                                      ast::sty_region(\n+                                                        ast::m_imm)),\n             ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n         let next_bcx = sub_block(bcx, ~\"next\");"}, {"sha": "059ada8b46efcee3de76ba7b54a7fafb58759e95", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -26,6 +26,7 @@\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n #[warn(deprecated_pattern)];\n+#[allow(deprecated_self)];\n \n #[no_core];\n "}, {"sha": "ce42910f7019174c0378826c130b40b370d92577", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -27,6 +27,7 @@\n #[allow(non_implicitly_copyable_typarams)];\n #[allow(deprecated_mode)];\n #[allow(deprecated_pattern)];\n+#[allow(deprecated_self)];\n \n extern mod core(vers = \"0.6\");\n extern mod std(vers = \"0.6\");"}, {"sha": "51b55b1c46fd2f10ae8a0dbdc171517515d9053d", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -32,6 +32,7 @@ not required in or otherwise suitable for the core library.\n // that can't be silenced otherwise. Most every module is set to forbid\n #[allow(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n+#[allow(deprecated_self)];\n \n \n // Transitional"}, {"sha": "13b32d52f119342a7b9cff0ff24c9fb84a062a89", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -24,6 +24,7 @@\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n #[warn(deprecated_pattern)];\n+#[allow(deprecated_self)];\n \n #[no_core];\n "}, {"sha": "1350c3e3ad1cd5459245b819f8f89b02487a4b7b", "filename": "src/test/compile-fail/lint-default-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Ftest%2Fcompile-fail%2Flint-default-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Ftest%2Fcompile-fail%2Flint-default-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-default-methods.rs?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -1,7 +1,7 @@\n #[forbid(default_methods)];\n \n trait Foo { //~ ERROR default methods are experimental\n-    fn bar() { io::println(\"hi\"); }\n+    fn bar(&self) { io::println(\"hi\"); }\n }\n \n fn main() {}"}, {"sha": "c7c1a6bb331957ea4f554530ef32c9814e0d9687", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 127, "deletions": 119, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226cd68f13339ae02e606957ebd1d2a3fb1e7aad/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=226cd68f13339ae02e606957ebd1d2a3fb1e7aad", "patch": "@@ -61,154 +61,154 @@ impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V> {\n \n impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V>: TyVisitor {\n \n-    fn visit_bot() -> bool {\n+    fn visit_bot(&self) -> bool {\n         self.align_to::<()>();\n         if ! self.inner.visit_bot() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n-    fn visit_nil() -> bool {\n+    fn visit_nil(&self) -> bool {\n         self.align_to::<()>();\n         if ! self.inner.visit_nil() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n-    fn visit_bool() -> bool {\n+    fn visit_bool(&self) -> bool {\n         self.align_to::<bool>();\n         if ! self.inner.visit_bool() { return false; }\n         self.bump_past::<bool>();\n         true\n     }\n \n-    fn visit_int() -> bool {\n+    fn visit_int(&self) -> bool {\n         self.align_to::<int>();\n         if ! self.inner.visit_int() { return false; }\n         self.bump_past::<int>();\n         true\n     }\n \n-    fn visit_i8() -> bool {\n+    fn visit_i8(&self) -> bool {\n         self.align_to::<i8>();\n         if ! self.inner.visit_i8() { return false; }\n         self.bump_past::<i8>();\n         true\n     }\n \n-    fn visit_i16() -> bool {\n+    fn visit_i16(&self) -> bool {\n         self.align_to::<i16>();\n         if ! self.inner.visit_i16() { return false; }\n         self.bump_past::<i16>();\n         true\n     }\n \n-    fn visit_i32() -> bool {\n+    fn visit_i32(&self) -> bool {\n         self.align_to::<i32>();\n         if ! self.inner.visit_i32() { return false; }\n         self.bump_past::<i32>();\n         true\n     }\n \n-    fn visit_i64() -> bool {\n+    fn visit_i64(&self) -> bool {\n         self.align_to::<i64>();\n         if ! self.inner.visit_i64() { return false; }\n         self.bump_past::<i64>();\n         true\n     }\n \n-    fn visit_uint() -> bool {\n+    fn visit_uint(&self) -> bool {\n         self.align_to::<uint>();\n         if ! self.inner.visit_uint() { return false; }\n         self.bump_past::<uint>();\n         true\n     }\n \n-    fn visit_u8() -> bool {\n+    fn visit_u8(&self) -> bool {\n         self.align_to::<u8>();\n         if ! self.inner.visit_u8() { return false; }\n         self.bump_past::<u8>();\n         true\n     }\n \n-    fn visit_u16() -> bool {\n+    fn visit_u16(&self) -> bool {\n         self.align_to::<u16>();\n         if ! self.inner.visit_u16() { return false; }\n         self.bump_past::<u16>();\n         true\n     }\n \n-    fn visit_u32() -> bool {\n+    fn visit_u32(&self) -> bool {\n         self.align_to::<u32>();\n         if ! self.inner.visit_u32() { return false; }\n         self.bump_past::<u32>();\n         true\n     }\n \n-    fn visit_u64() -> bool {\n+    fn visit_u64(&self) -> bool {\n         self.align_to::<u64>();\n         if ! self.inner.visit_u64() { return false; }\n         self.bump_past::<u64>();\n         true\n     }\n \n-    fn visit_float() -> bool {\n+    fn visit_float(&self) -> bool {\n         self.align_to::<float>();\n         if ! self.inner.visit_float() { return false; }\n         self.bump_past::<float>();\n         true\n     }\n \n-    fn visit_f32() -> bool {\n+    fn visit_f32(&self) -> bool {\n         self.align_to::<f32>();\n         if ! self.inner.visit_f32() { return false; }\n         self.bump_past::<f32>();\n         true\n     }\n \n-    fn visit_f64() -> bool {\n+    fn visit_f64(&self) -> bool {\n         self.align_to::<f64>();\n         if ! self.inner.visit_f64() { return false; }\n         self.bump_past::<f64>();\n         true\n     }\n \n-    fn visit_char() -> bool {\n+    fn visit_char(&self) -> bool {\n         self.align_to::<char>();\n         if ! self.inner.visit_char() { return false; }\n         self.bump_past::<char>();\n         true\n     }\n \n-    fn visit_str() -> bool {\n+    fn visit_str(&self) -> bool {\n         self.align_to::<~str>();\n         if ! self.inner.visit_str() { return false; }\n         self.bump_past::<~str>();\n         true\n     }\n \n-    fn visit_estr_box() -> bool {\n+    fn visit_estr_box(&self) -> bool {\n         self.align_to::<@str>();\n         if ! self.inner.visit_estr_box() { return false; }\n         self.bump_past::<@str>();\n         true\n     }\n \n-    fn visit_estr_uniq() -> bool {\n+    fn visit_estr_uniq(&self) -> bool {\n         self.align_to::<~str>();\n         if ! self.inner.visit_estr_uniq() { return false; }\n         self.bump_past::<~str>();\n         true\n     }\n \n-    fn visit_estr_slice() -> bool {\n+    fn visit_estr_slice(&self) -> bool {\n         self.align_to::<&static/str>();\n         if ! self.inner.visit_estr_slice() { return false; }\n         self.bump_past::<&static/str>();\n         true\n     }\n \n-    fn visit_estr_fixed(n: uint,\n+    fn visit_estr_fixed(&self, n: uint,\n                         sz: uint,\n                         align: uint) -> bool {\n         self.align(align);\n@@ -217,35 +217,35 @@ impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_box(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@u8>();\n         if ! self.inner.visit_box(mtbl, inner) { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n-    fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n         if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n-    fn visit_ptr(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n         self.bump_past::<*u8>();\n         true\n     }\n \n-    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&static/u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n         self.bump_past::<&static/u8>();\n         true\n     }\n \n-    fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<UnboxedVecRepr>();\n         // FIXME (#3732): Inner really has to move its own pointers on this one.\n         // or else possibly we could have some weird interface wherein we\n@@ -255,35 +255,35 @@ impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_vec(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n         if ! self.inner.visit_vec(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n-    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@[u8]>();\n         if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n         self.bump_past::<@[u8]>();\n         true\n     }\n \n-    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n         if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n-    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&static/[u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n         self.bump_past::<&static/[u8]>();\n         true\n     }\n \n-    fn visit_evec_fixed(n: uint, sz: uint, align: uint,\n+    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool {\n         self.align(align);\n         if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n@@ -293,95 +293,98 @@ impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_enter_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_rec_field(i: uint, name: &str,\n+    fn visit_rec_field(&self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_rec_field(i, name, mtbl, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_enter_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_class(&self, n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_class(n_fields, sz, align) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_class_field(i: uint, name: &str,\n+    fn visit_class_field(&self, i: uint, name: &str,\n                          mtbl: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_leave_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_class(&self, n_fields: uint, sz: uint, align: uint)\n+                      -> bool {\n         if ! self.inner.visit_leave_class(n_fields, sz, align) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_enter_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_tup_field(i, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_enter_fn(purity: uint, proto: uint,\n+    fn visit_enter_fn(&self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n             return false\n         }\n         true\n     }\n \n-    fn visit_fn_input(i: uint, mode: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n         true\n     }\n \n-    fn visit_fn_output(retstyle: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_fn(purity: uint, proto: uint,\n+    fn visit_leave_fn(&self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n         if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n             return false;\n         }\n         true\n     }\n \n-    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+    fn visit_enter_enum(&self, n_variants: uint, sz: uint, align: uint)\n+                     -> bool {\n         self.align(align);\n         if ! self.inner.visit_enter_enum(n_variants, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_enter_enum_variant(variant: uint,\n+    fn visit_enter_enum_variant(&self, variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n@@ -392,12 +395,12 @@ impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n+    fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_enum_variant_field(i, inner) { return false; }\n         true\n     }\n \n-    fn visit_leave_enum_variant(variant: uint,\n+    fn visit_leave_enum_variant(&self, variant: uint,\n                                 disr_val: int,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n@@ -408,58 +411,59 @@ impl<V: TyVisitor movable_ptr> ptr_visit_adaptor<V>: TyVisitor {\n         true\n     }\n \n-    fn visit_leave_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+    fn visit_leave_enum(&self, n_variants: uint, sz: uint, align: uint)\n+                     -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, sz, align) { return false; }\n         true\n     }\n \n-    fn visit_trait() -> bool {\n+    fn visit_trait(&self) -> bool {\n         self.align_to::<TyVisitor>();\n         if ! self.inner.visit_trait() { return false; }\n         self.bump_past::<TyVisitor>();\n         true\n     }\n \n-    fn visit_var() -> bool {\n+    fn visit_var(&self) -> bool {\n         if ! self.inner.visit_var() { return false; }\n         true\n     }\n \n-    fn visit_var_integral() -> bool {\n+    fn visit_var_integral(&self) -> bool {\n         if ! self.inner.visit_var_integral() { return false; }\n         true\n     }\n \n-    fn visit_param(i: uint) -> bool {\n+    fn visit_param(&self, i: uint) -> bool {\n         if ! self.inner.visit_param(i) { return false; }\n         true\n     }\n \n-    fn visit_self() -> bool {\n+    fn visit_self(&self) -> bool {\n         self.align_to::<&static/u8>();\n         if ! self.inner.visit_self() { return false; }\n         self.align_to::<&static/u8>();\n         true\n     }\n \n-    fn visit_type() -> bool {\n+    fn visit_type(&self) -> bool {\n         if ! self.inner.visit_type() { return false; }\n         true\n     }\n \n-    fn visit_opaque_box() -> bool {\n+    fn visit_opaque_box(&self) -> bool {\n         self.align_to::<@u8>();\n         if ! self.inner.visit_opaque_box() { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n-    fn visit_constr(inner: *TyDesc) -> bool {\n+    fn visit_constr(&self, inner: *TyDesc) -> bool {\n         if ! self.inner.visit_constr(inner) { return false; }\n         true\n     }\n \n-    fn visit_closure_ptr(ck: uint) -> bool {\n+    fn visit_closure_ptr(&self, ck: uint) -> bool {\n         self.align_to::<fn@()>();\n         if ! self.inner.visit_closure_ptr(ck) { return false; }\n         self.bump_past::<fn@()>();\n@@ -503,121 +507,125 @@ impl my_visitor: movable_ptr {\n \n impl my_visitor: TyVisitor {\n \n-    fn visit_bot() -> bool { true }\n-    fn visit_nil() -> bool { true }\n-    fn visit_bool() -> bool {\n+    fn visit_bot(&self) -> bool { true }\n+    fn visit_nil(&self) -> bool { true }\n+    fn visit_bool(&self) -> bool {\n       do self.get::<bool>() |b| {\n             self.vals += ~[bool::to_str(b)];\n       };\n       true\n     }\n-    fn visit_int() -> bool {\n+    fn visit_int(&self) -> bool {\n       do self.get::<int>() |i| {\n             self.vals += ~[int::to_str(i, 10u)];\n       };\n       true\n     }\n-    fn visit_i8() -> bool { true }\n-    fn visit_i16() -> bool { true }\n-    fn visit_i32() -> bool { true }\n-    fn visit_i64() -> bool { true }\n+    fn visit_i8(&self) -> bool { true }\n+    fn visit_i16(&self) -> bool { true }\n+    fn visit_i32(&self) -> bool { true }\n+    fn visit_i64(&self) -> bool { true }\n \n-    fn visit_uint() -> bool { true }\n-    fn visit_u8() -> bool { true }\n-    fn visit_u16() -> bool { true }\n-    fn visit_u32() -> bool { true }\n-    fn visit_u64() -> bool { true }\n+    fn visit_uint(&self) -> bool { true }\n+    fn visit_u8(&self) -> bool { true }\n+    fn visit_u16(&self) -> bool { true }\n+    fn visit_u32(&self) -> bool { true }\n+    fn visit_u64(&self) -> bool { true }\n \n-    fn visit_float() -> bool { true }\n-    fn visit_f32() -> bool { true }\n-    fn visit_f64() -> bool { true }\n+    fn visit_float(&self) -> bool { true }\n+    fn visit_f32(&self) -> bool { true }\n+    fn visit_f64(&self) -> bool { true }\n \n-    fn visit_char() -> bool { true }\n-    fn visit_str() -> bool { true }\n+    fn visit_char(&self) -> bool { true }\n+    fn visit_str(&self) -> bool { true }\n \n-    fn visit_estr_box() -> bool { true }\n-    fn visit_estr_uniq() -> bool { true }\n-    fn visit_estr_slice() -> bool { true }\n-    fn visit_estr_fixed(_n: uint, _sz: uint,\n+    fn visit_estr_box(&self) -> bool { true }\n+    fn visit_estr_uniq(&self) -> bool { true }\n+    fn visit_estr_slice(&self) -> bool { true }\n+    fn visit_estr_fixed(&self, _n: uint, _sz: uint,\n                         _align: uint) -> bool { true }\n \n-    fn visit_box(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_ptr(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_rptr(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-\n-    fn visit_vec(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_unboxed_vec(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_box(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_slice(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_fixed(_n: uint, _sz: uint, _align: uint,\n+    fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+\n+    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_unboxed_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_slice(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_fixed(&self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n-    fn visit_enter_rec(_n_fields: uint,\n+    fn visit_enter_rec(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_rec_field(_i: uint, _name: &str,\n+    fn visit_rec_field(&self, _i: uint, _name: &str,\n                        _mtbl: uint, inner: *TyDesc) -> bool {\n         error!(\"rec field!\");\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_rec(_n_fields: uint,\n+    fn visit_leave_rec(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_class(_n_fields: uint,\n+    fn visit_enter_class(&self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n-    fn visit_class_field(_i: uint, _name: &str,\n+    fn visit_class_field(&self, _i: uint, _name: &str,\n                          _mtbl: uint, inner: *TyDesc) -> bool {\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_class(_n_fields: uint,\n+    fn visit_leave_class(&self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_tup(_n_fields: uint,\n+    fn visit_enter_tup(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(_i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&self, _i: uint, inner: *TyDesc) -> bool {\n         error!(\"tup field!\");\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_tup(_n_fields: uint,\n+    fn visit_leave_tup(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_enum(_n_variants: uint,\n+    fn visit_enter_enum(&self, _n_variants: uint,\n                         _sz: uint, _align: uint) -> bool {\n         // FIXME (#3732): this needs to rewind between enum variants, or something.\n         true\n     }\n-    fn visit_enter_enum_variant(_variant: uint,\n+    fn visit_enter_enum_variant(&self, _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(_i: uint, inner: *TyDesc) -> bool {\n+    fn visit_enum_variant_field(&self, _i: uint, inner: *TyDesc) -> bool {\n         self.visit_inner(inner)\n     }\n-    fn visit_leave_enum_variant(_variant: uint,\n+    fn visit_leave_enum_variant(&self, _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_leave_enum(_n_variants: uint,\n+    fn visit_leave_enum(&self, _n_variants: uint,\n                         _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_fn(_purity: uint, _proto: uint,\n+    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(_i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(_retstyle: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n+    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n+        true\n+    }\n+    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool {\n+        true\n+    }\n+    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n \n \n-    fn visit_trait() -> bool { true }\n-    fn visit_var() -> bool { true }\n-    fn visit_var_integral() -> bool { true }\n-    fn visit_param(_i: uint) -> bool { true }\n-    fn visit_self() -> bool { true }\n-    fn visit_type() -> bool { true }\n-    fn visit_opaque_box() -> bool { true }\n-    fn visit_constr(_inner: *TyDesc) -> bool { true }\n-    fn visit_closure_ptr(_ck: uint) -> bool { true }\n+    fn visit_trait(&self) -> bool { true }\n+    fn visit_var(&self) -> bool { true }\n+    fn visit_var_integral(&self) -> bool { true }\n+    fn visit_param(&self, _i: uint) -> bool { true }\n+    fn visit_self(&self) -> bool { true }\n+    fn visit_type(&self) -> bool { true }\n+    fn visit_opaque_box(&self) -> bool { true }\n+    fn visit_constr(&self, _inner: *TyDesc) -> bool { true }\n+    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n }\n \n fn get_tydesc_for<T>(&&_t: T) -> *TyDesc {"}]}