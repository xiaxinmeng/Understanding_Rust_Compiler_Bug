{"sha": "eb4fc640b0f881e240ad0ebb9d05f56547e42036", "node_id": "C_kwDOAAsO6NoAKGViNGZjNjQwYjBmODgxZTI0MGFkMGViYjlkMDVmNTY1NDdlNDIwMzY", "commit": {"author": {"name": "woppopo", "email": "woppopo@protonmail.com", "date": "2021-12-23T13:03:12Z"}, "committer": {"name": "woppopo", "email": "woppopo@protonmail.com", "date": "2021-12-23T13:03:12Z"}, "message": "Constify `Box<T, A>` methods", "tree": {"sha": "686c6b42f18aa6fa98a408088a2ee2029446dc77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/686c6b42f18aa6fa98a408088a2ee2029446dc77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb4fc640b0f881e240ad0ebb9d05f56547e42036", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4fc640b0f881e240ad0ebb9d05f56547e42036", "html_url": "https://github.com/rust-lang/rust/commit/eb4fc640b0f881e240ad0ebb9d05f56547e42036", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb4fc640b0f881e240ad0ebb9d05f56547e42036/comments", "author": {"login": "lilasta", "id": 77098789, "node_id": "MDQ6VXNlcjc3MDk4Nzg5", "avatar_url": "https://avatars.githubusercontent.com/u/77098789?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilasta", "html_url": "https://github.com/lilasta", "followers_url": "https://api.github.com/users/lilasta/followers", "following_url": "https://api.github.com/users/lilasta/following{/other_user}", "gists_url": "https://api.github.com/users/lilasta/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilasta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilasta/subscriptions", "organizations_url": "https://api.github.com/users/lilasta/orgs", "repos_url": "https://api.github.com/users/lilasta/repos", "events_url": "https://api.github.com/users/lilasta/events{/privacy}", "received_events_url": "https://api.github.com/users/lilasta/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilasta", "id": 77098789, "node_id": "MDQ6VXNlcjc3MDk4Nzg5", "avatar_url": "https://avatars.githubusercontent.com/u/77098789?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilasta", "html_url": "https://github.com/lilasta", "followers_url": "https://api.github.com/users/lilasta/followers", "following_url": "https://api.github.com/users/lilasta/following{/other_user}", "gists_url": "https://api.github.com/users/lilasta/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilasta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilasta/subscriptions", "organizations_url": "https://api.github.com/users/lilasta/orgs", "repos_url": "https://api.github.com/users/lilasta/repos", "events_url": "https://api.github.com/users/lilasta/events{/privacy}", "received_events_url": "https://api.github.com/users/lilasta/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69ac533527025fffa37ad1bc4d82b3bc65f90264", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ac533527025fffa37ad1bc4d82b3bc65f90264", "html_url": "https://github.com/rust-lang/rust/commit/69ac533527025fffa37ad1bc4d82b3bc65f90264"}], "stats": {"total": 256, "additions": 224, "deletions": 32}, "files": [{"sha": "fd4b37ca6a8326bba9dbe31404b0834b0722f158", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=eb4fc640b0f881e240ad0ebb9d05f56547e42036", "patch": "@@ -323,17 +323,21 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n \n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n // This signature has to be the same as `Box`, otherwise an ICE will happen.\n // When an additional parameter to `Box` is added (like `A: Allocator`), this has to be added here as\n // well.\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: Allocator>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: Allocator>(Unique<T>, A)` as well.\n-pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A) {\n+pub(crate) const unsafe fn box_free<T: ?Sized, A: ~const Allocator + ~const Drop>(\n+    ptr: Unique<T>,\n+    alloc: A,\n+) {\n     unsafe {\n         let size = size_of_val(ptr.as_ref());\n         let align = min_align_of_val(ptr.as_ref());\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        alloc.deallocate(ptr.cast().into(), layout)\n+        alloc.deallocate(From::from(ptr.cast()), layout)\n     }\n }\n \n@@ -361,13 +365,22 @@ extern \"Rust\" {\n /// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n /// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n #[cfg(all(not(no_global_oom_handling), not(test)))]\n #[rustc_allocator_nounwind]\n #[cold]\n-pub fn handle_alloc_error(layout: Layout) -> ! {\n-    unsafe {\n-        __rust_alloc_error_handler(layout.size(), layout.align());\n+pub const fn handle_alloc_error(layout: Layout) -> ! {\n+    const fn ct_error(_: Layout) -> ! {\n+        panic!(\"allocation failed\");\n     }\n+\n+    fn rt_error(layout: Layout) -> ! {\n+        unsafe {\n+            __rust_alloc_error_handler(layout.size(), layout.align());\n+        }\n+    }\n+\n+    unsafe { core::intrinsics::const_eval_select((layout,), ct_error, rt_error) }\n }\n \n // For alloc test `std::alloc::handle_alloc_error` can be used directly."}, {"sha": "59e4ebb181fe5a44f4e9543c0919eb423965dbff", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=eb4fc640b0f881e240ad0ebb9d05f56547e42036", "patch": "@@ -346,9 +346,13 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[must_use]\n     #[inline]\n-    pub fn new_in(x: T, alloc: A) -> Self {\n+    pub const fn new_in(x: T, alloc: A) -> Self\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let mut boxed = Self::new_uninit_in(alloc);\n         unsafe {\n             boxed.as_mut_ptr().write(x);\n@@ -372,8 +376,13 @@ impl<T, A: Allocator> Box<T, A> {\n     /// # Ok::<(), std::alloc::AllocError>(())\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError> {\n+    pub const fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n+    where\n+        T: ~const Drop,\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let mut boxed = Self::try_new_uninit_in(alloc)?;\n         unsafe {\n             boxed.as_mut_ptr().write(x);\n@@ -402,10 +411,14 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[cfg(not(no_global_oom_handling))]\n     #[must_use]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+    pub const fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n         // That would make code size bigger.\n@@ -439,7 +452,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+    pub const fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate(layout)?.cast();\n         unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n@@ -466,10 +483,14 @@ impl<T, A: Allocator> Box<T, A> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[cfg(not(no_global_oom_handling))]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n-    pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+    pub const fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n         // That would make code size bigger.\n@@ -503,7 +524,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+    pub const fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate_zeroed(layout)?.cast();\n         unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n@@ -513,20 +538,22 @@ impl<T, A: Allocator> Box<T, A> {\n     /// `x` will be pinned in memory and unable to be moved.\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[must_use]\n     #[inline(always)]\n-    pub fn pin_in(x: T, alloc: A) -> Pin<Self>\n+    pub const fn pin_in(x: T, alloc: A) -> Pin<Self>\n     where\n-        A: 'static,\n+        A: 'static + ~const Allocator + ~const Drop,\n     {\n-        Self::new_in(x, alloc).into()\n+        Self::into_pin(Self::new_in(x, alloc))\n     }\n \n     /// Converts a `Box<T>` into a `Box<[T]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n-    pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+    pub const fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(boxed);\n         unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n     }\n@@ -543,8 +570,12 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(Box::into_inner(c), 5);\n     /// ```\n     #[unstable(feature = \"box_into_inner\", issue = \"80437\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub fn into_inner(boxed: Self) -> T {\n+    pub const fn into_inner(boxed: Self) -> T\n+    where\n+        Self: ~const Drop,\n+    {\n         *boxed\n     }\n }\n@@ -758,8 +789,9 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub unsafe fn assume_init(self) -> Box<T, A> {\n+    pub const unsafe fn assume_init(self) -> Box<T, A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(self);\n         unsafe { Box::from_raw_in(raw as *mut T, alloc) }\n     }\n@@ -792,8 +824,9 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// }\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub fn write(mut boxed: Self, value: T) -> Box<T, A> {\n+    pub const fn write(mut boxed: Self, value: T) -> Box<T, A> {\n         unsafe {\n             (*boxed).write(value);\n             boxed.assume_init()\n@@ -938,8 +971,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// [memory layout]: self#memory-layout\n     /// [`Layout`]: crate::Layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n+    pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n     }\n \n@@ -1035,8 +1069,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     ///\n     /// [memory layout]: self#memory-layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n+    pub const fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n         let (leaked, alloc) = Box::into_unique(b);\n         (leaked.as_ptr(), alloc)\n     }\n@@ -1046,9 +1081,10 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n         issue = \"none\",\n         reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(b: Self) -> (Unique<T>, A) {\n+    pub const fn into_unique(b: Self) -> (Unique<T>, A) {\n         // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n         // raw pointer for the type system. Turning it directly into a raw pointer would not be\n         // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n@@ -1064,8 +1100,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// to call it as `Box::allocator(&b)` instead of `b.allocator()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub fn allocator(b: &Self) -> &A {\n+    pub const fn allocator(b: &Self) -> &A {\n         &b.1\n     }\n \n@@ -1105,8 +1142,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// assert_eq!(*static_ref, [4, 2, 3]);\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n     #[inline]\n-    pub fn leak<'a>(b: Self) -> &'a mut T\n+    pub const fn leak<'a>(b: Self) -> &'a mut T\n     where\n         A: 'a,\n     {\n@@ -1119,7 +1157,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     ///\n     /// This is also available via [`From`].\n     #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n-    pub fn into_pin(boxed: Self) -> Pin<Self>\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+    pub const fn into_pin(boxed: Self) -> Pin<Self>\n     where\n         A: 'static,\n     {\n@@ -1131,7 +1170,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> const Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // FIXME: Do nothing, drop is currently performed by compiler.\n     }\n@@ -1341,7 +1381,8 @@ impl<T> From<T> for Box<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: Allocator> From<Box<T, A>> for Pin<Box<T, A>>\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+impl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\n where\n     A: 'static,\n {\n@@ -1720,7 +1761,8 @@ impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+impl<T: ?Sized, A: Allocator> const Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -1729,7 +1771,8 @@ impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: Allocator> DerefMut for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+impl<T: ?Sized, A: Allocator> const DerefMut for Box<T, A> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n@@ -1908,7 +1951,8 @@ impl<T: ?Sized, A: Allocator> AsMut<T> for Box<T, A> {\n  *  could have a method to project a Pin<T> from it.\n  */\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: Allocator> Unpin for Box<T, A> where A: 'static {}\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"none\")]\n+impl<T: ?Sized, A: Allocator> const Unpin for Box<T, A> where A: 'static {}\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R> + Unpin, R, A: Allocator> Generator<R> for Box<G, A>"}, {"sha": "d1a34e49175b826894d297460dba3ba841e25481", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=eb4fc640b0f881e240ad0ebb9d05f56547e42036", "patch": "@@ -97,8 +97,18 @@\n #![feature(async_stream)]\n #![feature(coerce_unsized)]\n #![cfg_attr(not(no_global_oom_handling), feature(const_btree_new))]\n+#![feature(const_box)]\n #![feature(const_cow_is_borrowed)]\n+#![feature(const_convert)]\n+#![feature(const_size_of_val)]\n+#![feature(const_align_of_val)]\n+#![feature(const_ptr_read)]\n+#![feature(const_maybe_uninit_write)]\n+#![feature(const_maybe_uninit_as_mut_ptr)]\n+#![feature(const_refs_to_cell)]\n #![feature(core_intrinsics)]\n+#![feature(const_eval_select)]\n+#![feature(const_pin)]\n #![feature(dispatch_from_dyn)]\n #![feature(exact_size_is_empty)]\n #![feature(extend_one)]\n@@ -134,8 +144,13 @@\n #![feature(box_syntax)]\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n+#![feature(const_deref)]\n #![feature(const_fn_trait_bound)]\n+#![feature(const_mut_refs)]\n+#![feature(const_ptr_write)]\n+#![feature(const_precise_live_drops)]\n #![feature(const_trait_impl)]\n+#![feature(const_try)]\n #![cfg_attr(bootstrap, feature(destructuring_assignment))]\n #![feature(dropck_eyepatch)]\n #![feature(exclusive_range_pattern)]"}, {"sha": "0d7acfed8c6a1b36f0354714fa375f9de8efd9b4", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 111, "deletions": 3, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=eb4fc640b0f881e240ad0ebb9d05f56547e42036", "patch": "@@ -1,6 +1,7 @@\n-use std::cell::Cell;\n-use std::mem::MaybeUninit;\n-use std::ptr::NonNull;\n+use core::alloc::{AllocError, Allocator, Layout};\n+use core::cell::Cell;\n+use core::mem::MaybeUninit;\n+use core::ptr::NonNull;\n \n #[test]\n fn uninitialized_zero_size_box() {\n@@ -57,3 +58,110 @@ fn box_deref_lval() {\n     x.set(1000);\n     assert_eq!(x.get(), 1000);\n }\n+\n+pub struct ConstAllocator;\n+\n+unsafe impl const Allocator for ConstAllocator {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        match layout.size() {\n+            0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n+            _ => unsafe {\n+                let ptr = core::intrinsics::const_allocate(layout.size(), layout.align());\n+                Ok(NonNull::new_unchecked(ptr as *mut [u8; 0] as *mut [u8]))\n+            },\n+        }\n+    }\n+\n+    unsafe fn deallocate(&self, _ptr: NonNull<u8>, layout: Layout) {\n+        match layout.size() {\n+            0 => { /* do nothing */ }\n+            _ => { /* do nothing too */ }\n+        }\n+    }\n+\n+    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        let ptr = self.allocate(layout)?;\n+        if layout.size() > 0 {\n+            unsafe {\n+                ptr.as_mut_ptr().write_bytes(0, layout.size());\n+            }\n+        }\n+        Ok(ptr)\n+    }\n+\n+    unsafe fn grow(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        debug_assert!(\n+            new_layout.size() >= old_layout.size(),\n+            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n+        );\n+\n+        let new_ptr = self.allocate(new_layout)?;\n+        if new_layout.size() > 0 {\n+            new_ptr.as_mut_ptr().copy_from_nonoverlapping(ptr.as_ptr(), old_layout.size());\n+            self.deallocate(ptr, old_layout);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    unsafe fn grow_zeroed(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        let new_ptr = self.grow(ptr, old_layout, new_layout)?;\n+        if new_layout.size() > 0 {\n+            let old_size = old_layout.size();\n+            let new_size = new_layout.size();\n+            let raw_ptr = new_ptr.as_mut_ptr();\n+            raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    unsafe fn shrink(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        debug_assert!(\n+            new_layout.size() <= old_layout.size(),\n+            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n+        );\n+\n+        let new_ptr = self.allocate(new_layout)?;\n+        if new_layout.size() > 0 {\n+            new_ptr.as_mut_ptr().copy_from_nonoverlapping(ptr.as_ptr(), new_layout.size());\n+            self.deallocate(ptr, old_layout);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    fn by_ref(&self) -> &Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n+}\n+\n+#[test]\n+fn const_box() {\n+    const VALUE: u32 = {\n+        let mut boxed = Box::new_in(1u32, ConstAllocator);\n+        assert!(*boxed == 1);\n+\n+        *boxed = 42;\n+        assert!(*boxed == 42);\n+\n+        *boxed\n+    };\n+\n+    assert!(VALUE == 42);\n+}"}, {"sha": "eec24a5c3f7e69ea3ca90574ba44c82609c78842", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4fc640b0f881e240ad0ebb9d05f56547e42036/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=eb4fc640b0f881e240ad0ebb9d05f56547e42036", "patch": "@@ -1,8 +1,19 @@\n #![feature(allocator_api)]\n+#![feature(alloc_layout_extra)]\n #![feature(assert_matches)]\n #![feature(box_syntax)]\n #![feature(cow_is_borrowed)]\n+#![feature(const_box)]\n+#![feature(const_convert)]\n #![feature(const_cow_is_borrowed)]\n+#![feature(const_heap)]\n+#![feature(const_intrinsic_copy)]\n+#![feature(const_mut_refs)]\n+#![feature(const_nonnull_slice_from_raw_parts)]\n+#![feature(const_ptr_offset)]\n+#![feature(const_ptr_write)]\n+#![feature(const_try)]\n+#![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(new_uninit)]\n@@ -26,6 +37,7 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(const_str_from_utf8)]\n+#![feature(nonnull_slice_from_raw_parts)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}]}