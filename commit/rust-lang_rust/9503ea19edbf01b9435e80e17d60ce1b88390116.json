{"sha": "9503ea19edbf01b9435e80e17d60ce1b88390116", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MDNlYTE5ZWRiZjAxYjk0MzVlODBlMTdkNjBjZTFiODgzOTAxMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-14T22:26:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-14T22:26:21Z"}, "message": "Auto merge of #82103 - Dylan-DPC:rollup-5wv8rid, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #80523 (#[doc(inline)] sym_generated)\n - #80920 (Visit more targets when validating attributes)\n - #81720 (Updated smallvec version due to RUSTSEC-2021-0003)\n - #81891 ([rustdoc-json] Make `header` a vec of modifiers, and FunctionPointer consistent)\n - #81912 (Implement the precise analysis pass for lint `disjoint_capture_drop_reorder`)\n - #81914 (Fixing bad suggestion for `_` in `const` type when a function #81885)\n - #81919 (BTreeMap: fix internal comments)\n - #81927 (Add a regression test for #32498)\n - #81965 (Fix MIR pretty printer for non-local DefIds)\n - #82029 (Use debug log level for developer oriented logs)\n - #82056 (fix ice (#82032))\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4d41215ce2c2e76194710cae727f728be42e642a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d41215ce2c2e76194710cae727f728be42e642a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9503ea19edbf01b9435e80e17d60ce1b88390116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9503ea19edbf01b9435e80e17d60ce1b88390116", "html_url": "https://github.com/rust-lang/rust/commit/9503ea19edbf01b9435e80e17d60ce1b88390116", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9503ea19edbf01b9435e80e17d60ce1b88390116/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fa22fe6f821ac3801d05f624b123dda25fde32c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa22fe6f821ac3801d05f624b123dda25fde32c", "html_url": "https://github.com/rust-lang/rust/commit/5fa22fe6f821ac3801d05f624b123dda25fde32c"}, {"sha": "bcb14035e9b07bf334e91854f5490e12a64bc161", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb14035e9b07bf334e91854f5490e12a64bc161", "html_url": "https://github.com/rust-lang/rust/commit/bcb14035e9b07bf334e91854f5490e12a64bc161"}], "stats": {"total": 1068, "additions": 903, "deletions": 165}, "files": [{"sha": "c1011c0f479cbd158455ac6686fd354c95441d67", "filename": "Cargo.lock", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -593,7 +593,7 @@ dependencies = [\n  \"rustc-semver\",\n  \"semver 0.11.0\",\n  \"serde\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"syn\",\n  \"toml\",\n  \"unicode-normalization\",\n@@ -2086,7 +2086,7 @@ checksum = \"22bf8d885d073610aee20e7fa205c4341ed32a761dbde96da5fd96301a8d3e82\"\n dependencies = [\n  \"parking_lot\",\n  \"rustc-hash\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n ]\n \n [[package]]\n@@ -2236,7 +2236,7 @@ dependencies = [\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n ]\n \n [[package]]\n@@ -2459,7 +2459,7 @@ dependencies = [\n  \"instant\",\n  \"libc\",\n  \"redox_syscall\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -3110,7 +3110,7 @@ version = \"705.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"93575affa286089b92c8208aea4e60fe9fdd251a619a09b566d6e4e2cc123212\"\n dependencies = [\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n ]\n \n [[package]]\n@@ -3126,7 +3126,7 @@ dependencies = [\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3201,7 +3201,7 @@ dependencies = [\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n@@ -3249,7 +3249,7 @@ dependencies = [\n  \"rustc-ap-rustc_serialize\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3337,7 +3337,7 @@ dependencies = [\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n  \"unicode-normalization\",\n ]\n@@ -3349,7 +3349,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bc232e2a351d8131c8f1386ce372ee22ef7b1b0b897bbf817a8ce4792029a564\"\n dependencies = [\n  \"indexmap\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n ]\n \n [[package]]\n@@ -3497,8 +3497,8 @@ dependencies = [\n  \"quote\",\n  \"serde\",\n  \"serde_json\",\n- \"smallvec 0.6.13\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 0.6.14\",\n+ \"smallvec 1.6.1\",\n  \"syn\",\n  \"url 2.1.1\",\n  \"winapi 0.3.9\",\n@@ -3509,14 +3509,14 @@ name = \"rustc_apfloat\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n ]\n \n [[package]]\n name = \"rustc_arena\"\n version = \"0.0.0\"\n dependencies = [\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n ]\n \n [[package]]\n@@ -3530,7 +3530,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3548,7 +3548,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3611,7 +3611,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3639,7 +3639,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"snap\",\n  \"tracing\",\n ]\n@@ -3697,7 +3697,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n@@ -3778,7 +3778,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3810,7 +3810,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3868,7 +3868,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -3909,7 +3909,7 @@ dependencies = [\n  \"rustc_traits\",\n  \"rustc_ty_utils\",\n  \"rustc_typeck\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tempfile\",\n  \"tracing\",\n  \"winapi 0.3.9\",\n@@ -3999,7 +3999,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"snap\",\n  \"stable_deref_trait\",\n  \"tracing\",\n@@ -4031,7 +4031,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_type_ir\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4062,7 +4062,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4085,7 +4085,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4102,7 +4102,7 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n  \"unicode-normalization\",\n ]\n@@ -4178,7 +4178,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4202,7 +4202,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4231,7 +4231,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"indexmap\",\n  \"rustc_macros\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n ]\n \n [[package]]\n@@ -4328,7 +4328,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4348,7 +4348,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_span\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4398,7 +4398,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tracing\",\n ]\n \n@@ -4425,7 +4425,7 @@ dependencies = [\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"tempfile\",\n ]\n \n@@ -4759,18 +4759,18 @@ checksum = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"0.6.13\"\n+version = \"0.6.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f7b0758c52e15a8b5e3691eae6cc559f08eee9406e548a4477ba4e67770a82b6\"\n+checksum = \"b97fcaeba89edba30f044a10c6a3cc39df9c3f17d7cd829dd1446cab35f890e0\"\n dependencies = [\n  \"maybe-uninit\",\n ]\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.4.2\"\n+version = \"1.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbee7696b84bbf3d89a1c2eccff0850e3047ed46bfcd2e92c29a2d074d57e252\"\n+checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n \n [[package]]\n name = \"snap\"\n@@ -5237,7 +5237,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"sharded-slab\",\n- \"smallvec 1.4.2\",\n+ \"smallvec 1.6.1\",\n  \"thread_local\",\n  \"tracing\",\n  \"tracing-core\","}, {"sha": "103e64be5ac0b326c8423161cfd3a3490810d579", "filename": "compiler/rustc_apfloat/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -6,4 +6,4 @@ edition = \"2018\"\n \n [dependencies]\n bitflags = \"1.2.1\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "f2d039c82ab7fd3b6204fcd4bddcfd1547deb82f", "filename": "compiler/rustc_arena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -5,4 +5,4 @@ version = \"0.0.0\"\n edition = \"2018\"\n \n [dependencies]\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "6b9b9e8155ed200c971bfe30d68fa20c8a8b2e93", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -15,5 +15,5 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n bitflags = \"1.2.1\""}, {"sha": "0cced00189eb5616478d8f686e1cbe8aecb3192c", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -19,4 +19,4 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_ast = { path = \"../rustc_ast\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "962dfbac934c7af29c7ac9e98d86e94b33981454", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -19,7 +19,7 @@ rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_expand = { path = \"../rustc_expand\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "ebbb852f21cc807df057ab3591a0946af728b004", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -29,6 +29,6 @@ rustc_llvm = { path = \"../rustc_llvm\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_target = { path = \"../rustc_target\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "e3476517de58325aa272f6d244a4e9bac5e1fa00", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -22,7 +22,7 @@ stable_deref_trait = \"1.0.0\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n rayon-core = { version = \"0.3.0\", package = \"rustc-rayon-core\" }\n rustc-hash = \"1.1.0\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n measureme = \"9.0.0\""}, {"sha": "59c1604e8444c13325fc2d6e70da8fb3c3a6b6e4", "filename": "compiler/rustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -23,5 +23,5 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "d41b81f8f217d53856ac1b5e3ad0a5a12b715c7e", "filename": "compiler/rustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -17,4 +17,4 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n tracing = \"0.1\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "473477bf22da26b91cbdc7758c364146135046b9", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -54,6 +54,7 @@ pub enum Target {\n     ForeignTy,\n     GenericParam(GenericParamKind),\n     MacroDef,\n+    Param,\n }\n \n impl Display for Target {\n@@ -96,6 +97,7 @@ impl Display for Target {\n                     GenericParamKind::Const => \"const parameter\",\n                 },\n                 Target::MacroDef => \"macro def\",\n+                Target::Param => \"function param\",\n             }\n         )\n     }"}, {"sha": "a75ad7b31a64e05acedb5a3141206b08dfd6b708", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -20,5 +20,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "f3e4aab941b7eeee3f39d0b4a2753d80f106468c", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -11,7 +11,7 @@ doctest = false\n libc = \"0.2\"\n tracing = \"0.1\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_builtin_macros = { path = \"../rustc_builtin_macros\" }"}, {"sha": "2aabc2c407b1af143fe261e3c05eb4b9295cc210", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -12,7 +12,7 @@ libc = \"0.2\"\n snap = \"1\"\n tracing = \"0.1\"\n memmap = \"0.7\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "7de398a1898e5e0238a26efe92146a4af0624053", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -27,7 +27,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n chalk-ir = \"0.55.0\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n measureme = \"9.0.0\"\n rustc_session = { path = \"../rustc_session\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "59a0c9a5dd5b996a1acd922eac86db2eb42dab2f", "filename": "compiler/rustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -31,7 +31,7 @@ rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n \n [dev-dependencies]\n coverage_test_macros = { path = \"src/transform/coverage/test_macros\" }"}, {"sha": "0400431a542ee74825501726b2a7a170d23d6a81", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -1,6 +1,7 @@\n use rustc_hir as hir;\n use rustc_hir::Node;\n use rustc_index::vec::Idx;\n+use rustc_middle::hir::map::Map;\n use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::{\n@@ -543,13 +544,24 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     // Attempt to search similar mutable associated items for suggestion.\n     // In the future, attempt in all path but initially for RHS of for_loop\n     fn suggest_similar_mut_method_for_for_loop(&self, err: &mut DiagnosticBuilder<'_>) {\n-        let hir = self.infcx.tcx.hir();\n-        let node = hir.item(self.mir_hir_id());\n         use hir::{\n-            Expr,\n+            BodyId, Expr,\n             ExprKind::{Block, Call, DropTemps, Match, MethodCall},\n+            HirId, ImplItem, ImplItemKind, Item, ItemKind,\n         };\n-        if let hir::ItemKind::Fn(_, _, body_id) = node.kind {\n+\n+        fn maybe_body_id_of_fn(hir_map: &Map<'tcx>, id: HirId) -> Option<BodyId> {\n+            match hir_map.find(id) {\n+                Some(Node::Item(Item { kind: ItemKind::Fn(_, _, body_id), .. }))\n+                | Some(Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })) => {\n+                    Some(*body_id)\n+                }\n+                _ => None,\n+            }\n+        }\n+        let hir_map = self.infcx.tcx.hir();\n+        let mir_body_hir_id = self.mir_hir_id();\n+        if let Some(fn_body_id) = maybe_body_id_of_fn(&hir_map, mir_body_hir_id) {\n             if let Block(\n                 hir::Block {\n                     expr:\n@@ -579,7 +591,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ..\n                 },\n                 _,\n-            ) = hir.body(body_id).value.kind\n+            ) = hir_map.body(fn_body_id).value.kind\n             {\n                 let opt_suggestions = path_segment\n                     .hir_id"}, {"sha": "f4f69fc8ac62b3b5846ade38cfae86036d4ff779", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -159,7 +159,7 @@ impl Inliner<'tcx> {\n         }\n     }\n \n-    #[instrument(skip(self, caller_body))]\n+    #[instrument(level = \"debug\", skip(self, caller_body))]\n     fn is_mir_available(&self, callee: Instance<'tcx>, caller_body: &Body<'tcx>) -> bool {\n         match callee.def {\n             InstanceDef::Item(_) => {\n@@ -258,7 +258,7 @@ impl Inliner<'tcx> {\n         None\n     }\n \n-    #[instrument(skip(self, callee_body))]\n+    #[instrument(level = \"debug\", skip(self, callee_body))]\n     fn should_inline(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n         let tcx = self.tcx;\n "}, {"sha": "4c24bec0ce3ad51334bd067e87a3119cde6bdcda", "filename": "compiler/rustc_mir/src/transform/inline/cycle.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::ty::{self, subst::SubstsRef, InstanceDef, TyCtxt};\n \n // FIXME: check whether it is cheaper to precompute the entire call graph instead of invoking\n // this query riddiculously often.\n-#[instrument(skip(tcx, root, target))]\n+#[instrument(level = \"debug\", skip(tcx, root, target))]\n crate fn mir_callgraph_reachable(\n     tcx: TyCtxt<'tcx>,\n     (root, target): (ty::Instance<'tcx>, LocalDefId),\n@@ -27,7 +27,10 @@ crate fn mir_callgraph_reachable(\n         !tcx.is_constructor(root.def_id()),\n         \"you should not call `mir_callgraph_reachable` on enum/struct constructor functions\"\n     );\n-    #[instrument(skip(tcx, param_env, target, stack, seen, recursion_limiter, caller))]\n+    #[instrument(\n+        level = \"debug\",\n+        skip(tcx, param_env, target, stack, seen, recursion_limiter, caller)\n+    )]\n     fn process(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "f46e94eea96c75828f2d5032b24c91df0ffcc6ed", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -289,19 +289,19 @@ pub fn write_mir_pretty<'tcx>(\n             }\n             Ok(())\n         };\n-        match tcx.hir().body_const_context(def_id.expect_local()) {\n-            None => render_body(w, tcx.optimized_mir(def_id))?,\n-            // For `const fn` we want to render the optimized MIR. If you want the mir used in\n-            // ctfe, you can dump the MIR after the `Deaggregator` optimization pass.\n-            Some(rustc_hir::ConstContext::ConstFn) => {\n-                render_body(w, tcx.optimized_mir(def_id))?;\n-                writeln!(w)?;\n-                writeln!(w, \"// MIR FOR CTFE\")?;\n-                // Do not use `render_body`, as that would render the promoteds again, but these\n-                // are shared between mir_for_ctfe and optimized_mir\n-                write_mir_fn(tcx, tcx.mir_for_ctfe(def_id), &mut |_, _| Ok(()), w)?;\n-            }\n-            Some(_) => render_body(w, tcx.mir_for_ctfe(def_id))?,\n+\n+        // For `const fn` we want to render both the optimized MIR and the MIR for ctfe.\n+        if tcx.is_const_fn_raw(def_id) {\n+            render_body(w, tcx.optimized_mir(def_id))?;\n+            writeln!(w)?;\n+            writeln!(w, \"// MIR FOR CTFE\")?;\n+            // Do not use `render_body`, as that would render the promoteds again, but these\n+            // are shared between mir_for_ctfe and optimized_mir\n+            write_mir_fn(tcx, tcx.mir_for_ctfe(def_id), &mut |_, _| Ok(()), w)?;\n+        } else {\n+            let instance_mir =\n+                tcx.instance_mir(ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id)));\n+            render_body(w, instance_mir)?;\n         }\n     }\n     Ok(())"}, {"sha": "b75221bb5d5cd052f84b5304bc288714789c0eab", "filename": "compiler/rustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -24,4 +24,4 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ast = { path = \"../rustc_ast\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "010fe4fd524d4d966bbd2207081023cc60e6a63d", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -1079,7 +1079,10 @@ impl<'tcx> Witness<'tcx> {\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-#[instrument(skip(cx, matrix, witness_preference, hir_id, is_under_guard, is_top_level))]\n+#[instrument(\n+    level = \"debug\",\n+    skip(cx, matrix, witness_preference, hir_id, is_under_guard, is_top_level)\n+)]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,"}, {"sha": "c887729c355700d5c83f60e204ec3daa84007a9a", "filename": "compiler/rustc_parse/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -19,4 +19,4 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_ast = { path = \"../rustc_ast\" }\n unicode-normalization = \"0.1.11\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "2c79eeeb0e6d22af72a7ed37ce2c6b6f34c4c3e2", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -1101,17 +1101,6 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_arm(self, arm);\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_attributes(\n-            macro_def.hir_id,\n-            &macro_def.attrs,\n-            &macro_def.span,\n-            Target::MacroDef,\n-            None,\n-        );\n-        intravisit::walk_macro_def(self, macro_def);\n-    }\n-\n     fn visit_foreign_item(&mut self, f_item: &'tcx ForeignItem<'tcx>) {\n         let target = Target::from_foreign_item(f_item);\n         self.check_attributes(\n@@ -1157,6 +1146,23 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         self.check_attributes(variant.id, variant.attrs, &variant.span, Target::Variant, None);\n         intravisit::walk_variant(self, variant, generics, item_id)\n     }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n+        self.check_attributes(\n+            macro_def.hir_id,\n+            macro_def.attrs,\n+            &macro_def.span,\n+            Target::MacroDef,\n+            None,\n+        );\n+        intravisit::walk_macro_def(self, macro_def);\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.check_attributes(param.hir_id, param.attrs, &param.span, Target::Param, None);\n+\n+        intravisit::walk_param(self, param);\n+    }\n }\n \n fn is_c_like_enum(item: &Item<'_>) -> bool {"}, {"sha": "d18a2a6faed6c9b5da4dcc6f040ff8a11afcbe88", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -18,4 +18,4 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n parking_lot = \"0.11\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "7441f4a9f22a471d64770c19ac5c98a7813eb749", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -26,4 +26,4 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "05fc6a4e11d437e75fa9f50503d07fb056fe3653", "filename": "compiler/rustc_serialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -6,7 +6,7 @@ edition = \"2018\"\n \n [dependencies]\n indexmap = \"1\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n \n [dev-dependencies]\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "4ccf657335fedb747694c74283e2d822b8d8a537", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -1405,8 +1405,8 @@ fn update_disambiguator(expn_id: ExpnId) {\n     });\n \n     if modified {\n-        info!(\"Set disambiguator for {:?} (hash {:?})\", expn_id, first_hash);\n-        info!(\"expn_data = {:?}\", expn_id.expn_data());\n+        debug!(\"Set disambiguator for {:?} (hash {:?})\", expn_id, first_hash);\n+        debug!(\"expn_data = {:?}\", expn_id.expn_data());\n \n         // Verify that the new disambiguator makes the hash unique\n         #[cfg(debug_assertions)]"}, {"sha": "ef062da3f6e891671ca85a22b684fda461b156d1", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -1604,6 +1604,7 @@ pub mod sym {\n     use super::Symbol;\n     use std::convert::TryInto;\n \n+    #[doc(inline)]\n     pub use super::sym_generated::*;\n \n     // Used from a macro in `librustc_feature/accepted.rs`"}, {"sha": "c5d4c2400f82a8519b3956bac2feda7a9242c8ad", "filename": "compiler/rustc_trait_selection/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -22,4 +22,4 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "45853a66efc2a565e1e0cb9592cc1913aa1877e0", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -91,7 +91,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n         });\n         let impl_source = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, impl_source);\n \n-        info!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n+        debug!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n         Ok(impl_source)\n     })\n }"}, {"sha": "95f79147efd43e62ea12361b3cc746967c673bd3", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -647,7 +647,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ProcessResult::Unchanged\n             }\n             Err(selection_err) => {\n-                info!(\"selecting trait at depth {} yielded Err\", obligation.recursion_depth);\n+                debug!(\"selecting trait at depth {} yielded Err\", obligation.recursion_depth);\n \n                 ProcessResult::Error(CodeSelectionError(selection_err))\n             }"}, {"sha": "a7ce14afaa362a42f4aa12a408ee470582f55b9e", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -16,6 +16,6 @@ rustc_span = { path = \"../rustc_span\" }\n chalk-ir = \"0.55.0\"\n chalk-solve = \"0.55.0\"\n chalk-engine = \"0.55.0\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "cfcbc77c172fd1f41ee457292474e69cee8dafd4", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -80,7 +80,7 @@ fn dropck_outlives<'tcx>(\n             let cause = ObligationCause::dummy();\n             let mut constraints = DtorckConstraint::empty();\n             while let Some((ty, depth)) = ty_stack.pop() {\n-                info!(\n+                debug!(\n                     \"{} kinds, {} overflows, {} ty_stack\",\n                     result.kinds.len(),\n                     result.overflows.len(),"}, {"sha": "d92d317e34ad68e89e5dc4fc9e6697ac78ee9192", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -20,7 +20,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_index = { path = \"../rustc_index\" }"}, {"sha": "c9cc47b83e3d675f6503e72f336bf9ddf6023055", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -2191,12 +2191,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::BareFn(ref bf) => {\n                 require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n+\n                 tcx.mk_fn_ptr(self.ty_of_fn(\n                     bf.unsafety,\n                     bf.abi,\n                     &bf.decl,\n                     &hir::Generics::empty(),\n                     None,\n+                    Some(ast_ty),\n                 ))\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n@@ -2336,6 +2338,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         decl: &hir::FnDecl<'_>,\n         generics: &hir::Generics<'_>,\n         ident_span: Option<Span>,\n+        hir_ty: Option<&hir::Ty<'_>>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n \n@@ -2367,12 +2370,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // only want to emit an error complaining about them if infer types (`_`) are not\n             // allowed. `allow_ty_infer` gates this behavior. We check for the presence of\n             // `ident_span` to not emit an error twice when we have `fn foo(_: fn() -> _)`.\n+\n             crate::collect::placeholder_type_error(\n                 tcx,\n                 ident_span.map(|sp| sp.shrink_to_hi()),\n                 &generics.params[..],\n                 visitor.0,\n                 true,\n+                hir_ty,\n             );\n         }\n "}, {"sha": "fce7ae8119e17a55efd888adcaae97ae87b5ee7d", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -502,6 +502,7 @@ fn typeck_with_fallback<'tcx>(\n                     decl,\n                     &hir::Generics::empty(),\n                     None,\n+                    None,\n                 )\n             } else {\n                 tcx.fn_sig(def_id)"}, {"sha": "d097f863ad2f9dd8b107c1dd7af929389d6ad18a", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 270, "deletions": 13, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -40,13 +40,16 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n-use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n+use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection, ProjectionKind};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n \n+use rustc_index::vec::Idx;\n+use rustc_target::abi::VariantIdx;\n+\n /// Describe the relationship between the paths of two places\n /// eg:\n /// - `foo` is ancestor of `foo.bar.baz`\n@@ -535,7 +538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         body: &'tcx hir::Body<'tcx>,\n     ) {\n-        let need_migrations = self.compute_2229_migrations_first_pass(\n+        let need_migrations = self.compute_2229_migrations(\n             closure_def_id,\n             span,\n             capture_clause,\n@@ -544,9 +547,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         if !need_migrations.is_empty() {\n-            let need_migrations_hir_id = need_migrations.iter().map(|m| m.0).collect::<Vec<_>>();\n-\n-            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations_hir_id);\n+            let migrations_text = migration_suggestion_for_2229(self.tcx, &need_migrations);\n \n             let local_def_id = closure_def_id.expect_local();\n             let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n@@ -573,15 +574,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - It would have been moved into the closure when `capture_disjoint_fields` wasn't\n     ///   enabled, **and**\n     /// - It wasn't completely captured by the closure, **and**\n-    /// - The type of the root variable needs Drop.\n-    fn compute_2229_migrations_first_pass(\n+    /// - One of the paths starting at this root variable, that is not captured needs Drop.\n+    fn compute_2229_migrations(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         closure_clause: hir::CaptureBy,\n         body: &'tcx hir::Body<'tcx>,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-    ) -> Vec<(hir::HirId, Ty<'tcx>)> {\n+    ) -> Vec<hir::HirId> {\n         fn resolve_ty<T: TypeFoldable<'tcx>>(\n             fcx: &FnCtxt<'_, 'tcx>,\n             span: Span,\n@@ -617,29 +618,285 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 match closure_clause {\n                     // Only migrate if closure is a move closure\n-                    hir::CaptureBy::Value => need_migrations.push((var_hir_id, ty)),\n+                    hir::CaptureBy::Value => need_migrations.push(var_hir_id),\n \n                     hir::CaptureBy::Ref => {}\n                 }\n \n                 continue;\n             };\n \n-            let is_moved = root_var_min_capture_list\n+            let projections_list = root_var_min_capture_list\n                 .iter()\n-                .any(|capture| matches!(capture.info.capture_kind, ty::UpvarCapture::ByValue(_)));\n+                .filter_map(|captured_place| match captured_place.info.capture_kind {\n+                    // Only care about captures that are moved into the closure\n+                    ty::UpvarCapture::ByValue(..) => {\n+                        Some(captured_place.place.projections.as_slice())\n+                    }\n+                    ty::UpvarCapture::ByRef(..) => None,\n+                })\n+                .collect::<Vec<_>>();\n+\n+            let is_moved = !projections_list.is_empty();\n \n             let is_not_completely_captured =\n                 root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n \n-            if is_moved && is_not_completely_captured {\n-                need_migrations.push((var_hir_id, ty));\n+            if is_moved\n+                && is_not_completely_captured\n+                && self.has_significant_drop_outside_of_captures(\n+                    closure_def_id,\n+                    closure_span,\n+                    ty,\n+                    projections_list,\n+                )\n+            {\n+                need_migrations.push(var_hir_id);\n             }\n         }\n \n         need_migrations\n     }\n \n+    /// This is a helper function to `compute_2229_migrations_precise_pass`. Provided the type\n+    /// of a root variable and a list of captured paths starting at this root variable (expressed\n+    /// using list of `Projection` slices), it returns true if there is a path that is not\n+    /// captured starting at this root variable that implements Drop.\n+    ///\n+    /// FIXME(project-rfc-2229#35): This should return true only for significant drops.\n+    ///                             A drop is significant if it's implemented by the user or does\n+    ///                             anything that will have any observable behavior (other than\n+    ///                             freeing up memory).\n+    ///\n+    /// The way this function works is at a given call it looks at type `base_path_ty` of some base\n+    /// path say P and then list of projection slices which represent the different captures moved\n+    /// into the closure starting off of P.\n+    ///\n+    /// This will make more sense with an example:\n+    ///\n+    /// ```rust\n+    /// #![feature(capture_disjoint_fields)]\n+    ///\n+    /// struct FancyInteger(i32); // This implements Drop\n+    ///\n+    /// struct Point { x: FancyInteger, y: FancyInteger }\n+    /// struct Color;\n+    ///\n+    /// struct Wrapper { p: Point, c: Color }\n+    ///\n+    /// fn f(w: Wrapper) {\n+    ///   let c = || {\n+    ///       // Closure captures w.p.x and w.c by move.\n+    ///   };\n+    ///\n+    ///   c();\n+    /// }\n+    /// ```\n+    ///\n+    /// If `capture_disjoint_fields` wasn't enabled the closure would've moved `w` instead of the\n+    /// precise paths. If we look closely `w.p.y` isn't captured which implements Drop and\n+    /// therefore Drop ordering would change and we want this function to return true.\n+    ///\n+    /// Call stack to figure out if we need to migrate for `w` would look as follows:\n+    ///\n+    /// Our initial base path is just `w`, and the paths captured from it are `w[p, x]` and\n+    /// `w[c]`.\n+    /// Notation:\n+    /// - Ty(place): Type of place\n+    /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_projs`\n+    /// respectively.\n+    /// ```\n+    ///                  (Ty(w), [ &[p, x], &[c] ])\n+    ///                                 |\n+    ///                    ----------------------------\n+    ///                    |                          |\n+    ///                    v                          v\n+    ///        (Ty(w.p), [ &[x] ])          (Ty(w.c), [ &[] ]) // I(1)\n+    ///                    |                          |\n+    ///                    v                          v\n+    ///        (Ty(w.p), [ &[x] ])                 false\n+    ///                    |\n+    ///                    |\n+    ///          -------------------------------\n+    ///          |                             |\n+    ///          v                             v\n+    ///     (Ty((w.p).x), [ &[] ])     (Ty((w.p).y), []) // IMP 2\n+    ///          |                             |\n+    ///          v                             v\n+    ///        false                     NeedsDrop(Ty(w.p.y))\n+    ///                                        |\n+    ///                                        v\n+    ///                                      true\n+    /// ```\n+    ///\n+    /// IMP 1 `(Ty(w.c), [ &[] ])`: Notice the single empty slice inside `captured_projs`.\n+    ///                             This implies that the `w.c` is completely captured by the closure.\n+    ///                             Since drop for this path will be called when the closure is\n+    ///                             dropped we don't need to migrate for it.\n+    ///\n+    /// IMP 2 `(Ty((w.p).y), [])`: Notice that `captured_projs` is empty. This implies that this\n+    ///                             path wasn't captured by the closure. Also note that even\n+    ///                             though we didn't capture this path, the function visits it,\n+    ///                             which is kind of the point of this function. We then return\n+    ///                             if the type of `w.p.y` implements Drop, which in this case is\n+    ///                             true.\n+    ///\n+    /// Consider another example:\n+    ///\n+    /// ```rust\n+    /// struct X;\n+    /// impl Drop for X {}\n+    ///\n+    /// struct Y(X);\n+    /// impl Drop for Y {}\n+    ///\n+    /// fn foo() {\n+    ///     let y = Y(X);\n+    ///     let c = || move(y.0);\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that `y.0` is captured by the closure. When this function is called for `y`, it will\n+    /// return true, because even though all paths starting at `y` are captured, `y` itself\n+    /// implements Drop which will be affected since `y` isn't completely captured.\n+    fn has_significant_drop_outside_of_captures(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_span: Span,\n+        base_path_ty: Ty<'tcx>,\n+        captured_projs: Vec<&[Projection<'tcx>]>,\n+    ) -> bool {\n+        let needs_drop = |ty: Ty<'tcx>| {\n+            ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local()))\n+        };\n+\n+        let is_drop_defined_for_ty = |ty: Ty<'tcx>| {\n+            let drop_trait = self.tcx.require_lang_item(hir::LangItem::Drop, Some(closure_span));\n+            let ty_params = self.tcx.mk_substs_trait(base_path_ty, &[]);\n+            self.tcx.type_implements_trait((\n+                drop_trait,\n+                ty,\n+                ty_params,\n+                self.tcx.param_env(closure_def_id.expect_local()),\n+            ))\n+        };\n+\n+        let is_drop_defined_for_ty = is_drop_defined_for_ty(base_path_ty);\n+\n+        // If there is a case where no projection is applied on top of current place\n+        // then there must be exactly one capture corresponding to such a case. Note that this\n+        // represents the case of the path being completely captured by the variable.\n+        //\n+        // eg. If `a.b` is captured and we are processing `a.b`, then we can't have the closure also\n+        //     capture `a.b.c`, because that voilates min capture.\n+        let is_completely_captured = captured_projs.iter().any(|projs| projs.is_empty());\n+\n+        assert!(!is_completely_captured || (captured_projs.len() == 1));\n+\n+        if is_completely_captured {\n+            // The place is captured entirely, so doesn't matter if needs dtor, it will be drop\n+            // when the closure is dropped.\n+            return false;\n+        }\n+\n+        if is_drop_defined_for_ty {\n+            // If drop is implemented for this type then we need it to be fully captured,\n+            // which we know it is not because of the previous check. Therefore we need to\n+            // do migrate.\n+            return true;\n+        }\n+\n+        if captured_projs.is_empty() {\n+            return needs_drop(base_path_ty);\n+        }\n+\n+        match base_path_ty.kind() {\n+            // Observations:\n+            // - `captured_projs` is not empty. Therefore we can call\n+            //   `captured_projs.first().unwrap()` safely.\n+            // - All entries in `captured_projs` have atleast one projection.\n+            //   Therefore we can call `captured_projs.first().unwrap().first().unwrap()` safely.\n+\n+            // We don't capture derefs in case of move captures, which would have be applied to\n+            // access any further paths.\n+            ty::Adt(def, _) if def.is_box() => unreachable!(),\n+            ty::Ref(..) => unreachable!(),\n+            ty::RawPtr(..) => unreachable!(),\n+\n+            ty::Adt(def, substs) => {\n+                // Multi-varaint enums are captured in entirety,\n+                // which would've been handled in the case of single empty slice in `captured_projs`.\n+                assert_eq!(def.variants.len(), 1);\n+\n+                // Only Field projections can be applied to a non-box Adt.\n+                assert!(\n+                    captured_projs.iter().all(|projs| matches!(\n+                        projs.first().unwrap().kind,\n+                        ProjectionKind::Field(..)\n+                    ))\n+                );\n+                def.variants.get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n+                    |(i, field)| {\n+                        let paths_using_field = captured_projs\n+                            .iter()\n+                            .filter_map(|projs| {\n+                                if let ProjectionKind::Field(field_idx, _) =\n+                                    projs.first().unwrap().kind\n+                                {\n+                                    if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                                } else {\n+                                    unreachable!();\n+                                }\n+                            })\n+                            .collect();\n+\n+                        let after_field_ty = field.ty(self.tcx, substs);\n+                        self.has_significant_drop_outside_of_captures(\n+                            closure_def_id,\n+                            closure_span,\n+                            after_field_ty,\n+                            paths_using_field,\n+                        )\n+                    },\n+                )\n+            }\n+\n+            ty::Tuple(..) => {\n+                // Only Field projections can be applied to a tuple.\n+                assert!(\n+                    captured_projs.iter().all(|projs| matches!(\n+                        projs.first().unwrap().kind,\n+                        ProjectionKind::Field(..)\n+                    ))\n+                );\n+\n+                base_path_ty.tuple_fields().enumerate().any(|(i, element_ty)| {\n+                    let paths_using_field = captured_projs\n+                        .iter()\n+                        .filter_map(|projs| {\n+                            if let ProjectionKind::Field(field_idx, _) = projs.first().unwrap().kind\n+                            {\n+                                if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                            } else {\n+                                unreachable!();\n+                            }\n+                        })\n+                        .collect();\n+\n+                    self.has_significant_drop_outside_of_captures(\n+                        closure_def_id,\n+                        closure_span,\n+                        element_ty,\n+                        paths_using_field,\n+                    )\n+                })\n+            }\n+\n+            // Anything else would be completely captured and therefore handled already.\n+            _ => unreachable!(),\n+        }\n+    }\n+\n     fn init_capture_kind(\n         &self,\n         capture_clause: hir::CaptureBy,"}, {"sha": "e24aa7d76f1942e71eabd506330d4717f44fa7a1", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -143,6 +143,7 @@ crate fn placeholder_type_error(\n     generics: &[hir::GenericParam<'_>],\n     placeholder_types: Vec<Span>,\n     suggest: bool,\n+    hir_ty: Option<&hir::Ty<'_>>,\n ) {\n     if placeholder_types.is_empty() {\n         return;\n@@ -173,12 +174,40 @@ crate fn placeholder_type_error(\n     }\n \n     let mut err = bad_placeholder_type(tcx, placeholder_types);\n+\n+    // Suggest, but only if it is not a function in const or static\n     if suggest {\n-        err.multipart_suggestion(\n-            \"use type parameters instead\",\n-            sugg,\n-            Applicability::HasPlaceholders,\n-        );\n+        let mut is_fn = false;\n+        let mut is_const = false;\n+        let mut is_static = false;\n+\n+        if let Some(hir_ty) = hir_ty {\n+            if let hir::TyKind::BareFn(_) = hir_ty.kind {\n+                is_fn = true;\n+\n+                // Check if parent is const or static\n+                let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n+                let parent_node = tcx.hir().get(parent_id);\n+\n+                if let hir::Node::Item(item) = parent_node {\n+                    if let hir::ItemKind::Const(_, _) = item.kind {\n+                        is_const = true;\n+                    } else if let hir::ItemKind::Static(_, _, _) = item.kind {\n+                        is_static = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // if function is wrapped around a const or static,\n+        // then don't show the suggestion\n+        if !(is_fn && (is_const || is_static)) {\n+            err.multipart_suggestion(\n+                \"use type parameters instead\",\n+                sugg,\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n     }\n     err.emit();\n }\n@@ -200,7 +229,14 @@ fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir\n     let mut visitor = PlaceholderHirTyCollector::default();\n     visitor.visit_item(item);\n \n-    placeholder_type_error(tcx, Some(generics.span), &generics.params[..], visitor.0, suggest);\n+    placeholder_type_error(\n+        tcx,\n+        Some(generics.span),\n+        &generics.params[..],\n+        visitor.0,\n+        suggest,\n+        None,\n+    );\n }\n \n impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n@@ -682,6 +718,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id(item_id);\n+\n     match it.kind {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n@@ -787,7 +824,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             // Account for `const C: _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false);\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n \n         hir::TraitItemKind::Type(_, Some(_)) => {\n@@ -796,7 +833,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             // Account for `type T = _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false);\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n \n         hir::TraitItemKind::Type(_, None) => {\n@@ -805,7 +842,8 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             // even if there is no concrete type.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false);\n+\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n     };\n \n@@ -826,7 +864,8 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n             // Account for `type T = _;`\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_impl_item(impl_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false);\n+\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n         hir::ImplItemKind::Const(..) => {}\n     }\n@@ -1654,6 +1693,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     &sig.decl,\n                     &generics,\n                     Some(ident.span),\n+                    None,\n                 ),\n             }\n         }\n@@ -1663,9 +1703,15 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             ident,\n             generics,\n             ..\n-        }) => {\n-            AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl, &generics, Some(ident.span))\n-        }\n+        }) => AstConv::ty_of_fn(\n+            &icx,\n+            header.unsafety,\n+            header.abi,\n+            decl,\n+            &generics,\n+            Some(ident.span),\n+            None,\n+        ),\n \n         ForeignItem(&hir::ForeignItem {\n             kind: ForeignItemKind::Fn(ref fn_decl, _, _),\n@@ -2335,6 +2381,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         decl,\n         &hir::Generics::empty(),\n         Some(ident.span),\n+        None,\n     );\n \n     // Feature gate SIMD types in FFI, since I am not sure that the"}, {"sha": "783c802448199918cebe654cf4e9dabd1fb538a4", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -103,7 +103,8 @@ where\n     }\n }\n \n-/// Equivalent to `range_search(k, v, ..)` but without the `Ord` bound.\n+/// Equivalent to `range_search(root1, root2, ..)` but without the `Ord` bound.\n+/// Equivalent to `(root1.first_leaf_edge(), root2.last_leaf_edge())` but more efficient.\n fn full_range<BorrowType: marker::BorrowType, K, V>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n@@ -130,7 +131,7 @@ fn full_range<BorrowType: marker::BorrowType, K, V>(\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Creates a pair of leaf edges delimiting a specified range in or underneath a node.\n+    /// Finds the pair of leaf edges delimiting a specific range in a tree.\n     ///\n     /// The result is meaningful only if the tree is ordered by key, like the tree\n     /// in a `BTreeMap` is.\n@@ -149,7 +150,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n         range_search(self, self, range)\n     }\n \n-    /// Returns (self.first_leaf_edge(), self.last_leaf_edge()), but more efficiently.\n+    /// Finds the pair of leaf edges delimiting an entire tree.\n     pub fn full_range(\n         self,\n     ) -> ("}, {"sha": "4fc32305f1e30a0066cf86f2f3e13dda45bd05e0", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -181,7 +181,7 @@ impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Irreversibly transistions to a reference that offers traversal,\n+    /// Irreversibly transitions to a reference that permits traversal and offers\n     /// destructive methods and little else.\n     pub fn into_dying(self) -> NodeRef<marker::Dying, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }"}, {"sha": "7572b8c6f4a8c761b9d14fede1f5fcaae3986b57", "filename": "src/etc/check_missing_items.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -108,7 +108,7 @@ def check_type(ty):\n     elif ty[\"kind\"] == \"function_pointer\":\n         for param in ty[\"inner\"][\"generic_params\"]:\n             check_generic_param(param)\n-        check_decl(ty[\"inner\"][\"inner\"])\n+        check_decl(ty[\"inner\"][\"decl\"])\n     elif ty[\"kind\"] == \"qualified_path\":\n         check_type(ty[\"inner\"][\"self_type\"])\n         check_type(ty[\"inner\"][\"trait\"])"}, {"sha": "1b9a35e649172e18bb6b878d6b2f230cf36a908c", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -14,7 +14,7 @@ minifier = \"0.0.33\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n-smallvec = \"1.0\"\n+smallvec = \"1.6.1\"\n tempfile = \"3\"\n itertools = \"0.9\"\n regex = \"1\""}, {"sha": "e2652ca378a81d78bade61d2edf208d1a8409291", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -2,6 +2,8 @@\n //! the `clean` types but with some fields removed or stringified to simplify the output and not\n //! expose unstable compiler internals.\n \n+#![allow(rustc::default_hash_types)]\n+\n use std::convert::From;\n \n use rustc_ast::ast;\n@@ -16,6 +18,7 @@ use crate::clean;\n use crate::clean::utils::print_const_expr;\n use crate::formats::item_type::ItemType;\n use crate::json::JsonRenderer;\n+use std::collections::HashSet;\n \n impl JsonRenderer<'_> {\n     pub(super) fn convert_item(&self, item: clean::Item) -> Option<Item> {\n@@ -225,15 +228,22 @@ crate fn from_ctor_kind(struct_type: CtorKind) -> StructType {\n     }\n }\n \n-fn stringify_header(header: &rustc_hir::FnHeader) -> String {\n-    let mut s = String::from(header.unsafety.prefix_str());\n-    if header.asyncness == rustc_hir::IsAsync::Async {\n-        s.push_str(\"async \")\n+crate fn from_fn_header(header: &rustc_hir::FnHeader) -> HashSet<Qualifiers> {\n+    let mut v = HashSet::new();\n+\n+    if let rustc_hir::Unsafety::Unsafe = header.unsafety {\n+        v.insert(Qualifiers::Unsafe);\n+    }\n+\n+    if let rustc_hir::IsAsync::Async = header.asyncness {\n+        v.insert(Qualifiers::Async);\n     }\n-    if header.constness == rustc_hir::Constness::Const {\n-        s.push_str(\"const \")\n+\n+    if let rustc_hir::Constness::Const = header.constness {\n+        v.insert(Qualifiers::Const);\n     }\n-    s\n+\n+    v\n }\n \n impl From<clean::Function> for Function {\n@@ -242,7 +252,7 @@ impl From<clean::Function> for Function {\n         Function {\n             decl: decl.into(),\n             generics: generics.into(),\n-            header: stringify_header(&header),\n+            header: from_fn_header(&header),\n             abi: header.abi.to_string(),\n         }\n     }\n@@ -364,7 +374,13 @@ impl From<clean::BareFunctionDecl> for FunctionPointer {\n     fn from(bare_decl: clean::BareFunctionDecl) -> Self {\n         let clean::BareFunctionDecl { unsafety, generic_params, decl, abi } = bare_decl;\n         FunctionPointer {\n-            is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n+            header: if let rustc_hir::Unsafety::Unsafe = unsafety {\n+                let mut hs = HashSet::new();\n+                hs.insert(Qualifiers::Unsafe);\n+                hs\n+            } else {\n+                HashSet::new()\n+            },\n             generic_params: generic_params.into_iter().map(Into::into).collect(),\n             decl: decl.into(),\n             abi: abi.to_string(),\n@@ -439,7 +455,7 @@ crate fn from_function_method(function: clean::Function, has_body: bool) -> Meth\n     Method {\n         decl: decl.into(),\n         generics: generics.into(),\n-        header: stringify_header(&header),\n+        header: from_fn_header(&header),\n         abi: header.abi.to_string(),\n         has_body,\n     }"}, {"sha": "b31276c9dcb7fb49e5f35197f34573eb8e16054c", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -243,7 +243,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                     )\n                 })\n                 .collect(),\n-            format_version: 3,\n+            format_version: 4,\n         };\n         let mut p = self.out_path.clone();\n         p.push(output.index.get(&output.root).unwrap().name.clone().unwrap());"}, {"sha": "6188b87d2c61746e17a23f9f01a8e694475e1b55", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -3,7 +3,7 @@\n //! These types are the public API exposed through the `--output-format json` flag. The [`Crate`]\n //! struct is the root of the JSON blob and all other items are contained within.\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::path::PathBuf;\n \n use serde::{Deserialize, Serialize};\n@@ -281,19 +281,28 @@ pub enum StructType {\n     Unit,\n }\n \n+#[non_exhaustive]\n+#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]\n+#[serde(rename_all = \"snake_case\")]\n+pub enum Qualifiers {\n+    Const,\n+    Unsafe,\n+    Async,\n+}\n+\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub header: String,\n+    pub header: HashSet<Qualifiers>,\n     pub abi: String,\n }\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct Method {\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub header: String,\n+    pub header: HashSet<Qualifiers>,\n     pub abi: String,\n     pub has_body: bool,\n }\n@@ -404,9 +413,9 @@ pub enum Type {\n \n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct FunctionPointer {\n-    pub is_unsafe: bool,\n-    pub generic_params: Vec<GenericParamDef>,\n     pub decl: FnDecl,\n+    pub generic_params: Vec<GenericParamDef>,\n+    pub header: HashSet<Qualifiers>,\n     pub abi: String,\n }\n "}, {"sha": "a5038e0cd2aa86e6dfe72294514d0bd75ea974ff", "filename": "src/test/rustdoc-json/fn_pointer/header.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Frustdoc-json%2Ffn_pointer%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Frustdoc-json%2Ffn_pointer%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ffn_pointer%2Fheader.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,5 @@\n+// @has header.json \"$.index[*][?(@.name=='FnPointer')].inner.type.inner.header\" \"[]\"\n+pub type FnPointer = fn();\n+\n+// @has - \"$.index[*][?(@.name=='UnsafePointer')].inner.type.inner.header\" '[\"unsafe\"]'\n+pub type UnsafePointer = unsafe fn();"}, {"sha": "29741dd50dadc927e5a3b7696b317233c14b5cdc", "filename": "src/test/rustdoc-json/fns/header.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Frustdoc-json%2Ffns%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Frustdoc-json%2Ffns%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ffns%2Fheader.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,22 @@\n+// edition:2018\n+\n+// @has header.json \"$.index[*][?(@.name=='nothing_fn')].inner.header\" \"[]\"\n+pub fn nothing_fn() {}\n+\n+// @has - \"$.index[*][?(@.name=='const_fn')].inner.header\" '[\"const\"]'\n+pub const fn const_fn() {}\n+\n+// @has - \"$.index[*][?(@.name=='async_fn')].inner.header\" '[\"async\"]'\n+pub async fn async_fn() {}\n+\n+// @count - \"$.index[*][?(@.name=='async_unsafe_fn')].inner.header[*]\" 2\n+// @has - \"$.index[*][?(@.name=='async_unsafe_fn')].inner.header[*]\" '\"async\"'\n+// @has - \"$.index[*][?(@.name=='async_unsafe_fn')].inner.header[*]\" '\"unsafe\"'\n+pub async unsafe fn async_unsafe_fn() {}\n+\n+// @count - \"$.index[*][?(@.name=='const_unsafe_fn')].inner.header[*]\" 2\n+// @has - \"$.index[*][?(@.name=='const_unsafe_fn')].inner.header[*]\" '\"const\"'\n+// @has - \"$.index[*][?(@.name=='const_unsafe_fn')].inner.header[*]\" '\"unsafe\"'\n+pub const unsafe fn const_unsafe_fn() {}\n+\n+// It's impossible for a function to be both const and async, so no test for that"}, {"sha": "50a3db75ef395a14c315d7f88e4e1b13f77c88e2", "filename": "src/test/rustdoc-json/methods/header.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Frustdoc-json%2Fmethods%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Frustdoc-json%2Fmethods%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fmethods%2Fheader.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,26 @@\n+// edition:2018\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    // @has header.json \"$.index[*][?(@.name=='nothing_meth')].inner.header\" \"[]\"\n+    pub fn nothing_meth() {}\n+\n+    // @has - \"$.index[*][?(@.name=='const_meth')].inner.header\" '[\"const\"]'\n+    pub const fn const_meth() {}\n+\n+    // @has - \"$.index[*][?(@.name=='async_meth')].inner.header\" '[\"async\"]'\n+    pub async fn async_meth() {}\n+\n+    // @count - \"$.index[*][?(@.name=='async_unsafe_meth')].inner.header[*]\" 2\n+    // @has - \"$.index[*][?(@.name=='async_unsafe_meth')].inner.header[*]\" '\"async\"'\n+    // @has - \"$.index[*][?(@.name=='async_unsafe_meth')].inner.header[*]\" '\"unsafe\"'\n+    pub async unsafe fn async_unsafe_meth() {}\n+\n+    // @count - \"$.index[*][?(@.name=='const_unsafe_meth')].inner.header[*]\" 2\n+    // @has - \"$.index[*][?(@.name=='const_unsafe_meth')].inner.header[*]\" '\"const\"'\n+    // @has - \"$.index[*][?(@.name=='const_unsafe_meth')].inner.header[*]\" '\"unsafe\"'\n+    pub const unsafe fn const_unsafe_meth() {}\n+\n+    // It's impossible for a method to be both const and async, so no test for that\n+}"}, {"sha": "0e606eac1e8b6d1a17fa74f30a163a63b1f4f4e9", "filename": "src/test/ui/attributes/attrs-on-params.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fattributes%2Fattrs-on-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fattributes%2Fattrs-on-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fattrs-on-params.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,8 @@\n+// This checks that incorrect params on function parameters are caught\n+\n+fn function(#[inline] param: u32) {\n+    //~^ ERROR attribute should be applied to function or closure\n+    //~| ERROR allow, cfg, cfg_attr, deny, forbid, and warn are the only allowed built-in attributes\n+}\n+\n+fn main() {}"}, {"sha": "003f43d371a35ba59154d1880f8d462a37f9368e", "filename": "src/test/ui/attributes/attrs-on-params.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fattributes%2Fattrs-on-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fattributes%2Fattrs-on-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fattrs-on-params.stderr?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,17 @@\n+error: allow, cfg, cfg_attr, deny, forbid, and warn are the only allowed built-in attributes in function parameters\n+  --> $DIR/attrs-on-params.rs:3:13\n+   |\n+LL | fn function(#[inline] param: u32) {\n+   |             ^^^^^^^^^\n+\n+error[E0518]: attribute should be applied to function or closure\n+  --> $DIR/attrs-on-params.rs:3:13\n+   |\n+LL | fn function(#[inline] param: u32) {\n+   |             ^^^^^^^^^-----------\n+   |             |\n+   |             not a function or closure\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0518`."}, {"sha": "4a01b60c1f62b55d25a8f5dbb63d95528ec97b24", "filename": "src/test/ui/borrowck/issue-82032.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fborrowck%2Fissue-82032.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fborrowck%2Fissue-82032.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-82032.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,16 @@\n+use std::{fs, io::*};\n+use std::collections::HashMap;\n+\n+type Handle = BufWriter<fs::File>;\n+struct Thing(HashMap<String, Handle>);\n+\n+impl Thing {\n+    pub fn die_horribly(&mut self) {\n+        for v in self.0.values() {\n+            v.flush();\n+              //~^ ERROR cannot borrow\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f272477a9f5b393dfb7040adc56c993b3ede5ed2", "filename": "src/test/ui/borrowck/issue-82032.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fborrowck%2Fissue-82032.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fborrowck%2Fissue-82032.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-82032.stderr?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,14 @@\n+error[E0596]: cannot borrow `*v` as mutable, as it is behind a `&` reference\n+  --> $DIR/issue-82032.rs:10:13\n+   |\n+LL |         for v in self.0.values() {\n+   |                  ---------------\n+   |                  |      |\n+   |                  |      help: use mutable method: `values_mut()`\n+   |                  this iterator yields `&` references\n+LL |             v.flush();\n+   |             ^ `v` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "79702cc6b56f3baf9b8f2ad1b5cc6583bd1a1176", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,78 @@\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+#[derive(Debug)]\n+struct ContainsAndImplsDrop(Foo);\n+impl Drop for ContainsAndImplsDrop {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// Test that even if all paths starting at root variable that implement Drop are captured,\n+// the lint is triggered if the root variable implements drop and isn't captured.\n+fn test_precise_analysis_parent_root_impl_drop_not_captured() {\n+    let t = ContainsAndImplsDrop(Foo(10));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+    };\n+\n+    c();\n+}\n+\n+// Test that lint is triggered if a path that implements Drop is not captured by move\n+fn test_precise_analysis_drop_paths_not_captured_by_move() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(t));\n+        let _t = t.0;\n+        let _t = &t.1;\n+    };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test precise analysis for the lint works with paths longer than one.\n+fn test_precise_analysis_long_path_missing() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || {\n+    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| NOTE: drop(&(u));\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_parent_root_impl_drop_not_captured();\n+    test_precise_analysis_drop_paths_not_captured_by_move();\n+    test_precise_analysis_long_path_missing();\n+}"}, {"sha": "968ca395f946ef9ccaab6fe357a776aa59905a75", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,49 @@\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:27:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/precise.rs:1:9\n+   |\n+LL | #![deny(disjoint_capture_drop_reorder)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:40:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _t = t.0;\n+LL | |         let _t = &t.1;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(t));\n+\n+error: drop order affected for closure because of `capture_disjoint_fields`\n+  --> $DIR/precise.rs:63:13\n+   |\n+LL |       let c = || {\n+   |  _____________^\n+LL | |\n+LL | |\n+LL | |         let _x = u.0.0;\n+LL | |         let _x = u.0.1;\n+LL | |         let _x = u.1.0;\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: drop(&(u));\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "8af48501ca2952670fe96143363d1c8ad0f3b0a5", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise_no_migrations.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise_no_migrations.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,105 @@\n+// run-pass\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+// Test that if all paths starting at root variable that implement Drop are captured\n+// then it doesn't trigger the lint.\n+fn test_precise_analysis_simple_1() {\n+    let t = (Foo(10), Foo(20), Foo(30));\n+\n+    let c = || {\n+        let _t = t.0;\n+        let _t = t.1;\n+        let _t = t.2;\n+    };\n+\n+    c();\n+}\n+\n+// Test that if all paths starting at root variable that implement Drop are captured\n+// then it doesn't trigger the lint.\n+fn test_precise_analysis_simple_2() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+        let _t = t.0;\n+        let _t = t.1;\n+    };\n+\n+    c();\n+}\n+\n+#[derive(Debug)]\n+struct ContainsAndImplsDrop(Foo);\n+impl Drop for ContainsAndImplsDrop {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+// If a path isn't directly captured but requires Drop, then this tests that migrations aren't\n+// needed if the a parent to that path is captured.\n+fn test_precise_analysis_parent_captured_1() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || {\n+        let _t = t;\n+    };\n+\n+    c();\n+}\n+\n+// If a path isn't directly captured but requires Drop, then this tests that migrations aren't\n+// needed if the a parent to that path is captured.\n+fn test_precise_analysis_parent_captured_2() {\n+    let t = ContainsAndImplsDrop(Foo(10));\n+\n+    let c = || {\n+        let _t = t;\n+    };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test that if the path is longer than just one element, precise analysis works correctly.\n+fn test_precise_analysis_long_path() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || {\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+        let _x = u.1.1;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_simple_1();\n+    test_precise_analysis_simple_2();\n+\n+    test_precise_analysis_parent_captured_1();\n+    test_precise_analysis_parent_captured_2();\n+\n+    test_precise_analysis_long_path();\n+}"}, {"sha": "1b54401097ea90c8094236ece2652bd8fef86044", "filename": "src/test/ui/generics/issue-32498.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fgenerics%2Fissue-32498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fgenerics%2Fissue-32498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-32498.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+#![allow(dead_code)]\n+\n+// Making sure that no overflow occurs.\n+\n+struct L<T> {\n+    n: Option<T>,\n+}\n+type L8<T> = L<L<L<L<L<L<L<L<T>>>>>>>>;\n+type L64<T> = L8<L8<L8<L8<T>>>>;\n+\n+fn main() {\n+    use std::mem::size_of;\n+    assert_eq!(size_of::<L64<L64<()>>>(), 1);\n+    assert_eq!(size_of::<L<L64<L64<()>>>>(), 1);\n+}"}, {"sha": "e602425059e1b893cbd25d921e4e9b9d5f2c0e1d", "filename": "src/test/ui/issues/issue-74086.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fissues%2Fissue-74086.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fissues%2Fissue-74086.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-74086.stderr?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -2,10 +2,7 @@ error[E0121]: the type placeholder `_` is not allowed within types on item signa\n   --> $DIR/issue-74086.rs:2:20\n    |\n LL |     static BUG: fn(_) -> u8 = |_| 8;\n-   |                    ^\n-   |                    |\n-   |                    not allowed in type signatures\n-   |                    help: use type parameters instead: `T`\n+   |                    ^ not allowed in type signatures\n \n error: aborting due to previous error\n "}, {"sha": "86c39d4a48c05cc037a834432b6fb2cf04973098", "filename": "src/test/ui/issues/issue-81885.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fissues%2Fissue-81885.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fissues%2Fissue-81885.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-81885.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,10 @@\n+const TEST4: fn() -> _ = 42;\n+                  //~^ ERROR the type placeholder `_` is not allowed within types on item\n+                  //signatures\n+\n+fn main() {\n+    const TEST5: fn() -> _ = 42;\n+                      //~^ ERROR the type placeholder `_` is not allowed within types on item\n+                      //signatures\n+\n+}"}, {"sha": "955b4283874421015017af2163978d0d4a4f5718", "filename": "src/test/ui/issues/issue-81885.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fissues%2Fissue-81885.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fissues%2Fissue-81885.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-81885.stderr?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -0,0 +1,15 @@\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-81885.rs:1:22\n+   |\n+LL | const TEST4: fn() -> _ = 42;\n+   |                      ^ not allowed in type signatures\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-81885.rs:6:26\n+   |\n+LL |     const TEST5: fn() -> _ = 42;\n+   |                          ^ not allowed in type signatures\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "65d8bcd9972e65bf82b6c1b9ecbcccaf34379d24", "filename": "src/test/ui/proc-macro/ambiguous-builtin-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -3,8 +3,8 @@\n #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n \n extern crate builtin_attrs;\n-use builtin_attrs::{test, bench};\n use builtin_attrs::*;\n+use builtin_attrs::{bench, test};\n \n #[repr(C)] //~ ERROR `repr` is ambiguous\n struct S;"}, {"sha": "1ad991db3be4450e6861de7ae4dadd516871d27d", "filename": "src/test/ui/proc-macro/ambiguous-builtin-attrs.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -12,7 +12,7 @@ LL | #[repr(C)]\n    |\n    = note: `repr` could refer to a built-in attribute\n note: `repr` could also refer to the attribute macro imported here\n-  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+  --> $DIR/ambiguous-builtin-attrs.rs:6:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL | #[cfg_attr(all(), repr(C))]\n    |\n    = note: `repr` could refer to a built-in attribute\n note: `repr` could also refer to the attribute macro imported here\n-  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+  --> $DIR/ambiguous-builtin-attrs.rs:6:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n@@ -40,7 +40,7 @@ LL | fn non_macro_expanded_location<#[repr(C)] T>() {\n    |\n    = note: `repr` could refer to a built-in attribute\n note: `repr` could also refer to the attribute macro imported here\n-  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+  --> $DIR/ambiguous-builtin-attrs.rs:6:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n@@ -54,7 +54,7 @@ LL |         #[repr(C)]\n    |\n    = note: `repr` could refer to a built-in attribute\n note: `repr` could also refer to the attribute macro imported here\n-  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+  --> $DIR/ambiguous-builtin-attrs.rs:6:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n@@ -82,7 +82,7 @@ LL | #![feature(decl_macro)]\n    |\n    = note: `feature` could refer to a built-in attribute\n note: `feature` could also refer to the attribute macro imported here\n-  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+  --> $DIR/ambiguous-builtin-attrs.rs:6:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^"}, {"sha": "f868c8d483486f30f267bf540fbeda84688e8f5a", "filename": "src/test/ui/typeck/typeck_type_placeholder_item_help.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -29,10 +29,7 @@ error[E0121]: the type placeholder `_` is not allowed within types on item signa\n   --> $DIR/typeck_type_placeholder_item_help.rs:13:22\n    |\n LL | const TEST4: fn() -> _ = 42;\n-   |                      ^\n-   |                      |\n-   |                      not allowed in type signatures\n-   |                      help: use type parameters instead: `T`\n+   |                      ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/typeck_type_placeholder_item_help.rs:17:18"}, {"sha": "8da7db2dfddb45f0f2c3c936e6441d902dff856f", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9503ea19edbf01b9435e80e17d60ce1b88390116/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=9503ea19edbf01b9435e80e17d60ce1b88390116", "patch": "@@ -71,8 +71,8 @@ proc-macro2 = { version = \"1\", features = [\"default\"] }\n quote = { version = \"1\", features = [\"default\"] }\n serde = { version = \"1.0.82\", features = ['derive'] }\n serde_json = { version = \"1.0.31\", features = [\"raw_value\", \"unbounded_depth\"] }\n-smallvec-0_6 = { package = \"smallvec\", version = \"0.6\", features = ['union', 'may_dangle'] }\n-smallvec = { version = \"1.0\", features = ['union', 'may_dangle'] }\n+smallvec-0_6 = { package = \"smallvec\", version = \"0.6.14\", features = ['union', 'may_dangle'] }\n+smallvec = { version = \"1.6.1\", features = ['union', 'may_dangle'] }\n syn = { version = \"1\", features = ['fold', 'full', 'extra-traits', 'visit', 'visit-mut'] }\n url = { version = \"2.0\", features = ['serde'] }\n "}]}