{"sha": "b36abea285e7615f12c079c40d3a68c9eee15c8d", "node_id": "C_kwDOAAsO6NoAKGIzNmFiZWEyODVlNzYxNWYxMmMwNzljNDBkM2E2OGM5ZWVlMTVjOGQ", "commit": {"author": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-03-03T12:41:22Z"}, "committer": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-04-04T15:34:50Z"}, "message": "Migrate SuggestAsRefWhereAppropriate", "tree": {"sha": "052f57a4d967e0c3ee2d9d0021272679000bb20d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/052f57a4d967e0c3ee2d9d0021272679000bb20d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b36abea285e7615f12c079c40d3a68c9eee15c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b36abea285e7615f12c079c40d3a68c9eee15c8d", "html_url": "https://github.com/rust-lang/rust/commit/b36abea285e7615f12c079c40d3a68c9eee15c8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b36abea285e7615f12c079c40d3a68c9eee15c8d/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37f55691f46741d783ba482d42f1cf5ef60593a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/37f55691f46741d783ba482d42f1cf5ef60593a9", "html_url": "https://github.com/rust-lang/rust/commit/37f55691f46741d783ba482d42f1cf5ef60593a9"}], "stats": {"total": 160, "additions": 131, "deletions": 29}, "files": [{"sha": "2cdc513d73c7a4485f31207992b13d5d14dae2d0", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b36abea285e7615f12c079c40d3a68c9eee15c8d/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b36abea285e7615f12c079c40d3a68c9eee15c8d/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=b36abea285e7615f12c079c40d3a68c9eee15c8d", "patch": "@@ -353,3 +353,10 @@ infer_fps_use_ref = consider using a reference\n infer_fps_remove_ref = consider removing the reference\n infer_fps_cast = consider casting to a fn pointer\n infer_fps_items_are_distinct = fn items are distinct from fn pointers\n+infer_fps_cast_both = consider casting both fn items to fn pointers using `as {$expected_sig}`\n+\n+infer_fn_uniq_types = different fn items have unique types, even if their signatures are the same\n+infer_fn_consider_casting = consider casting the fn item to a fn pointer: `{$casting}`\n+\n+infer_sarwa_option = you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n+infer_sarwa_result = you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`"}, {"sha": "481199d99eaec70e811987a3d7da817f8f377157", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b36abea285e7615f12c079c40d3a68c9eee15c8d/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36abea285e7615f12c079c40d3a68c9eee15c8d/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=b36abea285e7615f12c079c40d3a68c9eee15c8d", "patch": "@@ -1158,6 +1158,14 @@ pub struct OpaqueCapturesLifetime<'tcx> {\n     pub opaque_ty: Ty<'tcx>,\n }\n \n+pub struct DiagArg<T>(pub T);\n+\n+impl<T: ToString> IntoDiagnosticArg for DiagArg<T> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        self.0.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n #[derive(Subdiagnostic)]\n pub enum FunctionPointerSuggestion<'a> {\n     #[suggestion(\n@@ -1212,8 +1220,72 @@ pub enum FunctionPointerSuggestion<'a> {\n         #[skip_arg]\n         sig: Binder<'a, FnSig<'a>>,\n     },\n+    #[suggestion(\n+        infer_fps_cast_both,\n+        code = \"{fn_name} as {found_sig}\",\n+        style = \"hidden\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastBoth {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        found_sig: Binder<'a, FnSig<'a>>,\n+        expected_sig: DiagArg<Binder<'a, FnSig<'a>>>,\n+    },\n+    #[suggestion(\n+        infer_fps_cast_both,\n+        code = \"&({fn_name} as {found_sig})\",\n+        style = \"hidden\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    CastBothRef {\n+        #[primary_span]\n+        span: Span,\n+        #[skip_arg]\n+        fn_name: String,\n+        #[skip_arg]\n+        found_sig: Binder<'a, FnSig<'a>>,\n+        expected_sig: DiagArg<Binder<'a, FnSig<'a>>>,\n+    },\n }\n \n #[derive(Subdiagnostic)]\n #[note(infer_fps_items_are_distinct)]\n pub struct FnItemsAreDistinct;\n+\n+#[derive(Subdiagnostic)]\n+#[note(infer_fn_uniq_types)]\n+pub struct FnUniqTypes;\n+\n+#[derive(Subdiagnostic)]\n+#[help(infer_fn_uniq_types)]\n+pub struct FnConsiderCasting {\n+    pub casting: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestAsRefWhereAppropriate<'a> {\n+    #[suggestion(\n+        infer_sarwa_option,\n+        code = \"{snippet}.as_ref()\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Option {\n+        #[primary_span]\n+        span: Span,\n+        snippet: &'a str,\n+    },\n+    #[suggestion(\n+        infer_sarwa_result,\n+        code = \"{snippet}.as_ref()\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Result {\n+        #[primary_span]\n+        span: Span,\n+        snippet: &'a str,\n+    },\n+}"}, {"sha": "2d173e9d577616d3ee84839389b516ed7dcc6b19", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b36abea285e7615f12c079c40d3a68c9eee15c8d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36abea285e7615f12c079c40d3a68c9eee15c8d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=b36abea285e7615f12c079c40d3a68c9eee15c8d", "patch": "@@ -13,12 +13,19 @@ use rustc_span::{sym, BytePos, Span};\n use rustc_target::abi::FieldIdx;\n \n use crate::errors::{\n-    ConsiderAddingAwait, FnItemsAreDistinct, FunctionPointerSuggestion, SuggAddLetForLetChains,\n+    ConsiderAddingAwait, DiagArg, FnConsiderCasting, FnItemsAreDistinct, FnUniqTypes,\n+    FunctionPointerSuggestion, SuggAddLetForLetChains, SuggestAsRefWhereAppropriate,\n     SuggestRemoveSemiOrReturnBinding,\n };\n \n use super::TypeErrCtxt;\n \n+#[derive(Clone, Copy)]\n+pub enum SuggestAsRefKind {\n+    Option,\n+    Result,\n+}\n+\n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_remove_semi_or_return_binding(\n         &self,\n@@ -322,15 +329,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         diag: &mut Diagnostic,\n     ) {\n         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+            && let Some(msg) = self.should_suggest_as_ref_kind(exp_found.expected, exp_found.found)\n         {\n-            diag.span_suggestion(\n-                span,\n-                msg,\n-                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                Applicability::MachineApplicable,\n-            );\n+            // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+            let snippet = snippet.trim_start_matches('&');\n+            let subdiag = match msg {\n+                SuggestAsRefKind::Option => SuggestAsRefWhereAppropriate::Option { span, snippet },\n+                SuggestAsRefKind::Result => SuggestAsRefWhereAppropriate::Result { span, snippet },\n+            };\n+            diag.subdiagnostic(subdiag);\n         }\n     }\n \n@@ -384,7 +391,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     &(self.normalize_fn_sig)(self.tcx.fn_sig(*did2).subst(self.tcx, substs2));\n \n                 if self.same_type_modulo_infer(*expected_sig, *found_sig) {\n-                    diag.note(\"different fn items have unique types, even if their signatures are the same\");\n+                    diag.subdiagnostic(FnUniqTypes);\n                 }\n \n                 if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n@@ -398,16 +405,22 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n                 let fn_name = self.tcx.def_path_str_with_substs(*did2, substs2);\n                 let sug = if found.is_ref() {\n-                    format!(\"&({fn_name} as {found_sig})\")\n+                    FunctionPointerSuggestion::CastBothRef {\n+                        span,\n+                        fn_name,\n+                        found_sig: *found_sig,\n+                        expected_sig: DiagArg(*expected_sig),\n+                    }\n                 } else {\n-                    format!(\"{fn_name} as {found_sig}\")\n+                    FunctionPointerSuggestion::CastBoth {\n+                        span,\n+                        fn_name,\n+                        found_sig: *found_sig,\n+                        expected_sig: DiagArg(*expected_sig),\n+                    }\n                 };\n \n-                let msg = format!(\n-                    \"consider casting both fn items to fn pointers using `as {expected_sig}`\"\n-                );\n-\n-                diag.span_suggestion_hidden(span, msg, sug, Applicability::MaybeIncorrect);\n+                diag.subdiagnostic(sug);\n             }\n             (ty::FnDef(did, substs), ty::FnPtr(sig)) => {\n                 let expected_sig =\n@@ -426,31 +439,27 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     format!(\"{fn_name} as {found_sig}\")\n                 };\n \n-                diag.help(&format!(\"consider casting the fn item to a fn pointer: `{}`\", casting));\n+                diag.subdiagnostic(FnConsiderCasting { casting });\n             }\n             _ => {\n                 return;\n             }\n         };\n     }\n \n-    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+    pub fn should_suggest_as_ref_kind(\n+        &self,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<SuggestAsRefKind> {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n             (expected.kind(), found.kind())\n         {\n             if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n                 if exp_def == &found_def {\n                     let have_as_ref = &[\n-                        (\n-                            sym::Option,\n-                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                        `.as_ref()`\",\n-                        ),\n-                        (\n-                            sym::Result,\n-                            \"you can convert from `&Result<T, E>` to \\\n-                        `Result<&T, &E>` using `.as_ref()`\",\n-                        ),\n+                        (sym::Option, SuggestAsRefKind::Option),\n+                        (sym::Result, SuggestAsRefKind::Result),\n                     ];\n                     if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n                         self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n@@ -484,6 +493,20 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         None\n     }\n \n+    // FIXME: Remove once rustc_hir_typeck is migrated to Diagnostics\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+        match self.should_suggest_as_ref_kind(expected, found) {\n+            Some(SuggestAsRefKind::Option) => Some(\n+                \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+            `.as_ref()`\",\n+            ),\n+            Some(SuggestAsRefKind::Result) => Some(\n+                \"you can convert from `&Result<T, E>` to \\\n+            `Result<&T, &E>` using `.as_ref()`\",\n+            ),\n+            None => None,\n+        }\n+    }\n     /// Try to find code with pattern `if Some(..) = expr`\n     /// use a `visitor` to mark the `if` which its span contains given error span,\n     /// and then try to find a assignment in the `cond` part, which span is equal with error span"}]}