{"sha": "85ef02d40446cccbc4a43a0d9fd4d39a67ff9037", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZWYwMmQ0MDQ0NmNjY2JjNGE0M2EwZDlmZDRkMzlhNjdmZjkwMzc=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-13T01:00:42Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:49Z"}, "message": "Only one DropValue per CleanupScope", "tree": {"sha": "c507479239b8028b5a25002729240f45e1b60e5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c507479239b8028b5a25002729240f45e1b60e5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037", "html_url": "https://github.com/rust-lang/rust/commit/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da971b765217bb3d729c448e88509fe817b94a8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/da971b765217bb3d729c448e88509fe817b94a8b", "html_url": "https://github.com/rust-lang/rust/commit/da971b765217bb3d729c448e88509fe817b94a8b"}], "stats": {"total": 161, "additions": 64, "deletions": 97}, "files": [{"sha": "971e01cc9e94875e1ef369e959fa98aa09b645d3", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=85ef02d40446cccbc4a43a0d9fd4d39a67ff9037", "patch": "@@ -389,8 +389,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.push_custom_cleanup_scope();\n-    fcx.schedule_drop_mem(self_scope, llenv, closure_ty);\n+    let self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n \n     let bcx = callee.call(bcx, &llargs[self_idx..], dest, None).0;\n "}, {"sha": "002e92d5223c653be858ae36d7eba3ca030695fe", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 58, "deletions": 90, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=85ef02d40446cccbc4a43a0d9fd4d39a67ff9037", "patch": "@@ -124,10 +124,10 @@ use value::Value;\n use rustc::ty::Ty;\n \n pub struct CleanupScope<'tcx> {\n-    // Cleanups to run upon scope exit.\n-    cleanups: Vec<DropValue<'tcx>>,\n+    // Cleanup to run upon scope exit.\n+    cleanup: DropValue<'tcx>,\n \n-    cached_early_exits: Vec<CachedEarlyExit>,\n+    cached_early_exit: Option<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n }\n \n@@ -146,95 +146,68 @@ enum UnwindKind {\n struct CachedEarlyExit {\n     label: UnwindKind,\n     cleanup_block: BasicBlockRef,\n-    last_cleanup: usize,\n }\n \n impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n-    pub fn push_custom_cleanup_scope(&self) -> CustomScopeIndex {\n-        let index = self.scopes_len();\n-        debug!(\"push_custom_cleanup_scope(): {}\", index);\n-        self.push_scope(CleanupScope::new());\n-        CustomScopeIndex { index: index }\n-    }\n-\n     /// Removes the top cleanup scope from the stack, which must be a temporary scope, and\n     /// generates the code to do its cleanups for normal exit.\n     pub fn pop_and_trans_custom_cleanup_scope(&self,\n-                                              mut bcx: BlockAndBuilder<'blk, 'tcx>,\n-                                              custom_scope: CustomScopeIndex)\n+                                              bcx: BlockAndBuilder<'blk, 'tcx>,\n+                                              custom_scope: Option<CustomScopeIndex>)\n                                               -> BlockAndBuilder<'blk, 'tcx> {\n         debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n+\n+        let custom_scope = if let Some(scope) = custom_scope {\n+            scope\n+        } else {\n+            return bcx;\n+        };\n+\n         assert!(self.is_valid_custom_scope(custom_scope));\n         assert!(custom_scope.index == self.scopes.borrow().len() - 1);\n \n         let scope = self.pop_scope();\n-        for cleanup in scope.cleanups.iter().rev() {\n-            bcx = cleanup.trans(bcx.funclet(), bcx);\n-        }\n-        bcx\n+        scope.cleanup.trans(bcx.funclet(), bcx)\n     }\n \n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of\n     /// `ty`\n-    pub fn schedule_drop_mem(&self,\n-                             cleanup_scope: CustomScopeIndex,\n-                             val: ValueRef,\n-                             ty: Ty<'tcx>) {\n-        if !self.type_needs_drop(ty) { return; }\n+    pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> Option<CustomScopeIndex> {\n+        if !self.type_needs_drop(ty) { return None; }\n         let drop = DropValue {\n             val: val,\n             ty: ty,\n             skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n-               cleanup_scope,\n-               Value(val),\n-               ty,\n-               drop.skip_dtor);\n+        debug!(\"schedule_drop_mem(val={:?}, ty={:?}) skip_dtor={}\", Value(val), ty, drop.skip_dtor);\n \n-        self.schedule_clean(cleanup_scope, drop);\n+        Some(self.push_scope(CleanupScope::new(drop)))\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self,\n-                                      cleanup_scope: CustomScopeIndex,\n-                                      val: ValueRef,\n-                                      ty: Ty<'tcx>) {\n+    pub fn schedule_drop_adt_contents(&self, val: ValueRef, ty: Ty<'tcx>)\n+        -> Option<CustomScopeIndex> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n-        if !self.type_needs_drop(ty) { return; }\n+        if !self.type_needs_drop(ty) { return None; }\n \n         let drop = DropValue {\n             val: val,\n             ty: ty,\n             skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_adt_contents({:?}, val={:?}, ty={:?}) skip_dtor={}\",\n-               cleanup_scope,\n+        debug!(\"schedule_drop_adt_contents(val={:?}, ty={:?}) skip_dtor={}\",\n                Value(val),\n                ty,\n                drop.skip_dtor);\n \n-        self.schedule_clean(cleanup_scope, drop);\n-    }\n-\n-    /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n-    fn schedule_clean(&self, custom_scope: CustomScopeIndex, cleanup: DropValue<'tcx>) {\n-        debug!(\"schedule_clean_in_custom_scope(custom_scope={})\",\n-               custom_scope.index);\n-\n-        assert!(self.is_valid_custom_scope(custom_scope));\n-\n-        let mut scopes = self.scopes.borrow_mut();\n-        let scope = &mut (*scopes)[custom_scope.index];\n-        scope.cleanups.push(cleanup);\n-        scope.cached_landing_pad = None;\n+        Some(self.push_scope(CleanupScope::new(drop)))\n     }\n \n     /// Returns true if there are pending cleanups that should execute on panic.\n@@ -335,11 +308,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         let llbb = self.get_or_create_landing_pad();\n \n         // Push the scopes we removed back on:\n-        loop {\n-            match popped_scopes.pop() {\n-                Some(scope) => self.push_scope(scope),\n-                None => break\n-            }\n+        while let Some(scope) = popped_scopes.pop() {\n+            self.push_scope(scope);\n         }\n \n         assert_eq!(self.scopes_len(), orig_scopes_len);\n@@ -356,8 +326,11 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         self.scopes.borrow().len()\n     }\n \n-    fn push_scope(&self, scope: CleanupScope<'tcx>) {\n-        self.scopes.borrow_mut().push(scope)\n+    fn push_scope(&self, scope: CleanupScope<'tcx>) -> CustomScopeIndex {\n+        let index = self.scopes_len();\n+        debug!(\"pushing custom cleanup scope: {}\", index);\n+        self.scopes.borrow_mut().push(scope);\n+        CustomScopeIndex { index: index }\n     }\n \n     fn pop_scope(&self) -> CleanupScope<'tcx> {\n@@ -401,7 +374,6 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         let orig_scopes_len = self.scopes_len();\n         let mut prev_llbb;\n         let mut popped_scopes = vec![];\n-        let mut skip = 0;\n \n         // First we pop off all the cleanup stacks that are\n         // traversed until the exit is reached, pushing them\n@@ -450,9 +422,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             // scope for this label. If so, we can stop popping scopes\n             // and branch to the cached label, since it contains the\n             // cleanups for any subsequent scopes.\n-            if let Some((exit, last_cleanup)) = cached_exit {\n+            if let Some(exit) = cached_exit {\n                 prev_llbb = exit;\n-                skip = last_cleanup;\n                 break;\n             }\n         }\n@@ -481,24 +452,17 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         // At this point, `popped_scopes` is empty, and so the final block\n         // that we return to the user is `Cleanup(AST 24)`.\n         while let Some(mut scope) = popped_scopes.pop() {\n-            if !scope.cleanups.is_empty() {\n-                let name = scope.block_name(\"clean\");\n-                debug!(\"generating cleanups for {}\", name);\n-\n-                let bcx_in = self.build_new_block(&name[..]);\n-                let exit_label = label.start(&bcx_in);\n-                let next_llbb = bcx_in.llbb();\n-                let mut bcx_out = bcx_in;\n-                let len = scope.cleanups.len();\n-                for cleanup in scope.cleanups.iter().rev().take(len - skip) {\n-                    bcx_out = cleanup.trans(bcx_out.funclet(), bcx_out);\n-                }\n-                skip = 0;\n-                exit_label.branch(&bcx_out, prev_llbb);\n-                prev_llbb = next_llbb;\n+            let name = scope.block_name(\"clean\");\n+            debug!(\"generating cleanup for {}\", name);\n \n-                scope.add_cached_early_exit(exit_label, prev_llbb, len);\n-            }\n+            let bcx_in = self.build_new_block(&name[..]);\n+            let exit_label = label.start(&bcx_in);\n+            let next_llbb = bcx_in.llbb();\n+            let bcx_out = scope.cleanup.trans(bcx_in.funclet(), bcx_in);\n+            exit_label.branch(&bcx_out, prev_llbb);\n+            prev_llbb = next_llbb;\n+\n+            scope.add_cached_early_exit(exit_label, prev_llbb);\n             self.push_scope(scope);\n         }\n \n@@ -510,33 +474,37 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n }\n \n impl<'tcx> CleanupScope<'tcx> {\n-    fn new() -> CleanupScope<'tcx> {\n+    fn new(drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n         CleanupScope {\n-            cleanups: vec![],\n-            cached_early_exits: vec![],\n+            cleanup: drop_val,\n+            cached_early_exit: None,\n             cached_landing_pad: None,\n         }\n     }\n \n-    fn cached_early_exit(&self, label: UnwindKind) -> Option<(BasicBlockRef, usize)> {\n-        self.cached_early_exits.iter().rev()\n-            .find(|e| e.label == label)\n-            .map(|e| (e.cleanup_block, e.last_cleanup))\n+    fn cached_early_exit(&self, label: UnwindKind) -> Option<BasicBlockRef> {\n+        if let Some(e) = self.cached_early_exit {\n+            if e.label == label {\n+                return Some(e.cleanup_block);\n+            }\n+        }\n+        None\n     }\n \n     fn add_cached_early_exit(&mut self,\n                              label: UnwindKind,\n-                             blk: BasicBlockRef,\n-                             last_cleanup: usize) {\n-        self.cached_early_exits.push(\n-            CachedEarlyExit { label: label,\n-                              cleanup_block: blk,\n-                              last_cleanup: last_cleanup});\n+                             blk: BasicBlockRef) {\n+        assert!(self.cached_early_exit.is_none());\n+        self.cached_early_exit = Some(CachedEarlyExit {\n+            label: label,\n+            cleanup_block: blk,\n+        });\n     }\n \n     /// True if this scope has cleanups that need unwinding\n     fn needs_invoke(&self) -> bool {\n-        self.cached_landing_pad.is_some() || !self.cleanups.is_empty()\n+        true\n+        //self.cached_landing_pad.is_some() || self.cleanups.is_empty()\n     }\n \n     /// Returns a suitable name to use for the basic block that handles this cleanup scope"}, {"sha": "692bf22d6f80c18d499f79a4edefc6ed73e9b698", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ef02d40446cccbc4a43a0d9fd4d39a67ff9037/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=85ef02d40446cccbc4a43a0d9fd4d39a67ff9037", "patch": "@@ -245,13 +245,13 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     //\n     // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n     // might well consider changing below to more direct code.\n-    let contents_scope = bcx.fcx().push_custom_cleanup_scope();\n-\n     // Issue #23611: schedule cleanup of contents, re-inspecting the\n     // discriminant (if any) in case of variant swap in drop code.\n-    if !shallow_drop {\n-        bcx.fcx().schedule_drop_adt_contents(contents_scope, v0, t);\n-    }\n+    let contents_scope = if !shallow_drop {\n+        bcx.fcx().schedule_drop_adt_contents(v0, t)\n+    } else {\n+        None\n+    };\n \n     let (sized_args, unsized_args);\n     let args: &[ValueRef] = if type_is_sized(tcx, t) {"}]}