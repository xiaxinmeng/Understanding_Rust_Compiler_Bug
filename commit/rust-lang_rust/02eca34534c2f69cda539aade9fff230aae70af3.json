{"sha": "02eca34534c2f69cda539aade9fff230aae70af3", "node_id": "C_kwDOAAsO6NoAKDAyZWNhMzQ1MzRjMmY2OWNkYTUzOWFhZGU5ZmZmMjMwYWFlNzBhZjM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-05-09T18:13:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-05-09T19:40:33Z"}, "message": "also sanity-check Abi::Vector, and slight refactoring", "tree": {"sha": "b350a9f7a0490b9f7cbb1f8a5938223471e074a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b350a9f7a0490b9f7cbb1f8a5938223471e074a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02eca34534c2f69cda539aade9fff230aae70af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02eca34534c2f69cda539aade9fff230aae70af3", "html_url": "https://github.com/rust-lang/rust/commit/02eca34534c2f69cda539aade9fff230aae70af3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02eca34534c2f69cda539aade9fff230aae70af3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04fb9222f861607b749a04e91e832475a5c8dc0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/04fb9222f861607b749a04e91e832475a5c8dc0f", "html_url": "https://github.com/rust-lang/rust/commit/04fb9222f861607b749a04e91e832475a5c8dc0f"}], "stats": {"total": 69, "additions": 43, "deletions": 26}, "files": [{"sha": "4879c622016e117e10e3e75e71049b27545574bd", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/02eca34534c2f69cda539aade9fff230aae70af3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eca34534c2f69cda539aade9fff230aae70af3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=02eca34534c2f69cda539aade9fff230aae70af3", "patch": "@@ -248,16 +248,36 @@ fn sanity_check_layout<'tcx>(\n                         \"size mismatch between ABI and layout in {layout:#?}\"\n                     );*/\n                 }\n+                Abi::Vector { count, element } => {\n+                    // No padding in vectors. Alignment can be strengthened, though.\n+                    assert!(\n+                        layout.align().abi >= element.align(&tcx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    let size = element.size(&tcx) * count;\n+                    assert_eq!(\n+                        layout.size(),\n+                        size.align_to(tcx.data_layout().vector_align(size).abi),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                }\n                 Abi::ScalarPair(scalar1, scalar2) => {\n-                    // Sanity-check scalar pair size.\n-                    let field2_offset = scalar1.size(&tcx).align_to(scalar2.align(&tcx).abi);\n-                    let total = field2_offset + scalar2.size(&tcx);\n+                    // Sanity-check scalar pairs. These are a bit more flexible and support\n+                    // padding, but we can at least ensure both fields actually fit into the layout\n+                    // and the alignment requirement has not been weakened.\n+                    let align1 = scalar1.align(&tcx).abi;\n+                    let align2 = scalar2.align(&tcx).abi;\n                     assert!(\n-                        layout.size() >= total,\n+                        layout.align().abi >= cmp::max(align1, align2),\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                    );\n+                    let field2_offset = scalar1.size(&tcx).align_to(align2);\n+                    assert!(\n+                        layout.size() >= field2_offset + scalar2.size(&tcx),\n                         \"size mismatch between ABI and layout in {layout:#?}\"\n                     );\n                 }\n-                _ => {}\n+                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n             }\n         }\n \n@@ -1401,16 +1421,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     // Without latter check aligned enums with custom discriminant values\n                     // Would result in ICE see the issue #92464 for more info\n                     abi = Abi::Scalar(tag);\n-                    // Make sure the variants with fields have the same ABI as the enum itself\n-                    // (since downcasting to them is a NOP).\n-                    for variant in &mut layout_variants {\n-                        if variant.fields.count() > 0\n-                            && matches!(variant.abi, Abi::Aggregate { .. })\n-                        {\n-                            assert_eq!(variant.size, size);\n-                            variant.abi = abi;\n-                        }\n-                    }\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n@@ -1479,17 +1489,24 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             // We can use `ScalarPair` only when it matches our\n                             // already computed layout (including `#[repr(C)]`).\n                             abi = pair.abi;\n-                            // Make sure the variants with fields have the same ABI as the enum itself\n-                            // (since downcasting to them is a NOP).\n-                            for variant in &mut layout_variants {\n-                                if variant.fields.count() > 0\n-                                    && matches!(variant.abi, Abi::Aggregate { .. })\n-                                {\n-                                    variant.abi = abi;\n-                                    // Also need to bump up the size, so that the pair fits inside.\n-                                    variant.size = size;\n-                                }\n-                            }\n+                        }\n+                    }\n+                }\n+\n+                // If we pick a \"clever\" (by-value) ABI, we might have to adjust the ABI of the\n+                // variants to ensure they are consistent. This is because a downcast is\n+                // semantically a NOP, and thus should not affect layout.\n+                if matches!(abi, Abi::Scalar(..) | Abi::ScalarPair(..)) {\n+                    for variant in &mut layout_variants {\n+                        // We only do this for variants with fields; the others are not accessed anyway.\n+                        // Also do not overwrite any already existing \"clever\" ABIs.\n+                        if variant.fields.count() > 0\n+                            && matches!(variant.abi, Abi::Aggregate { .. })\n+                        {\n+                            variant.abi = abi;\n+                            // Also need to bump up the size and alignment, so that the entire value fits in here.\n+                            variant.size = cmp::max(variant.size, size);\n+                            variant.align.abi = cmp::max(variant.align.abi, align.abi);\n                         }\n                     }\n                 }"}]}