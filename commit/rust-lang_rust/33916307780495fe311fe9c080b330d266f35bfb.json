{"sha": "33916307780495fe311fe9c080b330d266f35bfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOTE2MzA3NzgwNDk1ZmUzMTFmZTljMDgwYjMzMGQyNjZmMzViZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T15:17:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T15:17:29Z"}, "message": "Auto merge of #30457 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #30272, #30286, #30365, #30381, #30384, #30398, #30406, #30408, #30420, #30431, #30447, #30452\n- Failed merges:", "tree": {"sha": "e4e5f3fcf28e4a7ca861ad3576747fb85795f9b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4e5f3fcf28e4a7ca861ad3576747fb85795f9b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33916307780495fe311fe9c080b330d266f35bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33916307780495fe311fe9c080b330d266f35bfb", "html_url": "https://github.com/rust-lang/rust/commit/33916307780495fe311fe9c080b330d266f35bfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33916307780495fe311fe9c080b330d266f35bfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de62f9d885623318206620ddd2856a288ccd3ee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/de62f9d885623318206620ddd2856a288ccd3ee4", "html_url": "https://github.com/rust-lang/rust/commit/de62f9d885623318206620ddd2856a288ccd3ee4"}, {"sha": "a8e424685cbf4db8fced2cee71f9d1b36e0dcf4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e424685cbf4db8fced2cee71f9d1b36e0dcf4b", "html_url": "https://github.com/rust-lang/rust/commit/a8e424685cbf4db8fced2cee71f9d1b36e0dcf4b"}], "stats": {"total": 2568, "additions": 1371, "deletions": 1197}, "files": [{"sha": "e4a900a2b1a4f8c79b9d7e538460d64680d4878e", "filename": "src/doc/book/macros.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Fdoc%2Fbook%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Fdoc%2Fbook%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmacros.md?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -485,10 +485,10 @@ These rules provide some flexibility for Rust\u2019s syntax to evolve without\n breaking existing macros.\n \n The macro system does not deal with parse ambiguity at all. For example, the\n-grammar `$($t:ty)* $e:expr` will always fail to parse, because the parser would\n-be forced to choose between parsing `$t` and parsing `$e`. Changing the\n+grammar `$($i:ident)* $e:expr` will always fail to parse, because the parser would\n+be forced to choose between parsing `$i` and parsing `$e`. Changing the\n invocation syntax to put a distinctive token in front can solve the problem. In\n-this case, you can write `$(T $t:ty)* E $e:exp`.\n+this case, you can write `$(I $i:ident)* E $e:expr`.\n \n [item]: ../reference.html#items\n "}, {"sha": "43f1bd2529fd2c85e7455f1e7cdfeaa233c56f04", "filename": "src/doc/book/patterns.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Fdoc%2Fbook%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Fdoc%2Fbook%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fpatterns.md?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -27,7 +27,7 @@ There\u2019s one pitfall with patterns: like anything that introduces a new binding\n they introduce shadowing. For example:\n \n ```rust\n-let x = 'x';\n+let x = 1;\n let c = 'c';\n \n match c {\n@@ -41,12 +41,14 @@ This prints:\n \n ```text\n x: c c: c\n-x: x\n+x: 1\n ```\n \n In other words, `x =>` matches the pattern and introduces a new binding named\n-`x` that\u2019s in scope for the match arm. Because we already have a binding named\n-`x`, this new `x` shadows it.\n+`x`. This new binding is in scope for the match arm and takes on the value of\n+`c`. Notice that the value of `x` outside the scope of the match has no bearing\n+on the value of `x` within it. Because we already have a binding named `x`, this\n+new `x` shadows it.\n \n # Multiple patterns\n "}, {"sha": "db22000fd9f5d1b5080315b0324aa61c2ab04579", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -47,7 +47,7 @@ use rustc_front::hir;\n use rustc_front::util;\n use rustc_front::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n-use syntax::diagnostic;\n+use syntax::errors;\n \n /// Information about the registered lints.\n ///\n@@ -167,7 +167,7 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(diagnostic::Auto, &msg[..]),\n+                    (None, _) => early_error(errors::ColorConfig::Auto, &msg[..]),\n                     (Some(sess), false) => sess.bug(&msg[..]),\n \n                     // A duplicate name from a plugin is a user error.\n@@ -191,7 +191,7 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(diagnostic::Auto, &msg[..]),\n+                (None, _) => early_error(errors::ColorConfig::Auto, &msg[..]),\n                 (Some(sess), false) => sess.bug(&msg[..]),\n \n                 // A duplicate name from a plugin is a user error."}, {"sha": "cab7e45ee62832522f99b664a1d4b3f269967ff7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -517,7 +517,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n             if let VariantKind::Struct = v.kind() {\n-                let field_pats: Vec<_> = v.fields.iter()\n+                let field_pats: hir::HirVec<_> = v.fields.iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != hir::PatWild)\n                     .map(|(field, pat)| Spanned {\n@@ -540,14 +540,14 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n@@ -562,7 +562,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n-            hir::PatVec(pats.collect(), None, vec![])\n+            hir::PatVec(pats.collect(), None, hir::HirVec::new())\n         }\n \n         _ => {"}, {"sha": "54061a14d1419644ff1880c9849dbdf5a433f63b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -357,14 +357,14 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n \n         hir::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n-            hir::PatVec(pats, None, vec![])\n+            hir::PatVec(pats, None, hir::HirVec::new())\n         }\n \n         hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n-                    hir::PatStruct(path.clone(), vec![], false),\n+                    hir::PatStruct(path.clone(), hir::HirVec::new(), false),\n                 Some(def::DefVariant(..)) =>\n                     hir::PatEnum(path.clone(), None),\n                 _ => {"}, {"sha": "73776304bc846d65cec3a38d1dc0a8a9326e25c7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -324,7 +324,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<P<hir::Expr>>) {\n+    fn consume_exprs(&mut self, exprs: &[P<hir::Expr>]) {\n         for expr in exprs {\n             self.consume_expr(&**expr);\n         }\n@@ -651,7 +651,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     fn walk_struct_expr(&mut self,\n                         _expr: &hir::Expr,\n-                        fields: &Vec<hir::Field>,\n+                        fields: &[hir::Field],\n                         opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n@@ -697,7 +697,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.walk_expr(with_expr);\n \n         fn contains_field_named(field: ty::FieldDef,\n-                                fields: &Vec<hir::Field>)\n+                                fields: &[hir::Field])\n                                 -> bool\n         {\n             fields.iter().any("}, {"sha": "2abf499185690f7c8bd9ef3f251946637cb095f4", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -90,7 +90,6 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n@@ -1154,10 +1153,10 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_ty_params(&self,\n-                         ty_params: OwnedSlice<hir::TyParam>,\n+                         ty_params: P<[hir::TyParam]>,\n                          lifetime: hir::Lifetime,\n                          region_names: &HashSet<ast::Name>)\n-                         -> OwnedSlice<hir::TyParam> {\n+                         -> P<[hir::TyParam]> {\n         ty_params.map(|ty_param| {\n             let bounds = self.rebuild_ty_param_bounds(ty_param.bounds.clone(),\n                                                       lifetime,\n@@ -1173,10 +1172,10 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_ty_param_bounds(&self,\n-                               ty_param_bounds: OwnedSlice<hir::TyParamBound>,\n+                               ty_param_bounds: hir::TyParamBounds,\n                                lifetime: hir::Lifetime,\n                                region_names: &HashSet<ast::Name>)\n-                               -> OwnedSlice<hir::TyParamBound> {\n+                               -> hir::TyParamBounds {\n         ty_param_bounds.map(|tpb| {\n             match tpb {\n                 &hir::RegionTyParamBound(lt) => {\n@@ -1249,13 +1248,13 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         add: &Vec<hir::Lifetime>,\n                         keep: &HashSet<ast::Name>,\n                         remove: &HashSet<ast::Name>,\n-                        ty_params: OwnedSlice<hir::TyParam>,\n+                        ty_params: P<[hir::TyParam]>,\n                         where_clause: hir::WhereClause)\n                         -> hir::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add {\n             lifetimes.push(hir::LifetimeDef { lifetime: *lt,\n-                                              bounds: Vec::new() });\n+                                              bounds: hir::HirVec::new() });\n         }\n         for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||\n@@ -1264,7 +1263,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n         }\n         hir::Generics {\n-            lifetimes: lifetimes,\n+            lifetimes: lifetimes.into(),\n             ty_params: ty_params,\n             where_clause: where_clause,\n         }\n@@ -1275,7 +1274,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        lifetime: hir::Lifetime,\n                        anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n-                       -> Vec<hir::Arg> {\n+                       -> hir::HirVec<hir::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs {\n             let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n@@ -1287,7 +1286,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             };\n             new_inputs.push(possibly_new_arg);\n         }\n-        new_inputs\n+        new_inputs.into()\n     }\n \n     fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n@@ -1514,7 +1513,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                 });\n                 hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                    lifetimes: new_lts,\n+                    lifetimes: new_lts.into(),\n                     types: new_types,\n                     bindings: new_bindings,\n                })\n@@ -1530,7 +1529,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         hir::Path {\n             span: path.span,\n             global: path.global,\n-            segments: new_segs\n+            segments: new_segs.into()\n         }\n     }\n }"}, {"sha": "9b133c5401519f595ff08dbe9a6f86bc99e89ecd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -79,10 +79,10 @@ struct LifetimeContext<'a> {\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n-    EarlyScope(subst::ParamSpace, &'a Vec<hir::LifetimeDef>, Scope<'a>),\n+    EarlyScope(subst::ParamSpace, &'a [hir::LifetimeDef], Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n-    LateScope(&'a Vec<hir::LifetimeDef>, Scope<'a>),\n+    LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n \n     /// lifetimes introduced by a fn are scoped to the call-site for that fn.\n     FnScope { fn_id: ast::NodeId, body_id: ast::NodeId, s: Scope<'a> },\n@@ -206,7 +206,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n                     Some((def::DefTrait(..), 0)) => {\n-                        self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n+                        self.with(LateScope(&[], self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n                     }\n@@ -661,7 +661,7 @@ impl<'a> LifetimeContext<'a> {\n                     lifetime_ref.name);\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<hir::LifetimeDef>) {\n+    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n@@ -753,7 +753,7 @@ impl<'a> LifetimeContext<'a> {\n     }\n }\n \n-fn search_lifetimes<'a>(lifetimes: &'a Vec<hir::LifetimeDef>,\n+fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n                     lifetime_ref: &hir::Lifetime)\n                     -> Option<(u32, &'a hir::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {"}, {"sha": "a41ee51fb5546023991fd29f56b2f53a0b190806", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -82,7 +82,7 @@ struct Annotator<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>,\n+    fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Annotator)\n     {"}, {"sha": "ecb2b85fd77445c98fea253e61f4404dc4aaeb88", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -16,7 +16,7 @@ use middle::ty::fold::{TypeFoldable, TypeFolder};\n \n use std::rc::Rc;\n use syntax::abi;\n-use syntax::owned_slice::OwnedSlice;\n+use syntax::ptr::P;\n \n use rustc_front::hir;\n \n@@ -555,8 +555,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> P<[T]> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }"}, {"sha": "e33fe9570c024f9bfaac483a1da7c47776a4834b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -27,7 +27,7 @@ use middle::cstore;\n use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::{ColorConfig, Auto, Always, Never, SpanHandler};\n+use syntax::errors::{ColorConfig, Handler};\n use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n@@ -238,7 +238,7 @@ pub fn basic_options() -> Options {\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n-        color: Auto,\n+        color: ColorConfig::Auto,\n         show_span: None,\n         externs: HashMap::new(),\n         crate_name: None,\n@@ -687,19 +687,19 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     v\n }\n \n-pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n+pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n     let target = match Target::search(&opts.target_triple) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(sp.handler().fatal(&format!(\"Error loading target specification: {}\", e)));\n+            panic!(sp.fatal(&format!(\"Error loading target specification: {}\", e)));\n         }\n     };\n \n     let (int_type, uint_type) = match &target.target_pointer_width[..] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n-        w    => panic!(sp.handler().fatal(&format!(\"target specification was invalid: \\\n-                                                    unrecognized target-pointer-width {}\", w))),\n+        w    => panic!(sp.fatal(&format!(\"target specification was invalid: \\\n+                                          unrecognized target-pointer-width {}\", w))),\n     };\n \n     Config {\n@@ -884,16 +884,16 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n \n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\")   => Auto,\n-        Some(\"always\") => Always,\n-        Some(\"never\")  => Never,\n+        Some(\"auto\")   => ColorConfig::Auto,\n+        Some(\"always\") => ColorConfig::Always,\n+        Some(\"never\")  => ColorConfig::Never,\n \n-        None => Auto,\n+        None => ColorConfig::Auto,\n \n         Some(arg) => {\n-            early_error(Auto, &format!(\"argument for --color must be auto, always \\\n-                                        or never (instead was `{}`)\",\n-                                       arg))\n+            early_error(ColorConfig::Auto, &format!(\"argument for --color must be auto, always \\\n+                                                     or never (instead was `{}`)\",\n+                                                    arg))\n         }\n     };\n \n@@ -1224,7 +1224,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(!sess.can_print_warnings);\n+            assert!(!sess.diagnostic().can_emit_warnings);\n         }\n \n         {\n@@ -1236,7 +1236,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(sess.can_print_warnings);\n+            assert!(sess.diagnostic().can_emit_warnings);\n         }\n \n         {\n@@ -1247,7 +1247,7 @@ mod tests {\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry,\n                                      Rc::new(DummyCrateStore));\n-            assert!(sess.can_print_warnings);\n+            assert!(sess.diagnostic().can_emit_warnings);\n         }\n     }\n }"}, {"sha": "7b96db4bf0a3af87e3283dc5cd672b30c5303865", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 37, "deletions": 87, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -16,7 +16,8 @@ use util::nodemap::{NodeMap, FnvHashMap};\n \n use syntax::ast::{NodeId, NodeIdAssigner, Name};\n use syntax::codemap::Span;\n-use syntax::diagnostic::{self, Emitter};\n+use syntax::errors;\n+use syntax::errors::emitter::{Emitter, BasicEmitter};\n use syntax::diagnostics;\n use syntax::feature_gate;\n use syntax::parse;\n@@ -63,14 +64,10 @@ pub struct Session {\n     pub crate_metadata: RefCell<Vec<String>>,\n     pub features: RefCell<feature_gate::Features>,\n \n-    pub delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n-\n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: Cell<usize>,\n \n-    pub can_print_warnings: bool,\n-\n     /// The metadata::creader module may inject an allocator dependency if it\n     /// didn't already find one, and this tracks what was injected.\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n@@ -84,22 +81,13 @@ pub struct Session {\n \n impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         panic!(self.diagnostic().span_fatal(sp, msg))\n     }\n     pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         panic!(self.diagnostic().span_fatal_with_code(sp, msg, code))\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n-        if self.opts.treat_err_as_bug {\n-            self.bug(msg);\n-        }\n-        panic!(self.diagnostic().handler().fatal(msg))\n+        panic!(self.diagnostic().fatal(msg))\n     }\n     pub fn span_err_or_warn(&self, is_warning: bool, sp: Span, msg: &str) {\n         if is_warning {\n@@ -109,9 +97,6 @@ impl Session {\n         }\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err(sp, &msg[..]),\n             None => self.diagnostic().span_err(sp, msg)\n@@ -125,36 +110,22 @@ impl Session {\n                       See RFC 1214 for details.\"));\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.span_bug(sp, msg);\n-        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n         }\n     }\n     pub fn err(&self, msg: &str) {\n-        if self.opts.treat_err_as_bug {\n-            self.bug(msg);\n-        }\n-        self.diagnostic().handler().err(msg)\n+        self.diagnostic().err(msg)\n     }\n     pub fn err_count(&self) -> usize {\n-        self.diagnostic().handler().err_count()\n+        self.diagnostic().err_count()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.diagnostic().handler().has_errors()\n+        self.diagnostic().has_errors()\n     }\n     pub fn abort_if_errors(&self) {\n-        self.diagnostic().handler().abort_if_errors();\n-\n-        let delayed_bug = self.delayed_span_bug.borrow();\n-        match *delayed_bug {\n-            Some((span, ref errmsg)) => {\n-                self.diagnostic().span_bug(span, errmsg);\n-            },\n-            _ => {}\n-        }\n+        self.diagnostic().abort_if_errors();\n     }\n     pub fn abort_if_new_errors<F>(&self, mut f: F)\n         where F: FnMut()\n@@ -166,19 +137,13 @@ impl Session {\n         }\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().span_warn(sp, msg)\n-        }\n+        self.diagnostic().span_warn(sp, msg)\n     }\n     pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().span_warn_with_code(sp, msg, code)\n-        }\n+        self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n     pub fn warn(&self, msg: &str) {\n-        if self.can_print_warnings {\n-            self.diagnostic().handler().warn(msg)\n-        }\n+        self.diagnostic().warn(msg)\n     }\n     pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n         match opt_sp {\n@@ -195,7 +160,7 @@ impl Session {\n \n     /// Prints out a message with a suggested edit of the code.\n     ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    /// See `errors::RenderSpan::Suggestion` for more information.\n     pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n         self.diagnostic().span_suggestion(sp, msg, suggestion)\n     }\n@@ -209,10 +174,10 @@ impl Session {\n         self.diagnostic().fileline_help(sp, msg)\n     }\n     pub fn note(&self, msg: &str) {\n-        self.diagnostic().handler().note(msg)\n+        self.diagnostic().note(msg)\n     }\n     pub fn help(&self, msg: &str) {\n-        self.diagnostic().handler().help(msg)\n+        self.diagnostic().help(msg)\n     }\n     pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {\n         match opt_sp {\n@@ -222,20 +187,19 @@ impl Session {\n     }\n     /// Delay a span_bug() call until abort_if_errors()\n     pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n-        let mut delayed = self.delayed_span_bug.borrow_mut();\n-        *delayed = Some((sp, msg.to_string()));\n+        self.diagnostic().delay_span_bug(sp, msg)\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_bug(sp, msg)\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.diagnostic().handler().bug(msg)\n+        self.diagnostic().bug(msg)\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_unimpl(sp, msg)\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.diagnostic().handler().unimpl(msg)\n+        self.diagnostic().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n                     lint: &'static lint::Lint,\n@@ -260,7 +224,7 @@ impl Session {\n \n         id\n     }\n-    pub fn diagnostic<'a>(&'a self) -> &'a diagnostic::SpanHandler {\n+    pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }\n     pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n@@ -269,8 +233,7 @@ impl Session {\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp,\n-                      &format!(\"impossible case reached: {}\", msg));\n+        self.span_bug(sp, &format!(\"impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n@@ -413,30 +376,33 @@ pub fn build_session(sopts: config::Options,\n         .map(|&(_, ref level)| *level != lint::Allow)\n         .last()\n         .unwrap_or(true);\n+    let treat_err_as_bug = sopts.treat_err_as_bug;\n \n-    let codemap = codemap::CodeMap::new();\n+    let codemap = Rc::new(codemap::CodeMap::new());\n     let diagnostic_handler =\n-        diagnostic::Handler::new(sopts.color, Some(registry), can_print_warnings);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+        errors::Handler::new(sopts.color,\n+                             Some(registry),\n+                             can_print_warnings,\n+                             treat_err_as_bug,\n+                             codemap.clone());\n \n-    build_session_(sopts, local_crate_source_file, span_diagnostic_handler, cstore)\n+    build_session_(sopts, local_crate_source_file, diagnostic_handler, codemap, cstore)\n }\n \n pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<PathBuf>,\n-                      span_diagnostic: diagnostic::SpanHandler,\n+                      span_diagnostic: errors::Handler,\n+                      codemap: Rc<codemap::CodeMap>,\n                       cstore: Rc<for<'a> CrateStore<'a>>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,\n         Err(e) => {\n-            panic!(span_diagnostic.handler()\n-                                  .fatal(&format!(\"Error loading host specification: {}\", e)));\n+            panic!(span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)));\n     }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n-    let p_s = parse::ParseSess::with_span_handler(span_diagnostic);\n+    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,\n         None => Some(filesearch::get_or_default_sysroot())\n@@ -451,13 +417,6 @@ pub fn build_session_(sopts: config::Options,\n         }\n     );\n \n-    let can_print_warnings = sopts.lint_opts\n-        .iter()\n-        .filter(|&&(ref key, _)| *key == \"warnings\")\n-        .map(|&(_, ref level)| *level != lint::Allow)\n-        .last()\n-        .unwrap_or(true);\n-\n     let sess = Session {\n         target: target_cfg,\n         host: host,\n@@ -478,10 +437,8 @@ pub fn build_session_(sopts: config::Options,\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n         crate_metadata: RefCell::new(Vec::new()),\n-        delayed_span_bug: RefCell::new(None),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n-        can_print_warnings: can_print_warnings,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n         available_macros: RefCell::new(HashSet::new()),\n@@ -490,20 +447,13 @@ pub fn build_session_(sopts: config::Options,\n     sess\n }\n \n-// Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T, M>(sess: &Session, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n-{\n-    diagnostic::expect(sess.diagnostic(), opt, msg)\n-}\n-\n-pub fn early_error(color: diagnostic::ColorConfig, msg: &str) -> ! {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(color, None);\n-    emitter.emit(None, msg, None, diagnostic::Fatal);\n-    panic!(diagnostic::FatalError);\n+pub fn early_error(color: errors::ColorConfig, msg: &str) -> ! {\n+    let mut emitter = BasicEmitter::stderr(color);\n+    emitter.emit(None, msg, None, errors::Level::Fatal);\n+    panic!(errors::FatalError);\n }\n \n-pub fn early_warn(color: diagnostic::ColorConfig, msg: &str) {\n-    let mut emitter = diagnostic::EmitterWriter::stderr(color, None);\n-    emitter.emit(None, msg, None, diagnostic::Warning);\n+pub fn early_warn(color: errors::ColorConfig, msg: &str) {\n+    let mut emitter = BasicEmitter::stderr(color);\n+    emitter.emit(None, msg, None, errors::Level::Warning);\n }"}, {"sha": "6a787139d77aa88c3d96dfa981da7f41c9fbdfde", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -11,7 +11,7 @@\n use std::slice;\n use std::path::{Path, PathBuf};\n use session::early_error;\n-use syntax::diagnostic;\n+use syntax::errors;\n \n #[derive(Clone, Debug)]\n pub struct SearchPaths {\n@@ -38,7 +38,7 @@ impl SearchPaths {\n         SearchPaths { paths: Vec::new() }\n     }\n \n-    pub fn add_path(&mut self, path: &str, color: diagnostic::ColorConfig) {\n+    pub fn add_path(&mut self, path: &str, color: errors::ColorConfig) {\n         let (kind, path) = if path.starts_with(\"native=\") {\n             (PathKind::Native, &path[\"native=\".len()..])\n         } else if path.starts_with(\"crate=\") {"}, {"sha": "f259698a220e2be8022a92de7bc1fae45b0b3be7", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -48,7 +48,7 @@\n use serialize::json::Json;\n use std::default::Default;\n use std::io::prelude::*;\n-use syntax::{diagnostic, abi};\n+use syntax::abi;\n \n mod android_base;\n mod apple_base;\n@@ -263,17 +263,13 @@ impl Target {\n     pub fn from_json(obj: Json) -> Target {\n         // this is 1. ugly, 2. error prone.\n \n-\n-        let handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-\n         let get_req_field = |name: &str| {\n             match obj.find(name)\n                      .map(|s| s.as_string())\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n                 None => {\n-                    panic!(handler.fatal(&format!(\"Field {} in target specification is required\",\n-                                                  name)))\n+                    panic!(\"Field {} in target specification is required\", name)\n                 }\n             }\n         };"}, {"sha": "8cfaec62f47754cacf5cc2eea895ca647b68f125", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -59,8 +59,6 @@ extern crate log;\n extern crate syntax;\n extern crate syntax_ext;\n \n-pub use syntax::diagnostic;\n-\n use driver::CompileController;\n use pretty::{PpMode, UserIdentifiedItem};\n \n@@ -91,7 +89,8 @@ use rustc::session::early_error;\n \n use syntax::ast;\n use syntax::parse;\n-use syntax::diagnostic::Emitter;\n+use syntax::errors;\n+use syntax::errors::emitter::Emitter;\n use syntax::diagnostics;\n use syntax::parse::token;\n \n@@ -239,7 +238,7 @@ pub trait CompilerCalls<'a> {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &diagnostics::registry::Registry,\n-                      _: diagnostic::ColorConfig)\n+                      _: errors::ColorConfig)\n                       -> Compilation {\n         Compilation::Continue\n     }\n@@ -315,7 +314,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n                       descriptions: &diagnostics::registry::Registry,\n-                      color: diagnostic::ColorConfig)\n+                      color: errors::ColorConfig)\n                       -> Compilation {\n         match matches.opt_str(\"explain\") {\n             Some(ref code) => {\n@@ -774,7 +773,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                             &opt.opt_group.short_name\n                         };\n                         if m.opt_present(opt_name) {\n-                            early_error(diagnostic::Auto,\n+                            early_error(errors::ColorConfig::Auto,\n                                         &format!(\"use of unstable option '{}' requires -Z \\\n                                                   unstable-options\",\n                                                  opt_name));\n@@ -783,7 +782,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                 }\n                 m\n             }\n-            Err(f) => early_error(diagnostic::Auto, &f.to_string()),\n+            Err(f) => early_error(errors::ColorConfig::Auto, &f.to_string()),\n         }\n     }\n \n@@ -895,25 +894,25 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n         }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic\n-            if !value.is::<diagnostic::FatalError>() {\n-                let mut emitter = diagnostic::EmitterWriter::stderr(diagnostic::Auto, None);\n+            if !value.is::<errors::FatalError>() {\n+                let mut emitter = errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n \n                 // a .span_bug or .bug call has already printed what\n                 // it wants to print.\n-                if !value.is::<diagnostic::ExplicitBug>() {\n-                    emitter.emit(None, \"unexpected panic\", None, diagnostic::Bug);\n+                if !value.is::<errors::ExplicitBug>() {\n+                    emitter.emit(None, \"unexpected panic\", None, errors::Level::Bug);\n                 }\n \n                 let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                           format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n                 for note in &xs {\n-                    emitter.emit(None, &note[..], None, diagnostic::Note)\n+                    emitter.emit(None, &note[..], None, errors::Level::Note)\n                 }\n                 if let None = env::var_os(\"RUST_BACKTRACE\") {\n                     emitter.emit(None,\n                                  \"run with `RUST_BACKTRACE=1` for a backtrace\",\n                                  None,\n-                                 diagnostic::Note);\n+                                 errors::Level::Note);\n                 }\n \n                 println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());"}, {"sha": "df9294a9d5bfb518cbcab55efb94e6b909154294", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -10,8 +10,6 @@\n \n //! # Standalone Tests for the Inference Module\n \n-use diagnostic;\n-use diagnostic::Emitter;\n use driver;\n use rustc_lint;\n use rustc_resolve as resolve;\n@@ -34,9 +32,10 @@ use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::{abi, ast};\n-use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n-use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n+use syntax::errors;\n+use syntax::errors::emitter::Emitter;\n+use syntax::errors::{Level, RenderSpan};\n use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n \n@@ -60,8 +59,8 @@ struct ExpectErrorEmitter {\n \n fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     match lvl {\n-        Bug | Fatal | Error => {}\n-        Warning | Note | Help => {\n+        Level::Bug | Level::Fatal | Level::Error => {}\n+        Level::Warning | Level::Note | Level::Help => {\n             return;\n         }\n     }\n@@ -79,14 +78,14 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n \n impl Emitter for ExpectErrorEmitter {\n     fn emit(&mut self,\n-            _cmsp: Option<(&codemap::CodeMap, Span)>,\n+            _sp: Option<Span>,\n             msg: &str,\n             _: Option<&str>,\n             lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n \n-    fn custom_emit(&mut self, _cm: &codemap::CodeMap, _sp: RenderSpan, msg: &str, lvl: Level) {\n+    fn custom_emit(&mut self, _sp: RenderSpan, msg: &str, lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n }\n@@ -105,13 +104,11 @@ fn test_env<F>(source_string: &str,\n     let mut options = config::basic_options();\n     options.debugging_opts.verbose = true;\n     options.unstable_features = UnstableFeatures::Allow;\n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::with_emitter(true, emitter);\n-    let span_diagnostic_handler = diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let sess = session::build_session_(options, None, span_diagnostic_handler,\n-                                       cstore.clone());\n+    let sess = session::build_session_(options, None, diagnostic_handler,\n+                                       Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let krate_config = Vec::new();\n     let input = config::Input::Str(source_string.to_string());\n@@ -366,13 +363,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.infcx.glb(true, trace)\n     }\n \n-    pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.lub().relate(&t1, &t2) {\n-            Ok(t) => t,\n-            Err(ref e) => panic!(\"unexpected error computing LUB: {}\", e),\n-        }\n-    }\n-\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {"}, {"sha": "784428cc114dc0cd9e7dba13dd0dd4e416aac3df", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -17,7 +17,6 @@ use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::ptr::P;\n use syntax::parse::token;\n use syntax::util::move_map::MoveMap;\n@@ -35,7 +34,7 @@ pub trait Folder : Sized {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n+    fn fold_meta_items(&mut self, meta_items: HirVec<P<MetaItem>>) -> HirVec<P<MetaItem>> {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n@@ -199,19 +198,19 @@ pub trait Folder : Sized {\n         noop_fold_variant_data(vdata, self)\n     }\n \n-    fn fold_lifetimes(&mut self, lts: Vec<Lifetime>) -> Vec<Lifetime> {\n+    fn fold_lifetimes(&mut self, lts: HirVec<Lifetime>) -> HirVec<Lifetime> {\n         noop_fold_lifetimes(lts, self)\n     }\n \n-    fn fold_lifetime_defs(&mut self, lts: Vec<LifetimeDef>) -> Vec<LifetimeDef> {\n+    fn fold_lifetime_defs(&mut self, lts: HirVec<LifetimeDef>) -> HirVec<LifetimeDef> {\n         noop_fold_lifetime_defs(lts, self)\n     }\n \n     fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: OwnedSlice<TyParam>) -> OwnedSlice<TyParam> {\n+    fn fold_ty_params(&mut self, tps: P<[TyParam]>) -> P<[TyParam]> {\n         noop_fold_ty_params(tps, self)\n     }\n \n@@ -220,12 +219,12 @@ pub trait Folder : Sized {\n     }\n \n     fn fold_opt_bounds(&mut self,\n-                       b: Option<OwnedSlice<TyParamBound>>)\n-                       -> Option<OwnedSlice<TyParamBound>> {\n+                       b: Option<TyParamBounds>)\n+                       -> Option<TyParamBounds> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>) -> OwnedSlice<TyParamBound> {\n+    fn fold_bounds(&mut self, b: TyParamBounds) -> TyParamBounds {\n         noop_fold_bounds(b, self)\n     }\n \n@@ -264,9 +263,9 @@ pub trait Folder : Sized {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>,\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: HirVec<P<MetaItem>>,\n                                        fld: &mut T)\n-                                       -> Vec<P<MetaItem>> {\n+                                       -> HirVec<P<MetaItem>> {\n     meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n@@ -305,7 +304,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n     })\n }\n \n-pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n+pub fn fold_attrs<T: Folder>(attrs: HirVec<Attribute>, fld: &mut T) -> HirVec<Attribute> {\n     attrs.move_flat_map(|x| fld.fold_attribute(x))\n }\n \n@@ -478,7 +477,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n-            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, fld)),\n+            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), fld).into()),\n         }\n     })\n }\n@@ -576,9 +575,9 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>,\n+pub fn noop_fold_ty_params<T: Folder>(tps: P<[TyParam]>,\n                                       fld: &mut T)\n-                                      -> OwnedSlice<TyParam> {\n+                                      -> P<[TyParam]> {\n     tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n \n@@ -597,11 +596,13 @@ pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> Lifetim\n     }\n }\n \n-pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Lifetime> {\n+pub fn noop_fold_lifetimes<T: Folder>(lts: HirVec<Lifetime>, fld: &mut T) -> HirVec<Lifetime> {\n     lts.move_map(|l| fld.fold_lifetime(l))\n }\n \n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T) -> Vec<LifetimeDef> {\n+pub fn noop_fold_lifetime_defs<T: Folder>(lts: HirVec<LifetimeDef>,\n+                                          fld: &mut T)\n+                                          -> HirVec<LifetimeDef> {\n     lts.move_map(|l| fld.fold_lifetime_def(l))\n }\n \n@@ -726,9 +727,9 @@ pub fn noop_fold_mt<T: Folder>(MutTy { ty, mutbl }: MutTy, folder: &mut T) -> Mu\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>,\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>,\n                                        folder: &mut T)\n-                                       -> Option<OwnedSlice<TyParamBound>> {\n+                                       -> Option<TyParamBounds> {\n     b.map(|bounds| folder.fold_bounds(bounds))\n }\n \n@@ -1140,7 +1141,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             }\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder)),\n+        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), folder).into()),\n     }\n }\n "}, {"sha": "6b2664af60ba5cd3bdf998321199b3396bdf68ee", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 82, "deletions": 65, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -40,9 +40,8 @@ use std::collections::BTreeMap;\n use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n-use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n+use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::attr::ThinAttributes;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n \n@@ -53,6 +52,22 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+/// HIR doesn't commit to a concrete storage type and have its own alias for a vector.\n+/// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n+/// behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead\n+/// of `Vec` to avoid keeping extra capacity.\n+pub type HirVec<T> = Vec<T>;\n+\n+macro_rules! hir_vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::hir::HirVec::from(vec![$elem; $n])\n+    );\n+    ($($x:expr),*) => (\n+        $crate::hir::HirVec::from(vec![$($x),*])\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n /// Identifier in HIR\n #[derive(Clone, Copy, Eq)]\n pub struct Ident {\n@@ -130,7 +145,7 @@ impl fmt::Debug for Lifetime {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>,\n+    pub bounds: HirVec<Lifetime>,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n@@ -143,7 +158,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     pub global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: Vec<PathSegment>,\n+    pub segments: HirVec<PathSegment>,\n }\n \n impl fmt::Debug for Path {\n@@ -192,9 +207,9 @@ pub enum PathParameters {\n impl PathParameters {\n     pub fn none() -> PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n-            bindings: OwnedSlice::empty(),\n+            lifetimes: HirVec::new(),\n+            types: P::empty(),\n+            bindings: P::empty(),\n         })\n     }\n \n@@ -224,7 +239,7 @@ impl PathParameters {\n \n     /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n     /// parameters in the parenthesized case.\n-    pub fn types(&self) -> Vec<&P<Ty>> {\n+    pub fn types(&self) -> HirVec<&P<Ty>> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.types.iter().collect()\n@@ -238,24 +253,24 @@ impl PathParameters {\n         }\n     }\n \n-    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n+    pub fn lifetimes(&self) -> HirVec<&Lifetime> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.lifetimes.iter().collect()\n             }\n             ParenthesizedParameters(_) => {\n-                Vec::new()\n+                HirVec::new()\n             }\n         }\n     }\n \n-    pub fn bindings(&self) -> Vec<&TypeBinding> {\n+    pub fn bindings(&self) -> HirVec<&TypeBinding> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.bindings.iter().collect()\n             }\n             ParenthesizedParameters(_) => {\n-                Vec::new()\n+                HirVec::new()\n             }\n         }\n     }\n@@ -265,12 +280,12 @@ impl PathParameters {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n-    pub lifetimes: Vec<Lifetime>,\n+    pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n-    pub types: OwnedSlice<P<Ty>>,\n+    pub types: P<[P<Ty>]>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n-    pub bindings: OwnedSlice<TypeBinding>,\n+    pub bindings: P<[TypeBinding]>,\n }\n \n impl AngleBracketedParameterData {\n@@ -286,7 +301,7 @@ pub struct ParenthesizedParameterData {\n     pub span: Span,\n \n     /// `(A,B)`\n-    pub inputs: Vec<P<Ty>>,\n+    pub inputs: HirVec<P<Ty>>,\n \n     /// `C`\n     pub output: Option<P<Ty>>,\n@@ -310,7 +325,7 @@ pub enum TraitBoundModifier {\n     Maybe,\n }\n \n-pub type TyParamBounds = OwnedSlice<TyParamBound>;\n+pub type TyParamBounds = P<[TyParamBound]>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TyParam {\n@@ -325,8 +340,8 @@ pub struct TyParam {\n /// of a function, enum, trait, etc.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n-    pub lifetimes: Vec<LifetimeDef>,\n-    pub ty_params: OwnedSlice<TyParam>,\n+    pub lifetimes: HirVec<LifetimeDef>,\n+    pub ty_params: P<[TyParam]>,\n     pub where_clause: WhereClause,\n }\n \n@@ -346,7 +361,7 @@ impl Generics {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n-    pub predicates: Vec<WherePredicate>,\n+    pub predicates: HirVec<WherePredicate>,\n }\n \n /// A single predicate in a `where` clause\n@@ -365,19 +380,19 @@ pub enum WherePredicate {\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any lifetimes from a `for` binding\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    pub bound_lifetimes: HirVec<LifetimeDef>,\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n-    pub bounds: OwnedSlice<TyParamBound>,\n+    pub bounds: TyParamBounds,\n }\n \n /// A lifetime predicate, e.g. `'a: 'b+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>,\n+    pub bounds: HirVec<Lifetime>,\n }\n \n /// An equality predicate (unsupported), e.g. `T=int`\n@@ -389,13 +404,15 @@ pub struct WhereEqPredicate {\n     pub ty: P<Ty>,\n }\n \n+pub type CrateConfig = HirVec<P<MetaItem>>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<MacroDef>,\n+    pub exported_macros: HirVec<MacroDef>,\n \n     // NB: We use a BTreeMap here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n@@ -432,20 +449,20 @@ impl Crate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub imported_from: Option<Name>,\n     pub export: bool,\n     pub use_locally: bool,\n     pub allow_internal_unstable: bool,\n-    pub body: Vec<TokenTree>,\n+    pub body: HirVec<TokenTree>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     /// Statements in a block\n-    pub stmts: Vec<Stmt>,\n+    pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n@@ -504,7 +521,7 @@ pub enum Pat_ {\n     PatIdent(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n     /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<Vec<P<Pat>>>),\n+    PatEnum(Path, Option<HirVec<P<Pat>>>),\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n@@ -514,9 +531,9 @@ pub enum Pat_ {\n \n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n-    PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+    PatStruct(Path, HirVec<Spanned<FieldPat>>, bool),\n     /// A tuple pattern `(a, b)`\n-    PatTup(Vec<P<Pat>>),\n+    PatTup(HirVec<P<Pat>>),\n     /// A `box` pattern\n     PatBox(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n@@ -527,7 +544,7 @@ pub enum Pat_ {\n     PatRange(P<Expr>, P<Expr>),\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatVec(box [a, b], Some(i), box [y, z])`\n-    PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    PatVec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -641,8 +658,8 @@ pub enum Decl_ {\n /// represents one arm of a 'match'\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n-    pub attrs: Vec<Attribute>,\n-    pub pats: Vec<P<Pat>>,\n+    pub attrs: HirVec<Attribute>,\n+    pub pats: HirVec<P<Pat>>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n }\n@@ -691,12 +708,12 @@ pub enum Expr_ {\n     /// A `box x` expression.\n     ExprBox(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprVec(Vec<P<Expr>>),\n+    ExprVec(HirVec<P<Expr>>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself,\n     /// and the second field is the list of arguments\n-    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    ExprCall(P<Expr>, HirVec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `Spanned<Name>` is the identifier for the method name.\n@@ -709,9 +726,9 @@ pub enum Expr_ {\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(Spanned<Name>, Vec<P<Ty>>, Vec<P<Expr>>),\n+    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(Vec<P<Expr>>),\n+    ExprTup(HirVec<P<Expr>>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n@@ -734,7 +751,7 @@ pub enum Expr_ {\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n-    ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n+    ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n     /// A block (`{ ... }`)\n@@ -761,7 +778,7 @@ pub enum Expr_ {\n     /// parameters, e.g. foo::bar::<baz>.\n     ///\n     /// Optionally \"qualified\",\n-    /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    /// e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n     ExprPath(Option<QSelf>, Path),\n \n     /// A referencing operation (`&a` or `&mut a`)\n@@ -780,7 +797,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n+    ExprStruct(Path, HirVec<Field>, Option<P<Expr>>),\n \n     /// A vector literal constructed from one repeated element.\n     ///\n@@ -794,11 +811,11 @@ pub enum Expr_ {\n /// separately. `position` represents the index of the associated\n /// item qualified with this Self type.\n ///\n-///     <Vec<T> as a::b::Trait>::AssociatedItem\n+///     <HirVec<T> as a::b::Trait>::AssociatedItem\n ///      ^~~~~     ~~~~~~~~~~~~~~^\n ///      ty        position = 3\n ///\n-///     <Vec<T>>::AssociatedItem\n+///     <HirVec<T>>::AssociatedItem\n ///      ^~~~~    ^\n ///      ty       position = 0\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -851,7 +868,7 @@ pub struct MethodSig {\n pub struct TraitItem {\n     pub id: NodeId,\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: TraitItem_,\n     pub span: Span,\n }\n@@ -868,7 +885,7 @@ pub struct ImplItem {\n     pub id: NodeId,\n     pub name: Name,\n     pub vis: Visibility,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n }\n@@ -919,7 +936,7 @@ pub enum PrimTy {\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n-    pub lifetimes: Vec<LifetimeDef>,\n+    pub lifetimes: HirVec<LifetimeDef>,\n     pub decl: P<FnDecl>,\n }\n \n@@ -936,9 +953,9 @@ pub enum Ty_ {\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(Vec<P<Ty>>),\n+    TyTup(HirVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n-    /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    /// \"qualified\", e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n     ///\n     /// Type parameters are stored in the Path itself\n     TyPath(Option<QSelf>, Path),\n@@ -965,9 +982,9 @@ pub struct InlineAsmOutput {\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n-    pub outputs: Vec<InlineAsmOutput>,\n-    pub inputs: Vec<(InternedString, P<Expr>)>,\n-    pub clobbers: Vec<InternedString>,\n+    pub outputs: HirVec<InlineAsmOutput>,\n+    pub inputs: HirVec<(InternedString, P<Expr>)>,\n+    pub clobbers: HirVec<InternedString>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n@@ -1008,7 +1025,7 @@ impl Arg {\n /// Represents the header (not the body) of a function declaration\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Arg>,\n+    pub inputs: HirVec<Arg>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n }\n@@ -1099,24 +1116,24 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub item_ids: Vec<ItemId>,\n+    pub item_ids: HirVec<ItemId>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignMod {\n     pub abi: Abi,\n-    pub items: Vec<ForeignItem>,\n+    pub items: HirVec<ForeignItem>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n-    pub variants: Vec<Variant>,\n+    pub variants: HirVec<Variant>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<P<Expr>>,\n@@ -1177,7 +1194,7 @@ pub enum ViewPath_ {\n     ViewPathGlob(Path),\n \n     /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem>),\n+    ViewPathList(Path, HirVec<PathListItem>),\n }\n \n /// TraitRef's appear in impls.\n@@ -1195,7 +1212,7 @@ pub struct TraitRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    pub bound_lifetimes: HirVec<LifetimeDef>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n     pub trait_ref: TraitRef,\n@@ -1223,7 +1240,7 @@ pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n     pub ty: P<Ty>,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n }\n \n impl StructField_ {\n@@ -1272,8 +1289,8 @@ impl StructFieldKind {\n /// Id of the whole struct lives in `Item`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantData {\n-    Struct(Vec<StructField>, NodeId),\n-    Tuple(Vec<StructField>, NodeId),\n+    Struct(HirVec<StructField>, NodeId),\n+    Tuple(HirVec<StructField>, NodeId),\n     Unit(NodeId),\n }\n \n@@ -1328,7 +1345,7 @@ pub struct ItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub node: Item_,\n     pub vis: Visibility,\n@@ -1361,7 +1378,7 @@ pub enum Item_ {\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(Unsafety, Generics, TyParamBounds, Vec<TraitItem>),\n+    ItemTrait(Unsafety, Generics, TyParamBounds, HirVec<TraitItem>),\n \n     // Default trait implementations\n     ///\n@@ -1373,7 +1390,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<ImplItem>),\n+             HirVec<ImplItem>),\n }\n \n impl Item_ {\n@@ -1399,7 +1416,7 @@ impl Item_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: ForeignItem_,\n     pub id: NodeId,\n     pub span: Span,"}, {"sha": "60080854a6f1724441b3ce75f405220aa71b5268", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -47,6 +47,7 @@ extern crate rustc_bitflags;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+#[macro_use]\n pub mod hir;\n pub mod lowering;\n pub mod fold;"}, {"sha": "db30ee9a5d2d351b7c61816edcd3fb45ac9a62e5", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 67, "deletions": 64, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -70,7 +70,6 @@ use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ext::mtwt;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::std_inject;\n use syntax::visit::{self, Visitor};\n@@ -148,6 +147,10 @@ pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n     }\n }\n \n+pub fn lower_attrs(_lctx: &LoweringContext, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n+    attrs.clone().into()\n+}\n+\n pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n@@ -187,7 +190,7 @@ pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::V\n \n pub fn lower_arm(lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n     hir::Arm {\n-        attrs: arm.attrs.clone(),\n+        attrs: lower_attrs(lctx, &arm.attrs),\n         pats: arm.pats.iter().map(|x| lower_pat(lctx, x)).collect(),\n         guard: arm.guard.as_ref().map(|ref x| lower_expr(lctx, x)),\n         body: lower_expr(lctx, &arm.body),\n@@ -276,7 +279,7 @@ pub fn lower_variant(lctx: &LoweringContext, v: &Variant) -> hir::Variant {\n     Spanned {\n         node: hir::Variant_ {\n             name: v.node.name.name,\n-            attrs: v.node.attrs.clone(),\n+            attrs: lower_attrs(lctx, &v.node.attrs),\n             data: lower_variant_data(lctx, &v.node.data),\n             disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(lctx, e)),\n         },\n@@ -430,8 +433,8 @@ pub fn lower_ty_param(lctx: &LoweringContext, tp: &TyParam) -> hir::TyParam {\n }\n \n pub fn lower_ty_params(lctx: &LoweringContext,\n-                       tps: &OwnedSlice<TyParam>)\n-                       -> OwnedSlice<hir::TyParam> {\n+                       tps: &P<[TyParam]>)\n+                       -> P<[hir::TyParam]> {\n     tps.iter().map(|tp| lower_ty_param(lctx, tp)).collect()\n }\n \n@@ -450,13 +453,13 @@ pub fn lower_lifetime_def(lctx: &LoweringContext, l: &LifetimeDef) -> hir::Lifet\n     }\n }\n \n-pub fn lower_lifetimes(lctx: &LoweringContext, lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n+pub fn lower_lifetimes(lctx: &LoweringContext, lts: &Vec<Lifetime>) -> hir::HirVec<hir::Lifetime> {\n     lts.iter().map(|l| lower_lifetime(lctx, l)).collect()\n }\n \n pub fn lower_lifetime_defs(lctx: &LoweringContext,\n                            lts: &Vec<LifetimeDef>)\n-                           -> Vec<hir::LifetimeDef> {\n+                           -> hir::HirVec<hir::LifetimeDef> {\n     lts.iter().map(|l| lower_lifetime_def(lctx, l)).collect()\n }\n \n@@ -561,7 +564,7 @@ pub fn lower_struct_field(lctx: &LoweringContext, f: &StructField) -> hir::Struc\n             id: f.node.id,\n             kind: lower_struct_field_kind(lctx, &f.node.kind),\n             ty: lower_ty(lctx, &f.node.ty),\n-            attrs: f.node.attrs.clone(),\n+            attrs: lower_attrs(lctx, &f.node.attrs),\n         },\n         span: f.span,\n     }\n@@ -583,8 +586,8 @@ pub fn lower_mt(lctx: &LoweringContext, mt: &MutTy) -> hir::MutTy {\n }\n \n pub fn lower_opt_bounds(lctx: &LoweringContext,\n-                        b: &Option<OwnedSlice<TyParamBound>>)\n-                        -> Option<OwnedSlice<hir::TyParamBound>> {\n+                        b: &Option<TyParamBounds>)\n+                        -> Option<hir::TyParamBounds> {\n     b.as_ref().map(|ref bounds| lower_bounds(lctx, bounds))\n }\n \n@@ -674,7 +677,7 @@ pub fn lower_trait_item(lctx: &LoweringContext, i: &TraitItem) -> hir::TraitItem\n     hir::TraitItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n                 hir::ConstTraitItem(lower_ty(lctx, ty),\n@@ -697,7 +700,7 @@ pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> hir::ImplItem {\n     hir::ImplItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         vis: lower_visibility(lctx, i.vis),\n         node: match i.node {\n             ImplItemKind::Const(ref ty, ref expr) => {\n@@ -741,25 +744,25 @@ pub fn lower_crate(lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n \n     hir::Crate {\n         module: lower_mod(lctx, &c.module),\n-        attrs: c.attrs.clone(),\n-        config: c.config.clone(),\n+        attrs: lower_attrs(lctx, &c.attrs),\n+        config: c.config.clone().into(),\n         span: c.span,\n         exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(lctx, m)).collect(),\n         items: items,\n     }\n }\n \n-pub fn lower_macro_def(_lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n+pub fn lower_macro_def(lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n     hir::MacroDef {\n         name: m.ident.name,\n-        attrs: m.attrs.clone(),\n+        attrs: lower_attrs(lctx, &m.attrs),\n         id: m.id,\n         span: m.span,\n         imported_from: m.imported_from.map(|x| x.name),\n         export: m.export,\n         use_locally: m.use_locally,\n         allow_internal_unstable: m.allow_internal_unstable,\n-        body: m.body.clone(),\n+        body: m.body.clone().into(),\n     }\n }\n \n@@ -773,7 +776,7 @@ pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n     hir::Item {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: node,\n         vis: lower_visibility(lctx, i.vis),\n         span: i.span,\n@@ -784,7 +787,7 @@ pub fn lower_foreign_item(lctx: &LoweringContext, i: &ForeignItem) -> hir::Forei\n     hir::ForeignItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n@@ -1021,7 +1024,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // let placer = <placer_expr> ;\n                     let s1 = {\n                         let placer_expr = signal_block_expr(lctx,\n-                                                            vec![],\n+                                                            hir_vec![],\n                                                             placer_expr,\n                                                             e.span,\n                                                             hir::PopUnstableBlock,\n@@ -1032,28 +1035,28 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // let mut place = Placer::make_place(placer);\n                     let s2 = {\n                         let placer = expr_ident(lctx, e.span, placer_ident, None);\n-                        let call = make_call(lctx, &make_place, vec![placer]);\n+                        let call = make_call(lctx, &make_place, hir_vec![placer]);\n                         mk_stmt_let_mut(lctx, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let s3 = {\n                         let agent = expr_ident(lctx, e.span, place_ident, None);\n-                        let args = vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n+                        let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n                         let call = make_call(lctx, &place_pointer, args);\n                         mk_stmt_let(lctx, p_ptr_ident, call)\n                     };\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n                         let value_expr = signal_block_expr(lctx,\n-                                                           vec![],\n+                                                           hir_vec![],\n                                                            value_expr,\n                                                            e.span,\n                                                            hir::PopUnstableBlock,\n                                                            None);\n                         signal_block_expr(lctx,\n-                                          vec![],\n+                                          hir_vec![],\n                                           value_expr,\n                                           e.span,\n                                           hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n@@ -1067,21 +1070,21 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n-                                make_call(lctx, &move_val_init, vec![ptr, pop_unsafe_expr]),\n+                                make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                                 lctx.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n                         let place = expr_ident(lctx, e.span, place_ident, None);\n-                        let call = make_call(lctx, &inplace_finalize, vec![place]);\n+                        let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n                         signal_block_expr(lctx,\n-                                          vec![call_move_val_init],\n+                                          hir_vec![call_move_val_init],\n                                           call,\n                                           e.span,\n                                           hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     signal_block_expr(lctx,\n-                                      vec![s1, s2, s3],\n+                                      hir_vec![s1, s2, s3],\n                                       expr,\n                                       e.span,\n                                       hir::PushUnstableBlock,\n@@ -1142,7 +1145,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 let els = lower_expr(lctx, els);\n                                 let id = lctx.next_id();\n                                 let blk = P(hir::Block {\n-                                    stmts: vec![],\n+                                    stmts: hir_vec![],\n                                     expr: Some(els),\n                                     id: id,\n                                     rules: hir::DefaultBlock,\n@@ -1239,7 +1242,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 .collect(),\n                 asm: asm.clone(),\n                 asm_str_style: asm_str_style,\n-                clobbers: clobbers.clone(),\n+                clobbers: clobbers.clone().into(),\n                 volatile: volatile,\n                 alignstack: alignstack,\n                 dialect: dialect,\n@@ -1276,7 +1279,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n                         let body_expr = expr_block(lctx, body, None);\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n@@ -1291,8 +1294,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                         hir::ExprIf(cond, then, else_opt) => {\n                                             let pat_under = pat_wild(lctx, e.span);\n                                             arms.push(hir::Arm {\n-                                                attrs: vec![],\n-                                                pats: vec![pat_under],\n+                                                attrs: hir_vec![],\n+                                                pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n                                                 body: expr_block(lctx, then, None),\n                                             });\n@@ -1326,8 +1329,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let else_expr =\n                             else_opt.unwrap_or_else(\n-                                || expr_tuple(lctx, e.span, vec![], None));\n-                        arm(vec![pat_under], else_expr)\n+                                || expr_tuple(lctx, e.span, hir_vec![], None));\n+                        arm(hir_vec![pat_under], else_expr)\n                     };\n \n                     let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n@@ -1340,7 +1343,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     expr(lctx,\n                          e.span,\n                          hir::ExprMatch(sub_expr,\n-                                        arms,\n+                                        arms.into(),\n                                         hir::MatchSource::IfLetDesugar {\n                                             contains_else_clause: contains_else_clause,\n                                         }),\n@@ -1365,18 +1368,18 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n                         let body_expr = expr_block(lctx, body, None);\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let break_expr = expr_break(lctx, e.span, None);\n-                        arm(vec![pat_under], break_expr)\n+                        arm(hir_vec![pat_under], break_expr)\n                     };\n \n                     // `match <sub_expr> { ... }`\n-                    let arms = vec![pat_arm, break_arm];\n+                    let arms = hir_vec![pat_arm, break_arm];\n                     let sub_expr = lower_expr(lctx, sub_expr);\n                     let match_expr = expr(lctx,\n                                           e.span,\n@@ -1432,14 +1435,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat = lower_pat(lctx, pat);\n                         let some_pat = pat_some(lctx, e.span, pat);\n \n-                        arm(vec![some_pat], body_expr)\n+                        arm(hir_vec![some_pat], body_expr)\n                     };\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n                         let break_expr = expr_break(lctx, e.span, None);\n \n-                        arm(vec![pat_none(lctx, e.span)], break_expr)\n+                        arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n                     };\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n@@ -1455,9 +1458,9 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let next_expr = expr_call(lctx,\n                                                   e.span,\n                                                   next_path,\n-                                                  vec![ref_mut_iter],\n+                                                  hir_vec![ref_mut_iter],\n                                                   None);\n-                        let arms = vec![pat_arm, break_arm];\n+                        let arms = hir_vec![pat_arm, break_arm];\n \n                         expr(lctx,\n                              e.span,\n@@ -1477,7 +1480,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                               e.span,\n                                                               iter,\n                                                               hir::BindByValue(hir::MutMutable));\n-                        arm(vec![iter_pat], loop_expr)\n+                        arm(hir_vec![iter_pat], loop_expr)\n                     };\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n@@ -1489,21 +1492,21 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         };\n \n                         let into_iter = expr_path(lctx, into_iter_path, None);\n-                        expr_call(lctx, e.span, into_iter, vec![head], None)\n+                        expr_call(lctx, e.span, into_iter, hir_vec![head], None)\n                     };\n \n                     let match_expr = expr_match(lctx,\n                                                 e.span,\n                                                 into_iter_expr,\n-                                                vec![iter_arm],\n+                                                hir_vec![iter_arm],\n                                                 hir::MatchSource::ForLoopDesugar,\n                                                 None);\n \n                     // `{ let result = ...; result }`\n                     let result_ident = lctx.str_to_ident(\"result\");\n                     let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n                     let result = expr_ident(lctx, e.span, result_ident, None);\n-                    let block = block_all(lctx, e.span, vec![let_stmt], Some(result));\n+                    let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n                     expr_block(lctx, block, e.attrs.clone())\n                 });\n@@ -1602,9 +1605,9 @@ pub fn lower_trait_bound_modifier(_lctx: &LoweringContext,\n \n // Helper methods for building HIR.\n \n-fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+fn arm(pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n     hir::Arm {\n-        attrs: vec![],\n+        attrs: hir_vec![],\n         pats: pats,\n         guard: None,\n         body: expr,\n@@ -1619,7 +1622,7 @@ fn expr_break(lctx: &LoweringContext, span: Span,\n fn expr_call(lctx: &LoweringContext,\n              span: Span,\n              e: P<hir::Expr>,\n-             args: Vec<P<hir::Expr>>,\n+             args: hir::HirVec<P<hir::Expr>>,\n              attrs: ThinAttributes)\n              -> P<hir::Expr> {\n     expr(lctx, span, hir::ExprCall(e, args), attrs)\n@@ -1643,7 +1646,7 @@ fn expr_path(lctx: &LoweringContext, path: hir::Path,\n fn expr_match(lctx: &LoweringContext,\n               span: Span,\n               arg: P<hir::Expr>,\n-              arms: Vec<hir::Arm>,\n+              arms: hir::HirVec<hir::Arm>,\n               source: hir::MatchSource,\n               attrs: ThinAttributes)\n               -> P<hir::Expr> {\n@@ -1655,7 +1658,7 @@ fn expr_block(lctx: &LoweringContext, b: P<hir::Block>,\n     expr(lctx, b.span, hir::ExprBlock(b), attrs)\n }\n \n-fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>,\n+fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: hir::HirVec<P<hir::Expr>>,\n               attrs: ThinAttributes) -> P<hir::Expr> {\n     expr(lctx, sp, hir::ExprTup(exprs), attrs)\n }\n@@ -1695,12 +1698,12 @@ fn stmt_let(lctx: &LoweringContext,\n }\n \n fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n-    block_all(lctx, expr.span, Vec::new(), Some(expr))\n+    block_all(lctx, expr.span, hir::HirVec::new(), Some(expr))\n }\n \n fn block_all(lctx: &LoweringContext,\n              span: Span,\n-             stmts: Vec<hir::Stmt>,\n+             stmts: hir::HirVec<hir::Stmt>,\n              expr: Option<P<hir::Expr>>)\n              -> P<hir::Block> {\n     P(hir::Block {\n@@ -1715,19 +1718,19 @@ fn block_all(lctx: &LoweringContext,\n fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n     let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n     let path = path_global(span, some);\n-    pat_enum(lctx, span, path, vec![pat])\n+    pat_enum(lctx, span, path, hir_vec![pat])\n }\n \n fn pat_none(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n     let none = std_path(lctx, &[\"option\", \"Option\", \"None\"]);\n     let path = path_global(span, none);\n-    pat_enum(lctx, span, path, vec![])\n+    pat_enum(lctx, span, path, hir_vec![])\n }\n \n fn pat_enum(lctx: &LoweringContext,\n             span: Span,\n             path: hir::Path,\n-            subpats: Vec<P<hir::Pat>>)\n+            subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n     let pt = hir::PatEnum(path, Some(subpats));\n     pat(lctx, span, pt)\n@@ -1768,17 +1771,17 @@ fn path_ident(span: Span, id: hir::Ident) -> hir::Path {\n }\n \n fn path(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n+    path_all(span, false, strs, hir::HirVec::new(), Vec::new(), Vec::new())\n }\n \n fn path_global(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n+    path_all(span, true, strs, hir::HirVec::new(), Vec::new(), Vec::new())\n }\n \n fn path_all(sp: Span,\n             global: bool,\n             mut idents: Vec<hir::Ident>,\n-            lifetimes: Vec<hir::Lifetime>,\n+            lifetimes: hir::HirVec<hir::Lifetime>,\n             types: Vec<P<hir::Ty>>,\n             bindings: Vec<hir::TypeBinding>)\n             -> hir::Path {\n@@ -1795,14 +1798,14 @@ fn path_all(sp: Span,\n         identifier: last_identifier,\n         parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n             lifetimes: lifetimes,\n-            types: OwnedSlice::from_vec(types),\n-            bindings: OwnedSlice::from_vec(bindings),\n+            types: P::from_vec(types),\n+            bindings: P::from_vec(bindings),\n         }),\n     });\n     hir::Path {\n         span: sp,\n         global: global,\n-        segments: segments,\n+        segments: segments.into(),\n     }\n }\n \n@@ -1823,7 +1826,7 @@ fn core_path(lctx: &LoweringContext, span: Span, components: &[&str]) -> hir::Pa\n }\n \n fn signal_block_expr(lctx: &LoweringContext,\n-                     stmts: Vec<hir::Stmt>,\n+                     stmts: hir::HirVec<hir::Stmt>,\n                      expr: P<hir::Expr>,\n                      span: Span,\n                      rule: hir::BlockCheckMode,"}, {"sha": "9ac0e65cba33b051e841e38f4648dc6c02b2e247", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -12,9 +12,8 @@ pub use self::AnnNode::*;\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n-use syntax::diagnostic;\n+use syntax::errors;\n use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::parse;\n@@ -121,7 +120,7 @@ pub const default_columns: usize = 78;\n /// it can scan the input text for comments and literals to\n /// copy forward.\n pub fn print_crate<'a>(cm: &'a CodeMap,\n-                       span_diagnostic: &diagnostic::SpanHandler,\n+                       span_diagnostic: &errors::Handler,\n                        krate: &hir::Crate,\n                        filename: String,\n                        input: &mut Read,\n@@ -142,7 +141,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n-                          span_diagnostic: &diagnostic::SpanHandler,\n+                          span_diagnostic: &errors::Handler,\n                           filename: String,\n                           input: &mut Read,\n                           out: Box<Write + 'a>,\n@@ -519,10 +518,10 @@ impl<'a> State<'a> {\n             hir::TyBareFn(ref f) => {\n                 let generics = hir::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty(),\n+                    ty_params: P::empty(),\n                     where_clause: hir::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n-                        predicates: Vec::new(),\n+                        predicates: hir::HirVec::new(),\n                     },\n                 };\n                 try!(self.print_ty_fn(f.abi, f.unsafety, &*f.decl, None, &generics, None));\n@@ -2257,11 +2256,11 @@ impl<'a> State<'a> {\n             try!(self.print_generics(generics));\n         }\n         let generics = hir::Generics {\n-            lifetimes: Vec::new(),\n-            ty_params: OwnedSlice::empty(),\n+            lifetimes: hir::HirVec::new(),\n+            ty_params: P::empty(),\n             where_clause: hir::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n-                predicates: Vec::new(),\n+                predicates: hir::HirVec::new(),\n             },\n         };\n         try!(self.print_fn(decl,"}, {"sha": "298904d1e0d7abdcf82df68c090b3a5cceca64eb", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -15,7 +15,6 @@ use syntax::ast_util;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n use syntax::ptr::P;\n-use syntax::owned_slice::OwnedSlice;\n \n pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n     where F: FnMut(&Pat) -> bool\n@@ -335,11 +334,11 @@ pub fn is_path(e: P<Expr>) -> bool {\n \n pub fn empty_generics() -> Generics {\n     Generics {\n-        lifetimes: Vec::new(),\n-        ty_params: OwnedSlice::empty(),\n+        lifetimes: HirVec::new(),\n+        ty_params: P::empty(),\n         where_clause: WhereClause {\n             id: DUMMY_NODE_ID,\n-            predicates: Vec::new(),\n+            predicates: HirVec::new(),\n         },\n     }\n }\n@@ -350,13 +349,13 @@ pub fn ident_to_path(s: Span, ident: Ident) -> Path {\n     hir::Path {\n         span: s,\n         global: false,\n-        segments: vec!(hir::PathSegment {\n+        segments: hir_vec![hir::PathSegment {\n             identifier: ident,\n             parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n-                bindings: OwnedSlice::empty(),\n+                lifetimes: HirVec::new(),\n+                types: P::empty(),\n+                bindings: P::empty(),\n             }),\n-        }),\n+        }],\n     }\n }"}, {"sha": "8dcaa4b5064c18095c2ceeb61c48edb37f11b0c3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -616,6 +616,7 @@ extern {\n                                              C: ContextRef)\n                                              -> ModuleRef;\n     pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n+    pub fn LLVMCloneModule(M: ModuleRef) -> ModuleRef;\n     pub fn LLVMDisposeModule(M: ModuleRef);\n \n     /// Data layout. See Module::getDataLayout."}, {"sha": "cd70172e8fa2112500da97662a9d337d2cd87451", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -44,7 +44,7 @@ use syntax::abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use syntax::parse::token::special_idents;\n use syntax;\n use rbml::writer::Encoder;\n@@ -57,7 +57,7 @@ pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n pub struct EncodeParams<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n@@ -69,7 +69,7 @@ pub struct EncodeParams<'a, 'tcx: 'a> {\n }\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n@@ -275,8 +275,7 @@ fn encode_symbol(ecx: &EncodeContext,\n             rbml_w.wr_tagged_str(tag_items_data_item_symbol, x);\n         }\n         None => {\n-            ecx.diag.handler().bug(\n-                &format!(\"encode_symbol: id not found {}\", id));\n+            ecx.diag.bug(&format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n }"}, {"sha": "81788e08c7ef2085135b3c90c59f2207cc8ff5d5", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -226,7 +226,7 @@ use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n use syntax::codemap::Span;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use rustc_back::target::Target;\n \n use std::cmp;\n@@ -697,8 +697,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(&format!(\"crate name: {}\", name));\n+pub fn note_crate_name(diag: &Handler, name: &str) {\n+    diag.note(&format!(\"crate name: {}\", name));\n }\n \n impl ArchiveMetadata {"}, {"sha": "0119f1d5cc109bc0343148da32c62f4036b464a5", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -29,14 +29,14 @@ use rustc_front::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n \n use rbml::writer::{self, Encoder};\n \n macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*); }) }\n \n pub struct ctxt<'a, 'tcx: 'a> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     // Def -> str Callback:\n     pub ds: fn(DefId) -> String,\n     // The type context.\n@@ -136,7 +136,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::TyInfer(_) => {\n-            cx.diag.handler().bug(\"cannot encode inference variable types\");\n+            cx.diag.bug(\"cannot encode inference variable types\");\n         }\n         ty::TyParam(ParamTy {space, idx, name}) => {\n             mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name)\n@@ -279,7 +279,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReVar(_) | ty::ReSkolemized(..) => {\n             // these should not crop up after typeck\n-            cx.diag.handler().bug(\"cannot encode region variables\");\n+            cx.diag.bug(\"cannot encode region variables\");\n         }\n     }\n }"}, {"sha": "8f3a1c17440fc56204f3fec8a20da367f5b4ed0c", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -256,7 +256,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n         }\n     }\n \n-    fn to_pats(&mut self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<Pattern<'tcx>> {\n+    fn to_pats(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n         pats.iter().map(|p| self.to_pat(p)).collect()\n     }\n \n@@ -267,9 +267,9 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n     fn slice_or_array_pattern(&mut self,\n                               pat: &'tcx hir::Pat,\n                               ty: Ty<'tcx>,\n-                              prefix: &'tcx Vec<P<hir::Pat>>,\n+                              prefix: &'tcx [P<hir::Pat>],\n                               slice: &'tcx Option<P<hir::Pat>>,\n-                              suffix: &'tcx Vec<P<hir::Pat>>)\n+                              suffix: &'tcx [P<hir::Pat>])\n                               -> PatternKind<'tcx> {\n         match ty.sty {\n             ty::TySlice(..) => {"}, {"sha": "476425a75c22df73bb61953d0bf6cb2a124130bf", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -13,7 +13,7 @@\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::diagnostic;\n+use syntax::errors;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n@@ -33,7 +33,7 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n }\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n-pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n+pub fn find_plugin_registrar(diagnostic: &errors::Handler,\n                              krate: &hir::Crate)\n                              -> Option<ast::NodeId> {\n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n@@ -46,11 +46,11 @@ pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n             Some(node_id)\n         },\n         _ => {\n-            diagnostic.handler().err(\"multiple plugin registration functions found\");\n+            diagnostic.err(\"multiple plugin registration functions found\");\n             for &(_, span) in &finder.registrars {\n                 diagnostic.span_note(span, \"one is here\");\n             }\n-            diagnostic.handler().abort_if_errors();\n+            diagnostic.abort_if_errors();\n             unreachable!();\n         }\n     }"}, {"sha": "8505c3968ee15ea761187821777340880c96416d", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -101,7 +101,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n-                    write::llvm_err(sess.diagnostic().handler(),\n+                    write::llvm_err(sess.diagnostic(),\n                                     format!(\"failed to load bc of `{}`\",\n                                             &name[..]));\n                 }"}, {"sha": "67eff1ca19fbc1957764576c1e213aa9245142fa", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -20,8 +20,8 @@ use trans::{CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n use syntax::codemap;\n-use syntax::diagnostic;\n-use syntax::diagnostic::{Emitter, Handler, Level};\n+use syntax::errors::{self, Handler, Level};\n+use syntax::errors::emitter::Emitter;\n \n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n@@ -34,7 +34,7 @@ use std::sync::mpsc::channel;\n use std::thread;\n use libc::{self, c_uint, c_int, c_void};\n \n-pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n+pub fn llvm_err(handler: &errors::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -49,7 +49,7 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n }\n \n pub fn write_output_file(\n-        handler: &diagnostic::Handler,\n+        handler: &errors::Handler,\n         target: llvm::TargetMachineRef,\n         pm: llvm::PassManagerRef,\n         m: ModuleRef,\n@@ -109,9 +109,9 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n+    fn emit(&mut self, sp: Option<codemap::Span>,\n             msg: &str, code: Option<&str>, lvl: Level) {\n-        assert!(cmsp.is_none(), \"SharedEmitter doesn't support spans\");\n+        assert!(sp.is_none(), \"SharedEmitter doesn't support spans\");\n \n         self.buffer.lock().unwrap().push(Diagnostic {\n             msg: msg.to_string(),\n@@ -120,8 +120,7 @@ impl Emitter for SharedEmitter {\n         });\n     }\n \n-    fn custom_emit(&mut self, _cm: &codemap::CodeMap,\n-                   _sp: diagnostic::RenderSpan, _msg: &str, _lvl: Level) {\n+    fn custom_emit(&mut self, _sp: errors::RenderSpan, _msg: &str, _lvl: Level) {\n         panic!(\"SharedEmitter doesn't support custom_emit\");\n     }\n }\n@@ -226,7 +225,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     };\n \n     if tm.is_null() {\n-        llvm_err(sess.diagnostic().handler(),\n+        llvm_err(sess.diagnostic(),\n                  format!(\"Could not create LLVM TargetMachine for triple: {}\",\n                          triple).to_string());\n     } else {\n@@ -333,7 +332,7 @@ impl<'a> CodegenContext<'a> {\n     fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n         CodegenContext {\n             lto_ctxt: Some((sess, reachable)),\n-            handler: sess.diagnostic().handler(),\n+            handler: sess.diagnostic(),\n             plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n             remark: sess.opts.cg.remark.clone(),\n             worker: 0,\n@@ -545,10 +544,22 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         if config.emit_asm {\n             let path = output_names.with_extension(&format!(\"{}.s\", name_extra));\n+\n+            // We can't use the same module for asm and binary output, because that triggers\n+            // various errors like invalid IR or broken binaries, so we might have to clone the\n+            // module to produce the asm output\n+            let llmod = if config.emit_obj {\n+                llvm::LLVMCloneModule(llmod)\n+            } else {\n+                llmod\n+            };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n                                   llvm::AssemblyFileType);\n             });\n+            if config.emit_obj {\n+                llvm::LLVMDisposeModule(llmod);\n+            }\n         }\n \n         if config.emit_obj {\n@@ -863,7 +874,7 @@ fn run_work_multithreaded(sess: &Session,\n         futures.push(rx);\n \n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move || {\n-            let diag_handler = Handler::with_emitter(true, box diag_emitter);\n+            let diag_handler = Handler::with_emitter(true, false, box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n             // fields.\n@@ -903,7 +914,7 @@ fn run_work_multithreaded(sess: &Session,\n             },\n         }\n         // Display any new diagnostics.\n-        diag_emitter.dump(sess.diagnostic().handler());\n+        diag_emitter.dump(sess.diagnostic());\n     }\n     if panicked {\n         sess.fatal(\"aborting due to worker thread panic\");"}, {"sha": "9c6b54e13796de6b9e2682a0a9c50978b841db8e", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -41,7 +41,6 @@ use std::fs::File;\n use syntax::ast::{self, NodeId};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n@@ -572,7 +571,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_trait(&mut self,\n                      item: &ast::Item,\n                      generics: &ast::Generics,\n-                     trait_refs: &OwnedSlice<ast::TyParamBound>,\n+                     trait_refs: &ast::TyParamBounds,\n                      methods: &[P<ast::TraitItem>]) {\n         let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);"}, {"sha": "c744ef321278d0b6d6b6eb10ce7308a74b124708", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -1165,7 +1165,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n \n     let meta = val.meta;\n \n-    // Calculate the unaligned offset of the the unsized field.\n+    // Calculate the unaligned offset of the unsized field.\n     let mut offset = 0;\n     for &ty in &st.fields[0..ix] {\n         let llty = type_of::sizing_type_of(ccx, ty);"}, {"sha": "d33beab9313d0f16e2fa4292d08f7c654b5b6ec2", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -20,7 +20,6 @@ pub use self::CallArgs::*;\n \n use arena::TypedArena;\n use back::link;\n-use session;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n use middle::def;\n@@ -57,6 +56,7 @@ use rustc_front::hir;\n \n use syntax::abi as synabi;\n use syntax::ast;\n+use syntax::errors;\n use syntax::ptr::P;\n \n #[derive(Copy, Clone)]\n@@ -412,8 +412,8 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             Some(n) => n,\n             None => { return false; }\n         };\n-        let map_node = session::expect(\n-            &tcx.sess,\n+        let map_node = errors::expect(\n+            &tcx.sess.diagnostic(),\n             tcx.map.find(node_id),\n             || \"local item should be in ast map\".to_string());\n "}, {"sha": "038e699a043ab4d755c17484959defab7227ed98", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -1037,7 +1037,7 @@ pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n                     expr: &hir::Expr,\n                     id: ast::NodeId,\n-                    attrs: &Vec<ast::Attribute>)\n+                    attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");"}, {"sha": "4b6a0d1a5096541cd77ba4349c0db612c417bc91", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use back::link::exported_name;\n-use session;\n use llvm::ValueRef;\n use llvm;\n use middle::def_id::DefId;\n@@ -32,6 +31,7 @@ use rustc_front::hir;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::errors;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -83,8 +83,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            hash_id);\n \n \n-    let map_node = session::expect(\n-        ccx.sess(),\n+    let map_node = errors::expect(\n+        ccx.sess().diagnostic(),\n         ccx.tcx().map.find(fn_node_id),\n         || {\n             format!(\"while monomorphizing {:?}, couldn't find it in \\"}, {"sha": "bddf0e9ffb0cb1d205aa00b2c8aff3f1e88010aa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -119,7 +119,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Spanned};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, InternedString};\n use syntax::ptr::P;\n use syntax::util::lev_distance::lev_distance;\n@@ -4907,7 +4906,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &hir::Block) -> bool {\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                       tps: &OwnedSlice<hir::TyParam>,\n+                                       tps: &P<[hir::TyParam]>,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n            tps.len(),  ty);"}, {"sha": "675eef637b10b7626a83b476ae79a084b7df973b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -112,7 +112,7 @@ impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n+impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     fn clean(&self, cx: &DocContext) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n@@ -1584,8 +1584,13 @@ impl Clean<Type> for hir::Ty {\n                 resolve_type(cx, p.clean(cx), self.id)\n             }\n             TyPath(Some(ref qself), ref p) => {\n-                let mut trait_path = p.clone();\n-                trait_path.segments.pop();\n+                let mut segments: Vec<_> = p.segments.clone().into();\n+                segments.pop();\n+                let trait_path = hir::Path {\n+                    span: p.span,\n+                    global: p.global,\n+                    segments: segments.into(),\n+                };\n                 Type::QPath {\n                     name: p.segments.last().unwrap().identifier.name.clean(cx),\n                     self_type: box qself.ty.clean(cx),"}, {"sha": "c6c98851f7c34af366a5b04575e980f171cf5836", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -22,7 +22,8 @@ use rustc_resolve as resolve;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_metadata::cstore::CStore;\n \n-use syntax::{ast, codemap, diagnostic};\n+use syntax::{ast, codemap, errors};\n+use syntax::errors::emitter::ColorConfig;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::parse::token;\n \n@@ -116,15 +117,16 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = codemap::CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let codemap = Rc::new(codemap::CodeMap::new());\n+    let diagnostic_handler = errors::Handler::new(ColorConfig::Auto,\n+                                                  None,\n+                                                  true,\n+                                                  false,\n+                                                  codemap.clone());\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n-    let sess = session::build_session_(sessopts, cpath,\n-                                       span_diagnostic_handler, cstore_);\n+    let sess = session::build_session_(sessopts, cpath, diagnostic_handler, codemap, cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess);"}, {"sha": "fc0422b3a3f037ad6be59491121c57deb068532f", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -24,7 +24,7 @@ use rustc_front::hir;\n \n pub struct Module {\n     pub name: Option<Name>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n     pub extern_crates: Vec<ExternCrate>,\n@@ -58,7 +58,7 @@ impl Module {\n             depr: None,\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n-            attrs      : Vec::new(),\n+            attrs      : hir::HirVec::new(),\n             extern_crates: Vec::new(),\n             imports    : Vec::new(),\n             structs    : Vec::new(),\n@@ -103,26 +103,26 @@ pub struct Struct {\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<ast::Attribute>,\n-    pub fields: Vec<hir::StructField>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub fields: hir::HirVec<hir::StructField>,\n     pub whence: Span,\n }\n \n pub struct Enum {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub variants: Vec<Variant>,\n+    pub variants: hir::HirVec<Variant>,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: NodeId,\n     pub whence: Span,\n     pub name: Name,\n }\n \n pub struct Variant {\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub def: hir::VariantData,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -131,7 +131,7 @@ pub struct Variant {\n \n pub struct Function {\n     pub decl: hir::FnDecl,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: NodeId,\n     pub name: Name,\n     pub vis: hir::Visibility,\n@@ -149,7 +149,7 @@ pub struct Typedef {\n     pub gen: hir::Generics,\n     pub name: Name,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -162,7 +162,7 @@ pub struct Static {\n     pub mutability: hir::Mutability,\n     pub expr: P<hir::Expr>,\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -174,7 +174,7 @@ pub struct Constant {\n     pub type_: P<hir::Ty>,\n     pub expr: P<hir::Expr>,\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -185,10 +185,10 @@ pub struct Constant {\n pub struct Trait {\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n-    pub items: Vec<hir::TraitItem>,\n+    pub items: hir::HirVec<hir::TraitItem>,\n     pub generics: hir::Generics,\n-    pub bounds: Vec<hir::TyParamBound>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub bounds: hir::HirVec<hir::TyParamBound>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: ast::NodeId,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n@@ -202,8 +202,8 @@ pub struct Impl {\n     pub generics: hir::Generics,\n     pub trait_: Option<hir::TraitRef>,\n     pub for_: P<hir::Ty>,\n-    pub items: Vec<hir::ImplItem>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub items: hir::HirVec<hir::ImplItem>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -215,16 +215,16 @@ pub struct DefaultImpl {\n     pub unsafety: hir::Unsafety,\n     pub trait_: hir::TraitRef,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Macro {\n     pub name: Name,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub matchers: Vec<Span>,\n+    pub matchers: hir::HirVec<Span>,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub imported_from: Option<Name>,\n@@ -234,14 +234,14 @@ pub struct ExternCrate {\n     pub name: Name,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Import {\n     pub id: NodeId,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub node: hir::ViewPath_,\n     pub whence: Span,\n }"}, {"sha": "31fdc1170c0261f54dc285cba4ff162f0d27eb58", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -65,7 +65,7 @@ use externalfiles::ExternalHtml;\n use serialize::Decodable;\n use serialize::json::{self, Json};\n use rustc::session::search_paths::SearchPaths;\n-use syntax::diagnostic;\n+use syntax::errors::emitter::ColorConfig;\n \n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n@@ -228,7 +228,7 @@ pub fn main_args(args: &[String]) -> isize {\n \n     let mut libs = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        libs.add_path(s, diagnostic::Auto);\n+        libs.add_path(s, ColorConfig::Auto);\n     }\n     let externs = match parse_externs(&matches) {\n         Ok(ex) => ex,\n@@ -363,7 +363,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // First, parse the crate and extract all relevant information.\n     let mut paths = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n-        paths.add_path(s, diagnostic::Auto);\n+        paths.add_path(s, ColorConfig::Auto);\n     }\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");"}, {"sha": "fde8299d2d2e6f5a37a851df388ab52380e93c12", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -34,7 +34,8 @@ use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n use rustc_metadata::cstore::CStore;\n use syntax::codemap::CodeMap;\n-use syntax::diagnostic;\n+use syntax::errors;\n+use syntax::errors::emitter::ColorConfig;\n use syntax::parse::token;\n \n use core;\n@@ -71,16 +72,19 @@ pub fn run(input: &str,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::new(diagnostic::Auto, None, true);\n-    let span_diagnostic_handler =\n-    diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let codemap = Rc::new(CodeMap::new());\n+    let diagnostic_handler = errors::Handler::new(ColorConfig::Auto,\n+                                                  None,\n+                                                  true,\n+                                                  false,\n+                                                  codemap.clone());\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        Some(input_path.clone()),\n-                                       span_diagnostic_handler,\n+                                       diagnostic_handler,\n+                                       codemap,\n                                        cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n@@ -220,21 +224,22 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         }\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let emitter = diagnostic::EmitterWriter::new(box Sink(data.clone()), None);\n+    let codemap = Rc::new(CodeMap::new());\n+    let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n+                                                      None,\n+                                                      codemap.clone());\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data, old.unwrap_or(box io::stdout()));\n \n     // Compile the code\n-    let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::Handler::with_emitter(true, box emitter);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n     let cstore_ = ::rustc_driver::cstore_to_cratestore(cstore.clone());\n     let sess = session::build_session_(sessopts,\n                                        None,\n-                                       span_diagnostic_handler,\n+                                       diagnostic_handler,\n+                                       codemap,\n                                        cstore_);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n "}, {"sha": "ba389bc42b78cd30df66543a03e688ef923a9827", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -38,7 +38,7 @@ use doctree::*;\n \n pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),\n-            attrs: Vec::new(),\n+            attrs: hir::HirVec::new(),\n             cx: cx,\n             analysis: analysis,\n             view_item_stack: stack,\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<ast::Attribute> ,\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: hir::HirVec<ast::Attribute>,\n                               vis: hir::Visibility, id: ast::NodeId,\n                               m: &hir::Mod,\n                               name: Option<ast::Name>) -> Module {\n@@ -192,7 +192,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let mine = paths.into_iter().filter(|path| {\n                     !self.resolve_id(path.node.id(), None, false, om,\n                                      please_inline)\n-                }).collect::<Vec<hir::PathListItem>>();\n+                }).collect::<hir::HirVec<hir::PathListItem>>();\n \n                 if mine.is_empty() {\n                     None"}, {"sha": "c4f59d51f5dade8aa9c6218b0ecd2ad0e3f08823", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -42,7 +42,7 @@ mod imp {\n         const NR_GETRANDOM: libc::c_long = 355;\n         #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc\"))]\n         const NR_GETRANDOM: libc::c_long = 384;\n-        #[cfg(any(target_arch = \"aarch64\"))]\n+        #[cfg(target_arch = \"aarch64\")]\n         const NR_GETRANDOM: libc::c_long = 278;\n \n         unsafe {\n@@ -60,8 +60,7 @@ mod imp {\n \n     fn getrandom_fill_bytes(v: &mut [u8]) {\n         let mut read = 0;\n-        let len = v.len();\n-        while read < len {\n+        while read < v.len() {\n             let result = getrandom(&mut v[read..]);\n             if result == -1 {\n                 let err = errno() as libc::c_int;"}, {"sha": "4b0ec8578c12ed5a869d15fb3e8472c10cef5ed0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -50,7 +50,6 @@ use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use ext::base;\n use ext::tt::macro_parser;\n-use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n use parse::token;\n use parse::lexer;\n@@ -261,8 +260,8 @@ impl PathParameters {\n     pub fn none() -> PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n             lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n-            bindings: OwnedSlice::empty(),\n+            types: P::empty(),\n+            bindings: P::empty(),\n         })\n     }\n \n@@ -334,10 +333,10 @@ pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n-    pub types: OwnedSlice<P<Ty>>,\n+    pub types: P<[P<Ty>]>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n-    pub bindings: OwnedSlice<P<TypeBinding>>,\n+    pub bindings: P<[P<TypeBinding>]>,\n }\n \n impl AngleBracketedParameterData {\n@@ -394,7 +393,7 @@ pub enum TraitBoundModifier {\n     Maybe,\n }\n \n-pub type TyParamBounds = OwnedSlice<TyParamBound>;\n+pub type TyParamBounds = P<[TyParamBound]>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TyParam {\n@@ -410,7 +409,7 @@ pub struct TyParam {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n     pub lifetimes: Vec<LifetimeDef>,\n-    pub ty_params: OwnedSlice<TyParam>,\n+    pub ty_params: P<[TyParam]>,\n     pub where_clause: WhereClause,\n }\n \n@@ -430,7 +429,7 @@ impl Default for Generics {\n     fn default() ->  Generics {\n         Generics {\n             lifetimes: Vec::new(),\n-            ty_params: OwnedSlice::empty(),\n+            ty_params: P::empty(),\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n@@ -466,7 +465,7 @@ pub struct WhereBoundPredicate {\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n-    pub bounds: OwnedSlice<TyParamBound>,\n+    pub bounds: TyParamBounds,\n }\n \n /// A lifetime predicate, e.g. `'a: 'b+'c`"}, {"sha": "d38b771814c2874ae30e24df88d52523e2ffed68", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -12,7 +12,6 @@ use ast::*;\n use ast;\n use codemap;\n use codemap::Span;\n-use owned_slice::OwnedSlice;\n use parse::token;\n use print::pprust;\n use ptr::P;\n@@ -43,8 +42,8 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n                 identifier: identifier,\n                 parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n-                    bindings: OwnedSlice::empty(),\n+                    types: P::empty(),\n+                    bindings: P::empty(),\n                 })\n             }\n         ),"}, {"sha": "26662605ba87fb68abab4d729ac722f7d669c3a9", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -21,7 +21,7 @@ use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use config::CfgDiag;\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use feature_gate::{GatedCfg, GatedCfgAttr};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::InternedString;\n@@ -299,14 +299,14 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n }\n \n /// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &SpanHandler, attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<InternedString> {\n     attrs.iter().fold(None, |ia,attr| {\n         if attr.check_name(\"export_name\") {\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n                 diag.span_err(attr.span, \"export_name attribute has invalid format\");\n-                diag.handler.help(\"use #[export_name=\\\"*\\\"]\");\n+                diag.help(\"use #[export_name=\\\"*\\\"]\");\n                 None\n             }\n         } else {\n@@ -324,7 +324,7 @@ pub enum InlineAttr {\n }\n \n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(diagnostic: Option<&SpanHandler>, attrs: &[Attribute]) -> InlineAttr {\n+pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia,attr| {\n         match attr.node.value.node {\n             MetaWord(ref n) if *n == \"inline\" => {\n@@ -426,7 +426,7 @@ impl StabilityLevel {\n     pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n }\n \n-fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n+fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                  attrs_iter: I,\n                                  item_sp: Span)\n                                  -> Option<Stability>\n@@ -612,10 +612,10 @@ fn find_stability_generic<'a, I>(diagnostic: &SpanHandler,\n     stab\n }\n \n-fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n-                                 attrs_iter: I,\n-                                 item_sp: Span)\n-                                 -> Option<Deprecation>\n+fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n+                                   attrs_iter: I,\n+                                   item_sp: Span)\n+                                   -> Option<Deprecation>\n     where I: Iterator<Item = &'a Attribute>\n {\n     let mut depr: Option<Deprecation> = None;\n@@ -672,18 +672,18 @@ fn find_deprecation_generic<'a, I>(diagnostic: &SpanHandler,\n }\n \n /// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(diagnostic: &SpanHandler, attrs: &[Attribute],\n+pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n                       item_sp: Span) -> Option<Stability> {\n     find_stability_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n /// Find the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(diagnostic: &SpanHandler, attrs: &[Attribute],\n-                      item_sp: Span) -> Option<Deprecation> {\n+pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n+                        item_sp: Span) -> Option<Deprecation> {\n     find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n-pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n+pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n     let mut set = HashSet::new();\n     for meta in metas {\n         let name = meta.name();\n@@ -702,7 +702,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n /// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n /// the same discriminant size that the corresponding C enum would or C\n /// structure layout, and `packed` to remove padding.\n-pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n+pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n     match attr.node.value.node {\n         ast::MetaList(ref s, ref items) if *s == \"repr\" => {"}, {"sha": "64b16538f05a14e0877ef28899475964ceba9b80", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use attr::AttrMetaMethods;\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use feature_gate::GatedCfgAttr;\n use fold::Folder;\n use {ast, fold, attr};\n@@ -23,12 +23,12 @@ use util::small_vector::SmallVector;\n /// configuration.\n struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     in_cfg: F,\n-    diagnostic: &'a SpanHandler,\n+    diagnostic: &'a Handler,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n+pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n                                 feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n                                 -> ast::Crate\n {\n@@ -83,7 +83,7 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n     }\n }\n \n-pub fn strip_items<'a, F>(diagnostic: &'a SpanHandler,\n+pub fn strip_items<'a, F>(diagnostic: &'a Handler,\n                           krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     F: FnMut(&[ast::Attribute]) -> bool,\n {\n@@ -291,7 +291,7 @@ struct CfgAttrFolder<'a, T> {\n }\n \n // Process `#[cfg_attr]`.\n-fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate,\n+fn process_cfg_attr(diagnostic: &Handler, krate: ast::Crate,\n                     feature_gated_cfgs: &mut Vec<GatedCfgAttr>) -> ast::Crate {\n     let mut fld = CfgAttrFolder {\n         diag: CfgDiagReal {\n@@ -463,17 +463,17 @@ impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n }\n \n pub trait CfgDiag {\n-    fn emit_error<F>(&mut self, f: F) where F: FnMut(&SpanHandler);\n+    fn emit_error<F>(&mut self, f: F) where F: FnMut(&Handler);\n     fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n }\n \n pub struct CfgDiagReal<'a, 'b> {\n-    pub diag: &'a SpanHandler,\n+    pub diag: &'a Handler,\n     pub feature_gated_cfgs: &'b mut Vec<GatedCfgAttr>,\n }\n \n impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n-    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&SpanHandler) {\n+    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&Handler) {\n         f(self.diag)\n     }\n     fn flag_gated<F>(&mut self, mut f: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {\n@@ -486,7 +486,7 @@ struct CfgDiagSilent {\n }\n \n impl CfgDiag for CfgDiagSilent {\n-    fn emit_error<F>(&mut self, _: F) where F: FnMut(&SpanHandler) {\n+    fn emit_error<F>(&mut self, _: F) where F: FnMut(&Handler) {\n         self.error = true;\n     }\n     fn flag_gated<F>(&mut self, _: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {}"}, {"sha": "7fef85a833e251224f3456ed46da1a11a8d270b4", "filename": "src/libsyntax/errors/emitter.rs", "status": "renamed", "additions": 229, "deletions": 449, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,423 +8,156 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Level::*;\n-pub use self::RenderSpan::*;\n-pub use self::ColorConfig::*;\n use self::Destination::*;\n \n use codemap::{self, COMMAND_LINE_SP, COMMAND_LINE_EXPN, Pos, Span};\n use diagnostics;\n \n-use std::cell::{RefCell, Cell};\n-use std::{cmp, error, fmt};\n+use errors::{Level, RenderSpan};\n+use errors::RenderSpan::*;\n+use errors::Level::*;\n+\n+use std::{cmp, fmt};\n use std::io::prelude::*;\n use std::io;\n+use std::rc::Rc;\n use term;\n \n-/// maximum number of lines we will print for each error; arbitrary.\n-const MAX_LINES: usize = 6;\n \n-#[derive(Clone)]\n-pub enum RenderSpan {\n-    /// A FullSpan renders with both with an initial line for the\n-    /// message, prefixed by file:linenum, followed by a summary of\n-    /// the source code covered by the span.\n-    FullSpan(Span),\n-\n-    /// Similar to a FullSpan, but the cited position is the end of\n-    /// the span, instead of the start. Used, at least, for telling\n-    /// compiletest/runtest to look at the last line of the span\n-    /// (since `end_highlight_lines` displays an arrow to the end\n-    /// of the span).\n-    EndSpan(Span),\n-\n-    /// A suggestion renders with both with an initial line for the\n-    /// message, prefixed by file:linenum, followed by a summary\n-    /// of hypothetical source code, where the `String` is spliced\n-    /// into the lines in place of the code covered by the span.\n-    Suggestion(Span, String),\n-\n-    /// A FileLine renders with just a line for the message prefixed\n-    /// by file:linenum.\n-    FileLine(Span),\n+pub trait Emitter {\n+    fn emit(&mut self, span: Option<Span>, msg: &str, code: Option<&str>, lvl: Level);\n+    fn custom_emit(&mut self, sp: RenderSpan, msg: &str, lvl: Level);\n }\n \n-impl RenderSpan {\n-    fn span(&self) -> Span {\n-        match *self {\n-            FullSpan(s) |\n-            Suggestion(s, _) |\n-            EndSpan(s) |\n-            FileLine(s) =>\n-                s\n-        }\n-    }\n-}\n+/// maximum number of lines we will print for each error; arbitrary.\n+const MAX_LINES: usize = 6;\n \n #[derive(Clone, Copy)]\n pub enum ColorConfig {\n     Auto,\n     Always,\n-    Never\n+    Never,\n }\n \n-pub trait Emitter {\n-    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str, code: Option<&str>, lvl: Level);\n-    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: RenderSpan, msg: &str, lvl: Level);\n-}\n-\n-/// Used as a return value to signify a fatal error occurred. (It is also\n-/// used as the argument to panic at the moment, but that will eventually\n-/// not be true.)\n-#[derive(Copy, Clone, Debug)]\n-#[must_use]\n-pub struct FatalError;\n-\n-impl fmt::Display for FatalError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(f, \"parser fatal error\")\n+impl ColorConfig {\n+    fn use_color(&self) -> bool {\n+        match *self {\n+            ColorConfig::Always => true,\n+            ColorConfig::Never  => false,\n+            ColorConfig::Auto   => stderr_isatty(),\n+        }\n     }\n }\n \n-impl error::Error for FatalError {\n-    fn description(&self) -> &str {\n-        \"The parser has encountered a fatal error\"\n-    }\n+// A basic emitter for when we don't have access to a codemap or registry. Used\n+// for reporting very early errors, etc.\n+pub struct BasicEmitter {\n+    dst: Destination,\n }\n \n-/// Signifies that the compiler died with an explicit call to `.bug`\n-/// or `.span_bug` rather than a failed assertion, etc.\n-#[derive(Copy, Clone, Debug)]\n-pub struct ExplicitBug;\n-\n-impl fmt::Display for ExplicitBug {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(f, \"parser internal bug\")\n-    }\n-}\n+impl Emitter for BasicEmitter {\n+    fn emit(&mut self,\n+            sp: Option<Span>,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        assert!(sp.is_none(), \"BasicEmitter can't handle spans\");\n+        if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n+        }\n \n-impl error::Error for ExplicitBug {\n-    fn description(&self) -> &str {\n-        \"The parser has encountered an internal bug\"\n     }\n-}\n \n-/// A span-handler is like a handler but also\n-/// accepts span information for source-location\n-/// reporting.\n-pub struct SpanHandler {\n-    pub handler: Handler,\n-    pub cm: codemap::CodeMap,\n-}\n-\n-impl SpanHandler {\n-    pub fn new(handler: Handler, cm: codemap::CodeMap) -> SpanHandler {\n-        SpanHandler {\n-            handler: handler,\n-            cm: cm,\n-        }\n+    fn custom_emit(&mut self, _: RenderSpan, _: &str, _: Level) {\n+        panic!(\"BasicEmitter can't handle custom_emit\");\n     }\n-    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n-        return FatalError;\n-    }\n-    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Fatal);\n-        return FatalError;\n-    }\n-    pub fn span_err(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Error);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Error);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Warning);\n-    }\n-    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Warning);\n-    }\n-    pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Note);\n-    }\n-    pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, EndSpan(sp), msg, Note);\n-    }\n-    pub fn span_help(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Help);\n-    }\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n-        self.handler.custom_emit(&self.cm, Suggestion(sp, suggestion), msg, Help);\n-    }\n-    pub fn fileline_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Note);\n-    }\n-    pub fn fileline_help(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&self.cm, FileLine(sp), msg, Help);\n-    }\n-    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n-        panic!(ExplicitBug);\n-    }\n-    pub fn span_bug_no_panic(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n-        self.handler.bump_err_count();\n-    }\n-    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n-    }\n-    pub fn handler<'a>(&'a self) -> &'a Handler {\n-        &self.handler\n-    }\n-}\n-\n-/// A handler deals with errors; certain errors\n-/// (fatal, bug, unimpl) may cause immediate exit,\n-/// others log errors for later reporting.\n-pub struct Handler {\n-    err_count: Cell<usize>,\n-    emit: RefCell<Box<Emitter + Send>>,\n-    pub can_emit_warnings: bool\n }\n \n-impl Handler {\n-    pub fn new(color_config: ColorConfig,\n-               registry: Option<diagnostics::registry::Registry>,\n-               can_emit_warnings: bool) -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, registry));\n-        Handler::with_emitter(can_emit_warnings, emitter)\n-    }\n-    pub fn with_emitter(can_emit_warnings: bool, e: Box<Emitter + Send>) -> Handler {\n-        Handler {\n-            err_count: Cell::new(0),\n-            emit: RefCell::new(e),\n-            can_emit_warnings: can_emit_warnings\n-        }\n-    }\n-    pub fn fatal(&self, msg: &str) -> FatalError {\n-        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n-        FatalError\n-    }\n-    pub fn err(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Error);\n-        self.bump_err_count();\n-    }\n-    pub fn bump_err_count(&self) {\n-        self.err_count.set(self.err_count.get() + 1);\n-    }\n-    pub fn err_count(&self) -> usize {\n-        self.err_count.get()\n-    }\n-    pub fn has_errors(&self) -> bool {\n-        self.err_count.get() > 0\n-    }\n-    pub fn abort_if_errors(&self) {\n-        let s;\n-        match self.err_count.get() {\n-            0 => return,\n-            1 => s = \"aborting due to previous error\".to_string(),\n-            _  => {\n-                s = format!(\"aborting due to {} previous errors\",\n-                            self.err_count.get());\n-            }\n+impl BasicEmitter {\n+    pub fn stderr(color_config: ColorConfig) -> BasicEmitter {\n+        if color_config.use_color() {\n+            let dst = Destination::from_stderr();\n+            BasicEmitter { dst: dst }\n+        } else {\n+            BasicEmitter { dst: Raw(Box::new(io::stderr())) }\n         }\n-\n-        panic!(self.fatal(&s[..]));\n-    }\n-    pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Warning);\n-    }\n-    pub fn note(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Note);\n-    }\n-    pub fn help(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Help);\n-    }\n-    pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(None, msg, None, Bug);\n-        panic!(ExplicitBug);\n-    }\n-    pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(&format!(\"unimplemented {}\", msg));\n-    }\n-    pub fn emit(&self,\n-                cmsp: Option<(&codemap::CodeMap, Span)>,\n-                msg: &str,\n-                lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(cmsp, msg, None, lvl);\n-    }\n-    pub fn emit_with_code(&self,\n-                          cmsp: Option<(&codemap::CodeMap, Span)>,\n-                          msg: &str,\n-                          code: &str,\n-                          lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(cmsp, msg, Some(code), lvl);\n-    }\n-    pub fn custom_emit(&self, cm: &codemap::CodeMap,\n-                       sp: RenderSpan, msg: &str, lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().custom_emit(cm, sp, msg, lvl);\n     }\n }\n \n-#[derive(Copy, PartialEq, Clone, Debug)]\n-pub enum Level {\n-    Bug,\n-    Fatal,\n-    Error,\n-    Warning,\n-    Note,\n-    Help,\n+pub struct EmitterWriter {\n+    dst: Destination,\n+    registry: Option<diagnostics::registry::Registry>,\n+    cm: Rc<codemap::CodeMap>,\n }\n \n-impl fmt::Display for Level {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use std::fmt::Display;\n+impl Emitter for EmitterWriter {\n+    fn emit(&mut self,\n+            sp: Option<Span>,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        let error = match sp {\n+            Some(COMMAND_LINE_SP) => self.emit_(FileLine(COMMAND_LINE_SP), msg, code, lvl),\n+            Some(sp) => self.emit_(FullSpan(sp), msg, code, lvl),\n+            None => print_diagnostic(&mut self.dst, \"\", lvl, msg, code),\n+        };\n \n-        match *self {\n-            Bug => \"error: internal compiler error\".fmt(f),\n-            Fatal | Error => \"error\".fmt(f),\n-            Warning => \"warning\".fmt(f),\n-            Note => \"note\".fmt(f),\n-            Help => \"help\".fmt(f),\n+        if let Err(e) = error {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n     }\n-}\n \n-impl Level {\n-    fn color(self) -> term::color::Color {\n-        match self {\n-            Bug | Fatal | Error => term::color::BRIGHT_RED,\n-            Warning => term::color::BRIGHT_YELLOW,\n-            Note => term::color::BRIGHT_GREEN,\n-            Help => term::color::BRIGHT_CYAN,\n+    fn custom_emit(&mut self,\n+                   sp: RenderSpan,\n+                   msg: &str,\n+                   lvl: Level) {\n+        match self.emit_(sp, msg, None, lvl) {\n+            Ok(()) => {}\n+            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }\n \n-pub struct EmitterWriter {\n-    dst: Destination,\n-    registry: Option<diagnostics::registry::Registry>\n-}\n-\n-enum Destination {\n-    Terminal(Box<term::StderrTerminal>),\n-    Raw(Box<Write + Send>),\n-}\n-\n /// Do not use this for messages that end in `\\n` \u2013 use `println_maybe_styled` instead. See\n /// `EmitterWriter::print_maybe_styled` for details.\n macro_rules! print_maybe_styled {\n-    ($writer: expr, $style: expr, $($arg: tt)*) => {\n-        $writer.print_maybe_styled(format_args!($($arg)*), $style, false)\n+    ($dst: expr, $style: expr, $($arg: tt)*) => {\n+        $dst.print_maybe_styled(format_args!($($arg)*), $style, false)\n     }\n }\n \n macro_rules! println_maybe_styled {\n-    ($writer: expr, $style: expr, $($arg: tt)*) => {\n-        $writer.print_maybe_styled(format_args!($($arg)*), $style, true)\n+    ($dst: expr, $style: expr, $($arg: tt)*) => {\n+        $dst.print_maybe_styled(format_args!($($arg)*), $style, true)\n     }\n }\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        let stderr = io::stderr();\n-\n-        let use_color = match color_config {\n-            Always => true,\n-            Never  => false,\n-            Auto   => stderr_isatty(),\n-        };\n-\n-        if use_color {\n-            let dst = match term::stderr() {\n-                Some(t) => Terminal(t),\n-                None    => Raw(Box::new(stderr)),\n-            };\n-            EmitterWriter { dst: dst, registry: registry }\n+                  registry: Option<diagnostics::registry::Registry>,\n+                  code_map: Rc<codemap::CodeMap>)\n+                  -> EmitterWriter {\n+        if color_config.use_color() {\n+            let dst = Destination::from_stderr();\n+            EmitterWriter { dst: dst, registry: registry, cm: code_map }\n         } else {\n-            EmitterWriter { dst: Raw(Box::new(stderr)), registry: registry }\n+            EmitterWriter { dst: Raw(Box::new(io::stderr())), registry: registry, cm: code_map }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n-               registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst), registry: registry }\n-    }\n-\n-    fn print_maybe_styled(&mut self,\n-                          args: fmt::Arguments,\n-                          color: term::Attr,\n-                          print_newline_at_end: bool) -> io::Result<()> {\n-        match self.dst {\n-            Terminal(ref mut t) => {\n-                try!(t.attr(color));\n-                // If `msg` ends in a newline, we need to reset the color before\n-                // the newline. We're making the assumption that we end up writing\n-                // to a `LineBufferedWriter`, which means that emitting the reset\n-                // after the newline ends up buffering the reset until we print\n-                // another line or exit. Buffering the reset is a problem if we're\n-                // sharing the terminal with any other programs (e.g. other rustc\n-                // instances via `make -jN`).\n-                //\n-                // Note that if `msg` contains any internal newlines, this will\n-                // result in the `LineBufferedWriter` flushing twice instead of\n-                // once, which still leaves the opportunity for interleaved output\n-                // to be miscolored. We assume this is rare enough that we don't\n-                // have to worry about it.\n-                try!(t.write_fmt(args));\n-                try!(t.reset());\n-                if print_newline_at_end {\n-                    t.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-            Raw(ref mut w) => {\n-                try!(w.write_fmt(args));\n-                if print_newline_at_end {\n-                    w.write_all(b\"\\n\")\n-                } else {\n-                    Ok(())\n-                }\n-            }\n-        }\n-    }\n-\n-    fn print_diagnostic(&mut self, topic: &str, lvl: Level,\n-                        msg: &str, code: Option<&str>) -> io::Result<()> {\n-        if !topic.is_empty() {\n-            try!(write!(&mut self.dst, \"{} \", topic));\n-        }\n-\n-        try!(print_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n-                                 \"{}: \", lvl.to_string()));\n-        try!(print_maybe_styled!(self, term::Attr::Bold, \"{}\", msg));\n-\n-        match code {\n-            Some(code) => {\n-                let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-                try!(print_maybe_styled!(self, style, \" [{}]\", code.clone()));\n-            }\n-            None => ()\n-        }\n-        try!(write!(&mut self.dst, \"\\n\"));\n-        Ok(())\n+               registry: Option<diagnostics::registry::Registry>,\n+               code_map: Rc<codemap::CodeMap>)\n+               -> EmitterWriter {\n+        EmitterWriter { dst: Raw(dst), registry: registry, cm: code_map }\n     }\n \n-    fn emit_(&mut self, cm: &codemap::CodeMap, rsp: RenderSpan,\n-             msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n+    fn emit_(&mut self,\n+             rsp: RenderSpan,\n+             msg: &str,\n+             code: Option<&str>,\n+             lvl: Level)\n+             -> io::Result<()> {\n         let sp = rsp.span();\n \n         // We cannot check equality directly with COMMAND_LINE_SP\n@@ -433,25 +166,27 @@ impl EmitterWriter {\n             \"<command line option>\".to_string()\n         } else if let EndSpan(_) = rsp {\n             let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-            cm.span_to_string(span_end)\n+            self.cm.span_to_string(span_end)\n         } else {\n-            cm.span_to_string(sp)\n+            self.cm.span_to_string(sp)\n         };\n \n-        try!(self.print_diagnostic(&ss[..], lvl, msg, code));\n+        try!(print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code));\n \n         match rsp {\n             FullSpan(_) => {\n-                try!(self.highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n-                try!(self.print_macro_backtrace(cm, sp));\n+                let lines = self.cm.span_to_lines(sp);\n+                try!(self.highlight_lines(sp, lvl, lines));\n+                try!(self.print_macro_backtrace(sp));\n             }\n             EndSpan(_) => {\n-                try!(self.end_highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n-                try!(self.print_macro_backtrace(cm, sp));\n+                let lines = self.cm.span_to_lines(sp);\n+                try!(self.end_highlight_lines(sp, lvl, lines));\n+                try!(self.print_macro_backtrace(sp));\n             }\n             Suggestion(_, ref suggestion) => {\n-                try!(self.highlight_suggestion(cm, sp, suggestion));\n-                try!(self.print_macro_backtrace(cm, sp));\n+                try!(self.highlight_suggestion(sp, suggestion));\n+                try!(self.print_macro_backtrace(sp));\n             }\n             FileLine(..) => {\n                 // no source text in this case!\n@@ -462,9 +197,9 @@ impl EmitterWriter {\n             Some(code) =>\n                 match self.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n                     Some(_) => {\n-                        try!(self.print_diagnostic(&ss[..], Help,\n-                                                   &format!(\"run `rustc --explain {}` to see a \\\n-                                                             detailed explanation\", code), None));\n+                        try!(print_diagnostic(&mut self.dst, &ss[..], Help,\n+                                              &format!(\"run `rustc --explain {}` to see a \\\n+                                                       detailed explanation\", code), None));\n                     }\n                     None => ()\n                 },\n@@ -474,12 +209,11 @@ impl EmitterWriter {\n     }\n \n     fn highlight_suggestion(&mut self,\n-                            cm: &codemap::CodeMap,\n                             sp: Span,\n                             suggestion: &str)\n                             -> io::Result<()>\n     {\n-        let lines = cm.span_to_lines(sp).unwrap();\n+        let lines = self.cm.span_to_lines(sp).unwrap();\n         assert!(!lines.lines.is_empty());\n \n         // To build up the result, we want to take the snippet from the first\n@@ -521,7 +255,6 @@ impl EmitterWriter {\n     }\n \n     fn highlight_lines(&mut self,\n-                       cm: &codemap::CodeMap,\n                        sp: Span,\n                        lvl: Level,\n                        lines: codemap::FileLinesResult)\n@@ -581,7 +314,7 @@ impl EmitterWriter {\n         // FIXME (#3260)\n         // If there's one line at fault we can easily point to the problem\n         if lines.lines.len() == 1 {\n-            let lo = cm.lookup_char_pos(sp.lo);\n+            let lo = self.cm.lookup_char_pos(sp.lo);\n             let mut digits = 0;\n             let mut num = (lines.lines[0].line_index + 1) / 10;\n \n@@ -628,7 +361,7 @@ impl EmitterWriter {\n                 col += count;\n                 s.extend(::std::iter::repeat('~').take(count));\n \n-                let hi = cm.lookup_char_pos(sp.hi);\n+                let hi = self.cm.lookup_char_pos(sp.hi);\n                 if hi.col != lo.col {\n                     for (pos, ch) in iter {\n                         if pos >= hi.col.to_usize() { break; }\n@@ -646,7 +379,7 @@ impl EmitterWriter {\n                     s.pop();\n                 }\n \n-                try!(println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n+                try!(println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n                                            \"{}\", s));\n             }\n         }\n@@ -661,7 +394,6 @@ impl EmitterWriter {\n     /// six lines.\n     #[allow(deprecated)]\n     fn end_highlight_lines(&mut self,\n-                           cm: &codemap::CodeMap,\n                            sp: Span,\n                            lvl: Level,\n                            lines: codemap::FileLinesResult)\n@@ -697,7 +429,7 @@ impl EmitterWriter {\n             }\n         }\n         let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n-        let hi = cm.lookup_char_pos(sp.hi);\n+        let hi = self.cm.lookup_char_pos(sp.hi);\n         let skip = last_line_start.chars().count();\n         let mut s = String::new();\n         for _ in 0..skip {\n@@ -719,55 +451,82 @@ impl EmitterWriter {\n             }\n         }\n         s.push('^');\n-        println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n+        println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n                               \"{}\", s)\n     }\n \n     fn print_macro_backtrace(&mut self,\n-                             cm: &codemap::CodeMap,\n                              sp: Span)\n                              -> io::Result<()> {\n         let mut last_span = codemap::DUMMY_SP;\n-        let mut sp_opt = Some(sp);\n-\n-        while let Some(sp) = sp_opt {\n-            sp_opt = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n-                match expn_info {\n-                    Some(ei) => {\n-                        let (pre, post) = match ei.callee.format {\n-                            codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n-                            codemap::MacroBang(..) => (\"\", \"!\"),\n-                        };\n-                        // Don't print recursive invocations\n-                        if ei.call_site != last_span {\n-                            last_span = ei.call_site;\n-\n-                            let mut diag_string = format!(\"in this expansion of {}{}{}\",\n-                                                          pre,\n-                                                          ei.callee.name(),\n-                                                          post);\n-\n-                            if let Some(def_site_span) = ei.callee.span {\n-                                diag_string.push_str(&format!(\" (defined in {})\",\n-                                                              cm.span_to_filename(def_site_span)));\n-                            }\n-\n-                            try!(self.print_diagnostic(&cm.span_to_string(ei.call_site),\n-                                                       Note,\n-                                                       &diag_string,\n-                                                       None));\n-                        }\n-                        Ok(Some(ei.call_site))\n-                    }\n-                    None => Ok(None)\n+        let mut span = sp;\n+\n+        loop {\n+            let span_name_span = self.cm.with_expn_info(span.expn_id, |expn_info| {\n+                expn_info.map(|ei| {\n+                    let (pre, post) = match ei.callee.format {\n+                        codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n+                        codemap::MacroBang(..) => (\"\", \"!\"),\n+                    };\n+                    let macro_decl_name = format!(\"in this expansion of {}{}{}\",\n+                                                  pre,\n+                                                  ei.callee.name(),\n+                                                  post);\n+                    let def_site_span = ei.callee.span;\n+                    (ei.call_site, macro_decl_name, def_site_span)\n+                })\n+            });\n+            let (macro_decl_name, def_site_span) = match span_name_span {\n+                None => break,\n+                Some((sp, macro_decl_name, def_site_span)) => {\n+                    span = sp;\n+                    (macro_decl_name, def_site_span)\n                 }\n-            }));\n+            };\n+\n+            // Don't print recursive invocations\n+            if span != last_span {\n+                let mut diag_string = macro_decl_name;\n+                if let Some(def_site_span) = def_site_span {\n+                    diag_string.push_str(&format!(\" (defined in {})\",\n+                                                  self.cm.span_to_filename(def_site_span)));\n+                }\n+\n+                let snippet = self.cm.span_to_string(span);\n+                try!(print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None));\n+            }\n+            last_span = span;\n         }\n \n         Ok(())\n     }\n }\n \n+fn print_diagnostic(dst: &mut Destination,\n+                    topic: &str,\n+                    lvl: Level,\n+                    msg: &str,\n+                    code: Option<&str>)\n+                    -> io::Result<()> {\n+    if !topic.is_empty() {\n+        try!(write!(dst, \"{} \", topic));\n+    }\n+\n+    try!(print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n+                             \"{}: \", lvl.to_string()));\n+    try!(print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg));\n+\n+    match code {\n+        Some(code) => {\n+            let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+            try!(print_maybe_styled!(dst, style, \" [{}]\", code.clone()));\n+        }\n+        None => ()\n+    }\n+    try!(write!(dst, \"\\n\"));\n+    Ok(())\n+}\n+\n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n     use libc;\n@@ -791,6 +550,60 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n+enum Destination {\n+    Terminal(Box<term::StderrTerminal>),\n+    Raw(Box<Write + Send>),\n+}\n+\n+impl Destination {\n+    fn from_stderr() -> Destination {\n+        match term::stderr() {\n+            Some(t) => Terminal(t),\n+            None    => Raw(Box::new(io::stderr())),\n+        }\n+    }\n+\n+    fn print_maybe_styled(&mut self,\n+                          args: fmt::Arguments,\n+                          color: term::Attr,\n+                          print_newline_at_end: bool)\n+                          -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => {\n+                try!(t.attr(color));\n+                // If `msg` ends in a newline, we need to reset the color before\n+                // the newline. We're making the assumption that we end up writing\n+                // to a `LineBufferedWriter`, which means that emitting the reset\n+                // after the newline ends up buffering the reset until we print\n+                // another line or exit. Buffering the reset is a problem if we're\n+                // sharing the terminal with any other programs (e.g. other rustc\n+                // instances via `make -jN`).\n+                //\n+                // Note that if `msg` contains any internal newlines, this will\n+                // result in the `LineBufferedWriter` flushing twice instead of\n+                // once, which still leaves the opportunity for interleaved output\n+                // to be miscolored. We assume this is rare enough that we don't\n+                // have to worry about it.\n+                try!(t.write_fmt(args));\n+                try!(t.reset());\n+                if print_newline_at_end {\n+                    t.write_all(b\"\\n\")\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+            Raw(ref mut w) => {\n+                try!(w.write_fmt(args));\n+                if print_newline_at_end {\n+                    w.write_all(b\"\\n\")\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl Write for Destination {\n     fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n         match *self {\n@@ -806,49 +619,16 @@ impl Write for Destination {\n     }\n }\n \n-impl Emitter for EmitterWriter {\n-    fn emit(&mut self,\n-            cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str, code: Option<&str>, lvl: Level) {\n-        let error = match cmsp {\n-            Some((cm, COMMAND_LINE_SP)) => self.emit_(cm,\n-                                                FileLine(COMMAND_LINE_SP),\n-                                                msg, code, lvl),\n-            Some((cm, sp)) => self.emit_(cm, FullSpan(sp), msg, code, lvl),\n-            None => self.print_diagnostic(\"\", lvl, msg, code),\n-        };\n-\n-        match error {\n-            Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n-        }\n-    }\n-\n-    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n-                   sp: RenderSpan, msg: &str, lvl: Level) {\n-        match self.emit_(cm, sp, msg, None, lvl) {\n-            Ok(()) => {}\n-            Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n-        }\n-    }\n-}\n-\n-pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n-    M: FnOnce() -> String,\n-{\n-    match opt {\n-        Some(t) => t,\n-        None => diag.handler().bug(&msg()),\n-    }\n-}\n \n #[cfg(test)]\n mod test {\n-    use super::{EmitterWriter, Level};\n+    use errors::Level;\n+    use super::EmitterWriter;\n     use codemap::{mk_sp, CodeMap};\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n     use std::str::from_utf8;\n+    use std::rc::Rc;\n \n     // Diagnostic doesn't align properly in span where line number increases by one digit\n     #[test]\n@@ -861,8 +641,8 @@ mod test {\n             fn flush(&mut self) -> io::Result<()> { Ok(()) }\n         }\n         let data = Arc::new(Mutex::new(Vec::new()));\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None);\n-        let cm = CodeMap::new();\n+        let cm = Rc::new(CodeMap::new());\n+        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n         let content = \"abcdefg\n         koksi\n         line3\n@@ -885,7 +665,7 @@ mod test {\n         println!(\"span_to_lines\");\n         let lines = cm.span_to_lines(sp);\n         println!(\"highlight_lines\");\n-        ew.highlight_lines(&cm, sp, lvl, lines).unwrap();\n+        ew.highlight_lines(sp, lvl, lines).unwrap();\n         println!(\"done\");\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;", "previous_filename": "src/libsyntax/diagnostic.rs"}, {"sha": "f2e61090ba23cfc86b1d72a3e9d2b9fe97b9dc1e", "filename": "src/libsyntax/errors/mod.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -0,0 +1,338 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use errors::emitter::ColorConfig;\n+\n+use self::Level::*;\n+use self::RenderSpan::*;\n+\n+use codemap::{self, Span};\n+use diagnostics;\n+use errors::emitter::{Emitter, EmitterWriter};\n+\n+use std::cell::{RefCell, Cell};\n+use std::{error, fmt};\n+use std::io::prelude::*;\n+use std::rc::Rc;\n+use term;\n+\n+pub mod emitter;\n+\n+#[derive(Clone)]\n+pub enum RenderSpan {\n+    /// A FullSpan renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary of\n+    /// the source code covered by the span.\n+    FullSpan(Span),\n+\n+    /// Similar to a FullSpan, but the cited position is the end of\n+    /// the span, instead of the start. Used, at least, for telling\n+    /// compiletest/runtest to look at the last line of the span\n+    /// (since `end_highlight_lines` displays an arrow to the end\n+    /// of the span).\n+    EndSpan(Span),\n+\n+    /// A suggestion renders with both with an initial line for the\n+    /// message, prefixed by file:linenum, followed by a summary\n+    /// of hypothetical source code, where the `String` is spliced\n+    /// into the lines in place of the code covered by the span.\n+    Suggestion(Span, String),\n+\n+    /// A FileLine renders with just a line for the message prefixed\n+    /// by file:linenum.\n+    FileLine(Span),\n+}\n+\n+impl RenderSpan {\n+    fn span(&self) -> Span {\n+        match *self {\n+            FullSpan(s) |\n+            Suggestion(s, _) |\n+            EndSpan(s) |\n+            FileLine(s) =>\n+                s\n+        }\n+    }\n+}\n+\n+/// Used as a return value to signify a fatal error occurred. (It is also\n+/// used as the argument to panic at the moment, but that will eventually\n+/// not be true.)\n+#[derive(Copy, Clone, Debug)]\n+#[must_use]\n+pub struct FatalError;\n+\n+impl fmt::Display for FatalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f, \"parser fatal error\")\n+    }\n+}\n+\n+impl error::Error for FatalError {\n+    fn description(&self) -> &str {\n+        \"The parser has encountered a fatal error\"\n+    }\n+}\n+\n+/// Signifies that the compiler died with an explicit call to `.bug`\n+/// or `.span_bug` rather than a failed assertion, etc.\n+#[derive(Copy, Clone, Debug)]\n+pub struct ExplicitBug;\n+\n+impl fmt::Display for ExplicitBug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(f, \"parser internal bug\")\n+    }\n+}\n+\n+impl error::Error for ExplicitBug {\n+    fn description(&self) -> &str {\n+        \"The parser has encountered an internal bug\"\n+    }\n+}\n+\n+/// A handler deals with errors; certain errors\n+/// (fatal, bug, unimpl) may cause immediate exit,\n+/// others log errors for later reporting.\n+pub struct Handler {\n+    err_count: Cell<usize>,\n+    emit: RefCell<Box<Emitter>>,\n+    pub can_emit_warnings: bool,\n+    treat_err_as_bug: bool,\n+    delayed_span_bug: RefCell<Option<(codemap::Span, String)>>,\n+}\n+\n+impl Handler {\n+    pub fn new(color_config: ColorConfig,\n+               registry: Option<diagnostics::registry::Registry>,\n+               can_emit_warnings: bool,\n+               treat_err_as_bug: bool,\n+               cm: Rc<codemap::CodeMap>)\n+               -> Handler {\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm));\n+        Handler::with_emitter(can_emit_warnings, treat_err_as_bug, emitter)\n+    }\n+\n+    pub fn with_emitter(can_emit_warnings: bool,\n+                        treat_err_as_bug: bool,\n+                        e: Box<Emitter>) -> Handler {\n+        Handler {\n+            err_count: Cell::new(0),\n+            emit: RefCell::new(e),\n+            can_emit_warnings: can_emit_warnings,\n+            treat_err_as_bug: treat_err_as_bug,\n+            delayed_span_bug: RefCell::new(None),\n+        }\n+    }\n+\n+    pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit(Some(sp), msg, Fatal);\n+        return FatalError;\n+    }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit_with_code(Some(sp), msg, code, Fatal);\n+        return FatalError;\n+    }\n+    pub fn span_err(&self, sp: Span, msg: &str) {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit(Some(sp), msg, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n+        self.emit_with_code(Some(sp), msg, code, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn span_warn(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Warning);\n+    }\n+    pub fn span_warn_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        self.emit_with_code(Some(sp), msg, code, Warning);\n+    }\n+    pub fn span_note(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Note);\n+    }\n+    pub fn span_end_note(&self, sp: Span, msg: &str) {\n+        self.custom_emit(EndSpan(sp), msg, Note);\n+    }\n+    pub fn span_help(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Help);\n+    }\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion(&self, sp: Span, msg: &str, suggestion: String) {\n+        self.custom_emit(Suggestion(sp, suggestion), msg, Help);\n+    }\n+    pub fn fileline_note(&self, sp: Span, msg: &str) {\n+        self.custom_emit(FileLine(sp), msg, Note);\n+    }\n+    pub fn fileline_help(&self, sp: Span, msg: &str) {\n+        self.custom_emit(FileLine(sp), msg, Help);\n+    }\n+    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n+        self.emit(Some(sp), msg, Bug);\n+        panic!(ExplicitBug);\n+    }\n+    pub fn delay_span_bug(&self, sp: Span, msg: &str) {\n+        let mut delayed = self.delayed_span_bug.borrow_mut();\n+        *delayed = Some((sp, msg.to_string()));\n+    }\n+    pub fn span_bug_no_panic(&self, sp: Span, msg: &str) {\n+        self.emit(Some(sp), msg, Bug);\n+        self.bump_err_count();\n+    }\n+    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n+        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n+    }\n+    pub fn fatal(&self, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n+        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n+        FatalError\n+    }\n+    pub fn err(&self, msg: &str) {\n+        if self.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n+        self.emit.borrow_mut().emit(None, msg, None, Error);\n+        self.bump_err_count();\n+    }\n+    pub fn warn(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Warning);\n+    }\n+    pub fn note(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Note);\n+    }\n+    pub fn help(&self, msg: &str) {\n+        self.emit.borrow_mut().emit(None, msg, None, Help);\n+    }\n+    pub fn bug(&self, msg: &str) -> ! {\n+        self.emit.borrow_mut().emit(None, msg, None, Bug);\n+        panic!(ExplicitBug);\n+    }\n+    pub fn unimpl(&self, msg: &str) -> ! {\n+        self.bug(&format!(\"unimplemented {}\", msg));\n+    }\n+\n+    pub fn bump_err_count(&self) {\n+        self.err_count.set(self.err_count.get() + 1);\n+    }\n+\n+    pub fn err_count(&self) -> usize {\n+        self.err_count.get()\n+    }\n+\n+    pub fn has_errors(&self) -> bool {\n+        self.err_count.get() > 0\n+    }\n+\n+    pub fn abort_if_errors(&self) {\n+        let s;\n+        match self.err_count.get() {\n+            0 => {\n+                let delayed_bug = self.delayed_span_bug.borrow();\n+                match *delayed_bug {\n+                    Some((span, ref errmsg)) => {\n+                        self.span_bug(span, errmsg);\n+                    },\n+                    _ => {}\n+                }\n+\n+                return;\n+            }\n+            1 => s = \"aborting due to previous error\".to_string(),\n+            _  => {\n+                s = format!(\"aborting due to {} previous errors\",\n+                            self.err_count.get());\n+            }\n+        }\n+\n+        panic!(self.fatal(&s[..]));\n+    }\n+\n+    pub fn emit(&self,\n+                sp: Option<Span>,\n+                msg: &str,\n+                lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().emit(sp, msg, None, lvl);\n+    }\n+\n+    pub fn emit_with_code(&self,\n+                          sp: Option<Span>,\n+                          msg: &str,\n+                          code: &str,\n+                          lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().emit(sp, msg, Some(code), lvl);\n+    }\n+\n+    pub fn custom_emit(&self, sp: RenderSpan, msg: &str, lvl: Level) {\n+        if lvl == Warning && !self.can_emit_warnings { return }\n+        self.emit.borrow_mut().custom_emit(sp, msg, lvl);\n+    }\n+}\n+\n+\n+#[derive(Copy, PartialEq, Clone, Debug)]\n+pub enum Level {\n+    Bug,\n+    Fatal,\n+    Error,\n+    Warning,\n+    Note,\n+    Help,\n+}\n+\n+impl fmt::Display for Level {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use std::fmt::Display;\n+\n+        match *self {\n+            Bug => \"error: internal compiler error\".fmt(f),\n+            Fatal | Error => \"error\".fmt(f),\n+            Warning => \"warning\".fmt(f),\n+            Note => \"note\".fmt(f),\n+            Help => \"help\".fmt(f),\n+        }\n+    }\n+}\n+\n+impl Level {\n+    fn color(self) -> term::color::Color {\n+        match self {\n+            Bug | Fatal | Error => term::color::BRIGHT_RED,\n+            Warning => term::color::BRIGHT_YELLOW,\n+            Note => term::color::BRIGHT_GREEN,\n+            Help => term::color::BRIGHT_CYAN,\n+        }\n+    }\n+}\n+\n+pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n+    M: FnOnce() -> String,\n+{\n+    match opt {\n+        Some(t) => t,\n+        None => diag.bug(&msg()),\n+    }\n+}"}, {"sha": "f198460137d5f78f070af026c1c63e66c45d90be", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -720,7 +720,7 @@ impl<'a> ExtCtxt<'a> {\n         self.parse_sess.span_diagnostic.fileline_help(sp, msg);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.handler().bug(msg);\n+        self.parse_sess.span_diagnostic.bug(msg);\n     }\n     pub fn trace_macros(&self) -> bool {\n         self.ecfg.trace_mac"}, {"sha": "46a39b98058a2382a9387b9849edb1407a60ec20", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -14,7 +14,6 @@ use ast;\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n-use owned_slice::OwnedSlice;\n use parse::token::special_idents;\n use parse::token::InternedString;\n use parse::token;\n@@ -56,7 +55,7 @@ pub trait AstBuilder {\n \n     fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty>;\n     fn ty_path(&self, ast::Path) -> P<ast::Ty>;\n-    fn ty_sum(&self, ast::Path, OwnedSlice<ast::TyParamBound>) -> P<ast::Ty>;\n+    fn ty_sum(&self, ast::Path, ast::TyParamBounds) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n     fn ty_rptr(&self, span: Span,\n@@ -70,13 +69,13 @@ pub trait AstBuilder {\n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n \n-    fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n-    fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars_global(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> ;\n \n     fn typaram(&self,\n                span: Span,\n                id: ast::Ident,\n-               bounds: OwnedSlice<ast::TyParamBound>,\n+               bounds: ast::TyParamBounds,\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n@@ -331,8 +330,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             identifier: last_identifier,\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n-                types: OwnedSlice::from_vec(types),\n-                bindings: OwnedSlice::from_vec(bindings),\n+                types: P::from_vec(types),\n+                bindings: P::from_vec(bindings),\n             })\n         });\n         ast::Path {\n@@ -369,8 +368,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             identifier: ident,\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n-                types: OwnedSlice::from_vec(types),\n-                bindings: OwnedSlice::from_vec(bindings),\n+                types: P::from_vec(types),\n+                bindings: P::from_vec(bindings),\n             })\n         });\n \n@@ -399,7 +398,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(path.span, ast::TyPath(None, path))\n     }\n \n-    fn ty_sum(&self, path: ast::Path, bounds: OwnedSlice<ast::TyParamBound>) -> P<ast::Ty> {\n+    fn ty_sum(&self, path: ast::Path, bounds: ast::TyParamBounds) -> P<ast::Ty> {\n         self.ty(path.span,\n                 ast::TyObjectSum(self.ty_path(path),\n                                  bounds))\n@@ -448,7 +447,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn typaram(&self,\n                span: Span,\n                id: ast::Ident,\n-               bounds: OwnedSlice<ast::TyParamBound>,\n+               bounds: ast::TyParamBounds,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n             ident: id,\n@@ -462,11 +461,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> {\n+    fn ty_vars(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> {\n         ty_params.iter().map(|p| self.ty_ident(DUMMY_SP, p.ident)).collect()\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> {\n+    fn ty_vars_global(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> {\n         ty_params\n             .iter()\n             .map(|p| self.ty_path(self.path_global(DUMMY_SP, vec!(p.ident))))"}, {"sha": "743bcda18def441507ef0cd3a3f1ca4a2995b32e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -1301,7 +1301,7 @@ pub fn expand_crate(mut cx: ExtCtxt,\n \n         let mut ret = expander.fold_crate(c);\n         ret.exported_macros = expander.cx.exported_macros.clone();\n-        cx.parse_sess.span_diagnostic.handler().abort_if_errors();\n+        cx.parse_sess.span_diagnostic.abort_if_errors();\n         ret\n     };\n     return (ret, cx.syntax_env.names);"}, {"sha": "8878c606d6a2c80a0c4b86b1d956adf50511308d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -12,7 +12,7 @@ use self::LockstepIterSize::*;\n use ast;\n use ast::{TokenTree, Ident, Name};\n use codemap::{Span, DUMMY_SP};\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n use parse::token::{Token, NtIdent, SpecialMacroVar};\n@@ -34,7 +34,7 @@ struct TtFrame {\n \n #[derive(Clone)]\n pub struct TtReader<'a> {\n-    pub sp_diag: &'a SpanHandler,\n+    pub sp_diag: &'a Handler,\n     /// the unzipped tree:\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n@@ -55,7 +55,7 @@ pub struct TtReader<'a> {\n /// This can do Macro-By-Example transcription. On the other hand, if\n /// `src` contains no `TokenTree::Sequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n-pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n+pub fn new_tt_reader<'a>(sp_diag: &'a Handler,\n                          interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                          imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree>)\n@@ -69,7 +69,7 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n /// This can do Macro-By-Example transcription. On the other hand, if\n /// `src` contains no `TokenTree::Sequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n-pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a SpanHandler,\n+pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a Handler,\n                                        interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                                        imported_from: Option<Ident>,\n                                        src: Vec<ast::TokenTree>,"}, {"sha": "89f318d09451b8b56c4890ce54bc9346ee1e525a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -32,7 +32,7 @@ use ast;\n use attr;\n use attr::AttrMetaMethods;\n use codemap::{CodeMap, Span};\n-use diagnostic::SpanHandler;\n+use errors::Handler;\n use visit;\n use visit::{FnKind, Visitor};\n use parse::token::InternedString;\n@@ -446,7 +446,7 @@ impl PartialOrd for GatedCfgAttr {\n }\n \n impl GatedCfgAttr {\n-    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    pub fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n         match *self {\n             GatedCfgAttr::GatedCfg(ref cfg) => {\n                 cfg.check_and_emit(diagnostic, features);\n@@ -476,7 +476,7 @@ impl GatedCfg {\n                       }\n                   })\n     }\n-    fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    fn check_and_emit(&self, diagnostic: &Handler, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n         if !has_feature(features) {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n@@ -595,21 +595,21 @@ const EXPLAIN_PUSHPOP_UNSAFE: &'static str =\n const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n     \"attributes on non-item statements and expressions are experimental.\";\n \n-pub fn check_for_box_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_box_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_box: true, .. }) = f {\n         return;\n     }\n     emit_feature_err(diag, \"box_syntax\", span, GateIssue::Language, EXPLAIN_BOX_SYNTAX);\n }\n \n-pub fn check_for_placement_in(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_placement_in(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_placement_in: true, .. }) = f {\n         return;\n     }\n     emit_feature_err(diag, \"placement_in_syntax\", span, GateIssue::Language, EXPLAIN_PLACEMENT_IN);\n }\n \n-pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n     if let Some(&Features { allow_pushpop_unsafe: true, .. }) = f {\n         return;\n     }\n@@ -618,7 +618,7 @@ pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &SpanHandler, span:\n \n struct Context<'a> {\n     features: Vec<&'static str>,\n-    span_handler: &'a SpanHandler,\n+    span_handler: &'a Handler,\n     cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n }\n@@ -704,7 +704,7 @@ pub enum GateIssue {\n     Library(Option<u32>)\n }\n \n-pub fn emit_feature_err(diag: &SpanHandler, feature: &str, span: Span, issue: GateIssue,\n+pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIssue,\n                         explain: &str) {\n     let issue = match issue {\n         GateIssue::Language => find_lang_feature_issue(feature),\n@@ -1064,7 +1064,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n }\n \n-fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n+fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n                         krate: &ast::Crate,\n                         plugin_attributes: &[(String, AttributeType)],\n                         check: F)\n@@ -1161,13 +1161,13 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n     }\n }\n \n-pub fn check_crate_macros(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate)\n+pub fn check_crate_macros(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate)\n -> Features {\n     check_crate_inner(cm, span_handler, krate, &[] as &'static [_],\n                       |ctx, krate| visit::walk_crate(&mut MacroVisitor { context: ctx }, krate))\n }\n \n-pub fn check_crate(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::Crate,\n+pub fn check_crate(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate,\n                    plugin_attributes: &[(String, AttributeType)],\n                    unstable: UnstableFeatures) -> Features\n {\n@@ -1192,7 +1192,7 @@ pub enum UnstableFeatures {\n     Cheat\n }\n \n-fn maybe_stage_features(span_handler: &SpanHandler, krate: &ast::Crate,\n+fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n                         unstable: UnstableFeatures) {\n     let allow_features = match unstable {\n         UnstableFeatures::Allow => true,"}, {"sha": "cd2210c71b89539c3420f305fccebe6c323f8664", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -23,7 +23,6 @@ use ast;\n use attr::{ThinAttributes, ThinAttributesExt};\n use ast_util;\n use codemap::{respan, Span, Spanned};\n-use owned_slice::OwnedSlice;\n use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n@@ -233,7 +232,7 @@ pub trait Folder : Sized {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: OwnedSlice<TyParam>) -> OwnedSlice<TyParam> {\n+    fn fold_ty_params(&mut self, tps: P<[TyParam]>) -> P<[TyParam]> {\n         noop_fold_ty_params(tps, self)\n     }\n \n@@ -257,13 +256,13 @@ pub trait Folder : Sized {\n         noop_fold_opt_lifetime(o_lt, self)\n     }\n \n-    fn fold_opt_bounds(&mut self, b: Option<OwnedSlice<TyParamBound>>)\n-                       -> Option<OwnedSlice<TyParamBound>> {\n+    fn fold_opt_bounds(&mut self, b: Option<TyParamBounds>)\n+                       -> Option<TyParamBounds> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>)\n-                       -> OwnedSlice<TyParamBound> {\n+    fn fold_bounds(&mut self, b: TyParamBounds)\n+                       -> TyParamBounds {\n         noop_fold_bounds(b, self)\n     }\n \n@@ -714,8 +713,8 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>, fld: &mut T)\n-                                      -> OwnedSlice<TyParam> {\n+pub fn noop_fold_ty_params<T: Folder>(tps: P<[TyParam]>, fld: &mut T)\n+                                      -> P<[TyParam]> {\n     tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n \n@@ -871,8 +870,8 @@ pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutT\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n-                                       -> Option<OwnedSlice<TyParamBound>> {\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>, folder: &mut T)\n+                                       -> Option<TyParamBounds> {\n     b.map(|bounds| folder.fold_bounds(bounds))\n }\n "}, {"sha": "47340d312242b2b0d220baf7821874dc93f85fae", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -52,7 +52,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use diagnostic::FatalError;\n+        use errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(FatalError) => panic!(FatalError)\n@@ -78,6 +78,8 @@ pub mod diagnostics {\n     pub mod metadata;\n }\n \n+pub mod errors;\n+\n pub mod syntax {\n     pub use ext;\n     pub use parse;\n@@ -90,7 +92,6 @@ pub mod ast_util;\n pub mod attr;\n pub mod codemap;\n pub mod config;\n-pub mod diagnostic;\n pub mod entry;\n pub mod feature_gate;\n pub mod fold;"}, {"sha": "33a3d5785981ae50f55b9708fecef54b0e9331f2", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 4, "deletions": 97, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -8,100 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::default::Default;\n-use std::fmt;\n-use std::iter::{IntoIterator, FromIterator};\n-use std::ops::Deref;\n-use std::slice;\n-use std::vec;\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n-/// A non-growable owned slice. This is a separate type to allow the\n-/// representation to change.\n-#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct OwnedSlice<T> {\n-    data: Box<[T]>\n-}\n-\n-impl<T:fmt::Debug> fmt::Debug for OwnedSlice<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        self.data.fmt(fmt)\n-    }\n-}\n-\n-impl<T> OwnedSlice<T> {\n-    pub fn empty() -> OwnedSlice<T> {\n-        OwnedSlice  { data: Box::new([]) }\n-    }\n-\n-    #[inline(never)]\n-    pub fn from_vec(v: Vec<T>) -> OwnedSlice<T> {\n-        OwnedSlice { data: v.into_boxed_slice() }\n-    }\n-\n-    #[inline(never)]\n-    pub fn into_vec(self) -> Vec<T> {\n-        self.data.into_vec()\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        &*self.data\n-    }\n-\n-    pub fn move_iter(self) -> vec::IntoIter<T> {\n-        self.into_vec().into_iter()\n-    }\n-\n-    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> OwnedSlice<U> {\n-        self.iter().map(f).collect()\n-    }\n-}\n-\n-impl<T> Deref for OwnedSlice<T> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-impl<T> Default for OwnedSlice<T> {\n-    fn default() -> OwnedSlice<T> {\n-        OwnedSlice::empty()\n-    }\n-}\n-\n-impl<T: Clone> Clone for OwnedSlice<T> {\n-    fn clone(&self) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(self.to_vec())\n-    }\n-}\n-\n-impl<T> FromIterator<T> for OwnedSlice<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(iter.into_iter().collect())\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a OwnedSlice<T> {\n-    type Item = &'a T;\n-    type IntoIter = slice::Iter<'a, T>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.data.into_iter()\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for OwnedSlice<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&**self, s)\n-    }\n-}\n-\n-impl<T: Decodable> Decodable for OwnedSlice<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<OwnedSlice<T>, D::Error> {\n-        Ok(OwnedSlice::from_vec(match Decodable::decode(d) {\n-            Ok(t) => t,\n-            Err(e) => return Err(e)\n-        }))\n-    }\n-}\n+/// A non-growable owned slice.\n+#[unstable(feature = \"rustc_private\", issue = \"0\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"use `ptr::P<[T]>` instead\")]\n+pub type OwnedSlice<T> = ::ptr::P<[T]>;"}, {"sha": "d2156d7cb68d25ae45b0420eb608b359ebe71ba7", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -12,7 +12,7 @@ pub use self::CommentStyle::*;\n \n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n-use diagnostic;\n+use errors;\n use parse::lexer::is_block_doc_comment;\n use parse::lexer::{StringReader, TokenAndSpan};\n use parse::lexer::{is_whitespace, Reader};\n@@ -334,7 +334,7 @@ pub struct Literal {\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(span_diagnostic: &diagnostic::SpanHandler,\n+pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n                                     path: String,\n                                     srdr: &mut Read)\n                                  -> (Vec<Comment>, Vec<Literal>) {"}, {"sha": "4619410ada7274c44cefe8f08032684bff346d78", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -11,8 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n-use diagnostic::FatalError;\n-use diagnostic::SpanHandler;\n+use errors::{FatalError, Handler};\n use ext::tt::transcribe::tt_next_token;\n use parse::token::str_to_ident;\n use parse::token;\n@@ -58,7 +57,7 @@ pub struct TokenAndSpan {\n }\n \n pub struct StringReader<'a> {\n-    pub span_diagnostic: &'a SpanHandler,\n+    pub span_diagnostic: &'a Handler,\n     /// The absolute offset within the codemap of the next character to read\n     pub pos: BytePos,\n     /// The absolute offset within the codemap of the last character read(curr)\n@@ -128,10 +127,10 @@ impl<'a> Reader for TtReader<'a> {\n \n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into pos and curr\n-    pub fn new_raw<'b>(span_diagnostic: &'b SpanHandler,\n+    pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n                        filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n         if filemap.src.is_none() {\n-            span_diagnostic.handler.bug(&format!(\"Cannot lex filemap without source: {}\",\n+            span_diagnostic.bug(&format!(\"Cannot lex filemap without source: {}\",\n                                                  filemap.name)[..]);\n         }\n \n@@ -153,7 +152,7 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n-    pub fn new<'b>(span_diagnostic: &'b SpanHandler,\n+    pub fn new<'b>(span_diagnostic: &'b Handler,\n                    filemap: Rc<codemap::FileMap>) -> StringReader<'b> {\n         let mut sr = StringReader::new_raw(span_diagnostic, filemap);\n         sr.advance_token();\n@@ -1423,28 +1422,30 @@ mod tests {\n     use super::*;\n \n     use codemap::{BytePos, CodeMap, Span, NO_EXPANSION};\n-    use diagnostic;\n+    use errors;\n     use parse::token;\n     use parse::token::{str_to_ident};\n     use std::io;\n+    use std::rc::Rc;\n \n-    fn mk_sh() -> diagnostic::SpanHandler {\n+    fn mk_sh(cm: Rc<CodeMap>) -> errors::Handler {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-        let emitter = diagnostic::EmitterWriter::new(Box::new(io::sink()), None);\n-        let handler = diagnostic::Handler::with_emitter(true, Box::new(emitter));\n-        diagnostic::SpanHandler::new(handler, CodeMap::new())\n+        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()), None, cm);\n+        errors::Handler::with_emitter(true, false, Box::new(emitter))\n     }\n \n     // open a string reader for the given string\n-    fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n+    fn setup<'a>(cm: &CodeMap,\n+                 span_handler: &'a errors::Handler,\n                  teststr: String) -> StringReader<'a> {\n-        let fm = span_handler.cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n+        let fm = cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n         StringReader::new(span_handler, fm)\n     }\n \n     #[test] fn t1 () {\n-        let span_handler = mk_sh();\n-        let mut string_reader = setup(&span_handler,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut string_reader = setup(&cm, &sh,\n             \"/* my source file */ \\\n              fn main() { println!(\\\"zebra\\\"); }\\n\".to_string());\n         let id = str_to_ident(\"fn\");\n@@ -1482,70 +1483,90 @@ mod tests {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        check_tokenization(setup(&mk_sh(), \"a b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                            vec![mk_ident(\"a\", token::Plain),\n                                 token::Whitespace,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n-        check_tokenization(setup(&mk_sh(), \"a::b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                            vec![mk_ident(\"a\",token::ModName),\n                                 token::ModSep,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n-        check_tokenization(setup(&mk_sh(), \"a ::b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                            vec![mk_ident(\"a\", token::Plain),\n                                 token::Whitespace,\n                                 token::ModSep,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n-        check_tokenization(setup(&mk_sh(), \"a:: b\".to_string()),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                            vec![mk_ident(\"a\",token::ModName),\n                                 token::ModSep,\n                                 token::Whitespace,\n                                 mk_ident(\"b\", token::Plain)]);\n     }\n \n     #[test] fn character_a() {\n-        assert_eq!(setup(&mk_sh(), \"'a'\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\"a\")), None));\n     }\n \n     #[test] fn character_space() {\n-        assert_eq!(setup(&mk_sh(), \"' '\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\" \")), None));\n     }\n \n     #[test] fn character_escaped() {\n-        assert_eq!(setup(&mk_sh(), \"'\\\\n'\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(token::intern(\"\\\\n\")), None));\n     }\n \n     #[test] fn lifetime_name() {\n-        assert_eq!(setup(&mk_sh(), \"'abc\".to_string()).next_token().tok,\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                    token::Lifetime(token::str_to_ident(\"'abc\")));\n     }\n \n     #[test] fn raw_string() {\n-        assert_eq!(setup(&mk_sh(),\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        assert_eq!(setup(&cm, &sh,\n                          \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token()\n                                                                  .tok,\n                    token::Literal(token::StrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n     }\n \n     #[test] fn literal_suffixes() {\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n-                assert_eq!(setup(&mk_sh(), format!(\"{}suffix\", $input)).next_token().tok,\n+                assert_eq!(setup(&cm, &sh, format!(\"{}suffix\", $input)).next_token().tok,\n                            token::Literal(token::$tok_type(token::intern($tok_contents)),\n                                           Some(token::intern(\"suffix\"))));\n                 // with a whitespace separator:\n-                assert_eq!(setup(&mk_sh(), format!(\"{} suffix\", $input)).next_token().tok,\n+                assert_eq!(setup(&cm, &sh, format!(\"{} suffix\", $input)).next_token().tok,\n                            token::Literal(token::$tok_type(token::intern($tok_contents)),\n                                           None));\n             }}\n@@ -1561,13 +1582,13 @@ mod tests {\n         test!(\"1.0\", Float, \"1.0\");\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n-        assert_eq!(setup(&mk_sh(), \"2us\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"2us\".to_string()).next_token().tok,\n                    token::Literal(token::Integer(token::intern(\"2\")),\n                                   Some(token::intern(\"us\"))));\n-        assert_eq!(setup(&mk_sh(), \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n-        assert_eq!(setup(&mk_sh(), \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n+        assert_eq!(setup(&cm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::ByteStrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n     }\n@@ -1579,8 +1600,9 @@ mod tests {\n     }\n \n     #[test] fn nested_block_comments() {\n-        let sh = mk_sh();\n-        let mut lexer = setup(&sh, \"/* /* */ */'a'\".to_string());\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n         match lexer.next_token().tok {\n             token::Comment => { },\n             _ => panic!(\"expected a comment!\")\n@@ -1589,8 +1611,9 @@ mod tests {\n     }\n \n     #[test] fn crlf_comments() {\n-        let sh = mk_sh();\n-        let mut lexer = setup(&sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n+        let cm = Rc::new(CodeMap::new());\n+        let sh = mk_sh(cm.clone());\n+        let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();\n         assert_eq!(comment.tok, token::Comment);\n         assert_eq!(comment.sp, ::codemap::mk_sp(BytePos(0), BytePos(7)));"}, {"sha": "cff106f838af234c8b72591e313986b141853f78", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -12,7 +12,7 @@\n \n use ast;\n use codemap::{self, Span, CodeMap, FileMap};\n-use diagnostic::{SpanHandler, Handler, Auto, FatalError};\n+use errors::{Handler, ColorConfig, FatalError};\n use parse::parser::Parser;\n use parse::token::InternedString;\n use ptr::P;\n@@ -40,26 +40,29 @@ pub mod obsolete;\n \n /// Info about a parsing session.\n pub struct ParseSess {\n-    pub span_diagnostic: SpanHandler, // better be the same as the one in the reader!\n+    pub span_diagnostic: Handler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: RefCell<Vec<PathBuf>>,\n+    code_map: Rc<CodeMap>,\n }\n \n impl ParseSess {\n     pub fn new() -> ParseSess {\n-        let handler = SpanHandler::new(Handler::new(Auto, None, true), CodeMap::new());\n-        ParseSess::with_span_handler(handler)\n+        let cm = Rc::new(CodeMap::new());\n+        let handler = Handler::new(ColorConfig::Auto, None, true, false, cm.clone());\n+        ParseSess::with_span_handler(handler, cm)\n     }\n \n-    pub fn with_span_handler(sh: SpanHandler) -> ParseSess {\n+    pub fn with_span_handler(handler: Handler, code_map: Rc<CodeMap>) -> ParseSess {\n         ParseSess {\n-            span_diagnostic: sh,\n-            included_mod_stack: RefCell::new(vec![])\n+            span_diagnostic: handler,\n+            included_mod_stack: RefCell::new(vec![]),\n+            code_map: code_map\n         }\n     }\n \n     pub fn codemap(&self) -> &CodeMap {\n-        &self.span_diagnostic.cm\n+        &self.code_map\n     }\n }\n \n@@ -235,7 +238,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             let msg = format!(\"couldn't read {:?}: {}\", path.display(), e);\n             match spanopt {\n                 Some(sp) => panic!(sess.span_diagnostic.span_fatal(sp, &msg)),\n-                None => panic!(sess.span_diagnostic.handler().fatal(&msg))\n+                None => panic!(sess.span_diagnostic.fatal(&msg))\n             }\n         }\n     }\n@@ -438,7 +441,7 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n }\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n-                      sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+                      sd: &Handler, sp: Span) -> ast::Lit_ {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n     match suffix.as_ref().map(|s| &**s) {\n         Some(\"f32\") => ast::LitFloat(data, ast::TyF32),\n@@ -459,7 +462,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n     }\n }\n pub fn float_lit(s: &str, suffix: Option<InternedString>,\n-                 sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n+                 sd: &Handler, sp: Span) -> ast::Lit_ {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -561,7 +564,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n \n pub fn integer_lit(s: &str,\n                    suffix: Option<InternedString>,\n-                   sd: &SpanHandler,\n+                   sd: &Handler,\n                    sp: Span)\n                    -> ast::Lit_ {\n     // s can only be ascii, byte indexing is fine\n@@ -668,7 +671,6 @@ mod tests {\n     use super::*;\n     use std::rc::Rc;\n     use codemap::{Span, BytePos, Pos, Spanned, NO_EXPANSION};\n-    use owned_slice::OwnedSlice;\n     use ast::{self, TokenTree};\n     use abi;\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n@@ -944,7 +946,7 @@ mod tests {\n                                     abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n-                                        ty_params: OwnedSlice::empty(),\n+                                        ty_params: P::empty(),\n                                         where_clause: ast::WhereClause {\n                                             id: ast::DUMMY_NODE_ID,\n                                             predicates: Vec::new(),"}, {"sha": "5dba1e189ab156dcb8ca3c0a65c17a01ad883de7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -66,10 +66,9 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n         }\n \n         if !self.obsolete_set.contains(&kind) &&\n-            (error || self.sess.span_diagnostic.handler().can_emit_warnings) {\n+            (error || self.sess.span_diagnostic.can_emit_warnings) {\n             self.sess\n                 .span_diagnostic\n-                .handler()\n                 .note(&format!(\"{}\", desc));\n             self.obsolete_set.insert(kind);\n         }"}, {"sha": "ebfcf8c5180cf6454ff133d3902c6d4aca29e058", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -50,7 +50,7 @@ use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{Ty, Ty_, TypeBinding, TyMac};\n use ast::{TyFixedLengthVec, TyBareFn, TyTypeof, TyInfer};\n-use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPtr};\n+use ast::{TyParam, TyParamBounds, TyParen, TyPath, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec};\n use ast::TypeTraitItem;\n use ast::{UnnamedField, UnsafeBlock};\n@@ -60,7 +60,7 @@ use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n-use diagnostic;\n+use errors::{self, FatalError};\n use ext::tt::macro_parser;\n use parse;\n use parse::classify;\n@@ -73,9 +73,7 @@ use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n-use owned_slice::OwnedSlice;\n use parse::PResult;\n-use diagnostic::FatalError;\n \n use std::collections::HashSet;\n use std::io::prelude::*;\n@@ -752,7 +750,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_before_gt_or_return<T, F>(&mut self,\n                                                   sep: Option<token::Token>,\n                                                   mut f: F)\n-                                                  -> PResult<(OwnedSlice<T>, bool)> where\n+                                                  -> PResult<(P<[T]>, bool)> where\n         F: FnMut(&mut Parser) -> PResult<Option<T>>,\n     {\n         let mut v = Vec::new();\n@@ -773,7 +771,7 @@ impl<'a> Parser<'a> {\n             if i % 2 == 0 {\n                 match try!(f(self)) {\n                     Some(result) => v.push(result),\n-                    None => return Ok((OwnedSlice::from_vec(v), true))\n+                    None => return Ok((P::from_vec(v), true))\n                 }\n             } else {\n                 if let Some(t) = sep.as_ref() {\n@@ -782,15 +780,15 @@ impl<'a> Parser<'a> {\n \n             }\n         }\n-        return Ok((OwnedSlice::from_vec(v), false));\n+        return Ok((P::from_vec(v), false));\n     }\n \n     /// Parse a sequence bracketed by '<' and '>', stopping\n     /// before the '>'.\n     pub fn parse_seq_to_before_gt<T, F>(&mut self,\n                                         sep: Option<token::Token>,\n                                         mut f: F)\n-                                        -> PResult<OwnedSlice<T>> where\n+                                        -> PResult<P<[T]>> where\n         F: FnMut(&mut Parser) -> PResult<T>,\n     {\n         let (result, returned) = try!(self.parse_seq_to_before_gt_or_return(sep,\n@@ -802,7 +800,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt<T, F>(&mut self,\n                                  sep: Option<token::Token>,\n                                  f: F)\n-                                 -> PResult<OwnedSlice<T>> where\n+                                 -> PResult<P<[T]>> where\n         F: FnMut(&mut Parser) -> PResult<T>,\n     {\n         let v = try!(self.parse_seq_to_before_gt(sep, f));\n@@ -813,7 +811,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt_or_return<T, F>(&mut self,\n                                            sep: Option<token::Token>,\n                                            f: F)\n-                                           -> PResult<(OwnedSlice<T>, bool)> where\n+                                           -> PResult<(P<[T]>, bool)> where\n         F: FnMut(&mut Parser) -> PResult<Option<T>>,\n     {\n         let (v, returned) = try!(self.parse_seq_to_before_gt_or_return(sep, f));\n@@ -983,16 +981,16 @@ impl<'a> Parser<'a> {\n         }\n         f(&self.buffer[((self.buffer_start + dist - 1) & 3) as usize].tok)\n     }\n-    pub fn fatal(&self, m: &str) -> diagnostic::FatalError {\n+    pub fn fatal(&self, m: &str) -> errors::FatalError {\n         self.sess.span_diagnostic.span_fatal(self.span, m)\n     }\n-    pub fn span_fatal(&self, sp: Span, m: &str) -> diagnostic::FatalError {\n+    pub fn span_fatal(&self, sp: Span, m: &str) -> errors::FatalError {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> diagnostic::FatalError {\n+    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> errors::FatalError {\n         self.span_err(sp, m);\n         self.fileline_help(sp, help);\n-        diagnostic::FatalError\n+        errors::FatalError\n     }\n     pub fn span_note(&self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n@@ -1022,7 +1020,7 @@ impl<'a> Parser<'a> {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n     pub fn abort_if_errors(&self) {\n-        self.sess.span_diagnostic.handler().abort_if_errors();\n+        self.sess.span_diagnostic.abort_if_errors();\n     }\n \n     pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n@@ -1077,7 +1075,7 @@ impl<'a> Parser<'a> {\n             let other_bounds = if try!(self.eat(&token::BinOp(token::Plus)) ){\n                 try!(self.parse_ty_param_bounds(BoundParsingMode::Bare))\n             } else {\n-                OwnedSlice::empty()\n+                P::empty()\n             };\n             let all_bounds =\n                 Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n@@ -1710,8 +1708,8 @@ impl<'a> Parser<'a> {\n \n                 ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n-                    types: OwnedSlice::from_vec(types),\n-                    bindings: OwnedSlice::from_vec(bindings),\n+                    types: P::from_vec(types),\n+                    bindings: P::from_vec(bindings),\n                 })\n             } else if try!(self.eat(&token::OpenDelim(token::Paren)) ){\n                 let lo = self.last_span.lo;\n@@ -1774,8 +1772,8 @@ impl<'a> Parser<'a> {\n                     identifier: identifier,\n                     parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n-                        types: OwnedSlice::from_vec(types),\n-                        bindings: OwnedSlice::from_vec(bindings),\n+                        types: P::from_vec(types),\n+                        bindings: P::from_vec(bindings),\n                     }),\n                 });\n \n@@ -3883,10 +3881,10 @@ impl<'a> Parser<'a> {\n     // otherwise returns empty list.\n     fn parse_colon_then_ty_param_bounds(&mut self,\n                                         mode: BoundParsingMode)\n-                                        -> PResult<OwnedSlice<TyParamBound>>\n+                                        -> PResult<TyParamBounds>\n     {\n         if !try!(self.eat(&token::Colon) ){\n-            Ok(OwnedSlice::empty())\n+            Ok(P::empty())\n         } else {\n             self.parse_ty_param_bounds(mode)\n         }\n@@ -3898,7 +3896,7 @@ impl<'a> Parser<'a> {\n     // and     bound     = 'region | trait_ref\n     fn parse_ty_param_bounds(&mut self,\n                              mode: BoundParsingMode)\n-                             -> PResult<OwnedSlice<TyParamBound>>\n+                             -> PResult<TyParamBounds>\n     {\n         let mut result = vec!();\n         loop {\n@@ -3940,7 +3938,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Ok(OwnedSlice::from_vec(result));\n+        return Ok(P::from_vec(result));\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?"}, {"sha": "1f296dc5d59bd6e83153106d57e0423d1cd6e9a5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -17,10 +17,9 @@ use ast::Attribute;\n use attr::ThinAttributesExt;\n use util::parser::AssocOp;\n use attr;\n-use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{self, CodeMap, BytePos};\n-use diagnostic;\n+use errors;\n use parse::token::{self, BinOpToken, Token, InternedString};\n use parse::lexer::comments;\n use parse;\n@@ -99,7 +98,7 @@ pub const DEFAULT_COLUMNS: usize = 78;\n /// it can scan the input text for comments and literals to\n /// copy forward.\n pub fn print_crate<'a>(cm: &'a CodeMap,\n-                       span_diagnostic: &diagnostic::SpanHandler,\n+                       span_diagnostic: &errors::Handler,\n                        krate: &ast::Crate,\n                        filename: String,\n                        input: &mut Read,\n@@ -139,7 +138,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n-                          span_diagnostic: &diagnostic::SpanHandler,\n+                          span_diagnostic: &errors::Handler,\n                           filename: String,\n                           input: &mut Read,\n                           out: Box<Write+'a>,\n@@ -1001,7 +1000,7 @@ impl<'a> State<'a> {\n             ast::TyBareFn(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty(),\n+                    ty_params: P::empty(),\n                     where_clause: ast::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n                         predicates: Vec::new(),\n@@ -3024,7 +3023,7 @@ impl<'a> State<'a> {\n         }\n         let generics = ast::Generics {\n             lifetimes: Vec::new(),\n-            ty_params: OwnedSlice::empty(),\n+            ty_params: P::empty(),\n             where_clause: ast::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),"}, {"sha": "1be0b08086d9ce830028441184dc1ee43a285ce7", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 88, "deletions": 18, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -37,14 +37,15 @@\n //!   Moreover, a switch to, e.g. `P<'a, T>` would be easy and mostly automated.\n \n use std::fmt::{self, Display, Debug};\n-use std::hash::{Hash, Hasher};\n+use std::iter::FromIterator;\n use std::ops::Deref;\n-use std::ptr;\n+use std::{ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// An owned smart pointer.\n-pub struct P<T> {\n+#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }\n \n@@ -92,14 +93,6 @@ impl<T: 'static + Clone> Clone for P<T> {\n     }\n }\n \n-impl<T: PartialEq> PartialEq for P<T> {\n-    fn eq(&self, other: &P<T>) -> bool {\n-        **self == **other\n-    }\n-}\n-\n-impl<T: Eq> Eq for P<T> {}\n-\n impl<T: Debug> Debug for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Debug::fmt(&**self, f)\n@@ -111,19 +104,12 @@ impl<T: Display> Display for P<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Pointer for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n \n-impl<T: Hash> Hash for P<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state);\n-    }\n-}\n-\n impl<T: 'static + Decodable> Decodable for P<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n         Decodable::decode(d).map(P)\n@@ -135,3 +121,87 @@ impl<T: Encodable> Encodable for P<T> {\n         (**self).encode(s)\n     }\n }\n+\n+\n+impl<T:fmt::Debug> fmt::Debug for P<[T]> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        self.ptr.fmt(fmt)\n+    }\n+}\n+\n+impl<T> P<[T]> {\n+    pub fn empty() -> P<[T]> {\n+        P { ptr: Default::default() }\n+    }\n+\n+    #[inline(never)]\n+    pub fn from_vec(v: Vec<T>) -> P<[T]> {\n+        P { ptr: v.into_boxed_slice() }\n+    }\n+\n+    #[inline(never)]\n+    pub fn into_vec(self) -> Vec<T> {\n+        self.ptr.into_vec()\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        &*self.ptr\n+    }\n+\n+    pub fn move_iter(self) -> vec::IntoIter<T> {\n+        self.into_vec().into_iter()\n+    }\n+\n+    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> P<[U]> {\n+        self.iter().map(f).collect()\n+    }\n+}\n+\n+impl<T> Deref for P<[T]> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+impl<T> Default for P<[T]> {\n+    fn default() -> P<[T]> {\n+        P::empty()\n+    }\n+}\n+\n+impl<T: Clone> Clone for P<[T]> {\n+    fn clone(&self) -> P<[T]> {\n+        P::from_vec(self.to_vec())\n+    }\n+}\n+\n+impl<T> FromIterator<T> for P<[T]> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> P<[T]> {\n+        P::from_vec(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a P<[T]> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.ptr.into_iter()\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for P<[T]> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        Encodable::encode(&**self, s)\n+    }\n+}\n+\n+impl<T: Decodable> Decodable for P<[T]> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n+        Ok(P::from_vec(match Decodable::decode(d) {\n+            Ok(t) => t,\n+            Err(e) => return Err(e)\n+        }))\n+    }\n+}"}, {"sha": "014c7b2a68f4f36935f96b38b726a1e6086d82c0", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -16,7 +16,7 @@\n use std::str::FromStr;\n \n use ast;\n-use diagnostic;\n+use errors;\n use visit;\n use visit::Visitor;\n \n@@ -40,7 +40,7 @@ impl FromStr for Mode {\n }\n \n struct ShowSpanVisitor<'a> {\n-    span_diagnostic: &'a diagnostic::SpanHandler,\n+    span_diagnostic: &'a errors::Handler,\n     mode: Mode,\n }\n \n@@ -71,7 +71,7 @@ impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n     }\n }\n \n-pub fn run(span_diagnostic: &diagnostic::SpanHandler,\n+pub fn run(span_diagnostic: &errors::Handler,\n            mode: &str,\n            krate: &ast::Crate) {\n     let mode = match mode.parse().ok() {"}, {"sha": "9a6d1f8fdab4dd3170c57c63370b8a9733fceb91", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -23,7 +23,7 @@ use attr::AttrMetaMethods;\n use attr;\n use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n-use diagnostic;\n+use errors;\n use config;\n use entry::{self, EntryPointType};\n use ext::base::ExtCtxt;\n@@ -32,7 +32,6 @@ use ext::expand::ExpansionConfig;\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n-use owned_slice::OwnedSlice;\n use parse::token::{intern, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n@@ -55,7 +54,7 @@ struct Test {\n \n struct TestCtxt<'a> {\n     sess: &'a ParseSess,\n-    span_diagnostic: &'a diagnostic::SpanHandler,\n+    span_diagnostic: &'a errors::Handler,\n     path: Vec<ast::Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n@@ -72,7 +71,7 @@ struct TestCtxt<'a> {\n pub fn modify_for_testing(sess: &ParseSess,\n                           cfg: &ast::CrateConfig,\n                           krate: ast::Crate,\n-                          span_diagnostic: &diagnostic::SpanHandler) -> ast::Crate {\n+                          span_diagnostic: &errors::Handler) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n@@ -275,7 +274,7 @@ fn generate_test_harness(sess: &ParseSess,\n                          reexport_test_harness_main: Option<InternedString>,\n                          krate: ast::Crate,\n                          cfg: &ast::CrateConfig,\n-                         sd: &diagnostic::SpanHandler) -> ast::Crate {\n+                         sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n@@ -315,7 +314,7 @@ fn generate_test_harness(sess: &ParseSess,\n     return res;\n }\n \n-fn strip_test_functions(diagnostic: &diagnostic::SpanHandler, krate: ast::Crate)\n+fn strip_test_functions(diagnostic: &errors::Handler, krate: ast::Crate)\n                         -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n@@ -688,7 +687,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n         Some(id) => vec![id],\n         None => {\n             let diag = cx.span_diagnostic;\n-            diag.handler.bug(\"expected to find top-level re-export name, but found None\");\n+            diag.bug(\"expected to find top-level re-export name, but found None\");\n         }\n     };\n     visible_path.extend(path);"}, {"sha": "e1078b719bf0679f07c4a64be63f6b817e556a42", "filename": "src/libsyntax/util/move_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Futil%2Fmove_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax%2Futil%2Fmove_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fmove_map.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use owned_slice::OwnedSlice;\n-\n use std::ptr;\n \n pub trait MoveMap<T>: Sized {\n@@ -69,11 +67,11 @@ impl<T> MoveMap<T> for Vec<T> {\n     }\n }\n \n-impl<T> MoveMap<T> for OwnedSlice<T> {\n+impl<T> MoveMap<T> for ::ptr::P<[T]> {\n     fn move_flat_map<F, I>(self, f: F) -> Self\n         where F: FnMut(T) -> I,\n               I: IntoIterator<Item=T>\n     {\n-        OwnedSlice::from_vec(self.into_vec().move_flat_map(f))\n+        ::ptr::P::from_vec(self.into_vec().move_flat_map(f))\n     }\n }"}, {"sha": "8f316649421a6511a6e2e1e1ae26ece5aadb8398", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -203,9 +203,8 @@ use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, DUMMY_SP};\n use syntax::codemap::Span;\n-use syntax::diagnostic::SpanHandler;\n+use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{intern, InternedString};\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n@@ -516,7 +515,7 @@ impl<'a> TraitDef<'a> {\n \n             cx.typaram(self.span,\n                        ty_param.ident,\n-                       OwnedSlice::from_vec(bounds),\n+                       P::from_vec(bounds),\n                        None)\n         }));\n \n@@ -528,7 +527,7 @@ impl<'a> TraitDef<'a> {\n                         span: self.span,\n                         bound_lifetimes: wb.bound_lifetimes.clone(),\n                         bounded_ty: wb.bounded_ty.clone(),\n-                        bounds: OwnedSlice::from_vec(wb.bounds.iter().cloned().collect())\n+                        bounds: P::from_vec(wb.bounds.iter().cloned().collect())\n                     })\n                 }\n                 ast::WherePredicate::RegionPredicate(ref rb) => {\n@@ -579,7 +578,7 @@ impl<'a> TraitDef<'a> {\n                         span: self.span,\n                         bound_lifetimes: vec![],\n                         bounded_ty: ty,\n-                        bounds: OwnedSlice::from_vec(bounds),\n+                        bounds: P::from_vec(bounds),\n                     };\n \n                     let predicate = ast::WherePredicate::BoundPredicate(predicate);\n@@ -590,7 +589,7 @@ impl<'a> TraitDef<'a> {\n \n         let trait_generics = Generics {\n             lifetimes: lifetimes,\n-            ty_params: OwnedSlice::from_vec(ty_params),\n+            ty_params: P::from_vec(ty_params),\n             where_clause: where_clause\n         };\n \n@@ -742,7 +741,7 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn find_repr_type_name(diagnostic: &SpanHandler,\n+fn find_repr_type_name(diagnostic: &Handler,\n                        type_attrs: &[ast::Attribute]) -> &'static str {\n     let mut repr_type_name = \"i32\";\n     for a in type_attrs {"}, {"sha": "10564b5f6985b7c407b2c05a9b4b9b758ed288f5", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -19,7 +19,6 @@ use syntax::ast::{Expr,Generics,Ident};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{Span,respan};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n \n@@ -209,7 +208,7 @@ fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n                -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n-        ty_params: OwnedSlice::from_vec(ty_params),\n+        ty_params: P::from_vec(ty_params),\n         where_clause: ast::WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),"}, {"sha": "01dc9662588bfab02877dee362ad170fa407ec99", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -39,7 +39,7 @@ use syntax::parse::token::intern;\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use syntax::diagnostic::FatalError;\n+        use syntax::errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(FatalError) => panic!(FatalError)"}, {"sha": "be34028fe1d013540acee5efe3d0e9c40e87371e", "filename": "src/test/run-make/emit/Makefile", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-make%2Femit%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-make%2Femit%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Femit%2FMakefile?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -0,0 +1,15 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) -Copt-level=0 --emit=llvm-bc,llvm-ir,asm,obj,link test-24876.rs\n+\t$(RUSTC) -Copt-level=1 --emit=llvm-bc,llvm-ir,asm,obj,link test-24876.rs\n+\t$(RUSTC) -Copt-level=2 --emit=llvm-bc,llvm-ir,asm,obj,link test-24876.rs\n+\t$(RUSTC) -Copt-level=3 --emit=llvm-bc,llvm-ir,asm,obj,link test-24876.rs\n+\t$(RUSTC) -Copt-level=0 --emit=llvm-bc,llvm-ir,asm,obj,link test-26235.rs\n+\t$(call RUN,test-26235) || exit 1\n+\t$(RUSTC) -Copt-level=1 --emit=llvm-bc,llvm-ir,asm,obj,link test-26235.rs\n+\t$(call RUN,test-26235) || exit 1\n+\t$(RUSTC) -Copt-level=2 --emit=llvm-bc,llvm-ir,asm,obj,link test-26235.rs\n+\t$(call RUN,test-26235) || exit 1\n+\t$(RUSTC) -Copt-level=3 --emit=llvm-bc,llvm-ir,asm,obj,link test-26235.rs\n+\t$(call RUN,test-26235) || exit 1"}, {"sha": "ab69decbf007e7f36d58887a49a022f94b2e3f2c", "filename": "src/test/run-make/emit/test-24876.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-make%2Femit%2Ftest-24876.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-make%2Femit%2Ftest-24876.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Femit%2Ftest-24876.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks for issue #24876\n+\n+fn main() {\n+    let mut v = 0;\n+    for i in 0..0 {\n+        v += i;\n+    }\n+    println!(\"{}\", v)\n+}"}, {"sha": "97b58a3671bf3531224cdcec425adcc6eb92f4f5", "filename": "src/test/run-make/emit/test-26235.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-make%2Femit%2Ftest-26235.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-make%2Femit%2Ftest-26235.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Femit%2Ftest-26235.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks for issue #26235\n+\n+fn main() {\n+    use std::thread;\n+\n+    type Key = u32;\n+    const NUM_THREADS: usize = 2;\n+\n+    #[derive(Clone,Copy)]\n+    struct Stats<S> {\n+        upsert: S,\n+        delete: S,\n+        insert: S,\n+        update: S\n+    };\n+\n+    impl<S> Stats<S> where S: Copy {\n+        fn dot<B, F, T>(self, s: Stats<T>, f: F) -> Stats<B> where F: Fn(S, T) -> B {\n+            let Stats { upsert: u1, delete: d1, insert: i1, update: p1 } = self;\n+            let Stats { upsert: u2, delete: d2, insert: i2, update: p2 } = s;\n+            Stats { upsert: f(u1, u2), delete: f(d1, d2), insert: f(i1, i2), update: f(p1, p2) }\n+        }\n+\n+        fn new(init: S) -> Self {\n+            Stats { upsert: init, delete: init, insert: init, update: init }\n+        }\n+    }\n+\n+    fn make_threads() -> Vec<thread::JoinHandle<()>> {\n+        let mut t = Vec::with_capacity(NUM_THREADS);\n+        for _ in 0..NUM_THREADS {\n+            t.push(thread::spawn(move || {}));\n+        }\n+        t\n+    }\n+\n+    let stats = [Stats::new(0); NUM_THREADS];\n+    make_threads();\n+\n+    {\n+        let Stats { ref upsert, ref delete, ref insert, ref update } = stats.iter().fold(\n+            Stats::new(0), |res, &s| res.dot(s, |x: Key, y: Key| x.wrapping_add(y)));\n+        println!(\"upserts: {}, deletes: {}, inserts: {}, updates: {}\",\n+                 upsert, delete, insert, update);\n+    }\n+}"}, {"sha": "7c1a45d020b22d61c84a280965eeffd773b31e3e", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -44,7 +44,7 @@ fn with_error_checking_parse<T, F>(s: String, f: F) -> PResult<T> where\n     let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);\n \n-    if ps.span_diagnostic.handler().has_errors() || p.token != token::Eof {\n+    if ps.span_diagnostic.has_errors() || p.token != token::Eof {\n         return Err(p.fatal(\"parse error\"));\n     }\n "}, {"sha": "e3eeeb863568800949e95c08d3bbe57d9910d2ef", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33916307780495fe311fe9c080b330d266f35bfb/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=33916307780495fe311fe9c080b330d266f35bfb", "patch": "@@ -23,7 +23,7 @@ extern crate syntax;\n use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n-use syntax::{diagnostics, diagnostic};\n+use syntax::{diagnostics, errors};\n \n use std::path::PathBuf;\n \n@@ -35,7 +35,7 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn early_callback(&mut self,\n                       _: &getopts::Matches,\n                       _: &diagnostics::registry::Registry,\n-                      _: diagnostic::ColorConfig)\n+                      _: errors::emitter::ColorConfig)\n                       -> Compilation {\n         self.count *= 2;\n         Compilation::Continue"}]}