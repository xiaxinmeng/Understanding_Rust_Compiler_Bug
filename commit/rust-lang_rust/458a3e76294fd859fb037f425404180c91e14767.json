{"sha": "458a3e76294fd859fb037f425404180c91e14767", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OGEzZTc2Mjk0ZmQ4NTlmYjAzN2Y0MjU0MDQxODBjOTFlMTQ3Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-22T01:32:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-22T01:32:42Z"}, "message": "Auto merge of #71956 - ecstatic-morse:remove-requires-storage-analysis, r=tmandry\n\nClean up logic around live locals in generator analysis\n\nResolves #69902. Requires #71893.\n\nI've found it difficult to make changes in the logic around live locals in `generator/transform.rs`. It uses a custom dataflow analysis, `MaybeRequiresStorage`, that AFAICT computes whether a local is either initialized or borrowed. That analysis is using `before` effects, which we should try to avoid if possible because they are harder to reason about than ones only using the unprefixed effects. @pnkfelix has suggested removing \"before\" effects entirely to simplify the dataflow framework, which I might pursue someday.\n\nThis PR replaces `MaybeRequiresStorage` with a combination of the existing `MaybeBorrowedLocals` and a new `MaybeInitializedLocals`. `MaybeInitializedLocals` is just `MaybeInitializedPlaces` with a coarser resolution: it works on whole locals instead of move paths. As a result, I was able to simplify the logic in `compute_storage_conflicts` and `locals_live_across_suspend_points`.\n\nThis is not exactly equivalent to the old logic; some generators are now smaller than before. I believe this was because the old logic was too conservative, but I'm not as familiar with the constraints as the original implementers were, so I could be wrong. For example, I don't see a reason the size of the `mixed_sizes` future couldn't be 5K. It went from 7K to 6K in this PR.\n\nr? @jonas-schievink @tmandry", "tree": {"sha": "58dbb752d8ca9a64c3fe9362bd92dfdba89c0183", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58dbb752d8ca9a64c3fe9362bd92dfdba89c0183"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/458a3e76294fd859fb037f425404180c91e14767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/458a3e76294fd859fb037f425404180c91e14767", "html_url": "https://github.com/rust-lang/rust/commit/458a3e76294fd859fb037f425404180c91e14767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/458a3e76294fd859fb037f425404180c91e14767/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9417b385145af1cabd0be8a95c65075d2fc30ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9417b385145af1cabd0be8a95c65075d2fc30ff", "html_url": "https://github.com/rust-lang/rust/commit/d9417b385145af1cabd0be8a95c65075d2fc30ff"}, {"sha": "3ff93177cf7976c1db072cdcb4bc3f23e5f6b78c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff93177cf7976c1db072cdcb4bc3f23e5f6b78c", "html_url": "https://github.com/rust-lang/rust/commit/3ff93177cf7976c1db072cdcb4bc3f23e5f6b78c"}], "stats": {"total": 626, "additions": 254, "deletions": 372}, "files": [{"sha": "b61dc56407eb923a5fa6705f274d0ac9bf586b6d", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=458a3e76294fd859fb037f425404180c91e14767", "patch": "@@ -99,6 +99,9 @@ impl<K> GenKillAnalysis<'tcx> for MaybeBorrowedLocals<K>\n where\n     K: BorrowAnalysisKind<'tcx>,\n {\n+    // The generator transform relies on the fact that this analysis does **not** use \"before\"\n+    // effects.\n+\n     fn statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,"}, {"sha": "726330b1f035e35677b31d458cafabdd172f1272", "filename": "src/librustc_mir/dataflow/impls/init_locals.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Finit_locals.rs?ref=458a3e76294fd859fb037f425404180c91e14767", "patch": "@@ -0,0 +1,118 @@\n+//! A less precise version of `MaybeInitializedPlaces` whose domain is entire locals.\n+//!\n+//! A local will be maybe initialized if *any* projections of that local might be initialized.\n+\n+use crate::dataflow::{self, BottomValue, GenKill};\n+\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::visit::{PlaceContext, Visitor};\n+use rustc_middle::mir::{self, BasicBlock, Local, Location};\n+\n+pub struct MaybeInitializedLocals;\n+\n+impl BottomValue for MaybeInitializedLocals {\n+    /// bottom = uninit\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+impl dataflow::AnalysisDomain<'tcx> for MaybeInitializedLocals {\n+    type Idx = Local;\n+\n+    const NAME: &'static str = \"maybe_init_locals\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n+    }\n+\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, entry_set: &mut BitSet<Self::Idx>) {\n+        // Function arguments are initialized to begin with.\n+        for arg in body.args_iter() {\n+            entry_set.insert(arg);\n+        }\n+    }\n+}\n+\n+impl dataflow::GenKillAnalysis<'tcx> for MaybeInitializedLocals {\n+    // The generator transform relies on the fact that this analysis does **not** use \"before\"\n+    // effects.\n+\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        TransferFunction { trans }.visit_statement(statement, loc)\n+    }\n+\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        TransferFunction { trans }.visit_terminator(terminator, loc)\n+    }\n+\n+    fn call_return_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        return_place: mir::Place<'tcx>,\n+    ) {\n+        trans.gen(return_place.local)\n+    }\n+\n+    /// See `Analysis::apply_yield_resume_effect`.\n+    fn yield_resume_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _resume_block: BasicBlock,\n+        resume_place: mir::Place<'tcx>,\n+    ) {\n+        trans.gen(resume_place.local)\n+    }\n+}\n+\n+struct TransferFunction<'a, T> {\n+    trans: &'a mut T,\n+}\n+\n+impl<T> Visitor<'tcx> for TransferFunction<'a, T>\n+where\n+    T: GenKill<Local>,\n+{\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n+        use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, NonUseContext};\n+        match context {\n+            // These are handled specially in `call_return_effect` and `yield_resume_effect`.\n+            PlaceContext::MutatingUse(MutatingUseContext::Call | MutatingUseContext::Yield) => {}\n+\n+            // Otherwise, when a place is mutated, we must consider it possibly initialized.\n+            PlaceContext::MutatingUse(_) => self.trans.gen(local),\n+\n+            // If the local is moved out of, or if it gets marked `StorageDead`, consider it no\n+            // longer initialized.\n+            PlaceContext::NonUse(NonUseContext::StorageDead)\n+            | PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => self.trans.kill(local),\n+\n+            // All other uses do not affect this analysis.\n+            PlaceContext::NonUse(\n+                NonUseContext::StorageLive\n+                | NonUseContext::AscribeUserTy\n+                | NonUseContext::VarDebugInfo,\n+            )\n+            | PlaceContext::NonMutatingUse(\n+                NonMutatingUseContext::Inspect\n+                | NonMutatingUseContext::Copy\n+                | NonMutatingUseContext::SharedBorrow\n+                | NonMutatingUseContext::ShallowBorrow\n+                | NonMutatingUseContext::UniqueBorrow\n+                | NonMutatingUseContext::AddressOf\n+                | NonMutatingUseContext::Projection,\n+            ) => {}\n+        }\n+    }\n+}"}, {"sha": "ed01d6b01ea4316afb9d7a1d3fc154fcb3cbac21", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=458a3e76294fd859fb037f425404180c91e14767", "patch": "@@ -22,13 +22,15 @@ use crate::dataflow::drop_flag_effects;\n \n mod borrowed_locals;\n pub(super) mod borrows;\n+mod init_locals;\n mod liveness;\n mod storage_liveness;\n \n pub use self::borrowed_locals::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n pub use self::borrows::Borrows;\n+pub use self::init_locals::MaybeInitializedLocals;\n pub use self::liveness::MaybeLiveLocals;\n-pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};\n+pub use self::storage_liveness::MaybeStorageLive;\n \n /// `MaybeInitializedPlaces` tracks all places that might be\n /// initialized upon reaching a particular point in the control flow"}, {"sha": "2a2be069b1ed8d433a94eb3a4af10d918655a792", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 233, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=458a3e76294fd859fb037f425404180c91e14767", "patch": "@@ -1,11 +1,9 @@\n pub use super::*;\n \n use crate::dataflow::BottomValue;\n-use crate::dataflow::{self, GenKill, Results, ResultsRefCursor};\n+use crate::dataflow::{self, GenKill};\n use crate::util::storage::AlwaysLiveLocals;\n-use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n-use std::cell::RefCell;\n \n #[derive(Clone)]\n pub struct MaybeStorageLive {\n@@ -78,233 +76,3 @@ impl BottomValue for MaybeStorageLive {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n-\n-type BorrowedLocalsResults<'a, 'tcx> = ResultsRefCursor<'a, 'a, 'tcx, MaybeBorrowedLocals>;\n-\n-/// Dataflow analysis that determines whether each local requires storage at a\n-/// given location; i.e. whether its storage can go away without being observed.\n-pub struct MaybeRequiresStorage<'mir, 'tcx> {\n-    body: &'mir Body<'tcx>,\n-    borrowed_locals: RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n-}\n-\n-impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n-    pub fn new(\n-        body: &'mir Body<'tcx>,\n-        borrowed_locals: &'mir Results<'tcx, MaybeBorrowedLocals>,\n-    ) -> Self {\n-        MaybeRequiresStorage {\n-            body,\n-            borrowed_locals: RefCell::new(ResultsRefCursor::new(&body, borrowed_locals)),\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> dataflow::AnalysisDomain<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n-    type Idx = Local;\n-\n-    const NAME: &'static str = \"requires_storage\";\n-\n-    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n-        body.local_decls.len()\n-    }\n-\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n-        // The resume argument is live on function entry (we don't care about\n-        // the `self` argument)\n-        for arg in body.args_iter().skip(1) {\n-            on_entry.insert(arg);\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tcx> {\n-    fn before_statement_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        stmt: &mir::Statement<'tcx>,\n-        loc: Location,\n-    ) {\n-        // If a place is borrowed in a statement, it needs storage for that statement.\n-        self.borrowed_locals.borrow().analysis().statement_effect(trans, stmt, loc);\n-\n-        match &stmt.kind {\n-            StatementKind::StorageDead(l) => trans.kill(*l),\n-\n-            // If a place is assigned to in a statement, it needs storage for that statement.\n-            StatementKind::Assign(box (place, _))\n-            | StatementKind::SetDiscriminant { box place, .. } => {\n-                trans.gen(place.local);\n-            }\n-            StatementKind::LlvmInlineAsm(asm) => {\n-                for place in &*asm.outputs {\n-                    trans.gen(place.local);\n-                }\n-            }\n-\n-            // Nothing to do for these. Match exhaustively so this fails to compile when new\n-            // variants are added.\n-            StatementKind::AscribeUserType(..)\n-            | StatementKind::FakeRead(..)\n-            | StatementKind::Nop\n-            | StatementKind::Retag(..)\n-            | StatementKind::StorageLive(..) => {}\n-        }\n-    }\n-\n-    fn statement_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _: &mir::Statement<'tcx>,\n-        loc: Location,\n-    ) {\n-        // If we move from a place then only stops needing storage *after*\n-        // that statement.\n-        self.check_for_move(trans, loc);\n-    }\n-\n-    fn before_terminator_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        terminator: &mir::Terminator<'tcx>,\n-        loc: Location,\n-    ) {\n-        // If a place is borrowed in a terminator, it needs storage for that terminator.\n-        self.borrowed_locals.borrow().analysis().terminator_effect(trans, terminator, loc);\n-\n-        match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n-                trans.gen(place.local);\n-            }\n-\n-            // Note that we do *not* gen the `resume_arg` of `Yield` terminators. The reason for\n-            // that is that a `yield` will return from the function, and `resume_arg` is written\n-            // only when the generator is later resumed. Unlike `Call`, this doesn't require the\n-            // place to have storage *before* the yield, only after.\n-            TerminatorKind::Yield { .. } => {}\n-\n-            TerminatorKind::InlineAsm { operands, .. } => {\n-                for op in operands {\n-                    match op {\n-                        InlineAsmOperand::Out { place, .. }\n-                        | InlineAsmOperand::InOut { out_place: place, .. } => {\n-                            if let Some(place) = place {\n-                                trans.gen(place.local);\n-                            }\n-                        }\n-                        InlineAsmOperand::In { .. }\n-                        | InlineAsmOperand::Const { .. }\n-                        | InlineAsmOperand::SymFn { .. }\n-                        | InlineAsmOperand::SymStatic { .. } => {}\n-                    }\n-                }\n-            }\n-\n-            // Nothing to do for these. Match exhaustively so this fails to compile when new\n-            // variants are added.\n-            TerminatorKind::Call { destination: None, .. }\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Assert { .. }\n-            | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n-            | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Goto { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Return\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Unreachable => {}\n-        }\n-    }\n-\n-    fn terminator_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        terminator: &mir::Terminator<'tcx>,\n-        loc: Location,\n-    ) {\n-        match &terminator.kind {\n-            // For call terminators the destination requires storage for the call\n-            // and after the call returns successfully, but not after a panic.\n-            // Since `propagate_call_unwind` doesn't exist, we have to kill the\n-            // destination here, and then gen it again in `call_return_effect`.\n-            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n-                trans.kill(place.local);\n-            }\n-\n-            // Nothing to do for these. Match exhaustively so this fails to compile when new\n-            // variants are added.\n-            TerminatorKind::Call { destination: None, .. }\n-            | TerminatorKind::Yield { .. }\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Assert { .. }\n-            | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n-            | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::GeneratorDrop\n-            | TerminatorKind::Goto { .. }\n-            | TerminatorKind::InlineAsm { .. }\n-            | TerminatorKind::Resume\n-            | TerminatorKind::Return\n-            | TerminatorKind::SwitchInt { .. }\n-            | TerminatorKind::Unreachable => {}\n-        }\n-\n-        self.check_for_move(trans, loc);\n-    }\n-\n-    fn call_return_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _block: BasicBlock,\n-        _func: &mir::Operand<'tcx>,\n-        _args: &[mir::Operand<'tcx>],\n-        return_place: mir::Place<'tcx>,\n-    ) {\n-        trans.gen(return_place.local);\n-    }\n-\n-    fn yield_resume_effect(\n-        &self,\n-        trans: &mut impl GenKill<Self::Idx>,\n-        _resume_block: BasicBlock,\n-        resume_place: mir::Place<'tcx>,\n-    ) {\n-        trans.gen(resume_place.local);\n-    }\n-}\n-\n-impl<'mir, 'tcx> MaybeRequiresStorage<'mir, 'tcx> {\n-    /// Kill locals that are fully moved and have not been borrowed.\n-    fn check_for_move(&self, trans: &mut impl GenKill<Local>, loc: Location) {\n-        let mut visitor = MoveVisitor { trans, borrowed_locals: &self.borrowed_locals };\n-        visitor.visit_location(&self.body, loc);\n-    }\n-}\n-\n-impl<'mir, 'tcx> BottomValue for MaybeRequiresStorage<'mir, 'tcx> {\n-    /// bottom = dead\n-    const BOTTOM_VALUE: bool = false;\n-}\n-\n-struct MoveVisitor<'a, 'mir, 'tcx, T> {\n-    borrowed_locals: &'a RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n-    trans: &'a mut T,\n-}\n-\n-impl<'a, 'mir, 'tcx, T> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx, T>\n-where\n-    T: GenKill<Local>,\n-{\n-    fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n-        if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n-            let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n-            borrowed_locals.seek_before_primary_effect(loc);\n-            if !borrowed_locals.contains(*local) {\n-                self.trans.kill(*local);\n-            }\n-        }\n-    }\n-}"}, {"sha": "5f8104e7934eb9253984f4221e2ef23477b8fa3f", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 127, "deletions": 136, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458a3e76294fd859fb037f425404180c91e14767/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=458a3e76294fd859fb037f425404180c91e14767", "patch": "@@ -50,7 +50,7 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::dataflow::impls::{\n-    MaybeBorrowedLocals, MaybeLiveLocals, MaybeRequiresStorage, MaybeStorageLive,\n+    MaybeBorrowedLocals, MaybeInitializedLocals, MaybeLiveLocals, MaybeStorageLive,\n };\n use crate::dataflow::{self, Analysis};\n use crate::transform::no_landing_pads::no_landing_pads;\n@@ -444,86 +444,80 @@ fn locals_live_across_suspend_points(\n     movable: bool,\n ) -> LivenessInfo {\n     let def_id = source.def_id();\n-    let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n     let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_engine(tcx, body, def_id)\n         .iterate_to_fixpoint()\n-        .into_results_cursor(body_ref);\n-\n-    // Calculate the MIR locals which have been previously\n-    // borrowed (even if they are still active).\n-    let borrowed_locals_results =\n-        MaybeBorrowedLocals::all_borrows().into_engine(tcx, body_ref, def_id).iterate_to_fixpoint();\n-\n-    let mut borrowed_locals_cursor =\n-        dataflow::ResultsCursor::new(body_ref, &borrowed_locals_results);\n-\n-    // Calculate the MIR locals that we actually need to keep storage around\n-    // for.\n-    let requires_storage_results = MaybeRequiresStorage::new(body, &borrowed_locals_results)\n-        .into_engine(tcx, body_ref, def_id)\n-        .iterate_to_fixpoint();\n-    let mut requires_storage_cursor =\n-        dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n-\n-    // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut liveness = MaybeLiveLocals\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_results_cursor(body);\n+\n+    let mut init = MaybeInitializedLocals\n+        .into_engine(tcx, body, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body);\n+\n+    let mut live = MaybeLiveLocals\n+        .into_engine(tcx, body, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body);\n+\n+    let mut borrowed = MaybeBorrowedLocals::all_borrows()\n+        .into_engine(tcx, body, def_id)\n         .iterate_to_fixpoint()\n-        .into_results_cursor(body_ref);\n+        .into_results_cursor(body);\n+\n+    // Liveness across yield points is determined by the following boolean equation, where `live`,\n+    // `init` and `borrowed` come from dataflow and `movable` is a property of the generator.\n+    // Movable generators do not allow borrows to live across yield points, so they don't need to\n+    // store a local simply because it is borrowed.\n+    //\n+    //    live_across_yield := (live & init) | (!movable & borrowed)\n+    //\n+    let mut locals_live_across_yield_point = |block| {\n+        live.seek_to_block_end(block);\n+        let mut live_locals = live.get().clone();\n+\n+        init.seek_to_block_end(block);\n+        live_locals.intersect(init.get());\n+\n+        if !movable {\n+            borrowed.seek_to_block_end(block);\n+            live_locals.union(borrowed.get());\n+        }\n+\n+        live_locals\n+    };\n \n     let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n     let mut live_locals_at_suspension_points = Vec::new();\n     let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n-        if let TerminatorKind::Yield { .. } = data.terminator().kind {\n-            let loc = Location { block, statement_index: data.statements.len() };\n-\n-            liveness.seek_to_block_end(block);\n-            let mut live_locals = liveness.get().clone();\n-\n-            if !movable {\n-                // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n-                // This is correct for movable generators since borrows cannot live across\n-                // suspension points. However for immovable generators we need to account for\n-                // borrows, so we conseratively assume that all borrowed locals are live until\n-                // we find a StorageDead statement referencing the locals.\n-                // To do this we just union our `liveness` result with `borrowed_locals`, which\n-                // contains all the locals which has been borrowed before this suspension point.\n-                // If a borrow is converted to a raw reference, we must also assume that it lives\n-                // forever. Note that the final liveness is still bounded by the storage liveness\n-                // of the local, which happens using the `intersect` operation below.\n-                borrowed_locals_cursor.seek_before_primary_effect(loc);\n-                live_locals.union(borrowed_locals_cursor.get());\n-            }\n-\n-            // Store the storage liveness for later use so we can restore the state\n-            // after a suspension point\n-            storage_live.seek_before_primary_effect(loc);\n-            storage_liveness_map[block] = Some(storage_live.get().clone());\n-\n-            // Locals live are live at this point only if they are used across\n-            // suspension points (the `liveness` variable)\n-            // and their storage is required (the `storage_required` variable)\n-            requires_storage_cursor.seek_before_primary_effect(loc);\n-            live_locals.intersect(requires_storage_cursor.get());\n+        if !matches!(data.terminator().kind, TerminatorKind::Yield { ..  }) {\n+            continue;\n+        }\n \n-            // The generator argument is ignored.\n-            live_locals.remove(SELF_ARG);\n+        // Store the storage liveness for later use so we can restore the state\n+        // after a suspension point\n+        storage_live.seek_to_block_end(block);\n+        storage_liveness_map[block] = Some(storage_live.get().clone());\n \n-            debug!(\"loc = {:?}, live_locals = {:?}\", loc, live_locals);\n+        let mut live_locals = locals_live_across_yield_point(block);\n \n-            // Add the locals live at this suspension point to the set of locals which live across\n-            // any suspension points\n-            live_locals_at_any_suspension_point.union(&live_locals);\n+        // The combination of `MaybeInitializedLocals` and `MaybeBorrowedLocals` should be strictly\n+        // more precise than `MaybeStorageLive` because they handle `StorageDead` themselves. This\n+        // assumes that the MIR forbids locals from being initialized/borrowed before reaching\n+        // `StorageLive`.\n+        debug_assert!(storage_live.get().superset(&live_locals));\n \n-            live_locals_at_suspension_points.push(live_locals);\n-        }\n+        // Ignore the generator's `self` argument since it is handled seperately.\n+        live_locals.remove(SELF_ARG);\n+        debug!(\"block = {:?}, live_locals = {:?}\", block, live_locals);\n+        live_locals_at_any_suspension_point.union(&live_locals);\n+        live_locals_at_suspension_points.push(live_locals);\n     }\n+\n     debug!(\"live_locals_anywhere = {:?}\", live_locals_at_any_suspension_point);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n@@ -534,10 +528,11 @@ fn locals_live_across_suspend_points(\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n-        body_ref,\n+        body,\n         &live_locals_at_any_suspension_point,\n         always_live_locals.clone(),\n-        requires_storage_results,\n+        init,\n+        borrowed,\n     );\n \n     LivenessInfo {\n@@ -569,6 +564,37 @@ fn renumber_bitset(\n     out\n }\n \n+/// Record conflicts between locals at the current dataflow cursor positions.\n+///\n+/// You need to seek the cursors before calling this function.\n+fn record_conflicts_at_curr_loc(\n+    local_conflicts: &mut BitMatrix<Local, Local>,\n+    init: &dataflow::ResultsCursor<'mir, 'tcx, MaybeInitializedLocals>,\n+    borrowed: &dataflow::ResultsCursor<'mir, 'tcx, MaybeBorrowedLocals>,\n+) {\n+    // A local requires storage if it is initialized or borrowed. For now, a local\n+    // becomes uninitialized if it is moved from, but is still considered \"borrowed\".\n+    //\n+    //     requires_storage := init | borrowed\n+    //\n+    // Just like when determining what locals are live at yield points, there is no need\n+    // to look at storage liveness here, since `init | borrowed` is strictly more precise.\n+    //\n+    // FIXME: This function is called in a loop, so it might be better to pass in a temporary\n+    // bitset rather than cloning here.\n+    let mut requires_storage = init.get().clone();\n+    requires_storage.union(borrowed.get());\n+\n+    for local in requires_storage.iter() {\n+        local_conflicts.union_row_with(&requires_storage, local);\n+    }\n+\n+    // `>1` because the `self` argument always requires storage.\n+    if requires_storage.count() > 1 {\n+        trace!(\"requires_storage={:?}\", requires_storage);\n+    }\n+}\n+\n /// For every saved local, looks for which locals are StorageLive at the same\n /// time. Generates a bitset for every local of all the other locals that may be\n /// StorageLive simultaneously with that local. This is used in the layout\n@@ -577,30 +603,45 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &BitSet<Local>,\n     always_live_locals: storage::AlwaysLiveLocals,\n-    requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n+    mut init: dataflow::ResultsCursor<'mir, 'tcx, MaybeInitializedLocals>,\n+    mut borrowed: dataflow::ResultsCursor<'mir, 'tcx, MaybeBorrowedLocals>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n-\n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n-    debug!(\"always_live = {:?}\", always_live_locals);\n-\n-    // Locals that are always live or ones that need to be stored across\n-    // suspension points are not eligible for overlap.\n-    let mut ineligible_locals = always_live_locals.into_inner();\n-    ineligible_locals.intersect(stored_locals);\n+    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n \n-    // Compute the storage conflicts for all eligible locals.\n-    let mut visitor = StorageConflictVisitor {\n-        body,\n-        stored_locals: &stored_locals,\n-        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n-    };\n+    // Locals that are always live conflict with all other locals.\n+    //\n+    // FIXME: Why do we need to handle locals without `Storage{Live,Dead}` specially here?\n+    // Shouldn't it be enough to know whether they are initialized?\n+    let always_live_locals = always_live_locals.into_inner();\n+    let mut local_conflicts = BitMatrix::from_row_n(&always_live_locals, body.local_decls.len());\n+\n+    // Visit every reachable statement and terminator. The exact order does not matter. When two\n+    // locals are live at the same point in time, add an entry in the conflict matrix.\n+    for (block, data) in traversal::preorder(body) {\n+        // Ignore unreachable blocks.\n+        if data.terminator().kind == TerminatorKind::Unreachable {\n+            continue;\n+        }\n \n-    // Visit only reachable basic blocks. The exact order is not important.\n-    let reachable_blocks = traversal::preorder(body).map(|(bb, _)| bb);\n-    requires_storage.visit_with(body, reachable_blocks, &mut visitor);\n+        // Observe the dataflow state *before* all possible locations (statement or terminator) in\n+        // each basic block...\n+        for statement_index in 0..=data.statements.len() {\n+            let loc = Location { block, statement_index };\n+            trace!(\"record conflicts at {:?}\", loc);\n+            init.seek_before_primary_effect(loc);\n+            borrowed.seek_before_primary_effect(loc);\n+            record_conflicts_at_curr_loc(&mut local_conflicts, &init, &borrowed);\n+        }\n \n-    let local_conflicts = visitor.local_conflicts;\n+        // ...and then observe the state *after* the terminator effect is applied. As long as\n+        // neither `init` nor `borrowed` has a \"before\" effect, we will observe all possible\n+        // dataflow states here or in the loop above.\n+        trace!(\"record conflicts at end of {:?}\", block);\n+        init.seek_to_block_end(block);\n+        borrowed.seek_to_block_end(block);\n+        record_conflicts_at_curr_loc(&mut local_conflicts, &init, &borrowed);\n+    }\n \n     // Compress the matrix using only stored locals (Local -> GeneratorSavedLocal).\n     //\n@@ -612,7 +653,7 @@ fn compute_storage_conflicts(\n     let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n     for (idx_a, local_a) in stored_locals.iter().enumerate() {\n         let saved_local_a = GeneratorSavedLocal::new(idx_a);\n-        if ineligible_locals.contains(local_a) {\n+        if always_live_locals.contains(local_a) {\n             // Conflicts with everything.\n             storage_conflicts.insert_all_into_row(saved_local_a);\n         } else {\n@@ -628,56 +669,6 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n-struct StorageConflictVisitor<'mir, 'tcx, 's> {\n-    body: &'mir Body<'tcx>,\n-    stored_locals: &'s BitSet<Local>,\n-    // FIXME(tmandry): Consider using sparse bitsets here once we have good\n-    // benchmarks for generators.\n-    local_conflicts: BitMatrix<Local, Local>,\n-}\n-\n-impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx, '_> {\n-    type FlowState = BitSet<Local>;\n-\n-    fn visit_statement_before_primary_effect(\n-        &mut self,\n-        state: &Self::FlowState,\n-        _statement: &'mir Statement<'tcx>,\n-        loc: Location,\n-    ) {\n-        self.apply_state(state, loc);\n-    }\n-\n-    fn visit_terminator_before_primary_effect(\n-        &mut self,\n-        state: &Self::FlowState,\n-        _terminator: &'mir Terminator<'tcx>,\n-        loc: Location,\n-    ) {\n-        self.apply_state(state, loc);\n-    }\n-}\n-\n-impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n-    fn apply_state(&mut self, flow_state: &BitSet<Local>, loc: Location) {\n-        // Ignore unreachable blocks.\n-        if self.body.basic_blocks()[loc.block].terminator().kind == TerminatorKind::Unreachable {\n-            return;\n-        }\n-\n-        let mut eligible_storage_live = flow_state.clone();\n-        eligible_storage_live.intersect(&self.stored_locals);\n-\n-        for local in eligible_storage_live.iter() {\n-            self.local_conflicts.union_row_with(&eligible_storage_live, local);\n-        }\n-\n-        if eligible_storage_live.count() > 1 {\n-            trace!(\"at {:?}, eligible_storage_live={:?}\", loc, eligible_storage_live);\n-        }\n-    }\n-}\n-\n fn compute_layout<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,"}, {"sha": "000acf14a3fbcf5cac85209afdb54e4568270730", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/458a3e76294fd859fb037f425404180c91e14767/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458a3e76294fd859fb037f425404180c91e14767/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=458a3e76294fd859fb037f425404180c91e14767", "patch": "@@ -114,5 +114,5 @@ fn main() {\n     assert_eq!(1026, std::mem::size_of_val(&single_with_noop()));\n     assert_eq!(3078, std::mem::size_of_val(&joined()));\n     assert_eq!(3079, std::mem::size_of_val(&joined_with_noop()));\n-    assert_eq!(7181, std::mem::size_of_val(&mixed_sizes()));\n+    assert_eq!(6157, std::mem::size_of_val(&mixed_sizes()));\n }"}, {"sha": "a5786c2999eb4ec231d99836f6dad318111a5824", "filename": "src/test/ui/generator/size-moved-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/458a3e76294fd859fb037f425404180c91e14767/src%2Ftest%2Fui%2Fgenerator%2Fsize-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/458a3e76294fd859fb037f425404180c91e14767/src%2Ftest%2Fui%2Fgenerator%2Fsize-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsize-moved-locals.rs?ref=458a3e76294fd859fb037f425404180c91e14767", "patch": "@@ -72,6 +72,6 @@ fn overlap_x_and_y() -> impl Generator<Yield = (), Return = ()> {\n fn main() {\n     assert_eq!(1025, std::mem::size_of_val(&move_before_yield()));\n     assert_eq!(1026, std::mem::size_of_val(&move_before_yield_with_noop()));\n-    assert_eq!(2051, std::mem::size_of_val(&overlap_move_points()));\n+    assert_eq!(1027, std::mem::size_of_val(&overlap_move_points()));\n     assert_eq!(1026, std::mem::size_of_val(&overlap_x_and_y()));\n }"}]}