{"sha": "b4def89d76896eec73b4af33642ba7e5eb53c567", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZGVmODlkNzY4OTZlZWM3M2I0YWYzMzY0MmJhN2U1ZWI1M2M1Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-03T02:00:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-03T02:00:46Z"}, "message": "Auto merge of #79637 - spastorino:revert-trait-inheritance-self, r=Mark-Simulacrum\n\nRevert \"Auto merge of #79209\n\nr? `@nikomatsakis`\n\nThis has caused some issues (#79560) so better to revert and try to come up with a proper fix without rush.", "tree": {"sha": "2ab62ff68117de489e0701a2806bfa202eac44da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ab62ff68117de489e0701a2806bfa202eac44da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4def89d76896eec73b4af33642ba7e5eb53c567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4def89d76896eec73b4af33642ba7e5eb53c567", "html_url": "https://github.com/rust-lang/rust/commit/b4def89d76896eec73b4af33642ba7e5eb53c567", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4def89d76896eec73b4af33642ba7e5eb53c567/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "html_url": "https://github.com/rust-lang/rust/commit/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb"}, {"sha": "37354ebc9794b0eb14b08c02177e3094c8fe91cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/37354ebc9794b0eb14b08c02177e3094c8fe91cd", "html_url": "https://github.com/rust-lang/rust/commit/37354ebc9794b0eb14b08c02177e3094c8fe91cd"}], "stats": {"total": 649, "additions": 151, "deletions": 498}, "files": [{"sha": "8273c2d291d096020ede192b4f10f6c7a2e257e0", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,10 +1,9 @@\n use smallvec::smallvec;\n \n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n-use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::{self, ToPredicate, TyCtxt, WithConstness};\n-use rustc_span::symbol::Ident;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -288,37 +287,6 @@ pub fn transitive_bounds<'tcx>(\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n-/// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n-/// define the given associated type `assoc_name`. It uses the\n-/// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n-/// aren't related to `assoc_item`.  This is used when resolving types like `Self::Item` or\n-/// `T::Item` and helps to avoid cycle errors (see e.g. #35237).\n-pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-    assoc_name: Ident,\n-) -> FxIndexSet<ty::PolyTraitRef<'tcx>> {\n-    let mut stack: Vec<_> = bounds.collect();\n-    let mut trait_refs = FxIndexSet::default();\n-\n-    while let Some(trait_ref) = stack.pop() {\n-        if trait_refs.insert(trait_ref) {\n-            let super_predicates =\n-                tcx.super_predicates_that_define_assoc_type((trait_ref.def_id(), Some(assoc_name)));\n-            for (super_predicate, _) in super_predicates.predicates {\n-                let bound_predicate = super_predicate.bound_atom();\n-                let subst_predicate = super_predicate\n-                    .subst_supertrait(tcx, &bound_predicate.rebind(trait_ref.skip_binder()));\n-                if let Some(binder) = subst_predicate.to_opt_poly_trait_ref() {\n-                    stack.push(binder.value);\n-                }\n-            }\n-        }\n-    }\n-\n-    trait_refs\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "7822ecc2c1f76f49fccee2c372bc2c7e9cc97acf", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -433,23 +433,12 @@ rustc_queries! {\n         /// full predicates are available (note that supertraits have\n         /// additional acyclicity requirements).\n         query super_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n-            desc { |tcx| \"computing the super predicates of `{}`\", tcx.def_path_str(key) }\n-        }\n-\n-        /// The `Option<Ident>` is the name of an associated type. If it is `None`, then this query\n-        /// returns the full set of predicates. If `Some<Ident>`, then the query returns only the\n-        /// subset of super-predicates that reference traits that define the given associated type.\n-        /// This is used to avoid cycles in resolving types like `T::Item`.\n-        query super_predicates_that_define_assoc_type(key: (DefId, Option<rustc_span::symbol::Ident>)) -> ty::GenericPredicates<'tcx> {\n-            desc { |tcx| \"computing the super traits of `{}`{}\",\n-                tcx.def_path_str(key.0),\n-                if let Some(assoc_name) = key.1 { format!(\" with associated type name `{}`\", assoc_name) } else { \"\".to_string() },\n-            }\n+            desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n         }\n \n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n-        query type_param_predicates(key: (DefId, LocalDefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n+        query type_param_predicates(key: (DefId, LocalDefId)) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n                 let id = tcx.hir().local_def_id_to_hir_id(key.1);\n                 tcx.hir().ty_param_name(id)"}, {"sha": "1b3416e112ba978576d8b397ded118a966730b65", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -51,7 +51,7 @@ use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n use rustc_span::source_map::MultiSpan;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n@@ -2066,42 +2066,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }))\n     }\n \n-    /// Given the def_id of a Trait `trait_def_id` and the name of an associated item `assoc_name`\n-    /// returns true if the `trait_def_id` defines an associated item of name `assoc_name`.\n-    pub fn trait_may_define_assoc_type(self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n-        self.super_traits_of(trait_def_id).any(|trait_did| {\n-            self.associated_items(trait_did)\n-                .find_by_name_and_kind(self, assoc_name, ty::AssocKind::Type, trait_did)\n-                .is_some()\n-        })\n-    }\n-\n-    /// Computes the def-ids of the transitive super-traits of `trait_def_id`. This (intentionally)\n-    /// does not compute the full elaborated super-predicates but just the set of def-ids. It is used\n-    /// to identify which traits may define a given associated type to help avoid cycle errors.\n-    /// Returns a `DefId` iterator.\n-    fn super_traits_of(self, trait_def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n-        let mut set = FxHashSet::default();\n-        let mut stack = vec![trait_def_id];\n-\n-        set.insert(trait_def_id);\n-\n-        iter::from_fn(move || -> Option<DefId> {\n-            let trait_did = stack.pop()?;\n-            let generic_predicates = self.super_predicates_of(trait_did);\n-\n-            for (predicate, _) in generic_predicates.predicates {\n-                if let ty::PredicateAtom::Trait(data, _) = predicate.skip_binders() {\n-                    if set.insert(data.def_id()) {\n-                        stack.push(data.def_id());\n-                    }\n-                }\n-            }\n-\n-            Some(trait_did)\n-        })\n-    }\n-\n     /// Given a closure signature, returns an equivalent fn signature. Detuples\n     /// and so forth -- so e.g., if we have a sig with `Fn<(u32, i32)>` then\n     /// you would get a `fn(u32, i32)`."}, {"sha": "a005990264cf11176443819ad7e8446804e15cb8", "filename": "compiler/rustc_middle/src/ty/query/keys.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -7,7 +7,7 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_query_system::query::DefaultCacheSelector;\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n /// The `Key` trait controls what types can legally be used as the key\n@@ -149,28 +149,6 @@ impl Key for (LocalDefId, DefId) {\n     }\n }\n \n-impl Key for (DefId, Option<Ident>) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        tcx.def_span(self.0)\n-    }\n-}\n-\n-impl Key for (DefId, LocalDefId, Ident) {\n-    type CacheSelector = DefaultCacheSelector;\n-\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        self.1.default_span(tcx)\n-    }\n-}\n-\n impl Key for (CrateNum, DefId) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "2fb9b3cd5d30547f03ac3d1ce6caa4cd744704f1", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -65,8 +65,7 @@ pub use self::util::{\n     get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n };\n pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n-    SupertraitDefIds, Supertraits,\n+    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };\n \n pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;"}, {"sha": "7888cb1b9f5991d47bdd79e92dd4d2959f7fc3f4", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 11, "deletions": 57, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -49,10 +49,9 @@ pub trait AstConv<'tcx> {\n \n     fn default_constness_for_trait_bounds(&self) -> Constness;\n \n-    /// Returns predicates in scope of the form `X: Foo<T>`, where `X`\n-    /// is a type parameter `X` with the given id `def_id` and T\n-    /// matches `assoc_name`. This is a subset of the full set of\n-    /// predicates.\n+    /// Returns predicates in scope of the form `X: Foo`, where `X` is\n+    /// a type parameter `X` with the given id `def_id`. This is a\n+    /// subset of the full set of predicates.\n     ///\n     /// This is used for one specific purpose: resolving \"short-hand\"\n     /// associated type references like `T::Item`. In principle, we\n@@ -61,12 +60,7 @@ pub trait AstConv<'tcx> {\n     /// but this can lead to cycle errors. The problem is that we have\n     /// to do this resolution *in order to create the predicates in\n     /// the first place*. Hence, we have this \"special pass\".\n-    fn get_type_parameter_bounds(\n-        &self,\n-        span: Span,\n-        def_id: DefId,\n-        assoc_name: Ident,\n-    ) -> ty::GenericPredicates<'tcx>;\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx>;\n \n     /// Returns the lifetime to use when a lifetime is omitted (and not elided).\n     fn re_infer(&self, param: Option<&ty::GenericParamDef>, span: Span)\n@@ -768,7 +762,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[&hir::GenericBound<'_>], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -826,7 +820,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[&hir::GenericBound<'_>],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n     ) {\n         let constness = self.default_constness_for_trait_bounds();\n@@ -841,7 +835,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n                 hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n                     .instantiate_lang_item_trait_ref(\n-                        *lang_item, *span, *hir_id, args, param_ty, bounds,\n+                        lang_item, span, hir_id, args, param_ty, bounds,\n                     ),\n                 hir::GenericBound::Outlives(ref l) => {\n                     bounds.region_bounds.push((self.ast_region_to_region(l, None), l.span))\n@@ -872,42 +866,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ast_bounds: &[hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n-    ) -> Bounds<'tcx> {\n-        let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n-        self.compute_bounds_inner(param_ty, &ast_bounds, sized_by_default, span)\n-    }\n-\n-    /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n-    /// named `assoc_name` into ty::Bounds. Ignore the rest.\n-    pub fn compute_bounds_that_match_assoc_type(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n-        assoc_name: Ident,\n-    ) -> Bounds<'tcx> {\n-        let mut result = Vec::new();\n-\n-        for ast_bound in ast_bounds {\n-            if let Some(trait_ref) = ast_bound.trait_ref() {\n-                if let Some(trait_did) = trait_ref.trait_def_id() {\n-                    if self.tcx().trait_may_define_assoc_type(trait_did, assoc_name) {\n-                        result.push(ast_bound);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.compute_bounds_inner(param_ty, &result, sized_by_default, span)\n-    }\n-\n-    fn compute_bounds_inner(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: &[&hir::GenericBound<'_>],\n-        sized_by_default: SizedByDefault,\n-        span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n@@ -1077,8 +1035,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_projection(assoc_ty.def_id, candidate.skip_binder().substs);\n-                let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n-                self.add_bounds(param_ty, &ast_bounds, bounds);\n+                self.add_bounds(param_ty, ast_bounds, bounds);\n             }\n         }\n         Ok(())\n@@ -1395,24 +1352,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty_param_def_id, assoc_name, span,\n         );\n \n-        let predicates = &self\n-            .get_type_parameter_bounds(span, ty_param_def_id.to_def_id(), assoc_name)\n-            .predicates;\n+        let predicates =\n+            &self.get_type_parameter_bounds(span, ty_param_def_id.to_def_id()).predicates;\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n         let param_hir_id = tcx.hir().local_def_id_to_hir_id(ty_param_def_id);\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(\n             || {\n-                traits::transitive_bounds_that_define_assoc_type(\n+                traits::transitive_bounds(\n                     tcx,\n                     predicates.iter().filter_map(|(p, _)| {\n                         p.to_opt_poly_trait_ref().map(|trait_ref| trait_ref.value)\n                     }),\n-                    assoc_name,\n                 )\n-                .into_iter()\n             },\n             || param_name.to_string(),\n             assoc_name,"}, {"sha": "f635e0b6f931c96c85250edbf142042700a10d5a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -20,7 +20,6 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::Session;\n-use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode};\n \n@@ -184,12 +183,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn get_type_parameter_bounds(\n-        &self,\n-        _: Span,\n-        def_id: DefId,\n-        _: Ident,\n-    ) -> ty::GenericPredicates<'tcx> {\n+    fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         let item_id = tcx.hir().ty_param_owner(hir_id);"}, {"sha": "0ff10abb60a357a5aff432be3631478bc1bca6cf", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 52, "deletions": 132, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -80,7 +79,6 @@ pub fn provide(providers: &mut Providers) {\n         projection_ty_from_predicates,\n         explicit_predicates_of,\n         super_predicates_of,\n-        super_predicates_that_define_assoc_type,\n         trait_explicit_predicates_and_bounds,\n         type_param_predicates,\n         trait_def,\n@@ -312,17 +310,8 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         }\n     }\n \n-    fn get_type_parameter_bounds(\n-        &self,\n-        span: Span,\n-        def_id: DefId,\n-        assoc_name: Ident,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.tcx.at(span).type_param_predicates((\n-            self.item_def_id,\n-            def_id.expect_local(),\n-            assoc_name,\n-        ))\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n+        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id.expect_local()))\n     }\n \n     fn re_infer(&self, _: Option<&ty::GenericParamDef>, _: Span) -> Option<ty::Region<'tcx>> {\n@@ -503,7 +492,7 @@ fn get_new_lifetime_name<'tcx>(\n /// `X: Foo` where `X` is the type parameter `def_id`.\n fn type_param_predicates(\n     tcx: TyCtxt<'_>,\n-    (item_def_id, def_id, assoc_name): (DefId, LocalDefId, Ident),\n+    (item_def_id, def_id): (DefId, LocalDefId),\n ) -> ty::GenericPredicates<'_> {\n     use rustc_hir::*;\n \n@@ -528,7 +517,7 @@ fn type_param_predicates(\n     let mut result = parent\n         .map(|parent| {\n             let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id(), assoc_name)\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id())\n         })\n         .unwrap_or_default();\n     let mut extend = None;\n@@ -571,18 +560,12 @@ fn type_param_predicates(\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n     let extra_predicates = extend.into_iter().chain(\n-        icx.type_parameter_bounds_in_generics(\n-            ast_generics,\n-            param_id,\n-            ty,\n-            OnlySelfBounds(true),\n-            Some(assoc_name),\n-        )\n-        .into_iter()\n-        .filter(|(predicate, _)| match predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(data, _) => data.self_ty().is_param(index),\n-            _ => false,\n-        }),\n+        icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n+            .into_iter()\n+            .filter(|(predicate, _)| match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(data, _) => data.self_ty().is_param(index),\n+                _ => false,\n+            }),\n     );\n     result.predicates =\n         tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(extra_predicates));\n@@ -600,7 +583,6 @@ impl ItemCtxt<'tcx> {\n         param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n-        assoc_name: Option<Ident>,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         let constness = self.default_constness_for_trait_bounds();\n         let from_ty_params = ast_generics\n@@ -611,10 +593,6 @@ impl ItemCtxt<'tcx> {\n                 _ => None,\n             })\n             .flat_map(|bounds| bounds.iter())\n-            .filter(|b| match assoc_name {\n-                Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n-                None => true,\n-            })\n             .flat_map(|b| predicates_from_bound(self, ty, b, constness));\n \n         let from_where_clauses = ast_generics\n@@ -633,34 +611,12 @@ impl ItemCtxt<'tcx> {\n                 } else {\n                     None\n                 };\n-                bp.bounds\n-                    .iter()\n-                    .filter(|b| match assoc_name {\n-                        Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n-                        None => true,\n-                    })\n-                    .filter_map(move |b| bt.map(|bt| (bt, b)))\n+                bp.bounds.iter().filter_map(move |b| bt.map(|bt| (bt, b)))\n             })\n             .flat_map(|(bt, b)| predicates_from_bound(self, bt, b, constness));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n-\n-    fn bound_defines_assoc_item(&self, b: &hir::GenericBound<'_>, assoc_name: Ident) -> bool {\n-        debug!(\"bound_defines_assoc_item(b={:?}, assoc_name={:?})\", b, assoc_name);\n-\n-        match b {\n-            hir::GenericBound::Trait(poly_trait_ref, _) => {\n-                let trait_ref = &poly_trait_ref.trait_ref;\n-                if let Some(trait_did) = trait_ref.trait_def_id() {\n-                    self.tcx.trait_may_define_assoc_type(trait_did, assoc_name)\n-                } else {\n-                    false\n-                }\n-            }\n-            _ => false,\n-        }\n-    }\n }\n \n /// Tests whether this is the AST for a reference to the type\n@@ -1029,90 +985,54 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    tcx.super_predicates_that_define_assoc_type((trait_def_id, None))\n-}\n-\n-/// Ensures that the super-predicates of the trait with a `DefId`\n-/// of `trait_def_id` are converted and stored. This also ensures that\n-/// the transitive super-predicates are converted.\n-fn super_predicates_that_define_assoc_type(\n-    tcx: TyCtxt<'_>,\n-    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n-) -> ty::GenericPredicates<'_> {\n-    debug!(\n-        \"super_predicates_that_define_assoc_type(trait_def_id={:?}, assoc_name={:?})\",\n-        trait_def_id, assoc_name\n-    );\n-    if trait_def_id.is_local() {\n-        debug!(\"super_predicates_that_define_assoc_type: local trait_def_id={:?}\", trait_def_id);\n-        let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n-\n-        let item = match tcx.hir().get(trait_hir_id) {\n-            Node::Item(item) => item,\n-            _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n-        };\n+    let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n \n-        let (generics, bounds) = match item.kind {\n-            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n-            _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n-        };\n-\n-        let icx = ItemCtxt::new(tcx, trait_def_id);\n+    let item = match tcx.hir().get(trait_hir_id) {\n+        Node::Item(item) => item,\n+        _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n+    };\n \n-        // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-        let self_param_ty = tcx.types.self_param;\n-        let superbounds1 = if let Some(assoc_name) = assoc_name {\n-            AstConv::compute_bounds_that_match_assoc_type(\n-                &icx,\n-                self_param_ty,\n-                &bounds,\n-                SizedByDefault::No,\n-                item.span,\n-                assoc_name,\n-            )\n-        } else {\n-            AstConv::compute_bounds(&icx, self_param_ty, &bounds, SizedByDefault::No, item.span)\n-        };\n+    let (generics, bounds) = match item.kind {\n+        hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n+        hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+        _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n+    };\n \n-        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+    let icx = ItemCtxt::new(tcx, trait_def_id);\n+\n+    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n+    let self_param_ty = tcx.types.self_param;\n+    let superbounds1 =\n+        AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n+\n+    let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+\n+    // Convert any explicit superbounds in the where-clause,\n+    // e.g., `trait Foo where Self: Bar`.\n+    // In the case of trait aliases, however, we include all bounds in the where-clause,\n+    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+    // as one of its \"superpredicates\".\n+    let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n+    let superbounds2 = icx.type_parameter_bounds_in_generics(\n+        generics,\n+        item.hir_id,\n+        self_param_ty,\n+        OnlySelfBounds(!is_trait_alias),\n+    );\n \n-        // Convert any explicit superbounds in the where-clause,\n-        // e.g., `trait Foo where Self: Bar`.\n-        // In the case of trait aliases, however, we include all bounds in the where-clause,\n-        // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-        // as one of its \"superpredicates\".\n-        let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n-        let superbounds2 = icx.type_parameter_bounds_in_generics(\n-            generics,\n-            item.hir_id,\n-            self_param_ty,\n-            OnlySelfBounds(!is_trait_alias),\n-            assoc_name,\n-        );\n+    // Combine the two lists to form the complete set of superbounds:\n+    let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n \n-        // Combine the two lists to form the complete set of superbounds:\n-        let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n-\n-        // Now require that immediate supertraits are converted,\n-        // which will, in turn, reach indirect supertraits.\n-        if assoc_name.is_none() {\n-            // FIXME: move this into the `super_predicates_of` query\n-            for &(pred, span) in superbounds {\n-                debug!(\"superbound: {:?}\", pred);\n-                if let ty::PredicateAtom::Trait(bound, _) = pred.skip_binders() {\n-                    tcx.at(span).super_predicates_of(bound.def_id());\n-                }\n-            }\n+    // Now require that immediate supertraits are converted,\n+    // which will, in turn, reach indirect supertraits.\n+    for &(pred, span) in superbounds {\n+        debug!(\"superbound: {:?}\", pred);\n+        if let ty::PredicateAtom::Trait(bound, _) = pred.skip_binders() {\n+            tcx.at(span).super_predicates_of(bound.def_id());\n         }\n-\n-        ty::GenericPredicates { parent: None, predicates: superbounds }\n-    } else {\n-        // if `assoc_name` is None, then the query should've been redirected to an\n-        // external provider\n-        assert!(assoc_name.is_some());\n-        tcx.super_predicates_of(trait_def_id)\n     }\n+\n+    ty::GenericPredicates { parent: None, predicates: superbounds }\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {"}, {"sha": "e596dd1a396c910d3c68ce292b139bed2c863b3b", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -28,7 +28,7 @@ fn associated_type_bounds<'tcx>(\n     let bounds = AstConv::compute_bounds(\n         &ItemCtxt::new(tcx, assoc_item_def_id),\n         item_ty,\n-        &bounds,\n+        bounds,\n         SizedByDefault::Yes,\n         span,\n     );\n@@ -68,7 +68,7 @@ fn opaque_type_bounds<'tcx>(\n         let bounds = AstConv::compute_bounds(\n             &ItemCtxt::new(tcx, opaque_def_id),\n             item_ty,\n-            &bounds,\n+            bounds,\n             SizedByDefault::Yes,\n             span,\n         )"}, {"sha": "03bb5eea765cc2315d5de099f74548125471cfac", "filename": "src/test/incremental/cyclic-trait-hierarchy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -3,11 +3,11 @@\n // revisions: rpass1 cfail2\n \n #[cfg(rpass1)]\n-pub trait T2 {}\n+pub trait T2 { }\n #[cfg(cfail2)]\n-pub trait T2: T1 {}\n-//[cfail2]~^ ERROR cycle detected when computing the super predicates of `T2`\n+pub trait T2: T1 { }\n+//[cfail2]~^ ERROR cycle detected when computing the supertraits of `T2`\n \n-pub trait T1: T2 {}\n+pub trait T1: T2 { }\n \n-fn main() {}\n+fn main() { }"}, {"sha": "1b6d6d0ff599f2ae8093f4c5f0276ebc9671cfea", "filename": "src/test/ui/associated-type-bounds/ambiguous-associated-type2.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,12 +0,0 @@\n-// ignore-tidy-linelength\n-\n-trait Foo {\n-    type Item;\n-}\n-trait Bar<T> {\n-    type Item;\n-}\n-trait Baz: Foo + Bar<Self::Item> {}\n-//~^ ERROR cycle detected when computing the super traits of `Baz` with associated type name `Item` [E0391]\n-\n-fn main() {}"}, {"sha": "bda1debeac0d6f7b8e4271036c3afb235b3d28ae", "filename": "src/test/ui/associated-type-bounds/ambiguous-associated-type2.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,16 +0,0 @@\n-error[E0391]: cycle detected when computing the super traits of `Baz` with associated type name `Item`\n-  --> $DIR/ambiguous-associated-type2.rs:9:1\n-   |\n-LL | trait Baz: Foo + Bar<Self::Item> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: ...which again requires computing the super traits of `Baz` with associated type name `Item`, completing the cycle\n-note: cycle used when computing the super traits of `Baz`\n-  --> $DIR/ambiguous-associated-type2.rs:9:1\n-   |\n-LL | trait Baz: Foo + Bar<Self::Item> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "3eb50ab554735e7b680dfe43d2ef9e5324fb4b1b", "filename": "src/test/ui/associated-type-bounds/associated-item-through-where-clause.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,21 +0,0 @@\n-// check-pass\n-\n-trait Foo {\n-    type Item;\n-}\n-\n-trait Bar\n-where\n-    Self: Foo,\n-{\n-}\n-\n-#[allow(dead_code)]\n-fn foo<M>(_m: M)\n-where\n-    M: Bar,\n-    M::Item: Send,\n-{\n-}\n-\n-fn main() {}"}, {"sha": "b1e54ec04493b3a3c97ecfab4b9b33ba8eae2103", "filename": "src/test/ui/associated-type-bounds/handle-predicates-that-can-define-assoc-type.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,10 +0,0 @@\n-// check-pass\n-\n-trait Foo<T> {}\n-trait Bar {\n-    type A;\n-    type B;\n-}\n-trait Baz: Bar<B = u32> + Foo<Self::A> {}\n-\n-fn main() {}"}, {"sha": "07d0f8f8769e5f2bd46ed23e24a718b315a8b44f", "filename": "src/test/ui/associated-type-bounds/missing-trait-bound-for-assoc-fails.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,10 +0,0 @@\n-#[allow(dead_code)]\n-fn foo<M>(_m: M)\n-where\n-    M::Item: Temp,\n-    //~^ ERROR cannot find trait `Temp` in this scope [E0405]\n-    //~| ERROR associated type `Item` not found for `M` [E0220]\n-{\n-}\n-\n-fn main() {}"}, {"sha": "bc2807b03961c0db6f79a3d93f41741272f5ab38", "filename": "src/test/ui/associated-type-bounds/missing-trait-bound-for-assoc-fails.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,16 +0,0 @@\n-error[E0405]: cannot find trait `Temp` in this scope\n-  --> $DIR/missing-trait-bound-for-assoc-fails.rs:4:14\n-   |\n-LL |     M::Item: Temp,\n-   |              ^^^^ not found in this scope\n-\n-error[E0220]: associated type `Item` not found for `M`\n-  --> $DIR/missing-trait-bound-for-assoc-fails.rs:4:8\n-   |\n-LL |     M::Item: Temp,\n-   |        ^^^^ associated type `Item` not found\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0220, E0405.\n-For more information about an error, try `rustc --explain E0220`."}, {"sha": "c82ec01f4d61db9b99f8a00d3adb039f1618f685", "filename": "src/test/ui/associated-type-bounds/super-trait-referencing-self.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,12 +0,0 @@\n-// check-pass\n-trait Foo {\n-    type Bar;\n-}\n-trait Qux: Foo + AsRef<Self::Bar> {}\n-trait Foo2 {}\n-\n-trait Qux2: Foo2 + AsRef<Self::Bar> {\n-    type Bar;\n-}\n-\n-fn main() {}"}, {"sha": "2e97535157fd2ca40ea0aba1f6786e3ccfd86c46", "filename": "src/test/ui/associated-type-bounds/super-trait-referencing.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,19 +0,0 @@\n-// check-pass\n-\n-// The goal of this test is to ensure that T: Bar<T::Item>\n-// in the where clause does not cycle\n-\n-trait Foo {\n-    type Item;\n-}\n-\n-trait Bar<T> {}\n-\n-fn baz<T>()\n-where\n-    T: Foo,\n-    T: Bar<T::Item>,\n-{\n-}\n-\n-fn main() {}"}, {"sha": "72a6be9ffc38843a38ebf1346b3ea4aebc978645", "filename": "src/test/ui/associated-type-bounds/super-trait-where-referencing-self.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,27 +0,0 @@\n-// check-pass\n-\n-// Test that we do not get a cycle due to\n-// resolving `Self::Bar` in the where clauses\n-// on a trait definition (in particular, in\n-// a where clause that is defining a superpredicate).\n-\n-trait Foo {\n-    type Bar;\n-}\n-trait Qux\n-where\n-    Self: Foo,\n-    Self: AsRef<Self::Bar>,\n-{\n-}\n-trait Foo2 {}\n-\n-trait Qux2\n-where\n-    Self: Foo2,\n-    Self: AsRef<Self::Bar>,\n-{\n-    type Bar;\n-}\n-\n-fn main() {}"}, {"sha": "d3609acfdff63edd44e05599669eeb292e2083d2", "filename": "src/test/ui/cycle-projection-based-on-where-clause.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -0,0 +1,24 @@\n+// Example cycle where a bound on `T` uses a shorthand for `T`. This\n+// creates a cycle because we have to know the bounds on `T` to figure\n+// out what trait defines `Item`, but we can't know the bounds on `T`\n+// without knowing how to handle `T::Item`.\n+//\n+// Note that in the future cases like this could perhaps become legal,\n+// if we got more fine-grained about our cycle detection or changed\n+// how we handle `T::Item` resolution.\n+\n+use std::ops::Add;\n+\n+// Preamble.\n+trait Trait { type Item; }\n+\n+struct A<T>\n+    where T : Trait,\n+          T : Add<T::Item>\n+    //~^ ERROR cycle detected\n+{\n+    data: T\n+}\n+\n+fn main() {\n+}"}, {"sha": "2c337cc6bf903bf6edefca9a1716777b93c41716", "filename": "src/test/ui/cycle-projection-based-on-where-clause.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -0,0 +1,16 @@\n+error[E0391]: cycle detected when computing the bounds for type parameter `T`\n+  --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n+   |\n+LL |           T : Add<T::Item>\n+   |                   ^^^^^^^\n+   |\n+   = note: ...which again requires computing the bounds for type parameter `T`, completing the cycle\n+note: cycle used when computing explicit predicates of `A`\n+  --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n+   |\n+LL |           T : Add<T::Item>\n+   |                   ^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "8aa3ac8abf52c5eaa658bc0955a17c059e57f77a", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-direct.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,15 +1,10 @@\n-error[E0391]: cycle detected when computing the super predicates of `Chromosome`\n-  --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n-   |\n-LL | trait Chromosome: Chromosome {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `Chromosome`...\n+error[E0391]: cycle detected when computing the supertraits of `Chromosome`\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:19\n    |\n LL | trait Chromosome: Chromosome {\n    |                   ^^^^^^^^^^\n-   = note: ...which again requires computing the super predicates of `Chromosome`, completing the cycle\n+   |\n+   = note: ...which again requires computing the supertraits of `Chromosome`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n    |"}, {"sha": "9740f43a4ba97cb6870024a8fe50129040e465b2", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-indirect.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,26 +1,16 @@\n-error[E0391]: cycle detected when computing the super predicates of `B`\n-  --> $DIR/cycle-trait-supertrait-indirect.rs:7:1\n-   |\n-LL | trait B: C {\n-   | ^^^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `B`...\n+error[E0391]: cycle detected when computing the supertraits of `B`\n   --> $DIR/cycle-trait-supertrait-indirect.rs:7:10\n    |\n LL | trait B: C {\n    |          ^\n-note: ...which requires computing the super predicates of `C`...\n-  --> $DIR/cycle-trait-supertrait-indirect.rs:11:1\n    |\n-LL | trait C: B { }\n-   | ^^^^^^^^^^\n-note: ...which requires computing the super traits of `C`...\n+note: ...which requires computing the supertraits of `C`...\n   --> $DIR/cycle-trait-supertrait-indirect.rs:11:10\n    |\n LL | trait C: B { }\n    |          ^\n-   = note: ...which again requires computing the super predicates of `B`, completing the cycle\n-note: cycle used when computing the super traits of `A`\n+   = note: ...which again requires computing the supertraits of `B`, completing the cycle\n+note: cycle used when computing the supertraits of `A`\n   --> $DIR/cycle-trait-supertrait-indirect.rs:4:10\n    |\n LL | trait A: B {"}, {"sha": "37e38ff60ae4bd55bf2eea482ed5babc3fcb3b45", "filename": "src/test/ui/issues/issue-12511.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,25 +1,15 @@\n-error[E0391]: cycle detected when computing the super predicates of `T1`\n-  --> $DIR/issue-12511.rs:1:1\n-   |\n-LL | trait T1 : T2 {\n-   | ^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `T1`...\n+error[E0391]: cycle detected when computing the supertraits of `T1`\n   --> $DIR/issue-12511.rs:1:12\n    |\n LL | trait T1 : T2 {\n    |            ^^\n-note: ...which requires computing the super predicates of `T2`...\n-  --> $DIR/issue-12511.rs:5:1\n    |\n-LL | trait T2 : T1 {\n-   | ^^^^^^^^^^^^^\n-note: ...which requires computing the super traits of `T2`...\n+note: ...which requires computing the supertraits of `T2`...\n   --> $DIR/issue-12511.rs:5:12\n    |\n LL | trait T2 : T1 {\n    |            ^^\n-   = note: ...which again requires computing the super predicates of `T1`, completing the cycle\n+   = note: ...which again requires computing the supertraits of `T1`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-12511.rs:1:1\n    |"}, {"sha": "d64636310a3687344adff5d67cd2482889abe8ae", "filename": "src/test/ui/issues/issue-20772.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,13 +1,13 @@\n-error[E0391]: cycle detected when computing the super traits of `T` with associated type name `Item`\n+error[E0391]: cycle detected when computing the supertraits of `T`\n   --> $DIR/issue-20772.rs:1:1\n    |\n LL | / trait T : Iterator<Item=Self::Item>\n LL | |\n LL | | {}\n    | |__^\n    |\n-   = note: ...which again requires computing the super traits of `T` with associated type name `Item`, completing the cycle\n-note: cycle used when computing the super traits of `T`\n+   = note: ...which again requires computing the supertraits of `T`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-20772.rs:1:1\n    |\n LL | / trait T : Iterator<Item=Self::Item>"}, {"sha": "5f9709d1c649badb26b724e024d9ecda38bf9e78", "filename": "src/test/ui/issues/issue-20825.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when computing the super traits of `Processor` with associated type name `Input`\n+error[E0391]: cycle detected when computing the supertraits of `Processor`\n   --> $DIR/issue-20825.rs:5:1\n    |\n LL | pub trait Processor: Subscriber<Input = Self::Input> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires computing the super traits of `Processor` with associated type name `Input`, completing the cycle\n-note: cycle used when computing the super traits of `Processor`\n+   = note: ...which again requires computing the supertraits of `Processor`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-20825.rs:5:1\n    |\n LL | pub trait Processor: Subscriber<Input = Self::Input> {"}, {"sha": "ba8057b684de8d48eb71e7ccabec59297cc52da4", "filename": "src/test/ui/issues/issue-22673.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -1,6 +1,5 @@\n-// check-pass\n-\n-trait Expr: PartialEq<Self::Item> {\n+trait Expr : PartialEq<Self::Item> {\n+    //~^ ERROR: cycle detected\n     type Item;\n }\n "}, {"sha": "9e7e4b218b1c668cdba6e31068cc2af5c05316b2", "filename": "src/test/ui/issues/issue-22673.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4def89d76896eec73b4af33642ba7e5eb53c567/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr?ref=b4def89d76896eec73b4af33642ba7e5eb53c567", "patch": "@@ -0,0 +1,16 @@\n+error[E0391]: cycle detected when computing the supertraits of `Expr`\n+  --> $DIR/issue-22673.rs:1:1\n+   |\n+LL | trait Expr : PartialEq<Self::Item> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: ...which again requires computing the supertraits of `Expr`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-22673.rs:1:1\n+   |\n+LL | trait Expr : PartialEq<Self::Item> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}]}