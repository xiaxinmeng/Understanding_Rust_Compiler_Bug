{"sha": "f7ec959c979b83f125ba9e8c274096c8838e5fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZWM5NTljOTc5YjgzZjEyNWJhOWU4YzI3NDA5NmM4ODM4ZTVmYTE=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-06T23:51:19Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-07T00:04:06Z"}, "message": "Use closure instead of declaring function\n\nTake comment overhead into account", "tree": {"sha": "5af11a866fa55d276e8fb5e1decdff4d9b45f296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af11a866fa55d276e8fb5e1decdff4d9b45f296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7ec959c979b83f125ba9e8c274096c8838e5fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7ec959c979b83f125ba9e8c274096c8838e5fa1", "html_url": "https://github.com/rust-lang/rust/commit/f7ec959c979b83f125ba9e8c274096c8838e5fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7ec959c979b83f125ba9e8c274096c8838e5fa1/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4cce31ea9d7dfd3213102dee2181ea9a8959279", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cce31ea9d7dfd3213102dee2181ea9a8959279", "html_url": "https://github.com/rust-lang/rust/commit/a4cce31ea9d7dfd3213102dee2181ea9a8959279"}], "stats": {"total": 103, "additions": 41, "deletions": 62}, "files": [{"sha": "4f762ea1f37b9d36f2666916fe2fa5115f9eb8cd", "filename": "src/lists.rs", "status": "modified", "additions": 41, "deletions": 62, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f7ec959c979b83f125ba9e8c274096c8838e5fa1/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ec959c979b83f125ba9e8c274096c8838e5fa1/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=f7ec959c979b83f125ba9e8c274096c8838e5fa1", "patch": "@@ -269,19 +269,36 @@ where\n \n         if tactic == DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n-            let block_style = !formatting.ends_with_newline && last;\n-            let mut formatted_comment = try_opt!(rewrite_post_comment(\n-                formatting.config,\n-                formatting.shape,\n-                comment,\n-                &cloned_items,\n-                inner_item,\n-                i,\n-                &mut item_max_width,\n-                item_last_line_width,\n-                last,\n-                block_style,\n-            ));\n+            let overhead = last_line_width(&result) + first_line_width(comment.trim());\n+\n+            let rewrite_post_comment = |item_max_width: &mut Option<usize>| {\n+                if item_max_width.is_none() && !last && !inner_item.contains('\\n') {\n+                    *item_max_width = Some(max_width_of_item_with_post_comment(\n+                        &cloned_items,\n+                        i,\n+                        overhead,\n+                        formatting.config.max_width(),\n+                    ));\n+                }\n+                let overhead = if let &mut Some(max_width) = item_max_width {\n+                    max_width + 2\n+                } else {\n+                    // 1 = space between item and comment.\n+                    item_last_line_width + 1\n+                };\n+                let width = formatting.shape.width.checked_sub(overhead).unwrap_or(1);\n+                let offset = formatting.shape.indent + overhead;\n+                let comment_shape = Shape::legacy(width, offset);\n+\n+                // Use block-style only for the last item or multiline comments.\n+                let block_style = !formatting.ends_with_newline && last ||\n+                    comment.trim().contains('\\n') ||\n+                    comment.trim().len() > width;\n+\n+                rewrite_comment(comment, block_style, comment_shape, formatting.config)\n+            };\n+\n+            let mut formatted_comment = try_opt!(rewrite_post_comment(&mut item_max_width));\n \n             if !formatted_comment.starts_with('\\n') {\n                 let mut comment_alignment =\n@@ -290,18 +307,7 @@ where\n                     comment_alignment + 1 > formatting.config.max_width()\n                 {\n                     item_max_width = None;\n-                    formatted_comment = try_opt!(rewrite_post_comment(\n-                        formatting.config,\n-                        formatting.shape,\n-                        comment,\n-                        &cloned_items,\n-                        inner_item,\n-                        i,\n-                        &mut item_max_width,\n-                        item_last_line_width,\n-                        last,\n-                        block_style,\n-                    ));\n+                    formatted_comment = try_opt!(rewrite_post_comment(&mut item_max_width));\n                     comment_alignment = post_comment_alignment(item_max_width, inner_item.len());\n                 }\n                 for _ in 0..(comment_alignment + 1) {\n@@ -329,42 +335,12 @@ where\n     Some(result)\n }\n \n-fn rewrite_post_comment<I, T>(\n-    config: &Config,\n-    shape: Shape,\n-    comment: &str,\n-    cloned_items: &I,\n-    inner_item: &str,\n+fn max_width_of_item_with_post_comment<I, T>(\n+    items: &I,\n     i: usize,\n-    mut item_max_width: &mut Option<usize>,\n-    item_last_line_width: usize,\n-    last: bool,\n-    block_style: bool,\n-) -> Option<String>\n-where\n-    I: IntoIterator<Item = T> + Clone,\n-    T: AsRef<ListItem>,\n-{\n-    if item_max_width.is_none() && !last && !inner_item.contains('\\n') {\n-        *item_max_width = Some(max_width_of_item_with_post_comment(cloned_items, i));\n-    }\n-    let overhead = if let &mut Some(max_width) = item_max_width {\n-        max_width + 2\n-    } else {\n-        // 1 = space between item and comment.\n-        item_last_line_width + 1\n-    };\n-    let width = shape.width.checked_sub(overhead).unwrap_or(1);\n-    let offset = shape.indent + overhead;\n-\n-    debug!(\"Width = {}, offset = {:?}\", width, offset);\n-    // Use block-style only for the last item or multiline comments.\n-    let block_style = block_style || comment.trim().contains('\\n') || comment.trim().len() > width;\n-\n-    rewrite_comment(comment, block_style, Shape::legacy(width, offset), config)\n-}\n-\n-fn max_width_of_item_with_post_comment<I, T>(items: &I, i: usize) -> usize\n+    overhead: usize,\n+    max_budget: usize,\n+) -> usize\n where\n     I: IntoIterator<Item = T> + Clone,\n     T: AsRef<ListItem>,\n@@ -373,10 +349,13 @@ where\n     let mut first = true;\n     for item in items.clone().into_iter().skip(i) {\n         let item = item.as_ref();\n-        if !first && (item.is_multiline() || !item.post_comment.is_some()) {\n+        let inner_item_width = item.inner_as_ref().len();\n+        if !first &&\n+            (item.is_multiline() || !item.post_comment.is_some() ||\n+                 inner_item_width + overhead > max_budget)\n+        {\n             return max_width;\n         }\n-        let inner_item_width = item.inner_as_ref().len();\n         if max_width < inner_item_width {\n             max_width = inner_item_width;\n         }"}]}