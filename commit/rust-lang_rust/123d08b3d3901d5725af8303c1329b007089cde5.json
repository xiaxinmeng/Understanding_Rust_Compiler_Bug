{"sha": "123d08b3d3901d5725af8303c1329b007089cde5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyM2QwOGIzZDM5MDFkNTcyNWFmODMwM2MxMzI5YjAwNzA4OWNkZTU=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-31T15:40:24Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-31T15:40:24Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust into redox", "tree": {"sha": "f257a46a600bfcc8faa09d843f5dbe0aae8c7b3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f257a46a600bfcc8faa09d843f5dbe0aae8c7b3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/123d08b3d3901d5725af8303c1329b007089cde5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/123d08b3d3901d5725af8303c1329b007089cde5", "html_url": "https://github.com/rust-lang/rust/commit/123d08b3d3901d5725af8303c1329b007089cde5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/123d08b3d3901d5725af8303c1329b007089cde5/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c77979b419959dda0d628ffb4af15c5f2a9e8648", "url": "https://api.github.com/repos/rust-lang/rust/commits/c77979b419959dda0d628ffb4af15c5f2a9e8648", "html_url": "https://github.com/rust-lang/rust/commit/c77979b419959dda0d628ffb4af15c5f2a9e8648"}, {"sha": "074d30d030a3339565ab737c23312e6bbe625431", "url": "https://api.github.com/repos/rust-lang/rust/commits/074d30d030a3339565ab737c23312e6bbe625431", "html_url": "https://github.com/rust-lang/rust/commit/074d30d030a3339565ab737c23312e6bbe625431"}], "stats": {"total": 4712, "additions": 2128, "deletions": 2584}, "files": [{"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/aarch64-unknown-fuchsia.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/mk%2Fcfg%2Faarch64-unknown-fuchsia.mk", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/mk%2Fcfg%2Faarch64-unknown-fuchsia.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-unknown-fuchsia.mk?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "25192bfd27a440ef26e1c92bc5f8ab2ea4e2063a", "filename": "mk/crates.mk", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -60,8 +60,8 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n                 rustc_const_eval rustc_const_math rustc_incremental proc_macro\n-HOST_CRATES := syntax syntax_ext proc_macro_plugin syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n-\t\tflate arena graphviz log serialize\n+HOST_CRATES := syntax syntax_ext proc_macro_tokens proc_macro_plugin syntax_pos $(RUSTC_CRATES) \\\n+\t\trustdoc fmt_macros flate arena graphviz log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n DEPS_core :=\n@@ -102,8 +102,9 @@ DEPS_test := std getopts term native:rust_test_helpers\n \n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n-DEPS_proc_macro_plugin := syntax syntax_pos rustc_plugin log\n DEPS_syntax_pos := serialize\n+DEPS_proc_macro_tokens := syntax syntax_pos log\n+DEPS_proc_macro_plugin := syntax syntax_pos rustc_plugin log proc_macro_tokens\n \n DEPS_rustc_const_math := std syntax log serialize\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n@@ -120,7 +121,7 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n                      rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n                      rustc_metadata syntax_ext proc_macro_plugin \\\n                      rustc_passes rustc_save_analysis rustc_const_eval \\\n-                     rustc_incremental syntax_pos rustc_errors proc_macro\n+                     rustc_incremental syntax_pos rustc_errors proc_macro rustc_data_structures\n DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags"}, {"sha": "5826995cc3cfc65da9a24a5b2678359f9853ce15", "filename": "src/Cargo.lock", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -19,7 +19,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -42,10 +42,10 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.35 (git+https://github.com/alexcrichton/gcc-rs)\",\n+ \"gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -66,7 +66,7 @@ name = \"cmake\"\n version = \"0.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -83,7 +83,7 @@ name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n- \"gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -116,15 +116,15 @@ name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -133,12 +133,12 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.35\"\n-source = \"git+https://github.com/alexcrichton/gcc-rs#03e22a4425c011fa8c96681591432456fa70d60c\"\n+version = \"0.3.38\"\n+source = \"git+https://github.com/alexcrichton/gcc-rs#be620ac6d3ddb498cd0c700d5312c6a4c3c19597\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.35\"\n+version = \"0.3.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -159,7 +159,7 @@ name = \"idna\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"matches 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -182,14 +182,14 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.15\"\n+version = \"0.2.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"linkchecker\"\n version = \"0.1.0\"\n dependencies = [\n- \"url 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -203,7 +203,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"matches\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -216,7 +216,7 @@ name = \"num_cpus\"\n version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -249,11 +249,21 @@ name = \"proc_macro_plugin\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"proc_macro_tokens 0.0.0\",\n  \"rustc_plugin 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"proc_macro_tokens\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n [[package]]\n name = \"rand\"\n version = \"0.0.0\"\n@@ -373,6 +383,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_borrowck 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_lint 0.0.0\",\n@@ -431,7 +442,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -585,7 +596,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -621,7 +632,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -704,7 +715,7 @@ name = \"unicode-bidi\"\n version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"matches 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -714,11 +725,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"url\"\n-version = \"1.2.0\"\n+version = \"1.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"matches 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -735,20 +746,20 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dfcf5bcece56ef953b8ea042509e9dcbdfe97820b7e20d86beb53df30ed94978\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.35 (git+https://github.com/alexcrichton/gcc-rs)\" = \"<none>\"\n-\"checksum gcc 0.3.35 (registry+https://github.com/rust-lang/crates.io-index)\" = \"91ecd03771effb0c968fd6950b37e89476a578aaf1c70297d8e92b6516ec3312\"\n+\"checksum gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\" = \"<none>\"\n+\"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1053236e00ce4f668aeca4a769a09b3bf5a682d802abd6f3cb39374f6b162c11\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum libc 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23e3757828fa702a20072c37ff47938e9dd331b92fac6e223d26d4b7a55f7ee2\"\n+\"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n-\"checksum matches 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15305656809ce5a4805b1ff2946892810992197ce1270ff79baded852187942e\"\n+\"checksum matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcc3ad8109fa4b522f9b0cd81440422781f564aaf8c195de6b9d6642177ad0dd\"\n \"checksum md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a5539a8dee9b4ae308c9c406a379838b435a8f2c84cf9fedc6d5a576be9888db\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n \"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n \"checksum unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1f7ceb96afdfeedee42bade65a0d585a6a0106f681b6749c8ff4daa8df30b3f\"\n \"checksum unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26643a2f83bac55f1976fb716c10234485f9202dcd65cfbdf9da49867b271172\"\n-\"checksum url 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afe9ec54bc4db14bc8744b7fed060d785ac756791450959b2248443319d5b119\"\n+\"checksum url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ba5a45db1d2e0effb7a1c00cc73ffc63a973da8c7d1fcd5b46f24285ade6c54\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "4838ecd2d42e62108b156dd760d9c8eb19b9942e", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -4023,9 +4023,9 @@ Methods that take either `self` or `Box<Self>` can optionally place them in a\n mutable variable by prefixing them with `mut` (similar to regular arguments):\n \n ```\n-trait Changer {\n-    fn change(mut self) -> Self;\n-    fn modify(mut self: Box<Self>) -> Box<Self>;\n+trait Changer: Sized {\n+    fn change(mut self) {}\n+    fn modify(mut self: Box<Self>) {}\n }\n ```\n \n@@ -4078,6 +4078,12 @@ be ignored in favor of only building the artifacts specified by command line.\n   Rust code into an existing non-Rust application because it will not have\n   dynamic dependencies on other Rust code.\n \n+* `--crate-type=cdylib`, `#[crate_type = \"cdylib\"]` - A dynamic system\n+  library will be produced.  This is used when compiling Rust code as\n+  a dynamic library to be loaded from another language.  This output type will\n+  create `*.so` files on Linux, `*.dylib` files on OSX, and `*.dll` files on\n+  Windows.\n+\n * `--crate-type=rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be\n   produced. This is used as an intermediate artifact and can be thought of as a\n   \"static Rust library\". These `rlib` files, unlike `staticlib` files, are"}, {"sha": "a4fabb5a2c96dbd69dc39340f1bdfb8ffea8250a", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -166,6 +166,7 @@ mod imp {\n         fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+        fn GetLastError() -> DWORD;\n     }\n \n     #[repr(C)]\n@@ -230,11 +231,11 @@ mod imp {\n     pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n         if align <= MIN_ALIGN {\n             let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-            debug_assert!(err != 0);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n         } else {\n             let header = get_header(ptr);\n             let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-            debug_assert!(err != 0);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n         }\n     }\n "}, {"sha": "9cd63d87931842caf06b546bdbca546c54d40fe0", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -299,5 +299,7 @@ fn test_extend_specialization() {\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n }"}, {"sha": "8222da105ccad767bc1e3c51e0a97ff8dfbd859d", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -533,9 +533,7 @@ create_append_test!(test_append_1700, 1700);\n \n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n     let mut rng = DeterministicRng::new();\n-    Vec::from_iter(\n-        (0..len).map(|_| (rng.next(), rng.next()))\n-    )\n+    Vec::from_iter((0..len).map(|_| (rng.next(), rng.next())))\n }\n \n #[test]"}, {"sha": "ae8b18d0c9fd92203fef9cc2bfd826aad5883bcc", "filename": "src/libcollectionstest/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,7 +25,7 @@ impl DeterministicRng {\n             x: 0x193a6754,\n             y: 0xa8a7d469,\n             z: 0x97830e05,\n-            w: 0x113ba7bb\n+            w: 0x113ba7bb,\n         }\n     }\n "}, {"sha": "6171b8ba624cd5581b505d3eb47cfc43d8e81c7c", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,45 +15,51 @@ use super::DeterministicRng;\n \n #[test]\n fn test_clone_eq() {\n-  let mut m = BTreeSet::new();\n+    let mut m = BTreeSet::new();\n \n-  m.insert(1);\n-  m.insert(2);\n+    m.insert(1);\n+    m.insert(2);\n \n-  assert!(m.clone() == m);\n+    assert!(m.clone() == m);\n }\n \n #[test]\n fn test_hash() {\n-  let mut x = BTreeSet::new();\n-  let mut y = BTreeSet::new();\n+    let mut x = BTreeSet::new();\n+    let mut y = BTreeSet::new();\n \n-  x.insert(1);\n-  x.insert(2);\n-  x.insert(3);\n+    x.insert(1);\n+    x.insert(2);\n+    x.insert(3);\n \n-  y.insert(3);\n-  y.insert(2);\n-  y.insert(1);\n+    y.insert(3);\n+    y.insert(2);\n+    y.insert(1);\n \n-  assert!(::hash(&x) == ::hash(&y));\n+    assert!(::hash(&x) == ::hash(&y));\n }\n \n-fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n-    F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut FnMut(&i32) -> bool) -> bool,\n+fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n+    where F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut FnMut(&i32) -> bool) -> bool\n {\n     let mut set_a = BTreeSet::new();\n     let mut set_b = BTreeSet::new();\n \n-    for x in a { assert!(set_a.insert(*x)) }\n-    for y in b { assert!(set_b.insert(*y)) }\n+    for x in a {\n+        assert!(set_a.insert(*x))\n+    }\n+    for y in b {\n+        assert!(set_b.insert(*y))\n+    }\n \n     let mut i = 0;\n-    f(&set_a, &set_b, &mut |&x| {\n-        assert_eq!(x, expected[i]);\n-        i += 1;\n-        true\n-    });\n+    f(&set_a,\n+      &set_b,\n+      &mut |&x| {\n+          assert_eq!(x, expected[i]);\n+          i += 1;\n+          true\n+      });\n     assert_eq!(i, expected.len());\n }\n \n@@ -82,9 +88,7 @@ fn test_difference() {\n     check_difference(&[], &[], &[]);\n     check_difference(&[1, 12], &[], &[1, 12]);\n     check_difference(&[], &[1, 2, 3, 9], &[]);\n-    check_difference(&[1, 3, 5, 9, 11],\n-                     &[3, 9],\n-                     &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[3, 9], &[1, 5, 11]);\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n@@ -245,10 +249,18 @@ fn test_recovery() {\n fn test_variance() {\n     use std::collections::btree_set::{IntoIter, Iter, Range};\n \n-    fn set<'new>(v: BTreeSet<&'static str>) -> BTreeSet<&'new str> { v }\n-    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> { v }\n-    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> { v }\n-    fn range<'a, 'new>(v: Range<'a, &'static str>) -> Range<'a, &'new str> { v }\n+    fn set<'new>(v: BTreeSet<&'static str>) -> BTreeSet<&'new str> {\n+        v\n+    }\n+    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n+        v\n+    }\n+    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> {\n+        v\n+    }\n+    fn range<'a, 'new>(v: Range<'a, &'static str>) -> Range<'a, &'new str> {\n+        v\n+    }\n }\n \n #[test]\n@@ -277,9 +289,7 @@ fn test_append() {\n \n fn rand_data(len: usize) -> Vec<u32> {\n     let mut rng = DeterministicRng::new();\n-    Vec::from_iter(\n-        (0..len).map(|_| rng.next())\n-    )\n+    Vec::from_iter((0..len).map(|_| rng.next()))\n }\n \n #[test]"}, {"sha": "5d3e03c2dee3691f21612ead902b7d6509c4c762", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -36,7 +36,9 @@ extern crate rustc_unicode;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n \n-#[cfg(test)] #[macro_use] mod bench;\n+#[cfg(test)]\n+#[macro_use]\n+mod bench;\n \n mod binary_heap;\n mod btree;"}, {"sha": "a6230ef471cec0f69f9cb197ae8f9cd24a16c9c0", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -420,12 +420,12 @@ fn test_sort_stability() {\n             // number this element is, i.e. the second elements\n             // will occur in sorted order.\n             let mut v: Vec<_> = (0..len)\n-                                    .map(|_| {\n-                                        let n = thread_rng().gen::<usize>() % 10;\n-                                        counts[n] += 1;\n-                                        (n, counts[n])\n-                                    })\n-                                    .collect();\n+                .map(|_| {\n+                    let n = thread_rng().gen::<usize>() % 10;\n+                    counts[n] += 1;\n+                    (n, counts[n])\n+                })\n+                .collect();\n \n             // only sort on the first element, so an unstable sort\n             // may mix up the counts.\n@@ -1116,13 +1116,13 @@ fn test_box_slice_clone_panics() {\n     };\n \n     spawn(move || {\n-        // When xs is dropped, +5.\n-        let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n-                     .into_boxed_slice();\n+            // When xs is dropped, +5.\n+            let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n+                .into_boxed_slice();\n \n-        // When panic is cloned, +3.\n-        xs.clone();\n-    })\n+            // When panic is cloned, +3.\n+            xs.clone();\n+        })\n         .join()\n         .unwrap_err();\n \n@@ -1374,8 +1374,8 @@ mod bench {\n         let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>()\n-                           .take(5)\n-                           .collect::<Vec<BigSortable>>();\n+                .take(5)\n+                .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n@@ -1386,8 +1386,8 @@ mod bench {\n         let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>()\n-                           .take(100)\n-                           .collect::<Vec<BigSortable>>();\n+                .take(100)\n+                .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n@@ -1398,8 +1398,8 @@ mod bench {\n         let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>()\n-                           .take(10000)\n-                           .collect::<Vec<BigSortable>>();\n+                .take(10000)\n+                .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 10000 * mem::size_of::<BigSortable>() as u64;"}, {"sha": "3bc1321d75653cd31a5e52e910cd62173c404fd7", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -607,8 +607,12 @@ fn test_from_cow() {\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n-    fn into_iter<'new>(i: IntoIter<&'static str>) -> IntoIter<&'new str> { i }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n+    fn into_iter<'new>(i: IntoIter<&'static str>) -> IntoIter<&'new str> {\n+        i\n+    }\n }\n \n #[bench]"}, {"sha": "f1ea85a6c5bed98e700fe42df0319a42f9765803", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -686,9 +686,9 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n     let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"]\n-                                   .iter()\n-                                   .cloned()\n-                                   .collect();\n+        .iter()\n+        .cloned()\n+        .collect();\n     assert_eq!(format!(\"{:?}\", ringbuf),\n                \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n@@ -1003,5 +1003,7 @@ fn test_contains() {\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n }"}, {"sha": "e0f976e4161da2416cbb3389c5957c210c0e4eb7", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -706,24 +706,24 @@ mod impls {\n \n     ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl Eq for ! {}\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self"}, {"sha": "2d75a8ec420b1cfa9252c8cd43d8b4a4c14a2016", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1356,14 +1356,14 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n impl Debug for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self\n     }\n }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n impl Display for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self"}, {"sha": "e6c3f549ec8e6c918fcc7a90606888939add4bdb", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -553,7 +553,7 @@ pub mod builtin {\n     /// For more information, see the documentation for [`std::concat_idents!`].\n     ///\n     /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n-    #[unstable(feature = \"concat_idents\", issue = \"29599\")]\n+    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n     #[macro_export]\n     macro_rules! concat_idents {\n         ($($e:ident),*) => ({ /* compiler built-in */ })"}, {"sha": "7d9b71f0971f8fa196d864d7071f216a59036d6e", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1 +1 @@\n-Subproject commit c95defce07a82f2f759f140c937dabd43a4f3d97\n+Subproject commit 7d9b71f0971f8fa196d864d7071f216a59036d6e"}, {"sha": "1d2c64d6d938aa815b6afc0fa6e03fd6e7ca4dd4", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -136,10 +136,8 @@ impl FromStr for TokenStream {\n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n         __internal::with_parse_sess(|sess| {\n             let src = src.to_string();\n-            let cfg = Vec::new();\n             let name = \"<proc-macro source code>\".to_string();\n-            let mut parser = parse::new_parser_from_source_str(sess, cfg, name,\n-                                                               src);\n+            let mut parser = parse::new_parser_from_source_str(sess, name, src);\n             let mut ret = TokenStream { inner: Vec::new() };\n             loop {\n                 match parser.parse_item() {"}, {"sha": "4bc3f488d32808fd7743c57b23157abf6a07c4ce", "filename": "src/libproc_macro_plugin/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2FCargo.toml?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,3 +12,4 @@ log = { path = \"../liblog\" }\n rustc_plugin = { path = \"../librustc_plugin\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+proc_macro_tokens = { path = \"../libproc_macro_tokens\" }"}, {"sha": "c45762bfb6e71525a9a1605152fbfd902c1399dc", "filename": "src/libproc_macro_plugin/lib.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,43 +13,14 @@\n //! A library for procedural macro writers.\n //!\n //! ## Usage\n-//! This package provides the `qquote!` macro for syntax creation, and the prelude\n-//! (at libproc_macro::prelude) provides a number of operations:\n-//! - `concat`, for concatenating two TokenStreams.\n-//! - `ident_eq`, for checking if two identifiers are equal regardless of syntax context.\n-//! - `str_to_token_ident`, for converting an `&str` into a Token.\n-//! - `keyword_to_token_delim`, for converting a `parse::token::keywords::Keyword` into a\n-//!    Token.\n-//! - `build_delimited`, for creating a new TokenStream from an existing one and a delimiter\n-//!    by wrapping the TokenStream in the delimiter.\n-//! - `build_bracket_delimited`, `build_brace_delimited`, and `build_paren_delimited`, for\n-//!    easing the above.\n-//! - `build_empty_args`, which returns a TokenStream containing `()`.\n-//! - `lex`, which takes an `&str` and returns the TokenStream it represents.\n-//!\n-//! The `qquote!` macro also imports `syntax::ext::proc_macro_shim::prelude::*`, so you\n+//! This crate provides the `qquote!` macro for syntax creation.\n+//!\n+//! The `qquote!` macro imports `syntax::ext::proc_macro_shim::prelude::*`, so you\n //! will need to `extern crate syntax` for usage. (This is a temporary solution until more\n-//! of the external API in libproc_macro is stabilized to support the token construction\n+//! of the external API in libproc_macro_tokens is stabilized to support the token construction\n //! operations that the qausiquoter relies on.) The shim file also provides additional\n //! operations, such as `build_block_emitter` (as used in the `cond` example below).\n //!\n-//! ## TokenStreams\n-//!\n-//! TokenStreams serve as the basis of the macro system. They are, in essence, vectors of\n-//! TokenTrees, where indexing treats delimited values as a single term. That is, the term\n-//! `even(a+c) && even(b)` will be indexibly encoded as `even | (a+c) | even | (b)` where,\n-//! in reality, `(a+c)` is actually a decorated pointer to `a | + | c`.\n-//!\n-//! If a user has a TokenStream that is a single, delimited value, they can use\n-//! `maybe_delimited` to destruct it and receive the internal vector as a new TokenStream\n-//! as:\n-//! ```\n-//! `(a+c)`.maybe_delimited() ~> Some(a | + | c)`\n-//! ```\n-//!\n-//! Check the TokenStream documentation for more information; the structure also provides\n-//! cheap concatenation and slicing.\n-//!\n //! ## Quasiquotation\n //!\n //! The quasiquoter creates output that, when run, constructs the tokenstream specified as\n@@ -118,12 +89,11 @@\n extern crate rustc_plugin;\n extern crate syntax;\n extern crate syntax_pos;\n+extern crate proc_macro_tokens;\n #[macro_use] extern crate log;\n \n mod qquote;\n-pub mod build;\n-pub mod parse;\n-pub mod prelude;\n+\n use qquote::qquote;\n \n use rustc_plugin::Registry;"}, {"sha": "e5a3abc2ea982e01a8e06bd95d0905790c086ec3", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,12 +24,9 @@\n //! TokenStream that resembles the output syntax.\n //!\n \n-extern crate rustc_plugin;\n-extern crate syntax;\n-extern crate syntax_pos;\n+use proc_macro_tokens::build::*;\n+use proc_macro_tokens::parse::lex;\n \n-use build::*;\n-use parse::lex;\n use qquote::int_build::*;\n \n use syntax::ast::Ident;\n@@ -51,7 +48,7 @@ pub fn qquote<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n     let output = qquoter(cx, TokenStream::from_tts(tts.clone().to_owned()));\n     debug!(\"\\nQQ out: {}\\n\", pprust::tts_to_string(&output.to_tts()[..]));\n     let imports = concat(lex(\"use syntax::ext::proc_macro_shim::prelude::*;\"),\n-                         lex(\"use proc_macro_plugin::prelude::*;\"));\n+                         lex(\"use proc_macro_tokens::prelude::*;\"));\n     build_block_emitter(cx, sp, build_brace_delimited(concat(imports, output)))\n }\n \n@@ -219,7 +216,7 @@ fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, T\n \n                 let sep = build_delim_tok(qdl.delim);\n \n-                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro_plugin\"),\n+                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro_tokens\"),\n                                                str_to_ident(\"build\"),\n                                                str_to_ident(\"build_delimited\")],\n                                           concat(from_tokens(vec![Token::Ident(new_id)]),\n@@ -264,11 +261,8 @@ fn is_qquote(id: Ident) -> bool {\n }\n \n mod int_build {\n-    extern crate syntax;\n-    extern crate syntax_pos;\n-\n-    use parse::*;\n-    use build::*;\n+    use proc_macro_tokens::build::*;\n+    use proc_macro_tokens::parse::*;\n \n     use syntax::ast::{self, Ident};\n     use syntax::codemap::{DUMMY_SP};"}, {"sha": "2b66d56759f35b220debeab20ea604f5f51f07bb", "filename": "src/libproc_macro_tokens/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2FCargo.toml?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"proc_macro_tokens\"\n+version = \"0.0.0\"\n+\n+[lib]\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+log = { path = \"../liblog\" }"}, {"sha": "7b7590b863b71aa5e5eba1e63d13a5f707dea352", "filename": "src/libproc_macro_tokens/build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fbuild.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "previous_filename": "src/libproc_macro_plugin/build.rs"}, {"sha": "3bfa2fbb29fbdab24e1493859a35a66d4ec7dd86", "filename": "src/libproc_macro_tokens/lib.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Proc_Macro\n+//!\n+//! A library for procedural macro writers.\n+//!\n+//! ## Usage\n+//! This crate provides the prelude (at libproc_macro_tokens::prelude), which\n+//! provides a number of operations:\n+//! - `concat`, for concatenating two TokenStreams.\n+//! - `ident_eq`, for checking if two identifiers are equal regardless of syntax context.\n+//! - `str_to_token_ident`, for converting an `&str` into a Token.\n+//! - `keyword_to_token_delim`, for converting a `parse::token::keywords::Keyword` into a\n+//!    Token.\n+//! - `build_delimited`, for creating a new TokenStream from an existing one and a delimiter\n+//!    by wrapping the TokenStream in the delimiter.\n+//! - `build_bracket_delimited`, `build_brace_delimited`, and `build_paren_delimited`, for\n+//!    easing the above.\n+//! - `build_empty_args`, which returns a TokenStream containing `()`.\n+//! - `lex`, which takes an `&str` and returns the TokenStream it represents.\n+//!\n+//! ## TokenStreams\n+//!\n+//! TokenStreams serve as the basis of the macro system. They are, in essence, vectors of\n+//! TokenTrees, where indexing treats delimited values as a single term. That is, the term\n+//! `even(a+c) && even(b)` will be indexibly encoded as `even | (a+c) | even | (b)` where,\n+//! in reality, `(a+c)` is actually a decorated pointer to `a | + | c`.\n+//!\n+//! If a user has a TokenStream that is a single, delimited value, they can use\n+//! `maybe_delimited` to destruct it and receive the internal vector as a new TokenStream\n+//! as:\n+//! ```\n+//! `(a+c)`.maybe_delimited() ~> Some(a | + | c)`\n+//! ```\n+//!\n+//! Check the TokenStream documentation for more information; the structure also provides\n+//! cheap concatenation and slicing.\n+//!\n+\n+#![crate_name = \"proc_macro_tokens\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(staged_api)]\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+extern crate syntax_pos;\n+#[macro_use] extern crate log;\n+\n+pub mod build;\n+pub mod parse;\n+pub mod prelude;"}, {"sha": "9af8a68cdcf497887b75e09a94f5917215d33bee", "filename": "src/libproc_macro_tokens/parse.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fparse.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "previous_filename": "src/libproc_macro_plugin/parse.rs"}, {"sha": "4c0c8ba6c6684b1c375236a4e13fefa2a5cbcfab", "filename": "src/libproc_macro_tokens/prelude.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibproc_macro_tokens%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fprelude.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "previous_filename": "src/libproc_macro_plugin/prelude.rs"}, {"sha": "620ee30c95628a100ca6ff35b01bc349fe76f1fe", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -124,7 +124,6 @@ impl<'a> LoweringContext<'a> {\n         hir::Crate {\n             module: self.lower_mod(&c.module),\n             attrs: self.lower_attrs(&c.attrs),\n-            config: c.config.clone().into(),\n             span: c.span,\n             exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n             items: items,\n@@ -1219,7 +1218,7 @@ impl<'a> LoweringContext<'a> {\n                         alignstack,\n                         dialect,\n                         expn_id,\n-                    }) => hir::ExprInlineAsm(hir::InlineAsm {\n+                    }) => hir::ExprInlineAsm(P(hir::InlineAsm {\n                     inputs: inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n                     outputs: outputs.iter()\n                                     .map(|out| {\n@@ -1237,7 +1236,7 @@ impl<'a> LoweringContext<'a> {\n                     alignstack: alignstack,\n                     dialect: dialect,\n                     expn_id: expn_id,\n-                }, outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n+                }), outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n                    inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect()),\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                     hir::ExprStruct(self.lower_path(path),"}, {"sha": "c451a789193aaecb0f917a69a3987eaf5282fa55", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -413,7 +413,6 @@ pub type CrateConfig = HirVec<P<MetaItem>>;\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: HirVec<Attribute>,\n-    pub config: CrateConfig,\n     pub span: Span,\n     pub exported_macros: HirVec<MacroDef>,\n \n@@ -941,7 +940,7 @@ pub enum Expr_ {\n     ExprRet(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    ExprInlineAsm(InlineAsm, Vec<P<Expr>>, Vec<P<Expr>>),\n+    ExprInlineAsm(P<InlineAsm>, HirVec<P<Expr>>, HirVec<P<Expr>>),\n \n     /// A struct or struct-like variant literal expression.\n     ///"}, {"sha": "d17402d21342b196338e5d80dab67da0431843fe", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -105,23 +105,12 @@ pub mod middle {\n     pub mod weak_lang_items;\n }\n \n-pub mod mir {\n-    mod cache;\n-    pub mod repr;\n-    pub mod tcx;\n-    pub mod visit;\n-    pub mod transform;\n-    pub mod traversal;\n-    pub mod mir_map;\n-}\n-\n+pub mod mir;\n pub mod session;\n pub mod traits;\n pub mod ty;\n \n pub mod util {\n-    pub use rustc_back::sha2;\n-\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;"}, {"sha": "3472c77cf42272038e401f17a493aba49466c96e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -192,6 +192,12 @@ declare_lint! {\n     \"safe access to extern statics was erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub PATTERNS_IN_FNS_WITHOUT_BODY,\n+    Warn,\n+    \"patterns in functions without body were erroneously allowed\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -228,7 +234,8 @@ impl LintPass for HardwiredLints {\n             SUPER_OR_SELF_IN_GLOBAL_PATH,\n             HR_LIFETIME_IN_ASSOC_TYPE,\n             LIFETIME_UNDERSCORE,\n-            SAFE_EXTERN_STATICS\n+            SAFE_EXTERN_STATICS,\n+            PATTERNS_IN_FNS_WITHOUT_BODY\n         )\n     }\n }"}, {"sha": "59a5147ed1c1681bc8d66ad765f99f5291845e6e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -29,8 +29,7 @@ use hir::map::definitions::{Definitions, DefKey};\n use hir::svh::Svh;\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt};\n-use mir::repr::Mir;\n-use mir::mir_map::MirMap;\n+use mir::Mir;\n use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n@@ -165,7 +164,6 @@ pub trait CrateStore<'tcx> {\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n \n@@ -209,8 +207,7 @@ pub trait CrateStore<'tcx> {\n     fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId>;\n     fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId>;\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>>;\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n     // This is basically a 1-based range of ints, which is a little\n@@ -228,8 +225,7 @@ pub trait CrateStore<'tcx> {\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>) -> Vec<u8>;\n+                           reachable: &NodeSet) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -334,8 +330,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n-        { bug!(\"is_extern_item\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n \n@@ -390,8 +384,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"defid_for_inlined_node\")\n     }\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                        -> Mir<'tcx> { bug!(\"get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n@@ -412,8 +406,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>) -> Vec<u8> { vec![] }\n+                           reachable: &NodeSet) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n "}, {"sha": "c37b6df369dfcf46ef302b40850a8874aecad116", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1017,7 +1017,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n                 Some(Def::Struct(..)) | Some(Def::StructCtor(..)) | Some(Def::Union(..)) |\n-                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) | Some(Def::SelfTy(..)) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }"}, {"sha": "bc9bbebb1796a83627c3fe418ce934e395df3335", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,7 +11,7 @@\n use std::cell::{Ref, RefCell};\n use rustc_data_structures::indexed_vec::IndexVec;\n \n-use mir::repr::{Mir, BasicBlock};\n+use mir::{Mir, BasicBlock};\n \n use rustc_serialize as serialize;\n "}, {"sha": "92de65798d3cbb18db8277631034ce72439f3f6d", "filename": "src/librustc/mir/mir_map.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c77979b419959dda0d628ffb4af15c5f2a9e8648/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77979b419959dda0d628ffb4af15c5f2a9e8648/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=c77979b419959dda0d628ffb4af15c5f2a9e8648", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n-use hir::def_id::DefId;\n-use mir::repr::Mir;\n-use std::marker::PhantomData;\n-\n-pub struct MirMap<'tcx> {\n-    pub map: DepTrackingMap<MirMapConfig<'tcx>>,\n-}\n-\n-impl<'tcx> MirMap<'tcx> {\n-    pub fn new(graph: DepGraph) -> Self {\n-        MirMap {\n-            map: DepTrackingMap::new(graph)\n-        }\n-    }\n-}\n-\n-pub struct MirMapConfig<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for MirMapConfig<'tcx> {\n-    type Key = DefId;\n-    type Value = Mir<'tcx>;\n-    fn to_dep_node(key: &DefId) -> DepNode<DefId> {\n-        DepNode::Mir(*key)\n-    }\n-}"}, {"sha": "9d82006ac9f9df244df43c0fb5e734bbdc4fc0d1", "filename": "src/librustc/mir/mod.rs", "status": "renamed", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -32,7 +32,11 @@ use std::vec::IntoIter;\n use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n-use super::cache::Cache;\n+mod cache;\n+pub mod tcx;\n+pub mod visit;\n+pub mod transform;\n+pub mod traversal;\n \n macro_rules! newtype_index {\n     ($name:ident, $debug_name:expr) => (\n@@ -59,7 +63,8 @@ macro_rules! newtype_index {\n }\n \n /// Lowered representation of a single function.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+// Do not implement clone for Mir, its easy to do so accidently and its kind of expensive.\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -106,7 +111,7 @@ pub struct Mir<'tcx> {\n     pub span: Span,\n \n     /// A cache for various calculations\n-    cache: Cache\n+    cache: cache::Cache\n }\n \n /// where execution begins\n@@ -137,7 +142,7 @@ impl<'tcx> Mir<'tcx> {\n             upvar_decls: upvar_decls,\n             spread_arg: None,\n             span: span,\n-            cache: Cache::new()\n+            cache: cache::Cache::new()\n         }\n     }\n \n@@ -1138,8 +1143,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     AggregateKind::Adt(adt_def, variant, substs, _) => {\n                         let variant_def = &adt_def.variants[variant];\n \n-                        ppaux::parameterized(fmt, substs, variant_def.did,\n-                                             ppaux::Ns::Value, &[])?;\n+                        ppaux::parameterized(fmt, substs, variant_def.did, &[])?;\n \n                         match variant_def.ctor_kind {\n                             CtorKind::Const => Ok(()),\n@@ -1234,7 +1238,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n         use self::Literal::*;\n         match *self {\n             Item { def_id, substs } => {\n-                ppaux::parameterized(fmt, substs, def_id, ppaux::Ns::Value, &[])\n+                ppaux::parameterized(fmt, substs, def_id, &[])\n             }\n             Value { ref value } => {\n                 write!(fmt, \"const \")?;", "previous_filename": "src/librustc/mir/repr.rs"}, {"sha": "f9afbaf104a663048df411e654afc08bc50d9936", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@\n  * building is complete.\n  */\n \n-use mir::repr::*;\n+use mir::*;\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};"}, {"sha": "3576ae662a005033e1a5f200327b9d03228dfa75", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,8 +11,7 @@\n use dep_graph::DepNode;\n use hir;\n use hir::map::DefPathData;\n-use mir::mir_map::MirMap;\n-use mir::repr::{Mir, Promoted};\n+use mir::{Mir, Promoted};\n use ty::TyCtxt;\n use syntax::ast::NodeId;\n use util::common::time;\n@@ -85,12 +84,11 @@ pub trait Pass {\n     fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> { None }\n }\n \n-/// A pass which inspects the whole MirMap.\n+/// A pass which inspects the whole Mir map.\n pub trait MirMapPass<'tcx>: Pass {\n     fn run_pass<'a>(\n         &mut self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        map: &mut MirMap<'tcx>,\n         hooks: &mut [Box<for<'s> MirPassHook<'s>>]);\n }\n \n@@ -114,13 +112,18 @@ pub trait MirPass<'tcx>: Pass {\n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n     fn run_pass<'a>(&mut self,\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    map: &mut MirMap<'tcx>,\n                     hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n     {\n-        let def_ids = map.map.keys();\n+        let def_ids = tcx.mir_map.borrow().keys();\n         for def_id in def_ids {\n+            if !def_id.is_local() {\n+                continue;\n+            }\n+\n             let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let mir = map.map.get_mut(&def_id).unwrap();\n+            let mir = &mut tcx.mir_map.borrow()[&def_id].borrow_mut();\n+            tcx.dep_graph.write(DepNode::Mir(def_id));\n+\n             let id = tcx.map.as_local_node_id(def_id).unwrap();\n             let src = MirSource::from_node(tcx, id);\n \n@@ -163,11 +166,11 @@ impl<'a, 'tcx> Passes {\n         passes\n     }\n \n-    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n+    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let Passes { ref mut passes, ref mut plugin_passes, ref mut pass_hooks } = *self;\n         for pass in plugin_passes.iter_mut().chain(passes.iter_mut()) {\n             time(tcx.sess.time_passes(), &*pass.name(),\n-                 || pass.run_pass(tcx, map, pass_hooks));\n+                 || pass.run_pass(tcx, pass_hooks));\n         }\n     }\n "}, {"sha": "6057e7ec7e0f5164c2606941eb4a47331a01d12d", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@ use std::vec;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::repr::*;\n+use super::*;\n \n /// Preorder traversal of a graph.\n ///"}, {"sha": "db7267ca0d4b888f340c46f85a369988fa3bc2d8", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,7 +12,7 @@ use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty};\n-use mir::repr::*;\n+use mir::*;\n use rustc_const_math::ConstUsize;\n use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "7b5413984a20504177a03783630aefb05e1f8ad4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1237,10 +1237,9 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.into_iter().map(|s| {\n         let sess = parse::ParseSess::new();\n-        let mut parser = parse::new_parser_from_source_str(&sess,\n-                                                           Vec::new(),\n-                                                           \"cfgspec\".to_string(),\n-                                                           s.to_string());\n+        let mut parser =\n+            parse::new_parser_from_source_str(&sess, \"cfgspec\".to_string(), s.to_string());\n+\n         let meta_item = panictry!(parser.parse_meta_item());\n \n         if !parser.reader.is_eof() {"}, {"sha": "62cc78141db468847f0cd70c59b390addb611e62", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -22,6 +22,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n+use mir::Mir;\n use ty::subst::{Kind, Substs};\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n@@ -65,8 +66,9 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n-    trait_defs: TypedArena<ty::TraitDef<'tcx>>,\n-    adt_defs: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+    trait_def: TypedArena<ty::TraitDef<'tcx>>,\n+    adt_def: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+    mir: TypedArena<RefCell<Mir<'tcx>>>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -81,8 +83,9 @@ impl<'tcx> CtxtArenas<'tcx> {\n             layout: TypedArena::new(),\n \n             generics: TypedArena::new(),\n-            trait_defs: TypedArena::new(),\n-            adt_defs: TypedArena::new()\n+            trait_def: TypedArena::new(),\n+            adt_def: TypedArena::new(),\n+            mir: TypedArena::new()\n         }\n     }\n }\n@@ -358,6 +361,15 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub map: ast_map::Map<'tcx>,\n \n+    /// Maps from the def-id of a function/method or const/static\n+    /// to its MIR. Mutation is done at an item granularity to\n+    /// allow MIR optimization passes to function and still\n+    /// access cross-crate MIR (e.g. inlining or const eval).\n+    ///\n+    /// Note that cross-crate MIR appears to be always borrowed\n+    /// (in the `RefCell` sense) to prevent accidental mutation.\n+    pub mir_map: RefCell<DepTrackingMap<maps::Mir<'tcx>>>,\n+\n     // Records the free variables refrenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n@@ -604,6 +616,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.generics.alloc(generics)\n     }\n \n+    pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx RefCell<Mir<'gcx>> {\n+        self.global_interners.arenas.mir.alloc(RefCell::new(mir))\n+    }\n+\n     pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n                             -> &'gcx ty::TraitDef<'gcx> {\n         let did = def.trait_ref.def_id;\n@@ -617,7 +633,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn alloc_trait_def(self, def: ty::TraitDef<'gcx>)\n                            -> &'gcx ty::TraitDef<'gcx> {\n-        self.global_interners.arenas.trait_defs.alloc(def)\n+        self.global_interners.arenas.trait_def.alloc(def)\n     }\n \n     pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n@@ -633,7 +649,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                           variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n                           -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n-        let interned = self.global_interners.arenas.adt_defs.alloc(def);\n+        let interned = self.global_interners.arenas.adt_def.alloc(def);\n         self.insert_adt_def(did, interned);\n         interned\n     }\n@@ -738,6 +754,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             map: map,\n+            mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             freevars: RefCell::new(freevars),\n             maybe_unused_trait_imports: maybe_unused_trait_imports,\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "cad87081a93b4a59e3dc63bab26fe8552a6bc0ac", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,10 @@\n \n use dep_graph::{DepNode, DepTrackingMapConfig};\n use hir::def_id::DefId;\n+use mir;\n use ty::{self, Ty};\n+\n+use std::cell::RefCell;\n use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::{attr, ast};\n@@ -43,3 +46,4 @@ dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { InlinedClosures: Hir(DefId) -> ast::NodeId }\n+dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }"}, {"sha": "588857e557c22fce71271141a104d135918afb1e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,6 +24,7 @@ use hir::def::{Def, CtorKind, PathResolution, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n+use mir::Mir;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n@@ -34,7 +35,7 @@ use util::nodemap::FnvHashMap;\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::ops::Deref;\n@@ -1698,7 +1699,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         match def {\n             Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n+            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n@@ -2519,6 +2520,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n     }\n \n+    /// Given the did of an item, returns its MIR, borrowed immutably.\n+    pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n+        lookup_locally_or_in_crate_store(\"mir_map\", did, &self.mir_map, || {\n+            let mir = self.sess.cstore.get_item_mir(self.global_tcx(), did);\n+            let mir = self.alloc_mir(mir);\n+\n+            // Perma-borrow MIR from extern crates to prevent mutation.\n+            mem::forget(mir.borrow());\n+\n+            mir\n+        }).borrow()\n+    }\n+\n     /// If `type_needs_drop` returns true, then `ty` is definitely\n     /// non-copy and *might* have a destructor attached; if it returns\n     /// false, then `ty` definitely has no destructor (i.e. no drop glue)."}, {"sha": "cca4069ba5a1799255be43dfd653e6d6b2f63ff5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -405,6 +405,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n ///\n /// The same goes for endianess: We always convert multi-byte integers to little\n /// endian before hashing.\n+#[derive(Debug)]\n pub struct ArchIndependentHasher<H> {\n     inner: H,\n }\n@@ -413,6 +414,10 @@ impl<H> ArchIndependentHasher<H> {\n     pub fn new(inner: H) -> ArchIndependentHasher<H> {\n         ArchIndependentHasher { inner: inner }\n     }\n+\n+    pub fn into_inner(self) -> H {\n+        self.inner\n+    }\n }\n \n impl<H: Hasher> Hasher for ArchIndependentHasher<H> {"}, {"sha": "5ca567410291ad3edacf7647aa810913a965b42b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -9,12 +9,13 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n+use hir::map::definitions::DefPathData;\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n-use ty::TyClosure;\n+use ty::{TyClosure, TyProjection, TyAnon};\n use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::{TypeFolder, TypeVisitor};\n@@ -56,17 +57,9 @@ fn fn_sig(f: &mut fmt::Formatter,\n     Ok(())\n }\n \n-/// Namespace of the path given to parameterized to print.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum Ns {\n-    Type,\n-    Value\n-}\n-\n pub fn parameterized(f: &mut fmt::Formatter,\n                      substs: &subst::Substs,\n                      did: DefId,\n-                     ns: Ns,\n                      projections: &[ty::ProjectionPredicate])\n                      -> fmt::Result {\n     let mut verbose = false;\n@@ -75,16 +68,42 @@ pub fn parameterized(f: &mut fmt::Formatter,\n     let mut num_regions = 0;\n     let mut num_types = 0;\n     let mut item_name = None;\n+    let mut is_value_path = false;\n     let fn_trait_kind = ty::tls::with(|tcx| {\n-        let mut generics = tcx.lookup_generics(did);\n+        // Unfortunately, some kinds of items (e.g., closures) don't have\n+        // generics. So walk back up the find the closest parent that DOES\n+        // have them.\n+        let mut item_def_id = did;\n+        loop {\n+            let key = tcx.def_key(item_def_id);\n+            match key.disambiguated_data.data {\n+                DefPathData::TypeNs(_) => {\n+                    break;\n+                }\n+                DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n+                    is_value_path = true;\n+                    break;\n+                }\n+                _ => {\n+                    // if we're making a symbol for something, there ought\n+                    // to be a value or type-def or something in there\n+                    // *somewhere*\n+                    item_def_id.index = key.parent.unwrap_or_else(|| {\n+                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                             parent\", did, item_def_id);\n+                    });\n+                }\n+            }\n+        }\n+        let mut generics = tcx.lookup_generics(item_def_id);\n         let mut path_def_id = did;\n         verbose = tcx.sess.verbose();\n         has_self = generics.has_self;\n \n         let mut child_types = 0;\n         if let Some(def_id) = generics.parent {\n             // Methods.\n-            assert_eq!(ns, Ns::Value);\n+            assert!(is_value_path);\n             child_types = generics.types.len();\n             generics = tcx.lookup_generics(def_id);\n             num_regions = generics.regions.len();\n@@ -97,7 +116,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             item_name = Some(tcx.item_name(did));\n             path_def_id = def_id;\n         } else {\n-            if ns == Ns::Value {\n+            if is_value_path {\n                 // Functions.\n                 assert_eq!(has_self, false);\n             } else {\n@@ -192,7 +211,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n     start_or_continue(f, \"\", \">\")?;\n \n     // For values, also print their name and type parameters.\n-    if ns == Ns::Value {\n+    if is_value_path {\n         empty.set(true);\n \n         if has_self {\n@@ -298,7 +317,6 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n         let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n         parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n-                      Ns::Type,\n                       projection_bounds)\n     }\n }\n@@ -398,7 +416,7 @@ impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n             let trait_ref = tcx.lift(&ty::Binder(*self))\n                                .expect(\"could not lift TraitRef for printing\")\n                                .with_self_ty(tcx, dummy_self).0;\n-            parameterized(f, trait_ref.substs, trait_ref.def_id, Ns::Type, &[])\n+            parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n         })\n     }\n }\n@@ -798,7 +816,7 @@ impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<&'tcx ty::Region,\n \n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, Ns::Type, &[])\n+        parameterized(f, self.substs, self.def_id, &[])\n     }\n }\n \n@@ -851,7 +869,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 }\n \n                 write!(f, \"{} {{\", bare_fn.sig.0)?;\n-                parameterized(f, substs, def_id, Ns::Value, &[])?;\n+                parameterized(f, substs, def_id, &[])?;\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n@@ -874,13 +892,13 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(f, substs, def.did, Ns::Type, &[])\n+                        parameterized(f, substs, def.did, &[])\n                     }\n                 })\n             }\n             TyTrait(ref data) => write!(f, \"{}\", data),\n-            ty::TyProjection(ref data) => write!(f, \"{}\", data),\n-            ty::TyAnon(def_id, substs) => {\n+            TyProjection(ref data) => write!(f, \"{}\", data),\n+            TyAnon(def_id, substs) => {\n                 ty::tls::with(|tcx| {\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id."}, {"sha": "da5f787bdf31e3d9be859acdef4e83e178722215", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -36,9 +36,8 @@\n #![feature(rand)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(step_by)]\n #![cfg_attr(stage0, feature(question_mark))]\n-#![cfg_attr(test, feature(test, rand))]\n+#![cfg_attr(test, feature(rand))]\n \n extern crate syntax;\n extern crate libc;\n@@ -48,7 +47,6 @@ extern crate serialize;\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod tempdir;\n-pub mod sha2;\n pub mod target;\n pub mod slice;\n pub mod dynamic_lib;"}, {"sha": "97fb39c17ea0e58e77aec4bdca3a9ca5cefdd58f", "filename": "src/librustc_back/sha2.rs", "status": "removed", "additions": 0, "deletions": 679, "changes": 679, "blob_url": "https://github.com/rust-lang/rust/blob/c77979b419959dda0d628ffb4af15c5f2a9e8648/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77979b419959dda0d628ffb4af15c5f2a9e8648/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=c77979b419959dda0d628ffb4af15c5f2a9e8648", "patch": "@@ -1,679 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This module implements only the Sha256 function since that is all that is needed for internal\n-//! use. This implementation is not intended for external use or for any use where security is\n-//! important.\n-\n-use serialize::hex::ToHex;\n-\n-/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n-/// format.\n-fn write_u32_be(dst: &mut[u8], input: u32) {\n-    dst[0] = (input >> 24) as u8;\n-    dst[1] = (input >> 16) as u8;\n-    dst[2] = (input >> 8) as u8;\n-    dst[3] = input as u8;\n-}\n-\n-/// Read the value of a vector of bytes as a u32 value in big-endian format.\n-fn read_u32_be(input: &[u8]) -> u32 {\n-    (input[0] as u32) << 24 |\n-        (input[1] as u32) << 16 |\n-        (input[2] as u32) << 8 |\n-        (input[3] as u32)\n-}\n-\n-/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n-fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    assert!(dst.len() * 4 == input.len());\n-    let mut pos = 0;\n-    for chunk in input.chunks(4) {\n-        dst[pos] = read_u32_be(chunk);\n-        pos += 1;\n-    }\n-}\n-\n-trait ToBits: Sized {\n-    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n-    /// high-order value and the 2nd item is the low order value.\n-    fn to_bits(self) -> (Self, Self);\n-}\n-\n-impl ToBits for u64 {\n-    fn to_bits(self) -> (u64, u64) {\n-        (self >> 61, self << 3)\n-    }\n-}\n-\n-/// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n-/// overflow.\n-fn add_bytes_to_bits(bits: u64, bytes: u64) -> u64 {\n-    let (new_high_bits, new_low_bits) = bytes.to_bits();\n-\n-    if new_high_bits > 0 {\n-        panic!(\"numeric overflow occurred.\")\n-    }\n-\n-    match bits.checked_add(new_low_bits) {\n-        Some(x) => x,\n-        None => panic!(\"numeric overflow occurred.\")\n-    }\n-}\n-\n-/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n-/// must be processed. The input() method takes care of processing and then clearing the buffer\n-/// automatically. However, other methods do not and require the caller to process the buffer. Any\n-/// method that modifies the buffer directory or provides the caller with bytes that can be modified\n-/// results in those bytes being marked as used by the buffer.\n-trait FixedBuffer {\n-    /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n-    /// function and then clear the buffer.\n-    fn input<F>(&mut self, input: &[u8], func: F) where\n-        F: FnMut(&[u8]);\n-\n-    /// Reset the buffer.\n-    fn reset(&mut self);\n-\n-    /// Zero the buffer up until the specified index. The buffer position currently must not be\n-    /// greater than that index.\n-    fn zero_until(&mut self, idx: usize);\n-\n-    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n-    /// remaining in the buffer.\n-    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8];\n-\n-    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n-\n-    /// Get the current position of the buffer.\n-    fn position(&self) -> usize;\n-\n-    /// Get the number of bytes remaining in the buffer until it is full.\n-    fn remaining(&self) -> usize;\n-\n-    /// Get the size of the buffer\n-    fn size(&self) -> usize;\n-}\n-\n-/// A FixedBuffer of 64 bytes useful for implementing Sha256 which has a 64 byte blocksize.\n-struct FixedBuffer64 {\n-    buffer: [u8; 64],\n-    buffer_idx: usize,\n-}\n-\n-impl FixedBuffer64 {\n-    /// Create a new FixedBuffer64\n-    fn new() -> FixedBuffer64 {\n-        FixedBuffer64 {\n-            buffer: [0; 64],\n-            buffer_idx: 0\n-        }\n-    }\n-}\n-\n-impl FixedBuffer for FixedBuffer64 {\n-    fn input<F>(&mut self, input: &[u8], mut func: F) where\n-        F: FnMut(&[u8]),\n-    {\n-        let mut i = 0;\n-\n-        let size = self.size();\n-\n-        // If there is already data in the buffer, copy as much as we can into it and process\n-        // the data if the buffer becomes full.\n-        if self.buffer_idx != 0 {\n-            let buffer_remaining = size - self.buffer_idx;\n-            if input.len() >= buffer_remaining {\n-                self.buffer[self.buffer_idx..size]\n-                    .copy_from_slice(&input[..buffer_remaining]);\n-                self.buffer_idx = 0;\n-                func(&self.buffer);\n-                i += buffer_remaining;\n-            } else {\n-                self.buffer[self.buffer_idx..self.buffer_idx + input.len()]\n-                    .copy_from_slice(input);\n-                self.buffer_idx += input.len();\n-                return;\n-            }\n-        }\n-\n-        // While we have at least a full buffer size chunk's worth of data, process that data\n-        // without copying it into the buffer\n-        while input.len() - i >= size {\n-            func(&input[i..i + size]);\n-            i += size;\n-        }\n-\n-        // Copy any input data into the buffer. At this point in the method, the amount of\n-        // data left in the input vector will be less than the buffer size and the buffer will\n-        // be empty.\n-        let input_remaining = input.len() - i;\n-        self.buffer[..input_remaining].copy_from_slice(&input[i..]);\n-        self.buffer_idx += input_remaining;\n-    }\n-\n-    fn reset(&mut self) {\n-        self.buffer_idx = 0;\n-    }\n-\n-    fn zero_until(&mut self, idx: usize) {\n-        assert!(idx >= self.buffer_idx);\n-        for slot in self.buffer[self.buffer_idx..idx].iter_mut() {\n-            *slot = 0;\n-        }\n-        self.buffer_idx = idx;\n-    }\n-\n-    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8] {\n-        self.buffer_idx += len;\n-        &mut self.buffer[self.buffer_idx - len..self.buffer_idx]\n-    }\n-\n-    fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n-        assert!(self.buffer_idx == 64);\n-        self.buffer_idx = 0;\n-        &self.buffer[..64]\n-    }\n-\n-    fn position(&self) -> usize { self.buffer_idx }\n-\n-    fn remaining(&self) -> usize { 64 - self.buffer_idx }\n-\n-    fn size(&self) -> usize { 64 }\n-}\n-\n-/// The StandardPadding trait adds a method useful for Sha256 to a FixedBuffer struct.\n-trait StandardPadding {\n-    /// Add padding to the buffer. The buffer must not be full when this method is called and is\n-    /// guaranteed to have exactly rem remaining bytes when it returns. If there are not at least\n-    /// rem bytes available, the buffer will be zero padded, processed, cleared, and then filled\n-    /// with zeros again until only rem bytes are remaining.\n-    fn standard_padding<F>(&mut self, rem: usize, func: F) where F: FnMut(&[u8]);\n-}\n-\n-impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding<F>(&mut self, rem: usize, mut func: F) where F: FnMut(&[u8]) {\n-        let size = self.size();\n-\n-        self.next(1)[0] = 128;\n-\n-        if self.remaining() < rem {\n-            self.zero_until(size);\n-            func(self.full_buffer());\n-        }\n-\n-        self.zero_until(size - rem);\n-    }\n-}\n-\n-/// The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n-/// family of digest functions.\n-pub trait Digest {\n-    /// Provide message data.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * input - A vector of message data\n-    fn input(&mut self, input: &[u8]);\n-\n-    /// Retrieve the digest result. This method may be called multiple times.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * out - the vector to hold the result. Must be large enough to contain output_bits().\n-    fn result(&mut self, out: &mut [u8]);\n-\n-    /// Reset the digest. This method must be called after result() and before supplying more\n-    /// data.\n-    fn reset(&mut self);\n-\n-    /// Get the output size in bits.\n-    fn output_bits(&self) -> usize;\n-\n-    /// Convenience function that feeds a string into a digest.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `input` The string to feed into the digest\n-    fn input_str(&mut self, input: &str) {\n-        self.input(input.as_bytes());\n-    }\n-\n-    /// Convenience function that retrieves the result of a digest as a\n-    /// newly allocated vec of bytes.\n-    fn result_bytes(&mut self) -> Vec<u8> {\n-        let mut buf = vec![0; (self.output_bits()+7)/8];\n-        self.result(&mut buf);\n-        buf\n-    }\n-\n-    /// Convenience function that retrieves the result of a digest as a\n-    /// String in hexadecimal format.\n-    fn result_str(&mut self) -> String {\n-        self.result_bytes().to_hex().to_string()\n-    }\n-}\n-\n-// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n-// functions\n-struct Engine256State {\n-    h0: u32,\n-    h1: u32,\n-    h2: u32,\n-    h3: u32,\n-    h4: u32,\n-    h5: u32,\n-    h6: u32,\n-    h7: u32,\n-}\n-\n-impl Engine256State {\n-    fn new(h: &[u32; 8]) -> Engine256State {\n-        Engine256State {\n-            h0: h[0],\n-            h1: h[1],\n-            h2: h[2],\n-            h3: h[3],\n-            h4: h[4],\n-            h5: h[5],\n-            h6: h[6],\n-            h7: h[7]\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u32; 8]) {\n-        self.h0 = h[0];\n-        self.h1 = h[1];\n-        self.h2 = h[2];\n-        self.h3 = h[3];\n-        self.h4 = h[4];\n-        self.h5 = h[5];\n-        self.h6 = h[6];\n-        self.h7 = h[7];\n-    }\n-\n-    fn process_block(&mut self, data: &[u8]) {\n-        fn ch(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ ((!x) & z))\n-        }\n-\n-        fn maj(x: u32, y: u32, z: u32) -> u32 {\n-            ((x & y) ^ (x & z) ^ (y & z))\n-        }\n-\n-        fn sum0(x: u32) -> u32 {\n-            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n-        }\n-\n-        fn sum1(x: u32) -> u32 {\n-            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n-        }\n-\n-        fn sigma0(x: u32) -> u32 {\n-            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n-        }\n-\n-        fn sigma1(x: u32) -> u32 {\n-            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n-        }\n-\n-        let mut a = self.h0;\n-        let mut b = self.h1;\n-        let mut c = self.h2;\n-        let mut d = self.h3;\n-        let mut e = self.h4;\n-        let mut f = self.h5;\n-        let mut g = self.h6;\n-        let mut h = self.h7;\n-\n-        let mut w = [0; 64];\n-\n-        // Sha-512 and Sha-256 use basically the same calculations which are implemented\n-        // by these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round { ($t:expr) => (\n-            w[$t] = sigma1(w[$t - 2]).wrapping_add(w[$t - 7])\n-                .wrapping_add(sigma0(w[$t - 15])).wrapping_add(w[$t - 16]);\n-            )\n-        }\n-\n-        macro_rules! sha2_round {\n-            ($A:ident, $B:ident, $C:ident, $D:ident,\n-             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n-                {\n-                    $H = $H.wrapping_add(sum1($E)).wrapping_add(ch($E, $F, $G))\n-                        .wrapping_add($K[$t]).wrapping_add(w[$t]);\n-                    $D = $D.wrapping_add($H);\n-                    $H = $H.wrapping_add(sum0($A)).wrapping_add(maj($A, $B, $C));\n-                }\n-             )\n-        }\n-\n-        read_u32v_be(&mut w[0..16], data);\n-\n-        // Putting the message schedule inside the same loop as the round calculations allows for\n-        // the compiler to generate better code.\n-        for t in (0..48).step_by(8) {\n-            schedule_round!(t + 16);\n-            schedule_round!(t + 17);\n-            schedule_round!(t + 18);\n-            schedule_round!(t + 19);\n-            schedule_round!(t + 20);\n-            schedule_round!(t + 21);\n-            schedule_round!(t + 22);\n-            schedule_round!(t + 23);\n-\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        for t in (48..64).step_by(8) {\n-            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n-            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n-            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n-            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n-            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n-            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n-            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n-            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n-        }\n-\n-        self.h0 = self.h0.wrapping_add(a);\n-        self.h1 = self.h1.wrapping_add(b);\n-        self.h2 = self.h2.wrapping_add(c);\n-        self.h3 = self.h3.wrapping_add(d);\n-        self.h4 = self.h4.wrapping_add(e);\n-        self.h5 = self.h5.wrapping_add(f);\n-        self.h6 = self.h6.wrapping_add(g);\n-        self.h7 = self.h7.wrapping_add(h);\n-    }\n-}\n-\n-static K32: [u32; 64] = [\n-    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n-    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n-    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n-    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n-    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n-    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n-    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n-    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n-    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n-    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n-    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n-    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n-    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n-    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n-    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n-    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n-];\n-\n-// A structure that keeps track of the state of the Sha-256 operation and contains the logic\n-// necessary to perform the final calculations.\n-struct Engine256 {\n-    length_bits: u64,\n-    buffer: FixedBuffer64,\n-    state: Engine256State,\n-    finished: bool,\n-}\n-\n-impl Engine256 {\n-    fn new(h: &[u32; 8]) -> Engine256 {\n-        Engine256 {\n-            length_bits: 0,\n-            buffer: FixedBuffer64::new(),\n-            state: Engine256State::new(h),\n-            finished: false\n-        }\n-    }\n-\n-    fn reset(&mut self, h: &[u32; 8]) {\n-        self.length_bits = 0;\n-        self.buffer.reset();\n-        self.state.reset(h);\n-        self.finished = false;\n-    }\n-\n-    fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished);\n-        // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n-        let self_state = &mut self.state;\n-        self.buffer.input(input, |input: &[u8]| { self_state.process_block(input) });\n-    }\n-\n-    fn finish(&mut self) {\n-        if !self.finished {\n-            let self_state = &mut self.state;\n-            self.buffer.standard_padding(8, |input: &[u8]| { self_state.process_block(input) });\n-            write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n-            write_u32_be(self.buffer.next(4), self.length_bits as u32);\n-            self_state.process_block(self.buffer.full_buffer());\n-\n-            self.finished = true;\n-        }\n-    }\n-}\n-\n-/// The SHA-256 hash algorithm\n-pub struct Sha256 {\n-    engine: Engine256\n-}\n-\n-impl Sha256 {\n-    /// Construct a new instance of a SHA-256 digest.\n-    /// Do not \u2013 under any circumstances \u2013 use this where timing attacks might be possible!\n-    pub fn new() -> Sha256 {\n-        Sha256 {\n-            engine: Engine256::new(&H256)\n-        }\n-    }\n-}\n-\n-impl Digest for Sha256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.finish();\n-\n-        write_u32_be(&mut out[0..4], self.engine.state.h0);\n-        write_u32_be(&mut out[4..8], self.engine.state.h1);\n-        write_u32_be(&mut out[8..12], self.engine.state.h2);\n-        write_u32_be(&mut out[12..16], self.engine.state.h3);\n-        write_u32_be(&mut out[16..20], self.engine.state.h4);\n-        write_u32_be(&mut out[20..24], self.engine.state.h5);\n-        write_u32_be(&mut out[24..28], self.engine.state.h6);\n-        write_u32_be(&mut out[28..32], self.engine.state.h7);\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset(&H256);\n-    }\n-\n-    fn output_bits(&self) -> usize { 256 }\n-}\n-\n-static H256: [u32; 8] = [\n-    0x6a09e667,\n-    0xbb67ae85,\n-    0x3c6ef372,\n-    0xa54ff53a,\n-    0x510e527f,\n-    0x9b05688c,\n-    0x1f83d9ab,\n-    0x5be0cd19\n-];\n-\n-#[cfg(test)]\n-mod tests {\n-    #![allow(deprecated)]\n-    extern crate rand;\n-\n-    use self::rand::Rng;\n-    use self::rand::isaac::IsaacRng;\n-    use serialize::hex::FromHex;\n-    use std::u64;\n-    use super::{Digest, Sha256};\n-\n-    // A normal addition - no overflow occurs\n-    #[test]\n-    fn test_add_bytes_to_bits_ok() {\n-        assert!(super::add_bytes_to_bits(100, 10) == 180);\n-    }\n-\n-    // A simple failure case - adding 1 to the max value\n-    #[test]\n-    #[should_panic]\n-    fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits(u64::MAX, 1);\n-    }\n-\n-    struct Test {\n-        input: String,\n-        output_str: String,\n-    }\n-\n-    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n-        // Test that it works when accepting the message all at once\n-        for t in tests {\n-            sh.reset();\n-            sh.input_str(&t.input);\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-        }\n-\n-        // Test that it works when accepting the message in pieces\n-        for t in tests {\n-            sh.reset();\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0 {\n-                let take = (left + 1) / 2;\n-                sh.input_str(&t.input[len - left..take + len - left]);\n-                left = left - take;\n-            }\n-            let out_str = sh.result_str();\n-            assert!(out_str == t.output_str);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sha256() {\n-        // Examples from wikipedia\n-        let wikipedia_tests = vec!(\n-            Test {\n-                input: \"\".to_string(),\n-                output_str: \"e3b0c44298fc1c149afb\\\n-            f4c8996fb92427ae41e4649b934ca495991b7852b855\".to_string()\n-            },\n-            Test {\n-                input: \"The quick brown fox jumps over the lazy \\\n-                        dog\".to_string(),\n-                output_str: \"d7a8fbb307d7809469ca\\\n-            9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\".to_string()\n-            },\n-            Test {\n-                input: \"The quick brown fox jumps over the lazy \\\n-                        dog.\".to_string(),\n-                output_str: \"ef537f25c895bfa78252\\\n-            6529a9b63d97aa631564d5d789c2b765448c8635fb6c\".to_string()\n-            });\n-\n-        let tests = wikipedia_tests;\n-\n-        let mut sh: Box<_> = box Sha256::new();\n-\n-        test_hash(&mut *sh, &tests);\n-    }\n-\n-    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n-    /// correct.\n-    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: usize, expected: &str) {\n-        let total_size = 1000000;\n-        let buffer = vec![b'a'; blocksize * 2];\n-        let mut rng = IsaacRng::new_unseeded();\n-        let mut count = 0;\n-\n-        digest.reset();\n-\n-        while count < total_size {\n-            let next: usize = rng.gen_range(0, 2 * blocksize + 1);\n-            let remaining = total_size - count;\n-            let size = if next > remaining { remaining } else { next };\n-            digest.input(&buffer[..size]);\n-            count += size;\n-        }\n-\n-        let result_str = digest.result_str();\n-        let result_bytes = digest.result_bytes();\n-\n-        assert_eq!(expected, result_str);\n-\n-        let expected_vec: Vec<u8> = expected.from_hex()\n-                                            .unwrap()\n-                                            .into_iter()\n-                                            .collect();\n-        assert_eq!(expected_vec, result_bytes);\n-    }\n-\n-    #[test]\n-    fn test_1million_random_sha256() {\n-        let mut sh = Sha256::new();\n-        test_digest_1million_random(\n-            &mut sh,\n-            64,\n-            \"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use super::{Sha256, Digest};\n-\n-    #[bench]\n-    pub fn sha256_10(b: &mut Bencher) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1; 10];\n-        b.iter(|| {\n-            sh.input(&bytes);\n-        });\n-        b.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_1k(b: &mut Bencher) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1; 1024];\n-        b.iter(|| {\n-            sh.input(&bytes);\n-        });\n-        b.bytes = bytes.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn sha256_64k(b: &mut Bencher) {\n-        let mut sh = Sha256::new();\n-        let bytes = [1; 65536];\n-        b.iter(|| {\n-            sh.input(&bytes);\n-        });\n-        b.bytes = bytes.len() as u64;\n-    }\n-}"}, {"sha": "a93a46d140238dabd7cd9122be1c20fbdf1e1b70", "filename": "src/librustc_back/target/aarch64_unknown_fuchsia.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::fuchsia_base::opts();\n+    base.max_atomic_width = Some(128);\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-fuchsia\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"fuchsia\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "5f6335d405f5ea40fe49b1e7827c51a9ecc6ead1", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,6 +13,10 @@ use target::{Target, TargetOptions, TargetResult};\n pub fn target() -> TargetResult {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = Some(128);\n+\n+    // see #36994\n+    base.exe_allocation_crate = \"alloc_system\".to_string();\n+\n     Ok(Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "c284840ecb4bdbdc3b06714732a85fabbe51d93d", "filename": "src/librustc_back/target/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,6 +25,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips64r2\".to_string(),\n             features: \"+mips64r2\".to_string(),\n             max_atomic_width: Some(64),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "17895836fe87b54dba7020dbd5b2d00be9c0ecfd", "filename": "src/librustc_back/target/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,6 +25,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips64r2\".to_string(),\n             features: \"+mips64r2\".to_string(),\n             max_atomic_width: Some(64),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "a6d8fae2536cae8628ab3d3b09fb64553ff442d1", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,6 +24,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips32r2\".to_string(),\n             features: \"+mips32r2\".to_string(),\n             max_atomic_width: Some(32),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "e4a6d2a55d9813ea4ea188540edae6126447ff1d", "filename": "src/librustc_back/target/mips_unknown_linux_musl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,6 +24,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips32r2\".to_string(),\n             features: \"+mips32r2,+soft-float\".to_string(),\n             max_atomic_width: Some(32),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         }\n     })"}, {"sha": "ccc64ea393b7885694640f22b6373ed7dfedf4f3", "filename": "src/librustc_back/target/mips_unknown_linux_uclibc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,6 +24,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips32r2\".to_string(),\n             features: \"+mips32r2,+soft-float\".to_string(),\n             max_atomic_width: Some(32),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "9b8b1d5713f1d950771a36d3da49fe750208d944", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,6 +25,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips32\".to_string(),\n             features: \"+mips32\".to_string(),\n             max_atomic_width: Some(32),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "5693bddd0488a51c780e53dbc07c2e641748e345", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,6 +24,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips32\".to_string(),\n             features: \"+mips32,+soft-float\".to_string(),\n             max_atomic_width: Some(32),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         }\n     })"}, {"sha": "3acade5a474445f1431585dbc0d62a79fed5a369", "filename": "src/librustc_back/target/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,6 +25,10 @@ pub fn target() -> TargetResult {\n             cpu: \"mips32\".to_string(),\n             features: \"+mips32,+soft-float\".to_string(),\n             max_atomic_width: Some(32),\n+\n+            // see #36994\n+            exe_allocation_crate: \"alloc_system\".to_string(),\n+\n             ..super::linux_base::opts()\n         },\n     })"}, {"sha": "4d9315a1a3bdb7b556e7e0cb7948dba6c3106329", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -177,6 +177,7 @@ supported_targets! {\n     (\"x86_64-apple-darwin\", x86_64_apple_darwin),\n     (\"i686-apple-darwin\", i686_apple_darwin),\n \n+    (\"aarch64-unknown-fuchsia\", aarch64_unknown_fuchsia),\n     (\"x86_64-unknown-fuchsia\", x86_64_unknown_fuchsia),\n \n     (\"i386-apple-ios\", i386_apple_ios),"}, {"sha": "909c5488dcb70374eaae5535870fe9606428af24", "filename": "src/librustc_back/target/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,6 +16,9 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n \n+    // see #36994\n+    base.exe_allocation_crate = \"alloc_system\".to_string();\n+\n     Ok(Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),"}, {"sha": "a692346ca0ffeeb95a88bf2183f3eea8b6ca4f90", "filename": "src/librustc_back/target/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,6 +16,9 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n \n+    // see #36994\n+    base.exe_allocation_crate = \"alloc_system\".to_string();\n+\n     Ok(Target {\n         llvm_target: \"powerpc64le-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),"}, {"sha": "284772c43319aedf193fd12af276ea1586adbd14", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,6 +15,9 @@ pub fn target() -> TargetResult {\n     base.pre_link_args.push(\"-m32\".to_string());\n     base.max_atomic_width = Some(32);\n \n+    // see #36994\n+    base.exe_allocation_crate = \"alloc_system\".to_string();\n+\n     Ok(Target {\n         llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),"}, {"sha": "dc450433ad9fa4c010570c266834624cf3493b75", "filename": "src/librustc_borrowck/borrowck/mir/abs_domain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -21,8 +21,8 @@\n //! `a[x]` would still overlap them both. But that is not this\n //! representation does today.)\n \n-use rustc::mir::repr::{Lvalue, LvalueElem};\n-use rustc::mir::repr::{Operand, Projection, ProjectionElem};\n+use rustc::mir::{Lvalue, LvalueElem};\n+use rustc::mir::{Operand, Projection, ProjectionElem};\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractOperand;"}, {"sha": "28f58723862cbdcd7d79fa804f7dae8709f9bf62", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,7 +11,7 @@\n //! Hook into libgraphviz for rendering dataflow graphs for MIR.\n \n use syntax::ast::NodeId;\n-use rustc::mir::repr::{BasicBlock, Mir};\n+use rustc::mir::{BasicBlock, Mir};\n use rustc_data_structures::bitslice::bits_to_string;\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "fcb453d81aa770c98a9fefca31bfddcc7280b42c", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::{self, Mir, Location};\n+use rustc::mir::{self, Mir, Location};\n use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n@@ -245,7 +245,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MovePathIndex>,\n-                        bb: repr::BasicBlock,\n+                        bb: mir::BasicBlock,\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n@@ -258,7 +258,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MovePathIndex>,\n-                         bb: repr::BasicBlock,\n+                         bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n@@ -271,9 +271,9 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MovePathIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             dest_lval: &mir::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MovePathIndex>,\n-                        bb: repr::BasicBlock,\n+                        bb: mir::BasicBlock,\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n@@ -319,7 +319,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MovePathIndex>,\n-                         bb: repr::BasicBlock,\n+                         bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n@@ -332,9 +332,9 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MovePathIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             dest_lval: &mir::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 0 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n@@ -366,7 +366,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MovePathIndex>,\n-                        bb: repr::BasicBlock,\n+                        bb: mir::BasicBlock,\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MovePathIndex>,\n-                         bb: repr::BasicBlock,\n+                         bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n@@ -392,9 +392,9 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MovePathIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             dest_lval: &mir::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, &ctxt.move_data,\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<MoveOutIndex>,\n-                        bb: repr::BasicBlock,\n+                        bb: mir::BasicBlock,\n                         idx: usize) {\n         let (tcx, mir, move_data) = (self.tcx, self.mir, &ctxt.move_data);\n         let stmt = &mir[bb].statements[idx];\n@@ -437,10 +437,10 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n         }\n         let bits_per_block = self.bits_per_block(ctxt);\n         match stmt.kind {\n-            repr::StatementKind::SetDiscriminant { .. } => {\n+            mir::StatementKind::SetDiscriminant { .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n             }\n-            repr::StatementKind::Assign(ref lvalue, _) => {\n+            mir::StatementKind::Assign(ref lvalue, _) => {\n                 // assigning into this `lvalue` kills all\n                 // MoveOuts from it, and *also* all MoveOuts\n                 // for children and associated fragment sets.\n@@ -453,16 +453,16 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                                          sets.kill_set.add(&moi);\n                                      });\n             }\n-            repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) |\n-            repr::StatementKind::Nop => {}\n+            mir::StatementKind::StorageLive(_) |\n+            mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::Nop => {}\n         }\n     }\n \n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<MoveOutIndex>,\n-                         bb: repr::BasicBlock,\n+                         bb: mir::BasicBlock,\n                          statements_len: usize)\n     {\n         let (mir, move_data) = (self.mir, &ctxt.move_data);\n@@ -481,9 +481,9 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<MoveOutIndex>,\n-                             _call_bb: repr::BasicBlock,\n-                             _dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue) {\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             dest_lval: &mir::Lvalue) {\n         let move_data = &ctxt.move_data;\n         let bits_per_block = self.bits_per_block(ctxt);\n "}, {"sha": "51817afbfeafdd53a7b24bc15f08a1d8dbc801ba", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::{self, Mir};\n+use rustc::mir::{self, Mir};\n \n use std::fmt::Debug;\n use std::io;\n@@ -78,14 +78,12 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n         // the kill-sets.\n \n         {\n-            let sets = &mut self.flow_state.sets.for_block(repr::START_BLOCK.index());\n+            let sets = &mut self.flow_state.sets.for_block(mir::START_BLOCK.index());\n             self.flow_state.operator.start_block_effect(&self.ctxt, sets);\n         }\n \n         for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n-            let &repr::BasicBlockData { ref statements,\n-                                        ref terminator,\n-                                        is_cleanup: _ } = data;\n+            let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n \n             let sets = &mut self.flow_state.sets.for_block(bb.index());\n             for j_stmt in 0..statements.len() {\n@@ -122,7 +120,7 @@ impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD>\n                 in_out.subtract(sets.kill_set);\n             }\n             builder.propagate_bits_into_graph_successors_of(\n-                in_out, &mut self.changed, (repr::BasicBlock::new(bb_idx), bb_data));\n+                in_out, &mut self.changed, (mir::BasicBlock::new(bb_idx), bb_data));\n         }\n     }\n }\n@@ -336,7 +334,7 @@ pub trait BitDenotation {\n     fn statement_effect(&self,\n                         ctxt: &Self::Ctxt,\n                         sets: &mut BlockSets<Self::Idx>,\n-                        bb: repr::BasicBlock,\n+                        bb: mir::BasicBlock,\n                         idx_stmt: usize);\n \n     /// Mutates the block-sets (the flow sets for the given\n@@ -352,7 +350,7 @@ pub trait BitDenotation {\n     fn terminator_effect(&self,\n                          ctxt: &Self::Ctxt,\n                          sets: &mut BlockSets<Self::Idx>,\n-                         bb: repr::BasicBlock,\n+                         bb: mir::BasicBlock,\n                          idx_term: usize);\n \n     /// Mutates the block-sets according to the (flow-dependent)\n@@ -377,9 +375,9 @@ pub trait BitDenotation {\n     fn propagate_call_return(&self,\n                              ctxt: &Self::Ctxt,\n                              in_out: &mut IdxSet<Self::Idx>,\n-                             call_bb: repr::BasicBlock,\n-                             dest_bb: repr::BasicBlock,\n-                             dest_lval: &repr::Lvalue);\n+                             call_bb: mir::BasicBlock,\n+                             dest_bb: mir::BasicBlock,\n+                             dest_lval: &mir::Lvalue);\n }\n \n impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n@@ -444,39 +442,39 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n         &mut self,\n         in_out: &mut IdxSet<D::Idx>,\n         changed: &mut bool,\n-        (bb, bb_data): (repr::BasicBlock, &repr::BasicBlockData))\n+        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData))\n     {\n         match bb_data.terminator().kind {\n-            repr::TerminatorKind::Return |\n-            repr::TerminatorKind::Resume |\n-            repr::TerminatorKind::Unreachable => {}\n-            repr::TerminatorKind::Goto { ref target } |\n-            repr::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n-            repr::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n-            repr::TerminatorKind::DropAndReplace {\n+            mir::TerminatorKind::Return |\n+            mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::Unreachable => {}\n+            mir::TerminatorKind::Goto { ref target } |\n+            mir::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n+            mir::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n+            mir::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: None\n             } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n             }\n-            repr::TerminatorKind::Assert { ref target, cleanup: Some(ref unwind), .. } |\n-            repr::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n-            repr::TerminatorKind::DropAndReplace {\n+            mir::TerminatorKind::Assert { ref target, cleanup: Some(ref unwind), .. } |\n+            mir::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n+            mir::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: Some(ref unwind)\n             } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n                 self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n             }\n-            repr::TerminatorKind::If { ref targets, .. } => {\n+            mir::TerminatorKind::If { ref targets, .. } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n                 self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n             }\n-            repr::TerminatorKind::Switch { ref targets, .. } |\n-            repr::TerminatorKind::SwitchInt { ref targets, .. } => {\n+            mir::TerminatorKind::Switch { ref targets, .. } |\n+            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n                 for target in targets {\n                     self.propagate_bits_into_entry_set_for(in_out, changed, target);\n                 }\n             }\n-            repr::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n+            mir::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n                 if let Some(ref unwind) = *cleanup {\n                     self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n                 }\n@@ -494,7 +492,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n     fn propagate_bits_into_entry_set_for(&mut self,\n                                          in_out: &IdxSet<D::Idx>,\n                                          changed: &mut bool,\n-                                         bb: &repr::BasicBlock) {\n+                                         bb: &mir::BasicBlock) {\n         let entry_set = self.flow_state.sets.for_block(bb.index()).on_entry;\n         let set_changed = bitwise(entry_set.words_mut(),\n                                   in_out.words(),"}, {"sha": "b8c26a0512ff8e835d79c78c3e819e8892b12640", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@ use syntax::ast;\n use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::repr::{self, Mir};\n+use rustc::mir::{self, Mir};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::super::gather_moves::{MovePathIndex, LookupResult};\n@@ -59,21 +59,19 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mir: &Mir<'tcx>,\n                            ctxt: &O::Ctxt,\n                            results: &DataflowResults<O>,\n-                           bb: repr::BasicBlock) where\n+                           bb: mir::BasicBlock) where\n     O: BitDenotation<Ctxt=MoveDataParamEnv<'tcx>, Idx=MovePathIndex>\n {\n     let move_data = &ctxt.move_data;\n-    let repr::BasicBlockData { ref statements,\n-                               ref terminator,\n-                               is_cleanup: _ } = mir[bb];\n+    let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = mir[bb];\n \n     let (args, span) = match is_rustc_peek(tcx, terminator) {\n         Some(args_and_span) => args_and_span,\n         None => return,\n     };\n     assert!(args.len() == 1);\n     let peek_arg_lval = match args[0] {\n-        repr::Operand::Consume(ref lval @ repr::Lvalue::Local(_)) => Some(lval),\n+        mir::Operand::Consume(ref lval @ mir::Lvalue::Local(_)) => Some(lval),\n         _ => None,\n     };\n \n@@ -103,21 +101,19 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for (j, stmt) in statements.iter().enumerate() {\n         debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n         let (lvalue, rvalue) = match stmt.kind {\n-            repr::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 (lvalue, rvalue)\n             }\n-            repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) |\n-            repr::StatementKind::Nop => continue,\n-            repr::StatementKind::SetDiscriminant{ .. } =>\n+            mir::StatementKind::StorageLive(_) |\n+            mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::Nop => continue,\n+            mir::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,\n                           \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),\n         };\n \n         if lvalue == peek_arg_lval {\n-            if let repr::Rvalue::Ref(_,\n-                                     repr::BorrowKind::Shared,\n-                                     ref peeking_at_lval) = *rvalue {\n+            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_lval) = *rvalue {\n                 // Okay, our search is over.\n                 match move_data.rev_lookup.find(peeking_at_lval) {\n                     LookupResult::Exact(peek_mpi) => {\n@@ -162,12 +158,12 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           terminator: &'a Option<repr::Terminator<'tcx>>)\n-                           -> Option<(&'a [repr::Operand<'tcx>], Span)> {\n-    if let Some(repr::Terminator { ref kind, source_info, .. }) = *terminator {\n-        if let repr::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n+                           terminator: &'a Option<mir::Terminator<'tcx>>)\n+                           -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n+    if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n+        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind\n         {\n-            if let repr::Operand::Constant(ref func) = *oper\n+            if let mir::Operand::Constant(ref func) = *oper\n             {\n                 if let ty::TyFnDef(def_id, _, &ty::BareFnTy { abi, .. }) = func.ty.sty\n                 {"}, {"sha": "191cd981b61ebffe62533f1f70aa46cec46b501c", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -17,7 +17,7 @@ use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;"}, {"sha": "1dc5769e63cf8e1518cef6aa70c27b9399ceb9e0", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n \n use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n "}, {"sha": "cea9170da9ffd86265f8016ee13c57735aff5a69", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -17,8 +17,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir;\n use rustc::hir::intravisit::{FnKind};\n \n-use rustc::mir::repr;\n-use rustc::mir::repr::{BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n+use rustc::mir::{self, BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n \n@@ -56,15 +55,13 @@ pub struct MoveDataParamEnv<'tcx> {\n     param_env: ty::ParameterEnvironment<'tcx>,\n }\n \n-pub fn borrowck_mir<'a, 'tcx: 'a>(\n-    bcx: &mut BorrowckCtxt<'a, 'tcx>,\n-    fk: FnKind,\n-    _decl: &hir::FnDecl,\n-    mir: &'a Mir<'tcx>,\n-    body: &hir::Block,\n-    _sp: Span,\n-    id: ast::NodeId,\n-    attributes: &[ast::Attribute]) {\n+pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n+                    fk: FnKind,\n+                    _decl: &hir::FnDecl,\n+                    body: &hir::Block,\n+                    _sp: Span,\n+                    id: ast::NodeId,\n+                    attributes: &[ast::Attribute]) {\n     match fk {\n         FnKind::ItemFn(name, ..) |\n         FnKind::Method(name, ..) => {\n@@ -76,8 +73,10 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n     }\n \n     let tcx = bcx.tcx;\n-\n     let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+\n+    let mir = &tcx.item_mir(tcx.map.local_def_id(id));\n+\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let flow_inits =\n@@ -171,8 +170,8 @@ pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n     mir: &'b Mir<'tcx>,\n     node_id: ast::NodeId,\n     move_data: MoveData<'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n-    flow_uninits: DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n+    flow_uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>\n }\n \n impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n@@ -214,12 +213,12 @@ fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)\n                                         -> Option<MovePathIndex>\n-    where F: FnMut(&repr::LvalueProjection<'tcx>) -> bool\n+    where F: FnMut(&mir::LvalueProjection<'tcx>) -> bool\n {\n     let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n         match move_data.move_paths[child_index].lvalue {\n-            repr::Lvalue::Projection(ref proj) => {\n+            mir::Lvalue::Projection(ref proj) => {\n                 if cond(proj) {\n                     return Some(child_index)\n                 }\n@@ -252,7 +251,7 @@ fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// FIXME: we have to do something for moving slice patterns.\n fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                       mir: &Mir<'tcx>,\n-                                                      lv: &repr::Lvalue<'tcx>) -> bool {\n+                                                      lv: &mir::Lvalue<'tcx>) -> bool {\n     let ty = lv.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n@@ -339,7 +338,7 @@ fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n {\n     let move_data = &ctxt.move_data;\n     for arg in mir.args_iter() {\n-        let lvalue = repr::Lvalue::Local(arg);\n+        let lvalue = mir::Lvalue::Local(arg);\n         let lookup_result = move_data.rev_lookup.find(&lvalue);\n         on_lookup_result_bits(tcx, mir, move_data,\n                               lookup_result,\n@@ -379,23 +378,23 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n     let block = &mir[loc.block];\n     match block.statements.get(loc.statement_index) {\n         Some(stmt) => match stmt.kind {\n-            repr::StatementKind::SetDiscriminant{ .. } => {\n+            mir::StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscrimant should not exist during borrowck\");\n             }\n-            repr::StatementKind::Assign(ref lvalue, _) => {\n+            mir::StatementKind::Assign(ref lvalue, _) => {\n                 debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n                  on_lookup_result_bits(tcx, mir, move_data,\n                                        move_data.rev_lookup.find(lvalue),\n                                        |moi| callback(moi, DropFlagState::Present))\n             }\n-            repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) |\n-            repr::StatementKind::Nop => {}\n+            mir::StatementKind::StorageLive(_) |\n+            mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::Nop => {}\n         },\n         None => {\n             debug!(\"drop_flag_effects: replace {:?}\", block.terminator());\n             match block.terminator().kind {\n-                repr::TerminatorKind::DropAndReplace { ref location, .. } => {\n+                mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                     on_lookup_result_bits(tcx, mir, move_data,\n                                           move_data.rev_lookup.find(location),\n                                           |moi| callback(moi, DropFlagState::Present))"}, {"sha": "19f240da73059d498b543a087c967581cc98b695", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::Ty;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n /// This struct represents a patch to MIR, which can add"}, {"sha": "ef6936b6e7db3184894abb60cf72d047cb1ee46f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -51,8 +51,6 @@ use rustc::hir::{FnDecl, Block};\n use rustc::hir::intravisit;\n use rustc::hir::intravisit::{Visitor, FnKind};\n \n-use rustc::mir::mir_map::MirMap;\n-\n pub mod check_loans;\n \n pub mod gather_loans;\n@@ -102,10 +100,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &MirMap<'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        mir_map: Some(mir_map),\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -168,12 +165,9 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n-    let def_id = this.tcx.map.local_def_id(id);\n-\n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n-        let mir = this.mir_map.unwrap().map.get(&def_id).unwrap();\n         this.with_temp_region_map(id, |this| {\n-            mir::borrowck_mir(this, fk, decl, mir, body, sp, id, attributes)\n+            mir::borrowck_mir(this, fk, decl, body, sp, id, attributes)\n         });\n     }\n \n@@ -249,15 +243,13 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir_map: Option<&'a MirMap<'tcx>>,\n     fn_parts: FnParts<'a>,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        mir_map: mir_map,\n         free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n@@ -297,10 +289,7 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     free_region_map: FreeRegionMap,\n \n     // Statistics:\n-    stats: BorrowStats,\n-\n-    // NodeId to MIR mapping (for methods that carry the #[rustc_mir] attribute).\n-    mir_map: Option<&'a MirMap<'tcx>>,\n+    stats: BorrowStats\n }\n \n #[derive(Clone)]"}, {"sha": "946a3974747654d2ce00afd36532fe4d494b8e51", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,7 +11,7 @@\n use eval;\n \n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::repr::{Field, BorrowKind, Mutability};\n+use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::Def;\n@@ -436,7 +436,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) => {\n+            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n "}, {"sha": "8c82c135dc426b5a30cac5f4c5bf5d3d6b5bf096", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -20,17 +20,25 @@\n // implementation. If you have the luxury of being able to use crates from\n // crates.io, you can go there and find still faster implementations.\n \n+use std::mem;\n+use std::slice;\n+\n pub struct Blake2bCtx {\n     b: [u8; 128],\n     h: [u64; 8],\n     t: [u64; 2],\n     c: usize,\n-    outlen: usize,\n+    outlen: u16,\n+    finalized: bool\n }\n \n impl ::std::fmt::Debug for Blake2bCtx {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{:?}\", self.h)\n+        try!(write!(fmt, \"hash: \"));\n+        for v in &self.h[..] {\n+            try!(write!(fmt, \"{:x}\", v));\n+        }\n+        Ok(())\n     }\n }\n \n@@ -136,15 +144,16 @@ fn blake2b_compress(ctx: &mut Blake2bCtx, last: bool) {\n     }\n }\n \n-pub fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n+fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n     assert!(outlen > 0 && outlen <= 64 && key.len() <= 64);\n \n     let mut ctx = Blake2bCtx {\n         b: [0; 128],\n         h: BLAKE2B_IV,\n         t: [0; 2],\n         c: 0,\n-        outlen: outlen,\n+        outlen: outlen as u16,\n+        finalized: false,\n     };\n \n     ctx.h[0] ^= 0x01010000 ^ ((key.len() << 8) as u64) ^ (outlen as u64);\n@@ -157,8 +166,9 @@ pub fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n     ctx\n }\n \n-pub fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8])\n-{\n+fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8]) {\n+    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n+\n     let mut bytes_to_copy = data.len();\n     let mut space_in_buffer = ctx.b.len() - ctx.c;\n \n@@ -183,8 +193,10 @@ pub fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8])\n     }\n }\n \n-pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n+fn blake2b_final(ctx: &mut Blake2bCtx)\n {\n+    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n+\n     ctx.t[0] = ctx.t[0].wrapping_add(ctx.c as u64);\n     if ctx.t[0] < ctx.c as u64 {\n         ctx.t[1] += 1;\n@@ -195,7 +207,7 @@ pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n         ctx.c += 1;\n     }\n \n-    blake2b_compress(&mut ctx, true);\n+    blake2b_compress(ctx, true);\n \n     if cfg!(target_endian = \"big\") {\n         // Make sure that the data is in memory in little endian format, as is\n@@ -205,13 +217,13 @@ pub fn blake2b_final(mut ctx: Blake2bCtx, out: &mut [u8])\n         }\n     }\n \n-    checked_mem_copy(&ctx.h, out, ctx.outlen);\n+    ctx.finalized = true;\n }\n \n #[inline(always)]\n fn checked_mem_copy<T1, T2>(from: &[T1], to: &mut [T2], byte_count: usize) {\n-    let from_size = from.len() * ::std::mem::size_of::<T1>();\n-    let to_size = to.len() * ::std::mem::size_of::<T2>();\n+    let from_size = from.len() * mem::size_of::<T1>();\n+    let to_size = to.len() * mem::size_of::<T2>();\n     assert!(from_size >= byte_count);\n     assert!(to_size >= byte_count);\n     let from_byte_ptr = from.as_ptr() as * const u8;\n@@ -225,7 +237,45 @@ pub fn blake2b(out: &mut [u8], key: &[u8],  data: &[u8])\n {\n     let mut ctx = blake2b_new(out.len(), key);\n     blake2b_update(&mut ctx, data);\n-    blake2b_final(ctx, out);\n+    blake2b_final(&mut ctx);\n+    checked_mem_copy(&ctx.h, out, ctx.outlen as usize);\n+}\n+\n+pub struct Blake2bHasher(Blake2bCtx);\n+\n+impl ::std::hash::Hasher for Blake2bHasher {\n+    fn write(&mut self, bytes: &[u8]) {\n+        blake2b_update(&mut self.0, bytes);\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        assert!(self.0.outlen == 8,\n+                \"Hasher initialized with incompatible output length\");\n+        u64::from_le(self.0.h[0])\n+    }\n+}\n+\n+impl Blake2bHasher {\n+    pub fn new(outlen: usize, key: &[u8]) -> Blake2bHasher {\n+        Blake2bHasher(blake2b_new(outlen, key))\n+    }\n+\n+    pub fn finalize(&mut self) -> &[u8] {\n+        if !self.0.finalized {\n+            blake2b_final(&mut self.0);\n+        }\n+        debug_assert!(mem::size_of_val(&self.0.h) >= self.0.outlen as usize);\n+        let raw_ptr = (&self.0.h[..]).as_ptr() as * const u8;\n+        unsafe {\n+            slice::from_raw_parts(raw_ptr, self.0.outlen as usize)\n+        }\n+    }\n+}\n+\n+impl ::std::fmt::Debug for Blake2bHasher {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{:?}\", self.0)\n+    }\n }\n \n #[cfg(test)]\n@@ -245,6 +295,8 @@ fn selftest_seq(out: &mut [u8], seed: u32)\n #[test]\n fn blake2b_selftest()\n {\n+    use std::hash::Hasher;\n+\n     // grand hash of hash results\n     const BLAKE2B_RES: [u8; 32] = [\n         0xC2, 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n@@ -261,7 +313,7 @@ fn blake2b_selftest()\n     let mut md = [0u8; 64];\n     let mut key = [0u8; 64];\n \n-    let mut ctx = blake2b_new(32, &[]);\n+    let mut hasher = Blake2bHasher::new(32, &[]);\n \n     for i in 0 .. 4 {\n        let outlen = B2B_MD_LEN[i];\n@@ -270,16 +322,16 @@ fn blake2b_selftest()\n \n             selftest_seq(&mut data[.. inlen], inlen as u32); // unkeyed hash\n             blake2b(&mut md[.. outlen], &[], &data[.. inlen]);\n-            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+            hasher.write(&md[.. outlen]); // hash the hash\n \n             selftest_seq(&mut key[0 .. outlen], outlen as u32); // keyed hash\n             blake2b(&mut md[.. outlen], &key[.. outlen], &data[.. inlen]);\n-            blake2b_update(&mut ctx, &md[.. outlen]); // hash the hash\n+            hasher.write(&md[.. outlen]); // hash the hash\n        }\n     }\n \n     // compute and compare the hash of hashes\n-    blake2b_final(ctx, &mut md[..]);\n+    let md = hasher.finalize();\n     for i in 0 .. 32 {\n         assert_eq!(md[i], BLAKE2B_RES[i]);\n     }"}, {"sha": "50fd1d802b7ffe8e44ee6b8b148fb9d35f638e1c", "filename": "src/librustc_data_structures/fmt_wrap.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffmt_wrap.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+// Provide some more formatting options for some data types (at the moment\n+// that's just `{:x}` for slices of u8).\n+\n+pub struct FmtWrap<T>(pub T);\n+\n+impl<'a> fmt::LowerHex for FmtWrap<&'a [u8]> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        for byte in self.0.iter() {\n+            try!(write!(formatter, \"{:02x}\", byte));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_lower_hex() {\n+    let bytes: &[u8] = &[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n+    assert_eq!(\"0123456789abcdef\", &format!(\"{:x}\", FmtWrap(bytes)));\n+}"}, {"sha": "fc963dac9495fc1b95d0350d05d99c5024281843", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -49,6 +49,7 @@ pub mod accumulate_vec;\n pub mod bitslice;\n pub mod blake2b;\n pub mod bitvec;\n+pub mod fmt_wrap;\n pub mod graph;\n pub mod ivar;\n pub mod indexed_set;"}, {"sha": "99d3e155e89365b2b4a504fc8d839be54bc82653", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -18,6 +18,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_lint = { path = \"../librustc_lint\" }"}, {"sha": "da1d5ad2c4a9b95ed5c8c6816545336d3bcf8f5f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 43, "deletions": 59, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,8 +12,10 @@ use rustc::hir;\n use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n use rustc::hir::def::DefMap;\n use rustc::hir::lowering::lower_crate;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n+use rustc_data_structures::fmt_wrap::FmtWrap;\n+use rustc::ty::util::ArchIndependentHasher;\n use rustc_mir as mir;\n-use rustc::mir::mir_map::MirMap;\n use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n                              OutputTypes};\n@@ -24,7 +26,6 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n-use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n@@ -68,7 +69,6 @@ pub struct Resolutions {\n \n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n-                     cfg: ast::CrateConfig,\n                      input: &Input,\n                      outdir: &Option<PathBuf>,\n                      output: &Option<PathBuf>,\n@@ -92,7 +92,7 @@ pub fn compile_input(sess: &Session,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans) = {\n-        let krate = match phase_1_parse_input(sess, cfg, input) {\n+        let krate = match phase_1_parse_input(sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n                 parse_error.emit();\n@@ -175,7 +175,7 @@ pub fn compile_input(sess: &Session,\n                                     resolutions,\n                                     &arenas,\n                                     &crate_name,\n-                                    |tcx, mir_map, analysis, incremental_hashes_map, result| {\n+                                    |tcx, analysis, incremental_hashes_map, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -187,7 +187,6 @@ pub fn compile_input(sess: &Session,\n                                                                    opt_crate,\n                                                                    tcx.map.krate(),\n                                                                    &analysis,\n-                                                                   mir_map.as_ref(),\n                                                                    tcx,\n                                                                    &crate_name);\n                 (control.after_analysis.callback)(&mut state);\n@@ -203,10 +202,7 @@ pub fn compile_input(sess: &Session,\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n-            let trans = phase_4_translate_to_llvm(tcx,\n-                                                  mir_map.unwrap(),\n-                                                  analysis,\n-                                                  &incremental_hashes_map);\n+            let trans = phase_4_translate_to_llvm(tcx, analysis, &incremental_hashes_map);\n \n             if log_enabled!(::log::INFO) {\n                 println!(\"Post-trans\");\n@@ -348,7 +344,6 @@ pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n     pub resolutions: Option<&'a Resolutions>,\n-    pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n     pub tcx: Option<TyCtxt<'b, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n@@ -375,7 +370,6 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n             ast_map: None,\n             resolutions: None,\n             analysis: None,\n-            mir_map: None,\n             tcx: None,\n             trans: None,\n         }\n@@ -449,13 +443,11 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis<'a>,\n-                            mir_map: Option<&'b MirMap<'tcx>>,\n                             tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n-            mir_map: mir_map,\n             tcx: Some(tcx),\n             expanded_crate: krate,\n             hir_crate: Some(hir_crate),\n@@ -491,23 +483,17 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n }\n \n-pub fn phase_1_parse_input<'a>(sess: &'a Session,\n-                               cfg: ast::CrateConfig,\n-                               input: &Input)\n-                               -> PResult<'a, ast::Crate> {\n+pub fn phase_1_parse_input<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     let continue_after_error = sess.opts.debugging_opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n \n     let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n-                parse::parse_crate_from_file(file, cfg.clone(), &sess.parse_sess)\n+                parse::parse_crate_from_file(file, &sess.parse_sess)\n             }\n             Input::Str { ref input, ref name } => {\n-                parse::parse_crate_from_source_str(name.clone(),\n-                                                   input.clone(),\n-                                                   cfg.clone(),\n-                                                   &sess.parse_sess)\n+                parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n             }\n         }\n     })?;\n@@ -645,7 +631,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let _ignore = sess.dep_graph.in_ignore();\n-    let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name, krate.config.clone());\n+    let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n     crate_loader.preprocess(&krate);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n@@ -686,7 +672,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             should_test: sess.opts.test,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n-        let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n+        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n         let err_count = ecx.parse_sess.span_diagnostic.err_count();\n \n         let krate = ecx.monotonic_expander().expand_crate(krate);\n@@ -812,17 +798,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n-                            Option<MirMap<'tcx>>,\n                             ty::CrateAnalysis,\n                             IncrementalHashesMap,\n                             CompileResult) -> R\n {\n     macro_rules! try_with_f {\n-        ($e: expr, ($t: expr, $m: expr, $a: expr, $h: expr)) => {\n+        ($e: expr, ($t: expr, $a: expr, $h: expr)) => {\n             match $e {\n                 Ok(x) => x,\n                 Err(x) => {\n-                    f($t, $m, $a, $h, Err(x));\n+                    f($t, $a, $h, Err(x));\n                     return Err(x);\n                 }\n             }\n@@ -888,7 +873,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx), (tcx, None, analysis, incremental_hashes_map));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n \n         time(time_passes,\n              \"const checking\",\n@@ -928,28 +913,28 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"rvalue checking\",\n              || rvalues::check_crate(tcx));\n \n-        let mut mir_map =\n-            time(time_passes,\n-                 \"MIR dump\",\n-                 || mir::mir_map::build_mir_for_crate(tcx));\n+        time(time_passes,\n+             \"MIR dump\",\n+             || mir::mir_map::build_mir_for_crate(tcx));\n \n         time(time_passes, \"MIR passes\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in passes.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n+            passes.push_pass(\n+                box mir::transform::qualify_consts::QualifyAndPromoteConstants::default());\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"qualify-consts\"));\n             // And run everything.\n-            passes.run_passes(tcx, &mut mir_map);\n+            passes.run_passes(tcx);\n         });\n \n         time(time_passes,\n              \"borrow checking\",\n-             || borrowck::check_crate(tcx, &mir_map));\n+             || borrowck::check_crate(tcx));\n \n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n@@ -958,11 +943,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx,\n-                        Some(mir_map),\n-                        analysis,\n-                        incremental_hashes_map,\n-                        Err(sess.err_count())));\n+            return Ok(f(tcx, analysis, incremental_hashes_map, Err(sess.err_count())));\n         }\n \n         analysis.reachable =\n@@ -990,20 +971,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         // The above three passes generate errors w/o aborting\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx,\n-                        Some(mir_map),\n-                        analysis,\n-                        incremental_hashes_map,\n-                        Err(sess.err_count())));\n+            return Ok(f(tcx, analysis, incremental_hashes_map, Err(sess.err_count())));\n         }\n \n-        Ok(f(tcx, Some(mir_map), analysis, incremental_hashes_map, Ok(())))\n+        Ok(f(tcx, analysis, incremental_hashes_map, Ok(())))\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           mut mir_map: MirMap<'tcx>,\n                                            analysis: ty::CrateAnalysis,\n                                            incremental_hashes_map: &IncrementalHashesMap)\n                                            -> trans::CrateTranslation {\n@@ -1037,13 +1013,13 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n \n-        passes.run_passes(tcx, &mut mir_map);\n+        passes.run_passes(tcx);\n     });\n \n     let translation =\n         time(time_passes,\n              \"translation\",\n-             move || trans::trans_crate(tcx, &mir_map, analysis, &incremental_hashes_map));\n+             move || trans::trans_crate(tcx, analysis, &incremental_hashes_map));\n \n     time(time_passes,\n          \"assert dep graph\",\n@@ -1247,7 +1223,16 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n }\n \n pub fn compute_crate_disambiguator(session: &Session) -> String {\n-    let mut hasher = Sha256::new();\n+    use std::hash::Hasher;\n+\n+    // The crate_disambiguator is a 128 bit hash. The disambiguator is fed\n+    // into various other hashes quite a bit (symbol hashes, incr. comp. hashes,\n+    // debuginfo type IDs, etc), so we don't want it to be too wide. 128 bits\n+    // should still be safe enough to avoid collisions in practice.\n+    // FIXME(mw): It seems that the crate_disambiguator is used everywhere as\n+    //            a hex-string instead of raw bytes. We should really use the\n+    //            smaller representation.\n+    let mut hasher = ArchIndependentHasher::new(Blake2bHasher::new(128 / 8, &[]));\n \n     let mut metadata = session.opts.cg.metadata.clone();\n     // We don't want the crate_disambiguator to dependent on the order\n@@ -1256,24 +1241,23 @@ pub fn compute_crate_disambiguator(session: &Session) -> String {\n     // Every distinct -C metadata value is only incorporated once:\n     metadata.dedup();\n \n-    hasher.input_str(\"metadata\");\n+    hasher.write(b\"metadata\");\n     for s in &metadata {\n         // Also incorporate the length of a metadata string, so that we generate\n         // different values for `-Cmetadata=ab -Cmetadata=c` and\n         // `-Cmetadata=a -Cmetadata=bc`\n-        hasher.input_str(&format!(\"{}\", s.len())[..]);\n-        hasher.input_str(&s[..]);\n+        hasher.write_usize(s.len());\n+        hasher.write(s.as_bytes());\n     }\n \n-    let mut hash = hasher.result_str();\n+    let mut hash_state = hasher.into_inner();\n+    let hash_bytes = hash_state.finalize();\n \n     // If this is an executable, add a special suffix, so that we don't get\n     // symbol conflicts when linking against a library of the same name.\n-    if session.crate_types.borrow().contains(&config::CrateTypeExecutable) {\n-       hash.push_str(\"-exe\");\n-    }\n+    let is_exe = session.crate_types.borrow().contains(&config::CrateTypeExecutable);\n \n-    hash\n+    format!(\"{:x}{}\", FmtWrap(hash_bytes), if is_exe { \"-exe\" } else {\"\"})\n }\n \n pub fn build_output_filenames(input: &Input,"}, {"sha": "cb78baa12a6ad052f5c08170eef8c119fe4412ca", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -42,6 +42,7 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n extern crate rustc_const_eval;\n+extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_passes;\n extern crate rustc_lint;\n@@ -205,24 +206,20 @@ pub fn run_compiler<'a>(args: &[String],\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader));\n-    let sess = session::build_session_with_codemap(sopts,\n-                                                   &dep_graph,\n-                                                   input_file_path,\n-                                                   descriptions,\n-                                                   cstore.clone(),\n-                                                   codemap,\n-                                                   emitter_dest);\n+    let mut sess = session::build_session_with_codemap(\n+        sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n     let mut cfg = config::build_configuration(&sess, cfg);\n     target_features::add_configuration(&mut cfg, &sess);\n+    sess.parse_sess.config = cfg;\n \n-    do_or_return!(callbacks.late_callback(&matches, &sess, &cfg, &input, &odir, &ofile),\n-                  Some(sess));\n+    do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile), Some(sess));\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess, &matches);\n-    (driver::compile_input(&sess, &cstore, cfg, &input, &odir, &ofile,\n-                           Some(plugins), &control),\n+    (driver::compile_input(&sess, &cstore, &input, &odir, &ofile, Some(plugins), &control),\n      Some(sess))\n }\n \n@@ -310,7 +307,6 @@ pub trait CompilerCalls<'a> {\n     fn late_callback(&mut self,\n                      _: &getopts::Matches,\n                      _: &Session,\n-                     _: &ast::CrateConfig,\n                      _: &Input,\n                      _: &Option<PathBuf>,\n                      _: &Option<PathBuf>)\n@@ -439,19 +435,18 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n                 let cstore = Rc::new(CStore::new(&dep_graph));\n-                let sess = build_session(sopts.clone(),\n+                let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n                 target_features::add_configuration(&mut cfg, &sess);\n-                let should_stop = RustcDefaultCalls::print_crate_info(&sess,\n-                                                                      &cfg,\n-                                                                      None,\n-                                                                      odir,\n-                                                                      ofile);\n+                sess.parse_sess.config = cfg;\n+                let should_stop =\n+                    RustcDefaultCalls::print_crate_info(&sess, None, odir, ofile);\n+\n                 if should_stop == Compilation::Stop {\n                     return None;\n                 }\n@@ -467,12 +462,11 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn late_callback(&mut self,\n                      matches: &getopts::Matches,\n                      sess: &Session,\n-                     cfg: &ast::CrateConfig,\n                      input: &Input,\n                      odir: &Option<PathBuf>,\n                      ofile: &Option<PathBuf>)\n                      -> Compilation {\n-        RustcDefaultCalls::print_crate_info(sess, cfg, Some(input), odir, ofile)\n+        RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile)\n             .and_then(|| RustcDefaultCalls::list_metadata(sess, matches, input))\n     }\n \n@@ -593,7 +587,6 @@ impl RustcDefaultCalls {\n \n \n     fn print_crate_info(sess: &Session,\n-                        cfg: &ast::CrateConfig,\n                         input: Option<&Input>,\n                         odir: &Option<PathBuf>,\n                         ofile: &Option<PathBuf>)\n@@ -649,8 +642,8 @@ impl RustcDefaultCalls {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n-                    for cfg in cfg {\n-                        if !allow_unstable_cfg && GatedCfg::gate(&*cfg).is_some() {\n+                    for cfg in &sess.parse_sess.config {\n+                        if !allow_unstable_cfg && GatedCfg::gate(cfg).is_some() {\n                             continue;\n                         }\n \n@@ -1036,13 +1029,10 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<ast::Attribute>> {\n     match *input {\n         Input::File(ref ifile) => {\n-            parse::parse_crate_attrs_from_file(ifile, Vec::new(), &sess.parse_sess)\n+            parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess)\n         }\n         Input::Str { ref name, ref input } => {\n-            parse::parse_crate_attrs_from_source_str(name.clone(),\n-                                                     input.clone(),\n-                                                     Vec::new(),\n-                                                     &sess.parse_sess)\n+            parse::parse_crate_attrs_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n         }\n     }\n }"}, {"sha": "10ff7dc89f9a33e5ddf38ac5ff728afb4e34fa23", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -52,8 +52,6 @@ use rustc::hir::map::{blocks, NodePrinter};\n use rustc::hir;\n use rustc::hir::print as pprust_hir;\n \n-use rustc::mir::mir_map::MirMap;\n-\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n     PpmNormal,\n@@ -234,7 +232,7 @@ impl PpSourceMode {\n                                                                  resolutions.clone(),\n                                                                  arenas,\n                                                                  id,\n-                                                                 |tcx, _, _, _, _| {\n+                                                                 |tcx, _, _, _| {\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                     };\n@@ -695,7 +693,6 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       mir_map: Option<&MirMap<'tcx>>,\n                                        code: blocks::Code,\n                                        mode: PpFlowGraphMode,\n                                        mut out: W)\n@@ -725,7 +722,6 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         blocks::FnLikeCode(fn_like) => {\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n-                                                              mir_map,\n                                                               fn_like.to_fn_parts(),\n                                                               &cfg);\n \n@@ -952,32 +948,28 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      resolutions.clone(),\n                                                      arenas,\n                                                      crate_name,\n-                                                     |tcx, mir_map, _, _, _| {\n+                                                     |tcx, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n-                if let Some(mir_map) = mir_map {\n-                    if let Some(nodeid) = nodeid {\n-                        let def_id = tcx.map.local_def_id(nodeid);\n-                        match ppm {\n-                            PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mir_map, &mut out),\n-                            PpmMirCFG => {\n-                                write_mir_graphviz(tcx, iter::once(def_id), &mir_map, &mut out)\n-                            }\n-                            _ => unreachable!(),\n-                        }?;\n-                    } else {\n-                        match ppm {\n-                            PpmMir => write_mir_pretty(tcx,\n-                                                       mir_map.map.keys().into_iter(),\n-                                                       &mir_map,\n-                                                       &mut out),\n-                            PpmMirCFG => write_mir_graphviz(tcx,\n-                                                            mir_map.map.keys().into_iter(),\n-                                                            &mir_map,\n-                                                            &mut out),\n-                            _ => unreachable!(),\n-                        }?;\n-                    }\n+                if let Some(nodeid) = nodeid {\n+                    let def_id = tcx.map.local_def_id(nodeid);\n+                    match ppm {\n+                        PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mut out),\n+                        PpmMirCFG => {\n+                            write_mir_graphviz(tcx, iter::once(def_id), &mut out)\n+                        }\n+                        _ => unreachable!(),\n+                    }?;\n+                } else {\n+                    match ppm {\n+                        PpmMir => write_mir_pretty(tcx,\n+                                                   tcx.mir_map.borrow().keys().into_iter(),\n+                                                   &mut out),\n+                        PpmMirCFG => write_mir_graphviz(tcx,\n+                                                        tcx.mir_map.borrow().keys().into_iter(),\n+                                                        &mut out),\n+                        _ => unreachable!(),\n+                    }?;\n                 }\n                 Ok(())\n             }\n@@ -995,12 +987,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n                         let out: &mut Write = &mut out;\n \n-                        print_flowgraph(variants,\n-                                        tcx,\n-                                        mir_map.as_ref(),\n-                                        code,\n-                                        mode,\n-                                        out)\n+                        print_flowgraph(variants, tcx, code, mode, out)\n                     }\n                     None => {\n                         let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\"}, {"sha": "50903c89a58901bcc49e001ed6fdf30c310b6e57", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -106,12 +106,11 @@ fn test_env<F>(source_string: &str,\n     let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n                                        Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    let krate_config = Vec::new();\n     let input = config::Input::Str {\n         name: driver::anon_src(),\n         input: source_string.to_string(),\n     };\n-    let krate = driver::phase_1_parse_input(&sess, krate_config, &input).unwrap();\n+    let krate = driver::phase_1_parse_input(&sess, &input).unwrap();\n     let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n         driver::phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"test\", None, MakeGlobMap::No, |_| Ok(()),"}, {"sha": "49683a81227b1ebfb2636d73cbdee54a7ff5b534", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -8,21 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::Hasher;\n use std::mem;\n-use rustc_data_structures::blake2b;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n+use rustc::ty::util::ArchIndependentHasher;\n use ich::Fingerprint;\n \n #[derive(Debug)]\n pub struct IchHasher {\n-    state: blake2b::Blake2bCtx,\n+    state: ArchIndependentHasher<Blake2bHasher>,\n     bytes_hashed: u64,\n }\n \n impl IchHasher {\n     pub fn new() -> IchHasher {\n+        let hash_size = mem::size_of::<Fingerprint>();\n         IchHasher {\n-            state: blake2b::blake2b_new(mem::size_of::<Fingerprint>(), &[]),\n+            state: ArchIndependentHasher::new(Blake2bHasher::new(hash_size, &[])),\n             bytes_hashed: 0\n         }\n     }\n@@ -33,40 +34,19 @@ impl IchHasher {\n \n     pub fn finish(self) -> Fingerprint {\n         let mut fingerprint = Fingerprint::zero();\n-        blake2b::blake2b_final(self.state, &mut fingerprint.0);\n+        fingerprint.0.copy_from_slice(self.state.into_inner().finalize());\n         fingerprint\n     }\n }\n \n-impl Hasher for IchHasher {\n+impl ::std::hash::Hasher for IchHasher {\n     fn finish(&self) -> u64 {\n         bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n     }\n \n     #[inline]\n     fn write(&mut self, bytes: &[u8]) {\n-        blake2b::blake2b_update(&mut self.state, bytes);\n+        self.state.write(bytes);\n         self.bytes_hashed += bytes.len() as u64;\n     }\n-\n-    #[inline]\n-    fn write_u16(&mut self, i: u16) {\n-        self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i.to_le()) })\n-    }\n-\n-    #[inline]\n-    fn write_u32(&mut self, i: u32) {\n-        self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i.to_le()) })\n-    }\n-\n-    #[inline]\n-    fn write_u64(&mut self, i: u64) {\n-        self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i.to_le()) })\n-    }\n-\n-    #[inline]\n-    fn write_usize(&mut self, i: usize) {\n-        // always hash as u64, so we don't depend on the size of `usize`\n-        self.write_u64(i as u64);\n-    }\n }"}, {"sha": "94478f6603a6ee8dcb8d4980490a1f1bd77a8f7e", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n /// flag called `foo`.\n fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n-    let config = &tcx.map.krate().config;\n+    let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n     for item in attr.meta_item_list().unwrap_or(&[]) {\n         if item.check_name(CFG) {"}, {"sha": "6f114e09a6c7df7be1349fb4777ca14a5e89468e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -225,6 +225,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(SAFE_EXTERN_STATICS),\n             reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/35112>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(PATTERNS_IN_FNS_WITHOUT_BODY),\n+            reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "f4558a2871d1963b6813b2a55990b27586610509", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -52,7 +52,6 @@ pub struct CrateLoader<'a> {\n     next_crate_num: CrateNum,\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n-    local_crate_config: ast::CrateConfig,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -144,18 +143,13 @@ enum LoadResult {\n }\n \n impl<'a> CrateLoader<'a> {\n-    pub fn new(sess: &'a Session,\n-               cstore: &'a CStore,\n-               local_crate_name: &str,\n-               local_crate_config: ast::CrateConfig)\n-               -> Self {\n+    pub fn new(sess: &'a Session, cstore: &'a CStore, local_crate_name: &str) -> Self {\n         CrateLoader {\n             sess: sess,\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FnvHashMap(),\n             local_crate_name: local_crate_name.to_owned(),\n-            local_crate_config: local_crate_config,\n         }\n     }\n \n@@ -541,7 +535,6 @@ impl<'a> CrateLoader<'a> {\n             // NB: Don't use parse::parse_tts_from_source_str because it parses with\n             // quote_depth > 0.\n             let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n-                                                          self.local_crate_config.clone(),\n                                                           source_name.clone(),\n                                                           def.body);\n             let lo = p.span.lo;"}, {"sha": "a618c98ff774cda9477a684a7c1577c31c8ad2a5", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -23,8 +23,7 @@ use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::DefKey;\n-use rustc::mir::repr::Mir;\n-use rustc::mir::mir_map::MirMap;\n+use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n@@ -207,11 +206,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(impl_did.krate).is_default_impl(impl_did.index)\n     }\n \n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool {\n-        self.dep_graph.read(DepNode::MetaData(did));\n-        self.get_crate_data(did.krate).is_extern_item(did.index, tcx)\n-    }\n-\n     fn is_foreign_item(&self, did: DefId) -> bool {\n         self.get_crate_data(did.krate).is_foreign_item(did.index)\n     }\n@@ -467,10 +461,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.defid_for_inlined_node.borrow().get(&node_id).map(|x| *x)\n     }\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>> {\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx> {\n         self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index)\n+        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index).unwrap_or_else(|| {\n+            bug!(\"get_item_mir: missing MIR for {}\", tcx.item_path_str(def))\n+        })\n     }\n \n     fn is_item_mir_available(&self, def: DefId) -> bool {\n@@ -523,10 +518,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>) -> Vec<u8>\n+                           reachable: &NodeSet) -> Vec<u8>\n     {\n-        encoder::encode_metadata(tcx, self, reexports, link_meta, reachable, mir_map)\n+        encoder::encode_metadata(tcx, self, reexports, link_meta, reachable)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "ccd497860de8a19f2e1c442407d221fba26fd588", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::subst::Substs;\n \n use rustc_const_math::ConstInt;\n \n-use rustc::mir::repr::Mir;\n+use rustc::mir::Mir;\n \n use std::borrow::Cow;\n use std::cell::Ref;\n@@ -1009,30 +1009,6 @@ impl<'a, 'tcx> CrateMetadata {\n         constness == hir::Constness::Const\n     }\n \n-    pub fn is_extern_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        let item = match self.maybe_entry(id) {\n-            Some(item) => item.decode(self),\n-            None => return false,\n-        };\n-        let applicable = match item.kind {\n-            EntryKind::ImmStatic |\n-            EntryKind::MutStatic |\n-            EntryKind::ForeignImmStatic |\n-            EntryKind::ForeignMutStatic => true,\n-\n-            EntryKind::Fn(_) |\n-            EntryKind::ForeignFn(_) => self.get_generics(id, tcx).types.is_empty(),\n-\n-            _ => false,\n-        };\n-\n-        if applicable {\n-            attr::contains_extern_indicator(tcx.sess.diagnostic(), &self.get_attributes(&item))\n-        } else {\n-            false\n-        }\n-    }\n-\n     pub fn is_foreign_item(&self, id: DefIndex) -> bool {\n         match self.entry(id).kind {\n             EntryKind::ForeignImmStatic |\n@@ -1138,6 +1114,14 @@ impl<'a, 'tcx> CrateMetadata {\n \n                 match reusable_filemap {\n                     Some(fm) => {\n+\n+                        debug!(\"CrateMetaData::imported_filemaps reuse \\\n+                                filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n+                                translated (start_pos {:?} end_pos {:?})\",\n+                               filemap_to_import.name,\n+                               filemap_to_import.start_pos, filemap_to_import.end_pos,\n+                               fm.start_pos, fm.end_pos);\n+\n                         cstore::ImportedFileMap {\n                             original_start_pos: filemap_to_import.start_pos,\n                             original_end_pos: filemap_to_import.end_pos,\n@@ -1176,6 +1160,12 @@ impl<'a, 'tcx> CrateMetadata {\n                                                                                source_length,\n                                                                                lines,\n                                                                                multibyte_chars);\n+                        debug!(\"CrateMetaData::imported_filemaps alloc \\\n+                                filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n+                                translated (start_pos {:?} end_pos {:?})\",\n+                               local_version.name, start_pos, end_pos,\n+                               local_version.start_pos, local_version.end_pos);\n+\n                         cstore::ImportedFileMap {\n                             original_start_pos: start_pos,\n                             original_end_pos: end_pos,\n@@ -1193,6 +1183,10 @@ impl<'a, 'tcx> CrateMetadata {\n }\n \n fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap, fm2: &syntax_pos::FileMap) -> bool {\n+    if fm1.byte_length() != fm2.byte_length() {\n+        return false;\n+    }\n+\n     if fm1.name != fm2.name {\n         return false;\n     }"}, {"sha": "e8734e4275712411cb2894021fcec54a2be3cd79", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 150, "deletions": 174, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -22,7 +22,6 @@ use rustc::mir;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n-use rustc::mir::mir_map::MirMap;\n use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n@@ -51,7 +50,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n     reachable: &'a NodeSet,\n-    mir_map: &'a MirMap<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FnvHashMap<Ty<'tcx>, usize>,\n@@ -117,7 +115,8 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, predicates: &ty::GenericPredicates<'tcx>)\n+    fn specialized_encode(&mut self,\n+                          predicates: &ty::GenericPredicates<'tcx>)\n                           -> Result<(), Self::Error> {\n         predicates.parent.encode(self)?;\n         predicates.predicates.len().encode(self)?;\n@@ -142,13 +141,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         r\n     }\n \n-    fn emit_lazy_distance(&mut self, position: usize, min_size: usize)\n+    fn emit_lazy_distance(&mut self,\n+                          position: usize,\n+                          min_size: usize)\n                           -> Result<(), <Self as Encoder>::Error> {\n         let min_end = position + min_size;\n         let distance = match self.lazy_state {\n-            LazyState::NoNode => {\n-                bug!(\"emit_lazy_distance: outside of a metadata node\")\n-            }\n+            LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n                 assert!(min_end <= start);\n                 start - min_end\n@@ -172,7 +171,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-    where I: IntoIterator<Item=T>, T: Encodable {\n+        where I: IntoIterator<Item = T>,\n+              T: Encodable\n+    {\n         self.emit_node(|ecx, pos| {\n             let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n \n@@ -182,7 +183,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n-    where I: IntoIterator<Item=&'b T>, T: 'b + Encodable {\n+        where I: IntoIterator<Item = &'b T>,\n+              T: 'b + Encodable\n+    {\n         self.emit_node(|ecx, pos| {\n             let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n \n@@ -192,11 +195,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     /// Encode the given value or a previously cached shorthand.\n-    fn encode_with_shorthand<T, U, M>(&mut self, value: &T, variant: &U, map: M)\n+    fn encode_with_shorthand<T, U, M>(&mut self,\n+                                      value: &T,\n+                                      variant: &U,\n+                                      map: M)\n                                       -> Result<(), <Self as Encoder>::Error>\n-    where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n-          T: Clone + Eq + Hash,\n-          U: Encodable {\n+        where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n+              T: Clone + Eq + Hash,\n+              U: Encodable\n+    {\n         let existing_shorthand = map(self).get(value).cloned();\n         if let Some(shorthand) = existing_shorthand {\n             return self.emit_usize(shorthand);\n@@ -208,9 +215,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // The shorthand encoding uses the same usize as the\n         // discriminant, with an offset so they can't conflict.\n-        let discriminant = unsafe {\n-            intrinsics::discriminant_value(variant)\n-        };\n+        let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n         assert!(discriminant < SHORTHAND_OFFSET as u64);\n         let shorthand = start + SHORTHAND_OFFSET;\n \n@@ -250,8 +255,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// the right to access any information in the adt-def (including,\n     /// e.g., the length of the various vectors).\n     fn encode_enum_variant_info(&mut self,\n-                                (enum_did, Untracked(index)):\n-                                (DefId, Untracked<usize>)) -> Entry<'tcx> {\n+                                (enum_did, Untracked(index)): (DefId, Untracked<usize>))\n+                                -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -260,7 +265,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             disr: variant.disr_val.to_u64_unchecked(),\n-            struct_ctor: None\n+            struct_ctor: None,\n         };\n \n         let enum_id = tcx.map.as_local_node_id(enum_did).unwrap();\n@@ -285,24 +290,23 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n     fn encode_info_for_mod(&mut self,\n-                           FromId(id, (md, attrs, vis)):\n-                           FromId<(&hir::Mod, &[ast::Attribute], &hir::Visibility)>)\n+                           FromId(id, (md, attrs, vis)): FromId<(&hir::Mod,\n+                                                                 &[ast::Attribute],\n+                                                                 &hir::Visibility)>)\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.map.local_def_id(id);\n \n         let data = ModData {\n             reexports: match self.reexports.get(&id) {\n-                Some(exports) if *vis == hir::Public => {\n-                    self.lazy_seq_ref(exports)\n-                }\n-                _ => LazySeq::empty()\n-            }\n+                Some(exports) if *vis == hir::Public => self.lazy_seq_ref(exports),\n+                _ => LazySeq::empty(),\n+            },\n         };\n \n         Entry {\n@@ -353,8 +357,7 @@ impl Visibility for ty::Visibility {\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    fn encode_fields(&mut self,\n-                     adt_def_id: DefId) {\n+    fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.lookup_adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n@@ -374,8 +377,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// the adt-def (including, e.g., the length of the various\n     /// vectors).\n     fn encode_field(&mut self,\n-                    (adt_def_id, Untracked((variant_index, field_index))):\n-                    (DefId, Untracked<(usize, usize)>)) -> Entry<'tcx> {\n+                    (adt_def_id, Untracked((variant_index, field_index))): (DefId,\n+                                                                            Untracked<(usize,\n+                                                                                       usize)>))\n+                    -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let variant = &tcx.lookup_adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n@@ -400,19 +405,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n-    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId))\n-                          -> Entry<'tcx> {\n+    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let variant = tcx.lookup_adt_def(adt_def_id).struct_variant();\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             disr: variant.disr_val.to_u64_unchecked(),\n-            struct_ctor: Some(def_id.index)\n+            struct_ctor: Some(def_id.index),\n         };\n \n         let struct_id = tcx.map.as_local_node_id(adt_def_id).unwrap();\n@@ -434,7 +438,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n@@ -469,21 +473,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let fn_data = if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl)\n+                        arg_names: self.encode_fn_arg_names(&sig.decl),\n                     }\n                 } else {\n                     bug!()\n                 };\n                 let data = MethodData {\n                     fn_data: fn_data,\n                     container: container(method_ty.has_body),\n-                    explicit_self: self.lazy(&method_ty.explicit_self)\n+                    explicit_self: self.lazy(&method_ty.explicit_self),\n                 };\n                 EntryKind::Method(self.lazy(&data))\n             }\n-            ty::TypeTraitItem(_) => {\n-                EntryKind::AssociatedType(container(false))\n-            }\n+            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container(false)),\n         };\n \n         Entry {\n@@ -497,9 +499,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ty: match trait_item {\n                 ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n+                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n                 ty::TypeTraitItem(ref associated_type) => {\n                     associated_type.ty.map(|ty| self.lazy(&ty))\n                 }\n@@ -515,7 +515,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            mir: self.encode_mir(def_id)\n+            mir: self.encode_mir(def_id),\n         }\n     }\n \n@@ -527,32 +527,28 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let container = match ast_item.defaultness {\n             hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n-            hir::Defaultness::Final => AssociatedContainer::ImplFinal\n+            hir::Defaultness::Final => AssociatedContainer::ImplFinal,\n         };\n \n         let kind = match impl_item {\n-            ty::ConstTraitItem(_) => {\n-                EntryKind::AssociatedConst(container)\n-            }\n+            ty::ConstTraitItem(_) => EntryKind::AssociatedConst(container),\n             ty::MethodTraitItem(ref method_ty) => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: sig.constness,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl)\n+                        arg_names: self.encode_fn_arg_names(&sig.decl),\n                     }\n                 } else {\n                     bug!()\n                 };\n                 let data = MethodData {\n                     fn_data: fn_data,\n                     container: container,\n-                    explicit_self: self.lazy(&method_ty.explicit_self)\n+                    explicit_self: self.lazy(&method_ty.explicit_self),\n                 };\n                 EntryKind::Method(self.lazy(&data))\n             }\n-            ty::TypeTraitItem(_) => {\n-                EntryKind::AssociatedType(container)\n-            }\n+            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container),\n         };\n \n         let (ast, mir) = if let ty::ConstTraitItem(_) = impl_item {\n@@ -578,9 +574,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ty: match impl_item {\n                 ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n+                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n                 ty::TypeTraitItem(ref associated_type) => {\n                     associated_type.ty.map(|ty| self.lazy(&ty))\n                 }\n@@ -595,11 +589,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            mir: if mir {\n-                self.encode_mir(def_id)\n-            } else {\n-                None\n-            }\n+            mir: if mir { self.encode_mir(def_id) } else { None },\n         }\n     }\n \n@@ -613,8 +603,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }))\n     }\n \n-    fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::repr::Mir<'tcx>>> {\n-        self.mir_map.map.get(&def_id).map(|mir| self.lazy(mir))\n+    fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n+        self.tcx.mir_map.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n@@ -638,8 +628,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n-    fn encode_info_for_item(&mut self,\n-                            (def_id, item): (DefId, &hir::Item)) -> Entry<'tcx> {\n+    fn encode_info_for_item(&mut self, (def_id, item): (DefId, &hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n         debug!(\"encoding info for item at {}\",\n@@ -652,7 +641,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemFn(ref decl, _, constness, ..) => {\n                 let data = FnData {\n                     constness: constness,\n-                    arg_names: self.encode_fn_arg_names(&decl)\n+                    arg_names: self.encode_fn_arg_names(&decl),\n                 };\n \n                 EntryKind::Fn(self.lazy(&data))\n@@ -666,9 +655,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n-                /* Encode def_ids for each field and method\n-                for methods, write all the stuff get_trait_method\n-                needs to know*/\n+                // Encode def_ids for each field and method\n+                // for methods, write all the stuff get_trait_method\n+                // needs to know\n                 let struct_ctor = if !struct_def.is_struct() {\n                     Some(tcx.map.local_def_id(struct_def.id()).index)\n                 } else {\n@@ -677,7 +666,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u64_unchecked(),\n-                    struct_ctor: struct_ctor\n+                    struct_ctor: struct_ctor,\n                 }))\n             }\n             hir::ItemUnion(..) => {\n@@ -686,15 +675,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u64_unchecked(),\n-                    struct_ctor: None\n+                    struct_ctor: None,\n                 }))\n             }\n             hir::ItemDefaultImpl(..) => {\n                 let data = ImplData {\n                     polarity: hir::ImplPolarity::Positive,\n                     parent_impl: None,\n                     coerce_unsized_kind: None,\n-                    trait_ref: tcx.impl_trait_ref(def_id).map(|trait_ref| self.lazy(&trait_ref))\n+                    trait_ref: tcx.impl_trait_ref(def_id).map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n                 EntryKind::DefaultImpl(self.lazy(&data))\n@@ -716,9 +705,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n-                    coerce_unsized_kind: tcx.custom_coerce_unsized_kinds.borrow()\n-                                            .get(&def_id).cloned(),\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref))\n+                    coerce_unsized_kind: tcx.custom_coerce_unsized_kinds\n+                        .borrow()\n+                        .get(&def_id)\n+                        .cloned(),\n+                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n                 EntryKind::Impl(self.lazy(&data))\n@@ -730,14 +721,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n                     trait_ref: self.lazy(&trait_def.trait_ref),\n-                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id))\n+                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(&data))\n             }\n-            hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n-                bug!(\"cannot encode info for item {:?}\", item)\n-            }\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(_) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n@@ -747,9 +737,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemForeignMod(ref fm) => {\n-                    self.lazy_seq(fm.items.iter().map(|foreign_item| {\n-                        tcx.map.local_def_id(foreign_item.id).index\n-                    }))\n+                    self.lazy_seq(fm.items\n+                        .iter()\n+                        .map(|foreign_item| tcx.map.local_def_id(foreign_item.id).index))\n                 }\n                 hir::ItemEnum(..) => {\n                     let def = self.tcx.lookup_adt_def(def_id);\n@@ -773,7 +763,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         def_id.index\n                     }))\n                 }\n-                _ => LazySeq::empty()\n+                _ => LazySeq::empty(),\n             },\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -786,20 +776,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemImpl(..) => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n-                _ => None\n+                hir::ItemImpl(..) => Some(self.encode_item_type(def_id)),\n+                _ => None,\n             },\n             inherent_impls: self.encode_inherent_implementations(def_id),\n             variances: match item.node {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => {\n-                    self.encode_item_variances(def_id)\n-                }\n-                _ => LazySeq::empty()\n+                hir::ItemTrait(..) => self.encode_item_variances(def_id),\n+                _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n                 hir::ItemStatic(..) |\n@@ -810,10 +796,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemImpl(..) |\n-                hir::ItemTrait(..) => {\n-                    Some(self.encode_generics(def_id))\n-                }\n-                _ => None\n+                hir::ItemTrait(..) => Some(self.encode_generics(def_id)),\n+                _ => None,\n             },\n             predicates: match item.node {\n                 hir::ItemStatic(..) |\n@@ -824,23 +808,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemImpl(..) |\n-                hir::ItemTrait(..) => {\n-                    Some(self.encode_predicates(def_id))\n-                }\n-                _ => None\n+                hir::ItemTrait(..) => Some(self.encode_predicates(def_id)),\n+                _ => None,\n             },\n \n             ast: match item.node {\n                 hir::ItemConst(..) |\n                 hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n                     Some(self.encode_inlined_item(InlinedItemRef::Item(def_id, item)))\n                 }\n-                _ => None\n+                _ => None,\n             },\n             mir: match item.node {\n-                hir::ItemConst(..) => {\n-                    self.encode_mir(def_id)\n-                }\n+                hir::ItemConst(..) => self.encode_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let tps_len = generics.ty_params.len();\n                     let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n@@ -850,8 +830,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         None\n                     }\n                 }\n-                _ => None\n-            }\n+                _ => None,\n+            },\n         }\n     }\n }\n@@ -861,8 +841,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n-    fn encode_addl_info_for_item(&mut self,\n-                                 item: &hir::Item) {\n+    fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemStatic(..) |\n@@ -930,12 +909,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ForeignItemFn(ref fndecl, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(&fndecl)\n+                    arg_names: self.encode_fn_arg_names(&fndecl),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }\n             hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic\n+            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic,\n         };\n \n         Entry {\n@@ -954,7 +933,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n }\n@@ -972,10 +951,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_item(self, item);\n         let def_id = self.index.tcx.map.local_def_id(item.id);\n         match item.node {\n-            hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n-            _ => self.index.record(def_id,\n-                                   EncodeContext::encode_info_for_item,\n-                                   (def_id, item)),\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(_) => (), // ignore these\n+            _ => self.index.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n     }\n@@ -996,21 +974,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = self.tcx.map.local_def_id(ty.id);\n-            self.record(def_id,\n-                        EncodeContext::encode_info_for_anon_ty,\n-                        def_id);\n+            self.record(def_id, EncodeContext::encode_info_for_anon_ty, def_id);\n         }\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(..) => {\n                 let def_id = self.tcx.map.local_def_id(expr.id);\n-                self.record(def_id,\n-                            EncodeContext::encode_info_for_closure,\n-                            def_id);\n+                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n }\n@@ -1033,7 +1007,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n@@ -1042,7 +1016,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id])\n+            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id]),\n         };\n \n         Entry {\n@@ -1061,7 +1035,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: None,\n \n             ast: None,\n-            mir: self.encode_mir(def_id)\n+            mir: self.encode_mir(def_id),\n         }\n     }\n \n@@ -1071,9 +1045,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      EncodeContext::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n-        let mut visitor = EncodeVisitor {\n-            index: index,\n-        };\n+        let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_items(&mut visitor);\n         visitor.index.into_items()\n     }\n@@ -1083,8 +1055,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n-        fn get_ordered_deps(cstore: &cstore::CStore)\n-                            -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n+        fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n             // Pull the cnums and name,vers,hash out of cstore\n             let mut deps = Vec::new();\n             cstore.iter_crate_data(|cnum, val| {\n@@ -1113,13 +1084,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             CrateDep {\n                 name: syntax::parse::token::intern(dep.name()),\n                 hash: dep.hash(),\n-                explicitly_linked: dep.explicitly_linked.get()\n+                explicitly_linked: dep.explicitly_linked.get(),\n             }\n         }))\n     }\n \n-    fn encode_lang_items(&mut self)\n-                         -> (LazySeq<(DefIndex, usize)>, LazySeq<lang_items::LangItem>) {\n+    fn encode_lang_items(&mut self) -> (LazySeq<(DefIndex, usize)>, LazySeq<lang_items::LangItem>) {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items.items().iter();\n         (self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n@@ -1129,31 +1099,32 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }\n             None\n-        })), self.lazy_seq_ref(&tcx.lang_items.missing))\n+        })),\n+         self.lazy_seq_ref(&tcx.lang_items.missing))\n     }\n \n     fn encode_native_libraries(&mut self) -> LazySeq<(NativeLibraryKind, String)> {\n         let used_libraries = self.tcx.sess.cstore.used_libraries();\n         self.lazy_seq(used_libraries.into_iter().filter_map(|(lib, kind)| {\n             match kind {\n                 cstore::NativeStatic => None, // these libraries are not propagated\n-                cstore::NativeFramework | cstore::NativeUnknown => {\n-                    Some((kind, lib))\n-                }\n+                cstore::NativeFramework | cstore::NativeUnknown => Some((kind, lib)),\n             }\n         }))\n     }\n \n     fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n         let codemap = self.tcx.sess.codemap();\n         let all_filemaps = codemap.files.borrow();\n-        self.lazy_seq_ref(all_filemaps.iter().filter(|filemap| {\n-            // No need to export empty filemaps, as they can't contain spans\n-            // that need translation.\n-            // Also no need to re-export imported filemaps, as any downstream\n-            // crate will import them from their original source.\n-            !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n-        }).map(|filemap| &**filemap))\n+        self.lazy_seq_ref(all_filemaps.iter()\n+            .filter(|filemap| {\n+                // No need to export empty filemaps, as they can't contain spans\n+                // that need translation.\n+                // Also no need to re-export imported filemaps, as any downstream\n+                // crate will import them from their original source.\n+                !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n+            })\n+            .map(|filemap| &**filemap))\n     }\n \n     /// Serialize the text of the exported macros\n@@ -1164,23 +1135,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 name: def.name,\n                 attrs: def.attrs.to_vec(),\n                 span: def.span,\n-                body: ::syntax::print::pprust::tts_to_string(&def.body)\n+                body: ::syntax::print::pprust::tts_to_string(&def.body),\n             }\n         }))\n     }\n }\n \n-struct ImplVisitor<'a, 'tcx:'a> {\n+struct ImplVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FnvHashMap<DefId, Vec<DefIndex>>\n+    impls: FnvHashMap<DefId, Vec<DefIndex>>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemImpl(..) = item.node {\n             let impl_id = self.tcx.map.local_def_id(item.id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n-                self.impls.entry(trait_ref.def_id)\n+                self.impls\n+                    .entry(trait_ref.def_id)\n                     .or_insert(vec![])\n                     .push(impl_id.index);\n             }\n@@ -1193,16 +1165,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n-            impls: FnvHashMap()\n+            impls: FnvHashMap(),\n         };\n         self.tcx.map.krate().visit_all_items(&mut visitor);\n \n-        let all_impls: Vec<_> = visitor.impls.into_iter().map(|(trait_def_id, impls)| {\n-            TraitImpls {\n-                trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                impls: self.lazy_seq(impls)\n-            }\n-        }).collect();\n+        let all_impls: Vec<_> = visitor.impls\n+            .into_iter()\n+            .map(|(trait_def_id, impls)| {\n+                TraitImpls {\n+                    trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n+                    impls: self.lazy_seq(impls),\n+                }\n+            })\n+            .collect();\n \n         self.lazy_seq(all_impls)\n     }\n@@ -1232,7 +1207,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 }))\n             }\n-            None => LazySeq::empty()\n+            None => LazySeq::empty(),\n         }\n     }\n \n@@ -1291,9 +1266,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n             panic_strategy: tcx.sess.panic_strategy(),\n-            plugin_registrar_fn: tcx.sess.plugin_registrar_fn.get().map(|id| {\n-                tcx.map.local_def_id(id).index\n-            }),\n+            plugin_registrar_fn: tcx.sess\n+                .plugin_registrar_fn\n+                .get()\n+                .map(|id| tcx.map.local_def_id(id).index),\n             macro_derive_registrar: if is_proc_macro {\n                 let id = tcx.sess.derive_registrar_fn.get().unwrap();\n                 Some(tcx.map.local_def_id(id).index)\n@@ -1368,35 +1344,35 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cstore: &cstore::CStore,\n                                  reexports: &def::ExportMap,\n                                  link_meta: &LinkMeta,\n-                                 reachable: &NodeSet,\n-                                 mir_map: &MirMap<'tcx>) -> Vec<u8> {\n+                                 reachable: &NodeSet)\n+                                 -> Vec<u8> {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n \n     // Will be filed with the root position after encoding everything.\n     cursor.write_all(&[0, 0, 0, 0]).unwrap();\n \n     let root = EncodeContext {\n-        opaque: opaque::Encoder::new(&mut cursor),\n-        tcx: tcx,\n-        reexports: reexports,\n-        link_meta: link_meta,\n-        cstore: cstore,\n-        reachable: reachable,\n-        mir_map: mir_map,\n-        lazy_state: LazyState::NoNode,\n-        type_shorthands: Default::default(),\n-        predicate_shorthands: Default::default()\n-    }.encode_crate_root();\n+            opaque: opaque::Encoder::new(&mut cursor),\n+            tcx: tcx,\n+            reexports: reexports,\n+            link_meta: link_meta,\n+            cstore: cstore,\n+            reachable: reachable,\n+            lazy_state: LazyState::NoNode,\n+            type_shorthands: Default::default(),\n+            predicate_shorthands: Default::default(),\n+        }\n+        .encode_crate_root();\n     let mut result = cursor.into_inner();\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n     let pos = root.position;\n     result[header + 0] = (pos >> 24) as u8;\n     result[header + 1] = (pos >> 16) as u8;\n-    result[header + 2] = (pos >>  8) as u8;\n-    result[header + 3] = (pos >>  0) as u8;\n+    result[header + 2] = (pos >> 8) as u8;\n+    result[header + 3] = (pos >> 0) as u8;\n \n     result\n }"}, {"sha": "53e6988c756c947d33dee83c6ab4c4bef33f1c42", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -28,9 +28,7 @@ pub struct Index {\n \n impl Index {\n     pub fn new(max_index: usize) -> Index {\n-        Index {\n-            positions: vec![u32::MAX; max_index]\n-        }\n+        Index { positions: vec![u32::MAX; max_index] }\n     }\n \n     pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry>) {\n@@ -46,7 +44,9 @@ impl Index {\n \n         assert!(self.positions[item] == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n-                item, self.positions[item], position);\n+                item,\n+                self.positions[item],\n+                position);\n \n         self.positions[item] = position.to_le();\n     }\n@@ -67,7 +67,8 @@ impl<'tcx> LazySeq<Index> {\n         let index = def_index.as_usize();\n \n         debug!(\"Index::lookup: index={:?} words.len={:?}\",\n-               index, words.len());\n+               index,\n+               words.len());\n \n         let position = u32::from_le(words[index]);\n         if position == u32::MAX {\n@@ -79,8 +80,9 @@ impl<'tcx> LazySeq<Index> {\n         }\n     }\n \n-    pub fn iter_enumerated<'a>(&self, bytes: &'a [u8])\n-                               -> impl Iterator<Item=(DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n+    pub fn iter_enumerated<'a>(&self,\n+                               bytes: &'a [u8])\n+                               -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n         let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n         words.iter().enumerate().filter_map(|(index, &position)| {\n             if position == u32::MAX {"}, {"sha": "9938e20d1861d83a799a39762ba8d3fa4983c8cd", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -138,11 +138,11 @@ pub trait DepGraphRead {\n }\n \n impl DepGraphRead for DefId {\n-    fn read(&self, _tcx: TyCtxt) { }\n+    fn read(&self, _tcx: TyCtxt) {}\n }\n \n impl DepGraphRead for ast::NodeId {\n-    fn read(&self, _tcx: TyCtxt) { }\n+    fn read(&self, _tcx: TyCtxt) {}\n }\n \n impl<T> DepGraphRead for Option<T>\n@@ -179,8 +179,8 @@ macro_rules! read_tuple {\n         }\n     }\n }\n-read_tuple!(A,B);\n-read_tuple!(A,B,C);\n+read_tuple!(A, B);\n+read_tuple!(A, B, C);\n \n macro_rules! read_hir {\n     ($t:ty) => {\n@@ -208,7 +208,7 @@ read_hir!(hir::ForeignItem);\n pub struct Untracked<T>(pub T);\n \n impl<T> DepGraphRead for Untracked<T> {\n-    fn read(&self, _tcx: TyCtxt) { }\n+    fn read(&self, _tcx: TyCtxt) {}\n }\n \n /// Newtype that can be used to package up misc data extracted from a"}, {"sha": "ef81dbd7f29ec79975f4d34db7269721b53506fe", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -30,8 +30,10 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n \n-#[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate flate;\n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "0461d7ec061d4010bb206f50ccc2367e8af8e7c0", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 164, "deletions": 125, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -273,33 +273,33 @@ pub struct ArchiveMetadata {\n pub struct CratePaths {\n     pub ident: String,\n     pub dylib: Option<PathBuf>,\n-    pub rlib: Option<PathBuf>\n+    pub rlib: Option<PathBuf>,\n }\n \n pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n-    Dylib\n+    Dylib,\n }\n \n impl fmt::Display for CrateFlavor {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(match *self {\n             CrateFlavor::Rlib => \"rlib\",\n-            CrateFlavor::Dylib => \"dylib\"\n+            CrateFlavor::Dylib => \"dylib\",\n         })\n     }\n }\n \n impl CratePaths {\n     fn paths(&self) -> Vec<PathBuf> {\n         match (&self.dylib, &self.rlib) {\n-            (&None,    &None)              => vec!(),\n+            (&None, &None) => vec![],\n             (&Some(ref p), &None) |\n-            (&None, &Some(ref p))          => vec!(p.clone()),\n-            (&Some(ref p1), &Some(ref p2)) => vec!(p1.clone(), p2.clone()),\n+            (&None, &Some(ref p)) => vec![p.clone()],\n+            (&Some(ref p1), &Some(ref p2)) => vec![p1.clone(), p2.clone()],\n         }\n     }\n }\n@@ -316,53 +316,72 @@ impl<'a> Context<'a> {\n     pub fn report_errs(&mut self) -> ! {\n         let add = match self.root {\n             &None => String::new(),\n-            &Some(ref r) => format!(\" which `{}` depends on\",\n-                                    r.ident)\n+            &Some(ref r) => format!(\" which `{}` depends on\", r.ident),\n         };\n         let mut err = if !self.rejected_via_hash.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0460,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0460,\n                              \"found possibly newer version of crate `{}`{}\",\n-                             self.ident, add)\n+                             self.ident,\n+                             add)\n         } else if !self.rejected_via_triple.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0461,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0461,\n                              \"couldn't find crate `{}` with expected target triple {}{}\",\n-                             self.ident, self.triple, add)\n+                             self.ident,\n+                             self.triple,\n+                             add)\n         } else if !self.rejected_via_kind.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0462,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0462,\n                              \"found staticlib `{}` instead of rlib or dylib{}\",\n-                             self.ident, add)\n+                             self.ident,\n+                             add)\n         } else if !self.rejected_via_version.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0514,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0514,\n                              \"found crate `{}` compiled by an incompatible version of rustc{}\",\n-                             self.ident, add)\n+                             self.ident,\n+                             add)\n         } else {\n-            let mut err = struct_span_err!(self.sess, self.span, E0463,\n+            let mut err = struct_span_err!(self.sess,\n+                                           self.span,\n+                                           E0463,\n                                            \"can't find crate for `{}`{}\",\n-                                           self.ident, add);\n+                                           self.ident,\n+                                           add);\n             err.span_label(self.span, &format!(\"can't find crate\"));\n             err\n         };\n \n         if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n-            for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n+            for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                                  self.ident, i+1, got, path.display()));\n+                                  self.ident,\n+                                  i + 1,\n+                                  got,\n+                                  path.display()));\n             }\n         }\n         if !self.rejected_via_hash.is_empty() {\n             err.note(\"perhaps that crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n-            for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n-                err.note(&format!(\"crate `{}` path #{}: {}\",\n-                                  self.ident, i+1, path.display()));\n+            for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n+                err.note(&format!(\"crate `{}` path #{}: {}\", self.ident, i + 1, path.display()));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         err.note(&format!(\"crate `{}` path #{}: {}\",\n-                                          r.ident, i+1, path.display()));\n+                                          r.ident,\n+                                          i + 1,\n+                                          path.display()));\n                     }\n                 }\n             }\n@@ -371,8 +390,7 @@ impl<'a> Context<'a> {\n             err.help(\"please recompile that crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n-                err.note(&format!(\"crate `{}` path #{}: {}\",\n-                                  self.ident, i+1, path.display()));\n+                err.note(&format!(\"crate `{}` path #{}: {}\", self.ident, i + 1, path.display()));\n             }\n         }\n         if !self.rejected_via_version.is_empty() {\n@@ -381,7 +399,10 @@ impl<'a> Context<'a> {\n             let mismatches = self.rejected_via_version.iter();\n             for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {} compiled by {:?}\",\n-                                  self.ident, i+1, path.display(), got));\n+                                  self.ident,\n+                                  i + 1,\n+                                  path.display(),\n+                                  got));\n             }\n         }\n \n@@ -410,7 +431,7 @@ impl<'a> Context<'a> {\n         let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n \n         let mut candidates = FnvHashMap();\n-        let mut staticlibs = vec!();\n+        let mut staticlibs = vec![];\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n         // the name of the files themselves. We're trying to match against an\n@@ -430,38 +451,36 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) &&\n-                                  file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n-                 true)\n+            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n+                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], true)\n             } else if file.starts_with(&dylib_prefix) &&\n-                      file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n-                 false)\n+                                         file.ends_with(&dypair.1) {\n+                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], false)\n             } else {\n-                if file.starts_with(&staticlib_prefix[..]) &&\n-                   file.ends_with(&staticpair.1) {\n+                if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n                     staticlibs.push(CrateMismatch {\n                         path: path.to_path_buf(),\n-                        got: \"static\".to_string()\n+                        got: \"static\".to_string(),\n                     });\n                 }\n-                return FileDoesntMatch\n+                return FileDoesntMatch;\n             };\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                                 .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n+                .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n-            fs::canonicalize(path).map(|p| {\n-                if rlib {\n-                    rlibs.insert(p, kind);\n-                } else {\n-                    dylibs.insert(p, kind);\n-                }\n-                FileMatches\n-            }).unwrap_or(FileDoesntMatch)\n+            fs::canonicalize(path)\n+                .map(|p| {\n+                    if rlib {\n+                        rlibs.insert(p, kind);\n+                    } else {\n+                        dylibs.insert(p, kind);\n+                    }\n+                    FileMatches\n+                })\n+                .unwrap_or(FileDoesntMatch)\n         });\n         self.rejected_via_kind.extend(staticlibs);\n \n@@ -479,11 +498,12 @@ impl<'a> Context<'a> {\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n             let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n             if let Some((h, m)) = slot {\n-                libraries.insert(h, Library {\n-                    dylib: dylib,\n-                    rlib: rlib,\n-                    metadata: m,\n-                });\n+                libraries.insert(h,\n+                                 Library {\n+                                     dylib: dylib,\n+                                     rlib: rlib,\n+                                     metadata: m,\n+                                 });\n             }\n         }\n \n@@ -494,7 +514,9 @@ impl<'a> Context<'a> {\n             0 => None,\n             1 => Some(libraries.into_iter().next().unwrap().1),\n             _ => {\n-                let mut err = struct_span_err!(self.sess, self.span, E0464,\n+                let mut err = struct_span_err!(self.sess,\n+                                               self.span,\n+                                               E0464,\n                                                \"multiple matching crates for `{}`\",\n                                                self.crate_name);\n                 err.note(\"candidates:\");\n@@ -521,8 +543,11 @@ impl<'a> Context<'a> {\n     // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n-    fn extract_one(&mut self, m: FnvHashMap<PathBuf, PathKind>, flavor: CrateFlavor,\n-                   slot: &mut Option<(Svh, MetadataBlob)>) -> Option<(PathBuf, PathKind)> {\n+    fn extract_one(&mut self,\n+                   m: FnvHashMap<PathBuf, PathKind>,\n+                   flavor: CrateFlavor,\n+                   slot: &mut Option<(Svh, MetadataBlob)>)\n+                   -> Option<(PathBuf, PathKind)> {\n         let mut ret: Option<(PathBuf, PathKind)> = None;\n         let mut error = 0;\n \n@@ -532,9 +557,9 @@ impl<'a> Context<'a> {\n             //                read both, but reading dylib metadata is quite\n             //                slow.\n             if m.is_empty() {\n-                return None\n+                return None;\n             } else if m.len() == 1 {\n-                return Some(m.into_iter().next().unwrap())\n+                return Some(m.into_iter().next().unwrap());\n             }\n         }\n \n@@ -547,23 +572,28 @@ impl<'a> Context<'a> {\n                         (h, blob)\n                     } else {\n                         info!(\"metadata mismatch\");\n-                        continue\n+                        continue;\n                     }\n                 }\n                 Err(err) => {\n                     info!(\"no metadata found: {}\", err);\n-                    continue\n+                    continue;\n                 }\n             };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n-                let mut e = struct_span_err!(self.sess, self.span, E0465,\n+                let mut e = struct_span_err!(self.sess,\n+                                             self.span,\n+                                             E0465,\n                                              \"multiple {} candidates for `{}` found\",\n-                                             flavor, self.crate_name);\n+                                             flavor,\n+                                             self.crate_name);\n                 e.span_note(self.span,\n                             &format!(r\"candidate #1: {}\",\n-                                     ret.as_ref().unwrap().0\n-                                        .display()));\n+                                     ret.as_ref()\n+                                         .unwrap()\n+                                         .0\n+                                         .display()));\n                 if let Some(ref mut e) = err {\n                     e.emit();\n                 }\n@@ -574,9 +604,10 @@ impl<'a> Context<'a> {\n             if error > 0 {\n                 error += 1;\n                 err.as_mut().unwrap().span_note(self.span,\n-                                                &format!(r\"candidate #{}: {}\", error,\n+                                                &format!(r\"candidate #{}: {}\",\n+                                                         error,\n                                                          lib.display()));\n-                continue\n+                continue;\n             }\n             *slot = Some((hash, metadata));\n             ret = Some((lib, kind));\n@@ -595,37 +626,39 @@ impl<'a> Context<'a> {\n         let rustc_version = rustc_version();\n         if root.rustc_version != rustc_version {\n             info!(\"Rejecting via version: expected {} got {}\",\n-                  rustc_version, root.rustc_version);\n+                  rustc_version,\n+                  root.rustc_version);\n             self.rejected_via_version.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: root.rustc_version\n+                got: root.rustc_version,\n             });\n             return None;\n         }\n \n         if self.should_match_name {\n             if self.crate_name != root.name {\n-                info!(\"Rejecting via crate name\"); return None;\n+                info!(\"Rejecting via crate name\");\n+                return None;\n             }\n         }\n \n         if root.triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\",\n-                  self.triple, root.triple);\n+                  self.triple,\n+                  root.triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: root.triple\n+                got: root.triple,\n             });\n             return None;\n         }\n \n         if let Some(myhash) = self.hash {\n             if *myhash != root.hash {\n-                info!(\"Rejecting via hash: expected {} got {}\",\n-                      *myhash, root.hash);\n+                info!(\"Rejecting via hash: expected {} got {}\", *myhash, root.hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n-                    got: myhash.to_string()\n+                    got: myhash.to_string(),\n                 });\n                 return None;\n             }\n@@ -649,8 +682,8 @@ impl<'a> Context<'a> {\n         (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n     }\n \n-    fn find_commandline_library<'b, LOCS> (&mut self, locs: LOCS) -> Option<Library>\n-        where LOCS: Iterator<Item=&'b String>\n+    fn find_commandline_library<'b, LOCS>(&mut self, locs: LOCS) -> Option<Library>\n+        where LOCS: Iterator<Item = &'b String>\n     {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n@@ -663,30 +696,33 @@ impl<'a> Context<'a> {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display()));\n+                                      self.crate_name,\n+                                      loc.display()));\n                     return false;\n                 }\n                 let file = match loc.file_name().and_then(|s| s.to_str()) {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display()));\n+                                          self.crate_name,\n+                                          loc.display()));\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n-                    return true\n+                    return true;\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(&prefix[..]) &&\n-                       file.ends_with(&suffix[..]) {\n-                        return true\n+                    if file.starts_with(&prefix[..]) && file.ends_with(&suffix[..]) {\n+                        return true;\n                     }\n                 }\n                 sess.struct_err(&format!(\"extern location for {} is of an unknown type: {}\",\n-                                         self.crate_name, loc.display()))\n+                                         self.crate_name,\n+                                         loc.display()))\n                     .help(&format!(\"file name should be lib*.rlib or {}*.{}\",\n-                                   dylibname.0, dylibname.1))\n+                                   dylibname.0,\n+                                   dylibname.1))\n                     .emit();\n                 false\n             });\n@@ -695,11 +731,9 @@ impl<'a> Context<'a> {\n             // there's at most one rlib and at most one dylib.\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::canonicalize(&loc).unwrap(),\n-                                 PathKind::ExternFlag);\n+                    rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::canonicalize(&loc).unwrap(),\n-                                  PathKind::ExternFlag);\n+                    dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n             }\n         };\n@@ -709,13 +743,17 @@ impl<'a> Context<'a> {\n         let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n         let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n \n-        if rlib.is_none() && dylib.is_none() { return None }\n+        if rlib.is_none() && dylib.is_none() {\n+            return None;\n+        }\n         match slot {\n-            Some((_, metadata)) => Some(Library {\n-                dylib: dylib,\n-                rlib: rlib,\n-                metadata: metadata,\n-            }),\n+            Some((_, metadata)) => {\n+                Some(Library {\n+                    dylib: dylib,\n+                    rlib: rlib,\n+                    metadata: metadata,\n+                })\n+            }\n             None => None,\n         }\n     }\n@@ -728,9 +766,9 @@ pub fn note_crate_name(err: &mut DiagnosticBuilder, name: &str) {\n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n         let data = {\n-            let section = ar.iter().filter_map(|s| s.ok()).find(|sect| {\n-                sect.name() == Some(METADATA_FILENAME)\n-            });\n+            let section = ar.iter()\n+                .filter_map(|s| s.ok())\n+                .find(|sect| sect.name() == Some(METADATA_FILENAME));\n             match section {\n                 Some(s) => s.data() as *const [u8],\n                 None => {\n@@ -746,12 +784,14 @@ impl ArchiveMetadata {\n         })\n     }\n \n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] { unsafe { &*self.data } }\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        unsafe { &*self.data }\n+    }\n }\n \n-fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n-                                        -> Result<(), String>\n-{\n+fn verify_decompressed_encoding_version(blob: &MetadataBlob,\n+                                        filename: &Path)\n+                                        -> Result<(), String> {\n     if !blob.is_compatible() {\n         Err((format!(\"incompatible metadata version found: '{}'\",\n                      filename.display())))\n@@ -761,16 +801,21 @@ fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(target: &Target, flavor: CrateFlavor, filename: &Path)\n+fn get_metadata_section(target: &Target,\n+                        flavor: CrateFlavor,\n+                        filename: &Path)\n                         -> Result<MetadataBlob, String> {\n     let start = Instant::now();\n     let ret = get_metadata_section_imp(target, flavor, filename);\n-    info!(\"reading {:?} => {:?}\", filename.file_name().unwrap(),\n+    info!(\"reading {:?} => {:?}\",\n+          filename.file_name().unwrap(),\n           start.elapsed());\n-    return ret\n+    return ret;\n }\n \n-fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Path)\n+fn get_metadata_section_imp(target: &Target,\n+                            flavor: CrateFlavor,\n+                            filename: &Path)\n                             -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n@@ -783,13 +828,11 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n             Some(ar) => ar,\n             None => {\n                 debug!(\"llvm didn't like `{}`\", filename.display());\n-                return Err(format!(\"failed to read rlib metadata: '{}'\",\n-                                   filename.display()));\n+                return Err(format!(\"failed to read rlib metadata: '{}'\", filename.display()));\n             }\n         };\n         return match ArchiveMetadata::new(archive).map(|ar| MetadataBlob::Archive(ar)) {\n-            None => Err(format!(\"failed to read rlib metadata: '{}'\",\n-                                filename.display())),\n+            None => Err(format!(\"failed to read rlib metadata: '{}'\", filename.display())),\n             Some(blob) => {\n                 verify_decompressed_encoding_version(&blob, filename)?;\n                 Ok(blob)\n@@ -800,31 +843,27 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n         let buf = common::path2cstr(filename);\n         let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n         if mb as isize == 0 {\n-            return Err(format!(\"error reading library: '{}'\",\n-                               filename.display()))\n+            return Err(format!(\"error reading library: '{}'\", filename.display()));\n         }\n         let of = match ObjectFile::new(mb) {\n             Some(of) => of,\n             _ => {\n-                return Err((format!(\"provided path not an object file: '{}'\",\n-                                    filename.display())))\n+                return Err((format!(\"provided path not an object file: '{}'\", filename.display())))\n             }\n         };\n         let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = slice::from_raw_parts(name_buf as *const u8,\n-                                             name_len as usize).to_vec();\n+            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n             let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(target) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n                 let vlen = METADATA_HEADER.len();\n-                debug!(\"checking {} bytes of metadata-version stamp\",\n-                       vlen);\n+                debug!(\"checking {} bytes of metadata-version stamp\", vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let buf0 = slice::from_raw_parts(cvbuf, minsz);\n                 let version_ok = buf0 == METADATA_HEADER;\n@@ -834,8 +873,7 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 }\n \n                 let cvbuf1 = cvbuf.offset(vlen as isize);\n-                debug!(\"inflating {} bytes of compressed metadata\",\n-                       csz - vlen);\n+                debug!(\"inflating {} bytes of compressed metadata\", csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n                     Ok(inflated) => {\n@@ -879,14 +917,15 @@ pub fn read_meta_section_name(_target: &Target) -> &'static str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(target: &Target, path: &Path,\n-                          out: &mut io::Write) -> io::Result<()> {\n+pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n-    let flavor = if filename.ends_with(\".rlib\") { CrateFlavor::Rlib } else { CrateFlavor::Dylib };\n+    let flavor = if filename.ends_with(\".rlib\") {\n+        CrateFlavor::Rlib\n+    } else {\n+        CrateFlavor::Dylib\n+    };\n     match get_metadata_section(target, flavor, path) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n-        Err(msg) => {\n-            write!(out, \"{}\\n\", msg)\n-        }\n+        Err(msg) => write!(out, \"{}\\n\", msg),\n     }\n }"}, {"sha": "3d1bd77d8bc287f998112101f9f86f6d28a341ff", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -27,7 +27,8 @@ use syntax_pos::{self, Span};\n use std::marker::PhantomData;\n \n pub fn rustc_version() -> String {\n-    format!(\"rustc {}\", option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n+    format!(\"rustc {}\",\n+            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n }\n \n /// Metadata encoding version.\n@@ -41,11 +42,8 @@ pub const METADATA_VERSION: u8 = 3;\n /// as a length of 0 by old compilers.\n ///\n /// This header is followed by the position of the `CrateRoot`.\n-pub const METADATA_HEADER: &'static [u8; 12] = &[\n-    0, 0, 0, 0,\n-    b'r', b'u', b's', b't',\n-    0, 0, 0, METADATA_VERSION\n-];\n+pub const METADATA_HEADER: &'static [u8; 12] =\n+    &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n@@ -70,14 +68,14 @@ pub const SHORTHAND_OFFSET: usize = 0x80;\n #[must_use]\n pub struct Lazy<T> {\n     pub position: usize,\n-    _marker: PhantomData<T>\n+    _marker: PhantomData<T>,\n }\n \n impl<T> Lazy<T> {\n     pub fn with_position(position: usize) -> Lazy<T> {\n         Lazy {\n             position: position,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         }\n     }\n \n@@ -90,7 +88,9 @@ impl<T> Lazy<T> {\n \n impl<T> Copy for Lazy<T> {}\n impl<T> Clone for Lazy<T> {\n-    fn clone(&self) -> Self { *self }\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n }\n \n impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n@@ -112,7 +112,7 @@ impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n pub struct LazySeq<T> {\n     pub len: usize,\n     pub position: usize,\n-    _marker: PhantomData<T>\n+    _marker: PhantomData<T>,\n }\n \n impl<T> LazySeq<T> {\n@@ -124,7 +124,7 @@ impl<T> LazySeq<T> {\n         LazySeq {\n             len: len,\n             position: position,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         }\n     }\n \n@@ -136,7 +136,9 @@ impl<T> LazySeq<T> {\n \n impl<T> Copy for LazySeq<T> {}\n impl<T> Clone for LazySeq<T> {\n-    fn clone(&self) -> Self { *self }\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n }\n \n impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n@@ -155,7 +157,7 @@ pub enum LazyState {\n     /// Inside a metadata node, with a previous `Lazy` or `LazySeq`.\n     /// The position is a conservative estimate of where that\n     /// previous `Lazy` / `LazySeq` would end (see their comments).\n-    Previous(usize)\n+    Previous(usize),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -185,21 +187,21 @@ pub struct CrateRoot {\n pub struct CrateDep {\n     pub name: ast::Name,\n     pub hash: hir::svh::Svh,\n-    pub explicitly_linked: bool\n+    pub explicitly_linked: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n-    pub impls: LazySeq<DefIndex>\n+    pub impls: LazySeq<DefIndex>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub name: ast::Name,\n     pub attrs: Vec<ast::Attribute>,\n     pub span: Span,\n-    pub body: String\n+    pub body: String,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -219,7 +221,7 @@ pub struct Entry<'tcx> {\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n-    pub mir: Option<Lazy<mir::repr::Mir<'tcx>>>\n+    pub mir: Option<Lazy<mir::Mir<'tcx>>>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n@@ -245,18 +247,18 @@ pub enum EntryKind<'tcx> {\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n     Method(Lazy<MethodData<'tcx>>),\n     AssociatedType(AssociatedContainer),\n-    AssociatedConst(AssociatedContainer)\n+    AssociatedConst(AssociatedContainer),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n-    pub reexports: LazySeq<def::Export>\n+    pub reexports: LazySeq<def::Export>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {\n     pub constness: hir::Constness,\n-    pub arg_names: LazySeq<ast::Name>\n+    pub arg_names: LazySeq<ast::Name>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -266,7 +268,7 @@ pub struct VariantData {\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n-    pub struct_ctor: Option<DefIndex>\n+    pub struct_ctor: Option<DefIndex>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -275,15 +277,15 @@ pub struct TraitData<'tcx> {\n     pub paren_sugar: bool,\n     pub has_default_impl: bool,\n     pub trait_ref: Lazy<ty::TraitRef<'tcx>>,\n-    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>\n+    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n     pub parent_impl: Option<DefId>,\n     pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n-    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>\n+    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n \n /// Describes whether the container of an associated item\n@@ -294,21 +296,17 @@ pub enum AssociatedContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n-    ImplFinal\n+    ImplFinal,\n }\n \n impl AssociatedContainer {\n     pub fn with_def_id(&self, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n         match *self {\n             AssociatedContainer::TraitRequired |\n-            AssociatedContainer::TraitWithDefault => {\n-                ty::TraitContainer(def_id)\n-            }\n+            AssociatedContainer::TraitWithDefault => ty::TraitContainer(def_id),\n \n             AssociatedContainer::ImplDefault |\n-            AssociatedContainer::ImplFinal => {\n-                ty::ImplContainer(def_id)\n-            }\n+            AssociatedContainer::ImplFinal => ty::ImplContainer(def_id),\n         }\n     }\n \n@@ -318,7 +316,7 @@ impl AssociatedContainer {\n \n             AssociatedContainer::TraitWithDefault |\n             AssociatedContainer::ImplDefault |\n-            AssociatedContainer::ImplFinal => true\n+            AssociatedContainer::ImplFinal => true,\n         }\n     }\n \n@@ -328,7 +326,7 @@ impl AssociatedContainer {\n             AssociatedContainer::TraitWithDefault |\n             AssociatedContainer::ImplDefault => hir::Defaultness::Default,\n \n-            AssociatedContainer::ImplFinal => hir::Defaultness::Final\n+            AssociatedContainer::ImplFinal => hir::Defaultness::Final,\n         }\n     }\n }\n@@ -337,11 +335,11 @@ impl AssociatedContainer {\n pub struct MethodData<'tcx> {\n     pub fn_data: FnData,\n     pub container: AssociatedContainer,\n-    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>\n+    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub kind: ty::ClosureKind,\n-    pub ty: Lazy<ty::ClosureTy<'tcx>>\n+    pub ty: Lazy<ty::ClosureTy<'tcx>>,\n }"}, {"sha": "b53f8c4da86f224ea50cae87980eb9c3c4842af0", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {"}, {"sha": "9f612175e5da7ca6a4c86237679cce5ab707d26b", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,7 +14,7 @@\n //! Routines for manipulating the control-flow graph.\n \n use build::CFG;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n impl<'tcx> CFG<'tcx> {\n     pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {"}, {"sha": "6230123a9ca17d04adca22ff7b29cf3de2314ee9", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,7 +12,7 @@\n \n use build::Builder;\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that"}, {"sha": "58abaa0c484f2c914dae3618c9ce05d2ee45d348", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n use rustc_data_structures::indexed_vec::Idx;\n "}, {"sha": "09cdcc74ef63e7f9ae78d48f0a2fbc79c9b5a81b", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a value that can be used as an operand."}, {"sha": "490f675c3d5e3595907d6d0b2d0c7698aade2f42", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -22,7 +22,7 @@ use hair::*;\n use rustc_const_math::{ConstInt, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use syntax::ast;\n use syntax_pos::Span;\n "}, {"sha": "fb12e08affd2d04f2612633a43f90620170851f1", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building"}, {"sha": "5fa08442221001cce28bbcab1d6f6ab93121d010", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,7 +14,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc::ty;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which"}, {"sha": "4a1926e7c57d4ec59886a4b4fcfb1503ccac540b", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,7 +12,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::scope::LoopScope;\n use hair::*;\n use rustc::middle::region::CodeExtent;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {"}, {"sha": "5c133780e433b53b922ed0e1a8a644deec08715d", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,7 +16,7 @@\n \n use build::{BlockAnd, Builder};\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n pub trait EvalInto<'tcx> {\n     fn eval_into<'a, 'gcx>(self,"}, {"sha": "727e634ef92db2051817ae03911fb73cbf9a6029", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{AdtDef, Ty};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use hair::*;\n use syntax::ast::{Name, NodeId};\n use syntax_pos::Span;"}, {"sha": "71282dcf0ba0770e8cc6b0ef99e3ae6af918dc27", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,7 +25,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n use std::mem;\n "}, {"sha": "5984b0f7893cdf856f8d22f9e83b11ad4743c38a", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -22,7 +22,7 @@ use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use syntax_pos::Span;\n use std::cmp::Ordering;\n "}, {"sha": "a013875b3110b9a713a2d8bd0d914184d59482a1", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,7 +11,7 @@\n use build::Builder;\n use build::matches::MatchPair;\n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use std::u32;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {"}, {"sha": "a5f51ef35b7419655b161ab9072da7ad9114e6b8", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -17,7 +17,7 @@ use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n \n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use syntax::ast;\n use syntax_pos::Span;\n "}, {"sha": "d6fcc79a9a2134bc9ad0b997f3ac16140ddb19ba", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@ use hair::Pattern;\n \n use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n use rustc::ty::{self, Ty};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use syntax::abi::Abi;"}, {"sha": "af8170a1b8f5504076d74df520e5e6a1c387c899", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -91,7 +91,7 @@ use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::ty::{Ty, TyCtxt};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use syntax_pos::Span;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::fnv::FnvHashMap;"}, {"sha": "d20d50c561140a3f6cf526c13a554c7737f5e48c", "filename": "src/librustc_mir/def_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdef_use.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n //! Def-use analysis.\n \n-use rustc::mir::repr::{Local, Location, Lvalue, Mir};\n+use rustc::mir::{Local, Location, Lvalue, Mir};\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::marker::PhantomData;"}, {"sha": "dd4dd4699d858f95a0a546a33c5fcdcbaade1881", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,8 +10,7 @@\n \n use dot;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::repr::*;\n-use rustc::mir::mir_map::MirMap;\n+use rustc::mir::*;\n use rustc::ty::TyCtxt;\n use std::fmt::Debug;\n use std::io::{self, Write};\n@@ -22,14 +21,13 @@ use rustc_data_structures::indexed_vec::Idx;\n /// Write a graphviz DOT graph of a list of MIRs.\n pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                               iter: I,\n-                                              mir_map: &MirMap<'tcx>,\n                                               w: &mut W)\n                                               -> io::Result<()>\n     where W: Write, I: Iterator<Item=DefId>\n {\n     for def_id in iter {\n         let nodeid = tcx.map.as_local_node_id(def_id).unwrap();\n-        let mir = &mir_map.map[&def_id];\n+        let mir = &tcx.item_mir(def_id);\n \n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n "}, {"sha": "1b324ac3132fcac6743fa1df9d3d578d12b5eb78", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -21,7 +21,7 @@ use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::hir;\n use syntax::ptr::P;\n "}, {"sha": "678db1e544cb017ed900d5c226590099083fa382", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,7 +16,7 @@\n  */\n \n use hair::*;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;"}, {"sha": "e211334e5473ae5e43616916de6a189dc64f724e", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,7 +14,7 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::repr::{BinOp, BorrowKind, Field, Literal, UnOp, TypedConstVal};\n+use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp, TypedConstVal};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::Substs;"}, {"sha": "b0e2d6e73d37aa0c3f19d7da16f893a2a4c47bef", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -19,13 +19,12 @@\n use build;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::repr::Mir;\n+use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n-use rustc::mir::mir_map::MirMap;\n use rustc::infer::InferCtxtBuilder;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -37,16 +36,10 @@ use syntax_pos::Span;\n \n use std::mem;\n \n-pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MirMap<'tcx> {\n-    let mut map = MirMap::new(tcx.dep_graph.clone());\n-    {\n-        let mut dump = BuildMir {\n-            tcx: tcx,\n-            map: &mut map,\n-        };\n-        tcx.visit_all_items_in_krate(DepNode::Mir, &mut dump);\n-    }\n-    map\n+pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.visit_all_items_in_krate(DepNode::Mir, &mut BuildMir {\n+        tcx: tcx\n+    });\n }\n \n /// A pass to lift all the types and substitutions in a Mir\n@@ -83,8 +76,7 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n struct BuildMir<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    map: &'a mut MirMap<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n /// Helper type of a temporary returned by BuildMir::cx(...).\n@@ -93,8 +85,7 @@ struct BuildMir<'a, 'tcx: 'a> {\n struct CxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     src: MirSource,\n     def_id: DefId,\n-    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>,\n-    map: &'a mut MirMap<'gcx>,\n+    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>\n }\n \n impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n@@ -104,8 +95,7 @@ impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n         CxBuilder {\n             src: src,\n             infcx: self.tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable),\n-            def_id: def_id,\n-            map: self.map\n+            def_id: def_id\n         }\n     }\n }\n@@ -114,27 +104,26 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n     fn build<F>(&'tcx mut self, f: F)\n         where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n-        let src = self.src;\n-        let mir = self.infcx.enter(|infcx| {\n+        let (src, def_id) = (self.src, self.def_id);\n+        self.infcx.enter(|infcx| {\n             let (mut mir, scope_auxiliary) = f(Cx::new(&infcx, src));\n \n             // Convert the Mir to global types.\n+            let tcx = infcx.tcx.global_tcx();\n             let mut globalizer = GlobalizeMir {\n-                tcx: infcx.tcx.global_tcx(),\n+                tcx: tcx,\n                 span: mir.span\n             };\n             globalizer.visit_mir(&mut mir);\n             let mir = unsafe {\n                 mem::transmute::<Mir, Mir<'gcx>>(mir)\n             };\n \n-            pretty::dump_mir(infcx.tcx.global_tcx(), \"mir_map\", &0,\n-                             src, &mir, Some(&scope_auxiliary));\n+            pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n \n-            mir\n+            let mir = tcx.alloc_mir(mir);\n+            assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n         });\n-\n-        assert!(self.map.map.insert(self.def_id, mir).is_none())\n     }\n }\n "}, {"sha": "d2fc8aeaa2eea743b2497e2da46a0e68bb0909fe", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,8 +11,7 @@\n use build::{ScopeAuxiliaryVec, ScopeId};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::repr::*;\n-use rustc::mir::mir_map::MirMap;\n+use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n@@ -90,14 +89,13 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Write out a human-readable textual representation for the given MIR.\n pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                          iter: I,\n-                                         mir_map: &MirMap<'tcx>,\n                                          w: &mut Write)\n                                          -> io::Result<()>\n     where I: Iterator<Item=DefId>, 'tcx: 'a\n {\n     let mut first = true;\n     for def_id in iter {\n-        let mir = &mir_map.map[&def_id];\n+        let mir = &tcx.item_mir(def_id);\n \n         if first {\n             first = false;"}, {"sha": "89e644e4fb077d5398d94c61f1add1bd0e981f8a", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n "}, {"sha": "8c8c42a1c7687bd9d19f6a9222646867b799aac1", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -30,7 +30,7 @@\n //! future.\n \n use def_use::DefUseAnalysis;\n-use rustc::mir::repr::{Constant, Local, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n+use rustc::mir::{Constant, Local, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;"}, {"sha": "fcdeae6d6c080187124464aa9799b20a23e0dd2b", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc_data_structures::indexed_vec::Idx;\n "}, {"sha": "b8fd9fb12ab01ee8477b693f877563c8bc177a9d", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@\n use std::fmt;\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirPassHook, MirSource};\n use pretty;\n "}, {"sha": "cebd9dd9668e331404a3dced86cdb03369fe5889", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,7 +14,7 @@\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{Ty, TyCtxt};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n "}, {"sha": "a01724d6d0e9bf9bfc862d93856533602c31e250", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n //! Performs various peephole optimizations.\n \n-use rustc::mir::repr::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n+use rustc::mir::{Location, Lvalue, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::TyCtxt;"}, {"sha": "6ef5720b330c967fba092d67891f39ad8f622fb3", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,7 +12,7 @@\n //! specified.\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n "}, {"sha": "41698574e0f1fa9233d7914cd1e8be8e41bc8124", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -22,7 +22,7 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::TyCtxt;"}, {"sha": "b33a7060e37537df665b2fca2c26d30a74537ba3", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 76, "deletions": 107, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,7 +16,6 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -25,10 +24,9 @@ use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::cast::CastTy;\n-use rustc::mir::repr::*;\n-use rustc::mir::mir_map::MirMap;\n-use rustc::mir::traversal::{self, ReversePostorder};\n-use rustc::mir::transform::{Pass, MirMapPass, MirPassHook, MirSource};\n+use rustc::mir::*;\n+use rustc::mir::traversal::ReversePostorder;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::util::nodemap::DefIdMap;\n use syntax::abi::Abi;\n@@ -142,7 +140,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParameterEnvironment<'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n-    mir_map: Option<&'a MirMap<'tcx>>,\n     temp_qualif: IndexVec<Local, Option<Qualif>>,\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n@@ -155,7 +152,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            param_env: ty::ParameterEnvironment<'tcx>,\n            qualif_map: &'a mut DefIdMap<Qualif>,\n-           mir_map: Option<&'a MirMap<'tcx>>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n@@ -172,7 +168,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             tcx: tcx,\n             param_env: param_env,\n             qualif_map: qualif_map,\n-            mir_map: mir_map,\n             temp_qualif: IndexVec::from_elem(None, &mir.local_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n@@ -595,7 +590,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     } else {\n                         let qualif = qualify_const_item_cached(self.tcx,\n                                                                self.qualif_map,\n-                                                               self.mir_map,\n                                                                def_id);\n                         self.add(qualif);\n                     }\n@@ -949,7 +943,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        qualif_map: &mut DefIdMap<Qualif>,\n-                                       mir_map: Option<&MirMap<'tcx>>,\n                                        def_id: DefId)\n                                        -> Qualif {\n     match qualif_map.entry(def_id) {\n@@ -960,124 +953,100 @@ fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let extern_mir;\n-    let param_env_and_mir = if def_id.is_local() {\n-        mir_map.and_then(|map| map.map.get(&def_id)).map(|mir| {\n-            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n-            (ty::ParameterEnvironment::for_item(tcx, node_id), mir)\n-        })\n-    } else if let Some(mir) = tcx.sess.cstore.maybe_get_item_mir(tcx, def_id) {\n-        // These should only be monomorphic constants.\n-        extern_mir = mir;\n-        Some((tcx.empty_parameter_environment(), &extern_mir))\n+    let param_env = if def_id.is_local() {\n+        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+        ty::ParameterEnvironment::for_item(tcx, node_id)\n     } else {\n-        None\n+        // These should only be monomorphic constants.\n+        tcx.empty_parameter_environment()\n     };\n \n-    let (param_env, mir) = param_env_and_mir.unwrap_or_else(|| {\n-        bug!(\"missing constant MIR for {}\", tcx.item_path_str(def_id))\n-    });\n-\n-    let mut qualifier = Qualifier::new(tcx, param_env, qualif_map, mir_map,\n-                                       def_id, mir, Mode::Const);\n+    let mir = &tcx.item_mir(def_id);\n+    let mut qualifier = Qualifier::new(tcx, param_env, qualif_map, def_id, mir, Mode::Const);\n     let qualif = qualifier.qualify_const();\n     qualifier.qualif_map.insert(def_id, qualif);\n     qualif\n }\n \n-pub struct QualifyAndPromoteConstants;\n+#[derive(Default)]\n+pub struct QualifyAndPromoteConstants {\n+    qualif_map: DefIdMap<Qualif>\n+}\n \n impl Pass for QualifyAndPromoteConstants {}\n \n-impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    map: &mut MirMap<'tcx>,\n-                    hooks: &mut [Box<for<'s> MirPassHook<'s>>]) {\n-        let mut qualif_map = DefIdMap();\n-\n-        // First, visit `const` items, potentially recursing, to get\n-        // accurate MUTABLE_INTERIOR and NEEDS_DROP qualifications.\n-        let keys = map.map.keys();\n-        for &def_id in &keys {\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let id = tcx.map.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-            if let MirSource::Const(_) = src {\n-                qualify_const_item_cached(tcx, &mut qualif_map, Some(map), def_id);\n+impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>) {\n+        let id = src.item_id();\n+        let def_id = tcx.map.local_def_id(id);\n+        let mode = match src {\n+            MirSource::Fn(_) => {\n+                if is_const_fn(tcx, def_id) {\n+                    Mode::ConstFn\n+                } else {\n+                    Mode::Fn\n+                }\n             }\n-        }\n-\n-        // Then, handle everything else, without recursing,\n-        // as the MIR map is not shared, since promotion\n-        // in functions (including `const fn`) mutates it.\n-        for &def_id in &keys {\n-            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            let id = tcx.map.as_local_node_id(def_id).unwrap();\n-            let src = MirSource::from_node(tcx, id);\n-            let mode = match src {\n-                MirSource::Fn(_) => {\n-                    if is_const_fn(tcx, def_id) {\n-                        Mode::ConstFn\n-                    } else {\n-                        Mode::Fn\n+            MirSource::Const(_) => {\n+                match self.qualif_map.entry(def_id) {\n+                    Entry::Occupied(_) => return,\n+                    Entry::Vacant(entry) => {\n+                        // Guard against `const` recursion.\n+                        entry.insert(Qualif::RECURSIVE);\n                     }\n                 }\n-                MirSource::Const(_) => continue,\n-                MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n-                MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n-                MirSource::Promoted(..) => bug!()\n-            };\n-            let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-\n-            let mir = map.map.get_mut(&def_id).unwrap();\n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, false);\n+                Mode::Const\n             }\n-\n-            if mode == Mode::Fn || mode == Mode::ConstFn {\n-                // This is ugly because Qualifier holds onto mir,\n-                // which can't be mutated until its scope ends.\n-                let (temps, candidates) = {\n-                    let mut qualifier = Qualifier::new(tcx, param_env, &mut qualif_map,\n-                                                       None, def_id, mir, mode);\n-                    if mode == Mode::ConstFn {\n-                        // Enforce a constant-like CFG for `const fn`.\n-                        qualifier.qualify_const();\n-                    } else {\n-                        while let Some((bb, data)) = qualifier.rpo.next() {\n-                            qualifier.visit_basic_block_data(bb, data);\n-                        }\n+            MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n+            MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+            MirSource::Promoted(..) => return\n+        };\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+\n+        if mode == Mode::Fn || mode == Mode::ConstFn {\n+            // This is ugly because Qualifier holds onto mir,\n+            // which can't be mutated until its scope ends.\n+            let (temps, candidates) = {\n+                let mut qualifier = Qualifier::new(tcx, param_env,\n+                                                   &mut self.qualif_map,\n+                                                   def_id, mir, mode);\n+                if mode == Mode::ConstFn {\n+                    // Enforce a constant-like CFG for `const fn`.\n+                    qualifier.qualify_const();\n+                } else {\n+                    while let Some((bb, data)) = qualifier.rpo.next() {\n+                        qualifier.visit_basic_block_data(bb, data);\n                     }\n+                }\n \n-                    (qualifier.temp_promotion_state,\n-                     qualifier.promotion_candidates)\n-                };\n+                (qualifier.temp_promotion_state, qualifier.promotion_candidates)\n+            };\n \n-                // Do the actual promotion, now that we know what's viable.\n-                promote_consts::promote_candidates(mir, tcx, temps, candidates);\n-            } else {\n-                let mut qualifier = Qualifier::new(tcx, param_env, &mut qualif_map,\n-                                                   None, def_id, mir, mode);\n-                qualifier.qualify_const();\n-            }\n+            // Do the actual promotion, now that we know what's viable.\n+            promote_consts::promote_candidates(mir, tcx, temps, candidates);\n+        } else {\n+            let mut qualifier = Qualifier::new(tcx, param_env,\n+                                               &mut self.qualif_map,\n+                                               def_id, mir, mode);\n+            let qualif = qualifier.qualify_const();\n \n-            for hook in &mut *hooks {\n-                hook.on_mir_pass(tcx, src, mir, self, true);\n+            if mode == Mode::Const {\n+                qualifier.qualif_map.insert(def_id, qualif);\n             }\n+        }\n \n-            // Statics must be Sync.\n-            if mode == Mode::Static {\n-                let ty = mir.return_ty;\n-                tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n-                    let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n-                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                    fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-                    if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                        infcx.report_fulfillment_errors(&err);\n-                    }\n-                });\n-            }\n+        // Statics must be Sync.\n+        if mode == Mode::Static {\n+            let ty = mir.return_ty;\n+            tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+                let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n+                let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+                if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+                    infcx.report_fulfillment_errors(&err);\n+                }\n+            });\n         }\n     }\n }"}, {"sha": "8759a340d7e3c6e033330d982f56f1a0bb86d0cb", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,7 +13,7 @@\n use rustc::ty::TyCtxt;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n \n use std::fmt;\n "}, {"sha": "1a8a5fa18cf593916ec5b21513553c07531af56b", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -35,9 +35,8 @@\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n-use rustc::mir::traversal;\n use std::fmt;\n \n pub struct SimplifyCfg<'a> { label: &'a str }"}, {"sha": "9d3afe541cca8ce0e55714586e00ad952951ecd2", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,10 +15,10 @@ use rustc::infer::{self, InferCtxt, InferOk};\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt, TypeVariants};\n-use rustc::mir::repr::*;\n+use rustc::mir::*;\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n-use rustc::mir::visit::{self, Visitor};\n+use rustc::mir::visit::Visitor;\n use std::fmt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};"}, {"sha": "828efbf373131d9e005e91177b88dce0c94ca075", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -190,8 +190,16 @@ impl<'a> Visitor for AstValidator<'a> {\n             }\n             ItemKind::Trait(.., ref trait_items) => {\n                 for trait_item in trait_items {\n-                    if let TraitItemKind::Method(ref sig, _) = trait_item.node {\n+                    if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n                         self.check_trait_fn_not_const(sig.constness);\n+                        if block.is_none() {\n+                            self.check_decl_no_pat(&sig.decl, |span, _| {\n+                                self.session.add_lint(lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n+                                                      trait_item.id, span,\n+                                                      \"patterns aren't allowed in methods \\\n+                                                       without bodies\".to_string());\n+                            });\n+                        }\n                     }\n                 }\n             }"}, {"sha": "8ad4d7f57a6f0a4505c5116654acfc2b5de07fd3", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -565,9 +565,11 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprStruct(..) => {\n-            // unsafe_cell_type doesn't necessarily exist with no_core\n-            if Some(v.tcx.expect_def(e.id).def_id()) == v.tcx.lang_items.unsafe_cell_type() {\n-                v.add_qualif(ConstQualif::MUTABLE_MEM);\n+            if let ty::TyAdt(adt, ..) = v.tcx.expr_ty(e).sty {\n+                // unsafe_cell_type doesn't necessarily exist with no_core\n+                if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n+                    v.add_qualif(ConstQualif::MUTABLE_MEM);\n+                }\n             }\n         }\n "}, {"sha": "4438241999a3940e4f6c289d0032f0bb473569fc", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -47,7 +47,7 @@ pub fn load_plugins(sess: &Session,\n                     krate: &ast::Crate,\n                     crate_name: &str,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n-    let mut loader = PluginLoader::new(sess, cstore, crate_name, krate.config.clone());\n+    let mut loader = PluginLoader::new(sess, cstore, crate_name);\n \n     // do not report any error now. since crate attributes are\n     // not touched by expansion, every use of plugin without\n@@ -89,14 +89,10 @@ pub fn load_plugins(sess: &Session,\n }\n \n impl<'a> PluginLoader<'a> {\n-    fn new(sess: &'a Session,\n-           cstore: &'a CStore,\n-           crate_name: &str,\n-           crate_config: ast::CrateConfig)\n-            -> PluginLoader<'a> {\n+    fn new(sess: &'a Session, cstore: &'a CStore, crate_name: &str) -> Self {\n         PluginLoader {\n             sess: sess,\n-            reader: CrateLoader::new(sess, cstore, crate_name, crate_config),\n+            reader: CrateLoader::new(sess, cstore, crate_name),\n             plugins: vec![],\n         }\n     }"}, {"sha": "1fb5db05dd5088e0b7c8f55942f5a3b496537024", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -860,31 +860,6 @@ match (A, B, C) {\n ```\n \"##,\n \n-E0422: r##\"\n-You are trying to use an identifier that is either undefined or not a struct.\n-\n-Erroneous code example:\n-\n-``` compile_fail,E0422\n-fn main () {\n-    let x = Foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `Foo` is undefined, so it inherently isn't anything, and\n-definitely not a struct.\n-\n-```compile_fail,E0422\n-fn main () {\n-    let foo = 1;\n-    let x = foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n-one.\n-\"##,\n-\n E0423: r##\"\n A `struct` variant name was used like a function name.\n \n@@ -1503,6 +1478,7 @@ register_diagnostics! {\n //  E0419, merged into 531\n //  E0420, merged into 532\n //  E0421, merged into 531\n+//  E0422, merged into 531/532\n     E0531, // unresolved pattern path kind `name`\n     E0532, // expected pattern path kind, found another pattern path kind\n //  E0427, merged into 530"}, {"sha": "0b382fcbfdd514a8d801f8f6939a7e1f90a0b9da", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -129,8 +129,6 @@ enum ResolutionError<'a> {\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n-    /// error E0422: does not name a struct\n-    DoesNotNameAStruct(&'a str),\n     /// error E0423: is a struct variant name, but this expression uses it like a function name\n     StructVariantUsedAsFunction(&'a str),\n     /// error E0424: `self` is not available in a static method\n@@ -336,15 +334,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(span, &format!(\"used in a pattern more than once\"));\n             err\n         }\n-        ResolutionError::DoesNotNameAStruct(name) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0422,\n-                             \"`{}` does not name a structure\",\n-                             name);\n-            err.span_label(span, &format!(\"not a structure\"));\n-            err\n-        }\n         ResolutionError::StructVariantUsedAsFunction(path_name) => {\n             let mut err = struct_span_err!(resolver.session,\n                              span,\n@@ -1412,7 +1401,7 @@ impl<'a> Resolver<'a> {\n \n                                 format!(\"Did you mean `{}{}`?\", prefix, path_str)\n                             }\n-                            None => format!(\"Maybe a missing `extern crate {}`?\", segment_name),\n+                            None => format!(\"Maybe a missing `extern crate {};`?\", segment_name),\n                         }\n                     } else {\n                         format!(\"Could not find `{}` in `{}`\", segment_name, module_name)\n@@ -2383,6 +2372,18 @@ impl<'a> Resolver<'a> {\n         self.record_def(pat_id, resolution);\n     }\n \n+    fn resolve_struct_path(&mut self, node_id: NodeId, path: &Path) {\n+        // Resolution logic is equivalent for expressions and patterns,\n+        // reuse `resolve_pattern_path` for both.\n+        self.resolve_pattern_path(node_id, None, path, TypeNS, |def| {\n+            match def {\n+                Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => true,\n+                _ => false,\n+            }\n+        }, \"struct, variant or union type\");\n+    }\n+\n     fn resolve_pattern(&mut self,\n                        pat: &Pat,\n                        pat_src: PatternSource,\n@@ -2460,13 +2461,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 PatKind::Struct(ref path, ..) => {\n-                    self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n-                        match def {\n-                            Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n-                            Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n-                            _ => false,\n-                        }\n-                    }, \"variant, struct or type alias\");\n+                    self.resolve_struct_path(pat.id, path);\n                 }\n \n                 _ => {}\n@@ -3024,23 +3019,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Struct(ref path, ..) => {\n-                // Resolve the path to the structure it goes to. We don't\n-                // check to ensure that the path is actually a structure; that\n-                // is checked later during typeck.\n-                match self.resolve_path(expr.id, path, 0, TypeNS) {\n-                    Ok(definition) => self.record_def(expr.id, definition),\n-                    Err(true) => self.record_def(expr.id, err_path_resolution()),\n-                    Err(false) => {\n-                        debug!(\"(resolving expression) didn't find struct def\",);\n-\n-                        resolve_error(self,\n-                                      path.span,\n-                                      ResolutionError::DoesNotNameAStruct(\n-                                                                &path_names_to_string(path, 0))\n-                                     );\n-                        self.record_def(expr.id, err_path_resolution());\n-                    }\n-                }\n+                self.resolve_struct_path(expr.id, path);\n \n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "73d0e5e50c6c7b0d1665cd2923411d6a11070d2b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -166,6 +166,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                        loc.file.name,\n                        loc.line);\n             }\n+            error!(\"    master span: {:?}: `{}`\", path.span, self.span.snippet(path.span));\n             return vec!();\n         }\n \n@@ -1493,7 +1494,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 Def::StructCtor(..) | Def::VariantCtor(..) |\n                 Def::Const(..) | Def::AssociatedConst(..) |\n                 Def::Struct(..) | Def::Variant(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) => {\n+                Def::TyAlias(..) | Def::AssociatedTy(..) |\n+                Def::SelfTy(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 def => error!(\"unexpected definition kind when processing collected paths: {:?}\","}, {"sha": "eb613c3afdab35c379398d36a39a54d595954341", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -129,7 +129,7 @@ impl From<DefId> for Id {\n #[derive(Debug, RustcEncodable)]\n struct Import {\n     kind: ImportKind,\n-    id: Id,\n+    ref_id: Option<Id>,\n     span: SpanData,\n     name: String,\n     value: String,\n@@ -146,7 +146,7 @@ impl From<ExternCrateData> for Import {\n     fn from(data: ExternCrateData) -> Import {\n         Import {\n             kind: ImportKind::ExternCrate,\n-            id: From::from(data.id),\n+            ref_id: None,\n             span: data.span,\n             name: data.name,\n             value: String::new(),\n@@ -157,7 +157,7 @@ impl From<UseData> for Import {\n     fn from(data: UseData) -> Import {\n         Import {\n             kind: ImportKind::Use,\n-            id: From::from(data.id),\n+            ref_id: data.mod_id.map(|id| From::from(id)),\n             span: data.span,\n             name: data.name,\n             value: String::new(),\n@@ -168,7 +168,7 @@ impl From<UseGlobData> for Import {\n     fn from(data: UseGlobData) -> Import {\n         Import {\n             kind: ImportKind::GlobUse,\n-            id: From::from(data.id),\n+            ref_id: None,\n             span: data.span,\n             name: \"*\".to_owned(),\n             value: data.names.join(\", \"),"}, {"sha": "264ed4cd12fc1a419cbad0b13d6500559cfc992e", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n     /// Scan for a `cfg=\"foo\"` attribute and check whether we have a\n     /// cfg flag called `foo`.\n     fn check_config(&self, attr: &ast::Attribute) -> bool {\n-        let config = &self.tcx.map.krate().config;\n+        let config = &self.tcx.sess.parse_sess.config;\n         let value = self.field(attr, CFG);\n         debug!(\"check_config(config={:?}, value={:?})\", config, value);\n         if config.iter().any(|c| c.check_name(&value[..])) {"}, {"sha": "bf2a5d76c10d493f27b645bce243b5e323ae2e19", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -99,7 +99,8 @@\n \n use common::SharedCrateContext;\n use monomorphize::Instance;\n-use util::sha2::{Digest, Sha256};\n+use rustc_data_structures::fmt_wrap::FmtWrap;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n \n use rustc::middle::weak_lang_items;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -113,21 +114,6 @@ use rustc::util::common::record_time;\n \n use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n-use serialize::hex::ToHex;\n-\n-use std::hash::Hasher;\n-\n-struct Sha256Hasher<'a>(&'a mut Sha256);\n-\n-impl<'a> Hasher for Sha256Hasher<'a> {\n-    fn write(&mut self, msg: &[u8]) {\n-        self.0.input(msg)\n-    }\n-\n-    fn finish(&self) -> u64 {\n-        bug!(\"Sha256Hasher::finish should not be called\");\n-    }\n-}\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n@@ -149,12 +135,9 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     let tcx = scx.tcx();\n \n-    let mut hash_state = scx.symbol_hasher().borrow_mut();\n-    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        hash_state.reset();\n-        let hasher = Sha256Hasher(&mut hash_state);\n-        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n+    let mut hasher = ty::util::TypeIdHasher::new(tcx, Blake2bHasher::new(8, &[]));\n \n+    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n@@ -175,8 +158,9 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     });\n \n     // 64 bits should be enough to avoid collisions.\n-    let output = hash_state.result_bytes();\n-    format!(\"h{}\", output[..8].to_hex())\n+    let mut hasher = hasher.into_inner();\n+    let hash_bytes = hasher.finalize();\n+    format!(\"h{:x}\", FmtWrap(hash_bytes))\n }\n \n impl<'a, 'tcx> Instance<'tcx> {"}, {"sha": "977ababbf56883c5b4f83386e2b52b82c4372f4d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -35,6 +35,7 @@ use back::link;\n use back::linker::LinkerInfo;\n use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::ty::subst::Substs;\n@@ -44,7 +45,6 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n-use rustc::mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::Session;\n@@ -79,7 +79,6 @@ use type_::Type;\n use type_of;\n use value::Value;\n use Disr;\n-use util::sha2::Sha256;\n use util::nodemap::{NodeSet, FnvHashMap, FnvHashSet};\n \n use arena::TypedArena;\n@@ -866,7 +865,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             false\n         };\n \n-        let mir = def_id.and_then(|id| ccx.get_mir(id));\n+        let mir = def_id.map(|id| ccx.tcx().item_mir(id));\n \n         let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n                 (no_debug, definition, &mir) {\n@@ -1278,8 +1277,7 @@ fn write_metadata(cx: &SharedCrateContext,\n     let metadata = cstore.encode_metadata(cx.tcx(),\n                                           cx.export_map(),\n                                           cx.link_meta(),\n-                                          reachable_ids,\n-                                          cx.mir_map());\n+                                          reachable_ids);\n     if kind == MetadataKind::Uncompressed {\n         return metadata;\n     }\n@@ -1527,7 +1525,6 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n }\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             mir_map: &MirMap<'tcx>,\n                              analysis: ty::CrateAnalysis,\n                              incremental_hashes_map: &IncrementalHashesMap)\n                              -> CrateTranslation {\n@@ -1551,9 +1548,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(incremental_hashes_map, name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n-                                             &mir_map,\n                                              export_map,\n-                                             Sha256::new(),\n                                              link_meta.clone(),\n                                              reachable,\n                                              check_overflow);\n@@ -1716,8 +1711,21 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // `reachable_symbols` list later on so it should be ok.\n     for cnum in sess.cstore.crates() {\n         let syms = sess.cstore.reachable_ids(cnum);\n-        reachable_symbols.extend(syms.into_iter().filter(|did| {\n-            sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n+        reachable_symbols.extend(syms.into_iter().filter(|&def_id| {\n+            let applicable = match sess.cstore.describe_def(def_id) {\n+                Some(Def::Static(..)) => true,\n+                Some(Def::Fn(_)) => {\n+                    shared_ccx.tcx().lookup_generics(def_id).types.is_empty()\n+                }\n+                _ => false\n+            };\n+\n+            if applicable {\n+                let attrs = shared_ccx.tcx().get_attrs(def_id);\n+                attr::contains_extern_indicator(sess.diagnostic(), &attrs)\n+            } else {\n+                false\n+            }\n         }).map(|did| {\n             symbol_for_def_id(did, &shared_ccx, &symbol_map)\n         }));"}, {"sha": "8348da9f7b7bfe05cd49d19adcd9331e5620fb59", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -198,15 +198,13 @@ use rustc::traits;\n use rustc::ty::subst::{Substs, Subst};\n use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::mir::repr as mir;\n+use rustc::mir::{self, Location};\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n-use rustc::mir::repr::Location;\n \n use rustc_const_eval as const_eval;\n \n use syntax::abi::Abi;\n-use errors;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n@@ -347,8 +345,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n-                || format!(\"Could not find MIR for static: {:?}\", def_id));\n+            let mir = scx.tcx().item_mir(def_id);\n \n             let empty_substs = scx.empty_substs_for_def_id(def_id);\n             let visitor = MirNeighborCollector {\n@@ -368,8 +365,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(instance.def),\n-                || format!(\"Could not find MIR for function: {}\", instance));\n+            let mir = scx.tcx().item_mir(instance.def);\n \n             let visitor = MirNeighborCollector {\n                 scx: scx,\n@@ -452,11 +448,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n                                                                ref substs), _) => {\n-                let mir = errors::expect(self.scx.sess().diagnostic(),\n-                                         self.scx.get_mir(def_id),\n-                                         || {\n-                    format!(\"Could not find MIR for closure: {:?}\", def_id)\n-                });\n+                let mir = self.scx.tcx().item_mir(def_id);\n \n                 let concrete_substs = monomorphize::apply_param_substs(self.scx,\n                                                                        self.param_substs,\n@@ -1249,8 +1241,7 @@ fn collect_const_item_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n {\n     // Scan the MIR in order to find function calls, closures, and\n     // drop-glue\n-    let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n-        || format!(\"Could not find MIR for const: {:?}\", def_id));\n+    let mir = scx.tcx().item_mir(def_id);\n \n     let visitor = MirNeighborCollector {\n         scx: scx,"}, {"sha": "464b261b08e05e81005b791346f6883fafd8eb82", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -19,6 +19,7 @@ use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n+use rustc::mir::Mir;\n use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use rustc::ty::subst::Substs;\n@@ -32,7 +33,6 @@ use consts;\n use debuginfo::{self, DebugLoc};\n use declare;\n use machine;\n-use mir::CachedMir;\n use monomorphize;\n use type_::Type;\n use value::Value;\n@@ -46,7 +46,7 @@ use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ops::Deref;\n use std::ffi::CString;\n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref};\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -250,10 +250,8 @@ pub fn validate_substs(substs: &Substs) {\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n-    // The MIR for this function. At present, this is optional because\n-    // we only have MIR available for things that are local to the\n-    // crate.\n-    pub mir: Option<CachedMir<'a, 'tcx>>,\n+    // The MIR for this function.\n+    pub mir: Option<Ref<'tcx, Mir<'tcx>>>,\n \n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n@@ -313,8 +311,8 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn mir(&self) -> CachedMir<'a, 'tcx> {\n-        self.mir.clone().expect(\"fcx.mir was empty\")\n+    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n+        self.mir.as_ref().map(Ref::clone).expect(\"fcx.mir was empty\")\n     }\n \n     pub fn cleanup(&self) {\n@@ -490,7 +488,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.set_lpad_ref(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n     }\n \n-    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n+    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n         self.fcx.mir()\n     }\n \n@@ -609,7 +607,7 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         self.bcx.llbb\n     }\n \n-    pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n+    pub fn mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n         self.bcx.mir()\n     }\n "}, {"sha": "fc75b1018ec35ef4bdd73b5e3718eac19879a3f5", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,15 +15,12 @@ use middle::cstore::LinkMeta;\n use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n-use rustc::mir::mir_map::MirMap;\n-use rustc::mir::repr as mir;\n use base;\n use builder::Builder;\n use common::BuilderRef_res;\n use debuginfo;\n use declare;\n use glue::DropGlueKind;\n-use mir::CachedMir;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n@@ -35,7 +32,6 @@ use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n use symbol_map::SymbolMap;\n-use util::sha2::Sha256;\n use util::nodemap::{NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::ffi::{CStr, CString};\n@@ -72,12 +68,9 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     export_map: ExportMap,\n     reachable: NodeSet,\n     link_meta: LinkMeta,\n-    symbol_hasher: RefCell<Sha256>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n-    mir_map: &'a MirMap<'tcx>,\n-    mir_cache: RefCell<DepTrackingMap<MirCache<'tcx>>>,\n \n     use_dll_storage_attrs: bool,\n \n@@ -184,19 +177,6 @@ impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     }\n }\n \n-// Cache for mir loaded from metadata\n-struct MirCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for MirCache<'tcx> {\n-    type Key = DefId;\n-    type Value = Rc<mir::Mir<'tcx>>;\n-    fn to_dep_node(key: &DefId) -> DepNode<DefId> {\n-        DepNode::Mir(*key)\n-    }\n-}\n-\n // # Global Cache\n \n pub struct ProjectionCache<'gcx> {\n@@ -453,9 +433,7 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               mir_map: &'b MirMap<'tcx>,\n                export_map: ExportMap,\n-               symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet,\n                check_overflow: bool)\n@@ -515,10 +493,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             export_map: export_map,\n             reachable: reachable,\n             link_meta: link_meta,\n-            symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n-            mir_map: mir_map,\n-            mir_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n@@ -582,23 +557,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         self.use_dll_storage_attrs\n     }\n \n-    pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n-        if def_id.is_local() {\n-            self.mir_map.map.get(&def_id).map(CachedMir::Ref)\n-        } else {\n-            if let Some(mir) = self.mir_cache.borrow().get(&def_id).cloned() {\n-                return Some(CachedMir::Owned(mir));\n-            }\n-\n-            let mir = self.sess().cstore.maybe_get_item_mir(self.tcx, def_id);\n-            let cached = mir.map(Rc::new);\n-            if let Some(ref mir) = cached {\n-                self.mir_cache.borrow_mut().insert(def_id, mir.clone());\n-            }\n-            cached.map(CachedMir::Owned)\n-        }\n-    }\n-\n     pub fn translation_items(&self) -> &RefCell<FnvHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n@@ -613,14 +571,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         })\n     }\n \n-    pub fn symbol_hasher(&self) -> &RefCell<Sha256> {\n-        &self.symbol_hasher\n-    }\n-\n-    pub fn mir_map(&self) -> &MirMap<'tcx> {\n-        &self.mir_map\n-    }\n-\n     pub fn metadata_symbol_name(&self) -> String {\n         format!(\"rust_metadata_{}_{}\",\n                 self.link_meta().crate_name,\n@@ -919,10 +869,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().llsizingtypes\n     }\n \n-    pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n-        &self.shared.symbol_hasher\n-    }\n-\n     pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n         &self.local().type_hashcodes\n     }\n@@ -1008,10 +954,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n-        self.shared.get_mir(def_id)\n-    }\n-\n     pub fn symbol_map(&self) -> &SymbolMap<'tcx> {\n         &*self.local().symbol_map\n     }"}, {"sha": "e0c1a80be394d047f7b7b3e78044c7a3080ddfd4", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,7 +15,7 @@ use super::utils::{DIB, span_start};\n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n use common::{CrateContext, FunctionContext};\n-use rustc::mir::repr::{Mir, VisibilityScope};\n+use rustc::mir::{Mir, VisibilityScope};\n \n use libc::c_uint;\n use std::ptr;\n@@ -45,7 +45,7 @@ impl MirDebugScope {\n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, MirDebugScope> {\n-    let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n+    let mir = fcx.mir();\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n         file_start_pos: BytePos(0),"}, {"sha": "863aecc824433f4954f5847d340d4caad28b827b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n-use rustc_data_structures::blake2b;\n+use rustc_data_structures::blake2b::Blake2bHasher;\n use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n@@ -149,10 +149,16 @@ impl<'tcx> TypeMap<'tcx> {\n             None => { /* generate one */}\n         };\n \n+        // The hasher we are using to generate the UniqueTypeId. We want\n+        // something that provides more than the 64 bits of the DefaultHasher.\n+        const TYPE_ID_HASH_LENGTH: usize = 20;\n+\n         let mut type_id_hasher = TypeIdHasher::new(cx.tcx(),\n-                                                   DebugInfoTypeIdHasher::new());\n+                                                   Blake2bHasher::new(TYPE_ID_HASH_LENGTH, &[]));\n         type_id_hasher.visit_ty(type_);\n-        let hash = type_id_hasher.into_inner().into_hash();\n+        let mut hash_state = type_id_hasher.into_inner();\n+        let hash: &[u8] = hash_state.finalize();\n+        debug_assert!(hash.len() == TYPE_ID_HASH_LENGTH);\n \n         let mut unique_type_id = String::with_capacity(TYPE_ID_HASH_LENGTH * 2);\n \n@@ -164,39 +170,6 @@ impl<'tcx> TypeMap<'tcx> {\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n         return UniqueTypeId(key);\n-\n-        // The hasher we are using to generate the UniqueTypeId. We want\n-        // something that provides more than the 64 bits of the DefaultHasher.\n-        const TYPE_ID_HASH_LENGTH: usize = 20;\n-\n-        struct DebugInfoTypeIdHasher {\n-            state: blake2b::Blake2bCtx\n-        }\n-\n-        impl ::std::hash::Hasher for DebugInfoTypeIdHasher {\n-            fn finish(&self) -> u64 {\n-                unimplemented!()\n-            }\n-\n-            #[inline]\n-            fn write(&mut self, bytes: &[u8]) {\n-                blake2b::blake2b_update(&mut self.state, bytes);\n-            }\n-        }\n-\n-        impl DebugInfoTypeIdHasher {\n-            fn new() -> DebugInfoTypeIdHasher {\n-                DebugInfoTypeIdHasher {\n-                    state: blake2b::blake2b_new(TYPE_ID_HASH_LENGTH, &[])\n-                }\n-            }\n-\n-            fn into_hash(self) -> [u8; TYPE_ID_HASH_LENGTH] {\n-                let mut hash = [0u8; TYPE_ID_HASH_LENGTH];\n-                blake2b::blake2b_final(self.state, &mut hash);\n-                hash\n-            }\n-        }\n     }\n \n     // Get the UniqueTypeId for an enum variant. Enum variants are not really"}, {"sha": "3bc5f4f3dbc4ba9e4dedc0ba6009d334ef677dc8", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -32,7 +32,7 @@ use abi::Abi;\n use common::{CrateContext, FunctionContext, Block, BlockAndBuilder};\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n-use rustc::mir::repr as mir;\n+use rustc::mir;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet};\n "}, {"sha": "07acc54962b877cbecd12d5dc14f33021e2647df", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,6 +25,7 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(cell_extras)]\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n #![feature(dotdot_in_tuple_patterns)]"}, {"sha": "a934da12b9e365f095a2cd46985cafe147e01f16", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,9 +13,7 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc::mir::repr as mir;\n-use rustc::mir::repr::TerminatorKind;\n-use rustc::mir::repr::Location;\n+use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common::{self, Block, BlockAndBuilder};"}, {"sha": "8bf27b4babfc2a054a2f0cbc7336548f4750efeb", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,7 +12,7 @@ use llvm::{self, ValueRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n use rustc::ty;\n-use rustc::mir::repr as mir;\n+use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n use base;\n@@ -37,13 +37,14 @@ use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{LvalueRef};\n use super::operand::OperandRef;\n-use super::operand::OperandValue::*;\n+use super::operand::OperandValue::{Pair, Ref, Immediate};\n+\n+use std::cell::Ref as CellRef;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         let mut bcx = self.bcx(bb);\n-        let mir = self.mir.clone();\n-        let data = &mir[bb];\n+        let data = &CellRef::clone(&self.mir)[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n \n@@ -228,7 +229,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let ty = location.ty(&mir, bcx.tcx()).to_ty(bcx.tcx());\n+                let ty = location.ty(&self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = bcx.monomorphize(&ty);\n \n                 // Double check for necessity to drop"}, {"sha": "3d0d889760943b5592867e5372bde94008bab7e8", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,7 +16,7 @@ use rustc_const_math::ConstFloat::*;\n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n-use rustc::mir::repr as mir;\n+use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -261,9 +261,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             }\n         }\n \n-        let mir = ccx.get_mir(instance.def).unwrap_or_else(|| {\n-            bug!(\"missing constant MIR for {}\", instance)\n-        });\n+        let mir = ccx.tcx().item_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n     }\n "}, {"sha": "d28c466e230bab664971e4702f71acf6eba0a9e2", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::mir::repr as mir;\n+use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;"}, {"sha": "d2adf88c9168356fad72266a2088d87160b1b170", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,7 +11,7 @@\n use libc::c_uint;\n use llvm::{self, ValueRef};\n use rustc::ty;\n-use rustc::mir::repr as mir;\n+use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use session::config::FullDebugInfo;\n use base;\n@@ -23,8 +23,7 @@ use type_of;\n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::parse::token::keywords;\n \n-use std::ops::Deref;\n-use std::rc::Rc;\n+use std::cell::Ref;\n use std::iter;\n \n use basic_block::BasicBlock;\n@@ -39,25 +38,9 @@ use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n \n-#[derive(Clone)]\n-pub enum CachedMir<'mir, 'tcx: 'mir> {\n-    Ref(&'mir mir::Mir<'tcx>),\n-    Owned(Rc<mir::Mir<'tcx>>)\n-}\n-\n-impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n-    type Target = mir::Mir<'tcx>;\n-    fn deref(&self) -> &mir::Mir<'tcx> {\n-        match *self {\n-            CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => rc\n-        }\n-    }\n-}\n-\n /// Master context for translating MIR.\n pub struct MirContext<'bcx, 'tcx:'bcx> {\n-    mir: CachedMir<'bcx, 'tcx>,\n+    mir: Ref<'tcx, mir::Mir<'tcx>>,\n \n     /// Function context\n     fcx: &'bcx common::FunctionContext<'bcx, 'tcx>,\n@@ -223,7 +206,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let scopes = debuginfo::create_mir_scopes(fcx);\n \n     let mut mircx = MirContext {\n-        mir: mir.clone(),\n+        mir: Ref::clone(&mir),\n         fcx: fcx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,"}, {"sha": "62eda56e2e1ba33c1bfd01f6651945227a9850ec", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty::Ty;\n-use rustc::mir::repr as mir;\n+use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;"}, {"sha": "f25877b1de12d1d398797227e6e3b85ea4243cdf", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,7 +12,7 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n-use rustc::mir::repr as mir;\n+use rustc::mir;\n \n use asm;\n use base;"}, {"sha": "296a0e8049e080377904cddbcc23e514861af116", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::repr as mir;\n+use rustc::mir;\n \n use base;\n use common::{self, BlockAndBuilder};"}, {"sha": "270ce79620f8bcd5b15da523a7b13b09d84a7d76", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -26,7 +26,7 @@ pub struct Instance<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[])\n+        ppaux::parameterized(f, &self.substs, self.def, &[])\n     }\n }\n "}, {"sha": "8799050b1b999058b31213ca74f418abba88ba77", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1484,7 +1484,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                       def: Def,\n                       opt_self_ty: Option<Ty<'tcx>>,\n                       base_path_ref_id: ast::NodeId,\n-                      base_segments: &[hir::PathSegment])\n+                      base_segments: &[hir::PathSegment],\n+                      permit_variants: bool)\n                       -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -1515,6 +1516,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                     did,\n                                     base_segments.last().unwrap())\n             }\n+            Def::Variant(did) if permit_variants => {\n+                // Convert \"variant type\" as if it were a real type.\n+                // The resulting `Ty` is type of the variant's enum for now.\n+                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n+                self.ast_path_to_ty(rscope,\n+                                    span,\n+                                    param_mode,\n+                                    tcx.parent_def_id(did).unwrap(),\n+                                    base_segments.last().unwrap())\n+            }\n             Def::TyParam(did) => {\n                 tcx.prohibit_type_params(base_segments);\n \n@@ -1604,7 +1615,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                       opt_self_ty: Option<Ty<'tcx>>,\n                                       base_path_ref_id: ast::NodeId,\n                                       base_segments: &[hir::PathSegment],\n-                                      assoc_segments: &[hir::PathSegment])\n+                                      assoc_segments: &[hir::PathSegment],\n+                                      permit_variants: bool)\n                                       -> (Ty<'tcx>, Def) {\n         // Convert the base type.\n         debug!(\"finish_resolving_def_to_ty(base_def={:?}, \\\n@@ -1619,7 +1631,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                           base_def,\n                                           opt_self_ty,\n                                           base_path_ref_id,\n-                                          base_segments);\n+                                          base_segments,\n+                                          permit_variants);\n         debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", base_ty);\n \n         // If any associated type segments remain, attempt to resolve them.\n@@ -1775,7 +1788,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                                 opt_self_ty,\n                                                                 ast_ty.id,\n                                                                 &path.segments[..base_ty_end],\n-                                                                &path.segments[base_ty_end..]);\n+                                                                &path.segments[base_ty_end..],\n+                                                                false);\n \n                 // Write back the new resolution.\n                 if path_res.depth != 0 {"}, {"sha": "c842514227ca090b50b19ed6abc854a7189e3035", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -489,8 +489,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id,\n-                                                                                 pat.span) {\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id) {\n             variant_ty\n         } else {\n             for field in fields {"}, {"sha": "ccc944813ff18f4bc142f817016760ecb51012b9", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -196,6 +196,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n                 // require double indirection).\n+                // Additionally, we permit coercion of function\n+                // items to drop the unsafe qualifier.\n                 self.coerce_from_fn_item(a, a_f, b)\n             }\n             ty::TyFnPtr(a_f) => {\n@@ -504,6 +506,24 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         Ok((target, AdjustDerefRef(adjustment)))\n     }\n \n+    fn coerce_from_safe_fn(&self,\n+                           a: Ty<'tcx>,\n+                           fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n+                           b: Ty<'tcx>)\n+                           -> CoerceResult<'tcx> {\n+        if let ty::TyFnPtr(fn_ty_b) = b.sty {\n+            match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n+                (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n+                    let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n+                    return self.unify_and_identity(unsafe_a, b)\n+                        .map(|(ty, _)| (ty, AdjustUnsafeFnPointer));\n+                }\n+                _ => {}\n+            }\n+        }\n+        self.unify_and_identity(a, b)\n+    }\n+\n     fn coerce_from_fn_pointer(&self,\n                               a: Ty<'tcx>,\n                               fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n@@ -516,17 +536,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n-        if let ty::TyFnPtr(fn_ty_b) = b.sty {\n-            match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n-                (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n-                    let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify_and_identity(unsafe_a, b)\n-                        .map(|(ty, _)| (ty, AdjustUnsafeFnPointer));\n-                }\n-                _ => {}\n-            }\n-        }\n-        self.unify_and_identity(a, b)\n+        self.coerce_from_safe_fn(a, fn_ty_a, b)\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -544,7 +554,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.unify_and_identity(a_fn_pointer, b).map(|(ty, _)| (ty, AdjustReifyFnPointer))\n+                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b)\n+                    .map(|(ty, _)| (ty, AdjustReifyFnPointer))\n             }\n             _ => self.unify_and_identity(a, b),\n         }"}, {"sha": "75a14bb3db9224ea5c367819a96362d8a6e966df", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 54, "deletions": 85, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1686,41 +1686,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        cause)\n     }\n \n-    /// Instantiates the type in `did` with the generics in `path` and returns\n-    /// it (registering the necessary trait obligations along the way).\n-    ///\n-    /// Note that this function is only intended to be used with type-paths,\n-    /// not with value-paths.\n-    pub fn instantiate_type_path(&self,\n-                                 did: DefId,\n-                                 path: &hir::Path,\n-                                 node_id: ast::NodeId)\n-                                 -> Ty<'tcx> {\n-        debug!(\"instantiate_type_path(did={:?}, path={:?})\", did, path);\n-        let mut ty = self.tcx.lookup_item_type(did).ty;\n-        if ty.is_fn() {\n-            // Tuple variants have fn type even in type namespace, extract true variant type from it\n-            ty = self.tcx.no_late_bound_regions(&ty.fn_ret()).unwrap();\n-        }\n-        let type_predicates = self.tcx.lookup_predicates(did);\n-        let substs = AstConv::ast_path_substs_for_ty(self, self,\n-                                                     path.span,\n-                                                     PathParamMode::Optional,\n-                                                     did,\n-                                                     path.segments.last().unwrap());\n-        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", ty, substs);\n-        let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n-        let cause = traits::ObligationCause::new(path.span, self.body_id,\n-                                                 traits::ItemObligation(did));\n-        self.add_obligations_for_parameters(cause, &bounds);\n-\n-        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &ty);\n-        self.write_substs(node_id, ty::ItemSubsts {\n-            substs: substs\n-        });\n-        ty_substituted\n-    }\n-\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.mk_nil());\n     }\n@@ -3251,47 +3216,55 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_struct_path(&self,\n-                         path: &hir::Path,\n-                         node_id: ast::NodeId,\n-                         span: Span)\n-                         -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n-        let def = self.finish_resolving_struct_path(path, node_id, span);\n+                             path: &hir::Path,\n+                             node_id: ast::NodeId)\n+                             -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n+        let (def, ty) = self.finish_resolving_struct_path(path, node_id);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(did) => {\n-                let type_did = self.tcx.parent_def_id(did).unwrap();\n-                Some((type_did, self.tcx.expect_variant_def(def)))\n-            }\n-            Def::Struct(type_did) | Def::Union(type_did) => {\n-                Some((type_did, self.tcx.expect_variant_def(def)))\n+            Def::Variant(..) => {\n+                match ty.sty {\n+                    ty::TyAdt(adt, substs) => {\n+                        Some((adt.variant_of_def(def), adt.did, substs))\n+                    }\n+                    _ => bug!(\"unexpected type: {:?}\", ty.sty)\n+                }\n             }\n-            Def::TyAlias(did) | Def::AssociatedTy(did) => {\n-                match self.tcx.opt_lookup_item_type(did).map(|scheme| &scheme.ty.sty) {\n-                    Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => {\n-                        Some((did, adt.struct_variant()))\n+            Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n+            Def::AssociatedTy(..) | Def::SelfTy(..) => {\n+                match ty.sty {\n+                    ty::TyAdt(adt, substs) if !adt.is_enum() => {\n+                        Some((adt.struct_variant(), adt.did, substs))\n                     }\n                     _ => None,\n                 }\n             }\n-            _ => None\n+            _ => bug!(\"unexpected definition: {:?}\", def)\n         };\n \n-        if let Some((def_id, variant)) = variant {\n+        if let Some((variant, did, substs)) = variant {\n             if variant.ctor_kind == CtorKind::Fn &&\n                     !self.tcx.sess.features.borrow().relaxed_adts {\n                 emit_feature_err(&self.tcx.sess.parse_sess,\n-                                 \"relaxed_adts\", span, GateIssue::Language,\n+                                 \"relaxed_adts\", path.span, GateIssue::Language,\n                                  \"tuple structs and variants in struct patterns are unstable\");\n             }\n-            let ty = self.instantiate_type_path(def_id, path, node_id);\n+\n+            // Check bounds on type arguments used in the path.\n+            let type_predicates = self.tcx.lookup_predicates(did);\n+            let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n+            let cause = traits::ObligationCause::new(path.span, self.body_id,\n+                                                     traits::ItemObligation(did));\n+            self.add_obligations_for_parameters(cause, &bounds);\n+\n             Some((variant, ty))\n         } else {\n             struct_span_err!(self.tcx.sess, path.span, E0071,\n-                             \"`{}` does not name a struct or a struct variant\",\n-                             pprust::path_to_string(path))\n+                             \"expected struct, variant or union type, found {}\",\n+                             ty.sort_string(self.tcx))\n                 .span_label(path.span, &format!(\"not a struct\"))\n                 .emit();\n             None\n@@ -3305,12 +3278,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, struct_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n-                                                                                    expr.span) {\n+        let (variant, struct_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id) {\n             variant_ty\n         } else {\n             self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx().types.err;\n+            return self.tcx.types.err;\n         };\n \n         self.check_expr_struct_fields(struct_ty, path.span, variant, fields,\n@@ -3805,7 +3777,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               }\n                           }\n                           err.emit();\n-                          self.tcx().types.err\n+                          self.tcx.types.err\n                       }\n                   }\n               }\n@@ -3815,29 +3787,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `def_map`.\n-    pub fn finish_resolving_struct_path(&self,\n-                                        path: &hir::Path,\n-                                        node_id: ast::NodeId,\n-                                        span: Span)\n-                                        -> Def\n+    fn finish_resolving_struct_path(&self,\n+                                    path: &hir::Path,\n+                                    node_id: ast::NodeId)\n+                                    -> (Def, Ty<'tcx>)\n     {\n-        let path_res = self.tcx().expect_resolution(node_id);\n-        if path_res.depth == 0 {\n-            // If fully resolved already, we don't have to do anything.\n-            path_res.base_def\n-        } else {\n-            let base_ty_end = path.segments.len() - path_res.depth;\n-            let (_ty, def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n-                                                                 PathParamMode::Optional,\n-                                                                 path_res.base_def,\n-                                                                 None,\n-                                                                 node_id,\n-                                                                 &path.segments[..base_ty_end],\n-                                                                 &path.segments[base_ty_end..]);\n-            // Write back the new resolution.\n-            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n-            def\n+        let path_res = self.tcx.expect_resolution(node_id);\n+        let base_ty_end = path.segments.len() - path_res.depth;\n+        let (ty, def) = AstConv::finish_resolving_def_to_ty(self, self, path.span,\n+                                                            PathParamMode::Optional,\n+                                                            path_res.base_def,\n+                                                            None,\n+                                                            node_id,\n+                                                            &path.segments[..base_ty_end],\n+                                                            &path.segments[base_ty_end..],\n+                                                            true);\n+        // Write back the new resolution.\n+        if path_res.depth != 0 {\n+            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n         }\n+        (def, ty)\n     }\n \n     // Resolve associated value path into a base type and associated constant or method definition.\n@@ -3849,7 +3818,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        let path_res = self.tcx().expect_resolution(node_id);\n+        let path_res = self.tcx.expect_resolution(node_id);\n         if path_res.depth == 0 {\n             // If fully resolved already, we don't have to do anything.\n             (path_res.base_def, opt_self_ty, &path.segments)\n@@ -3863,7 +3832,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                  opt_self_ty,\n                                                                  node_id,\n                                                                  &ty_segments[..base_ty_end],\n-                                                                 &ty_segments[base_ty_end..]);\n+                                                                 &ty_segments[base_ty_end..],\n+                                                                 false);\n \n             // Resolve an associated constant or method on the previously resolved type.\n             let item_segment = path.segments.last().unwrap();\n@@ -3883,7 +3853,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             // Write back the new resolution.\n-            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n             (def, Some(ty), slice::ref_slice(item_segment))\n         }\n     }\n@@ -4308,7 +4278,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // the referenced item.\n         let ty_substituted = self.instantiate_type_scheme(span, &substs, &scheme.ty);\n \n-\n         if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n             // is inherent, there is no `Self` parameter, instead, the impl needs"}, {"sha": "7dd850180d44206ffd167ee32ff6ee6558867274", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -895,17 +895,14 @@ fn some_func(x: &mut i32) {\n \n E0071: r##\"\n You tried to use structure-literal syntax to create an item that is\n-not a struct-style structure or enum variant.\n+not a structure or enum variant.\n \n Example of erroneous code:\n \n ```compile_fail,E0071\n-enum Foo { FirstValue(i32) };\n-\n-let u = Foo::FirstValue { value: 0 }; // error: Foo::FirstValue\n-                                         // isn't a structure!\n-// or even simpler, if the name doesn't refer to a structure at all.\n-let t = u32 { value: 4 }; // error: `u32` does not name a structure.\n+type U32 = u32;\n+let t = U32 { value: 4 }; // error: expected struct, variant or union type,\n+                          // found builtin type `u32`\n ```\n \n To fix this, ensure that the name was correctly spelled, and that"}, {"sha": "5ce7581000626691dcecdd7b60da1acc93b17697", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -163,14 +163,16 @@ pub fn run_core(search_paths: SearchPaths,\n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(sessopts, &dep_graph, cpath, diagnostic_handler,\n-                                       codemap, cstore.clone());\n+    let mut sess = session::build_session_(\n+        sessopts, &dep_graph, cpath, diagnostic_handler, codemap, cstore.clone()\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n     target_features::add_configuration(&mut cfg, &sess);\n+    sess.parse_sess.config = cfg;\n \n-    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n+    let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n \n     let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n \n@@ -189,7 +191,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      resolutions,\n                                                      &arenas,\n                                                      &name,\n-                                                     |tcx, _, analysis, _, result| {\n+                                                     |tcx, analysis, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}, {"sha": "45c3d413500bf9e33a7ab871255916c8cacc0599", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -73,24 +73,20 @@ pub fn run(input: &str,\n     };\n \n     let codemap = Rc::new(CodeMap::new());\n-    let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                               true,\n-                                                               false,\n-                                                               Some(codemap.clone()));\n+    let handler =\n+        errors::Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(codemap.clone()));\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(sessopts,\n-                                       &dep_graph,\n-                                       Some(input_path.clone()),\n-                                       diagnostic_handler,\n-                                       codemap,\n-                                       cstore.clone());\n+    let mut sess = session::build_session_(\n+        sessopts, &dep_graph, Some(input_path.clone()), handler, codemap, cstore.clone(),\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+    sess.parse_sess.config =\n+        config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n \n-    let cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-    let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n+    let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n     let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n@@ -236,28 +232,24 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let cstore = Rc::new(CStore::new(&dep_graph));\n-    let sess = session::build_session_(sessopts,\n-                                       &dep_graph,\n-                                       None,\n-                                       diagnostic_handler,\n-                                       codemap,\n-                                       cstore.clone());\n+    let mut sess = session::build_session_(\n+        sessopts, &dep_graph, None, diagnostic_handler, codemap, cstore.clone(),\n+    );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));\n     let libdir = sess.target_filesearch(PathKind::All).get_lib_path();\n     let mut control = driver::CompileController::basic();\n-    let cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n+    sess.parse_sess.config =\n+        config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n     let out = Some(outdir.lock().unwrap().path().to_path_buf());\n \n     if no_run {\n         control.after_analysis.stop = Compilation::Stop;\n     }\n \n     let res = panic::catch_unwind(AssertUnwindSafe(|| {\n-        driver::compile_input(&sess, &cstore, cfg.clone(),\n-                              &input, &out,\n-                              &None, None, &control)\n+        driver::compile_input(&sess, &cstore, &input, &out, &None, None, &control)\n     }));\n \n     match res {"}, {"sha": "72cd6e4830bca0a374619ee73a3977709aeea118", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -58,6 +58,8 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=ws2_32\");\n         println!(\"cargo:rustc-link-lib=userenv\");\n         println!(\"cargo:rustc-link-lib=shell32\");\n+    } else if target.contains(\"fuchsia\") {\n+        println!(\"cargo:rustc-link-lib=magenta\");\n     }\n }\n "}, {"sha": "6b26c016638a7e2c9df7fecca7daec162e93041c", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -147,6 +147,10 @@ impl<B: BufRead + ?Sized> BufRead for Box<B> {\n // =============================================================================\n // In-memory buffer implementations\n \n+/// Read is implemented for `&[u8]` by copying from the slice.\n+///\n+/// Note that reading updates the slice to point to the yet unread part.\n+/// The slice will be empty when EOF is reached.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a [u8] {\n     #[inline]\n@@ -180,6 +184,11 @@ impl<'a> BufRead for &'a [u8] {\n     fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n }\n \n+/// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n+/// its data.\n+///\n+/// Note that writing updates the slice to point to the yet unwritten part.\n+/// The slice will be empty when it has been completely overwritten.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a mut [u8] {\n     #[inline]\n@@ -204,6 +213,8 @@ impl<'a> Write for &'a mut [u8] {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n+/// Write is implemented for `Vec<u8>` by appending to the vector.\n+/// The vector will grow as needed.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Vec<u8> {\n     #[inline]"}, {"sha": "0ce6b0a9431d4a8b56ef0caa9cee3dadf9c2cb3f", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -286,7 +286,7 @@ pub mod builtin {\n     /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n     /// # }\n     /// ```\n-    #[unstable(feature = \"concat_idents\", issue = \"29599\")]\n+    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n     #[macro_export]\n     macro_rules! concat_idents {\n         ($($e:ident),*) => ({ /* compiler built-in */ })"}, {"sha": "2a918d8aeb7b8a2310785cf70a9b994b2a9b7af4", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -18,15 +18,17 @@\n                                        target_arch = \"arm\",\n                                        target_arch = \"powerpc\",\n                                        target_arch = \"powerpc64\",\n-                                       target_arch = \"s390x\"))))]\n+                                       target_arch = \"s390x\")),\n+          all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n #[cfg(not(any(target_os = \"android\",\n               target_os = \"emscripten\",\n               all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                            target_arch = \"arm\",\n                                            target_arch = \"powerpc\",\n                                            target_arch = \"powerpc64\",\n-                                           target_arch = \"s390x\")))))]\n+                                           target_arch = \"s390x\")),\n+              all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;"}, {"sha": "3aebb8c18ec869b6d39c015cf59e3e2e98da6d8f", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -27,7 +27,8 @@ fn next_u64(mut fill_buf: &mut FnMut(&mut [u8])) -> u64 {\n #[cfg(all(unix,\n           not(target_os = \"ios\"),\n           not(target_os = \"openbsd\"),\n-          not(target_os = \"freebsd\")))]\n+          not(target_os = \"freebsd\"),\n+          not(target_os = \"fuchsia\")))]\n mod imp {\n     use self::OsRngInner::*;\n     use super::{next_u32, next_u64};\n@@ -339,3 +340,54 @@ mod imp {\n         }\n     }\n }\n+\n+#[cfg(target_os = \"fuchsia\")]\n+mod imp {\n+    use super::{next_u32, next_u64};\n+\n+    use io;\n+    use rand::Rng;\n+\n+    #[link(name = \"magenta\")]\n+    extern {\n+        fn mx_cprng_draw(buffer: *mut u8, len: usize) -> isize;\n+    }\n+\n+    fn getrandom(buf: &mut [u8]) -> isize {\n+        unsafe { mx_cprng_draw(buf.as_mut_ptr(), buf.len()) }\n+    }\n+\n+    pub struct OsRng {\n+        // dummy field to ensure that this struct cannot be constructed outside\n+        // of this module\n+        _dummy: (),\n+    }\n+\n+    impl OsRng {\n+        /// Create a new `OsRng`.\n+        pub fn new() -> io::Result<OsRng> {\n+            Ok(OsRng { _dummy: () })\n+        }\n+    }\n+\n+    impl Rng for OsRng {\n+        fn next_u32(&mut self) -> u32 {\n+            next_u32(&mut |v| self.fill_bytes(v))\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            next_u64(&mut |v| self.fill_bytes(v))\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            let mut buf = v;\n+            while !buf.is_empty() {\n+                let ret = getrandom(buf);\n+                if ret < 0 {\n+                    panic!(\"kernel mx_cprng_draw call failed! (returned {}, buf.len() {})\",\n+                        ret, buf.len());\n+                }\n+                let move_buf = buf;\n+                buf = &mut move_buf[(ret as usize)..];\n+            }\n+        }\n+    }\n+}"}, {"sha": "8864694c932f38dc87a7543db23f21a3f3ab255b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -477,7 +477,6 @@ pub type CrateConfig = Vec<P<MetaItem>>;\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n-    pub config: CrateConfig,\n     pub span: Span,\n     pub exported_macros: Vec<MacroDef>,\n }"}, {"sha": "0335f210347a2e05de4ece44211c92208f53e515", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -501,10 +501,7 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n-                   sess: &ParseSess,\n-                   features: Option<&Features>)\n-                   -> bool {\n+pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n     match cfg.node {\n         ast::MetaItemKind::List(ref pred, ref mis) => {\n             for mi in mis.iter() {\n@@ -518,18 +515,18 @@ pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n             // that they won't fail with the loop above.\n             match &pred[..] {\n                 \"any\" => mis.iter().any(|mi| {\n-                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n                 }),\n                 \"all\" => mis.iter().all(|mi| {\n-                    cfg_matches(cfgs, mi.meta_item().unwrap(), sess, features)\n+                    cfg_matches(mi.meta_item().unwrap(), sess, features)\n                 }),\n                 \"not\" => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n                     }\n \n-                    !cfg_matches(cfgs, mis[0].meta_item().unwrap(), sess, features)\n+                    !cfg_matches(mis[0].meta_item().unwrap(), sess, features)\n                 },\n                 p => {\n                     span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n@@ -541,7 +538,7 @@ pub fn cfg_matches(cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n             if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n                 gated_cfg.check_and_emit(sess, feats);\n             }\n-            contains(cfgs, cfg)\n+            contains(&sess.config, cfg)\n         }\n     }\n }"}, {"sha": "946257a16d5ac110a5a6218adc372653ae653611", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -20,7 +20,6 @@ use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n-    pub config: &'a ast::CrateConfig,\n     pub should_test: bool,\n     pub sess: &'a ParseSess,\n     pub features: Option<&'a Features>,\n@@ -32,7 +31,6 @@ pub fn features(mut krate: ast::Crate, sess: &ParseSess, should_test: bool)\n     let features;\n     {\n         let mut strip_unconfigured = StripUnconfigured {\n-            config: &krate.config.clone(),\n             should_test: should_test,\n             sess: sess,\n             features: None,\n@@ -107,7 +105,7 @@ impl<'a> StripUnconfigured<'a> {\n         use attr::cfg_matches;\n         match (cfg.meta_item(), mi.meta_item()) {\n             (Some(cfg), Some(mi)) =>\n-                if cfg_matches(self.config, &cfg, self.sess, self.features) {\n+                if cfg_matches(&cfg, self.sess, self.features) {\n                     self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n                         id: attr::mk_attr_id(),\n                         style: attr.node.style,\n@@ -148,7 +146,7 @@ impl<'a> StripUnconfigured<'a> {\n                 return true;\n             }\n \n-            attr::cfg_matches(self.config, mis[0].meta_item().unwrap(), self.sess, self.features)\n+            attr::cfg_matches(mis[0].meta_item().unwrap(), self.sess, self.features)\n         })\n     }\n "}, {"sha": "cc097ab0efadc05491b2c9290e1171d092af6b8d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -574,7 +574,6 @@ pub struct ExpansionData {\n /// -> expn_info of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n-    pub cfg: ast::CrateConfig,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n     pub resolver: &'a mut Resolver,\n@@ -583,13 +582,12 @@ pub struct ExtCtxt<'a> {\n }\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n+    pub fn new(parse_sess: &'a parse::ParseSess,\n                ecfg: expand::ExpansionConfig<'a>,\n                resolver: &'a mut Resolver)\n                -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n-            cfg: cfg,\n             ecfg: ecfg,\n             crate_root: None,\n             resolver: resolver,\n@@ -617,11 +615,11 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])\n         -> parser::Parser<'a> {\n-        parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg().clone())\n+        parse::tts_to_parser(self.parse_sess, tts.to_vec())\n     }\n     pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n-    pub fn cfg(&self) -> &ast::CrateConfig { &self.cfg }\n+    pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n         self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n             Some(expn_info) => expn_info.call_site,"}, {"sha": "e3b23e239f917103d05d2bdf0307946d6600e16f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -293,11 +293,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n-        let crate_config = mem::replace(&mut self.cx.cfg, Vec::new());\n         let result = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n-                    config: &crate_config,\n                     should_test: self.cx.ecfg.should_test,\n                     sess: self.cx.parse_sess,\n                     features: self.cx.ecfg.features,\n@@ -308,7 +306,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n             (expansion.fold_with(&mut collector), collector.invocations)\n         };\n-        self.cx.cfg = crate_config;\n \n         if self.monotonic {\n             let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n@@ -646,7 +643,7 @@ fn string_to_tts(text: String, parse_sess: &ParseSess) -> Vec<TokenTree> {\n                             .new_filemap(String::from(\"<macro expansion>\"), None, text);\n \n     let lexer = lexer::StringReader::new(&parse_sess.span_diagnostic, filemap);\n-    let mut parser = Parser::new(parse_sess, Vec::new(), Box::new(lexer));\n+    let mut parser = Parser::new(parse_sess, Box::new(lexer));\n     panictry!(parser.parse_all_token_trees())\n }\n "}, {"sha": "f3497c130bff43caf6ba9cd32f5ecc52433ccb55", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -331,31 +331,27 @@ pub mod rt {\n             panictry!(parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> ast::Stmt {\n             panictry!(parse::parse_stmt_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_expr(&self, s: String) -> P<ast::Expr> {\n             panictry!(parse::parse_expr_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess()))\n         }\n \n         fn parse_tts(&self, s: String) -> Vec<TokenTree> {\n             panictry!(parse::parse_tts_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n-                self.cfg().clone(),\n                 self.parse_sess()))\n         }\n     }\n@@ -920,22 +916,14 @@ fn expand_parse_call(cx: &ExtCtxt,\n                      tts: &[TokenTree]) -> P<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || cx.expr_method_call(\n-        sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-        id_ext(\"cfg\"), Vec::new());\n-\n-    let cfg_clone_call = || cx.expr_method_call(\n-        sp, cfg_call(),\n-        id_ext(\"clone\"), Vec::new());\n-\n     let parse_sess_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"parse_sess\"), Vec::new());\n \n     let new_parser_call =\n         cx.expr_call(sp,\n                      cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n-                     vec!(parse_sess_call(), cfg_clone_call(), tts_expr));\n+                     vec!(parse_sess_call(), tts_expr));\n \n     let path = vec![id_ext(\"syntax\"), id_ext(\"ext\"), id_ext(\"quote\"), id_ext(parse_method)];\n     let mut args = vec![cx.expr_mut_addr_of(sp, new_parser_call)];"}, {"sha": "ec48cae3f7652a6a4537c5431392d77561045cef", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -92,15 +92,8 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n         None => return DummyResult::expr(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let p =\n-        parse::new_sub_parser_from_file(cx.parse_sess(),\n-                                        cx.cfg().clone(),\n-                                        &res_rel_file(cx,\n-                                                      sp,\n-                                                      Path::new(&file)),\n-                                        true,\n-                                        None,\n-                                        sp);\n+    let path = res_rel_file(cx, sp, Path::new(&file));\n+    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, true, None, sp);\n \n     struct ExpandResult<'a> {\n         p: parse::parser::Parser<'a>,"}, {"sha": "7e3fe3285695c2d6726b4df566d4c5841c61ce9a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -78,7 +78,6 @@ pub use self::NamedMatch::*;\n pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n-use ast;\n use ast::Ident;\n use syntax_pos::{self, BytePos, mk_sp, Span};\n use codemap::Spanned;\n@@ -92,6 +91,7 @@ use parse::token;\n use print::pprust;\n use ptr::P;\n use tokenstream::{self, TokenTree};\n+use util::small_vector::SmallVector;\n \n use std::mem;\n use std::rc::Rc;\n@@ -104,7 +104,7 @@ use std::collections::hash_map::Entry::{Vacant, Occupied};\n #[derive(Clone)]\n enum TokenTreeOrTokenTreeVec {\n     Tt(tokenstream::TokenTree),\n-    TtSeq(Rc<Vec<tokenstream::TokenTree>>),\n+    TtSeq(Vec<tokenstream::TokenTree>),\n }\n \n impl TokenTreeOrTokenTreeVec {\n@@ -161,7 +161,7 @@ pub fn count_names(ms: &[TokenTree]) -> usize {\n     })\n }\n \n-pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(ms: Vec<TokenTree>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(&ms[..]);\n     let matches: Vec<_> = (0..match_idx_hi).map(|_| Vec::new()).collect();\n@@ -279,17 +279,10 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse(sess: &ParseSess,\n-             cfg: &ast::CrateConfig,\n-             mut rdr: TtReader,\n-             ms: &[TokenTree])\n-             -> NamedParseResult {\n-    let mut cur_eis = Vec::new();\n-    cur_eis.push(initial_matcher_pos(Rc::new(ms.iter()\n-                                                .cloned()\n-                                                .collect()),\n-                                     None,\n-                                     rdr.peek().sp.lo));\n+pub fn parse(sess: &ParseSess, mut rdr: TtReader, ms: &[TokenTree]) -> NamedParseResult {\n+    let mut cur_eis = SmallVector::one(initial_matcher_pos(ms.to_owned(),\n+                                                           None,\n+                                                           rdr.peek().sp.lo));\n \n     loop {\n         let mut bb_eis = Vec::new(); // black-box parsed by parser.rs\n@@ -484,7 +477,7 @@ pub fn parse(sess: &ParseSess,\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n                 rdr.next_tok = {\n-                    let mut rust_parser = Parser::new(sess, cfg.clone(), Box::new(&mut rdr));\n+                    let mut rust_parser = Parser::new(sess, Box::new(&mut rdr));\n                     let mut ei = bb_eis.pop().unwrap();\n                     if let TokenTree::Token(span, MatchNt(_, ident)) = ei.top_elts.get_tt(ei.idx) {\n                         let match_cur = ei.match_cur;"}, {"sha": "431e757368c0361d59f0c2954d4979dbb63afe5c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -115,7 +115,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr =\n                     new_tt_reader(&cx.parse_sess.span_diagnostic, Some(named_matches), rhs);\n-                let mut p = Parser::new(cx.parse_sess(), cx.cfg().clone(), Box::new(trncbr));\n+                let mut p = Parser::new(cx.parse_sess(), Box::new(trncbr));\n                 p.directory = cx.current_expansion.module.directory.clone();\n                 p.restrictions = match cx.current_expansion.no_noninline_mod {\n                     true => Restrictions::NO_NONINLINE_MOD,\n@@ -220,7 +220,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&sess.span_diagnostic, None, def.body.clone());\n \n-    let argument_map = match parse(sess, &Vec::new(), arg_reader, &argument_gram) {\n+    let argument_map = match parse(sess, arg_reader, &argument_gram) {\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);"}, {"sha": "8a6a8e53a3e4c1b122aa2c33030b4724e94a1449", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,14 +10,15 @@\n use self::LockstepIterSize::*;\n \n use ast::Ident;\n-use syntax_pos::{Span, DUMMY_SP};\n use errors::{Handler, DiagnosticBuilder};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n use parse::token::{Token, Interpolated, NtIdent, NtTT};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n+use syntax_pos::{Span, DUMMY_SP};\n use tokenstream::{self, TokenTree};\n+use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n use std::ops::Add;\n@@ -36,7 +37,7 @@ struct TtFrame {\n pub struct TtReader<'a> {\n     pub sp_diag: &'a Handler,\n     /// the unzipped tree:\n-    stack: Vec<TtFrame>,\n+    stack: SmallVector<TtFrame>,\n     /* for MBE-style macro transcription */\n     interpolations: HashMap<Ident, Rc<NamedMatch>>,\n \n@@ -74,7 +75,7 @@ pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n                                    -> TtReader {\n     let mut r = TtReader {\n         sp_diag: sp_diag,\n-        stack: vec!(TtFrame {\n+        stack: SmallVector::one(TtFrame {\n             forest: TokenTree::Sequence(DUMMY_SP, Rc::new(tokenstream::SequenceRepetition {\n                 tts: src,\n                 // doesn't matter. This merely holds the root unzipping."}, {"sha": "4bf6e55d6743bdbda6a2f45871b9c19cd3d3cdd8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -972,10 +972,8 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_macros, span}: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, mut exported_macros, span}: Crate,\n                                   folder: &mut T) -> Crate {\n-    let config = folder.fold_meta_items(config);\n-\n     let mut items = folder.fold_item(P(ast::Item {\n         ident: keywords::Invalid.ident(),\n         attrs: attrs,\n@@ -1009,7 +1007,6 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n     Crate {\n         module: module,\n         attrs: attrs,\n-        config: config,\n         exported_macros: exported_macros,\n         span: span,\n     }"}, {"sha": "b86e508d89970a3f614e4b979d7fa2ccf201668a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -36,6 +36,7 @@\n #![feature(specialization)]\n #![feature(dotdot_in_tuple_patterns)]\n \n+extern crate core;\n extern crate serialize;\n extern crate term;\n extern crate libc;"}, {"sha": "7b67c23e10231464b1d537931155247ea15f147d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 41, "deletions": 103, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n //! The main parser interface\n \n-use ast;\n+use ast::{self, CrateConfig};\n use codemap::CodeMap;\n use syntax_pos::{self, Span, FileMap};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n@@ -44,13 +44,14 @@ pub mod obsolete;\n pub struct ParseSess {\n     pub span_diagnostic: Handler, // better be the same as the one in the reader!\n     pub unstable_features: UnstableFeatures,\n+    pub config: CrateConfig,\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: RefCell<Vec<PathBuf>>,\n     code_map: Rc<CodeMap>,\n }\n \n impl ParseSess {\n-    pub fn new() -> ParseSess {\n+    pub fn new() -> Self {\n         let cm = Rc::new(CodeMap::new());\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n                                                 true,\n@@ -63,6 +64,7 @@ impl ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n+            config: Vec::new(),\n             included_mod_stack: RefCell::new(vec![]),\n             code_map: code_map\n         }\n@@ -78,146 +80,90 @@ impl ParseSess {\n // uses a HOF to parse anything, and <source> includes file and\n // source_str.\n \n-pub fn parse_crate_from_file<'a>(input: &Path,\n-                                 cfg: ast::CrateConfig,\n-                                 sess: &'a ParseSess)\n-                                 -> PResult<'a, ast::Crate> {\n-    let mut parser = new_parser_from_file(sess, cfg, input);\n+pub fn parse_crate_from_file<'a>(input: &Path, sess: &'a ParseSess) -> PResult<'a, ast::Crate> {\n+    let mut parser = new_parser_from_file(sess, input);\n     parser.parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_file<'a>(input: &Path,\n-                                       cfg: ast::CrateConfig,\n-                                       sess: &'a ParseSess)\n+pub fn parse_crate_attrs_from_file<'a>(input: &Path, sess: &'a ParseSess)\n                                        -> PResult<'a, Vec<ast::Attribute>> {\n-    let mut parser = new_parser_from_file(sess, cfg, input);\n+    let mut parser = new_parser_from_file(sess, input);\n     parser.parse_inner_attributes()\n }\n \n-pub fn parse_crate_from_source_str<'a>(name: String,\n-                                       source: String,\n-                                       cfg: ast::CrateConfig,\n-                                       sess: &'a ParseSess)\n+pub fn parse_crate_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                        -> PResult<'a, ast::Crate> {\n-    let mut p = new_parser_from_source_str(sess,\n-                                           cfg,\n-                                           name,\n-                                           source);\n-    p.parse_crate_mod()\n+    new_parser_from_source_str(sess, name, source).parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_source_str<'a>(name: String,\n-                                             source: String,\n-                                             cfg: ast::CrateConfig,\n-                                             sess: &'a ParseSess)\n+pub fn parse_crate_attrs_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                              -> PResult<'a, Vec<ast::Attribute>> {\n-    let mut p = new_parser_from_source_str(sess,\n-                                           cfg,\n-                                           name,\n-                                           source);\n-    p.parse_inner_attributes()\n+    new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n \n-pub fn parse_expr_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_expr_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, P<ast::Expr>> {\n-    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    p.parse_expr()\n+    new_parser_from_source_str(sess, name, source).parse_expr()\n }\n \n /// Parses an item.\n ///\n /// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and`Err`\n /// when a syntax error occurred.\n-pub fn parse_item_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_item_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, Option<P<ast::Item>>> {\n-    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    p.parse_item()\n+    new_parser_from_source_str(sess, name, source).parse_item()\n }\n \n-pub fn parse_meta_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_meta_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, P<ast::MetaItem>> {\n-    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    p.parse_meta_item()\n+    new_parser_from_source_str(sess, name, source).parse_meta_item()\n }\n \n-pub fn parse_stmt_from_source_str<'a>(name: String,\n-                                      source: String,\n-                                      cfg: ast::CrateConfig,\n-                                      sess: &'a ParseSess)\n+pub fn parse_stmt_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                       -> PResult<'a, Option<ast::Stmt>> {\n-    let mut p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n-    p.parse_stmt()\n+    new_parser_from_source_str(sess, name, source).parse_stmt()\n }\n \n // Warning: This parses with quote_depth > 0, which is not the default.\n-pub fn parse_tts_from_source_str<'a>(name: String,\n-                                     source: String,\n-                                     cfg: ast::CrateConfig,\n-                                     sess: &'a ParseSess)\n+pub fn parse_tts_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                      -> PResult<'a, Vec<tokenstream::TokenTree>> {\n-    let mut p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, name, source);\n     p.quote_depth += 1;\n     // right now this is re-creating the token trees from ... token trees.\n     p.parse_all_token_trees()\n }\n \n // Create a new parser from a source string\n-pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n-                                      cfg: ast::CrateConfig,\n-                                      name: String,\n-                                      source: String)\n+pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess, name: String, source: String)\n                                       -> Parser<'a> {\n-    filemap_to_parser(sess, sess.codemap().new_filemap(name, None, source), cfg)\n+    filemap_to_parser(sess, sess.codemap().new_filemap(name, None, source))\n }\n \n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_parser_from_file<'a>(sess: &'a ParseSess,\n-                                cfg: ast::CrateConfig,\n-                                path: &Path) -> Parser<'a> {\n-    filemap_to_parser(sess, file_to_filemap(sess, path, None), cfg)\n+pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a> {\n+    filemap_to_parser(sess, file_to_filemap(sess, path, None))\n }\n \n /// Given a session, a crate config, a path, and a span, add\n /// the file at the given path to the codemap, and return a parser.\n /// On an error, use the given span as the source of the problem.\n pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n-                                    cfg: ast::CrateConfig,\n                                     path: &Path,\n                                     owns_directory: bool,\n                                     module_name: Option<String>,\n                                     sp: Span) -> Parser<'a> {\n-    let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)), cfg);\n+    let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)));\n     p.owns_directory = owns_directory;\n     p.root_module_name = module_name;\n     p\n }\n \n /// Given a filemap and config, return a parser\n-pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n-                             filemap: Rc<FileMap>,\n-                             cfg: ast::CrateConfig) -> Parser<'a> {\n+pub fn filemap_to_parser<'a>(sess: &'a ParseSess, filemap: Rc<FileMap>, ) -> Parser<'a> {\n     let end_pos = filemap.end_pos;\n-    let mut parser = tts_to_parser(sess, filemap_to_tts(sess, filemap), cfg);\n+    let mut parser = tts_to_parser(sess, filemap_to_tts(sess, filemap));\n \n     if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n         parser.span = syntax_pos::mk_sp(end_pos, end_pos);\n@@ -228,18 +174,13 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n \n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n-pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n-                               cfg: ast::CrateConfig,\n-                               tts: Vec<tokenstream::TokenTree>)\n+pub fn new_parser_from_tts<'a>(sess: &'a ParseSess, tts: Vec<tokenstream::TokenTree>)\n                                -> Parser<'a> {\n-    tts_to_parser(sess, tts, cfg)\n+    tts_to_parser(sess, tts)\n }\n \n-pub fn new_parser_from_ts<'a>(sess: &'a ParseSess,\n-                              cfg: ast::CrateConfig,\n-                              ts: tokenstream::TokenStream)\n-                              -> Parser<'a> {\n-    tts_to_parser(sess, ts.to_tts(), cfg)\n+pub fn new_parser_from_ts<'a>(sess: &'a ParseSess, ts: tokenstream::TokenStream) -> Parser<'a> {\n+    tts_to_parser(sess, ts.to_tts())\n }\n \n \n@@ -266,18 +207,15 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     -> Vec<tokenstream::TokenTree> {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n-    let cfg = Vec::new();\n     let srdr = lexer::StringReader::new(&sess.span_diagnostic, filemap);\n-    let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n+    let mut p1 = Parser::new(sess, Box::new(srdr));\n     panictry!(p1.parse_all_token_trees())\n }\n \n-/// Given tts and cfg, produce a parser\n-pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n-                         tts: Vec<tokenstream::TokenTree>,\n-                         cfg: ast::CrateConfig) -> Parser<'a> {\n+/// Given tts and the ParseSess, produce a parser\n+pub fn tts_to_parser<'a>(sess: &'a ParseSess, tts: Vec<tokenstream::TokenTree>) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n-    let mut p = Parser::new(sess, cfg, Box::new(trdr));\n+    let mut p = Parser::new(sess, Box::new(trdr));\n     p.check_unknown_macro_variable();\n     p\n }\n@@ -1057,21 +995,21 @@ mod tests {\n \n         let name = \"<source>\".to_string();\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess)\n+        let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(&doc[..], \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess)\n+        let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n         let docs = item.attrs.iter().filter(|a| &*a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n-        let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap().unwrap();\n+        let item = parse_item_from_source_str(name, source, &sess).unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n         assert_eq!(&doc[..], \"/** doc comment\\n *  with CRLF */\");\n     }\n@@ -1080,7 +1018,7 @@ mod tests {\n     fn ttdelim_span() {\n         let sess = ParseSess::new();\n         let expr = parse::parse_expr_from_source_str(\"foo\".to_string(),\n-            \"foo!( fn main() { body } )\".to_string(), vec![], &sess).unwrap();\n+            \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n         let tts = match expr.node {\n             ast::ExprKind::Mac(ref mac) => mac.node.tts.clone(),"}, {"sha": "a75937759a2a596470830d4acf8ad947305156f8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,7 +15,7 @@ use ast::Unsafety;\n use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n-use ast::{Constness, Crate, CrateConfig};\n+use ast::{Constness, Crate};\n use ast::Defaultness;\n use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n@@ -271,7 +271,6 @@ pub struct Parser<'a> {\n     pub span: Span,\n     /// the span of the previous token:\n     pub prev_span: Span,\n-    pub cfg: CrateConfig,\n     /// the previous token kind\n     prev_token_kind: PrevTokenKind,\n     lookahead_buffer: LookaheadBuffer,\n@@ -358,11 +357,7 @@ impl From<P<Expr>> for LhsExpr {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(sess: &'a ParseSess,\n-               cfg: ast::CrateConfig,\n-               mut rdr: Box<Reader+'a>)\n-               -> Parser<'a>\n-    {\n+    pub fn new(sess: &'a ParseSess, mut rdr: Box<Reader+'a>) -> Self {\n         let tok0 = rdr.real_token();\n         let span = tok0.sp;\n         let mut directory = match span {\n@@ -374,7 +369,6 @@ impl<'a> Parser<'a> {\n         Parser {\n             reader: rdr,\n             sess: sess,\n-            cfg: cfg,\n             token: tok0.tok,\n             span: span,\n             prev_span: span,\n@@ -1757,6 +1751,17 @@ impl<'a> Parser<'a> {\n             // First, parse an identifier.\n             let identifier = self.parse_path_segment_ident()?;\n \n+            if self.check(&token::ModSep) && self.look_ahead(1, |t| *t == token::Lt) {\n+                self.bump();\n+                let prev_span = self.prev_span;\n+\n+                let mut err = self.diagnostic().struct_span_err(prev_span,\n+                    \"unexpected token: `::`\");\n+                err.help(\n+                    \"use `<...>` instead of `::<...>` if you meant to specify type arguments\");\n+                err.emit();\n+            }\n+\n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n@@ -5317,7 +5322,6 @@ impl<'a> Parser<'a> {\n     fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n         let (in_cfg, outer_attrs) = {\n             let mut strip_unconfigured = ::config::StripUnconfigured {\n-                config: &self.cfg,\n                 sess: self.sess,\n                 should_test: false, // irrelevant\n                 features: None, // don't perform gated feature checking\n@@ -5485,12 +5489,7 @@ impl<'a> Parser<'a> {\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);\n \n-        let mut p0 = new_sub_parser_from_file(self.sess,\n-                                              self.cfg.clone(),\n-                                              &path,\n-                                              owns_directory,\n-                                              Some(name),\n-                                              id_sp);\n+        let mut p0 = new_sub_parser_from_file(self.sess, &path, owns_directory, Some(name), id_sp);\n         let mod_inner_lo = p0.span.lo;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n@@ -6134,15 +6133,20 @@ impl<'a> Parser<'a> {\n     /// MOD_SEP? LBRACE item_seq RBRACE\n     fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> {\n         let lo = self.span.lo;\n-        if self.check(&token::OpenDelim(token::Brace)) || self.is_import_coupler() {\n-            // `{foo, bar}` or `::{foo, bar}`\n+        if self.check(&token::OpenDelim(token::Brace)) || self.check(&token::BinOp(token::Star)) ||\n+           self.is_import_coupler() {\n+            // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n             let prefix = ast::Path {\n                 global: self.eat(&token::ModSep),\n                 segments: Vec::new(),\n                 span: mk_sp(lo, self.span.hi),\n             };\n-            let items = self.parse_path_list_items()?;\n-            Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n+            let view_path_kind = if self.eat(&token::BinOp(token::Star)) {\n+                ViewPathGlob(prefix)\n+            } else {\n+                ViewPathList(prefix, self.parse_path_list_items()?)\n+            };\n+            Ok(P(spanned(lo, self.span.hi, view_path_kind)))\n         } else {\n             let prefix = self.parse_path(PathStyle::Mod)?;\n             if self.is_import_coupler() {\n@@ -6179,7 +6183,6 @@ impl<'a> Parser<'a> {\n         Ok(ast::Crate {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n-            config: self.cfg.clone(),\n             span: mk_sp(lo, self.span.lo),\n             exported_macros: Vec::new(),\n         })"}, {"sha": "fdc1f45623d9c15b2ffb1a91d560de07d76f3da3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -274,7 +274,7 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, vec![], ExpansionConfig::default(\"test\".to_string()), resolver),\n+        ext_cx: ExtCtxt::new(sess, ExpansionConfig::default(\"test\".to_string()), resolver),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main: reexport_test_harness_main,"}, {"sha": "9e644e59e86a736ee62caa68722165ccce1f23ff", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -220,7 +220,7 @@ impl TokenTree {\n                                                          None,\n                                                          tts.iter().cloned().collect(),\n                                                          true);\n-        macro_parser::parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtch)\n+        macro_parser::parse(cx.parse_sess(), arg_rdr, mtch)\n     }\n \n     /// Check if this TokenTree is equal to the other, regardless of span information."}, {"sha": "76d3f2a063c1884bd0d49b980ecbafe47c2a4e28", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -25,10 +25,7 @@ pub fn string_to_tts(source_str: String) -> Vec<tokenstream::TokenTree> {\n \n /// Map string to parser (via tts)\n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n-    new_parser_from_source_str(ps,\n-                               Vec::new(),\n-                               \"bogofile\".to_string(),\n-                               source_str)\n+    new_parser_from_source_str(ps, \"bogofile\".to_string(), source_str)\n }\n \n fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T where"}, {"sha": "57258c76335a1a4c39bb1bcd9a84c50404f250f5", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,6 +11,7 @@\n use self::SmallVectorRepr::*;\n use self::IntoIterRepr::*;\n \n+use core::ops;\n use std::iter::{IntoIterator, FromIterator};\n use std::mem;\n use std::slice;\n@@ -19,10 +20,12 @@ use std::vec;\n use util::move_map::MoveMap;\n \n /// A vector type optimized for cases where the size is almost always 0 or 1\n+#[derive(Clone)]\n pub struct SmallVector<T> {\n     repr: SmallVectorRepr<T>,\n }\n \n+#[derive(Clone)]\n enum SmallVectorRepr<T> {\n     Zero,\n     One(T),\n@@ -75,16 +78,11 @@ impl<T> SmallVector<T> {\n     }\n \n     pub fn as_slice(&self) -> &[T] {\n-        match self.repr {\n-            Zero => {\n-                let result: &[T] = &[];\n-                result\n-            }\n-            One(ref v) => {\n-                unsafe { slice::from_raw_parts(v, 1) }\n-            }\n-            Many(ref vs) => vs\n-        }\n+        self\n+    }\n+\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        self\n     }\n \n     pub fn pop(&mut self) -> Option<T> {\n@@ -163,6 +161,38 @@ impl<T> SmallVector<T> {\n     }\n }\n \n+impl<T> ops::Deref for SmallVector<T> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &[T] {\n+        match self.repr {\n+            Zero => {\n+                let result: &[T] = &[];\n+                result\n+            }\n+            One(ref v) => {\n+                unsafe { slice::from_raw_parts(v, 1) }\n+            }\n+            Many(ref vs) => vs\n+        }\n+    }\n+}\n+\n+impl<T> ops::DerefMut for SmallVector<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        match self.repr {\n+            Zero => {\n+                let result: &mut [T] = &mut [];\n+                result\n+            }\n+            One(ref mut v) => {\n+                unsafe { slice::from_raw_parts_mut(v, 1) }\n+            }\n+            Many(ref mut vs) => vs\n+        }\n+    }\n+}\n+\n impl<T> IntoIterator for SmallVector<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;"}, {"sha": "24c515e502808f5799fe66c4f17a5ac0cb35acef", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -107,7 +107,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                 if p2.token != token::Eof {\n                     let mut extra_tts = panictry!(p2.parse_all_token_trees());\n                     extra_tts.extend(tts[first_colon..].iter().cloned());\n-                    p = parse::tts_to_parser(cx.parse_sess, extra_tts, cx.cfg().clone());\n+                    p = parse::tts_to_parser(cx.parse_sess, extra_tts);\n                 }\n \n                 asm = s;"}, {"sha": "98da49545f9272c3dac300ac81ca78d11843493a", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -32,6 +32,6 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.cfg, &cfg, cx.parse_sess, cx.ecfg.features);\n+    let matches_cfg = attr::cfg_matches(&cfg, cx.parse_sess, cx.ecfg.features);\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "687f8c902f2597fd9858d22aaba1139a94c41b6e", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1460,8 +1460,9 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|v| {\n                 let ident = v.node.name;\n+                let sp = Span { expn_id: trait_.span.expn_id, ..v.span };\n                 let summary = trait_.summarise_struct(cx, &v.node.data);\n-                (ident, v.span, summary)\n+                (ident, sp, summary)\n             })\n             .collect();\n         self.call_substructure_method(cx,"}, {"sha": "f49a5f0e0706ed11084c9261be45ec2d45489082", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -47,7 +47,7 @@ pub fn modify(sess: &ParseSess,\n               handler: &errors::Handler,\n               features: &Features) -> ast::Crate {\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n-    let mut cx = ExtCtxt::new(sess, Vec::new(), ecfg, resolver);\n+    let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n \n     let mut collect = CollectCustomDerives {\n         derives: Vec::new(),"}, {"sha": "d83d3a6c5cfac1f2d7bd65641e4d6ca9d919b13d", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -481,6 +481,9 @@ impl FileMap {\n         self.src.is_none()\n     }\n \n+    pub fn byte_length(&self) -> u32 {\n+        self.end_pos.0 - self.start_pos.0\n+    }\n     pub fn count_lines(&self) -> usize {\n         self.lines.borrow().len()\n     }"}, {"sha": "c1d962263bf76a10bea0c761621fcd98d6214b2e", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1 +1 @@\n-Subproject commit 8c9961a9cc406c9bcb29a8752a4a2ad9f5f98b1b\n+Subproject commit c1d962263bf76a10bea0c761621fcd98d6214b2e"}, {"sha": "37fded948e1de8704ab6d0e12b32502efd0afa9d", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-10-18\n+2016-10-29"}, {"sha": "60697cc8b6acecd985193530abedecd2d487c95c", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -56,8 +56,7 @@ fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n                    -> Box<MacResult+'static> {\n     // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n-        cx.cfg().clone(), tts.to_vec());\n+    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "95af37605441da366b6a6ada5171c7fe024ffef2", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,6 +15,6 @@ pub use use_from_trait_xc::Trait;\n \n fn main() {\n     match () {\n-        Trait { x: 42 } => () //~ ERROR expected variant, struct or type alias, found trait `Trait`\n+        Trait { x: 42 } => () //~ ERROR expected struct, variant or union type, found trait `Trait`\n     }\n }"}, {"sha": "4a7033d44b87858e65e5479c8bb9a4b52825536a", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps, vec![],\n+        &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {"}, {"sha": "95653ae83e7cd6080fcd0142a727db746168d51c", "filename": "src/test/compile-fail/E0071.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2FE0071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2FE0071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0071.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n enum Foo {}\n+type FooAlias = Foo;\n \n fn main() {\n-    let u = Foo { value: 0 };\n-    //~^ ERROR `Foo` does not name a struct or a struct variant [E0071]\n-    //~| NOTE not a struct\n-\n-    let t = u32 { value: 4 };\n-    //~^ ERROR `u32` does not name a struct or a struct variant [E0071]\n+    let u = FooAlias { value: 0 };\n+    //~^ ERROR expected struct, variant or union type, found enum `Foo` [E0071]\n     //~| NOTE not a struct\n }"}, {"sha": "02939565f69cd0417b160218761931fab61a05f7", "filename": "src/test/compile-fail/enums-are-namespaced-xc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fenums-are-namespaced-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fenums-are-namespaced-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenums-are-namespaced-xc.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,5 +14,6 @@ extern crate namespaced_enums;\n fn main() {\n     let _ = namespaced_enums::A; //~ ERROR unresolved name\n     let _ = namespaced_enums::B(10); //~ ERROR unresolved name\n-    let _ = namespaced_enums::C { a: 10 }; //~ ERROR does not name a structure\n+    let _ = namespaced_enums::C { a: 10 };\n+    //~^ ERROR unresolved struct, variant or union type `namespaced_enums::C`\n }"}, {"sha": "c6f76ca78874bdc74e290e685ec285a503207e67", "filename": "src/test/compile-fail/issue-12612.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,7 +16,7 @@ use foo::bar;\n \n mod test {\n     use bar::foo; //~ ERROR unresolved import `bar::foo` [E0432]\n-                  //~^ Maybe a missing `extern crate bar`?\n+                  //~^ Maybe a missing `extern crate bar;`?\n }\n \n fn main() {}"}, {"sha": "92c1e4b5f5060810c5bb8da8e6cd39b8d7baa19f", "filename": "src/test/compile-fail/issue-16058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -16,7 +16,7 @@ pub struct GslResult {\n \n impl GslResult {\n     pub fn new() -> GslResult {\n-        Result { //~ ERROR: `Result` does not name a struct or a struct variant\n+        Result { //~ ERROR: expected struct, variant or union type, found enum `Result`\n             val: 0f64,\n             err: 0f64\n         }"}, {"sha": "1375200271c552c791d51b15410b84bd488b5efc", "filename": "src/test/compile-fail/issue-1697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,6 +11,6 @@\n // Testing that we don't fail abnormally after hitting the errors\n \n use unresolved::*; //~ ERROR unresolved import `unresolved::*` [E0432]\n-                   //~^ Maybe a missing `extern crate unresolved`?\n+                   //~^ Maybe a missing `extern crate unresolved;`?\n \n fn main() {}"}, {"sha": "413e8b464fff78a2aacbe103f7e0651f970407d2", "filename": "src/test/compile-fail/issue-17001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,5 +11,5 @@\n mod foo {}\n \n fn main() {\n-    let p = foo { x: () }; //~ ERROR `foo` does not name a struct or a struct variant\n+    let p = foo { x: () }; //~ ERROR expected struct, variant or union type, found module `foo`\n }"}, {"sha": "5a6bd5ed588a676d6ecfcecc944f9c10970c209c", "filename": "src/test/compile-fail/issue-17405.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,6 +14,6 @@ enum Foo {\n \n fn main() {\n     match Foo::Bar(1) {\n-        Foo { i } => () //~ ERROR expected variant, struct or type alias, found enum `Foo`\n+        Foo { i } => () //~ ERROR expected struct, variant or union type, found enum `Foo`\n     }\n }"}, {"sha": "2113e38c45cc38aab2c7e1bf9413ef63ad08d00f", "filename": "src/test/compile-fail/issue-17518.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-17518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-17518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17518.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -13,5 +13,5 @@ enum SomeEnum {\n }\n \n fn main() {\n-    E { name: \"foobar\" }; //~ ERROR `E` does not name a structure\n+    E { name: \"foobar\" }; //~ ERROR unresolved struct, variant or union type `E`\n }"}, {"sha": "cc44cf88f09bd97b0d5364052265657c3f89e2d7", "filename": "src/test/compile-fail/issue-21449.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,5 +11,6 @@\n mod MyMod {}\n \n fn main() {\n-    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a struct or a struct variant\n+    let myVar = MyMod { T: 0 };\n+    //~^ ERROR expected struct, variant or union type, found module `MyMod`\n }"}, {"sha": "8be3d88bd5c8f5bcfdbbf24fd16d895ed77f411a", "filename": "src/test/compile-fail/issue-26459.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,6 +11,6 @@\n fn main() {\n     match 'a' {\n         char{ch} => true\n-        //~^ ERROR expected variant, struct or type alias, found builtin type `char`\n+        //~^ ERROR expected struct, variant or union type, found builtin type `char`\n     };\n }"}, {"sha": "d9840abf0ca77a371182b9f69e33e4f67251fbe5", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,12 +11,12 @@\n mod A {}\n \n fn main() {\n-    let u = A { x: 1 }; //~ ERROR `A` does not name a struct or a struct variant\n-    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a struct or a struct variant\n+    let u = A { x: 1 }; //~ ERROR expected struct, variant or union type, found module `A`\n+    let v = u32 { x: 1 }; //~ ERROR expected struct, variant or union type, found builtin type `u32`\n     match () {\n         A { x: 1 } => {}\n-        //~^ ERROR expected variant, struct or type alias, found module `A`\n+        //~^ ERROR expected struct, variant or union type, found module `A`\n         u32 { x: 1 } => {}\n-        //~^ ERROR expected variant, struct or type alias, found builtin type `u32`\n+        //~^ ERROR expected struct, variant or union type, found builtin type `u32`\n     }\n }"}, {"sha": "9abf2b5ec3ad3d988e2531849a22837d8fdb4a1f", "filename": "src/test/compile-fail/issue-36116.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<T> {\n+    _a: T,\n+}\n+\n+fn main() {\n+    let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>);\n+    //~^ ERROR unexpected token: `::`\n+    //~| HELP use `<...>` instead of `::<...>` if you meant to specify type arguments\n+\n+    let g: Foo::<i32> = Foo { _a: 42 };\n+    //~^ ERROR unexpected token: `::`\n+    //~| HELP use `<...>` instead of `::<...>` if you meant to specify type arguments\n+}"}, {"sha": "1ab59e790d7ee5975a6a41524625763b08c24930", "filename": "src/test/compile-fail/lexical-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,7 +10,7 @@\n \n struct T { i: i32 }\n fn f<T>() {\n-    let t = T { i: 0 }; //~ ERROR `T` does not name a struct or a struct variant\n+    let t = T { i: 0 }; //~ ERROR expected struct, variant or union type, found type parameter `T`\n }\n \n mod Foo {"}, {"sha": "385d012cadee65f58396390849972b540f9c79c3", "filename": "src/test/compile-fail/no-patterns-in-args-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-patterns-in-args-2.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(patterns_in_fns_without_body)]\n+\n+trait Tr {\n+    fn f1(mut arg: u8); //~ ERROR patterns aren't allowed in methods without bodies\n+                        //~^ WARN was previously accepted\n+    fn f2(&arg: u8); //~ ERROR patterns aren't allowed in methods without bodies\n+                     //~^ WARN was previously accepted\n+    fn g1(arg: u8); // OK\n+    fn g2(_: u8); // OK\n+    fn g3(u8); // OK\n+}\n+\n+fn main() {}"}, {"sha": "1b6e51e37034e5be42d59d1609769f5ae592b85f", "filename": "src/test/compile-fail/struct-path-alias-bounds.rs", "status": "renamed", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-alias-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-alias-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-alias-bounds.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -8,8 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main () {\n-    let x = Foo { x: 1, y: 2 };\n-    //~^ ERROR E0422\n-    //~| NOTE not a structure\n+// issue #36286\n+\n+struct S<T: Clone> { a: T }\n+\n+struct NoClone;\n+type A = S<NoClone>;\n+\n+fn main() {\n+    let s = A { a: NoClone };\n+    //~^ ERROR the trait bound `NoClone: std::clone::Clone` is not satisfied\n }", "previous_filename": "src/test/compile-fail/E0422.rs"}, {"sha": "660ac44ce0b53c07130fa71b89f73afac155d9d7", "filename": "src/test/compile-fail/struct-path-associated-type.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+trait Tr {\n+    type A;\n+}\n+\n+impl Tr for S {\n+    type A = S;\n+}\n+\n+fn f<T: Tr>() {\n+    let s = T::A {};\n+    //~^ ERROR expected struct, variant or union type, found associated type\n+    let z = T::A::<u8> {};\n+    //~^ ERROR expected struct, variant or union type, found associated type\n+    //~| ERROR type parameters are not allowed on this type\n+    match S {\n+        T::A {} => {}\n+        //~^ ERROR expected struct, variant or union type, found associated type\n+    }\n+}\n+\n+fn g<T: Tr<A = S>>() {\n+    let s = T::A {}; // OK\n+    let z = T::A::<u8> {}; //~ ERROR type parameters are not allowed on this type\n+    match S {\n+        T::A {} => {} // OK\n+    }\n+}\n+\n+fn main() {\n+    let s = S::A {}; //~ ERROR ambiguous associated type\n+    let z = S::A::<u8> {}; //~ ERROR ambiguous associated type\n+    //~^ ERROR type parameters are not allowed on this type\n+    match S {\n+        S::A {} => {} //~ ERROR ambiguous associated type\n+    }\n+}"}, {"sha": "f694e7d277c7fec094e70b30b191f17605845340", "filename": "src/test/compile-fail/struct-path-self-type-mismatch.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<A> { inner: A }\n+\n+trait Bar { fn bar(); }\n+\n+impl Bar for Foo<i32> {\n+    fn bar() {\n+        Self { inner: 1.5f32 }; //~ ERROR mismatched types\n+                                //~^ NOTE expected i32, found f32\n+    }\n+}\n+\n+impl<T> Foo<T> {\n+    fn new<U>(u: U) -> Foo<U> {\n+        Self {\n+        //~^ ERROR mismatched types\n+        //~| expected type parameter, found a different type parameter\n+        //~| expected type `Foo<U>`\n+        //~| found type `Foo<T>`\n+            inner: u\n+            //~^ ERROR mismatched types\n+            //~| expected type parameter, found a different type parameter\n+            //~| expected type `T`\n+            //~| found type `U`\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "067d6ac22dc6fb35a3a7e06fdb98c6be84487de7", "filename": "src/test/compile-fail/struct-path-self.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+trait Tr {\n+    fn f() {\n+        let s = Self {};\n+        //~^ ERROR expected struct, variant or union type, found Self\n+        let z = Self::<u8> {};\n+        //~^ ERROR expected struct, variant or union type, found Self\n+        //~| ERROR type parameters are not allowed on this type\n+        match s {\n+            Self { .. } => {}\n+            //~^ ERROR expected struct, variant or union type, found Self\n+        }\n+    }\n+}\n+\n+impl Tr for S {\n+    fn f() {\n+        let s = Self {}; // OK\n+        let z = Self::<u8> {}; //~ ERROR type parameters are not allowed on this type\n+        match s {\n+            Self { .. } => {} // OK\n+        }\n+    }\n+}\n+\n+impl S {\n+    fn g() {\n+        let s = Self {}; // OK\n+        let z = Self::<u8> {}; //~ ERROR type parameters are not allowed on this type\n+        match s {\n+            Self { .. } => {} // OK\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "49d58580da52ddb34f353c6b7df55e0ed655865d", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -12,6 +12,5 @@ trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };\n-    //~^ ERROR: `TraitNotAStruct` does not name a struct or a struct variant [E0071]\n-    //~| NOTE not a struct\n+    //~^ ERROR expected struct, variant or union type, found trait `TraitNotAStruct`\n }"}, {"sha": "47490af0ff35edbd8ea28d12f411d6e0b4f73e44", "filename": "src/test/compile-fail/unresolved-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-import.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -11,7 +11,7 @@\n // ignore-tidy-linelength\n \n use foo::bar; //~ ERROR unresolved import `foo::bar` [E0432]\n-              //~^ Maybe a missing `extern crate foo`?\n+              //~^ Maybe a missing `extern crate foo;`?\n \n use bar::Baz as x; //~ ERROR unresolved import `bar::Baz` [E0432]\n                    //~^ no `Baz` in `bar`. Did you mean to use `Bar`?"}, {"sha": "391c2e75ba4d5770dbd81840130fe2708043ab5e", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -264,17 +264,17 @@ trait TraitChangeModeSelfRefToMut {\n \n \n #[cfg(cfail1)]\n-trait TraitChangeModeSelfOwnToMut {\n-    fn method(self);\n+trait TraitChangeModeSelfOwnToMut: Sized {\n+    fn method(self) {}\n }\n \n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-trait TraitChangeModeSelfOwnToMut {\n-    fn method(mut self);\n+trait TraitChangeModeSelfOwnToMut: Sized {\n+    fn method(mut self) {}\n }\n \n "}, {"sha": "d2a16ac750704de8f3bf49cea7cc6aed7e6db5fb", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps, vec![],\n+        &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {"}, {"sha": "ed127b017b6a92cdfe800aadd8a5e2e416942a28", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -67,12 +67,6 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n     let cfg = build_configuration(&sess, vec![]);\n     let control = CompileController::basic();\n-\n-    compile_input(&sess, &cstore,\n-            cfg,\n-            &Input::Str { name: anon_src(), input: code },\n-            &None,\n-            &Some(output),\n-            None,\n-            &control);\n+    let input = Input::Str { name: anon_src(), input: code };\n+    compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);\n }"}, {"sha": "a41b34f6a53d0a3e08e5c32a6077b80b00ec414a", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -31,10 +31,7 @@ use std::fmt;\n // Copied out of syntax::util::parser_testing\n \n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n-    new_parser_from_source_str(ps,\n-                               Vec::new(),\n-                               \"bogofile\".to_string(),\n-                               source_str)\n+    new_parser_from_source_str(ps, \"bogofile\".to_string(), source_str)\n }\n \n fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> PResult<'a, T> where"}, {"sha": "48919fe876a221cad38d87ba119f86eae212d934", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_noprelude_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,10 +15,10 @@\n #![plugin(proc_macro_plugin)]\n \n extern crate rustc_plugin;\n-extern crate proc_macro_plugin;\n+extern crate proc_macro_tokens;\n extern crate syntax;\n \n-use proc_macro_plugin::build::ident_eq;\n+use proc_macro_tokens::build::ident_eq;\n \n use syntax::ext::base::{ExtCtxt, MacResult};\n use syntax::ext::proc_macro_shim::build_block_emitter;"}, {"sha": "0ea4cec75cdda5ae6b726e59c7f4142664089921", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,10 +15,10 @@\n #![plugin(proc_macro_plugin)]\n \n extern crate rustc_plugin;\n-extern crate proc_macro_plugin;\n+extern crate proc_macro_tokens;\n extern crate syntax;\n \n-use proc_macro_plugin::prelude::*;\n+use proc_macro_tokens::prelude::*;\n \n use rustc_plugin::Registry;\n "}, {"sha": "169c96b438529166ebbdee1f3eef6d9e0dc800a9", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_prelude_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -15,11 +15,11 @@\n #![plugin(proc_macro_plugin)]\n \n extern crate rustc_plugin;\n-extern crate proc_macro_plugin;\n+extern crate proc_macro_tokens;\n extern crate syntax;\n \n use syntax::ext::proc_macro_shim::prelude::*;\n-use proc_macro_plugin::prelude::*;\n+use proc_macro_tokens::prelude::*;\n \n use rustc_plugin::Registry;\n "}, {"sha": "3bc4a40a39c99a144c1bafe11752527bd9708ef3", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -19,7 +19,7 @@ extern crate rustc_const_math;\n extern crate syntax;\n \n use rustc::mir::transform::{self, MirPass, MirSource};\n-use rustc::mir::repr::{Mir, Literal, Location};\n+use rustc::mir::{Mir, Literal, Location};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use rustc::middle::const_val::ConstVal;"}, {"sha": "15ec0ccae8fdd243cddb2c9f1f9116b246f1d5bd", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -60,7 +60,7 @@ fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResu\n // See Issue #15750\n fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n     // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg().clone(), tts.to_vec());\n+    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), tts.to_vec());\n     let expr = parser.parse_expr().unwrap();\n     MacEager::expr(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "9fce19f46f65c7a4bdfafa445ca69a40289f6ca3", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -10,11 +10,11 @@\n \n #![feature(plugin, plugin_registrar, rustc_private)]\n \n-extern crate proc_macro_plugin;\n+extern crate proc_macro_tokens;\n extern crate rustc_plugin;\n extern crate syntax;\n \n-use proc_macro_plugin::prelude::*;\n+use proc_macro_tokens::prelude::*;\n use rustc_plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::proc_macro_shim::prelude::*;"}, {"sha": "4a397621ceb53ebfc5bb31723a4eb8f9a5ee2077", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -47,7 +47,6 @@ impl<'a> CompilerCalls<'a> for TestCalls {\n     fn late_callback(&mut self,\n                      _: &getopts::Matches,\n                      _: &Session,\n-                     _: &ast::CrateConfig,\n                      _: &Input,\n                      _: &Option<PathBuf>,\n                      _: &Option<PathBuf>)"}, {"sha": "914da3f746773fe69d731c8ee2e24de1c426f960", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,8 +14,8 @@\n #![feature(rustc_private)]\n #![plugin(proc_macro_plugin)]\n \n-extern crate proc_macro_plugin;\n-use proc_macro_plugin::prelude::*;\n+extern crate proc_macro_tokens;\n+use proc_macro_tokens::prelude::*;\n \n extern crate syntax;\n use syntax::ast::Ident;"}, {"sha": "7c0c24163fe617a7486fe21cee25ff1206d171b0", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     let ps = syntax::parse::ParseSess::new();\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps, vec![],\n+        &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {"}, {"sha": "846b695c35b3d771ee9781cf5129f4b1e4a0996e", "filename": "src/test/run-pass/by-value-self-in-mut-slot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fby-value-self-in-mut-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fby-value-self-in-mut-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fby-value-self-in-mut-slot.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -14,7 +14,7 @@ struct X {\n }\n \n trait Changer {\n-    fn change(mut self) -> Self;\n+    fn change(self) -> Self;\n }\n \n impl Changer for X {"}, {"sha": "fec46c7e1f82d9eeffea15398ed755296fd26e8c", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![allow(dead_assignment)]\n-\n use std::mem::*;\n \n pub fn main() {\n@@ -20,3 +17,12 @@ pub fn main() {\n     assert_eq!(x, 2);\n     assert_eq!(y, 1);\n }\n+\n+#[allow(unused)]\n+fn f() {\n+    mod foo { pub use *; }\n+    mod bar { pub use ::*; }\n+\n+    foo::main();\n+    bar::main();\n+}"}, {"sha": "8516d344e1cdc41115c48335b24c017e712d972e", "filename": "src/test/run-pass/issue-22546.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fissue-22546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fissue-22546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22546.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -51,4 +51,10 @@ fn main() {\n     if let None::<u8> = Some(8) {\n         panic!();\n     }\n+    if let None::<u8> { .. } = Some(8) {\n+        panic!();\n+    }\n+    if let Option::None::<u8> { .. } = Some(8) {\n+        panic!();\n+    }\n }"}, {"sha": "b033ed5c802100f51c53096bbccdb43e5c00d84a", "filename": "src/test/run-pass/struct-path-associated-type.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -8,30 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S;\n+struct S<T, U = u16> {\n+    a: T,\n+    b: U,\n+}\n \n trait Tr {\n     type A;\n }\n-\n-impl Tr for S {\n-    type A = S;\n-}\n-\n-fn f<T: Tr>() {\n-    match S {\n-        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n-    }\n+impl Tr for u8 {\n+    type A = S<u8, u16>;\n }\n \n-fn g<T: Tr<A = S>>() {\n-    match S {\n-        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n+fn f<T: Tr<A = S<u8>>>() {\n+    let s = T::A { a: 0, b: 1 };\n+    match s {\n+        T::A { a, b } => {\n+            assert_eq!(a, 0);\n+            assert_eq!(b, 1);\n+        }\n     }\n }\n \n fn main() {\n-    match S {\n-        S::A {} => {} //~ ERROR ambiguous associated type\n-    }\n+    f::<u8>();\n }", "previous_filename": "src/test/compile-fail/struct-pat-associated-path.rs"}, {"sha": "c7a282c2a2fa02c289cfdf87028c4439ff57b45f", "filename": "src/test/run-pass/struct-path-self.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-path-self.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Add;\n+\n+struct S<T, U = u16> {\n+    a: T,\n+    b: U,\n+}\n+\n+trait Tr {\n+    fn f(&self) -> Self;\n+}\n+\n+impl<T: Default + Add<u8, Output = T>, U: Default> Tr for S<T, U> {\n+    fn f(&self) -> Self {\n+        let s = Self { a: Default::default(), b: Default::default() };\n+        match s {\n+            Self { a, b } => Self { a: a + 1, b: b }\n+        }\n+    }\n+}\n+\n+impl<T: Default, U: Default + Add<u16, Output = U>> S<T, U> {\n+    fn g(&self) -> Self {\n+        let s = Self { a: Default::default(), b: Default::default() };\n+        match s {\n+            Self { a, b } => Self { a: a, b: b + 1 }\n+        }\n+    }\n+}\n+\n+impl S<u8> {\n+    fn new() -> Self {\n+        Self { a: 0, b: 1 }\n+    }\n+}\n+\n+fn main() {\n+    let s0 = S::new();\n+    let s1 = s0.f();\n+    assert_eq!(s1.a, 1);\n+    assert_eq!(s1.b, 0);\n+    let s2 = s0.g();\n+    assert_eq!(s2.a, 0);\n+    assert_eq!(s2.b, 1);\n+}"}, {"sha": "323705f3f955f8117d75f985d9d2a9085aca4633", "filename": "src/test/run-pass/typeck-fn-to-unsafe-fn-ptr.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Ftypeck-fn-to-unsafe-fn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Ftypeck-fn-to-unsafe-fn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck-fn-to-unsafe-fn-ptr.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This tests reification from safe function to `unsafe fn` pointer\n+\n+fn do_nothing() -> () {}\n+\n+unsafe fn call_unsafe(func: unsafe fn() -> ()) -> () {\n+    func()\n+}\n+\n+pub fn main() {\n+    unsafe { call_unsafe(do_nothing); }\n+}"}, {"sha": "7910380abeef0db7c0204893a694239c960067e3", "filename": "src/test/run-pass/uniq-self-in-mut-slot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -17,7 +17,7 @@ struct X {\n }\n \n trait Changer {\n-    fn change(mut self: Box<Self>) -> Box<Self>;\n+    fn change(self: Box<Self>) -> Box<Self>;\n }\n \n impl Changer for X {"}, {"sha": "800186a926df612e881928bd447b49abba0db3c6", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -24,7 +24,7 @@ struct Test {\n const TEST_REPOS: &'static [Test] = &[Test {\n                                           name: \"cargo\",\n                                           repo: \"https://github.com/rust-lang/cargo\",\n-                                          sha: \"d3bad1ab29efae414e9b4c24534b2d02b3a59782\",\n+                                          sha: \"806e3c368a15f618244a3b4e918bf77f9c403fd0\",\n                                           lock: None,\n                                       },\n                                       Test {"}, {"sha": "ef93b0858b02f646068332f6c47fb521bb9e9a20", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -44,28 +44,27 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let filename = file.file_name().unwrap().to_string_lossy();\n         let extensions = [\".py\", \".sh\"];\n         if extensions.iter().any(|e| filename.ends_with(e)) {\n-            return\n+            return;\n         }\n \n         let metadata = t!(fs::symlink_metadata(&file), &file);\n         if metadata.mode() & 0o111 != 0 {\n             let rel_path = file.strip_prefix(path).unwrap();\n             let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n-            let ret_code = Command::new(\"git\")\n-                                        .arg(\"ls-files\")\n-                                        .arg(&git_friendly_path)\n-                                        .current_dir(path)\n-                                        .stdout(Stdio::null())\n-                                        .stderr(Stdio::null())\n-                                        .status()\n-                                        .unwrap_or_else(|e| {\n-                                            panic!(\"could not run git ls-files: {}\", e);\n-                                        });\n-            if ret_code.success() {\n+            let output = Command::new(\"git\")\n+                .arg(\"ls-files\")\n+                .arg(&git_friendly_path)\n+                .current_dir(path)\n+                .stderr(Stdio::null())\n+                .output()\n+                .unwrap_or_else(|e| {\n+                    panic!(\"could not run git ls-files: {}\", e);\n+                });\n+            let path_bytes = rel_path.as_os_str().as_bytes();\n+            if output.status.success() && output.stdout.starts_with(path_bytes) {\n                 println!(\"binary checked into source: {}\", file.display());\n                 *bad = true;\n             }\n         }\n     })\n }\n-"}, {"sha": "4ef07f7e4b896dd5fc6f28475b901845115b1605", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123d08b3d3901d5725af8303c1329b007089cde5/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=123d08b3d3901d5725af8303c1329b007089cde5", "patch": "@@ -18,27 +18,42 @@\n //! * Library features have at most one `since` value\n \n use std::collections::HashMap;\n+use std::fmt;\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::Path;\n \n-const STATUSES: &'static [&'static str] = &[\n-    \"Active\", \"Deprecated\", \"Removed\", \"Accepted\",\n-];\n+#[derive(PartialEq)]\n+enum Status {\n+    Stable,\n+    Unstable,\n+}\n+\n+impl fmt::Display for Status {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let as_str = match *self {\n+            Status::Stable => \"stable\",\n+            Status::Unstable => \"unstable\",\n+        };\n+        fmt::Display::fmt(as_str, f)\n+    }\n+}\n+\n \n struct Feature {\n     name: String,\n+    level: Status,\n     since: String,\n-    status: String,\n }\n \n struct LibFeature {\n-    level: String,\n+    level: Status,\n     since: String,\n }\n \n pub fn check(path: &Path, bad: &mut bool) {\n     let features = collect_lang_features(&path.join(\"libsyntax/feature_gate.rs\"));\n+    assert!(!features.is_empty());\n     let mut lib_features = HashMap::<String, LibFeature>::new();\n \n     let mut contents = String::new();\n@@ -48,7 +63,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let filename = file.file_name().unwrap().to_string_lossy();\n         if !filename.ends_with(\".rs\") || filename == \"features.rs\" ||\n            filename == \"diagnostic_list.rs\" {\n-            return\n+            return;\n         }\n \n         contents.truncate(0);\n@@ -60,24 +75,24 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 *bad = true;\n             };\n             let level = if line.contains(\"[unstable(\") {\n-                \"unstable\"\n+                Status::Unstable\n             } else if line.contains(\"[stable(\") {\n-                \"stable\"\n+                Status::Stable\n             } else {\n-                continue\n+                continue;\n             };\n             let feature_name = match find_attr_val(line, \"feature\") {\n                 Some(name) => name,\n                 None => {\n                     err(\"malformed stability attribute\");\n-                    continue\n+                    continue;\n                 }\n             };\n             let since = match find_attr_val(line, \"since\") {\n                 Some(name) => name,\n-                None if level == \"stable\" => {\n+                None if level == Status::Stable => {\n                     err(\"malformed stability attribute\");\n-                    continue\n+                    continue;\n                 }\n                 None => \"None\",\n             };\n@@ -92,27 +107,34 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 if s.since != since {\n                     err(\"different `since` than before\");\n                 }\n-                continue\n+                continue;\n             }\n-            lib_features.insert(feature_name.to_owned(), LibFeature {\n-                level: level.to_owned(),\n-                since: since.to_owned(),\n-            });\n+            lib_features.insert(feature_name.to_owned(),\n+                                LibFeature {\n+                                    level: level,\n+                                    since: since.to_owned(),\n+                                });\n         }\n     });\n \n     if *bad {\n-        return\n+        return;\n     }\n \n     let mut lines = Vec::new();\n     for feature in features {\n         lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           feature.name, \"lang\", feature.status, feature.since));\n+                           feature.name,\n+                           \"lang\",\n+                           feature.level,\n+                           feature.since));\n     }\n     for (name, feature) in lib_features {\n         lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           name, \"lib\", feature.level, feature.since));\n+                           name,\n+                           \"lib\",\n+                           feature.level,\n+                           feature.since));\n     }\n \n     lines.sort();\n@@ -122,39 +144,32 @@ pub fn check(path: &Path, bad: &mut bool) {\n }\n \n fn find_attr_val<'a>(line: &'a str, attr: &str) -> Option<&'a str> {\n-    line.find(attr).and_then(|i| {\n-        line[i..].find(\"\\\"\").map(|j| i + j + 1)\n-    }).and_then(|i| {\n-        line[i..].find(\"\\\"\").map(|j| (i, i + j))\n-    }).map(|(i, j)| {\n-        &line[i..j]\n-    })\n+    line.find(attr)\n+        .and_then(|i| line[i..].find('\"').map(|j| i + j + 1))\n+        .and_then(|i| line[i..].find('\"').map(|j| (i, i + j)))\n+        .map(|(i, j)| &line[i..j])\n }\n \n fn collect_lang_features(path: &Path) -> Vec<Feature> {\n     let mut contents = String::new();\n     t!(t!(File::open(path)).read_to_string(&mut contents));\n \n-    let mut features = Vec::new();\n-    for line in contents.lines().map(|l| l.trim()) {\n-        if !STATUSES.iter().any(|s| line.starts_with(&format!(\"({}\", s))) {\n-            continue\n-        }\n-        let mut parts = line.split(\",\");\n-        let status = match &parts.next().unwrap().trim().replace(\"(\", \"\")[..] {\n-            \"active\"   => \"unstable\",\n-            \"removed\"  => \"unstable\",\n-            \"accepted\" => \"stable\",\n-            s => panic!(\"unknown status: {}\", s),\n-        };\n-        let name = parts.next().unwrap().trim().to_owned();\n-        let since = parts.next().unwrap().trim().replace(\"\\\"\", \"\");\n-\n-        features.push(Feature {\n-            name: name,\n-            since: since,\n-            status: status.to_owned(),\n-        });\n-    }\n-    return features\n+    contents.lines()\n+        .filter_map(|line| {\n+            let mut parts = line.trim().split(\",\");\n+            let level = match parts.next().map(|l| l.trim().trim_left_matches('(')) {\n+                Some(\"active\") => Status::Unstable,\n+                Some(\"removed\") => Status::Unstable,\n+                Some(\"accepted\") => Status::Stable,\n+                _ => return None,\n+            };\n+            let name = parts.next().unwrap().trim();\n+            let since = parts.next().unwrap().trim().trim_matches('\"');\n+            Some(Feature {\n+                name: name.to_owned(),\n+                level: level,\n+                since: since.to_owned(),\n+            })\n+        })\n+        .collect()\n }"}]}