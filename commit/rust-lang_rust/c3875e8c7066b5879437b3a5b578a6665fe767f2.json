{"sha": "c3875e8c7066b5879437b3a5b578a6665fe767f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzODc1ZThjNzA2NmI1ODc5NDM3YjNhNWI1NzhhNjY2NWZlNzY3ZjI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-05-11T02:00:51Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-05-15T00:47:39Z"}, "message": "rustpkg: Implement URL-like package IDs\n\nThis patch implements package IDs like\ngithub.com/catamorphism/test-pkg.\n\nTo support such package IDs, I changed the PkgId struct to contain\na LocalPath and a RemotePath field, where the RemotePath reflects\nthe actual URL and the LocalPath reflects the file name of the cached\ncopy. Right now, the only difference is that the local path doesn't\ncontain dashes, but this will change when we implement #6407.\n\nAlso, PkgIds now have a short_name field -- though the short name\ncan be derived from the LocalPath, I thought it was cleaner not to\ncall option::get() wantonly.", "tree": {"sha": "9dd3f920694150f7eea627f82bc2cd8297c0eccd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dd3f920694150f7eea627f82bc2cd8297c0eccd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3875e8c7066b5879437b3a5b578a6665fe767f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3875e8c7066b5879437b3a5b578a6665fe767f2", "html_url": "https://github.com/rust-lang/rust/commit/c3875e8c7066b5879437b3a5b578a6665fe767f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3875e8c7066b5879437b3a5b578a6665fe767f2/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "url": "https://api.github.com/repos/rust-lang/rust/commits/c30414f980eb3e8010640f6c83a5ef6f8e6ab047", "html_url": "https://github.com/rust-lang/rust/commit/c30414f980eb3e8010640f6c83a5ef6f8e6ab047"}], "stats": {"total": 431, "additions": 223, "deletions": 208}, "files": [{"sha": "3cc2a5f3fb6ef6c7f94dc538309fb84d7b883530", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 59, "deletions": 48, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=c3875e8c7066b5879437b3a5b578a6665fe767f2", "patch": "@@ -10,12 +10,10 @@\n \n // rustpkg utilities having to do with paths and directories\n \n-use util::PkgId;\n+pub use util::{PkgId, RemotePath, LocalPath};\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use core::os::mkdir_recursive;\n-\n-#[deriving(Eq)]\n-pub enum OutputType { Main, Lib, Bench, Test }\n+pub use util::{normalize, OutputType, Main, Lib, Bench, Test};\n \n /// Returns the value of RUST_PATH, as a list\n /// of Paths. In general this should be read from the\n@@ -31,67 +29,73 @@ pub static u_rwx: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n /// succeeded.\n pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n \n-/// Replace all occurrences of '-' in the stem part of path with '_'\n-/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n-/// as the same name\n-pub fn normalize(p: ~Path) -> ~Path {\n-    match p.filestem() {\n-        None => p,\n-        Some(st) => {\n-            let replaced = str::replace(st, \"-\", \"_\");\n-            if replaced != st {\n-                ~p.with_filestem(replaced)\n-            }\n-            else {\n-                p\n-            }\n-        }\n-    }\n-}\n-\n // n.b. So far this only handles local workspaces\n // n.b. The next three functions ignore the package version right\n // now. Should fix that.\n \n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n-pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    let pkgpath = workspace.push(\"src\").push(pkgid.path.to_str());\n+pub fn workspace_contains_package_id(pkgid: PkgId, workspace: &Path) -> bool {\n+    let pkgpath = workspace.push(\"src\").push(pkgid.local_path.to_str());\n     os::path_is_dir(&pkgpath)\n }\n \n /// Return the directory for <pkgid>'s source files in <workspace>.\n /// Doesn't check that it exists.\n pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let result = workspace.push(\"src\");\n-    result.push(pkgid.path.to_str())\n+    result.push(pkgid.local_path.to_str())\n }\n \n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n-    result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n-    result = mk_output_path(Main, fmt!(\"%s-%s\", pkgid.path.to_str(), pkgid.version.to_str()),\n-                                       result);\n+    result = mk_output_path(Main, pkgid, &result);\n     debug!(\"built_executable_in_workspace: checking whether %s exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n+        // This is not an error, but it's worth logging it\n+        error!(fmt!(\"built_executable_in_workspace: %s does not exist\", result.to_str()));\n         None\n     }\n }\n \n-/// Figure out what the library name for <pkgid> in <workspace>'s build\n+/// Figure out what the test name for <pkgid> in <workspace>'s build\n+/// directory is, and if the file exists, return it.\n+pub fn built_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(pkgid, workspace, Test)\n+}\n+\n+/// Figure out what the test name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(pkgid, workspace, Bench)\n+}\n+\n+fn output_in_workspace(pkgid: PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n-    result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n-    result = mk_output_path(Lib, pkgid.path.to_str(), result);\n+    result = mk_output_path(what, pkgid, &result);\n+    debug!(\"output_in_workspace: checking whether %s exists\",\n+           result.to_str());\n+    if os::path_exists(&result) {\n+        Some(result)\n+    }\n+    else {\n+        error!(fmt!(\"output_in_workspace: %s does not exist\", result.to_str()));\n+        None\n+    }\n+}\n+\n+/// Figure out what the library name for <pkgid> in <workspace>'s build\n+/// directory is, and if the file exists, return it.\n+pub fn built_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+    let result = mk_output_path(Lib, pkgid, &workspace.push(\"build\"));\n     debug!(\"built_library_in_workspace: checking whether %s exists\",\n            result.to_str());\n \n@@ -100,8 +104,7 @@ pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Pat\n     let dir_contents = os::list_dir(&result.pop());\n     debug!(\"dir has %? entries\", dir_contents.len());\n \n-    // n.b. This code assumes the pkgid's path only has one element\n-    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, pkgid.path.to_str());\n+    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, pkgid.short_name);\n     let lib_filetype = fmt!(\"%s%s\", pkgid.version.to_str(), os::consts::DLL_SUFFIX);\n \n     debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n@@ -173,13 +176,15 @@ pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n /// Returns the test executable that would be installed for <pkgid>\n /// in <workspace>\n-pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n+/// note that we *don't* install test executables, so this is just for unit testing\n+pub fn target_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Test)\n }\n \n /// Returns the bench executable that would be installed for <pkgid>\n /// in <workspace>\n-pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n+/// note that we *don't* install bench executables, so this is just for unit testing\n+pub fn target_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Bench)\n }\n \n@@ -188,17 +193,14 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     use conditions::bad_path::cond;\n \n     let (subdir, create_dir) = match what {\n-        Main => (\"bin\", true), Lib => (\"lib\", true), Test | Bench => (\"build\", false)\n+        Lib => \"lib\", Main | Test | Bench => \"bin\"\n     };\n     let result = workspace.push(subdir);\n-    if create_dir {\n-        if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n-            cond.raise((copy result,\n-                        fmt!(\"I couldn't create the %s dir\", subdir)));\n-        }\n+    debug!(\"target_file_in_workspace: %s %?\", result.to_str(), create_dir);\n+    if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n+        cond.raise((result, fmt!(\"I couldn't create the %s dir\", subdir)));\n     }\n-    mk_output_path(what, pkgid.path.to_str(), result)\n-\n+    mk_output_path(what, pkgid, &result)\n }\n \n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n@@ -209,7 +211,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let mut result = workspace.push(\"build\");\n     // n.b. Should actually use a target-specific\n     // subdirectory of build/\n-    result = result.push(normalize(~copy pkgid.path).to_str());\n+    result = result.push_rel(&*pkgid.local_path);\n     if os::path_exists(&result) || os::mkdir_recursive(&result, u_rwx) {\n         result\n     }\n@@ -220,8 +222,15 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n-pub fn mk_output_path(what: OutputType, short_name: ~str, dir: Path) -> Path {\n-    match what {\n+pub fn mk_output_path(what: OutputType, pkg_id: PkgId, workspace: &Path) -> Path {\n+    let short_name = pkg_id.short_name_with_version();\n+    // Not local_path.dir_path()! For package foo/bar/blat/, we want\n+    // the executable blat-0.5 to live under blat/\n+    let dir = workspace.push_rel(&*pkg_id.local_path);\n+    debug!(\"mk_output_path: short_name = %s, path = %s\",\n+           short_name, dir.to_str());\n+    let output_path = match what {\n+        // this code is duplicated from elsewhere; fix this\n         Lib => dir.push(os::dll_filename(short_name)),\n         _ => dir.push(fmt!(\"%s%s%s\", short_name,\n                            match what {\n@@ -230,5 +239,7 @@ pub fn mk_output_path(what: OutputType, short_name: ~str, dir: Path) -> Path {\n                                _     => \"\"\n                            }\n                            os::EXE_SUFFIX))\n-    }\n+    };\n+    debug!(\"mk_output_path: returning %s\", output_path.to_str());\n+    output_path\n }"}, {"sha": "1f72b2434541715cda1bbf22594ea56de1bb3cfc", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 54, "deletions": 106, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=c3875e8c7066b5879437b3a5b578a6665fe767f2", "patch": "@@ -30,12 +30,10 @@ use rustc::metadata::filesearch;\n use std::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n-use path_util::normalize;\n-use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace};\n+use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace, u_rwx};\n use path_util::{built_executable_in_workspace, built_library_in_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use workspace::pkg_parent_workspaces;\n-use rustc::driver::session::{lib_crate, bin_crate, crate_type};\n use context::Ctx;\n \n mod conditions;\n@@ -269,7 +267,7 @@ impl Ctx {\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n \n         // Create the package source\n-        let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, pkgid);\n+        let mut src = PkgSrc::new(workspace, &build_dir, &pkgid);\n         debug!(\"Package src = %?\", src);\n \n         // Is there custom build logic? If so, use it\n@@ -337,111 +335,38 @@ impl Ctx {\n         // Should use RUST_PATH in the future.\n         // Also should use workcache to not build if not necessary.\n         self.build(workspace, id);\n+        debug!(\"install: workspace = %s, id = %s\", workspace.to_str(),\n+               id.to_str());\n \n         // Now copy stuff into the install dirs\n         let maybe_executable = built_executable_in_workspace(id, workspace);\n         let maybe_library = built_library_in_workspace(id, workspace);\n         let target_exec = target_executable_in_workspace(id, workspace);\n         let target_lib = target_library_in_workspace(id, workspace);\n \n+        debug!(\"target_exec = %s target_lib = %s \\\n+                maybe_executable = %? maybe_library = %?\",\n+               target_exec.to_str(), target_lib.to_str(),\n+               maybe_executable, maybe_library);\n+\n         for maybe_executable.each |exec| {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n-            if !os::copy_file(exec, &target_exec) {\n-                cond.raise((copy *exec, copy target_exec));\n+            if !(os::mkdir_recursive(&target_exec.dir_path(), u_rwx) &&\n+                 os::copy_file(exec, &target_exec)) {\n+                cond.raise((*exec, target_exec));\n             }\n         }\n         for maybe_library.each |lib| {\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n-            if !os::copy_file(lib, &target_lib) {\n-                cond.raise((copy *lib, copy target_lib));\n-            }\n-        }\n-    }\n-\n-    fn fetch(&self, _dir: &Path, _url: ~str, _target: Option<~str>)  {\n-        // stub\n-        fail!(\"fetch not yet implemented\");\n-    }\n-\n-    fn fetch_curl(&self, dir: &Path, url: ~str)  {\n-        util::note(fmt!(\"fetching from %s using curl\", url));\n-\n-        let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n-\n-        if run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", tar.to_str(),\n-                                          url]).status != 0 {\n-            util::error(~\"fetching failed: downloading using curl failed\");\n-\n-            fail!();\n-        }\n-\n-        if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                                         ~\"-C\", dir.to_str(), ~\"-f\",\n-                                         tar.to_str()]).status != 0 {\n-            util::error(~\"fetching failed: extracting using tar failed\" +\n-                        ~\"(is it a valid tar archive?)\");\n-\n-           fail!();\n-        }\n-    }\n-\n-    fn fetch_git(&self, dir: &Path, url: ~str, mut target: Option<~str>)  {\n-        util::note(fmt!(\"fetching from %s using git\", url));\n-\n-        // Git can't clone into a non-empty directory\n-        util::remove_dir_r(dir);\n-\n-        if run::program_output(~\"git\", ~[~\"clone\", url,\n-                                         dir.to_str()]).status != 0 {\n-            util::error(~\"fetching failed: can't clone repository\");\n-            fail!();\n-        }\n-\n-        if !target.is_none() {\n-            let mut success = true;\n-\n-            do util::temp_change_dir(dir) {\n-                success = run::program_output(~\"git\",\n-                                              ~[~\"checkout\",\n-                                                target.swap_unwrap()]).status != 0\n-            }\n-\n-            if !success {\n-                util::error(~\"fetching failed: can't checkout target\");\n-                fail!();\n+            if !(os::mkdir_recursive(&target_lib.dir_path(), u_rwx) &&\n+                 os::copy_file(lib, &target_lib)) {\n+                cond.raise((*lib, target_lib));\n             }\n         }\n     }\n \n-    fn prefer(&self, id: ~str, vers: Option<~str>)  {\n-        let package = match util::get_pkg(id, vers) {\n-            result::Ok(package) => package,\n-            result::Err(err) => {\n-                util::error(err);\n-                fail!(); // Condition?\n-            }\n-        };\n-        let name = package.id.path.to_str(); // ???\n-\n-        util::note(fmt!(\"preferring %s v%s\", name, package.id.version.to_str()));\n-\n-        let bin_dir = util::root().push(~\"bin\");\n-\n-        for package.bins.each |&bin| {\n-            let path = Path(bin);\n-            let mut name = None;\n-            for str::each_split_char(path.file_path().to_str(), '-') |s| {\n-                name = Some(s.to_owned());\n-                break;\n-            }\n-            let out = bin_dir.push(name.unwrap());\n-\n-            util::link_exe(&path, &out);\n-            util::note(fmt!(\"linked %s\", out.to_str()));\n-        }\n-\n-        util::note(fmt!(\"preferred %s v%s\", name, package.id.version.to_str()));\n+    fn prefer(&self, _id: ~str, _vers: Option<~str>)  {\n+        fail!(~\"prefer not yet implemented\");\n     }\n \n     fn test(&self)  {\n@@ -641,17 +566,19 @@ impl PkgSrc {\n     fn check_dir(&self) -> Path {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(),\n+        debug!(\"Pushing onto root: %s | %s\", self.id.to_str(),\n                self.root.to_str());\n \n-        let dir = self.root.push_rel(&self.id.path).normalize();\n+        let mut dir = self.root.push(\"src\");\n+        dir = dir.push(self.id.to_str()); // ?? Should this use the version number?\n \n         debug!(\"Checking dir: %s\", dir.to_str());\n \n-        // tjc: Rather than erroring out, need to try downloading the\n-        // contents of the path to a local directory (#5679)\n         if !os::path_exists(&dir) {\n-            cond.raise((copy self.id, ~\"missing package dir\"));\n+            if !self.fetch_git() {\n+                cond.raise((self.id, ~\"supplied path for package dir does not \\\n+                    exist, and couldn't interpret it as a URL fragment\"));\n+            }\n         }\n \n         if !os::path_is_dir(&dir) {\n@@ -662,6 +589,28 @@ impl PkgSrc {\n         dir\n     }\n \n+    /// Try interpreting self's package id as a remote package, and try\n+    /// fetching it and caching it in a local directory. If that didn't\n+    /// work, return false.\n+    /// (right now we only support git)\n+    fn fetch_git(&self) -> bool {\n+\n+        let mut local = self.root.push(\"src\");\n+        local = local.push(self.id.to_str());\n+        // Git can't clone into a non-empty directory\n+        util::remove_dir_r(&local);\n+\n+        let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n+        util::note(fmt!(\"git clone %s %s\", url, local.to_str()));\n+\n+        if run::program_output(~\"git\", ~[~\"clone\", url, local.to_str()]).status != 0 {\n+            util::note(fmt!(\"fetching %s failed: can't clone repository\", url));\n+            return false;\n+        }\n+        true\n+    }\n+\n+\n     // If a file named \"pkg.rs\" in the current directory exists,\n     // return the path for it. Otherwise, None\n     fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n@@ -680,7 +629,7 @@ impl PkgSrc {\n     /// Requires that dashes in p have already been normalized to\n     /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = normalize(~copy self.id.path).filestem();\n+        let self_id = self.id.local_path.filestem();\n         if self_id == p.filestem() {\n             return true;\n         }\n@@ -715,7 +664,7 @@ impl PkgSrc {\n \n         let dir = self.check_dir();\n         let prefix = dir.components.len();\n-        debug!(\"Matching against %?\", self.id.path.filestem());\n+        debug!(\"Matching against %?\", self.id.local_path.filestem());\n         for os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => push_crate(&mut self.libs,\n@@ -752,8 +701,7 @@ impl PkgSrc {\n                     src_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n-                    test: bool, crate_type: crate_type) {\n-\n+                    what: OutputType) {\n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n@@ -763,7 +711,7 @@ impl PkgSrc {\n                                      dst_dir,\n                                      crate.flags,\n                                      crate.cfgs + cfgs,\n-                                     false, test, crate_type);\n+                                     false, what);\n             if !result {\n                 build_err::cond.raise(fmt!(\"build failure on %s\",\n                                            path.to_str()));\n@@ -776,12 +724,12 @@ impl PkgSrc {\n     fn build(&self, dst_dir: &Path, cfgs: ~[~str], maybe_sysroot: Option<@Path>) {\n         let dir = self.check_dir();\n         debug!(\"Building libs\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.libs, cfgs, false, lib_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.mains, cfgs, false, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.tests, cfgs, true, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.benchs, cfgs, true, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.benchs, cfgs, Bench);\n     }\n }"}, {"sha": "6379dd9b3407b85d37e28236a1c95154f08cbe18", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=c3875e8c7066b5879437b3a5b578a6665fe767f2", "patch": "@@ -17,7 +17,8 @@ use std::tempfile::mkdtemp;\n use util::{PkgId, default_version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n-               make_dir_rwx, u_rwx};\n+               make_dir_rwx, u_rwx, RemotePath, LocalPath, normalize,\n+               built_bench_in_workspace, built_test_in_workspace};\n use core::os::mkdir_recursive;\n \n fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n@@ -29,15 +30,22 @@ fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n }\n \n fn fake_pkg() -> PkgId {\n+    let sn = ~\"bogus\";\n+    let remote = RemotePath(Path(sn));\n     PkgId {\n-        path: Path(~\"bogus\"),\n+        local_path: normalize(remote),\n+        remote_path: remote,\n+        short_name: sn,\n         version: default_version()\n     }\n }\n \n fn remote_pkg() -> PkgId {\n+    let remote = RemotePath(Path(~\"github.com/catamorphism/test-pkg\"));\n     PkgId {\n-        path: Path(~\"github.com/catamorphism/test-pkg\"),\n+        local_path: normalize(remote),\n+        remote_path: remote,\n+        short_name: ~\"test_pkg\",\n         version: default_version()\n     }\n }\n@@ -49,9 +57,10 @@ fn writeFile(file_path: &Path, contents: ~str) {\n     out.write_line(contents);\n }\n \n-fn mk_temp_workspace(short_name: &Path) -> Path {\n+fn mk_temp_workspace(short_name: &LocalPath) -> Path {\n     let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n-    let package_dir = workspace.push(~\"src\").push_rel(short_name);\n+    // Ugh, including version number\n+    let package_dir = workspace.push(~\"src\").push(fmt!(\"%s-0-1\", short_name.to_str()));\n     assert!(mkdir_recursive(&package_dir, u_rwx));\n     // Create main, lib, test, and bench files\n     writeFile(&package_dir.push(~\"main.rs\"),\n@@ -104,7 +113,7 @@ fn test_install_valid() {\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path);\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, &temp_pkg_id);\n     // Check that all files exist\n@@ -146,27 +155,32 @@ fn test_install_invalid() {\n }\n \n #[test]\n-#[ignore(reason = \"install from URL-fragment not yet implemented\")]\n fn test_install_url() {\n+    let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = remote_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n     // should have test, bench, lib, and main\n-    ctxt.install(&temp_workspace, &temp_pkg_id);\n+    ctxt.install(&workspace, temp_pkg_id);\n     // Check that all files exist\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n+    let exec = target_executable_in_workspace(temp_pkg_id, &workspace);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let lib = target_library_in_workspace(&temp_pkg_id, &temp_workspace);\n+    let lib = target_library_in_workspace(temp_pkg_id, &workspace);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n+    let built_test = built_test_in_workspace(temp_pkg_id, &workspace).expect(~\"test_install_url\");\n+    assert!(os::path_exists(&built_test));\n+    let built_bench = built_bench_in_workspace(temp_pkg_id, &workspace).expect(~\"test_install_url\");\n+    assert!(os::path_exists(&built_bench));\n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n-    let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n+    let test = target_test_in_workspace(temp_pkg_id, &workspace);\n+    assert!(!os::path_exists(&test));\n+    debug!(\"test = %s\", test.to_str());\n+    let bench = target_bench_in_workspace(temp_pkg_id, &workspace);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }"}, {"sha": "ca9596afbf82bb46dcd5a412cd58f6456fb70a5f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 78, "deletions": 37, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=c3875e8c7066b5879437b3a5b578a6665fe767f2", "patch": "@@ -13,7 +13,6 @@ use core::cmp::Ord;\n use core::hash::Streaming;\n use core::rt::io::Writer;\n use rustc::driver::{driver, session};\n-use rustc::driver::session::{lib_crate, unknown_crate};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n use std::semver;\n@@ -26,7 +25,7 @@ use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::ast::{meta_name_value, meta_list, attribute};\n use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n-use rustc::driver::session::{lib_crate, unknown_crate, crate_type};\n+use rustc::driver::session::{lib_crate, bin_crate};\n \n static Commands: &'static [&'static str] =\n     &[\"build\", \"clean\", \"do\", \"info\", \"install\", \"prefer\", \"test\", \"uninstall\",\n@@ -83,14 +82,28 @@ impl ToStr for Version {\n     }\n }\n \n+#[deriving(Eq)]\n+pub enum OutputType { Main, Lib, Bench, Test }\n+\n /// Placeholder\n pub fn default_version() -> Version { ExactRevision(0.1) }\n \n-// Path-fragment identifier of a package such as\n-// 'github.com/graydon/test'; path must be a relative\n-// path with >=1 component.\n+/// Path-fragment identifier of a package such as\n+/// 'github.com/graydon/test'; path must be a relative\n+/// path with >=1 component.\n pub struct PkgId {\n-    path: Path,\n+    /// Remote path: for example, github.com/mozilla/quux-whatever\n+    remote_path: RemotePath,\n+    /// Local path: for example, /home/quux/github.com/mozilla/quux_whatever\n+    /// Note that '-' normalizes to '_' when mapping a remote path\n+    /// onto a local path\n+    /// Also, this will change when we implement #6407, though we'll still\n+    /// need to keep track of separate local and remote paths\n+    local_path: LocalPath,\n+    /// Short name. This is the local path's filestem, but we store it\n+    /// redundantly so as to not call get() everywhere (filestem() returns an\n+    /// option)\n+    short_name: ~str,\n     version: Version\n }\n \n@@ -105,24 +118,31 @@ pub impl PkgId {\n         if p.components.len() < 1 {\n             return cond.raise((p, ~\"0-length pkgid\"));\n         }\n+        let remote_path = RemotePath(p);\n+        let local_path = normalize(remote_path);\n         PkgId {\n-            path: p,\n+            local_path: local_path,\n+            remote_path: remote_path,\n+            short_name: local_path.filestem().expect(fmt!(\"Strange path! %s\", s)),\n             version: default_version()\n         }\n     }\n \n     fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.path.to_str(),\n-             hash(self.path.to_str() + self.version.to_str()),\n+        fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n+             hash(self.remote_path.to_str() + self.version.to_str()),\n              self.version.to_str())\n     }\n \n+    fn short_name_with_version(&self) -> ~str {\n+        fmt!(\"%s-%s\", self.short_name, self.version.to_str())\n+    }\n }\n \n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.path.to_str(),\n+        fmt!(\"%s-%s\", self.local_path.to_str(),\n              // Replace dots with -s in the version\n              // this is because otherwise rustc will think\n              // that foo-0.1 has .1 as its extension\n@@ -444,31 +464,26 @@ pub fn compile_input(sysroot: Option<@Path>,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n-                     test: bool,\n-                     crate_type: session::crate_type) -> bool {\n+                     what: OutputType) -> bool {\n \n-    // Want just the directory component here\n-    let pkg_filename = pkg_id.path.filename().expect(~\"Weird pkg id\");\n-    let short_name = fmt!(\"%s-%s\", pkg_filename, pkg_id.version.to_str());\n+    let short_name = pkg_id.short_name_with_version();\n \n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n-    debug!(\"compile_input: %s / %?\", in_file.to_str(), crate_type);\n+    debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let binary = @copy os::args()[0];\n-    let building_library = match crate_type {\n-        lib_crate | unknown_crate => true,\n-        _ => false\n-    };\n+    let binary = os::args()[0];\n+    let building_library = what == Lib;\n \n     let out_file = if building_library {\n         out_dir.push(os::dll_filename(short_name))\n     }\n     else {\n-        out_dir.push(short_name + if test { ~\"test\" } else { ~\"\" }\n-                     + os::EXE_SUFFIX)\n+        out_dir.push(short_name + match what {\n+            Test => ~\"test\", Bench => ~\"bench\", Main | Lib => ~\"\"\n+        } + os::EXE_SUFFIX)\n     };\n \n     debug!(\"compiling %s into %s\",\n@@ -478,18 +493,24 @@ pub fn compile_input(sysroot: Option<@Path>,\n     debug!(\"cfgs: %s\", str::connect(cfgs, ~\" \"));\n     debug!(\"compile_input's sysroot = %?\", sysroot);\n \n+    let crate_type = match what {\n+        Lib => lib_crate,\n+        Test | Bench | Main => bin_crate\n+    };\n     let matches = getopts(~[~\"-Z\", ~\"time-passes\"]\n-                          + if building_library { ~[~\"--lib\"] }\n-                            else if test { ~[~\"--test\"] }\n-                            // bench?\n-                            else { ~[] }\n+                          + match what {\n+                              Lib => ~[~\"--lib\"],\n+                              // --test compiles both #[test] and #[bench] fns\n+                              Test | Bench => ~[~\"--test\"],\n+                              Main => ~[]\n+                          }\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n                           driver::optgroups()).get();\n     let mut options = session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n-        test: test,\n+        test: what == Test || what == Bench,\n         maybe_sysroot: sysroot,\n         addl_lib_search_paths: ~[copy *out_dir],\n         // output_type should be conditional\n@@ -549,13 +570,11 @@ pub fn compile_crate_from_input(input: &driver::input,\n             debug!(\"How many attrs? %?\", attr::find_linkage_metas(crate.node.attrs).len());\n \n             if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n-                crate_to_use = add_attrs(copy *crate,\n-                    ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n-                                                  // change PkgId to have a <shortname> field?\n+                crate_to_use = add_attrs(*crate, ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n                     ~[@dummy_spanned(meta_name_value(@~\"name\",\n-                                                    mk_string_lit(@pkg_id.path.filestem().get()))),\n+                                         mk_string_lit(@pkg_id.short_name))),\n                       @dummy_spanned(meta_name_value(@~\"vers\",\n-                                                    mk_string_lit(@pkg_id.version.to_str())))])))]);\n+                                         mk_string_lit(@pkg_id.version.to_str())))])))]);\n             }\n \n             driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate_to_use));\n@@ -586,17 +605,35 @@ fn add_attrs(mut c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n                      crate: &Path, dir: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n-                     test: bool, crate_type: crate_type) -> bool {\n+                     what: OutputType) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for flags.each |&fl| {\n         debug!(\"+++ %s\", fl);\n     }\n-    compile_input(sysroot, pkg_id,\n-                  crate, dir, flags, cfgs, opt, test, crate_type)\n+    compile_input(sysroot, pkg_id, crate, dir, flags, cfgs, opt, what)\n+}\n+\n+// normalize should be the only way to construct a LocalPath\n+// (though this isn't enforced)\n+/// Replace all occurrences of '-' in the stem part of path with '_'\n+/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n+/// as the same name\n+pub fn normalize(p: RemotePath) -> LocalPath {\n+    match p.filestem() {\n+        None => LocalPath(*p),\n+        Some(st) => {\n+            let replaced = str::replace(st, \"-\", \"_\");\n+            if replaced != st {\n+                LocalPath(p.with_filestem(replaced))\n+            }\n+            else {\n+                LocalPath(*p)\n+            }\n+        }\n+    }\n }\n \n-\n #[cfg(windows)]\n pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n     /* FIXME (#1768): Investigate how to do this on win32\n@@ -628,6 +665,10 @@ pub fn mk_string_lit(s: @~str) -> ast::lit {\n     }\n }\n \n+/// Wrappers to prevent local and remote paths from getting confused\n+pub struct RemotePath (Path);\n+pub struct LocalPath (Path);\n+\n #[cfg(test)]\n mod test {\n     use super::{is_cmd, parse_name};"}, {"sha": "cb9f735bce8d4cd8a4aec215b65e6d5969fe34a4", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3875e8c7066b5879437b3a5b578a6665fe767f2/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=c3875e8c7066b5879437b3a5b578a6665fe767f2", "patch": "@@ -21,9 +21,10 @@ pub fn pkg_parent_workspaces(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool\n         workspace_contains_package_id(pkgid, ws));\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n-        fail!(\"Package %s not found in any of the following workspaces: %s\",\n-              pkgid.path.to_str(),\n-              rust_path().to_str());\n+        fail!(\"Package %s not found in any of \\\n+                    the following workspaces: %s\",\n+                   pkgid.remote_path.to_str(),\n+                   rust_path().to_str());\n     }\n     for workspaces.each |ws| {\n         if action(ws) {"}, {"sha": "218ab86721eefd7b7e97fa6d9f95a80a1fa8686c", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=c3875e8c7066b5879437b3a5b578a6665fe767f2", "patch": "@@ -1 +1 @@\n-Subproject commit 97ac7c087a0caf6b0f611b80e14f7fe3cb18bb27\n+Subproject commit 218ab86721eefd7b7e97fa6d9f95a80a1fa8686c"}]}