{"sha": "dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMzQxNjI0NTA3OTdmNTc1NmNlMmI0NGYxYTNmZTczZDhlMmRjZTQ=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-01T14:26:30Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-01T14:26:30Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer", "tree": {"sha": "0883abc2d87f8b9704b49f5662da04b73ffedbf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0883abc2d87f8b9704b49f5662da04b73ffedbf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "html_url": "https://github.com/rust-lang/rust/commit/dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbe22640b8d52354c3de3e126c9fcda5b1b174fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe22640b8d52354c3de3e126c9fcda5b1b174fd", "html_url": "https://github.com/rust-lang/rust/commit/bbe22640b8d52354c3de3e126c9fcda5b1b174fd"}, {"sha": "a5f2b16366f027ad60c58266a66eb7fbdcbda9f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5f2b16366f027ad60c58266a66eb7fbdcbda9f9", "html_url": "https://github.com/rust-lang/rust/commit/a5f2b16366f027ad60c58266a66eb7fbdcbda9f9"}], "stats": {"total": 2520, "additions": 1928, "deletions": 592}, "files": [{"sha": "3f52f31f805d85989f947f32fb1d35a9ef713e34", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -39,7 +39,6 @@ jobs:\n       with:\n         toolchain: stable\n         profile: minimal\n-        target: x86_64-unknown-linux-musl\n         override: true\n \n     - name: Install Nodejs"}, {"sha": "6a2fff906510d2bb89b9e1f45235e1c224604db6", "filename": ".vscode/launch.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Flaunch.json?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -41,7 +41,7 @@\n       \"outFiles\": [\n         \"${workspaceFolder}/editors/code/out/**/*.js\"\n       ],\n-      \"preLaunchTask\": \"Build Extension\",\n+      \"preLaunchTask\": \"Build Server and Extension\",\n       \"skipFiles\": [\n         \"<node_internals>/**/*.js\"\n       ],\n@@ -62,7 +62,7 @@\n       \"outFiles\": [\n         \"${workspaceFolder}/editors/code/out/**/*.js\"\n       ],\n-      \"preLaunchTask\": \"Build Extension\",\n+      \"preLaunchTask\": \"Build Server (Release) and Extension\",\n       \"skipFiles\": [\n         \"<node_internals>/**/*.js\"\n       ],"}, {"sha": "0969ce89a107ffcd711d086754d13c25edeaeffa", "filename": ".vscode/tasks.json", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/.vscode%2Ftasks.json", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/.vscode%2Ftasks.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Ftasks.json?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -4,7 +4,7 @@\n   \"version\": \"2.0.0\",\n   \"tasks\": [\n     {\n-      \"label\": \"Build Extension\",\n+      \"label\": \"Build Extension in Background\",\n       \"group\": \"build\",\n       \"type\": \"npm\",\n       \"script\": \"watch\",\n@@ -15,12 +15,41 @@\n       },\n       \"isBackground\": true,\n     },\n+    {\n+      \"label\": \"Build Extension\",\n+      \"group\": \"build\",\n+      \"type\": \"npm\",\n+      \"script\": \"build\",\n+      \"path\": \"editors/code/\",\n+      \"problemMatcher\": {\n+        \"base\": \"$tsc\",\n+        \"fileLocation\": [\"relative\", \"${workspaceFolder}/editors/code/\"]\n+      },\n+    },\n     {\n       \"label\": \"Build Server\",\n       \"group\": \"build\",\n       \"type\": \"shell\",\n       \"command\": \"cargo build --package rust-analyzer\",\n       \"problemMatcher\": \"$rustc\"\n     },\n+    {\n+      \"label\": \"Build Server (Release)\",\n+      \"group\": \"build\",\n+      \"type\": \"shell\",\n+      \"command\": \"cargo build --release --package rust-analyzer\",\n+      \"problemMatcher\": \"$rustc\"\n+    },\n+\n+    {\n+      \"label\": \"Build Server and Extension\",\n+      \"dependsOn\": [\"Build Server\", \"Build Extension\"],\n+      \"problemMatcher\": \"$rustc\"\n+    },\n+    {\n+      \"label\": \"Build Server (Release) and Extension\",\n+      \"dependsOn\": [\"Build Server (Release)\", \"Build Extension\"],\n+      \"problemMatcher\": \"$rustc\"\n+    }\n   ]\n }"}, {"sha": "522ecf2ee87ce5aab38911f48c6e8e3e8ff1f6e2", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -68,9 +68,9 @@ dependencies = [\n \n [[package]]\n name = \"base64\"\n-version = \"0.11.0\"\n+version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b41b7ea54a0c9d92199de89e20e58d49f02f8e699814ef3fdf266f6f748d15c7\"\n+checksum = \"7d5ca2cd0adc3f48f9e9ea5a6bbdf9ccc0bfade884847e484d452414c7ccffb3\"\n \n [[package]]\n name = \"bitflags\"\n@@ -645,9 +645,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.73.0\"\n+version = \"0.74.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93d0cf64ea141b43d9e055f6b9df13f0bce32b103d84237509ce0a571ab9b159\"\n+checksum = \"820f746e5716ab9a2d664794636188bd003023b72e55404ee27105dc22869922\"\n dependencies = [\n  \"base64\",\n  \"bitflags\",\n@@ -1193,9 +1193,9 @@ dependencies = [\n \n [[package]]\n name = \"ra_vfs\"\n-version = \"0.5.3\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"58a265769d5e5655345a9fcbd870a1a7c3658558c0d8efaed79e0669358f46b8\"\n+checksum = \"fcaa5615f420134aea7667253db101d03a5c5f300eac607872dc2a36407b2ac9\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\","}, {"sha": "49deb670175c0c6e213c6a18b262718c08fd8cf1", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,11 +1,12 @@\n+use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n     TextSize,\n };\n use stdx::format_to;\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ra_ide_db::RootDatabase;\n+use crate::{utils::FamousDefs, Assist, AssistCtx, AssistId};\n+use test_utils::tested_by;\n \n // Assist add_from_impl_for_enum\n //\n@@ -41,7 +42,8 @@ pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n         _ => return None,\n     };\n \n-    if already_has_from_impl(ctx.sema, &variant) {\n+    if existing_from_impl(ctx.sema, &variant).is_some() {\n+        tested_by!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n@@ -70,41 +72,33 @@ impl From<{0}> for {1} {{\n     )\n }\n \n-fn already_has_from_impl(\n+fn existing_from_impl(\n     sema: &'_ hir::Semantics<'_, RootDatabase>,\n     variant: &ast::EnumVariant,\n-) -> bool {\n-    let scope = sema.scope(&variant.syntax());\n+) -> Option<()> {\n+    let variant = sema.to_def(variant)?;\n+    let enum_ = variant.parent_enum(sema.db);\n+    let krate = enum_.module(sema.db).krate();\n \n-    let from_path = ast::make::path_from_text(\"From\");\n-    let from_hir_path = match hir::Path::from_ast(from_path) {\n-        Some(p) => p,\n-        None => return false,\n-    };\n-    let from_trait = match scope.resolve_hir_path(&from_hir_path) {\n-        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(t))) => t,\n-        _ => return false,\n-    };\n+    let from_trait = FamousDefs(sema, krate).core_convert_From()?;\n \n-    let e: hir::Enum = match sema.to_def(&variant.parent_enum()) {\n-        Some(e) => e,\n-        None => return false,\n-    };\n-    let e_ty = e.ty(sema.db);\n+    let enum_type = enum_.ty(sema.db);\n \n-    let hir_enum_var: hir::EnumVariant = match sema.to_def(variant) {\n-        Some(ev) => ev,\n-        None => return false,\n-    };\n-    let var_ty = hir_enum_var.fields(sema.db)[0].signature_ty(sema.db);\n+    let wrapped_type = variant.fields(sema.db).get(0)?.signature_ty(sema.db);\n \n-    e_ty.impls_trait(sema.db, from_trait, &[var_ty])\n+    if enum_type.impls_trait(sema.db, from_trait, &[wrapped_type]) {\n+        Some(())\n+    } else {\n+        None\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n     use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use test_utils::covers;\n \n     #[test]\n     fn test_add_from_impl_for_enum() {\n@@ -136,36 +130,40 @@ mod tests {\n         );\n     }\n \n+    fn check_not_applicable(ra_fixture: &str) {\n+        let fixture =\n+            format!(\"//- main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        check_assist_not_applicable(add_from_impl_for_enum, &fixture)\n+    }\n+\n     #[test]\n     fn test_add_from_impl_no_element() {\n-        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One }\");\n+        check_not_applicable(\"enum A { <|>One }\");\n     }\n \n     #[test]\n     fn test_add_from_impl_more_than_one_element_in_tuple() {\n-        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One(u32, String) }\");\n+        check_not_applicable(\"enum A { <|>One(u32, String) }\");\n     }\n \n     #[test]\n     fn test_add_from_impl_struct_variant() {\n-        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One { x: u32 } }\");\n+        check_not_applicable(\"enum A { <|>One { x: u32 } }\");\n     }\n \n     #[test]\n     fn test_add_from_impl_already_exists() {\n-        check_assist_not_applicable(\n-            add_from_impl_for_enum,\n-            r#\"enum A { <|>One(u32), }\n+        covers!(test_add_from_impl_already_exists);\n+        check_not_applicable(\n+            r#\"\n+enum A { <|>One(u32), }\n \n impl From<u32> for A {\n     fn from(v: u32) -> Self {\n         A::One(v)\n     }\n }\n-\n-pub trait From<T> {\n-    fn from(T) -> Self;\n-}\"#,\n+\"#,\n         );\n     }\n "}, {"sha": "9841f6980bc3e01cff360b540e87915027eb9784", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,11 +1,10 @@\n use ra_fmt::unwrap_trivial_block;\n use ra_syntax::{\n-    ast::{self, make},\n+    ast::{self, edit::IndentLevel, make},\n     AstNode,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::edit::IndentLevel;\n+use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n \n // Assist: replace_if_let_with_match\n //\n@@ -44,15 +43,21 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n         ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n-    ctx.add_assist(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", |edit| {\n+    let sema = ctx.sema;\n+    ctx.add_assist(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", move |edit| {\n         let match_expr = {\n             let then_arm = {\n                 let then_expr = unwrap_trivial_block(then_block);\n-                make::match_arm(vec![pat], then_expr)\n+                make::match_arm(vec![pat.clone()], then_expr)\n             };\n             let else_arm = {\n+                let pattern = sema\n+                    .type_of_pat(&pat)\n+                    .and_then(|ty| TryEnum::from_ty(sema, &ty))\n+                    .map(|it| it.sad_pattern())\n+                    .unwrap_or_else(|| make::placeholder_pat().into());\n                 let else_expr = unwrap_trivial_block(else_block);\n-                make::match_arm(vec![make::placeholder_pat().into()], else_expr)\n+                make::match_arm(vec![pattern], else_expr)\n             };\n             make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n         };\n@@ -68,6 +73,7 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+\n     use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n@@ -145,4 +151,64 @@ impl VariantData {\n         }\",\n         );\n     }\n+\n+    #[test]\n+    fn special_case_option() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    <|>if let Some(x) = x {\n+        println!(\"{}\", x)\n+    } else {\n+        println!(\"none\")\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+\n+fn foo(x: Option<i32>) {\n+    <|>match x {\n+        Some(x) => println!(\"{}\", x),\n+        None => println!(\"none\"),\n+    }\n+}\n+           \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn special_case_result() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    <|>if let Ok(x) = x {\n+        println!(\"{}\", x)\n+    } else {\n+        println!(\"none\")\n+    }\n+}\n+           \"#,\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n+\n+fn foo(x: Result<i32, ()>) {\n+    <|>match x {\n+        Ok(x) => println!(\"{}\", x),\n+        Err(_) => println!(\"none\"),\n+    }\n+}\n+           \"#,\n+        );\n+    }\n }"}, {"sha": "0cf23b754e8d635a06f30a509bdbf46327bee3a7", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,6 +1,5 @@\n use std::iter::once;\n \n-use hir::Adt;\n use ra_syntax::{\n     ast::{\n         self,\n@@ -12,6 +11,7 @@ use ra_syntax::{\n \n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n+    utils::TryEnum,\n     AssistId,\n };\n \n@@ -45,20 +45,10 @@ pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n     let init = let_stmt.initializer()?;\n     let original_pat = let_stmt.pat()?;\n     let ty = ctx.sema.type_of_expr(&init)?;\n-    let enum_ = match ty.as_adt() {\n-        Some(Adt::Enum(it)) => it,\n-        _ => return None,\n-    };\n-    let happy_case =\n-        [(\"Result\", \"Ok\"), (\"Option\", \"Some\")].iter().find_map(|(known_type, happy_case)| {\n-            if &enum_.name(ctx.db).to_string() == known_type {\n-                return Some(happy_case);\n-            }\n-            None\n-        });\n+    let happy_variant = TryEnum::from_ty(ctx.sema, &ty).map(|it| it.happy_case());\n \n     ctx.add_assist(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", |edit| {\n-        let with_placeholder: ast::Pat = match happy_case {\n+        let with_placeholder: ast::Pat = match happy_variant {\n             None => make::placeholder_pat().into(),\n             Some(var_name) => make::tuple_struct_pat(\n                 make::path_unqualified(make::path_segment(make::name_ref(var_name))),"}, {"sha": "62d4ea5220259f070d026aefdf6f04c13272a1f2", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 18, "deletions": 34, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,12 +1,11 @@\n use std::iter;\n \n use ra_syntax::{\n-    ast::{self, make},\n+    ast::{self, edit::IndentLevel, make},\n     AstNode,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::edit::IndentLevel;\n+use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n \n // Assist: replace_unwrap_with_match\n //\n@@ -38,42 +37,27 @@ pub(crate) fn replace_unwrap_with_match(ctx: AssistCtx) -> Option<Assist> {\n     }\n     let caller = method_call.expr()?;\n     let ty = ctx.sema.type_of_expr(&caller)?;\n+    let happy_variant = TryEnum::from_ty(ctx.sema, &ty)?.happy_case();\n \n-    let type_name = ty.as_adt()?.name(ctx.sema.db).to_string();\n+    ctx.add_assist(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", |edit| {\n+        let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n+        let it = make::bind_pat(make::name(\"a\")).into();\n+        let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n-    for (unwrap_type, variant_name) in [(\"Result\", \"Ok\"), (\"Option\", \"Some\")].iter() {\n-        if &type_name == unwrap_type {\n-            return ctx.add_assist(\n-                AssistId(\"replace_unwrap_with_match\"),\n-                \"Replace unwrap with match\",\n-                |edit| {\n-                    let ok_path =\n-                        make::path_unqualified(make::path_segment(make::name_ref(variant_name)));\n-                    let it = make::bind_pat(make::name(\"a\")).into();\n-                    let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n+        let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n+        let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-                    let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n-                    let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n+        let unreachable_call = make::unreachable_macro_call().into();\n+        let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n-                    let unreachable_call = make::unreachable_macro_call().into();\n-                    let err_arm = make::match_arm(\n-                        iter::once(make::placeholder_pat().into()),\n-                        unreachable_call,\n-                    );\n+        let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n+        let match_expr = make::expr_match(caller.clone(), match_arm_list);\n+        let match_expr = IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n \n-                    let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n-                    let match_expr = make::expr_match(caller.clone(), match_arm_list);\n-                    let match_expr =\n-                        IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n-\n-                    edit.target(method_call.syntax().text_range());\n-                    edit.set_cursor(caller.syntax().text_range().start());\n-                    edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n-                },\n-            );\n-        }\n-    }\n-    None\n+        edit.target(method_call.syntax().text_range());\n+        edit.set_cursor(caller.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "8d910205f0ab332d9fecc40cc94909e3c242abee", "filename": "crates/ra_assists/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fmarks.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -8,4 +8,5 @@ test_utils::marks![\n     test_not_inline_mut_variable\n     test_not_applicable_if_variable_unused\n     change_visibility_field_false_positive\n+    test_add_from_impl_already_exists\n ];"}, {"sha": "efd9886978a59b8f9aedec2663cf0a13441a010f", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,7 +1,9 @@\n //! Assorted functions shared by several assists.\n pub(crate) mod insert_use;\n \n-use hir::Semantics;\n+use std::iter;\n+\n+use hir::{Adt, Crate, Semantics, Trait, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, make, NameOwner},\n@@ -99,3 +101,109 @@ fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n         _ => None,\n     }\n }\n+\n+#[derive(Clone, Copy)]\n+pub(crate) enum TryEnum {\n+    Result,\n+    Option,\n+}\n+\n+impl TryEnum {\n+    const ALL: [TryEnum; 2] = [TryEnum::Option, TryEnum::Result];\n+\n+    pub(crate) fn from_ty(sema: &Semantics<RootDatabase>, ty: &Type) -> Option<TryEnum> {\n+        let enum_ = match ty.as_adt() {\n+            Some(Adt::Enum(it)) => it,\n+            _ => return None,\n+        };\n+        TryEnum::ALL.iter().find_map(|&var| {\n+            if &enum_.name(sema.db).to_string() == var.type_name() {\n+                return Some(var);\n+            }\n+            None\n+        })\n+    }\n+\n+    pub(crate) fn happy_case(self) -> &'static str {\n+        match self {\n+            TryEnum::Result => \"Ok\",\n+            TryEnum::Option => \"Some\",\n+        }\n+    }\n+\n+    pub(crate) fn sad_pattern(self) -> ast::Pat {\n+        match self {\n+            TryEnum::Result => make::tuple_struct_pat(\n+                make::path_unqualified(make::path_segment(make::name_ref(\"Err\"))),\n+                iter::once(make::placeholder_pat().into()),\n+            )\n+            .into(),\n+            TryEnum::Option => make::bind_pat(make::name(\"None\")).into(),\n+        }\n+    }\n+\n+    fn type_name(self) -> &'static str {\n+        match self {\n+            TryEnum::Result => \"Result\",\n+            TryEnum::Option => \"Option\",\n+        }\n+    }\n+}\n+\n+/// Helps with finding well-know things inside the standard library. This is\n+/// somewhat similar to the known paths infra inside hir, but it different; We\n+/// want to make sure that IDE specific paths don't become interesting inside\n+/// the compiler itself as well.\n+pub(crate) struct FamousDefs<'a, 'b>(pub(crate) &'a Semantics<'b, RootDatabase>, pub(crate) Crate);\n+\n+#[allow(non_snake_case)]\n+impl FamousDefs<'_, '_> {\n+    #[cfg(test)]\n+    pub(crate) const FIXTURE: &'static str = r#\"\n+//- /libcore.rs crate:core\n+pub mod convert{\n+    pub trait From<T> {\n+        fn from(T) -> Self;\n+    }\n+}\n+\n+pub mod prelude { pub use crate::convert::From }\n+#[prelude_import]\n+pub use prelude::*;\n+\"#;\n+\n+    pub(crate) fn core_convert_From(&self) -> Option<Trait> {\n+        self.find_trait(\"core:convert:From\")\n+    }\n+\n+    fn find_trait(&self, path: &str) -> Option<Trait> {\n+        let db = self.0.db;\n+        let mut path = path.split(':');\n+        let trait_ = path.next_back()?;\n+        let std_crate = path.next()?;\n+        let std_crate = self\n+            .1\n+            .dependencies(db)\n+            .into_iter()\n+            .find(|dep| &dep.name.to_string() == std_crate)?\n+            .krate;\n+\n+        let mut module = std_crate.root_module(db)?;\n+        for segment in path {\n+            module = module.children(db).find_map(|child| {\n+                let name = child.name(db)?;\n+                if &name.to_string() == segment {\n+                    Some(child)\n+                } else {\n+                    None\n+                }\n+            })?;\n+        }\n+        let def =\n+            module.scope(db, None).into_iter().find(|(name, _def)| &name.to_string() == trait_)?.1;\n+        match def {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "324c33d9dd28dd554e23af4c5b8c6521a1b5f0d5", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -6,7 +6,7 @@ authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n crossbeam-channel = \"0.4.0\"\n-lsp-types = { version = \"0.73.0\", features = [\"proposed\"] }\n+lsp-types = { version = \"0.74.0\", features = [\"proposed\"] }\n log = \"0.4.8\"\n cargo_metadata = \"0.9.1\"\n serde_json = \"1.0.48\""}, {"sha": "1a30b2b3ab8721e7f7249e3ded2070ad0d1c9738", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -57,18 +57,17 @@ pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n             return None;\n         }\n         return Some(expr);\n-    } else {\n-        // Unwrap `{ continue; }`\n-        let (stmt,) = block.statements().next_tuple()?;\n-        if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n-            if has_anything_else(expr_stmt.syntax()) {\n-                return None;\n-            }\n-            let expr = expr_stmt.expr()?;\n-            match expr.syntax().kind() {\n-                CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),\n-                _ => (),\n-            }\n+    }\n+    // Unwrap `{ continue; }`\n+    let (stmt,) = block.statements().next_tuple()?;\n+    if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n+        if has_anything_else(expr_stmt.syntax()) {\n+            return None;\n+        }\n+        let expr = expr_stmt.expr()?;\n+        match expr.syntax().kind() {\n+            CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),\n+            _ => (),\n         }\n     }\n     None"}, {"sha": "af59aa1b6cf4156a462a68623fff5a13db9ab1cf", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -953,6 +953,16 @@ impl TypeParam {\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         self.id.parent.module(db.upcast()).into()\n     }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let resolver = self.id.parent.resolver(db.upcast());\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = Ty::Placeholder(self.id);\n+        Type {\n+            krate: self.id.parent.module(db.upcast()).krate,\n+            ty: InEnvironment { value: ty, environment },\n+        }\n+    }\n }\n \n // FIXME: rename from `ImplDef` to `Impl`\n@@ -1157,18 +1167,21 @@ impl Type {\n \n     pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n         if let Ty::Apply(a_ty) = &self.ty.value {\n-            if let TypeCtor::Adt(AdtId::StructId(s)) = a_ty.ctor {\n-                let var_def = s.into();\n-                return db\n-                    .field_types(var_def)\n-                    .iter()\n-                    .map(|(local_id, ty)| {\n-                        let def = Field { parent: var_def.into(), id: local_id };\n-                        let ty = ty.clone().subst(&a_ty.parameters);\n-                        (def, self.derived(ty))\n-                    })\n-                    .collect();\n-            }\n+            let variant_id = match a_ty.ctor {\n+                TypeCtor::Adt(AdtId::StructId(s)) => s.into(),\n+                TypeCtor::Adt(AdtId::UnionId(u)) => u.into(),\n+                _ => return Vec::new(),\n+            };\n+\n+            return db\n+                .field_types(variant_id)\n+                .iter()\n+                .map(|(local_id, ty)| {\n+                    let def = Field { parent: variant_id.into(), id: local_id };\n+                    let ty = ty.clone().subst(&a_ty.parameters);\n+                    (def, self.derived(ty))\n+                })\n+                .collect();\n         };\n         Vec::new()\n     }"}, {"sha": "a0a0f234bf9272aaf468e4f1e11f546eef9e3e96", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -9,6 +9,7 @@ use hir_def::{\n     AsMacroCall, TraitId,\n };\n use hir_expand::ExpansionInfo;\n+use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use ra_db::{FileId, FileRange};\n use ra_prof::profile;\n@@ -24,8 +25,9 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n-    Name, Origin, Path, ScopeDef, Trait, Type, TypeParam,\n+    Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam,\n };\n+use resolver::TypeNs;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathResolution {\n@@ -40,6 +42,44 @@ pub enum PathResolution {\n     AssocItem(AssocItem),\n }\n \n+impl PathResolution {\n+    fn in_type_ns(&self) -> Option<TypeNs> {\n+        match self {\n+            PathResolution::Def(ModuleDef::Adt(adt)) => Some(TypeNs::AdtId((*adt).into())),\n+            PathResolution::Def(ModuleDef::BuiltinType(builtin)) => {\n+                Some(TypeNs::BuiltinType(*builtin))\n+            }\n+            PathResolution::Def(ModuleDef::Const(_))\n+            | PathResolution::Def(ModuleDef::EnumVariant(_))\n+            | PathResolution::Def(ModuleDef::Function(_))\n+            | PathResolution::Def(ModuleDef::Module(_))\n+            | PathResolution::Def(ModuleDef::Static(_))\n+            | PathResolution::Def(ModuleDef::Trait(_)) => None,\n+            PathResolution::Def(ModuleDef::TypeAlias(alias)) => {\n+                Some(TypeNs::TypeAliasId((*alias).into()))\n+            }\n+            PathResolution::Local(_) | PathResolution::Macro(_) => None,\n+            PathResolution::TypeParam(param) => Some(TypeNs::GenericParam((*param).into())),\n+            PathResolution::SelfType(impl_def) => Some(TypeNs::SelfType((*impl_def).into())),\n+            PathResolution::AssocItem(AssocItem::Const(_))\n+            | PathResolution::AssocItem(AssocItem::Function(_)) => None,\n+            PathResolution::AssocItem(AssocItem::TypeAlias(alias)) => {\n+                Some(TypeNs::TypeAliasId((*alias).into()))\n+            }\n+        }\n+    }\n+\n+    /// Returns an iterator over associated types that may be specified after this path (using\n+    /// `Ty::Assoc` syntax).\n+    pub fn assoc_type_shorthand_candidates<R>(\n+        &self,\n+        db: &dyn HirDatabase,\n+        mut cb: impl FnMut(TypeAlias) -> Option<R>,\n+    ) -> Option<R> {\n+        associated_type_shorthand_candidates(db, self.in_type_ns()?, |_, _, id| cb(id.into()))\n+    }\n+}\n+\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,"}, {"sha": "f467ed3fe2fe550dd8dc2828d021253af4c0366f", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -182,10 +182,6 @@ impl ExprCollector<'_> {\n \n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n-            ast::Expr::TryBlockExpr(e) => {\n-                let body = self.collect_block_opt(e.body());\n-                self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n-            }\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());"}, {"sha": "aad12e1235d3e6fe60dc2689d278da35e27b207e", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -101,9 +101,6 @@ pub enum Expr {\n     Try {\n         expr: ExprId,\n     },\n-    TryBlock {\n-        body: ExprId,\n-    },\n     Cast {\n         expr: ExprId,\n         type_ref: TypeRef,\n@@ -239,7 +236,6 @@ impl Expr {\n                     f(*expr);\n                 }\n             }\n-            Expr::TryBlock { body } => f(*body),\n             Expr::Loop { body } => f(*body),\n             Expr::While { condition, body } => {\n                 f(*condition);"}, {"sha": "efc60986bd03af2b51b485f1b6c272dd72364cca", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -73,11 +73,6 @@ impl<'a> InferenceContext<'a> {\n                 self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n-            Expr::TryBlock { body } => {\n-                let _inner = self.infer_expr(*body, expected);\n-                // FIXME should be std::result::Result<{inner}, _>\n-                Ty::Unknown\n-            }\n             Expr::Loop { body } => {\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 // FIXME handle break with value"}, {"sha": "a6f56c661e2a7b509371b954d58c0dd894c37c88", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -66,7 +66,8 @@ pub use autoderef::autoderef;\n pub use infer::{InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub use lower::{\n-    callable_item_sig, ImplTraitLoweringMode, TyDefId, TyLoweringContext, ValueTyDefId,\n+    associated_type_shorthand_candidates, callable_item_sig, ImplTraitLoweringMode, TyDefId,\n+    TyLoweringContext, ValueTyDefId,\n };\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n "}, {"sha": "9ad6dbe075a2b26b2cfbfdc014cf43e2bca193c0", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 88, "deletions": 55, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -17,9 +17,9 @@ use hir_def::{\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AssocContainerId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n-    ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n-    VariantId,\n+    AdtId, AssocContainerId, AssocItemId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n+    HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId,\n+    UnionId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -34,6 +34,7 @@ use crate::{\n     Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate,\n     ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n+use hir_expand::name::Name;\n \n #[derive(Debug)]\n pub struct TyLoweringContext<'a> {\n@@ -383,61 +384,38 @@ impl Ty {\n         res: Option<TypeNs>,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n-        let traits_from_env: Vec<_> = match res {\n-            Some(TypeNs::SelfType(impl_id)) => match ctx.db.impl_trait(impl_id) {\n-                None => return Ty::Unknown,\n-                Some(trait_ref) => vec![trait_ref.value],\n-            },\n-            Some(TypeNs::GenericParam(param_id)) => {\n-                let predicates = ctx.db.generic_predicates_for_param(param_id);\n-                let mut traits_: Vec<_> = predicates\n-                    .iter()\n-                    .filter_map(|pred| match &pred.value {\n-                        GenericPredicate::Implemented(tr) => Some(tr.clone()),\n-                        _ => None,\n-                    })\n-                    .collect();\n-                // Handle `Self::Type` referring to own associated type in trait definitions\n-                if let GenericDefId::TraitId(trait_id) = param_id.parent {\n-                    let generics = generics(ctx.db.upcast(), trait_id.into());\n-                    if generics.params.types[param_id.local_id].provenance\n-                        == TypeParamProvenance::TraitSelf\n-                    {\n-                        let trait_ref = TraitRef {\n-                            trait_: trait_id,\n-                            substs: Substs::bound_vars(&generics, DebruijnIndex::INNERMOST),\n+        if let Some(res) = res {\n+            let ty =\n+                associated_type_shorthand_candidates(ctx.db, res, move |name, t, associated_ty| {\n+                    if name == segment.name {\n+                        let substs = match ctx.type_param_mode {\n+                            TypeParamLoweringMode::Placeholder => {\n+                                // if we're lowering to placeholders, we have to put\n+                                // them in now\n+                                let s = Substs::type_params(\n+                                    ctx.db,\n+                                    ctx.resolver.generic_def().expect(\n+                                        \"there should be generics if there's a generic param\",\n+                                    ),\n+                                );\n+                                t.substs.clone().subst_bound_vars(&s)\n+                            }\n+                            TypeParamLoweringMode::Variable => t.substs.clone(),\n                         };\n-                        traits_.push(trait_ref);\n+                        // FIXME handle type parameters on the segment\n+                        return Some(Ty::Projection(ProjectionTy {\n+                            associated_ty,\n+                            parameters: substs,\n+                        }));\n                     }\n-                }\n-                traits_\n-            }\n-            _ => return Ty::Unknown,\n-        };\n-        let traits = traits_from_env.into_iter().flat_map(|t| all_super_trait_refs(ctx.db, t));\n-        for t in traits {\n-            if let Some(associated_ty) =\n-                ctx.db.trait_data(t.trait_).associated_type_by_name(&segment.name)\n-            {\n-                let substs = match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => {\n-                        // if we're lowering to placeholders, we have to put\n-                        // them in now\n-                        let s = Substs::type_params(\n-                            ctx.db,\n-                            ctx.resolver\n-                                .generic_def()\n-                                .expect(\"there should be generics if there's a generic param\"),\n-                        );\n-                        t.substs.subst_bound_vars(&s)\n-                    }\n-                    TypeParamLoweringMode::Variable => t.substs,\n-                };\n-                // FIXME handle (forbid) type parameters on the segment\n-                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n-            }\n+\n+                    None\n+                });\n+\n+            ty.unwrap_or(Ty::Unknown)\n+        } else {\n+            Ty::Unknown\n         }\n-        Ty::Unknown\n     }\n \n     fn from_hir_path_inner(\n@@ -694,6 +672,61 @@ pub fn callable_item_sig(db: &dyn HirDatabase, def: CallableDef) -> PolyFnSig {\n     }\n }\n \n+pub fn associated_type_shorthand_candidates<R>(\n+    db: &dyn HirDatabase,\n+    res: TypeNs,\n+    mut cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n+) -> Option<R> {\n+    let traits_from_env: Vec<_> = match res {\n+        TypeNs::SelfType(impl_id) => match db.impl_trait(impl_id) {\n+            None => vec![],\n+            Some(trait_ref) => vec![trait_ref.value],\n+        },\n+        TypeNs::GenericParam(param_id) => {\n+            let predicates = db.generic_predicates_for_param(param_id);\n+            let mut traits_: Vec<_> = predicates\n+                .iter()\n+                .filter_map(|pred| match &pred.value {\n+                    GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+                    _ => None,\n+                })\n+                .collect();\n+            // Handle `Self::Type` referring to own associated type in trait definitions\n+            if let GenericDefId::TraitId(trait_id) = param_id.parent {\n+                let generics = generics(db.upcast(), trait_id.into());\n+                if generics.params.types[param_id.local_id].provenance\n+                    == TypeParamProvenance::TraitSelf\n+                {\n+                    let trait_ref = TraitRef {\n+                        trait_: trait_id,\n+                        substs: Substs::bound_vars(&generics, DebruijnIndex::INNERMOST),\n+                    };\n+                    traits_.push(trait_ref);\n+                }\n+            }\n+            traits_\n+        }\n+        _ => vec![],\n+    };\n+\n+    for t in traits_from_env.into_iter().flat_map(move |t| all_super_trait_refs(db, t)) {\n+        let data = db.trait_data(t.trait_);\n+\n+        for (name, assoc_id) in &data.items {\n+            match assoc_id {\n+                AssocItemId::TypeAliasId(alias) => {\n+                    if let Some(result) = cb(name, &t, *alias) {\n+                        return Some(result);\n+                    }\n+                }\n+                AssocItemId::FunctionId(_) | AssocItemId::ConstId(_) => {}\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n /// Build the type of all specific fields of a struct or enum variant.\n pub(crate) fn field_types_query(\n     db: &dyn HirDatabase,"}, {"sha": "05f825c6fe22225b0042e229789a528142a1b752", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -249,6 +249,44 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_union_field_completion() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+            union Un {\n+                field: u8,\n+                other: u16,\n+            }\n+\n+            fn foo(u: Un) {\n+                u.<|>\n+            }\n+            \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"field\",\n+                source_range: 140..140,\n+                delete: 140..140,\n+                insert: \"field\",\n+                kind: Field,\n+                detail: \"u8\",\n+            },\n+            CompletionItem {\n+                label: \"other\",\n+                source_range: 140..140,\n+                delete: 140..140,\n+                insert: \"other\",\n+                kind: Field,\n+                detail: \"u16\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_method_completion() {\n         assert_debug_snapshot!("}, {"sha": "aa56a5cd870311d45deaef28088552c1977b7378", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 261, "deletions": 11, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -5,19 +5,29 @@ use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n use crate::completion::{CompletionContext, Completions};\n+use rustc_hash::FxHashSet;\n \n pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let path = match &ctx.path_prefix {\n         Some(path) => path.clone(),\n         _ => return,\n     };\n-    let def = match ctx.scope().resolve_hir_path(&path) {\n-        Some(PathResolution::Def(def)) => def,\n-        _ => return,\n+    let scope = ctx.scope();\n+    let context_module = scope.module();\n+\n+    let res = match scope.resolve_hir_path(&path) {\n+        Some(res) => res,\n+        None => return,\n     };\n-    let context_module = ctx.scope().module();\n-    match def {\n-        hir::ModuleDef::Module(module) => {\n+\n+    // Add associated types on type parameters and `Self`.\n+    res.assoc_type_shorthand_candidates(ctx.db, |alias| {\n+        acc.add_type_alias(ctx, alias);\n+        None::<()>\n+    });\n+\n+    match res {\n+        PathResolution::Def(hir::ModuleDef::Module(module)) => {\n             let module_scope = module.scope(ctx.db, context_module);\n             for (name, def) in module_scope {\n                 if ctx.use_item_syntax.is_some() {\n@@ -35,7 +45,8 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 acc.add_resolution(ctx, name.to_string(), &def);\n             }\n         }\n-        hir::ModuleDef::Adt(_) | hir::ModuleDef::TypeAlias(_) => {\n+        PathResolution::Def(def @ hir::ModuleDef::Adt(_))\n+        | PathResolution::Def(def @ hir::ModuleDef::TypeAlias(_)) => {\n             if let hir::ModuleDef::Adt(Adt::Enum(e)) = def {\n                 for variant in e.variants(ctx.db) {\n                     acc.add_enum_variant(ctx, variant, None);\n@@ -46,8 +57,10 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n-            // Iterate assoc types separately\n-            // FIXME: complete T::AssocType\n+\n+            // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n+            // (where AssocType is defined on a trait, not an inherent impl)\n+\n             let krate = ctx.krate;\n             if let Some(krate) = krate {\n                 let traits_in_scope = ctx.scope().traits_in_scope();\n@@ -65,6 +78,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     None::<()>\n                 });\n \n+                // Iterate assoc types separately\n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n                     if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n                         return None;\n@@ -77,7 +91,8 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 });\n             }\n         }\n-        hir::ModuleDef::Trait(t) => {\n+        PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n+            // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n             for item in t.items(ctx.db) {\n                 if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n                     continue;\n@@ -91,8 +106,38 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 }\n             }\n         }\n+        PathResolution::TypeParam(_) | PathResolution::SelfType(_) => {\n+            if let Some(krate) = ctx.krate {\n+                let ty = match res {\n+                    PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                    PathResolution::SelfType(impl_def) => impl_def.target_ty(ctx.db),\n+                    _ => return,\n+                };\n+\n+                let traits_in_scope = ctx.scope().traits_in_scope();\n+                let mut seen = FxHashSet::default();\n+                ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n+                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                        return None;\n+                    }\n+\n+                    // We might iterate candidates of a trait multiple times here, so deduplicate\n+                    // them.\n+                    if seen.insert(item) {\n+                        match item {\n+                            hir::AssocItem::Function(func) => {\n+                                acc.add_function(ctx, func, None);\n+                            }\n+                            hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+                            hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+                        }\n+                    }\n+                    None::<()>\n+                });\n+            }\n+        }\n         _ => {}\n-    };\n+    }\n }\n \n #[cfg(test)]\n@@ -843,6 +888,211 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_ty_param_assoc_ty() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                trait Super {\n+                    type Ty;\n+                    const CONST: u8;\n+                    fn func() {}\n+                    fn method(&self) {}\n+                }\n+\n+                trait Sub: Super {\n+                    type SubTy;\n+                    const C2: ();\n+                    fn subfunc() {}\n+                    fn submethod(&self) {}\n+                }\n+\n+                fn foo<T: Sub>() {\n+                    T::<|>\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"C2\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"C2\",\n+                kind: Const,\n+                detail: \"const C2: ();\",\n+            },\n+            CompletionItem {\n+                label: \"CONST\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"CONST\",\n+                kind: Const,\n+                detail: \"const CONST: u8;\",\n+            },\n+            CompletionItem {\n+                label: \"SubTy\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"SubTy\",\n+                kind: TypeAlias,\n+                detail: \"type SubTy;\",\n+            },\n+            CompletionItem {\n+                label: \"Ty\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"Ty\",\n+                kind: TypeAlias,\n+                detail: \"type Ty;\",\n+            },\n+            CompletionItem {\n+                label: \"func()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"func()$0\",\n+                kind: Function,\n+                lookup: \"func\",\n+                detail: \"fn func()\",\n+            },\n+            CompletionItem {\n+                label: \"method()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"method()$0\",\n+                kind: Method,\n+                lookup: \"method\",\n+                detail: \"fn method(&self)\",\n+            },\n+            CompletionItem {\n+                label: \"subfunc()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"subfunc()$0\",\n+                kind: Function,\n+                lookup: \"subfunc\",\n+                detail: \"fn subfunc()\",\n+            },\n+            CompletionItem {\n+                label: \"submethod()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"submethod()$0\",\n+                kind: Method,\n+                lookup: \"submethod\",\n+                detail: \"fn submethod(&self)\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_self_param_assoc_ty() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                trait Super {\n+                    type Ty;\n+                    const CONST: u8 = 0;\n+                    fn func() {}\n+                    fn method(&self) {}\n+                }\n+\n+                trait Sub: Super {\n+                    type SubTy;\n+                    const C2: () = ();\n+                    fn subfunc() {}\n+                    fn submethod(&self) {}\n+                }\n+\n+                struct Wrap<T>(T);\n+                impl<T> Super for Wrap<T> {}\n+                impl<T> Sub for Wrap<T> {\n+                    fn subfunc() {\n+                        // Should be able to assume `Self: Sub + Super`\n+                        Self::<|>\n+                    }\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"C2\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"C2\",\n+                kind: Const,\n+                detail: \"const C2: () = ();\",\n+            },\n+            CompletionItem {\n+                label: \"CONST\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"CONST\",\n+                kind: Const,\n+                detail: \"const CONST: u8 = 0;\",\n+            },\n+            CompletionItem {\n+                label: \"SubTy\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"SubTy\",\n+                kind: TypeAlias,\n+                detail: \"type SubTy;\",\n+            },\n+            CompletionItem {\n+                label: \"Ty\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"Ty\",\n+                kind: TypeAlias,\n+                detail: \"type Ty;\",\n+            },\n+            CompletionItem {\n+                label: \"func()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"func()$0\",\n+                kind: Function,\n+                lookup: \"func\",\n+                detail: \"fn func()\",\n+            },\n+            CompletionItem {\n+                label: \"method()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"method()$0\",\n+                kind: Method,\n+                lookup: \"method\",\n+                detail: \"fn method(&self)\",\n+            },\n+            CompletionItem {\n+                label: \"subfunc()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"subfunc()$0\",\n+                kind: Function,\n+                lookup: \"subfunc\",\n+                detail: \"fn subfunc()\",\n+            },\n+            CompletionItem {\n+                label: \"submethod()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"submethod()$0\",\n+                kind: Method,\n+                lookup: \"submethod\",\n+                detail: \"fn submethod(&self)\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_type_alias() {\n         assert_debug_snapshot!("}, {"sha": "a6a5568de0bf55dffcdb591a6ae352a54ed38efa", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -53,7 +53,7 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n                 // Variants with trivial paths are already added by the existing completion logic,\n                 // so we should avoid adding these twice\n                 if path.segments.len() > 1 {\n-                    acc.add_enum_variant(ctx, variant, Some(path.to_string()));\n+                    acc.add_qualified_enum_variant(ctx, variant, path);\n                 }\n             }\n         }\n@@ -1173,6 +1173,7 @@ mod tests {\n                 delete: 248..250,\n                 insert: \"Foo::Bar\",\n                 kind: EnumVariant,\n+                lookup: \"Bar\",\n                 detail: \"()\",\n             },\n             CompletionItem {\n@@ -1181,6 +1182,7 @@ mod tests {\n                 delete: 248..250,\n                 insert: \"Foo::Baz\",\n                 kind: EnumVariant,\n+                lookup: \"Baz\",\n                 detail: \"()\",\n             },\n             CompletionItem {\n@@ -1189,6 +1191,7 @@ mod tests {\n                 delete: 248..250,\n                 insert: \"Foo::Quux\",\n                 kind: EnumVariant,\n+                lookup: \"Quux\",\n                 detail: \"()\",\n             },\n         ]\n@@ -1231,6 +1234,7 @@ mod tests {\n                 delete: 219..221,\n                 insert: \"Foo::Bar\",\n                 kind: EnumVariant,\n+                lookup: \"Bar\",\n                 detail: \"()\",\n             },\n             CompletionItem {\n@@ -1239,6 +1243,7 @@ mod tests {\n                 delete: 219..221,\n                 insert: \"Foo::Baz\",\n                 kind: EnumVariant,\n+                lookup: \"Baz\",\n                 detail: \"()\",\n             },\n             CompletionItem {\n@@ -1247,6 +1252,7 @@ mod tests {\n                 delete: 219..221,\n                 insert: \"Foo::Quux\",\n                 kind: EnumVariant,\n+                lookup: \"Quux\",\n                 detail: \"()\",\n             },\n         ]\n@@ -1285,6 +1291,7 @@ mod tests {\n                 delete: 185..186,\n                 insert: \"Foo::Bar\",\n                 kind: EnumVariant,\n+                lookup: \"Bar\",\n                 detail: \"()\",\n             },\n             CompletionItem {\n@@ -1293,6 +1300,7 @@ mod tests {\n                 delete: 185..186,\n                 insert: \"Foo::Baz\",\n                 kind: EnumVariant,\n+                lookup: \"Baz\",\n                 detail: \"()\",\n             },\n             CompletionItem {\n@@ -1301,6 +1309,7 @@ mod tests {\n                 delete: 185..186,\n                 insert: \"Foo::Quux\",\n                 kind: EnumVariant,\n+                lookup: \"Quux\",\n                 detail: \"()\",\n             },\n             CompletionItem {\n@@ -1353,6 +1362,7 @@ mod tests {\n                 delete: 98..99,\n                 insert: \"m::E::V\",\n                 kind: EnumVariant,\n+                lookup: \"V\",\n                 detail: \"()\",\n             },\n         ]"}, {"sha": "2edb130cf7bfca726dce877a8d8ad2e8f1951dba", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,6 +1,6 @@\n //! This modules takes care of rendering various definitions as completion items.\n \n-use hir::{Docs, HasAttrs, HasSource, HirDisplay, ScopeDef, StructKind, Type};\n+use hir::{Docs, HasAttrs, HasSource, HirDisplay, ModPath, ScopeDef, StructKind, Type};\n use ra_syntax::ast::NameOwner;\n use stdx::SepBy;\n use test_utils::tested_by;\n@@ -246,14 +246,37 @@ impl Completions {\n             .add_to(self);\n     }\n \n+    pub(crate) fn add_qualified_enum_variant(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::EnumVariant,\n+        path: ModPath,\n+    ) {\n+        self.add_enum_variant_impl(ctx, variant, None, Some(path))\n+    }\n+\n     pub(crate) fn add_enum_variant(\n         &mut self,\n         ctx: &CompletionContext,\n         variant: hir::EnumVariant,\n         local_name: Option<String>,\n+    ) {\n+        self.add_enum_variant_impl(ctx, variant, local_name, None)\n+    }\n+\n+    fn add_enum_variant_impl(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::EnumVariant,\n+        local_name: Option<String>,\n+        path: Option<ModPath>,\n     ) {\n         let is_deprecated = is_deprecated(variant, ctx.db);\n         let name = local_name.unwrap_or_else(|| variant.name(ctx.db).to_string());\n+        let qualified_name = match &path {\n+            Some(it) => it.to_string(),\n+            None => name.to_string(),\n+        };\n         let detail_types = variant\n             .fields(ctx.db)\n             .into_iter()\n@@ -271,16 +294,23 @@ impl Completions {\n                 .surround_with(\"{ \", \" }\")\n                 .to_string(),\n         };\n-        let mut res =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n-                .kind(CompletionItemKind::EnumVariant)\n-                .set_documentation(variant.docs(ctx.db))\n-                .set_deprecated(is_deprecated)\n-                .detail(detail);\n+        let mut res = CompletionItem::new(\n+            CompletionKind::Reference,\n+            ctx.source_range(),\n+            qualified_name.clone(),\n+        )\n+        .kind(CompletionItemKind::EnumVariant)\n+        .set_documentation(variant.docs(ctx.db))\n+        .set_deprecated(is_deprecated)\n+        .detail(detail);\n+\n+        if path.is_some() {\n+            res = res.lookup_by(name);\n+        }\n \n         if variant_kind == StructKind::Tuple {\n             let params = Params::Anonymous(variant.fields(ctx.db).len());\n-            res = res.add_call_parens(ctx, name, params)\n+            res = res.add_call_parens(ctx, qualified_name, params)\n         }\n \n         res.add_to(self);"}, {"sha": "db3907fe64e13afe8194abb13e1a209fda488b8f", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -26,6 +26,8 @@ pub struct FunctionSignature {\n     pub kind: CallableKind,\n     /// Optional visibility\n     pub visibility: Option<String>,\n+    /// Qualifiers like `async`, `unsafe`, ...\n+    pub qualifier: FunctionQualifier,\n     /// Name of the function\n     pub name: Option<String>,\n     /// Documentation for the function\n@@ -46,6 +48,16 @@ pub struct FunctionSignature {\n     pub has_self_param: bool,\n }\n \n+#[derive(Debug, Default)]\n+pub struct FunctionQualifier {\n+    // `async` and `const` are mutually exclusive. Do we need to enforcing it here?\n+    pub is_async: bool,\n+    pub is_const: bool,\n+    pub is_unsafe: bool,\n+    /// The string `extern \"..\"`\n+    pub extern_abi: Option<String>,\n+}\n+\n impl FunctionSignature {\n     pub(crate) fn with_doc_opt(mut self, doc: Option<Documentation>) -> Self {\n         self.doc = doc;\n@@ -83,6 +95,8 @@ impl FunctionSignature {\n             FunctionSignature {\n                 kind: CallableKind::StructConstructor,\n                 visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n+                // Do we need `const`?\n+                qualifier: Default::default(),\n                 name: node.name().map(|n| n.text().to_string()),\n                 ret_type: node.name().map(|n| n.text().to_string()),\n                 parameters: params,\n@@ -128,6 +142,8 @@ impl FunctionSignature {\n             FunctionSignature {\n                 kind: CallableKind::VariantConstructor,\n                 visibility: None,\n+                // Do we need `const`?\n+                qualifier: Default::default(),\n                 name: Some(name),\n                 ret_type: None,\n                 parameters: params,\n@@ -151,6 +167,7 @@ impl FunctionSignature {\n             FunctionSignature {\n                 kind: CallableKind::Macro,\n                 visibility: None,\n+                qualifier: Default::default(),\n                 name: node.name().map(|n| n.text().to_string()),\n                 ret_type: None,\n                 parameters: params,\n@@ -223,6 +240,12 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n         FunctionSignature {\n             kind: CallableKind::Function,\n             visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n+            qualifier: FunctionQualifier {\n+                is_async: node.async_token().is_some(),\n+                is_const: node.const_token().is_some(),\n+                is_unsafe: node.unsafe_token().is_some(),\n+                extern_abi: node.abi().map(|n| n.to_string()),\n+            },\n             name: node.name().map(|n| n.text().to_string()),\n             ret_type: node\n                 .ret_type()\n@@ -246,6 +269,23 @@ impl Display for FunctionSignature {\n             write!(f, \"{} \", t)?;\n         }\n \n+        if self.qualifier.is_async {\n+            write!(f, \"async \")?;\n+        }\n+\n+        if self.qualifier.is_const {\n+            write!(f, \"const \")?;\n+        }\n+\n+        if self.qualifier.is_unsafe {\n+            write!(f, \"unsafe \")?;\n+        }\n+\n+        if let Some(extern_abi) = &self.qualifier.extern_abi {\n+            // Keyword `extern` is included in the string.\n+            write!(f, \"{} \", extern_abi)?;\n+        }\n+\n         if let Some(name) = &self.name {\n             match self.kind {\n                 CallableKind::Function => write!(f, \"fn {}\", name)?,"}, {"sha": "a62f598f0db82e0f0af12ecd5f36de507aa3453a", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -844,4 +844,29 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"fn foo()\\n```\\n\\n<- `\\u{3000}` here\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_function_show_qualifiers() {\n+        check_hover_result(\n+            \"\n+            //- /lib.rs\n+            async fn foo<|>() {}\n+            \",\n+            &[\"async fn foo()\"],\n+        );\n+        check_hover_result(\n+            \"\n+            //- /lib.rs\n+            pub const unsafe fn foo<|>() {}\n+            \",\n+            &[\"pub const unsafe fn foo()\"],\n+        );\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            pub(crate) async unsafe extern \"C\" fn foo<|>() {}\n+            \"#,\n+            &[r#\"pub(crate) async unsafe extern \"C\" fn foo()\"#],\n+        );\n+    }\n }"}, {"sha": "d0def7eaafd091e3301f045a6cf2549abb66461f", "filename": "crates/ra_ide/src/join_lines.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -131,6 +131,9 @@ fn has_comma_after(node: &SyntaxNode) -> bool {\n fn join_single_expr_block(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n     let block = ast::Block::cast(token.parent())?;\n     let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n+    if !block_expr.is_standalone() {\n+        return None;\n+    }\n     let expr = extract_trivial_expression(&block_expr)?;\n \n     let block_range = block_expr.syntax().text_range();\n@@ -662,4 +665,67 @@ fn main() {\n         \",\n         )\n     }\n+\n+    #[test]\n+    fn join_lines_mandatory_blocks_block() {\n+        check_join_lines(\n+            r\"\n+<|>fn foo() {\n+    92\n+}\n+        \",\n+            r\"\n+<|>fn foo() { 92\n+}\n+        \",\n+        );\n+\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    <|>if true {\n+        92\n+    }\n+}\n+        \",\n+            r\"\n+fn foo() {\n+    <|>if true { 92\n+    }\n+}\n+        \",\n+        );\n+\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    <|>loop {\n+        92\n+    }\n+}\n+        \",\n+            r\"\n+fn foo() {\n+    <|>loop { 92\n+    }\n+}\n+        \",\n+        );\n+\n+        check_join_lines(\n+            r\"\n+fn foo() {\n+    <|>unsafe {\n+        92\n+    }\n+}\n+        \",\n+            r\"\n+fn foo() {\n+    <|>unsafe { 92\n+    }\n+}\n+        \",\n+        );\n+    }\n }"}, {"sha": "76aa601cb56c4561e5416446d7e54aef0d79c688", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -84,7 +84,7 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n         T![box] => box_expr(p, None),\n         T![for] => for_expr(p, None),\n         T![while] => while_expr(p, None),\n-        T![try] => try_block_expr(p, None),\n+        T![try] => try_expr(p, None),\n         LIFETIME if la == T![:] => {\n             let m = p.start();\n             label(p);\n@@ -134,7 +134,7 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n         }\n     };\n     let blocklike = match done.kind() {\n-        IF_EXPR | WHILE_EXPR | FOR_EXPR | LOOP_EXPR | MATCH_EXPR | BLOCK_EXPR | TRY_BLOCK_EXPR => {\n+        IF_EXPR | WHILE_EXPR | FOR_EXPR | LOOP_EXPR | MATCH_EXPR | BLOCK_EXPR | TRY_EXPR => {\n             BlockLike::Block\n         }\n         _ => BlockLike::NotBlock,\n@@ -532,9 +532,25 @@ fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n // fn foo() {\n //     let _ = try {};\n // }\n-fn try_block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n+fn try_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![try]));\n     let m = m.unwrap_or_else(|| p.start());\n+    // Special-case `try!` as macro.\n+    // This is a hack until we do proper edition support\n+    if p.nth_at(1, T![!]) {\n+        // test try_macro_fallback\n+        // fn foo() { try!(Ok(())); }\n+        let path = p.start();\n+        let path_segment = p.start();\n+        let name_ref = p.start();\n+        p.bump_remap(IDENT);\n+        name_ref.complete(p, NAME_REF);\n+        path_segment.complete(p, PATH_SEGMENT);\n+        path.complete(p, PATH);\n+        let _block_like = items::macro_call_after_excl(p);\n+        return m.complete(p, MACRO_CALL);\n+    }\n+\n     p.bump(T![try]);\n     block(p);\n     m.complete(p, TRY_EXPR)"}, {"sha": "1503a87300fa321a1a5dbd2313700f0ed6aa4285", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -415,6 +415,17 @@ pub(super) fn macro_call_after_excl(p: &mut Parser) -> BlockLike {\n     if p.at(IDENT) {\n         name(p);\n     }\n+    // Special-case `macro_rules! try`.\n+    // This is a hack until we do proper edition support\n+\n+    // test try_macro_rules\n+    // macro_rules! try { () => {} }\n+    if p.at(T![try]) {\n+        let m = p.start();\n+        p.bump_remap(IDENT);\n+        m.complete(p, NAME);\n+    }\n+\n     match p.current() {\n         T!['{'] => {\n             token_tree(p);"}, {"sha": "3a0c7a31a852b2a544febe467832f6081143c2e9", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -47,7 +47,7 @@ fn use_tree(p: &mut Parser, top_level: bool) {\n         // use {crate::path::from::root, or::path::from::crate_name}; // Rust 2018 (with a crate named `or`)\n         // use {path::from::root}; // Rust 2015\n         // use ::{some::arbritrary::path}; // Rust 2015\n-        // use ::{{{crate::export}}}; // Nonsensical but perfectly legal nestnig\n+        // use ::{{{root::export}}}; // Nonsensical but perfectly legal nesting\n         T!['{'] => {\n             use_tree_list(p);\n         }"}, {"sha": "ab727ed7e18dcbeadf78ef7231fb9d843ef0c803", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -191,7 +191,6 @@ pub enum SyntaxKind {\n     RECORD_LIT,\n     RECORD_FIELD_LIST,\n     RECORD_FIELD,\n-    TRY_BLOCK_EXPR,\n     BOX_EXPR,\n     CALL_EXPR,\n     INDEX_EXPR,"}, {"sha": "1437794c9e23a3030a97bda224f6dc9cadaf8437", "filename": "crates/ra_proc_macro_srv/src/cli.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,15 +1,17 @@\n //! Driver for proc macro server\n \n-use crate::{expand_task, list_macros};\n+use crate::ProcMacroSrv;\n use ra_proc_macro::msg::{self, Message};\n use std::io;\n \n pub fn run() -> io::Result<()> {\n+    let mut srv = ProcMacroSrv::default();\n+\n     while let Some(req) = read_request()? {\n         let res = match req {\n-            msg::Request::ListMacro(task) => Ok(msg::Response::ListMacro(list_macros(&task))),\n+            msg::Request::ListMacro(task) => srv.list_macros(&task).map(msg::Response::ListMacro),\n             msg::Request::ExpansionMacro(task) => {\n-                expand_task(&task).map(msg::Response::ExpansionMacro)\n+                srv.expand(&task).map(msg::Response::ExpansionMacro)\n             }\n         };\n "}, {"sha": "aa84e951cd5601636490c9ffe2f0638a7c2ade1c", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 69, "deletions": 44, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -2,13 +2,12 @@\n \n use crate::{proc_macro::bridge, rustc_server::TokenStream};\n use std::fs::File;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n use goblin::{mach::Mach, Object};\n use libloading::Library;\n use memmap::Mmap;\n use ra_proc_macro::ProcMacroKind;\n-\n use std::io;\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n@@ -109,23 +108,21 @@ impl ProcMacroLibraryLibloading {\n     }\n }\n \n-type ProcMacroLibraryImpl = ProcMacroLibraryLibloading;\n-\n pub struct Expander {\n-    libs: Vec<ProcMacroLibraryImpl>,\n+    inner: ProcMacroLibraryLibloading,\n }\n \n impl Expander {\n-    pub fn new(lib: &Path) -> Result<Expander, String> {\n+    pub fn new(lib: &Path) -> io::Result<Expander> {\n         // Some libraries for dynamic loading require canonicalized path even when it is\n         // already absolute\n-        let lib = lib\n-            .canonicalize()\n-            .unwrap_or_else(|err| panic!(\"Cannot canonicalize {}: {:?}\", lib.display(), err));\n+        let lib = lib.canonicalize()?;\n+\n+        let lib = ensure_file_with_lock_free_access(&lib)?;\n \n-        let library = ProcMacroLibraryImpl::open(&lib).map_err(|e| e.to_string())?;\n+        let library = ProcMacroLibraryLibloading::open(&lib)?;\n \n-        Ok(Expander { libs: vec![library] })\n+        Ok(Expander { inner: library })\n     }\n \n     pub fn expand(\n@@ -141,48 +138,46 @@ impl Expander {\n                 TokenStream::with_subtree(attr.clone())\n             });\n \n-        for lib in &self.libs {\n-            for proc_macro in &lib.exported_macros {\n-                match proc_macro {\n-                    bridge::client::ProcMacro::CustomDerive { trait_name, client, .. }\n-                        if *trait_name == macro_name =>\n-                    {\n-                        let res = client.run(\n-                            &crate::proc_macro::bridge::server::SameThread,\n-                            crate::rustc_server::Rustc::default(),\n-                            parsed_body,\n-                        );\n-                        return res.map(|it| it.subtree);\n-                    }\n-                    bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n-                        let res = client.run(\n-                            &crate::proc_macro::bridge::server::SameThread,\n-                            crate::rustc_server::Rustc::default(),\n-                            parsed_body,\n-                        );\n-                        return res.map(|it| it.subtree);\n-                    }\n-                    bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n-                        let res = client.run(\n-                            &crate::proc_macro::bridge::server::SameThread,\n-                            crate::rustc_server::Rustc::default(),\n-                            parsed_attributes,\n-                            parsed_body,\n-                        );\n-                        return res.map(|it| it.subtree);\n-                    }\n-                    _ => continue,\n+        for proc_macro in &self.inner.exported_macros {\n+            match proc_macro {\n+                bridge::client::ProcMacro::CustomDerive { trait_name, client, .. }\n+                    if *trait_name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &crate::proc_macro::bridge::server::SameThread,\n+                        crate::rustc_server::Rustc::default(),\n+                        parsed_body,\n+                    );\n+                    return res.map(|it| it.subtree);\n+                }\n+                bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n+                    let res = client.run(\n+                        &crate::proc_macro::bridge::server::SameThread,\n+                        crate::rustc_server::Rustc::default(),\n+                        parsed_body,\n+                    );\n+                    return res.map(|it| it.subtree);\n+                }\n+                bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n+                    let res = client.run(\n+                        &crate::proc_macro::bridge::server::SameThread,\n+                        crate::rustc_server::Rustc::default(),\n+                        parsed_attributes,\n+                        parsed_body,\n+                    );\n+                    return res.map(|it| it.subtree);\n                 }\n+                _ => continue,\n             }\n         }\n \n         Err(bridge::PanicMessage::String(\"Nothing to expand\".to_string()))\n     }\n \n     pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        self.libs\n+        self.inner\n+            .exported_macros\n             .iter()\n-            .flat_map(|it| &it.exported_macros)\n             .map(|proc_macro| match proc_macro {\n                 bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n                     (trait_name.to_string(), ProcMacroKind::CustomDerive)\n@@ -197,3 +192,33 @@ impl Expander {\n             .collect()\n     }\n }\n+\n+/// Copy the dylib to temp directory to prevent locking in Windows\n+#[cfg(windows)]\n+fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n+    use std::{ffi::OsString, time::SystemTime};\n+\n+    let mut to = std::env::temp_dir();\n+\n+    let file_name = path.file_name().ok_or_else(|| {\n+        io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            format!(\"File path is invalid: {}\", path.display()),\n+        )\n+    })?;\n+\n+    // generate a time deps unique number\n+    let t = SystemTime::now().duration_since(std::time::UNIX_EPOCH).expect(\"Time went backwards\");\n+\n+    let mut unique_name = OsString::from(t.as_millis().to_string());\n+    unique_name.push(file_name);\n+\n+    to.push(unique_name);\n+    std::fs::copy(path, &to).unwrap();\n+    Ok(to)\n+}\n+\n+#[cfg(unix)]\n+fn ensure_file_with_lock_free_access(path: &Path) -> io::Result<PathBuf> {\n+    Ok(path.to_path_buf())\n+}"}, {"sha": "922bb84bbfcda92336fcc3f9b35536900547159b", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -21,28 +21,46 @@ mod dylib;\n \n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n-use std::path::Path;\n+use std::{\n+    collections::{hash_map::Entry, HashMap},\n+    fs,\n+    path::{Path, PathBuf},\n+    time::SystemTime,\n+};\n \n-pub(crate) fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n-    let expander = create_expander(&task.lib);\n+#[derive(Default)]\n+pub(crate) struct ProcMacroSrv {\n+    expanders: HashMap<(PathBuf, SystemTime), dylib::Expander>,\n+}\n \n-    match expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref()) {\n-        Ok(expansion) => Ok(ExpansionResult { expansion }),\n-        Err(msg) => {\n-            Err(format!(\"Cannot perform expansion for {}: error {:?}\", &task.macro_name, msg))\n+impl ProcMacroSrv {\n+    pub fn expand(&mut self, task: &ExpansionTask) -> Result<ExpansionResult, String> {\n+        let expander = self.expander(&task.lib)?;\n+        match expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref()) {\n+            Ok(expansion) => Ok(ExpansionResult { expansion }),\n+            Err(msg) => {\n+                Err(format!(\"Cannot perform expansion for {}: error {:?}\", &task.macro_name, msg))\n+            }\n         }\n     }\n-}\n \n-pub(crate) fn list_macros(task: &ListMacrosTask) -> ListMacrosResult {\n-    let expander = create_expander(&task.lib);\n+    pub fn list_macros(&mut self, task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n+        let expander = self.expander(&task.lib)?;\n+        Ok(ListMacrosResult { macros: expander.list_macros() })\n+    }\n \n-    ListMacrosResult { macros: expander.list_macros() }\n-}\n+    fn expander(&mut self, path: &Path) -> Result<&dylib::Expander, String> {\n+        let time = fs::metadata(path).and_then(|it| it.modified()).map_err(|err| {\n+            format!(\"Failed to get file metadata for {}: {:?}\", path.display(), err)\n+        })?;\n \n-fn create_expander(lib: &Path) -> dylib::Expander {\n-    dylib::Expander::new(lib)\n-        .unwrap_or_else(|err| panic!(\"Cannot create expander for {}: {:?}\", lib.display(), err))\n+        Ok(match self.expanders.entry((path.to_path_buf(), time)) {\n+            Entry::Vacant(v) => v.insert(dylib::Expander::new(path).map_err(|err| {\n+                format!(\"Cannot create expander for {}: {:?}\", path.display(), err)\n+            })?),\n+            Entry::Occupied(e) => e.into_mut(),\n+        })\n+    }\n }\n \n pub mod cli;"}, {"sha": "646a427c5653546f4638b319c681509a11cc16eb", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,7 +1,7 @@\n //! utils used in proc-macro tests\n \n use crate::dylib;\n-use crate::list_macros;\n+use crate::ProcMacroSrv;\n pub use difference::Changeset as __Changeset;\n use ra_proc_macro::ListMacrosTask;\n use std::str::FromStr;\n@@ -59,7 +59,7 @@ pub fn assert_expand(\n pub fn list(crate_name: &str, version: &str) -> Vec<String> {\n     let path = fixtures::dylib_path(crate_name, version);\n     let task = ListMacrosTask { lib: path };\n-\n-    let res = list_macros(&task);\n+    let mut srv = ProcMacroSrv::default();\n+    let res = srv.list_macros(&task).unwrap();\n     res.macros.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()\n }"}, {"sha": "a3f5321fb3c1619ce66fee30155443d1017d96ca", "filename": "crates/ra_prof/src/hprof.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fhprof.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -30,8 +30,9 @@ pub fn init_from(spec: &str) {\n pub type Label = &'static str;\n \n /// This function starts a profiling scope in the current execution stack with a given description.\n-/// It returns a Profile structure and measure elapsed time between this method invocation and Profile structure drop.\n-/// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n+/// It returns a `Profile` struct that measures elapsed time between this method invocation and `Profile` struct drop.\n+/// It supports nested profiling scopes in case when this function is invoked multiple times at the execution stack.\n+/// In this case the profiling information will be nested at the output.\n /// Profiling information is being printed in the stderr.\n ///\n /// # Example\n@@ -58,36 +59,35 @@ pub type Label = &'static str;\n /// ```\n pub fn profile(label: Label) -> Profiler {\n     assert!(!label.is_empty());\n-    let enabled = PROFILING_ENABLED.load(Ordering::Relaxed)\n-        && PROFILE_STACK.with(|stack| stack.borrow_mut().push(label));\n-    let label = if enabled { Some(label) } else { None };\n-    Profiler { label, detail: None }\n+\n+    if PROFILING_ENABLED.load(Ordering::Relaxed)\n+        && PROFILE_STACK.with(|stack| stack.borrow_mut().push(label))\n+    {\n+        Profiler(Some(ProfilerImpl { label, detail: None }))\n+    } else {\n+        Profiler(None)\n+    }\n }\n \n-pub struct Profiler {\n-    label: Option<Label>,\n+pub struct Profiler(Option<ProfilerImpl>);\n+\n+struct ProfilerImpl {\n+    label: Label,\n     detail: Option<String>,\n }\n \n impl Profiler {\n     pub fn detail(mut self, detail: impl FnOnce() -> String) -> Profiler {\n-        if self.label.is_some() {\n-            self.detail = Some(detail())\n+        if let Some(profiler) = &mut self.0 {\n+            profiler.detail = Some(detail())\n         }\n         self\n     }\n }\n \n-impl Drop for Profiler {\n+impl Drop for ProfilerImpl {\n     fn drop(&mut self) {\n-        match self {\n-            Profiler { label: Some(label), detail } => {\n-                PROFILE_STACK.with(|stack| {\n-                    stack.borrow_mut().pop(label, detail.take());\n-                });\n-            }\n-            Profiler { label: None, .. } => (),\n-        }\n+        PROFILE_STACK.with(|it| it.borrow_mut().pop(self.label, self.detail.take()));\n     }\n }\n \n@@ -179,21 +179,18 @@ impl ProfileStack {\n     pub fn pop(&mut self, label: Label, detail: Option<String>) {\n         let start = self.starts.pop().unwrap();\n         let duration = start.elapsed();\n-        let level = self.starts.len();\n         self.messages.finish(Message { duration, label, detail });\n-        if level == 0 {\n+        if self.starts.is_empty() {\n             let longer_than = self.filter.longer_than;\n             // Convert to millis for comparison to avoid problems with rounding\n             // (otherwise we could print `0ms` despite user's `>0` filter when\n             // `duration` is just a few nanos).\n             if duration.as_millis() > longer_than.as_millis() {\n-                let stderr = stderr();\n                 if let Some(root) = self.messages.root() {\n-                    print(&self.messages, root, 0, longer_than, &mut stderr.lock());\n+                    print(&self.messages, root, 0, longer_than, &mut stderr().lock());\n                 }\n             }\n             self.messages.clear();\n-            assert!(self.starts.is_empty())\n         }\n     }\n }"}, {"sha": "521ca8ab8eda3a18034d0b44d334adad5f1a2d82", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -16,7 +16,9 @@ use crate::{\n };\n \n pub use self::{\n-    expr_extensions::{ArrayExprKind, BinOp, ElseBranch, LiteralKind, PrefixOp, RangeOp},\n+    expr_extensions::{\n+        ArrayExprKind, BinOp, BlockModifier, ElseBranch, LiteralKind, PrefixOp, RangeOp,\n+    },\n     extensions::{\n         AttrKind, FieldKind, NameOrNameRef, PathSegmentKind, SelfParamKind, SlicePatComponents,\n         StructKind, TypeBoundKind, VisibilityKind,\n@@ -242,6 +244,21 @@ fn test_comments_preserve_trailing_whitespace() {\n     );\n }\n \n+#[test]\n+fn test_four_slash_line_comment() {\n+    let file = SourceFile::parse(\n+        r#\"\n+        //// too many slashes to be a doc comment\n+        /// doc comment\n+        mod foo {}\n+        \"#,\n+    )\n+    .ok()\n+    .unwrap();\n+    let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n+    assert_eq!(\"doc comment\", module.doc_comment_text().unwrap());\n+}\n+\n #[test]\n fn test_where_predicates() {\n     fn assert_bound(text: &str, bound: Option<TypeBound>) {"}, {"sha": "329c80749d30157c20c9d7b1e220f21c927e46e5", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -16,7 +16,7 @@ impl ast::Expr {\n             | ast::Expr::WhileExpr(_)\n             | ast::Expr::BlockExpr(_)\n             | ast::Expr::MatchExpr(_)\n-            | ast::Expr::TryBlockExpr(_) => true,\n+            | ast::Expr::TryExpr(_) => true,\n             _ => false,\n         }\n     }\n@@ -359,7 +359,22 @@ impl ast::Literal {\n     }\n }\n \n+pub enum BlockModifier {\n+    Async(SyntaxToken),\n+    Unsafe(SyntaxToken),\n+}\n+\n impl ast::BlockExpr {\n+    pub fn modifier(&self) -> Option<BlockModifier> {\n+        if let Some(token) = self.async_token() {\n+            return Some(BlockModifier::Async(token));\n+        }\n+        if let Some(token) = self.unsafe_token() {\n+            return Some(BlockModifier::Unsafe(token));\n+        }\n+        None\n+    }\n+\n     /// false if the block is an intrinsic part of the syntax and can't be\n     /// replaced with arbitrary expression.\n     ///\n@@ -368,12 +383,15 @@ impl ast::BlockExpr {\n     /// const FOO: () = { stand_alone };\n     /// ```\n     pub fn is_standalone(&self) -> bool {\n-        let kind = match self.syntax().parent() {\n+        if self.modifier().is_some() {\n+            return false;\n+        }\n+        let parent = match self.syntax().parent() {\n+            Some(it) => it,\n             None => return true,\n-            Some(it) => it.kind(),\n         };\n-        match kind {\n-            FN_DEF | MATCH_ARM | IF_EXPR | WHILE_EXPR | LOOP_EXPR | TRY_BLOCK_EXPR => false,\n+        match parent.kind() {\n+            FN_DEF | IF_EXPR | WHILE_EXPR | LOOP_EXPR => false,\n             _ => true,\n         }\n     }"}, {"sha": "81260680f91b1f104d95f4dadc330b9442501776", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -475,16 +475,6 @@ impl LoopExpr {\n     pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TryBlockExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for TryBlockExpr {}\n-impl TryBlockExpr {\n-    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n-    pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ForExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -554,6 +544,7 @@ impl ast::AttrsOwner for BlockExpr {}\n impl BlockExpr {\n     pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n     pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n     pub fn block(&self) -> Option<Block> { support::child(&self.syntax) }\n }\n \n@@ -1249,6 +1240,7 @@ pub struct PathSegment {\n }\n impl PathSegment {\n     pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n     pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n@@ -1473,7 +1465,6 @@ pub enum Expr {\n     FieldExpr(FieldExpr),\n     AwaitExpr(AwaitExpr),\n     TryExpr(TryExpr),\n-    TryBlockExpr(TryBlockExpr),\n     CastExpr(CastExpr),\n     RefExpr(RefExpr),\n     PrefixExpr(PrefixExpr),\n@@ -1956,17 +1947,6 @@ impl AstNode for LoopExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TryBlockExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_BLOCK_EXPR }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for ForExpr {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -3308,9 +3288,6 @@ impl From<AwaitExpr> for Expr {\n impl From<TryExpr> for Expr {\n     fn from(node: TryExpr) -> Expr { Expr::TryExpr(node) }\n }\n-impl From<TryBlockExpr> for Expr {\n-    fn from(node: TryBlockExpr) -> Expr { Expr::TryBlockExpr(node) }\n-}\n impl From<CastExpr> for Expr {\n     fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }\n }\n@@ -3341,9 +3318,8 @@ impl AstNode for Expr {\n             TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR\n             | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL\n             | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | RECORD_LIT | CALL_EXPR | INDEX_EXPR\n-            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | TRY_BLOCK_EXPR\n-            | CAST_EXPR | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL\n-            | BOX_EXPR => true,\n+            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | CAST_EXPR | REF_EXPR\n+            | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL | BOX_EXPR => true,\n             _ => false,\n         }\n     }\n@@ -3371,7 +3347,6 @@ impl AstNode for Expr {\n             FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),\n             AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),\n             TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),\n-            TRY_BLOCK_EXPR => Expr::TryBlockExpr(TryBlockExpr { syntax }),\n             CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),\n             REF_EXPR => Expr::RefExpr(RefExpr { syntax }),\n             PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),\n@@ -3408,7 +3383,6 @@ impl AstNode for Expr {\n             Expr::FieldExpr(it) => &it.syntax,\n             Expr::AwaitExpr(it) => &it.syntax,\n             Expr::TryExpr(it) => &it.syntax,\n-            Expr::TryBlockExpr(it) => &it.syntax,\n             Expr::CastExpr(it) => &it.syntax,\n             Expr::RefExpr(it) => &it.syntax,\n             Expr::PrefixExpr(it) => &it.syntax,\n@@ -3889,11 +3863,6 @@ impl std::fmt::Display for LoopExpr {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TryBlockExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for ForExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "492088353254e9bcc18ce67d4d774ae4725ccd91", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -22,8 +22,7 @@ pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n     path_from_text(&format!(\"{}::{}\", qual, segment))\n }\n-\n-pub fn path_from_text(text: &str) -> ast::Path {\n+fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n "}, {"sha": "74906d8a62efe732ef6f4b765e0c132264327e7e", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -13,7 +13,12 @@ impl Comment {\n     }\n \n     pub fn prefix(&self) -> &'static str {\n-        prefix_by_kind(self.kind())\n+        for (prefix, k) in COMMENT_PREFIX_TO_KIND.iter() {\n+            if *k == self.kind() && self.text().starts_with(prefix) {\n+                return prefix;\n+            }\n+        }\n+        unreachable!()\n     }\n }\n \n@@ -48,6 +53,7 @@ pub enum CommentPlacement {\n const COMMENT_PREFIX_TO_KIND: &[(&str, CommentKind)] = {\n     use {CommentPlacement::*, CommentShape::*};\n     &[\n+        (\"////\", CommentKind { shape: Line, doc: None }),\n         (\"///\", CommentKind { shape: Line, doc: Some(Outer) }),\n         (\"//!\", CommentKind { shape: Line, doc: Some(Inner) }),\n         (\"/**\", CommentKind { shape: Block, doc: Some(Outer) }),\n@@ -69,15 +75,6 @@ fn kind_by_prefix(text: &str) -> CommentKind {\n     panic!(\"bad comment text: {:?}\", text)\n }\n \n-fn prefix_by_kind(kind: CommentKind) -> &'static str {\n-    for (prefix, k) in COMMENT_PREFIX_TO_KIND.iter() {\n-        if *k == kind {\n-            return prefix;\n-        }\n-    }\n-    unreachable!()\n-}\n-\n impl Whitespace {\n     pub fn spans_multiple_lines(&self) -> bool {\n         let text = self.text();"}, {"sha": "f0b3dec631f41c431205008b6ce57bf5572cd194", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -96,6 +96,7 @@ pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n                 ast::RecordField(it) => validate_numeric_name(it.name_ref(), &mut errors),\n                 ast::Visibility(it) => validate_visibility(it, &mut errors),\n                 ast::RangeExpr(it) => validate_range_expr(it, &mut errors),\n+                ast::PathSegment(it) => validate_crate_keyword_in_path_segment(it, &mut errors),\n                 _ => (),\n             }\n         }\n@@ -222,3 +223,60 @@ fn validate_range_expr(expr: ast::RangeExpr, errors: &mut Vec<SyntaxError>) {\n         ));\n     }\n }\n+\n+fn validate_crate_keyword_in_path_segment(\n+    segment: ast::PathSegment,\n+    errors: &mut Vec<SyntaxError>,\n+) {\n+    const ERR_MSG: &str = \"The `crate` keyword is only allowed as the first segment of a path\";\n+\n+    let crate_token = match segment.crate_token() {\n+        None => return,\n+        Some(it) => it,\n+    };\n+\n+    // Disallow both ::crate and foo::crate\n+    let mut path = segment.parent_path();\n+    if segment.coloncolon_token().is_some() || path.qualifier().is_some() {\n+        errors.push(SyntaxError::new(ERR_MSG, crate_token.text_range()));\n+        return;\n+    }\n+\n+    // For expressions and types, validation is complete, but we still have\n+    // to handle invalid UseItems like this:\n+    //\n+    //      use foo:{crate::bar::baz};\n+    //\n+    // To handle this we must inspect the parent `UseItem`s and `UseTree`s\n+    // but right now we're looking deep inside the nested `Path` nodes because\n+    // `Path`s are left-associative:\n+    //\n+    //   ((crate)::bar)::baz)\n+    //       ^ current value of path\n+    //\n+    // So we need to climb to the top\n+    while let Some(parent) = path.parent_path() {\n+        path = parent;\n+    }\n+\n+    // Now that we've found the whole path we need to see if there's a prefix\n+    // somewhere in the UseTree hierarchy. This check is arbitrarily deep\n+    // because rust allows arbitrary nesting like so:\n+    //\n+    // use {foo::{{{{crate::bar::baz}}}}};\n+    for node in path.syntax().ancestors().skip(1) {\n+        match_ast! {\n+            match node {\n+                ast::UseTree(it) => if let Some(tree_path) = it.path() {\n+                    // Even a top-level path exists within a `UseTree` so we must explicitly\n+                    // allow our path but disallow anything else\n+                    if tree_path != path {\n+                        errors.push(SyntaxError::new(ERR_MSG, crate_token.text_range()));\n+                    }\n+                },\n+                ast::UseTreeList(_it) => continue,\n+                _ => return,\n+            }\n+        };\n+    }\n+}"}, {"sha": "d2a5492733b7b239f9c6c9b78f2da3ce852e8c68", "filename": "crates/ra_syntax/test_data/parser/err/0040_illegal_crate_kw_location.rast", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0040_illegal_crate_kw_location.rast", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0040_illegal_crate_kw_location.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0040_illegal_crate_kw_location.rast?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -0,0 +1,91 @@\n+SOURCE_FILE@0..98\n+  USE_ITEM@0..12\n+    USE_KW@0..3 \"use\"\n+    WHITESPACE@3..4 \" \"\n+    USE_TREE@4..11\n+      PATH@4..11\n+        PATH_SEGMENT@4..11\n+          COLON2@4..6 \"::\"\n+          CRATE_KW@6..11 \"crate\"\n+    SEMICOLON@11..12 \";\"\n+  WHITESPACE@12..13 \"\\n\"\n+  USE_ITEM@13..54\n+    USE_KW@13..16 \"use\"\n+    WHITESPACE@16..17 \" \"\n+    USE_TREE@17..53\n+      USE_TREE_LIST@17..53\n+        L_CURLY@17..18 \"{\"\n+        USE_TREE@18..23\n+          PATH@18..23\n+            PATH_SEGMENT@18..23\n+              CRATE_KW@18..23 \"crate\"\n+        COMMA@23..24 \",\"\n+        WHITESPACE@24..25 \" \"\n+        USE_TREE@25..52\n+          PATH@25..28\n+            PATH_SEGMENT@25..28\n+              NAME_REF@25..28\n+                IDENT@25..28 \"foo\"\n+          COLON2@28..30 \"::\"\n+          USE_TREE_LIST@30..52\n+            L_CURLY@30..31 \"{\"\n+            USE_TREE@31..51\n+              PATH@31..51\n+                PATH@31..46\n+                  PATH@31..41\n+                    PATH@31..36\n+                      PATH_SEGMENT@31..36\n+                        CRATE_KW@31..36 \"crate\"\n+                    COLON2@36..38 \"::\"\n+                    PATH_SEGMENT@38..41\n+                      NAME_REF@38..41\n+                        IDENT@38..41 \"foo\"\n+                  COLON2@41..43 \"::\"\n+                  PATH_SEGMENT@43..46\n+                    NAME_REF@43..46\n+                      IDENT@43..46 \"bar\"\n+                COLON2@46..48 \"::\"\n+                PATH_SEGMENT@48..51\n+                  NAME_REF@48..51\n+                    IDENT@48..51 \"baz\"\n+            R_CURLY@51..52 \"}\"\n+        R_CURLY@52..53 \"}\"\n+    SEMICOLON@53..54 \";\"\n+  WHITESPACE@54..55 \"\\n\"\n+  USE_ITEM@55..72\n+    USE_KW@55..58 \"use\"\n+    WHITESPACE@58..59 \" \"\n+    USE_TREE@59..71\n+      PATH@59..71\n+        PATH@59..64\n+          PATH_SEGMENT@59..64\n+            NAME_REF@59..64\n+              IDENT@59..64 \"hello\"\n+        COLON2@64..66 \"::\"\n+        PATH_SEGMENT@66..71\n+          CRATE_KW@66..71 \"crate\"\n+    SEMICOLON@71..72 \";\"\n+  WHITESPACE@72..73 \"\\n\"\n+  USE_ITEM@73..97\n+    USE_KW@73..76 \"use\"\n+    WHITESPACE@76..77 \" \"\n+    USE_TREE@77..96\n+      PATH@77..96\n+        PATH@77..89\n+          PATH@77..82\n+            PATH_SEGMENT@77..82\n+              NAME_REF@77..82\n+                IDENT@77..82 \"hello\"\n+          COLON2@82..84 \"::\"\n+          PATH_SEGMENT@84..89\n+            CRATE_KW@84..89 \"crate\"\n+        COLON2@89..91 \"::\"\n+        PATH_SEGMENT@91..96\n+          NAME_REF@91..96\n+            IDENT@91..96 \"there\"\n+    SEMICOLON@96..97 \";\"\n+  WHITESPACE@97..98 \"\\n\"\n+error 6..11: The `crate` keyword is only allowed as the first segment of a path\n+error 31..36: The `crate` keyword is only allowed as the first segment of a path\n+error 66..71: The `crate` keyword is only allowed as the first segment of a path\n+error 84..89: The `crate` keyword is only allowed as the first segment of a path"}, {"sha": "508def2c7ef503bbdadcdc19ef7b550da9260214", "filename": "crates/ra_syntax/test_data/parser/err/0040_illegal_crate_kw_location.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0040_illegal_crate_kw_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0040_illegal_crate_kw_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0040_illegal_crate_kw_location.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -0,0 +1,4 @@\n+use ::crate;\n+use {crate, foo::{crate::foo::bar::baz}};\n+use hello::crate;\n+use hello::crate::there;"}, {"sha": "cf3a90400a802fb6c97af7dcf93adcceeea99a0a", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0002_use_tree_list.rast", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0002_use_tree_list.rast", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0002_use_tree_list.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0002_use_tree_list.rast?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,4 +1,4 @@\n-SOURCE_FILE@0..250\n+SOURCE_FILE@0..249\n   USE_ITEM@0..58\n     USE_KW@0..3 \"use\"\n     WHITESPACE@3..4 \" \"\n@@ -104,32 +104,33 @@ SOURCE_FILE@0..250\n   WHITESPACE@166..167 \" \"\n   COMMENT@167..179 \"// Rust 2015\"\n   WHITESPACE@179..180 \"\\n\"\n-  USE_ITEM@180..206\n+  USE_ITEM@180..205\n     USE_KW@180..183 \"use\"\n     WHITESPACE@183..184 \" \"\n-    USE_TREE@184..205\n+    USE_TREE@184..204\n       COLON2@184..186 \"::\"\n-      USE_TREE_LIST@186..205\n+      USE_TREE_LIST@186..204\n         L_CURLY@186..187 \"{\"\n-        USE_TREE@187..204\n-          USE_TREE_LIST@187..204\n+        USE_TREE@187..203\n+          USE_TREE_LIST@187..203\n             L_CURLY@187..188 \"{\"\n-            USE_TREE@188..203\n-              USE_TREE_LIST@188..203\n+            USE_TREE@188..202\n+              USE_TREE_LIST@188..202\n                 L_CURLY@188..189 \"{\"\n-                USE_TREE@189..202\n-                  PATH@189..202\n-                    PATH@189..194\n-                      PATH_SEGMENT@189..194\n-                        CRATE_KW@189..194 \"crate\"\n-                    COLON2@194..196 \"::\"\n-                    PATH_SEGMENT@196..202\n-                      NAME_REF@196..202\n-                        IDENT@196..202 \"export\"\n-                R_CURLY@202..203 \"}\"\n-            R_CURLY@203..204 \"}\"\n-        R_CURLY@204..205 \"}\"\n-    SEMICOLON@205..206 \";\"\n-  WHITESPACE@206..207 \" \"\n-  COMMENT@207..249 \"// Nonsensical but pe ...\"\n-  WHITESPACE@249..250 \"\\n\"\n+                USE_TREE@189..201\n+                  PATH@189..201\n+                    PATH@189..193\n+                      PATH_SEGMENT@189..193\n+                        NAME_REF@189..193\n+                          IDENT@189..193 \"root\"\n+                    COLON2@193..195 \"::\"\n+                    PATH_SEGMENT@195..201\n+                      NAME_REF@195..201\n+                        IDENT@195..201 \"export\"\n+                R_CURLY@201..202 \"}\"\n+            R_CURLY@202..203 \"}\"\n+        R_CURLY@203..204 \"}\"\n+    SEMICOLON@204..205 \";\"\n+  WHITESPACE@205..206 \" \"\n+  COMMENT@206..248 \"// Nonsensical but pe ...\"\n+  WHITESPACE@248..249 \"\\n\""}, {"sha": "381cba1e29e084aa06f8562fc108700e570ef03e", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0002_use_tree_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0002_use_tree_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0002_use_tree_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0002_use_tree_list.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,4 +1,4 @@\n use {crate::path::from::root, or::path::from::crate_name}; // Rust 2018 (with a crate named `or`)\n use {path::from::root}; // Rust 2015\n use ::{some::arbritrary::path}; // Rust 2015\n-use ::{{{crate::export}}}; // Nonsensical but perfectly legal nestnig\n+use ::{{{root::export}}}; // Nonsensical but perfectly legal nesting"}, {"sha": "beb6d80104af72a8bfac5d45f97a446cedf1c78b", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0159_try_macro_fallback.rast", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0159_try_macro_fallback.rast", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0159_try_macro_fallback.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0159_try_macro_fallback.rast?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -0,0 +1,35 @@\n+SOURCE_FILE@0..27\n+  FN_DEF@0..26\n+    FN_KW@0..2 \"fn\"\n+    WHITESPACE@2..3 \" \"\n+    NAME@3..6\n+      IDENT@3..6 \"foo\"\n+    PARAM_LIST@6..8\n+      L_PAREN@6..7 \"(\"\n+      R_PAREN@7..8 \")\"\n+    WHITESPACE@8..9 \" \"\n+    BLOCK_EXPR@9..26\n+      BLOCK@9..26\n+        L_CURLY@9..10 \"{\"\n+        WHITESPACE@10..11 \" \"\n+        EXPR_STMT@11..24\n+          MACRO_CALL@11..23\n+            PATH@11..14\n+              PATH_SEGMENT@11..14\n+                NAME_REF@11..14\n+                  IDENT@11..14 \"try\"\n+            BANG@14..15 \"!\"\n+            TOKEN_TREE@15..23\n+              L_PAREN@15..16 \"(\"\n+              IDENT@16..18 \"Ok\"\n+              TOKEN_TREE@18..22\n+                L_PAREN@18..19 \"(\"\n+                TOKEN_TREE@19..21\n+                  L_PAREN@19..20 \"(\"\n+                  R_PAREN@20..21 \")\"\n+                R_PAREN@21..22 \")\"\n+              R_PAREN@22..23 \")\"\n+          SEMICOLON@23..24 \";\"\n+        WHITESPACE@24..25 \" \"\n+        R_CURLY@25..26 \"}\"\n+  WHITESPACE@26..27 \"\\n\""}, {"sha": "61a6b46a0b342f77ef5b8a5ae2526ada5c34589f", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0159_try_macro_fallback.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0159_try_macro_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0159_try_macro_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0159_try_macro_fallback.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -0,0 +1 @@\n+fn foo() { try!(Ok(())); }"}, {"sha": "05b89d1c36902200122eee7907802cd7129f4bde", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0160_try_macro_rules.rast", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0160_try_macro_rules.rast", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0160_try_macro_rules.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0160_try_macro_rules.rast?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -0,0 +1,27 @@\n+SOURCE_FILE@0..30\n+  MACRO_CALL@0..29\n+    PATH@0..11\n+      PATH_SEGMENT@0..11\n+        NAME_REF@0..11\n+          IDENT@0..11 \"macro_rules\"\n+    BANG@11..12 \"!\"\n+    WHITESPACE@12..13 \" \"\n+    NAME@13..16\n+      IDENT@13..16 \"try\"\n+    WHITESPACE@16..17 \" \"\n+    TOKEN_TREE@17..29\n+      L_CURLY@17..18 \"{\"\n+      WHITESPACE@18..19 \" \"\n+      TOKEN_TREE@19..21\n+        L_PAREN@19..20 \"(\"\n+        R_PAREN@20..21 \")\"\n+      WHITESPACE@21..22 \" \"\n+      EQ@22..23 \"=\"\n+      R_ANGLE@23..24 \">\"\n+      WHITESPACE@24..25 \" \"\n+      TOKEN_TREE@25..27\n+        L_CURLY@25..26 \"{\"\n+        R_CURLY@26..27 \"}\"\n+      WHITESPACE@27..28 \" \"\n+      R_CURLY@28..29 \"}\"\n+  WHITESPACE@29..30 \"\\n\""}, {"sha": "2e2ab6e60b641d8abfaaf08e79bc6b114491778a", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0160_try_macro_rules.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0160_try_macro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0160_try_macro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0160_try_macro_rules.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -0,0 +1 @@\n+macro_rules! try { () => {} }"}, {"sha": "0459807fc9d9131d158991899c15831ede85a160", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -20,7 +20,7 @@ globset = \"0.4.4\"\n itertools = \"0.9.0\"\n jod-thread = \"0.1.0\"\n log = \"0.4.8\"\n-lsp-types = { version = \"0.73.0\", features = [\"proposed\"] }\n+lsp-types = { version = \"0.74.0\", features = [\"proposed\"] }\n parking_lot = \"0.10.0\"\n pico-args = \"0.3.1\"\n rand = { version = \"0.7.3\", features = [\"small_rng\"] }\n@@ -39,7 +39,7 @@ ra_prof = { path = \"../ra_prof\" }\n ra_project_model = { path = \"../ra_project_model\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }\n-ra_vfs = \"0.5.2\"\n+ra_vfs = \"0.6.0\"\n \n # This should only be used in CLI\n ra_db = { path = \"../ra_db\" }"}, {"sha": "e22ab8402ec68a5e68693bcf12a0522346333398", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -16,7 +16,7 @@ pub fn server_capabilities() -> ServerCapabilities {\n     ServerCapabilities {\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n             open_close: Some(true),\n-            change: Some(TextDocumentSyncKind::Full),\n+            change: Some(TextDocumentSyncKind::Incremental),\n             will_save: None,\n             will_save_wait_until: None,\n             save: Some(SaveOptions::default()),"}, {"sha": "7be5ebcdb5a0d13599cc5a8d628c48186cc46936", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -150,7 +150,7 @@ impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n             detail: self.detail().map(|it| it.to_string()),\n             filter_text: Some(self.lookup().to_string()),\n             kind: self.kind().map(|it| it.conv()),\n-            text_edit: Some(text_edit),\n+            text_edit: Some(text_edit.into()),\n             additional_text_edits: Some(additional_text_edits),\n             documentation: self.documentation().map(|it| it.conv()),\n             deprecated: Some(self.deprecated()),"}, {"sha": "0a0e616c9cbd4e50eb72084b80dd2061aabe1981", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 121, "deletions": 9, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -6,9 +6,12 @@ mod subscriptions;\n pub(crate) mod pending_requests;\n \n use std::{\n+    borrow::Cow,\n     env,\n     error::Error,\n-    fmt, panic,\n+    fmt,\n+    ops::Range,\n+    panic,\n     path::PathBuf,\n     sync::Arc,\n     time::{Duration, Instant},\n@@ -18,11 +21,12 @@ use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n use itertools::Itertools;\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{\n-    NumberOrString, WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressCreateParams,\n-    WorkDoneProgressEnd, WorkDoneProgressReport,\n+    DidChangeTextDocumentParams, NumberOrString, TextDocumentContentChangeEvent, WorkDoneProgress,\n+    WorkDoneProgressBegin, WorkDoneProgressCreateParams, WorkDoneProgressEnd,\n+    WorkDoneProgressReport,\n };\n use ra_flycheck::{url_from_path_with_drive_lowercasing, CheckTask};\n-use ra_ide::{Canceled, FileId, LibraryData, SourceRootId};\n+use ra_ide::{Canceled, FileId, LibraryData, LineIndex, SourceRootId};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n use ra_vfs::{VfsFile, VfsTask, Watch};\n@@ -33,6 +37,7 @@ use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher},\n+    conv::{ConvWith, TryConvWith},\n     diagnostics::DiagnosticTask,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n@@ -579,12 +584,16 @@ fn on_notification(\n         Err(not) => not,\n     };\n     let not = match notification_cast::<req::DidChangeTextDocument>(not) {\n-        Ok(mut params) => {\n-            let uri = params.text_document.uri;\n+        Ok(params) => {\n+            let DidChangeTextDocumentParams { text_document, content_changes } = params;\n+            let world = state.snapshot();\n+            let file_id = text_document.try_conv_with(&world)?;\n+            let line_index = world.analysis().file_line_index(file_id)?;\n+            let uri = text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n-            let text =\n-                params.content_changes.pop().ok_or_else(|| \"empty changes\".to_string())?.text;\n-            state.vfs.write().change_file_overlay(path.as_path(), text);\n+            state.vfs.write().change_file_overlay(&path, |old_text| {\n+                apply_document_changes(old_text, Cow::Borrowed(&line_index), content_changes);\n+            });\n             return Ok(());\n         }\n         Err(not) => not,\n@@ -653,6 +662,48 @@ fn on_notification(\n     Ok(())\n }\n \n+fn apply_document_changes(\n+    old_text: &mut String,\n+    mut line_index: Cow<'_, LineIndex>,\n+    content_changes: Vec<TextDocumentContentChangeEvent>,\n+) {\n+    // The changes we got must be applied sequentially, but can cross lines so we\n+    // have to keep our line index updated.\n+    // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n+    // remember the last valid line in the index and only rebuild it if needed.\n+    enum IndexValid {\n+        All,\n+        UpToLine(u64),\n+    }\n+\n+    impl IndexValid {\n+        fn covers(&self, line: u64) -> bool {\n+            match *self {\n+                IndexValid::UpToLine(to) => to >= line,\n+                _ => true,\n+            }\n+        }\n+    }\n+\n+    let mut index_valid = IndexValid::All;\n+    for change in content_changes {\n+        match change.range {\n+            Some(range) => {\n+                if !index_valid.covers(range.start.line) {\n+                    line_index = Cow::Owned(LineIndex::new(&old_text));\n+                }\n+                index_valid = IndexValid::UpToLine(range.start.line);\n+                let range = range.conv_with(&line_index);\n+                old_text.replace_range(Range::<usize>::from(range), &change.text);\n+            }\n+            None => {\n+                *old_text = change.text;\n+                index_valid = IndexValid::UpToLine(0);\n+            }\n+        }\n+    }\n+}\n+\n fn on_check_task(\n     task: CheckTask,\n     world_state: &mut WorldState,\n@@ -958,3 +1009,64 @@ where\n {\n     Request::new(id, R::METHOD.to_string(), params)\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::borrow::Cow;\n+\n+    use lsp_types::{Position, Range, TextDocumentContentChangeEvent};\n+    use ra_ide::LineIndex;\n+\n+    #[test]\n+    fn apply_document_changes() {\n+        fn run(text: &mut String, changes: Vec<TextDocumentContentChangeEvent>) {\n+            let line_index = Cow::Owned(LineIndex::new(&text));\n+            super::apply_document_changes(text, line_index, changes);\n+        }\n+\n+        macro_rules! c {\n+            [$($sl:expr, $sc:expr; $el:expr, $ec:expr => $text:expr),+] => {\n+                vec![$(TextDocumentContentChangeEvent {\n+                    range: Some(Range {\n+                        start: Position { line: $sl, character: $sc },\n+                        end: Position { line: $el, character: $ec },\n+                    }),\n+                    range_length: None,\n+                    text: String::from($text),\n+                }),+]\n+            };\n+        }\n+\n+        let mut text = String::new();\n+        run(&mut text, vec![]);\n+        assert_eq!(text, \"\");\n+        run(\n+            &mut text,\n+            vec![TextDocumentContentChangeEvent {\n+                range: None,\n+                range_length: None,\n+                text: String::from(\"the\"),\n+            }],\n+        );\n+        assert_eq!(text, \"the\");\n+        run(&mut text, c![0, 3; 0, 3 => \" quick\"]);\n+        assert_eq!(text, \"the quick\");\n+        run(&mut text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        assert_eq!(text, \"quick foxes\");\n+        run(&mut text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        assert_eq!(text, \"quick foxes\\ndream\");\n+        run(&mut text, c![1, 0; 1, 0 => \"have \"]);\n+        assert_eq!(text, \"quick foxes\\nhave dream\");\n+        run(&mut text, c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"]);\n+        assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n+        run(&mut text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n+        run(\n+            &mut text,\n+            c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n+        );\n+        assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n+        run(&mut text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n+    }\n+}"}, {"sha": "8db2dfa0c861f7a0fb9591967c15ccdb86a2ba9c", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -326,10 +326,10 @@ pub fn handle_workspace_symbol(\n \n pub fn handle_goto_definition(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n+    params: req::GotoDefinitionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = params.text_document_position_params.try_conv_with(&world)?;\n     let nav_info = match world.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n@@ -340,10 +340,10 @@ pub fn handle_goto_definition(\n \n pub fn handle_goto_implementation(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n+    params: req::GotoImplementationParams,\n ) -> Result<Option<req::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = params.text_document_position_params.try_conv_with(&world)?;\n     let nav_info = match world.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n@@ -354,10 +354,10 @@ pub fn handle_goto_implementation(\n \n pub fn handle_goto_type_definition(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n+    params: req::GotoTypeDefinitionParams,\n ) -> Result<Option<req::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = params.text_document_position_params.try_conv_with(&world)?;\n     let nav_info = match world.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n@@ -487,10 +487,10 @@ pub fn handle_folding_range(\n \n pub fn handle_signature_help(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n+    params: req::SignatureHelpParams,\n ) -> Result<Option<req::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = params.text_document_position_params.try_conv_with(&world)?;\n     if let Some(call_info) = world.analysis().call_info(position)? {\n         let concise = !world.config.call_info_full;\n         let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n@@ -509,12 +509,9 @@ pub fn handle_signature_help(\n     }\n }\n \n-pub fn handle_hover(\n-    world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n-) -> Result<Option<Hover>> {\n+pub fn handle_hover(world: WorldSnapshot, params: req::HoverParams) -> Result<Option<Hover>> {\n     let _p = profile(\"handle_hover\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = params.text_document_position_params.try_conv_with(&world)?;\n     let info = match world.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n@@ -878,8 +875,14 @@ pub fn handle_code_lens(\n             .map(|it| {\n                 let range = it.node_range.conv_with(&line_index);\n                 let pos = range.start;\n-                let lens_params =\n-                    req::TextDocumentPositionParams::new(params.text_document.clone(), pos);\n+                let lens_params = req::GotoImplementationParams {\n+                    text_document_position_params: req::TextDocumentPositionParams::new(\n+                        params.text_document.clone(),\n+                        pos,\n+                    ),\n+                    work_done_progress_params: Default::default(),\n+                    partial_result_params: Default::default(),\n+                };\n                 CodeLens {\n                     range,\n                     command: None,\n@@ -894,7 +897,7 @@ pub fn handle_code_lens(\n #[derive(Debug, Serialize, Deserialize)]\n #[serde(rename_all = \"camelCase\")]\n enum CodeLensResolveData {\n-    Impls(req::TextDocumentPositionParams),\n+    Impls(req::GotoImplementationParams),\n }\n \n pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Result<CodeLens> {\n@@ -927,7 +930,7 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n                 title,\n                 command: \"rust-analyzer.showReferences\".into(),\n                 arguments: Some(vec![\n-                    to_value(&lens_params.text_document.uri).unwrap(),\n+                    to_value(&lens_params.text_document_position_params.text_document.uri).unwrap(),\n                     to_value(code_lens.range.start).unwrap(),\n                     to_value(locations).unwrap(),\n                 ]),\n@@ -944,16 +947,16 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n \n pub fn handle_document_highlight(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n+    params: req::DocumentHighlightParams,\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = params.text_document_position_params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n \n-    let refs = match world\n-        .analysis()\n-        .find_all_refs(params.try_conv_with(&world)?, Some(SearchScope::single_file(file_id)))?\n-    {\n+    let refs = match world.analysis().find_all_refs(\n+        params.text_document_position_params.try_conv_with(&world)?,\n+        Some(SearchScope::single_file(file_id)),\n+    )? {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };"}, {"sha": "0dae6bad4ff2333d0d82aea3a62df8bd70dcaa4e", "filename": "crates/rust-analyzer/src/req.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freq.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -8,14 +8,15 @@ pub use lsp_types::{\n     notification::*, request::*, ApplyWorkspaceEditParams, CodeActionParams, CodeLens,\n     CodeLensParams, CompletionParams, CompletionResponse, ConfigurationItem, ConfigurationParams,\n     DiagnosticTag, DidChangeConfigurationParams, DidChangeWatchedFilesParams,\n-    DidChangeWatchedFilesRegistrationOptions, DocumentOnTypeFormattingParams, DocumentSymbolParams,\n-    DocumentSymbolResponse, FileSystemWatcher, Hover, InitializeResult, MessageType,\n-    PartialResultParams, ProgressParams, ProgressParamsValue, ProgressToken,\n-    PublishDiagnosticsParams, ReferenceParams, Registration, RegistrationParams, SelectionRange,\n-    SelectionRangeParams, SemanticTokensParams, SemanticTokensRangeParams,\n+    DidChangeWatchedFilesRegistrationOptions, DocumentHighlightParams,\n+    DocumentOnTypeFormattingParams, DocumentSymbolParams, DocumentSymbolResponse,\n+    FileSystemWatcher, GotoDefinitionParams, GotoDefinitionResponse, Hover, HoverParams,\n+    InitializeResult, MessageType, PartialResultParams, ProgressParams, ProgressParamsValue,\n+    ProgressToken, PublishDiagnosticsParams, ReferenceParams, Registration, RegistrationParams,\n+    SelectionRange, SelectionRangeParams, SemanticTokensParams, SemanticTokensRangeParams,\n     SemanticTokensRangeResult, SemanticTokensResult, ServerCapabilities, ShowMessageParams,\n-    SignatureHelp, SymbolKind, TextDocumentEdit, TextDocumentPositionParams, TextEdit,\n-    WorkDoneProgressParams, WorkspaceEdit, WorkspaceSymbolParams,\n+    SignatureHelp, SignatureHelpParams, SymbolKind, TextDocumentEdit, TextDocumentPositionParams,\n+    TextEdit, WorkDoneProgressParams, WorkspaceEdit, WorkspaceSymbolParams,\n };\n use std::path::PathBuf;\n "}, {"sha": "2dc5cb1196fc41e6f374185d731ac043c300ed3a", "filename": "crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -4,64 +4,69 @@ use std::ops;\n \n use lsp_types::{Range, SemanticToken, SemanticTokenModifier, SemanticTokenType, SemanticTokens};\n \n-pub(crate) const ATTRIBUTE: SemanticTokenType = SemanticTokenType::new(\"attribute\");\n-pub(crate) const BUILTIN_TYPE: SemanticTokenType = SemanticTokenType::new(\"builtinType\");\n-pub(crate) const ENUM_MEMBER: SemanticTokenType = SemanticTokenType::new(\"enumMember\");\n-pub(crate) const LIFETIME: SemanticTokenType = SemanticTokenType::new(\"lifetime\");\n-pub(crate) const TYPE_ALIAS: SemanticTokenType = SemanticTokenType::new(\"typeAlias\");\n-pub(crate) const UNION: SemanticTokenType = SemanticTokenType::new(\"union\");\n-pub(crate) const UNRESOLVED_REFERENCE: SemanticTokenType =\n-    SemanticTokenType::new(\"unresolvedReference\");\n-pub(crate) const FORMAT_SPECIFIER: SemanticTokenType = SemanticTokenType::new(\"formatSpecifier\");\n-\n-pub(crate) const CONSTANT: SemanticTokenModifier = SemanticTokenModifier::new(\"constant\");\n-pub(crate) const CONTROL_FLOW: SemanticTokenModifier = SemanticTokenModifier::new(\"controlFlow\");\n-pub(crate) const MUTABLE: SemanticTokenModifier = SemanticTokenModifier::new(\"mutable\");\n-pub(crate) const UNSAFE: SemanticTokenModifier = SemanticTokenModifier::new(\"unsafe\");\n-\n-pub(crate) const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n-    SemanticTokenType::COMMENT,\n-    SemanticTokenType::KEYWORD,\n-    SemanticTokenType::STRING,\n-    SemanticTokenType::NUMBER,\n-    SemanticTokenType::REGEXP,\n-    SemanticTokenType::OPERATOR,\n-    SemanticTokenType::NAMESPACE,\n-    SemanticTokenType::TYPE,\n-    SemanticTokenType::STRUCT,\n-    SemanticTokenType::CLASS,\n-    SemanticTokenType::INTERFACE,\n-    SemanticTokenType::ENUM,\n-    SemanticTokenType::TYPE_PARAMETER,\n-    SemanticTokenType::FUNCTION,\n-    SemanticTokenType::MEMBER,\n-    SemanticTokenType::PROPERTY,\n-    SemanticTokenType::MACRO,\n-    SemanticTokenType::VARIABLE,\n-    SemanticTokenType::PARAMETER,\n-    SemanticTokenType::LABEL,\n-    ATTRIBUTE,\n-    BUILTIN_TYPE,\n-    ENUM_MEMBER,\n-    LIFETIME,\n-    TYPE_ALIAS,\n-    UNION,\n-    UNRESOLVED_REFERENCE,\n-    FORMAT_SPECIFIER,\n+macro_rules! define_semantic_token_types {\n+    ($(($ident:ident, $string:literal)),*$(,)?) => {\n+        $(pub(crate) const $ident: SemanticTokenType = SemanticTokenType::new($string);)*\n+\n+        pub(crate) const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n+            SemanticTokenType::COMMENT,\n+            SemanticTokenType::KEYWORD,\n+            SemanticTokenType::STRING,\n+            SemanticTokenType::NUMBER,\n+            SemanticTokenType::REGEXP,\n+            SemanticTokenType::OPERATOR,\n+            SemanticTokenType::NAMESPACE,\n+            SemanticTokenType::TYPE,\n+            SemanticTokenType::STRUCT,\n+            SemanticTokenType::CLASS,\n+            SemanticTokenType::INTERFACE,\n+            SemanticTokenType::ENUM,\n+            SemanticTokenType::TYPE_PARAMETER,\n+            SemanticTokenType::FUNCTION,\n+            SemanticTokenType::MEMBER,\n+            SemanticTokenType::PROPERTY,\n+            SemanticTokenType::MACRO,\n+            SemanticTokenType::VARIABLE,\n+            SemanticTokenType::PARAMETER,\n+            SemanticTokenType::LABEL,\n+            $($ident),*\n+        ];\n+    };\n+}\n+\n+define_semantic_token_types![\n+    (ATTRIBUTE, \"attribute\"),\n+    (BUILTIN_TYPE, \"builtinType\"),\n+    (ENUM_MEMBER, \"enumMember\"),\n+    (LIFETIME, \"lifetime\"),\n+    (TYPE_ALIAS, \"typeAlias\"),\n+    (UNION, \"union\"),\n+    (UNRESOLVED_REFERENCE, \"unresolvedReference\"),\n+    (FORMAT_SPECIFIER, \"formatSpecifier\"),\n ];\n \n-pub(crate) const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n-    SemanticTokenModifier::DOCUMENTATION,\n-    SemanticTokenModifier::DECLARATION,\n-    SemanticTokenModifier::DEFINITION,\n-    SemanticTokenModifier::STATIC,\n-    SemanticTokenModifier::ABSTRACT,\n-    SemanticTokenModifier::DEPRECATED,\n-    SemanticTokenModifier::READONLY,\n-    CONSTANT,\n-    MUTABLE,\n-    UNSAFE,\n-    CONTROL_FLOW,\n+macro_rules! define_semantic_token_modifiers {\n+    ($(($ident:ident, $string:literal)),*$(,)?) => {\n+        $(pub(crate) const $ident: SemanticTokenModifier = SemanticTokenModifier::new($string);)*\n+\n+        pub(crate) const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n+            SemanticTokenModifier::DOCUMENTATION,\n+            SemanticTokenModifier::DECLARATION,\n+            SemanticTokenModifier::DEFINITION,\n+            SemanticTokenModifier::STATIC,\n+            SemanticTokenModifier::ABSTRACT,\n+            SemanticTokenModifier::DEPRECATED,\n+            SemanticTokenModifier::READONLY,\n+            $($ident),*\n+        ];\n+    };\n+}\n+\n+define_semantic_token_modifiers![\n+    (CONSTANT, \"constant\"),\n+    (CONTROL_FLOW, \"controlFlow\"),\n+    (MUTABLE, \"mutable\"),\n+    (UNSAFE, \"unsafe\"),\n ];\n \n #[derive(Default)]"}, {"sha": "07b8114c613996d15b47ccaf92c4c23ef49f80bc", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -4,8 +4,8 @@ use std::{collections::HashMap, path::PathBuf, time::Instant};\n \n use lsp_types::{\n     CodeActionContext, DidOpenTextDocumentParams, DocumentFormattingParams, FormattingOptions,\n-    PartialResultParams, Position, Range, TextDocumentItem, TextDocumentPositionParams,\n-    WorkDoneProgressParams,\n+    GotoDefinitionParams, HoverParams, PartialResultParams, Position, Range, TextDocumentItem,\n+    TextDocumentPositionParams, WorkDoneProgressParams,\n };\n use rust_analyzer::req::{\n     CodeActionParams, CodeActionRequest, Completion, CompletionParams, DidOpenTextDocument,\n@@ -610,10 +610,14 @@ fn main() { message(); }\n     })\n     .server();\n     server.wait_until_workspace_is_loaded();\n-    let res = server.send_request::<GotoDefinition>(TextDocumentPositionParams::new(\n-        server.doc_id(\"src/main.rs\"),\n-        Position::new(2, 15),\n-    ));\n+    let res = server.send_request::<GotoDefinition>(GotoDefinitionParams {\n+        text_document_position_params: TextDocumentPositionParams::new(\n+            server.doc_id(\"src/main.rs\"),\n+            Position::new(2, 15),\n+        ),\n+        work_done_progress_params: Default::default(),\n+        partial_result_params: Default::default(),\n+    });\n     assert!(format!(\"{}\", res).contains(\"hello.rs\"));\n }\n \n@@ -692,10 +696,13 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n     .root(\"bar\")\n     .server();\n     server.wait_until_workspace_is_loaded();\n-    let res = server.send_request::<HoverRequest>(TextDocumentPositionParams::new(\n-        server.doc_id(\"foo/src/main.rs\"),\n-        Position::new(7, 9),\n-    ));\n+    let res = server.send_request::<HoverRequest>(HoverParams {\n+        text_document_position_params: TextDocumentPositionParams::new(\n+            server.doc_id(\"foo/src/main.rs\"),\n+            Position::new(7, 9),\n+        ),\n+        work_done_progress_params: Default::default(),\n+    });\n \n     let value = res.get(\"contents\").unwrap().get(\"value\").unwrap().to_string();\n     assert_eq!(value, r#\"\"```rust\\nfoo::Bar\\nfn bar()\\n```\"\"#)"}, {"sha": "33973ffecb6611c5445823ad7b5ee5ac403520bb", "filename": "docs/dev/syntax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/docs%2Fdev%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/docs%2Fdev%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fsyntax.md?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -35,7 +35,7 @@ The syntax tree consists of three layers:\n * AST\n \n Of these, only GreenNodes store the actual data, the other two layers are (non-trivial) views into green tree.\n-Red-green terminology comes from Roslyn ([link](https://docs.microsoft.com/en-ie/archive/blogs/ericlippert/persistence-facades-and-roslyns-red-green-trees)) and gives the name to the `rowan` library. Green and syntax nodes are defined in rowan, ast is defined in rust-analyzer.\n+Red-green terminology comes from Roslyn ([link](https://ericlippert.com/2012/06/08/red-green-trees/)) and gives the name to the `rowan` library. Green and syntax nodes are defined in rowan, ast is defined in rust-analyzer.\n \n Syntax trees are a semi-transient data structure.\n In general, frontend does not keep syntax trees for all files in memory."}, {"sha": "b9a365fc197dcc90d85ab439340db3604083b596", "filename": "docs/user/features.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -140,8 +140,8 @@ space or `;` depending on the return type of the function.\n When completing a function call, `()` are automatically inserted. If a function\n takes arguments, the cursor is positioned inside the parenthesis.\n \n-There are postifx completions, which can be triggerd by typing something like\n-`foo().if`. The word after `.` determines postifx completion. Possible variants are:\n+There are postfix completions, which can be triggered by typing something like\n+`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n \n - `expr.if` -> `if expr {}`\n - `expr.match` -> `match expr {}`"}, {"sha": "4cb1e23e8d836b6e18c34f6878bcf003c3ddfc8b", "filename": "docs/user/readme.adoc", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -111,7 +111,7 @@ Here are some useful self-diagnostic commands:\n === rust-analyzer Language Server Binary\n \n Other editors generally require the `rust-analyzer` binary to be in `$PATH`.\n-You can download the pre-built binary from the https://github.com/rust-analyzer/rust-analyzer/releases[releases] page. Typically, you then need to rename the binary for your platform, e.g. `rust-analyzer-mac` if you're on Mac OS, to `rust-analzyer` and make it executable in addition to moving it into a directory in your `$PATH`.\n+You can download the pre-built binary from the https://github.com/rust-analyzer/rust-analyzer/releases[releases] page. Typically, you then need to rename the binary for your platform, e.g. `rust-analyzer-mac` if you're on Mac OS, to `rust-analyzer` and make it executable in addition to moving it into a directory in your `$PATH`.\n \n On Linux to install the `rust-analyzer` binary into `~/.local/bin`, this commands could be used\n \n@@ -169,13 +169,15 @@ The are several LSP client implementations for vim:\n \n 1. Install coc.nvim by following the instructions at\n    https://github.com/neoclide/coc.nvim[coc.nvim]\n-   (nodejs required)\n+   (Node.js required)\n 2. Run `:CocInstall coc-rust-analyzer` to install\n    https://github.com/fannheyward/coc-rust-analyzer[coc-rust-analyzer],\n    this extension implements _most_ of the features supported in the VSCode extension:\n+   * automatically install and upgrade stable/nightly releases\n    * same configurations as VSCode extension, `rust-analyzer.serverPath`, `rust-analyzer.cargo.features` etc.\n    * same commands too, `rust-analyzer.analyzerStatus`, `rust-analyzer.ssr` etc.\n-   * highlighting and inlay_hints are not implemented yet\n+   * inlay hints for method chaining support, _Neovim Only_\n+   * semantic highlighting is not implemented yet\n \n ==== LanguageClient-neovim\n \n@@ -195,7 +197,7 @@ let g:LanguageClient_serverCommands = {\n ==== YouCompleteMe\n \n 1. Install YouCompleteMe by following the instructions\n-  https://ycm-core.github.io/YouCompleteMe/#rust-semantic-completion[here]\n+  https://github.com/ycm-core/lsp-examples#rust-rust-analyzer[here]\n \n 2. Configure by adding this to your vim/neovim config file (replacing the existing Rust-specific line if it exists):\n +\n@@ -212,6 +214,21 @@ let g:ycm_language_server =\n \\ ]\n ----\n \n+==== ALE\n+\n+To add the LSP server to https://github.com/dense-analysis/ale[ale]:\n+\n+[source,vim]\n+----\n+call ale#linter#Define('rust', {\n+\\   'name': 'rust-analyzer',\n+\\   'lsp': 'stdio',\n+\\   'executable': 'rust-analyzer',\n+\\   'command': '%e',\n+\\   'project_root': '.',\n+\\})\n+----\n+\n ==== nvim-lsp\n \n NeoVim 0.5 (not yet released) has built-in language server support.\n@@ -229,9 +246,9 @@ You also need the `LSP` package. To install it:\n    * Type `Install Package Control`, press enter\n 2. In the command palette, run `Package control: Install package`, and in the list that pops up, type `LSP` and press enter.\n \n-Finally, with your Rust project open, in the command palette, run `LSP: Enable Language Server In Project` or `LSP: Enable Language Server Globally`, then select `rust-analyzer` in the list that pops up to enable the rust-analyzer LSP. The latter means that rust-analzyer is enabled by default in Rust projects.\n+Finally, with your Rust project open, in the command palette, run `LSP: Enable Language Server In Project` or `LSP: Enable Language Server Globally`, then select `rust-analyzer` in the list that pops up to enable the rust-analyzer LSP. The latter means that rust-analyzer is enabled by default in Rust projects.\n \n-If it worked, you should see \"rust-analzyer, Line X, Column Y\" on the left side of the bottom bar, and after waiting a bit, functionality like tooltips on hovering over variables should become available.\n+If it worked, you should see \"rust-analyzer, Line X, Column Y\" on the left side of the bottom bar, and after waiting a bit, functionality like tooltips on hovering over variables should become available.\n \n If you get an error saying `No such file or directory: 'rust-analyzer'`, see the <<rust-analyzer-language-server-binary,`rust-analyzer` binary>> section on installing the language server binary.\n "}, {"sha": "d30673791f7c5faba00413c69b5702a313b1dc54", "filename": "editors/code/package.json", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -27,6 +27,7 @@\n     \"scripts\": {\n         \"vscode:prepublish\": \"tsc && rollup -c\",\n         \"package\": \"vsce package -o rust-analyzer.vsix\",\n+        \"build\": \"tsc\",\n         \"watch\": \"tsc --watch\",\n         \"lint\": \"tsfmt --verify && eslint -c .eslintrc.js --ext ts ./src\",\n         \"fix\": \" tsfmt -r       && eslint -c .eslintrc.js --ext ts ./src --fix\"\n@@ -388,6 +389,28 @@\n                     \"description\": \"Enable Proc macro support, cargo.loadOutDirsFromCheck must be enabled.\",\n                     \"type\": \"boolean\",\n                     \"default\": false\n+                },\n+                \"rust-analyzer.debug.engine\": {\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"auto\",\n+                        \"vadimcn.vscode-lldb\",\n+                        \"ms-vscode.cpptools\"\n+                    ],\n+                    \"default\": \"auto\",\n+                    \"description\": \"Preffered debug engine.\",\n+                    \"markdownEnumDescriptions\": [\n+                        \"First try to use [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb), if it's not installed try to use [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools).\",\n+                        \"Use [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb)\",\n+                        \"Use [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)\"\n+                    ]\n+                },\n+                \"rust-analyzer.debug.sourceFileMap\": {\n+                    \"type\": \"object\",\n+                    \"description\": \"Optional source file mappings passed to the debug engine.\",\n+                    \"default\": {\n+                        \"/rustc/<id>\": \"${env:USERPROFILE}/.rustup/toolchains/<toolchain-id>/lib/rustlib/src/rust\"\n+                    }\n                 }\n             }\n         },"}, {"sha": "a328ba9bd01c1f1f19d4aa9fcfd4df9d4985cd99", "filename": "editors/code/src/cargo.ts", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fsrc%2Fcargo.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fsrc%2Fcargo.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcargo.ts?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -0,0 +1,106 @@\n+import * as cp from 'child_process';\n+import * as readline from 'readline';\n+import { OutputChannel } from 'vscode';\n+\n+interface CompilationArtifact {\n+    fileName: string;\n+    name: string;\n+    kind: string;\n+    isTest: boolean;\n+}\n+\n+export class Cargo {\n+    rootFolder: string;\n+    env?: Record<string, string>;\n+    output: OutputChannel;\n+\n+    public constructor(cargoTomlFolder: string, output: OutputChannel, env: Record<string, string> | undefined = undefined) {\n+        this.rootFolder = cargoTomlFolder;\n+        this.output = output;\n+        this.env = env;\n+    }\n+\n+    public async artifactsFromArgs(cargoArgs: string[]): Promise<CompilationArtifact[]> {\n+        const artifacts: CompilationArtifact[] = [];\n+\n+        try {\n+            await this.runCargo(cargoArgs,\n+                message => {\n+                    if (message.reason === 'compiler-artifact' && message.executable) {\n+                        const isBinary = message.target.crate_types.includes('bin');\n+                        const isBuildScript = message.target.kind.includes('custom-build');\n+                        if ((isBinary && !isBuildScript) || message.profile.test) {\n+                            artifacts.push({\n+                                fileName: message.executable,\n+                                name: message.target.name,\n+                                kind: message.target.kind[0],\n+                                isTest: message.profile.test\n+                            });\n+                        }\n+                    }\n+                    else if (message.reason === 'compiler-message') {\n+                        this.output.append(message.message.rendered);\n+                    }\n+                },\n+                stderr => {\n+                    this.output.append(stderr);\n+                }\n+            );\n+        }\n+        catch (err) {\n+            this.output.show(true);\n+            throw new Error(`Cargo invocation has failed: ${err}`);\n+        }\n+\n+        return artifacts;\n+    }\n+\n+    public async executableFromArgs(args: string[]): Promise<string> {\n+        const cargoArgs = [...args]; // to remain  args unchanged\n+        cargoArgs.push(\"--message-format=json\");\n+\n+        const artifacts = await this.artifactsFromArgs(cargoArgs);\n+\n+        if (artifacts.length === 0) {\n+            throw new Error('No compilation artifacts');\n+        } else if (artifacts.length > 1) {\n+            throw new Error('Multiple compilation artifacts are not supported.');\n+        }\n+\n+        return artifacts[0].fileName;\n+    }\n+\n+    runCargo(\n+        cargoArgs: string[],\n+        onStdoutJson: (obj: any) => void,\n+        onStderrString: (data: string) => void\n+    ): Promise<number> {\n+        return new Promise<number>((resolve, reject) => {\n+            const cargo = cp.spawn('cargo', cargoArgs, {\n+                stdio: ['ignore', 'pipe', 'pipe'],\n+                cwd: this.rootFolder,\n+                env: this.env,\n+            });\n+\n+            cargo.on('error', err => {\n+                reject(new Error(`could not launch cargo: ${err}`));\n+            });\n+            cargo.stderr.on('data', chunk => {\n+                onStderrString(chunk.toString());\n+            });\n+\n+            const rl = readline.createInterface({ input: cargo.stdout });\n+            rl.on('line', line => {\n+                const message = JSON.parse(line);\n+                onStdoutJson(message);\n+            });\n+\n+            cargo.on('exit', (exitCode, _) => {\n+                if (exitCode === 0)\n+                    resolve(exitCode);\n+                else\n+                    reject(new Error(`exit code: ${exitCode}.`));\n+            });\n+        });\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "d77e8188c75f67d9e8784be3cdbebcdc83e5cd23", "filename": "editors/code/src/commands/runnables.ts", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -1,8 +1,10 @@\n import * as vscode from 'vscode';\n import * as lc from 'vscode-languageclient';\n import * as ra from '../rust-analyzer-api';\n+import * as os from \"os\";\n \n import { Ctx, Cmd } from '../ctx';\n+import { Cargo } from '../cargo';\n \n export function run(ctx: Ctx): Cmd {\n     let prevRunnable: RunnableQuickPick | undefined;\n@@ -62,25 +64,69 @@ export function runSingle(ctx: Ctx): Cmd {\n     };\n }\n \n+function getLldbDebugConfig(config: ra.Runnable, sourceFileMap: Record<string, string>): vscode.DebugConfiguration {\n+    return {\n+        type: \"lldb\",\n+        request: \"launch\",\n+        name: config.label,\n+        cargo: {\n+            args: config.args,\n+        },\n+        args: config.extraArgs,\n+        cwd: config.cwd,\n+        sourceMap: sourceFileMap\n+    };\n+}\n+\n+const debugOutput = vscode.window.createOutputChannel(\"Debug\");\n+\n+async function getCppvsDebugConfig(config: ra.Runnable, sourceFileMap: Record<string, string>): Promise<vscode.DebugConfiguration> {\n+    debugOutput.clear();\n+\n+    const cargo = new Cargo(config.cwd || '.', debugOutput);\n+    const executable = await cargo.executableFromArgs(config.args);\n+\n+    // if we are here, there were no compilation errors.\n+    return {\n+        type: (os.platform() === \"win32\") ? \"cppvsdbg\" : 'cppdbg',\n+        request: \"launch\",\n+        name: config.label,\n+        program: executable,\n+        args: config.extraArgs,\n+        cwd: config.cwd,\n+        sourceFileMap: sourceFileMap,\n+    };\n+}\n+\n export function debugSingle(ctx: Ctx): Cmd {\n     return async (config: ra.Runnable) => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n-        if (!vscode.extensions.getExtension(\"vadimcn.vscode-lldb\")) {\n-            vscode.window.showErrorMessage(\"Install `vadimcn.vscode-lldb` extension for debugging\");\n+\n+        const lldbId = \"vadimcn.vscode-lldb\";\n+        const cpptoolsId = \"ms-vscode.cpptools\";\n+\n+        const debugEngineId = ctx.config.debug.engine;\n+        let debugEngine = null;\n+        if (debugEngineId === \"auto\") {\n+            debugEngine = vscode.extensions.getExtension(lldbId);\n+            if (!debugEngine) {\n+                debugEngine = vscode.extensions.getExtension(cpptoolsId);\n+            }\n+        }\n+        else {\n+            debugEngine = vscode.extensions.getExtension(debugEngineId);\n+        }\n+\n+        if (!debugEngine) {\n+            vscode.window.showErrorMessage(`Install [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=${lldbId})`\n+                + ` or [MS C++ tools](https://marketplace.visualstudio.com/items?itemName=${cpptoolsId}) extension for debugging.`);\n             return;\n         }\n \n-        const debugConfig = {\n-            type: \"lldb\",\n-            request: \"launch\",\n-            name: config.label,\n-            cargo: {\n-                args: config.args,\n-            },\n-            args: config.extraArgs,\n-            cwd: config.cwd\n-        };\n+        const debugConfig = lldbId === debugEngine.id\n+            ? getLldbDebugConfig(config, ctx.config.debug.sourceFileMap)\n+            : await getCppvsDebugConfig(config, ctx.config.debug.sourceFileMap);\n \n         return vscode.debug.startDebugging(undefined, debugConfig);\n     };"}, {"sha": "110e541800ed8f131c9dc8eb2c36704d23d94c80", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -92,7 +92,6 @@ export class Config {\n     get askBeforeDownload() { return this.get<boolean>(\"updates.askBeforeDownload\"); }\n     get traceExtension() { return this.get<boolean>(\"trace.extension\"); }\n \n-\n     get inlayHints() {\n         return {\n             typeHints: this.get<boolean>(\"inlayHints.typeHints\"),\n@@ -107,4 +106,12 @@ export class Config {\n             command: this.get<string>(\"checkOnSave.command\"),\n         };\n     }\n+\n+    get debug() {\n+        return {\n+            engine: this.get<string>(\"debug.engine\"),\n+            sourceFileMap: this.get<Record<string, string>>(\"debug.sourceFileMap\"),\n+        };\n+    }\n+\n }"}, {"sha": "bdd42cb769f4077ff8a48d1bfcca6c63be6354ba", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -162,7 +162,6 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"RECORD_LIT\",\n         \"RECORD_FIELD_LIST\",\n         \"RECORD_FIELD\",\n-        \"TRY_BLOCK_EXPR\",\n         \"BOX_EXPR\",\n         // postfix\n         \"CALL_EXPR\",\n@@ -440,7 +439,6 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         }\n         struct IfExpr: AttrsOwner { T![if], Condition }\n         struct LoopExpr: AttrsOwner, LoopBodyOwner { T![loop] }\n-        struct TryBlockExpr: AttrsOwner { T![try], body: BlockExpr }\n         struct ForExpr: AttrsOwner, LoopBodyOwner {\n             T![for],\n             Pat,\n@@ -451,7 +449,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct ContinueExpr: AttrsOwner { T![continue], T![lifetime] }\n         struct BreakExpr: AttrsOwner { T![break], T![lifetime], Expr }\n         struct Label { T![lifetime] }\n-        struct BlockExpr: AttrsOwner { Label, T![unsafe], Block  }\n+        struct BlockExpr: AttrsOwner { Label, T![unsafe], T![async], Block }\n         struct ReturnExpr: AttrsOwner { Expr }\n         struct CallExpr: ArgListOwner { Expr }\n         struct MethodCallExpr: AttrsOwner, ArgListOwner {\n@@ -595,7 +593,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             qualifier: Path,\n         }\n         struct PathSegment {\n-            T![::], T![<], NameRef, TypeArgList, ParamList, RetType, PathType, T![>]\n+            T![::], T![crate], T![<], NameRef, TypeArgList, ParamList, RetType, PathType, T![>]\n         }\n         struct TypeArgList {\n             T![::],\n@@ -722,7 +720,6 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             FieldExpr,\n             AwaitExpr,\n             TryExpr,\n-            TryBlockExpr,\n             CastExpr,\n             RefExpr,\n             PrefixExpr,"}, {"sha": "aef68089e1ec8db7d1637b01c1cebc1a43765d2c", "filename": "xtask/src/dist.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fdist.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -50,21 +50,19 @@ fn dist_server(nightly: bool) -> Result<()> {\n     if cfg!(target_os = \"linux\") {\n         std::env::set_var(\"CC\", \"clang\");\n         run!(\n-            \"cargo build --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --release\n-             --target x86_64-unknown-linux-musl\n-            \"\n+            \"cargo build --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --release\"\n             // We'd want to add, but that requires setting the right linker somehow\n             // --features=jemalloc\n         )?;\n         if !nightly {\n-            run!(\"strip ./target/x86_64-unknown-linux-musl/release/rust-analyzer\")?;\n+            run!(\"strip ./target/release/rust-analyzer\")?;\n         }\n     } else {\n         run!(\"cargo build --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --release\")?;\n     }\n \n     let (src, dst) = if cfg!(target_os = \"linux\") {\n-        (\"./target/x86_64-unknown-linux-musl/release/rust-analyzer\", \"./dist/rust-analyzer-linux\")\n+        (\"./target/release/rust-analyzer\", \"./dist/rust-analyzer-linux\")\n     } else if cfg!(target_os = \"windows\") {\n         (\"./target/release/rust-analyzer.exe\", \"./dist/rust-analyzer-windows.exe\")\n     } else if cfg!(target_os = \"macos\") {"}, {"sha": "2b7a461e568d3b0cebb429a1a2d74e1c2327b598", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 36, "deletions": 53, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -10,23 +10,19 @@ pub mod pre_commit;\n pub mod codegen;\n mod ast_src;\n \n-use anyhow::Context;\n use std::{\n     env,\n-    io::Write,\n     path::{Path, PathBuf},\n-    process::{Command, Stdio},\n };\n+\n use walkdir::{DirEntry, WalkDir};\n \n use crate::{\n     codegen::Mode,\n-    not_bash::{date_iso, fs2, pushd, rm_rf, run},\n+    not_bash::{date_iso, fs2, pushd, pushenv, rm_rf, run},\n };\n \n-pub use anyhow::Result;\n-\n-const TOOLCHAIN: &str = \"stable\";\n+pub use anyhow::{bail, Context as _, Result};\n \n pub fn project_root() -> PathBuf {\n     Path::new(\n@@ -55,82 +51,69 @@ pub fn rust_files(path: &Path) -> impl Iterator<Item = PathBuf> {\n \n pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     let _dir = pushd(project_root());\n+    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n     ensure_rustfmt()?;\n-\n-    let check = if mode == Mode::Verify { \"--check\" } else { \"\" };\n-    run!(\"rustup run {} -- cargo fmt -- {}\", TOOLCHAIN, check)?;\n+    match mode {\n+        Mode::Overwrite => run!(\"cargo fmt\"),\n+        Mode::Verify => run!(\"cargo fmt -- --check\"),\n+    }?;\n     Ok(())\n }\n \n fn reformat(text: impl std::fmt::Display) -> Result<String> {\n+    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n     ensure_rustfmt()?;\n-    let mut rustfmt = Command::new(\"rustup\")\n-        .args(&[\"run\", TOOLCHAIN, \"--\", \"rustfmt\", \"--config-path\"])\n-        .arg(project_root().join(\"rustfmt.toml\"))\n-        .args(&[\"--config\", \"fn_single_line=true\"])\n-        .stdin(Stdio::piped())\n-        .stdout(Stdio::piped())\n-        .spawn()?;\n-    write!(rustfmt.stdin.take().unwrap(), \"{}\", text)?;\n-    let output = rustfmt.wait_with_output()?;\n-    let stdout = String::from_utf8(output.stdout)?;\n+    let stdout = run!(\n+        \"rustfmt --config-path {} --config fn_single_line=true\", project_root().join(\"rustfmt.toml\").display();\n+        <text.to_string().as_bytes()\n+    )?;\n     let preamble = \"Generated file, do not edit by hand, see `xtask/src/codegen`\";\n-    Ok(format!(\"//! {}\\n\\n{}\", preamble, stdout))\n+    Ok(format!(\"//! {}\\n\\n{}\\n\", preamble, stdout))\n }\n \n fn ensure_rustfmt() -> Result<()> {\n-    match Command::new(\"rustup\")\n-        .args(&[\"run\", TOOLCHAIN, \"--\", \"cargo\", \"fmt\", \"--version\"])\n-        .stderr(Stdio::null())\n-        .stdout(Stdio::null())\n-        .status()\n-    {\n-        Ok(status) if status.success() => return Ok(()),\n-        _ => (),\n-    };\n-    run!(\"rustup toolchain install {}\", TOOLCHAIN)?;\n-    run!(\"rustup component add rustfmt --toolchain {}\", TOOLCHAIN)?;\n+    let out = run!(\"rustfmt --version\")?;\n+    if !out.contains(\"stable\") {\n+        bail!(\n+            \"Failed to run rustfmt from toolchain 'stable'. \\\n+             Please run `rustup component add rustfmt --toolchain stable` to install it.\",\n+        )\n+    }\n     Ok(())\n }\n \n pub fn run_clippy() -> Result<()> {\n-    match Command::new(\"rustup\")\n-        .args(&[\"run\", TOOLCHAIN, \"--\", \"cargo\", \"clippy\", \"--version\"])\n-        .stderr(Stdio::null())\n-        .stdout(Stdio::null())\n-        .status()\n-    {\n-        Ok(status) if status.success() => (),\n-        _ => install_clippy().context(\"install clippy\")?,\n-    };\n+    if run!(\"cargo clippy --version\").is_err() {\n+        bail!(\n+            \"Failed run cargo clippy. \\\n+            Please run `rustup component add clippy` to install it.\",\n+        )\n+    }\n \n     let allowed_lints = [\n         \"clippy::collapsible_if\",\n         \"clippy::needless_pass_by_value\",\n         \"clippy::nonminimal_bool\",\n         \"clippy::redundant_pattern_matching\",\n     ];\n-    run!(\n-        \"rustup run {} -- cargo clippy --all-features --all-targets -- -A {}\",\n-        TOOLCHAIN,\n-        allowed_lints.join(\" -A \")\n-    )?;\n-    Ok(())\n-}\n-\n-fn install_clippy() -> Result<()> {\n-    run!(\"rustup toolchain install {}\", TOOLCHAIN)?;\n-    run!(\"rustup component add clippy --toolchain {}\", TOOLCHAIN)?;\n+    run!(\"cargo clippy --all-features --all-targets -- -A {}\", allowed_lints.join(\" -A \"))?;\n     Ok(())\n }\n \n pub fn run_fuzzer() -> Result<()> {\n     let _d = pushd(\"./crates/ra_syntax\");\n+    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"nightly\");\n     if run!(\"cargo fuzz --help\").is_err() {\n         run!(\"cargo install cargo-fuzz\")?;\n     };\n \n-    run!(\"rustup run nightly -- cargo fuzz run parser\")?;\n+    // Expecting nightly rustc\n+    let out = run!(\"rustc --version\")?;\n+    if !out.contains(\"nightly\") {\n+        bail!(\"fuzz tests require nightly rustc\")\n+    }\n+\n+    run!(\"cargo fuzz run parser\")?;\n     Ok(())\n }\n "}, {"sha": "a6431e58633c18b0cad2b6244eb70c0212476e09", "filename": "xtask/src/not_bash.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Fnot_bash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc34162450797f5756ce2b44f1a3fe73d8e2dce4/xtask%2Fsrc%2Fnot_bash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fnot_bash.rs?ref=dc34162450797f5756ce2b44f1a3fe73d8e2dce4", "patch": "@@ -3,6 +3,8 @@\n use std::{\n     cell::RefCell,\n     env,\n+    ffi::OsString,\n+    io::Write,\n     path::{Path, PathBuf},\n     process::{Command, Stdio},\n };\n@@ -57,7 +59,10 @@ macro_rules! _run {\n         run!($($expr),*; echo = true)\n     };\n     ($($expr:expr),* ; echo = $echo:expr) => {\n-        $crate::not_bash::run_process(format!($($expr),*), $echo)\n+        $crate::not_bash::run_process(format!($($expr),*), $echo, None)\n+    };\n+    ($($expr:expr),* ;  <$stdin:expr) => {\n+        $crate::not_bash::run_process(format!($($expr),*), false, Some($stdin))\n     };\n }\n pub(crate) use _run as run;\n@@ -77,6 +82,21 @@ impl Drop for Pushd {\n     }\n }\n \n+pub struct Pushenv {\n+    _p: (),\n+}\n+\n+pub fn pushenv(var: &str, value: &str) -> Pushenv {\n+    Env::with(|env| env.pushenv(var.into(), value.into()));\n+    Pushenv { _p: () }\n+}\n+\n+impl Drop for Pushenv {\n+    fn drop(&mut self) {\n+        Env::with(|env| env.popenv())\n+    }\n+}\n+\n pub fn rm_rf(path: impl AsRef<Path>) -> Result<()> {\n     let path = path.as_ref();\n     if !path.exists() {\n@@ -90,15 +110,15 @@ pub fn rm_rf(path: impl AsRef<Path>) -> Result<()> {\n }\n \n #[doc(hidden)]\n-pub fn run_process(cmd: String, echo: bool) -> Result<String> {\n-    run_process_inner(&cmd, echo).with_context(|| format!(\"process `{}` failed\", cmd))\n+pub fn run_process(cmd: String, echo: bool, stdin: Option<&[u8]>) -> Result<String> {\n+    run_process_inner(&cmd, echo, stdin).with_context(|| format!(\"process `{}` failed\", cmd))\n }\n \n pub fn date_iso() -> Result<String> {\n     run!(\"date --iso --utc\")\n }\n \n-fn run_process_inner(cmd: &str, echo: bool) -> Result<String> {\n+fn run_process_inner(cmd: &str, echo: bool, stdin: Option<&[u8]>) -> Result<String> {\n     let mut args = shelx(cmd);\n     let binary = args.remove(0);\n     let current_dir = Env::with(|it| it.cwd().to_path_buf());\n@@ -107,12 +127,17 @@ fn run_process_inner(cmd: &str, echo: bool) -> Result<String> {\n         println!(\"> {}\", cmd)\n     }\n \n-    let output = Command::new(binary)\n-        .args(args)\n-        .current_dir(current_dir)\n-        .stdin(Stdio::null())\n-        .stderr(Stdio::inherit())\n-        .output()?;\n+    let mut command = Command::new(binary);\n+    command.args(args).current_dir(current_dir).stderr(Stdio::inherit());\n+    let output = match stdin {\n+        None => command.stdin(Stdio::null()).output(),\n+        Some(stdin) => {\n+            command.stdin(Stdio::piped()).stdout(Stdio::piped());\n+            let mut process = command.spawn()?;\n+            process.stdin.take().unwrap().write_all(stdin)?;\n+            process.wait_with_output()\n+        }\n+    }?;\n     let stdout = String::from_utf8(output.stdout)?;\n \n     if echo {\n@@ -133,13 +158,15 @@ fn shelx(cmd: &str) -> Vec<String> {\n \n struct Env {\n     pushd_stack: Vec<PathBuf>,\n+    pushenv_stack: Vec<(OsString, Option<OsString>)>,\n }\n \n impl Env {\n     fn with<F: FnOnce(&mut Env) -> T, T>(f: F) -> T {\n         thread_local! {\n             static ENV: RefCell<Env> = RefCell::new(Env {\n-                pushd_stack: vec![env::current_dir().unwrap()]\n+                pushd_stack: vec![env::current_dir().unwrap()],\n+                pushenv_stack: vec![],\n             });\n         }\n         ENV.with(|it| f(&mut *it.borrow_mut()))\n@@ -154,6 +181,17 @@ impl Env {\n         self.pushd_stack.pop().unwrap();\n         env::set_current_dir(self.cwd()).unwrap();\n     }\n+    fn pushenv(&mut self, var: OsString, value: OsString) {\n+        self.pushenv_stack.push((var.clone(), env::var_os(&var)));\n+        env::set_var(var, value)\n+    }\n+    fn popenv(&mut self) {\n+        let (var, value) = self.pushenv_stack.pop().unwrap();\n+        match value {\n+            None => env::remove_var(var),\n+            Some(value) => env::set_var(var, value),\n+        }\n+    }\n     fn cwd(&self) -> &Path {\n         self.pushd_stack.last().unwrap()\n     }"}]}