{"sha": "4cd30197eb126727b791a1c845c5ec47dbd3b1de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZDMwMTk3ZWIxMjY3MjdiNzkxYTFjODQ1YzVlYzQ3ZGJkM2IxZGU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-01T01:58:48Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-01T02:04:42Z"}, "message": "Fix #78549\n\nBefore #78430, string literals worked because `specialize_constructor`\ndidn't actually care too much which constructor was passed to it unless\nneeded. Since then, string literals are special cased and a bit hacky. I\ndid not anticipate patterns for the `&str` type other than string\nliterals, hence this bug. This makes string literals less hacky.", "tree": {"sha": "0b3e2d94cf67c154f2c3b92b7a51737fe3a9accd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b3e2d94cf67c154f2c3b92b7a51737fe3a9accd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cd30197eb126727b791a1c845c5ec47dbd3b1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cd30197eb126727b791a1c845c5ec47dbd3b1de", "html_url": "https://github.com/rust-lang/rust/commit/4cd30197eb126727b791a1c845c5ec47dbd3b1de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cd30197eb126727b791a1c845c5ec47dbd3b1de/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a53fb30e3bf2655b0563da6d561c23cda5f3ec11", "url": "https://api.github.com/repos/rust-lang/rust/commits/a53fb30e3bf2655b0563da6d561c23cda5f3ec11", "html_url": "https://github.com/rust-lang/rust/commit/a53fb30e3bf2655b0563da6d561c23cda5f3ec11"}], "stats": {"total": 97, "additions": 75, "deletions": 22}, "files": [{"sha": "868923be757c1be7f2dc79d0524bdf70698e9e84", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4cd30197eb126727b791a1c845c5ec47dbd3b1de/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd30197eb126727b791a1c845c5ec47dbd3b1de/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=4cd30197eb126727b791a1c845c5ec47dbd3b1de", "patch": "@@ -327,9 +327,23 @@ struct LiteralExpander;\n impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n-        match (pat.ty.kind(), &*pat.kind) {\n-            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n-            (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n+        match (pat.ty.kind(), pat.kind.as_ref()) {\n+            (_, PatKind::Binding { subpattern: Some(s), .. }) => s.fold_with(self),\n+            (_, PatKind::AscribeUserType { subpattern: s, .. }) => s.fold_with(self),\n+            (ty::Ref(_, t, _), PatKind::Constant { .. }) if t.is_str() => {\n+                // Treat string literal patterns as deref patterns to a `str` constant, i.e.\n+                // `&CONST`. This expands them like other const patterns. This could have been done\n+                // in `const_to_pat`, but that causes issues with the rest of the matching code.\n+                let mut new_pat = pat.super_fold_with(self);\n+                // Make a fake const pattern of type `str` (instead of `&str`). That the carried\n+                // constant value still knows it is of type `&str`.\n+                new_pat.ty = t;\n+                Pat {\n+                    kind: Box::new(PatKind::Deref { subpattern: new_pat }),\n+                    span: pat.span,\n+                    ty: pat.ty,\n+                }\n+            }\n             _ => pat.super_fold_with(self),\n         }\n     }\n@@ -788,7 +802,7 @@ enum Constructor<'tcx> {\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n     /// Fake constructor for those types for which we can't list constructors explicitly, like\n-    /// `f64` and `&str`.\n+    /// `f64` and `str`.\n     Unlistable,\n     /// Wildcard pattern.\n     Wildcard,\n@@ -931,7 +945,12 @@ impl<'tcx> Constructor<'tcx> {\n             // Otherwise, only a wildcard pattern can match the special extra constructor.\n             (Unlistable, _) => false,\n \n-            _ => bug!(\"trying to compare incompatible constructors {:?} and {:?}\", self, other),\n+            _ => span_bug!(\n+                pcx.span,\n+                \"trying to compare incompatible constructors {:?} and {:?}\",\n+                self,\n+                other\n+            ),\n         }\n     }\n \n@@ -1009,6 +1028,10 @@ impl<'tcx> Constructor<'tcx> {\n                         PatKind::Leaf { subpatterns }\n                     }\n                 }\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to reconstruct the correct constant pattern here. However a string\n+                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n+                // can ignore this issue.\n                 ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, pcx.ty),\n                 _ => PatKind::Wild,\n@@ -1303,9 +1326,13 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     ///     [Some(0), ..] => {}\n     /// }\n     /// ```\n+    /// This is guaranteed to preserve the number of patterns in `self`.\n     fn replace_with_pattern_arguments(&self, pat: &'p Pat<'tcx>) -> Self {\n         match pat.kind.as_ref() {\n-            PatKind::Deref { subpattern } => Self::from_single_pattern(subpattern),\n+            PatKind::Deref { subpattern } => {\n+                assert_eq!(self.len(), 1);\n+                Fields::from_single_pattern(subpattern)\n+            }\n             PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n                 self.replace_with_fieldpats(subpatterns)\n             }\n@@ -1596,9 +1623,8 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             vec![make_range(0, max)]\n         }\n         _ if cx.is_uninhabited(pcx.ty) => vec![],\n-        ty::Adt(..) | ty::Tuple(..) => vec![Single],\n-        ty::Ref(_, t, _) if !t.is_str() => vec![Single],\n-        // This type is one for which we don't know how to list constructors, like `&str` or `f64`.\n+        ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => vec![Single],\n+        // This type is one for which we don't know how to list constructors, like `str` or `f64`.\n         _ => vec![Unlistable],\n     }\n }\n@@ -2161,28 +2187,31 @@ fn pat_constructor<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     pat: &'p Pat<'tcx>,\n ) -> Constructor<'tcx> {\n-    match *pat.kind {\n+    match pat.kind.as_ref() {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n         PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n         PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n-        PatKind::Variant { adt_def, variant_index, .. } => {\n+        &PatKind::Variant { adt_def, variant_index, .. } => {\n             Variant(adt_def.variants[variant_index].def_id)\n         }\n         PatKind::Constant { value } => {\n             if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value, pat.span) {\n                 IntRange(int_range)\n             } else {\n-                match value.ty.kind() {\n+                match pat.ty.kind() {\n                     ty::Float(_) => FloatRange(value, value, RangeEnd::Included),\n-                    ty::Ref(_, t, _) if t.is_str() => Str(value),\n+                    // In `expand_pattern`, we convert string literals to `&CONST` patterns with\n+                    // `CONST` a pattern of type `str`. In truth this contains a constant of type\n+                    // `&str`.\n+                    ty::Str => Str(value),\n                     // All constants that can be structurally matched have already been expanded\n                     // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n                     // opaque.\n                     _ => Opaque,\n                 }\n             }\n         }\n-        PatKind::Range(PatRange { lo, hi, end }) => {\n+        &PatKind::Range(PatRange { lo, hi, end }) => {\n             let ty = lo.ty;\n             if let Some(int_range) = IntRange::from_range(\n                 cx.tcx,\n@@ -2197,8 +2226,7 @@ fn pat_constructor<'p, 'tcx>(\n                 FloatRange(lo, hi, end)\n             }\n         }\n-        PatKind::Array { ref prefix, ref slice, ref suffix }\n-        | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n             let array_len = match pat.ty.kind() {\n                 ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env)),\n                 ty::Slice(_) => None,"}, {"sha": "a0c0d1626ec45d3ddb19fa669834140ca43d7a8b", "filename": "src/test/ui/issues/issue-30240.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cd30197eb126727b791a1c845c5ec47dbd3b1de/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd30197eb126727b791a1c845c5ec47dbd3b1de/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs?ref=4cd30197eb126727b791a1c845c5ec47dbd3b1de", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n-    match \"world\" { //~ ERROR non-exhaustive patterns: `_`\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n         \"hello\" => {}\n     }\n \n-    match \"world\" { //~ ERROR non-exhaustive patterns: `_`\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n         ref _x if false => {}\n         \"hello\" => {}\n     }"}, {"sha": "a2c58d6e051b54214ddd332fa42edf8feca04d2e", "filename": "src/test/ui/issues/issue-30240.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4cd30197eb126727b791a1c845c5ec47dbd3b1de/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4cd30197eb126727b791a1c845c5ec47dbd3b1de/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr?ref=4cd30197eb126727b791a1c845c5ec47dbd3b1de", "patch": "@@ -1,17 +1,17 @@\n-error[E0004]: non-exhaustive patterns: `_` not covered\n+error[E0004]: non-exhaustive patterns: `&_` not covered\n   --> $DIR/issue-30240.rs:2:11\n    |\n LL |     match \"world\" {\n-   |           ^^^^^^^ pattern `_` not covered\n+   |           ^^^^^^^ pattern `&_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`\n \n-error[E0004]: non-exhaustive patterns: `_` not covered\n+error[E0004]: non-exhaustive patterns: `&_` not covered\n   --> $DIR/issue-30240.rs:6:11\n    |\n LL |     match \"world\" {\n-   |           ^^^^^^^ pattern `_` not covered\n+   |           ^^^^^^^ pattern `&_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`"}, {"sha": "2879caf2c4c70c03118846322b2a5cee3b4668e2", "filename": "src/test/ui/pattern/usefulness/issue-78549-ref-pat-and-str.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4cd30197eb126727b791a1c845c5ec47dbd3b1de/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78549-ref-pat-and-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd30197eb126727b791a1c845c5ec47dbd3b1de/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78549-ref-pat-and-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-78549-ref-pat-and-str.rs?ref=4cd30197eb126727b791a1c845c5ec47dbd3b1de", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+// From https://github.com/rust-lang/rust/issues/78549\n+\n+fn main() {\n+    match \"foo\" {\n+        \"foo\" => {},\n+        &_ => {},\n+    }\n+\n+    match \"foo\" {\n+        &_ => {},\n+        \"foo\" => {},\n+    }\n+\n+    match (\"foo\", 0, \"bar\") {\n+        (&_, 0, &_) => {},\n+        (\"foo\", _, \"bar\") => {},\n+        (&_, _, &_) => {},\n+    }\n+\n+    match (&\"foo\", \"bar\") {\n+        (&\"foo\", &_) => {},\n+        (&&_, &_) => {},\n+    }\n+}"}]}