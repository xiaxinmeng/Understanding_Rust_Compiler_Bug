{"sha": "5819ee1d45c99ad9761c5a2dfa1cb697393a200b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MTllZTFkNDVjOTlhZDk3NjFjNWEyZGZhMWNiNjk3MzkzYTIwMGI=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-15T20:12:20Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-21T15:39:35Z"}, "message": "Remove runtime failure from pattern matching\n\nIt's an artifact of the old refutable version of `match`\nand is no longer necessary.", "tree": {"sha": "d3e046b47b91697c46e834582289453ce9df33b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3e046b47b91697c46e834582289453ce9df33b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5819ee1d45c99ad9761c5a2dfa1cb697393a200b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5819ee1d45c99ad9761c5a2dfa1cb697393a200b", "html_url": "https://github.com/rust-lang/rust/commit/5819ee1d45c99ad9761c5a2dfa1cb697393a200b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5819ee1d45c99ad9761c5a2dfa1cb697393a200b/comments", "author": null, "committer": null, "parents": [{"sha": "f15d6d28396e8700b6c3f2704204a2769e710403", "url": "https://api.github.com/repos/rust-lang/rust/commits/f15d6d28396e8700b6c3f2704204a2769e710403", "html_url": "https://github.com/rust-lang/rust/commit/f15d6d28396e8700b6c3f2704204a2769e710403"}], "stats": {"total": 105, "additions": 22, "deletions": 83}, "files": [{"sha": "7ba49f5a2b90df532ea12ba2e95c52b336cef272", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 22, "deletions": 83, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5819ee1d45c99ad9761c5a2dfa1cb697393a200b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5819ee1d45c99ad9761c5a2dfa1cb697393a200b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5819ee1d45c99ad9761c5a2dfa1cb697393a200b", "patch": "@@ -202,12 +202,12 @@ use middle::resolve::DefMap;\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n+use middle::trans::build;\n use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::consts;\n-use middle::trans::controlflow;\n use middle::trans::datum::*;\n use middle::trans::expr::Dest;\n use middle::trans::expr;\n@@ -220,14 +220,12 @@ use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n use std::collections::HashMap;\n-use std::cell::Cell;\n use std::rc::Rc;\n use std::gc::{Gc};\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n-use syntax::parse::token::InternedString;\n \n #[deriving(PartialEq)]\n pub enum VecLenOpt {\n@@ -301,20 +299,6 @@ fn trans_opt<'a>(mut bcx: &'a Block<'a>, o: &Opt) -> opt_result<'a> {\n     }\n }\n \n-fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n-    let ccx = bcx.ccx();\n-    let def = ccx.tcx.def_map.borrow().get_copy(&pat_id);\n-    match def {\n-        def::DefVariant(enum_id, var_id, _) => {\n-            let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);\n-            var(variant.disr_val, adt::represent_node(bcx, pat_id), var_id)\n-        }\n-        _ => {\n-            ccx.sess().bug(\"non-variant or struct in variant_opt()\");\n-        }\n-    }\n-}\n-\n #[deriving(Clone)]\n pub enum TransBindingMode {\n     TrByCopy(/* llbinding */ ValueRef),\n@@ -630,26 +614,15 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n             ast::PatLit(l) => {\n                 add_to_set(ccx.tcx(), &mut found, lit(l));\n             }\n-            ast::PatIdent(..) => {\n+            ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n-                    Some(def::DefVariant(..)) => {\n-                        add_to_set(ccx.tcx(), &mut found,\n-                                   variant_opt(bcx, cur.id));\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            ast::PatEnum(..) | ast::PatStruct(..) => {\n-                // This could be one of: a tuple-like enum variant, a\n-                // struct-like enum variant, or a struct.\n-                let opt_def = ccx.tcx.def_map.borrow().find_copy(&cur.id);\n-                match opt_def {\n-                    Some(def::DefFn(..)) |\n-                    Some(def::DefVariant(..)) => {\n+                    Some(def::DefVariant(enum_id, var_id, _)) => {\n+                        let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);\n                         add_to_set(ccx.tcx(), &mut found,\n-                                   variant_opt(bcx, cur.id));\n+                                   var(variant.disr_val,\n+                                       adt::represent_node(bcx, cur.id), var_id));\n                     }\n                     _ => {}\n                 }\n@@ -795,56 +768,33 @@ fn any_irrefutable_adt_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n     })\n }\n \n-struct DynamicFailureHandler<'a> {\n-    bcx: &'a Block<'a>,\n-    sp: Span,\n-    msg: InternedString,\n-    finished: Cell<Option<BasicBlockRef>>,\n-}\n-\n-impl<'a> DynamicFailureHandler<'a> {\n-    fn handle_fail(&self) -> BasicBlockRef {\n-        match self.finished.get() {\n-            Some(bb) => return bb,\n-            _ => (),\n-        }\n-\n-        let fcx = self.bcx.fcx;\n-        let fail_cx = fcx.new_block(false, \"case_fallthrough\", None);\n-        controlflow::trans_fail(fail_cx, self.sp, self.msg.clone());\n-        self.finished.set(Some(fail_cx.llbb));\n-        fail_cx.llbb\n-    }\n-}\n-\n /// What to do when the pattern match fails.\n enum FailureHandler<'a> {\n     Infallible,\n     JumpToBasicBlock(BasicBlockRef),\n-    DynamicFailureHandlerClass(Box<DynamicFailureHandler<'a>>),\n+    Unreachable\n }\n \n impl<'a> FailureHandler<'a> {\n     fn is_infallible(&self) -> bool {\n         match *self {\n             Infallible => true,\n-            _ => false,\n+            _ => false\n         }\n     }\n \n     fn is_fallible(&self) -> bool {\n         !self.is_infallible()\n     }\n \n-    fn handle_fail(&self) -> BasicBlockRef {\n+    fn handle_fail(&self, bcx: &Block) {\n         match *self {\n-            Infallible => {\n-                fail!(\"attempted to fail in infallible failure handler!\")\n-            }\n-            JumpToBasicBlock(basic_block) => basic_block,\n-            DynamicFailureHandlerClass(ref dynamic_failure_handler) => {\n-                dynamic_failure_handler.handle_fail()\n-            }\n+            Infallible =>\n+                fail!(\"attempted to fail in infallible failure handler!\"),\n+            JumpToBasicBlock(basic_block) =>\n+                Br(bcx, basic_block),\n+            Unreachable =>\n+                build::Unreachable(bcx)\n         }\n     }\n }\n@@ -1005,7 +955,7 @@ fn compile_guard<'a, 'b>(\n             // condition explicitly rather than (possibly) falling back to\n             // the default arm.\n             &JumpToBasicBlock(_) if m.len() == 1 && has_genuine_default => {\n-                Br(bcx, chk.handle_fail());\n+                chk.handle_fail(bcx);\n             }\n             _ => {\n                 compile_submatch(bcx, m, vals, chk, has_genuine_default);\n@@ -1030,7 +980,7 @@ fn compile_submatch<'a, 'b>(\n     let mut bcx = bcx;\n     if m.len() == 0u {\n         if chk.is_fallible() {\n-            Br(bcx, chk.handle_fail());\n+            chk.handle_fail(bcx);\n         }\n         return;\n     }\n@@ -1301,7 +1251,7 @@ fn compile_submatch_continue<'a, 'b>(\n             // condition explicitly rather than (eventually) falling back to\n             // the last default arm.\n             &JumpToBasicBlock(_) if defaults.len() == 1 && has_genuine_default => {\n-                Br(else_cx, chk.handle_fail());\n+                chk.handle_fail(else_cx);\n             }\n             _ => {\n                 compile_submatch(else_cx,\n@@ -1395,21 +1345,10 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n     }\n \n     let t = node_id_type(bcx, discr_expr.id);\n-    let chk = {\n-        if ty::type_is_empty(tcx, t) {\n-            // Special case for empty types\n-            let fail_cx = Cell::new(None);\n-            let fail_handler = box DynamicFailureHandler {\n-                bcx: scope_cx,\n-                sp: discr_expr.span,\n-                msg: InternedString::new(\"scrutinizing value that can't \\\n-                                          exist\"),\n-                finished: fail_cx,\n-            };\n-            DynamicFailureHandlerClass(fail_handler)\n-        } else {\n-            Infallible\n-        }\n+    let chk = if ty::type_is_empty(tcx, t) {\n+        Unreachable\n+    } else {\n+        Infallible\n     };\n \n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {"}]}