{"sha": "72da5a9d85a522b11e80d0fdd1fd95247d442604", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZGE1YTlkODVhNTIyYjExZTgwZDBmZGQxZmQ5NTI0N2Q0NDI2MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-26T18:51:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-26T18:51:45Z"}, "message": "Auto merge of #77671 - flip1995:lint_list_always_plugins, r=oli-obk,Manishearth\n\nAlways print lints from plugins, if they're available\n\nCurrently you can get a list of lints and lint groups by running `rustc\n-Whelp`. This prints an additional line at the end:\n```\nCompiler plugins can provide additional lints and lint groups. To see a listing of these, re-run `rustc -W help` with a crate filename.\n```\n\nClippy is such a \"compiler plugin\", that provides additional lints.\nRunning `clippy-driver -Whelp` (`rustc` wrapper) still only prints the\nrustc lints with the above message at the end. But when running\n`clippy-driver -Whelp main.rs`, where `main.rs` is any rust file, it\nalso prints Clippy lints. I don't think this is a good approach from a\nUX perspective: Why is a random file necessary to print a help message?\n\nThis PR changes this behavior: Whenever a compiler callback\nregisters lints, it is assumed that these lints come from a plugin and\nare printed without having to specify a Rust source file.\n\nFixes rust-lang/rust-clippy#6122\n\ncc `@Manishearth` `@ebroto` for the Clippy changes.", "tree": {"sha": "a8bb60c04cf42d64d9e8bbf5a56b0bed0cdf69c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8bb60c04cf42d64d9e8bbf5a56b0bed0cdf69c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72da5a9d85a522b11e80d0fdd1fd95247d442604", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72da5a9d85a522b11e80d0fdd1fd95247d442604", "html_url": "https://github.com/rust-lang/rust/commit/72da5a9d85a522b11e80d0fdd1fd95247d442604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72da5a9d85a522b11e80d0fdd1fd95247d442604/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65ecc481fac7ceced57d973a580d0a7ccbdcb192", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ecc481fac7ceced57d973a580d0a7ccbdcb192", "html_url": "https://github.com/rust-lang/rust/commit/65ecc481fac7ceced57d973a580d0a7ccbdcb192"}, {"sha": "e54c0600b4ba25b0f7af582d9878bfd5c88736bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e54c0600b4ba25b0f7af582d9878bfd5c88736bc", "html_url": "https://github.com/rust-lang/rust/commit/e54c0600b4ba25b0f7af582d9878bfd5c88736bc"}], "stats": {"total": 3124, "additions": 14, "deletions": 3110}, "files": [{"sha": "c1741bfaabad25e648f6678178c636dccee6f0e5", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72da5a9d85a522b11e80d0fdd1fd95247d442604/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72da5a9d85a522b11e80d0fdd1fd95247d442604/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=72da5a9d85a522b11e80d0fdd1fd95247d442604", "patch": "@@ -248,11 +248,18 @@ fn run_compiler(\n                 interface::run_compiler(config, |compiler| {\n                     let sopts = &compiler.session().opts;\n                     if sopts.describe_lints {\n-                        let lint_store = rustc_lint::new_lint_store(\n+                        let mut lint_store = rustc_lint::new_lint_store(\n                             sopts.debugging_opts.no_interleave_lints,\n                             compiler.session().unstable_options(),\n                         );\n-                        describe_lints(compiler.session(), &lint_store, false);\n+                        let registered_lints =\n+                            if let Some(register_lints) = compiler.register_lints() {\n+                                register_lints(compiler.session(), &mut lint_store);\n+                                true\n+                            } else {\n+                                false\n+                            };\n+                        describe_lints(compiler.session(), &lint_store, registered_lints);\n                         return;\n                     }\n                     let should_stop = RustcDefaultCalls::print_crate_info(\n@@ -954,10 +961,7 @@ Available lint options:\n \n     match (loaded_plugins, plugin.len(), plugin_groups.len()) {\n         (false, 0, _) | (false, _, 0) => {\n-            println!(\n-                \"Compiler plugins can provide additional lints and lint groups. To see a \\\n-                      listing of these, re-run `rustc -W help` with a crate filename.\"\n-            );\n+            println!(\"Lint tools like Clippy can provide additional lints and lint groups.\");\n         }\n         (false, ..) => panic!(\"didn't load lint plugins but got them anyway!\"),\n         (true, 0, 0) => println!(\"This crate does not load any lint plugins or lint groups.\"),"}, {"sha": "11dd6ec32c094b3fee96fe28c9aed10782ce7f85", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/72da5a9d85a522b11e80d0fdd1fd95247d442604/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72da5a9d85a522b11e80d0fdd1fd95247d442604/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=72da5a9d85a522b11e80d0fdd1fd95247d442604", "patch": "@@ -56,6 +56,9 @@ impl Compiler {\n     pub fn output_file(&self) -> &Option<PathBuf> {\n         &self.output_file\n     }\n+    pub fn register_lints(&self) -> &Option<Box<dyn Fn(&Session, &mut LintStore) + Send + Sync>> {\n+        &self.register_lints\n+    }\n     pub fn build_output_filenames(\n         &self,\n         sess: &Session,"}, {"sha": "fcf093f8835d866f7a2059521999ab75dd58c065", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72da5a9d85a522b11e80d0fdd1fd95247d442604/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72da5a9d85a522b11e80d0fdd1fd95247d442604/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=72da5a9d85a522b11e80d0fdd1fd95247d442604", "patch": "@@ -22,20 +22,7 @@ pub fn run(update_mode: UpdateMode) {\n \n     let usable_lint_count = round_to_fifty(usable_lints.len());\n \n-    let mut file_change = replace_region_in_file(\n-        Path::new(\"src/lintlist/mod.rs\"),\n-        \"begin lint list\",\n-        \"end lint list\",\n-        false,\n-        update_mode == UpdateMode::Change,\n-        || {\n-            format!(\"vec!{:#?}\", sorted_usable_lints)\n-                .lines()\n-                .map(ToString::to_string)\n-                .collect::<Vec<_>>()\n-        },\n-    )\n-    .changed;\n+    let mut file_change = false;\n \n     file_change |= replace_region_in_file(\n         Path::new(\"README.md\"),"}, {"sha": "ef31c72481a236793b026fac2c02ca820268ac2c", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/72da5a9d85a522b11e80d0fdd1fd95247d442604/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72da5a9d85a522b11e80d0fdd1fd95247d442604/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=72da5a9d85a522b11e80d0fdd1fd95247d442604", "patch": "@@ -8,7 +8,6 @@\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n-extern crate rustc_data_structures;\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_interface;\n@@ -26,8 +25,6 @@ use std::panic;\n use std::path::{Path, PathBuf};\n use std::process::{exit, Command};\n \n-mod lintlist;\n-\n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n /// true, then return it. The parameter is assumed to be either `--arg=value` or `--arg value`.\n fn arg_value<'a, T: Deref<Target = str>>(\n@@ -92,113 +89,6 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n     }\n }\n \n-#[allow(clippy::find_map, clippy::filter_map)]\n-fn describe_lints() {\n-    use lintlist::{Level, Lint, ALL_LINTS, LINT_LEVELS};\n-    use rustc_data_structures::fx::FxHashSet;\n-\n-    println!(\n-        \"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> (deny <foo> and all attempts to override)\n-\n-\"\n-    );\n-\n-    let lint_level = |lint: &Lint| {\n-        LINT_LEVELS\n-            .iter()\n-            .find(|level_mapping| level_mapping.0 == lint.group)\n-            .map(|(_, level)| match level {\n-                Level::Allow => \"allow\",\n-                Level::Warn => \"warn\",\n-                Level::Deny => \"deny\",\n-            })\n-            .unwrap()\n-    };\n-\n-    let mut lints: Vec<_> = ALL_LINTS.iter().collect();\n-    // The sort doesn't case-fold but it's doubtful we care.\n-    lints.sort_by_cached_key(|x: &&Lint| (lint_level(x), x.name));\n-\n-    let max_lint_name_len = lints\n-        .iter()\n-        .map(|lint| lint.name.len())\n-        .map(|len| len + \"clippy::\".len())\n-        .max()\n-        .unwrap_or(0);\n-\n-    let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_lint_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    let scoped = |x: &str| format!(\"clippy::{}\", x);\n-\n-    let lint_groups: FxHashSet<_> = lints.iter().map(|lint| lint.group).collect();\n-\n-    println!(\"Lint checks provided by clippy:\\n\");\n-    println!(\"    {}  {:7.7}  meaning\", padded(\"name\"), \"default\");\n-    println!(\"    {}  {:7.7}  -------\", padded(\"----\"), \"-------\");\n-\n-    let print_lints = |lints: &[&Lint]| {\n-        for lint in lints {\n-            let name = lint.name.replace(\"_\", \"-\");\n-            println!(\n-                \"    {}  {:7.7}  {}\",\n-                padded(&scoped(&name)),\n-                lint_level(lint),\n-                lint.desc\n-            );\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lints(&lints);\n-\n-    let max_group_name_len = std::cmp::max(\n-        \"clippy::all\".len(),\n-        lint_groups\n-            .iter()\n-            .map(|group| group.len())\n-            .map(|len| len + \"clippy::\".len())\n-            .max()\n-            .unwrap_or(0),\n-    );\n-\n-    let padded_group = |x: &str| {\n-        let mut s = \" \".repeat(max_group_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    println!(\"Lint groups provided by clippy:\\n\");\n-    println!(\"    {}  sub-lints\", padded_group(\"name\"));\n-    println!(\"    {}  ---------\", padded_group(\"----\"));\n-    println!(\"    {}  the set of all clippy lints\", padded_group(\"clippy::all\"));\n-\n-    let print_lint_groups = || {\n-        for group in lint_groups {\n-            let name = group.to_lowercase().replace(\"_\", \"-\");\n-            let desc = lints\n-                .iter()\n-                .filter(|&lint| lint.group == group)\n-                .map(|lint| lint.name)\n-                .map(|name| name.replace(\"_\", \"-\"))\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-            println!(\"    {}  {}\", padded_group(&scoped(&name)), desc);\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lint_groups();\n-}\n-\n fn display_help() {\n     println!(\n         \"\\\n@@ -379,17 +269,6 @@ pub fn main() {\n             exit(0);\n         }\n \n-        let should_describe_lints = || {\n-            let args: Vec<_> = env::args().collect();\n-            args.windows(2)\n-                .any(|args| args[1] == \"help\" && matches!(args[0].as_str(), \"-W\" | \"-A\" | \"-D\" | \"-F\"))\n-        };\n-\n-        if !wrapper_mode && should_describe_lints() {\n-            describe_lints();\n-            exit(0);\n-        }\n-\n         // this conditional check for the --sysroot flag is there so users can call\n         // `clippy_driver` directly\n         // without having to pass --sysroot or anything"}, {"sha": "c817d83b33aeb12df5817b1c5a2e891c3423df17", "filename": "src/tools/clippy/src/lintlist/lint.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Flint.rs?ref=65ecc481fac7ceced57d973a580d0a7ccbdcb192", "patch": "@@ -1,27 +0,0 @@\n-/// Lint data parsed from the Clippy source code.\n-#[derive(Clone, PartialEq, Debug)]\n-pub struct Lint {\n-    pub name: &'static str,\n-    pub group: &'static str,\n-    pub desc: &'static str,\n-    pub deprecation: Option<&'static str>,\n-    pub module: &'static str,\n-}\n-\n-#[derive(PartialOrd, PartialEq, Ord, Eq)]\n-pub enum Level {\n-    Allow,\n-    Warn,\n-    Deny,\n-}\n-\n-pub const LINT_LEVELS: [(&str, Level); 8] = [\n-    (\"correctness\", Level::Deny),\n-    (\"style\", Level::Warn),\n-    (\"complexity\", Level::Warn),\n-    (\"perf\", Level::Warn),\n-    (\"restriction\", Level::Allow),\n-    (\"pedantic\", Level::Allow),\n-    (\"nursery\", Level::Allow),\n-    (\"cargo\", Level::Allow),\n-];"}, {"sha": "1d906d20ad475eec2b7039d7b6703f4444c7dcb6", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "removed", "additions": 0, "deletions": 2942, "changes": 2942, "blob_url": "https://github.com/rust-lang/rust/blob/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ecc481fac7ceced57d973a580d0a7ccbdcb192/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=65ecc481fac7ceced57d973a580d0a7ccbdcb192", "patch": "@@ -1,2942 +0,0 @@\n-//! This file is managed by `cargo dev update_lints`. Do not edit or format this file.\n-\n-use std::lazy::SyncLazy;\n-\n-pub mod lint;\n-pub use lint::Level;\n-pub use lint::Lint;\n-pub use lint::LINT_LEVELS;\n-\n-#[rustfmt::skip]\n-pub static ALL_LINTS: SyncLazy<Vec<Lint>> = SyncLazy::new(|| {\n-// begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-vec![\n-    Lint {\n-        name: \"absurd_extreme_comparisons\",\n-        group: \"correctness\",\n-        desc: \"a comparison with a maximum or minimum value that is always true or false\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"almost_swapped\",\n-        group: \"correctness\",\n-        desc: \"`foo = bar; bar = foo` sequence\",\n-        deprecation: None,\n-        module: \"swap\",\n-    },\n-    Lint {\n-        name: \"approx_constant\",\n-        group: \"correctness\",\n-        desc: \"the approximate of a known float constant (in `std::fXX::consts`)\",\n-        deprecation: None,\n-        module: \"approx_const\",\n-    },\n-    Lint {\n-        name: \"as_conversions\",\n-        group: \"restriction\",\n-        desc: \"using a potentially dangerous silent `as` conversion\",\n-        deprecation: None,\n-        module: \"as_conversions\",\n-    },\n-    Lint {\n-        name: \"assertions_on_constants\",\n-        group: \"style\",\n-        desc: \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\",\n-        deprecation: None,\n-        module: \"assertions_on_constants\",\n-    },\n-    Lint {\n-        name: \"assign_op_pattern\",\n-        group: \"style\",\n-        desc: \"assigning the result of an operation on a variable to that same variable\",\n-        deprecation: None,\n-        module: \"assign_ops\",\n-    },\n-    Lint {\n-        name: \"async_yields_async\",\n-        group: \"correctness\",\n-        desc: \"async blocks that return a type that can be awaited\",\n-        deprecation: None,\n-        module: \"async_yields_async\",\n-    },\n-    Lint {\n-        name: \"await_holding_lock\",\n-        group: \"pedantic\",\n-        desc: \"Inside an async function, holding a MutexGuard while calling await\",\n-        deprecation: None,\n-        module: \"await_holding_invalid\",\n-    },\n-    Lint {\n-        name: \"await_holding_refcell_ref\",\n-        group: \"pedantic\",\n-        desc: \"Inside an async function, holding a RefCell ref while calling await\",\n-        deprecation: None,\n-        module: \"await_holding_invalid\",\n-    },\n-    Lint {\n-        name: \"bad_bit_mask\",\n-        group: \"correctness\",\n-        desc: \"expressions of the form `_ & mask == select` that will only ever return `true` or `false`\",\n-        deprecation: None,\n-        module: \"bit_mask\",\n-    },\n-    Lint {\n-        name: \"bind_instead_of_map\",\n-        group: \"complexity\",\n-        desc: \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"blacklisted_name\",\n-        group: \"style\",\n-        desc: \"usage of a blacklisted/placeholder name\",\n-        deprecation: None,\n-        module: \"blacklisted_name\",\n-    },\n-    Lint {\n-        name: \"blanket_clippy_restriction_lints\",\n-        group: \"style\",\n-        desc: \"enabling the complete restriction group\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"blocks_in_if_conditions\",\n-        group: \"style\",\n-        desc: \"useless or complex blocks that can be eliminated in conditions\",\n-        deprecation: None,\n-        module: \"blocks_in_if_conditions\",\n-    },\n-    Lint {\n-        name: \"bool_comparison\",\n-        group: \"complexity\",\n-        desc: \"comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\",\n-        deprecation: None,\n-        module: \"needless_bool\",\n-    },\n-    Lint {\n-        name: \"borrow_interior_mutable_const\",\n-        group: \"style\",\n-        desc: \"referencing `const` with interior mutability\",\n-        deprecation: None,\n-        module: \"non_copy_const\",\n-    },\n-    Lint {\n-        name: \"borrowed_box\",\n-        group: \"complexity\",\n-        desc: \"a borrow of a boxed type\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"box_vec\",\n-        group: \"perf\",\n-        desc: \"usage of `Box<Vec<T>>`, vector elements are already on the heap\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"boxed_local\",\n-        group: \"perf\",\n-        desc: \"using `Box<T>` where unnecessary\",\n-        deprecation: None,\n-        module: \"escape\",\n-    },\n-    Lint {\n-        name: \"builtin_type_shadow\",\n-        group: \"style\",\n-        desc: \"shadowing a builtin type\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"cargo_common_metadata\",\n-        group: \"cargo\",\n-        desc: \"common metadata is defined in `Cargo.toml`\",\n-        deprecation: None,\n-        module: \"cargo_common_metadata\",\n-    },\n-    Lint {\n-        name: \"cast_lossless\",\n-        group: \"pedantic\",\n-        desc: \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_possible_truncation\",\n-        group: \"pedantic\",\n-        desc: \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_possible_wrap\",\n-        group: \"pedantic\",\n-        desc: \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_precision_loss\",\n-        group: \"pedantic\",\n-        desc: \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_ptr_alignment\",\n-        group: \"pedantic\",\n-        desc: \"cast from a pointer to a more-strictly-aligned pointer\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_ref_to_mut\",\n-        group: \"correctness\",\n-        desc: \"a cast of reference to a mutable pointer\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"cast_sign_loss\",\n-        group: \"pedantic\",\n-        desc: \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"char_lit_as_u8\",\n-        group: \"complexity\",\n-        desc: \"casting a character literal to `u8` truncates\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"chars_last_cmp\",\n-        group: \"style\",\n-        desc: \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"chars_next_cmp\",\n-        group: \"style\",\n-        desc: \"using `.chars().next()` to check if a string starts with a char\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"checked_conversions\",\n-        group: \"pedantic\",\n-        desc: \"`try_from` could replace manual bounds checking when casting\",\n-        deprecation: None,\n-        module: \"checked_conversions\",\n-    },\n-    Lint {\n-        name: \"clone_double_ref\",\n-        group: \"correctness\",\n-        desc: \"using `clone` on `&&T`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"clone_on_copy\",\n-        group: \"complexity\",\n-        desc: \"using `clone` on a `Copy` type\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"clone_on_ref_ptr\",\n-        group: \"restriction\",\n-        desc: \"using \\'clone\\' on a ref-counted pointer\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"cmp_nan\",\n-        group: \"correctness\",\n-        desc: \"comparisons to `NAN`, which will always return false, probably not intended\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"cmp_null\",\n-        group: \"style\",\n-        desc: \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\",\n-        deprecation: None,\n-        module: \"ptr\",\n-    },\n-    Lint {\n-        name: \"cmp_owned\",\n-        group: \"perf\",\n-        desc: \"creating owned instances for comparing with others, e.g., `x == \\\"foo\\\".to_string()`\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"cognitive_complexity\",\n-        group: \"nursery\",\n-        desc: \"functions that should be split up into multiple functions\",\n-        deprecation: None,\n-        module: \"cognitive_complexity\",\n-    },\n-    Lint {\n-        name: \"collapsible_if\",\n-        group: \"style\",\n-        desc: \"`if`s that can be collapsed (e.g., `if x { if y { ... } }` and `else { if x { ... } }`)\",\n-        deprecation: None,\n-        module: \"collapsible_if\",\n-    },\n-    Lint {\n-        name: \"comparison_chain\",\n-        group: \"style\",\n-        desc: \"`if`s that can be rewritten with `match` and `cmp`\",\n-        deprecation: None,\n-        module: \"comparison_chain\",\n-    },\n-    Lint {\n-        name: \"comparison_to_empty\",\n-        group: \"style\",\n-        desc: \"checking `x == \\\"\\\"` or `x == []` (or similar) when `.is_empty()` could be used instead\",\n-        deprecation: None,\n-        module: \"len_zero\",\n-    },\n-    Lint {\n-        name: \"copy_iterator\",\n-        group: \"pedantic\",\n-        desc: \"implementing `Iterator` on a `Copy` type\",\n-        deprecation: None,\n-        module: \"copy_iterator\",\n-    },\n-    Lint {\n-        name: \"create_dir\",\n-        group: \"restriction\",\n-        desc: \"calling `std::fs::create_dir` instead of `std::fs::create_dir_all`\",\n-        deprecation: None,\n-        module: \"create_dir\",\n-    },\n-    Lint {\n-        name: \"crosspointer_transmute\",\n-        group: \"complexity\",\n-        desc: \"transmutes that have to or from types that are a pointer to the other\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"dbg_macro\",\n-        group: \"restriction\",\n-        desc: \"`dbg!` macro is intended as a debugging tool\",\n-        deprecation: None,\n-        module: \"dbg_macro\",\n-    },\n-    Lint {\n-        name: \"debug_assert_with_mut_call\",\n-        group: \"nursery\",\n-        desc: \"mutable arguments in `debug_assert{,_ne,_eq}!`\",\n-        deprecation: None,\n-        module: \"mutable_debug_assertion\",\n-    },\n-    Lint {\n-        name: \"decimal_literal_representation\",\n-        group: \"restriction\",\n-        desc: \"using decimal representation when hexadecimal would be better\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"declare_interior_mutable_const\",\n-        group: \"style\",\n-        desc: \"declaring `const` with interior mutability\",\n-        deprecation: None,\n-        module: \"non_copy_const\",\n-    },\n-    Lint {\n-        name: \"default_trait_access\",\n-        group: \"pedantic\",\n-        desc: \"checks for literal calls to `Default::default()`\",\n-        deprecation: None,\n-        module: \"default\",\n-    },\n-    Lint {\n-        name: \"deprecated_cfg_attr\",\n-        group: \"complexity\",\n-        desc: \"usage of `cfg_attr(rustfmt)` instead of tool attributes\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"deprecated_semver\",\n-        group: \"correctness\",\n-        desc: \"use of `#[deprecated(since = \\\"x\\\")]` where x is not semver\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"deref_addrof\",\n-        group: \"complexity\",\n-        desc: \"use of `*&` or `*&mut` in an expression\",\n-        deprecation: None,\n-        module: \"reference\",\n-    },\n-    Lint {\n-        name: \"derive_hash_xor_eq\",\n-        group: \"correctness\",\n-        desc: \"deriving `Hash` but implementing `PartialEq` explicitly\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"derive_ord_xor_partial_ord\",\n-        group: \"correctness\",\n-        desc: \"deriving `Ord` but implementing `PartialOrd` explicitly\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"disallowed_method\",\n-        group: \"nursery\",\n-        desc: \"use of a disallowed method call\",\n-        deprecation: None,\n-        module: \"disallowed_method\",\n-    },\n-    Lint {\n-        name: \"diverging_sub_expression\",\n-        group: \"complexity\",\n-        desc: \"whether an expression contains a diverging sub expression\",\n-        deprecation: None,\n-        module: \"eval_order_dependence\",\n-    },\n-    Lint {\n-        name: \"doc_markdown\",\n-        group: \"pedantic\",\n-        desc: \"presence of `_`, `::` or camel-case outside backticks in documentation\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"double_comparisons\",\n-        group: \"complexity\",\n-        desc: \"unnecessary double comparisons that can be simplified\",\n-        deprecation: None,\n-        module: \"double_comparison\",\n-    },\n-    Lint {\n-        name: \"double_must_use\",\n-        group: \"style\",\n-        desc: \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"double_neg\",\n-        group: \"style\",\n-        desc: \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"double_parens\",\n-        group: \"complexity\",\n-        desc: \"Warn on unnecessary double parentheses\",\n-        deprecation: None,\n-        module: \"double_parens\",\n-    },\n-    Lint {\n-        name: \"drop_copy\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::drop` with a value that implements Copy\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"drop_ref\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::drop` with a reference instead of an owned value\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"duplicate_underscore_argument\",\n-        group: \"style\",\n-        desc: \"function arguments having names which only differ by an underscore\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"duration_subsec\",\n-        group: \"complexity\",\n-        desc: \"checks for calculation of subsecond microseconds or milliseconds\",\n-        deprecation: None,\n-        module: \"duration_subsec\",\n-    },\n-    Lint {\n-        name: \"else_if_without_else\",\n-        group: \"restriction\",\n-        desc: \"`if` expression with an `else if`, but without a final `else` branch\",\n-        deprecation: None,\n-        module: \"else_if_without_else\",\n-    },\n-    Lint {\n-        name: \"empty_enum\",\n-        group: \"pedantic\",\n-        desc: \"enum with no variants\",\n-        deprecation: None,\n-        module: \"empty_enum\",\n-    },\n-    Lint {\n-        name: \"empty_line_after_outer_attr\",\n-        group: \"nursery\",\n-        desc: \"empty line after outer attribute\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"empty_loop\",\n-        group: \"style\",\n-        desc: \"empty `loop {}`, which should block or sleep\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"enum_clike_unportable_variant\",\n-        group: \"correctness\",\n-        desc: \"C-like enums that are `repr(isize/usize)` and have values that don\\'t fit into an `i32`\",\n-        deprecation: None,\n-        module: \"enum_clike\",\n-    },\n-    Lint {\n-        name: \"enum_glob_use\",\n-        group: \"pedantic\",\n-        desc: \"use items that import all variants of an enum\",\n-        deprecation: None,\n-        module: \"wildcard_imports\",\n-    },\n-    Lint {\n-        name: \"enum_variant_names\",\n-        group: \"style\",\n-        desc: \"enums where all variants share a prefix/postfix\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"eq_op\",\n-        group: \"correctness\",\n-        desc: \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\",\n-        deprecation: None,\n-        module: \"eq_op\",\n-    },\n-    Lint {\n-        name: \"erasing_op\",\n-        group: \"correctness\",\n-        desc: \"using erasing operations, e.g., `x * 0` or `y & 0`\",\n-        deprecation: None,\n-        module: \"erasing_op\",\n-    },\n-    Lint {\n-        name: \"eval_order_dependence\",\n-        group: \"complexity\",\n-        desc: \"whether a variable read occurs before a write depends on sub-expression evaluation order\",\n-        deprecation: None,\n-        module: \"eval_order_dependence\",\n-    },\n-    Lint {\n-        name: \"excessive_precision\",\n-        group: \"style\",\n-        desc: \"excessive precision for float literal\",\n-        deprecation: None,\n-        module: \"float_literal\",\n-    },\n-    Lint {\n-        name: \"exit\",\n-        group: \"restriction\",\n-        desc: \"`std::process::exit` is called, terminating the program\",\n-        deprecation: None,\n-        module: \"exit\",\n-    },\n-    Lint {\n-        name: \"expect_fun_call\",\n-        group: \"perf\",\n-        desc: \"using any `expect` method with a function call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"expect_used\",\n-        group: \"restriction\",\n-        desc: \"using `.expect()` on `Result` or `Option`, which might be better handled\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"expl_impl_clone_on_copy\",\n-        group: \"pedantic\",\n-        desc: \"implementing `Clone` explicitly on `Copy` types\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"explicit_counter_loop\",\n-        group: \"complexity\",\n-        desc: \"for-looping with an explicit counter when `_.enumerate()` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"explicit_deref_methods\",\n-        group: \"pedantic\",\n-        desc: \"Explicit use of deref or deref_mut method while not in a method chain.\",\n-        deprecation: None,\n-        module: \"dereference\",\n-    },\n-    Lint {\n-        name: \"explicit_into_iter_loop\",\n-        group: \"pedantic\",\n-        desc: \"for-looping over `_.into_iter()` when `_` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"explicit_iter_loop\",\n-        group: \"pedantic\",\n-        desc: \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"explicit_write\",\n-        group: \"complexity\",\n-        desc: \"using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\",\n-        deprecation: None,\n-        module: \"explicit_write\",\n-    },\n-    Lint {\n-        name: \"extra_unused_lifetimes\",\n-        group: \"complexity\",\n-        desc: \"unused lifetimes in function definitions\",\n-        deprecation: None,\n-        module: \"lifetimes\",\n-    },\n-    Lint {\n-        name: \"fallible_impl_from\",\n-        group: \"nursery\",\n-        desc: \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\",\n-        deprecation: None,\n-        module: \"fallible_impl_from\",\n-    },\n-    Lint {\n-        name: \"field_reassign_with_default\",\n-        group: \"style\",\n-        desc: \"binding initialized with Default should have its fields set in the initializer\",\n-        deprecation: None,\n-        module: \"default\",\n-    },\n-    Lint {\n-        name: \"filetype_is_file\",\n-        group: \"restriction\",\n-        desc: \"`FileType::is_file` is not recommended to test for readable file type\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"filter_map\",\n-        group: \"pedantic\",\n-        desc: \"using combinations of `filter`, `map`, `filter_map` and `flat_map` which can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"filter_map_next\",\n-        group: \"pedantic\",\n-        desc: \"using combination of `filter_map` and `next` which can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"filter_next\",\n-        group: \"complexity\",\n-        desc: \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"find_map\",\n-        group: \"pedantic\",\n-        desc: \"using a combination of `find` and `map` can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"flat_map_identity\",\n-        group: \"complexity\",\n-        desc: \"call to `flat_map` where `flatten` is sufficient\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"float_arithmetic\",\n-        group: \"restriction\",\n-        desc: \"any floating-point arithmetic statement\",\n-        deprecation: None,\n-        module: \"arithmetic\",\n-    },\n-    Lint {\n-        name: \"float_cmp\",\n-        group: \"correctness\",\n-        desc: \"using `==` or `!=` on float values instead of comparing difference with an epsilon\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"float_cmp_const\",\n-        group: \"restriction\",\n-        desc: \"using `==` or `!=` on float constants instead of comparing difference with an epsilon\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"float_equality_without_abs\",\n-        group: \"correctness\",\n-        desc: \"float equality check without `.abs()`\",\n-        deprecation: None,\n-        module: \"float_equality_without_abs\",\n-    },\n-    Lint {\n-        name: \"fn_address_comparisons\",\n-        group: \"correctness\",\n-        desc: \"comparison with an address of a function item\",\n-        deprecation: None,\n-        module: \"unnamed_address\",\n-    },\n-    Lint {\n-        name: \"fn_params_excessive_bools\",\n-        group: \"pedantic\",\n-        desc: \"using too many bools in function parameters\",\n-        deprecation: None,\n-        module: \"excessive_bools\",\n-    },\n-    Lint {\n-        name: \"fn_to_numeric_cast\",\n-        group: \"style\",\n-        desc: \"casting a function pointer to a numeric type other than usize\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"fn_to_numeric_cast_with_truncation\",\n-        group: \"style\",\n-        desc: \"casting a function pointer to a numeric type not wide enough to store the address\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"for_kv_map\",\n-        group: \"style\",\n-        desc: \"looping on a map using `iter` when `keys` or `values` would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"for_loops_over_fallibles\",\n-        group: \"correctness\",\n-        desc: \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"forget_copy\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::forget` with a value that implements Copy\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"forget_ref\",\n-        group: \"correctness\",\n-        desc: \"calls to `std::mem::forget` with a reference instead of an owned value\",\n-        deprecation: None,\n-        module: \"drop_forget_ref\",\n-    },\n-    Lint {\n-        name: \"from_iter_instead_of_collect\",\n-        group: \"style\",\n-        desc: \"use `.collect()` instead of `::from_iter()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"future_not_send\",\n-        group: \"nursery\",\n-        desc: \"public Futures must be Send\",\n-        deprecation: None,\n-        module: \"future_not_send\",\n-    },\n-    Lint {\n-        name: \"get_last_with_len\",\n-        group: \"complexity\",\n-        desc: \"Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\",\n-        deprecation: None,\n-        module: \"get_last_with_len\",\n-    },\n-    Lint {\n-        name: \"get_unwrap\",\n-        group: \"restriction\",\n-        desc: \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"identity_op\",\n-        group: \"complexity\",\n-        desc: \"using identity operations, e.g., `x + 0` or `y / 1`\",\n-        deprecation: None,\n-        module: \"identity_op\",\n-    },\n-    Lint {\n-        name: \"if_let_mutex\",\n-        group: \"correctness\",\n-        desc: \"locking a `Mutex` in an `if let` block can cause deadlocks\",\n-        deprecation: None,\n-        module: \"if_let_mutex\",\n-    },\n-    Lint {\n-        name: \"if_let_some_result\",\n-        group: \"style\",\n-        desc: \"usage of `ok()` in `if let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\",\n-        deprecation: None,\n-        module: \"if_let_some_result\",\n-    },\n-    Lint {\n-        name: \"if_not_else\",\n-        group: \"pedantic\",\n-        desc: \"`if` branches that could be swapped so no negation operation is necessary on the condition\",\n-        deprecation: None,\n-        module: \"if_not_else\",\n-    },\n-    Lint {\n-        name: \"if_same_then_else\",\n-        group: \"correctness\",\n-        desc: \"`if` with the same `then` and `else` blocks\",\n-        deprecation: None,\n-        module: \"copies\",\n-    },\n-    Lint {\n-        name: \"ifs_same_cond\",\n-        group: \"correctness\",\n-        desc: \"consecutive `if`s with the same condition\",\n-        deprecation: None,\n-        module: \"copies\",\n-    },\n-    Lint {\n-        name: \"implicit_hasher\",\n-        group: \"pedantic\",\n-        desc: \"missing generalization over different hashers\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"implicit_return\",\n-        group: \"restriction\",\n-        desc: \"use a return statement like `return expr` instead of an expression\",\n-        deprecation: None,\n-        module: \"implicit_return\",\n-    },\n-    Lint {\n-        name: \"implicit_saturating_sub\",\n-        group: \"pedantic\",\n-        desc: \"Perform saturating subtraction instead of implicitly checking lower bound of data type\",\n-        deprecation: None,\n-        module: \"implicit_saturating_sub\",\n-    },\n-    Lint {\n-        name: \"imprecise_flops\",\n-        group: \"nursery\",\n-        desc: \"usage of imprecise floating point operations\",\n-        deprecation: None,\n-        module: \"floating_point_arithmetic\",\n-    },\n-    Lint {\n-        name: \"inconsistent_digit_grouping\",\n-        group: \"style\",\n-        desc: \"integer literals with digits grouped inconsistently\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"indexing_slicing\",\n-        group: \"restriction\",\n-        desc: \"indexing/slicing usage\",\n-        deprecation: None,\n-        module: \"indexing_slicing\",\n-    },\n-    Lint {\n-        name: \"ineffective_bit_mask\",\n-        group: \"correctness\",\n-        desc: \"expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\",\n-        deprecation: None,\n-        module: \"bit_mask\",\n-    },\n-    Lint {\n-        name: \"inefficient_to_string\",\n-        group: \"pedantic\",\n-        desc: \"using `to_string` on `&&T` where `T: ToString`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"infallible_destructuring_match\",\n-        group: \"style\",\n-        desc: \"a `match` statement with a single infallible arm instead of a `let`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"infinite_iter\",\n-        group: \"correctness\",\n-        desc: \"infinite iteration\",\n-        deprecation: None,\n-        module: \"infinite_iter\",\n-    },\n-    Lint {\n-        name: \"inherent_to_string\",\n-        group: \"style\",\n-        desc: \"type implements inherent method `to_string()`, but should instead implement the `Display` trait\",\n-        deprecation: None,\n-        module: \"inherent_to_string\",\n-    },\n-    Lint {\n-        name: \"inherent_to_string_shadow_display\",\n-        group: \"correctness\",\n-        desc: \"type implements inherent method `to_string()`, which gets shadowed by the implementation of the `Display` trait\",\n-        deprecation: None,\n-        module: \"inherent_to_string\",\n-    },\n-    Lint {\n-        name: \"inline_always\",\n-        group: \"pedantic\",\n-        desc: \"use of `#[inline(always)]`\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"inline_asm_x86_att_syntax\",\n-        group: \"restriction\",\n-        desc: \"prefer Intel x86 assembly syntax\",\n-        deprecation: None,\n-        module: \"asm_syntax\",\n-    },\n-    Lint {\n-        name: \"inline_asm_x86_intel_syntax\",\n-        group: \"restriction\",\n-        desc: \"prefer AT&T x86 assembly syntax\",\n-        deprecation: None,\n-        module: \"asm_syntax\",\n-    },\n-    Lint {\n-        name: \"inline_fn_without_body\",\n-        group: \"correctness\",\n-        desc: \"use of `#[inline]` on trait methods without bodies\",\n-        deprecation: None,\n-        module: \"inline_fn_without_body\",\n-    },\n-    Lint {\n-        name: \"int_plus_one\",\n-        group: \"complexity\",\n-        desc: \"instead of using `x >= y + 1`, use `x > y`\",\n-        deprecation: None,\n-        module: \"int_plus_one\",\n-    },\n-    Lint {\n-        name: \"integer_arithmetic\",\n-        group: \"restriction\",\n-        desc: \"any integer arithmetic expression which could overflow or panic\",\n-        deprecation: None,\n-        module: \"arithmetic\",\n-    },\n-    Lint {\n-        name: \"integer_division\",\n-        group: \"restriction\",\n-        desc: \"integer division may cause loss of precision\",\n-        deprecation: None,\n-        module: \"integer_division\",\n-    },\n-    Lint {\n-        name: \"into_iter_on_ref\",\n-        group: \"style\",\n-        desc: \"using `.into_iter()` on a reference\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"invalid_atomic_ordering\",\n-        group: \"correctness\",\n-        desc: \"usage of invalid atomic ordering in atomic operations and memory fences\",\n-        deprecation: None,\n-        module: \"atomic_ordering\",\n-    },\n-    Lint {\n-        name: \"invalid_regex\",\n-        group: \"correctness\",\n-        desc: \"invalid regular expressions\",\n-        deprecation: None,\n-        module: \"regex\",\n-    },\n-    Lint {\n-        name: \"invalid_upcast_comparisons\",\n-        group: \"pedantic\",\n-        desc: \"a comparison involving an upcast which is always true or false\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"invisible_characters\",\n-        group: \"correctness\",\n-        desc: \"using an invisible character in a string literal, which is confusing\",\n-        deprecation: None,\n-        module: \"unicode\",\n-    },\n-    Lint {\n-        name: \"items_after_statements\",\n-        group: \"pedantic\",\n-        desc: \"blocks where an item comes after a statement\",\n-        deprecation: None,\n-        module: \"items_after_statements\",\n-    },\n-    Lint {\n-        name: \"iter_cloned_collect\",\n-        group: \"style\",\n-        desc: \"using `.cloned().collect()` on slice to create a `Vec`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_next_loop\",\n-        group: \"correctness\",\n-        desc: \"for-looping over `_.next()` which is probably not intended\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"iter_next_slice\",\n-        group: \"style\",\n-        desc: \"using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_nth\",\n-        group: \"perf\",\n-        desc: \"using `.iter().nth()` on a standard library type with O(1) element access\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_nth_zero\",\n-        group: \"style\",\n-        desc: \"replace `iter.nth(0)` with `iter.next()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iter_skip_next\",\n-        group: \"style\",\n-        desc: \"using `.skip(x).next()` on an iterator\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"iterator_step_by_zero\",\n-        group: \"correctness\",\n-        desc: \"using `Iterator::step_by(0)`, which will panic at runtime\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"just_underscores_and_digits\",\n-        group: \"style\",\n-        desc: \"unclear name\",\n-        deprecation: None,\n-        module: \"non_expressive_names\",\n-    },\n-    Lint {\n-        name: \"large_const_arrays\",\n-        group: \"perf\",\n-        desc: \"large non-scalar const array may cause performance overhead\",\n-        deprecation: None,\n-        module: \"large_const_arrays\",\n-    },\n-    Lint {\n-        name: \"large_digit_groups\",\n-        group: \"pedantic\",\n-        desc: \"grouping digits into groups that are too large\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"large_enum_variant\",\n-        group: \"perf\",\n-        desc: \"large size difference between variants on an enum\",\n-        deprecation: None,\n-        module: \"large_enum_variant\",\n-    },\n-    Lint {\n-        name: \"large_stack_arrays\",\n-        group: \"pedantic\",\n-        desc: \"allocating large arrays on stack may cause stack overflow\",\n-        deprecation: None,\n-        module: \"large_stack_arrays\",\n-    },\n-    Lint {\n-        name: \"large_types_passed_by_value\",\n-        group: \"pedantic\",\n-        desc: \"functions taking large arguments by value\",\n-        deprecation: None,\n-        module: \"pass_by_ref_or_value\",\n-    },\n-    Lint {\n-        name: \"len_without_is_empty\",\n-        group: \"style\",\n-        desc: \"traits or impls with a public `len` method but no corresponding `is_empty` method\",\n-        deprecation: None,\n-        module: \"len_zero\",\n-    },\n-    Lint {\n-        name: \"len_zero\",\n-        group: \"style\",\n-        desc: \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\",\n-        deprecation: None,\n-        module: \"len_zero\",\n-    },\n-    Lint {\n-        name: \"let_and_return\",\n-        group: \"style\",\n-        desc: \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\",\n-        deprecation: None,\n-        module: \"returns\",\n-    },\n-    Lint {\n-        name: \"let_underscore_drop\",\n-        group: \"pedantic\",\n-        desc: \"non-binding let on a type that implements `Drop`\",\n-        deprecation: None,\n-        module: \"let_underscore\",\n-    },\n-    Lint {\n-        name: \"let_underscore_lock\",\n-        group: \"correctness\",\n-        desc: \"non-binding let on a synchronization lock\",\n-        deprecation: None,\n-        module: \"let_underscore\",\n-    },\n-    Lint {\n-        name: \"let_underscore_must_use\",\n-        group: \"restriction\",\n-        desc: \"non-binding let on a `#[must_use]` expression\",\n-        deprecation: None,\n-        module: \"let_underscore\",\n-    },\n-    Lint {\n-        name: \"let_unit_value\",\n-        group: \"pedantic\",\n-        desc: \"creating a `let` binding to a value of unit type, which usually can\\'t be used afterwards\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"linkedlist\",\n-        group: \"pedantic\",\n-        desc: \"usage of LinkedList, usually a vector is faster, or a more specialized data structure like a `VecDeque`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"logic_bug\",\n-        group: \"correctness\",\n-        desc: \"boolean expressions that contain terminals which can be eliminated\",\n-        deprecation: None,\n-        module: \"booleans\",\n-    },\n-    Lint {\n-        name: \"lossy_float_literal\",\n-        group: \"restriction\",\n-        desc: \"lossy whole number float literals\",\n-        deprecation: None,\n-        module: \"float_literal\",\n-    },\n-    Lint {\n-        name: \"macro_use_imports\",\n-        group: \"pedantic\",\n-        desc: \"#[macro_use] is no longer needed\",\n-        deprecation: None,\n-        module: \"macro_use\",\n-    },\n-    Lint {\n-        name: \"main_recursion\",\n-        group: \"style\",\n-        desc: \"recursion using the entrypoint\",\n-        deprecation: None,\n-        module: \"main_recursion\",\n-    },\n-    Lint {\n-        name: \"manual_async_fn\",\n-        group: \"style\",\n-        desc: \"manual implementations of `async` functions can be simplified using the dedicated syntax\",\n-        deprecation: None,\n-        module: \"manual_async_fn\",\n-    },\n-    Lint {\n-        name: \"manual_memcpy\",\n-        group: \"perf\",\n-        desc: \"manually copying items between slices\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"manual_non_exhaustive\",\n-        group: \"style\",\n-        desc: \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\",\n-        deprecation: None,\n-        module: \"manual_non_exhaustive\",\n-    },\n-    Lint {\n-        name: \"manual_ok_or\",\n-        group: \"pedantic\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::ok_or`\",\n-        deprecation: None,\n-        module: \"manual_ok_or\",\n-    },\n-    Lint {\n-        name: \"manual_range_contains\",\n-        group: \"style\",\n-        desc: \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"manual_saturating_arithmetic\",\n-        group: \"style\",\n-        desc: \"`.chcked_add/sub(x).unwrap_or(MAX/MIN)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"manual_strip\",\n-        group: \"complexity\",\n-        desc: \"suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\",\n-        deprecation: None,\n-        module: \"manual_strip\",\n-    },\n-    Lint {\n-        name: \"manual_swap\",\n-        group: \"complexity\",\n-        desc: \"manual swap of two variables\",\n-        deprecation: None,\n-        module: \"swap\",\n-    },\n-    Lint {\n-        name: \"manual_unwrap_or\",\n-        group: \"complexity\",\n-        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\",\n-        deprecation: None,\n-        module: \"manual_unwrap_or\",\n-    },\n-    Lint {\n-        name: \"many_single_char_names\",\n-        group: \"style\",\n-        desc: \"too many single character bindings\",\n-        deprecation: None,\n-        module: \"non_expressive_names\",\n-    },\n-    Lint {\n-        name: \"map_clone\",\n-        group: \"style\",\n-        desc: \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\",\n-        deprecation: None,\n-        module: \"map_clone\",\n-    },\n-    Lint {\n-        name: \"map_collect_result_unit\",\n-        group: \"style\",\n-        desc: \"using `.map(_).collect::<Result<(),_>()`, which can be replaced with `try_for_each`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"map_entry\",\n-        group: \"perf\",\n-        desc: \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\",\n-        deprecation: None,\n-        module: \"entry\",\n-    },\n-    Lint {\n-        name: \"map_err_ignore\",\n-        group: \"pedantic\",\n-        desc: \"`map_err` should not ignore the original error\",\n-        deprecation: None,\n-        module: \"map_err_ignore\",\n-    },\n-    Lint {\n-        name: \"map_flatten\",\n-        group: \"pedantic\",\n-        desc: \"using combinations of `flatten` and `map` which can usually be written as a single method call\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"map_identity\",\n-        group: \"complexity\",\n-        desc: \"using iterator.map(|x| x)\",\n-        deprecation: None,\n-        module: \"map_identity\",\n-    },\n-    Lint {\n-        name: \"map_unwrap_or\",\n-        group: \"pedantic\",\n-        desc: \"using `.map(f).unwrap_or(a)` or `.map(f).unwrap_or_else(func)`, which are more succinctly expressed as `map_or(a, f)` or `map_or_else(a, f)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"match_as_ref\",\n-        group: \"complexity\",\n-        desc: \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_bool\",\n-        group: \"pedantic\",\n-        desc: \"a `match` on a boolean expression instead of an `if..else` block\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_like_matches_macro\",\n-        group: \"style\",\n-        desc: \"a match that could be written with the matches! macro\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_on_vec_items\",\n-        group: \"pedantic\",\n-        desc: \"matching on vector elements can panic\",\n-        deprecation: None,\n-        module: \"match_on_vec_items\",\n-    },\n-    Lint {\n-        name: \"match_overlapping_arm\",\n-        group: \"style\",\n-        desc: \"a `match` with overlapping arms\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_ref_pats\",\n-        group: \"style\",\n-        desc: \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_same_arms\",\n-        group: \"pedantic\",\n-        desc: \"`match` with identical arm bodies\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_single_binding\",\n-        group: \"complexity\",\n-        desc: \"a match with a single binding instead of using `let` statement\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_wild_err_arm\",\n-        group: \"pedantic\",\n-        desc: \"a `match` with `Err(_)` arm and take drastic actions\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"match_wildcard_for_single_variants\",\n-        group: \"pedantic\",\n-        desc: \"a wildcard enum match for a single variant\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"maybe_infinite_iter\",\n-        group: \"pedantic\",\n-        desc: \"possible infinite iteration\",\n-        deprecation: None,\n-        module: \"infinite_iter\",\n-    },\n-    Lint {\n-        name: \"mem_discriminant_non_enum\",\n-        group: \"correctness\",\n-        desc: \"calling `mem::descriminant` on non-enum type\",\n-        deprecation: None,\n-        module: \"mem_discriminant\",\n-    },\n-    Lint {\n-        name: \"mem_forget\",\n-        group: \"restriction\",\n-        desc: \"`mem::forget` usage on `Drop` types, likely to cause memory leaks\",\n-        deprecation: None,\n-        module: \"mem_forget\",\n-    },\n-    Lint {\n-        name: \"mem_replace_option_with_none\",\n-        group: \"style\",\n-        desc: \"replacing an `Option` with `None` instead of `take()`\",\n-        deprecation: None,\n-        module: \"mem_replace\",\n-    },\n-    Lint {\n-        name: \"mem_replace_with_default\",\n-        group: \"style\",\n-        desc: \"replacing a value of type `T` with `T::default()` instead of using `std::mem::take`\",\n-        deprecation: None,\n-        module: \"mem_replace\",\n-    },\n-    Lint {\n-        name: \"mem_replace_with_uninit\",\n-        group: \"correctness\",\n-        desc: \"`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\",\n-        deprecation: None,\n-        module: \"mem_replace\",\n-    },\n-    Lint {\n-        name: \"min_max\",\n-        group: \"correctness\",\n-        desc: \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\",\n-        deprecation: None,\n-        module: \"minmax\",\n-    },\n-    Lint {\n-        name: \"mismatched_target_os\",\n-        group: \"correctness\",\n-        desc: \"usage of `cfg(operating_system)` instead of `cfg(target_os = \\\"operating_system\\\")`\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"misrefactored_assign_op\",\n-        group: \"complexity\",\n-        desc: \"having a variable on both sides of an assign op\",\n-        deprecation: None,\n-        module: \"assign_ops\",\n-    },\n-    Lint {\n-        name: \"missing_const_for_fn\",\n-        group: \"nursery\",\n-        desc: \"Lint functions definitions that could be made `const fn`\",\n-        deprecation: None,\n-        module: \"missing_const_for_fn\",\n-    },\n-    Lint {\n-        name: \"missing_docs_in_private_items\",\n-        group: \"restriction\",\n-        desc: \"detects missing documentation for public and private members\",\n-        deprecation: None,\n-        module: \"missing_doc\",\n-    },\n-    Lint {\n-        name: \"missing_errors_doc\",\n-        group: \"pedantic\",\n-        desc: \"`pub fn` returns `Result` without `# Errors` in doc comment\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"missing_inline_in_public_items\",\n-        group: \"restriction\",\n-        desc: \"detects missing `#[inline]` attribute for public callables (functions, trait methods, methods...)\",\n-        deprecation: None,\n-        module: \"missing_inline\",\n-    },\n-    Lint {\n-        name: \"missing_safety_doc\",\n-        group: \"style\",\n-        desc: \"`pub unsafe fn` without `# Safety` docs\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"mistyped_literal_suffixes\",\n-        group: \"correctness\",\n-        desc: \"mistyped literal suffix\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"mixed_case_hex_literals\",\n-        group: \"style\",\n-        desc: \"hex literals whose letter digits are not consistently upper- or lowercased\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"module_inception\",\n-        group: \"style\",\n-        desc: \"modules that have the same name as their parent module\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"module_name_repetitions\",\n-        group: \"pedantic\",\n-        desc: \"type names prefixed/postfixed with their containing module\\'s name\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"modulo_arithmetic\",\n-        group: \"restriction\",\n-        desc: \"any modulo arithmetic statement\",\n-        deprecation: None,\n-        module: \"modulo_arithmetic\",\n-    },\n-    Lint {\n-        name: \"modulo_one\",\n-        group: \"correctness\",\n-        desc: \"taking a number modulo 1, which always returns 0\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"multiple_crate_versions\",\n-        group: \"cargo\",\n-        desc: \"multiple versions of the same crate being used\",\n-        deprecation: None,\n-        module: \"multiple_crate_versions\",\n-    },\n-    Lint {\n-        name: \"multiple_inherent_impl\",\n-        group: \"restriction\",\n-        desc: \"Multiple inherent impl that could be grouped\",\n-        deprecation: None,\n-        module: \"inherent_impl\",\n-    },\n-    Lint {\n-        name: \"must_use_candidate\",\n-        group: \"pedantic\",\n-        desc: \"function or method that could take a `#[must_use]` attribute\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"must_use_unit\",\n-        group: \"style\",\n-        desc: \"`#[must_use]` attribute on a unit-returning function / method\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"mut_from_ref\",\n-        group: \"correctness\",\n-        desc: \"fns that create mutable refs from immutable ref args\",\n-        deprecation: None,\n-        module: \"ptr\",\n-    },\n-    Lint {\n-        name: \"mut_mut\",\n-        group: \"pedantic\",\n-        desc: \"usage of double-mut refs, e.g., `&mut &mut ...`\",\n-        deprecation: None,\n-        module: \"mut_mut\",\n-    },\n-    Lint {\n-        name: \"mut_mutex_lock\",\n-        group: \"style\",\n-        desc: \"`&mut Mutex::lock` does unnecessary locking\",\n-        deprecation: None,\n-        module: \"mut_mutex_lock\",\n-    },\n-    Lint {\n-        name: \"mut_range_bound\",\n-        group: \"complexity\",\n-        desc: \"for loop over a range where one of the bounds is a mutable variable\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"mutable_key_type\",\n-        group: \"correctness\",\n-        desc: \"Check for mutable `Map`/`Set` key type\",\n-        deprecation: None,\n-        module: \"mut_key\",\n-    },\n-    Lint {\n-        name: \"mutex_atomic\",\n-        group: \"perf\",\n-        desc: \"using a mutex where an atomic value could be used instead\",\n-        deprecation: None,\n-        module: \"mutex_atomic\",\n-    },\n-    Lint {\n-        name: \"mutex_integer\",\n-        group: \"nursery\",\n-        desc: \"using a mutex for an integer type\",\n-        deprecation: None,\n-        module: \"mutex_atomic\",\n-    },\n-    Lint {\n-        name: \"naive_bytecount\",\n-        group: \"perf\",\n-        desc: \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\",\n-        deprecation: None,\n-        module: \"bytecount\",\n-    },\n-    Lint {\n-        name: \"needless_arbitrary_self_type\",\n-        group: \"complexity\",\n-        desc: \"type of `self` parameter is already by default `Self`\",\n-        deprecation: None,\n-        module: \"needless_arbitrary_self_type\",\n-    },\n-    Lint {\n-        name: \"needless_bool\",\n-        group: \"complexity\",\n-        desc: \"if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`\",\n-        deprecation: None,\n-        module: \"needless_bool\",\n-    },\n-    Lint {\n-        name: \"needless_borrow\",\n-        group: \"nursery\",\n-        desc: \"taking a reference that is going to be automatically dereferenced\",\n-        deprecation: None,\n-        module: \"needless_borrow\",\n-    },\n-    Lint {\n-        name: \"needless_borrowed_reference\",\n-        group: \"complexity\",\n-        desc: \"taking a needless borrowed reference\",\n-        deprecation: None,\n-        module: \"needless_borrowed_ref\",\n-    },\n-    Lint {\n-        name: \"needless_collect\",\n-        group: \"perf\",\n-        desc: \"collecting an iterator when collect is not needed\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"needless_continue\",\n-        group: \"pedantic\",\n-        desc: \"`continue` statements that can be replaced by a rearrangement of code\",\n-        deprecation: None,\n-        module: \"needless_continue\",\n-    },\n-    Lint {\n-        name: \"needless_doctest_main\",\n-        group: \"style\",\n-        desc: \"presence of `fn main() {` in code examples\",\n-        deprecation: None,\n-        module: \"doc\",\n-    },\n-    Lint {\n-        name: \"needless_lifetimes\",\n-        group: \"complexity\",\n-        desc: \"using explicit lifetimes for references in function arguments when elision rules would allow omitting them\",\n-        deprecation: None,\n-        module: \"lifetimes\",\n-    },\n-    Lint {\n-        name: \"needless_pass_by_value\",\n-        group: \"pedantic\",\n-        desc: \"functions taking arguments by value, but not consuming them in its body\",\n-        deprecation: None,\n-        module: \"needless_pass_by_value\",\n-    },\n-    Lint {\n-        name: \"needless_range_loop\",\n-        group: \"style\",\n-        desc: \"for-looping over a range of indices where an iterator over items would do\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"needless_return\",\n-        group: \"style\",\n-        desc: \"using a return statement like `return expr;` where an expression would suffice\",\n-        deprecation: None,\n-        module: \"returns\",\n-    },\n-    Lint {\n-        name: \"needless_update\",\n-        group: \"complexity\",\n-        desc: \"using `Foo { ..base }` when there are no missing fields\",\n-        deprecation: None,\n-        module: \"needless_update\",\n-    },\n-    Lint {\n-        name: \"neg_cmp_op_on_partial_ord\",\n-        group: \"complexity\",\n-        desc: \"The use of negated comparison operators on partially ordered types may produce confusing code.\",\n-        deprecation: None,\n-        module: \"neg_cmp_op_on_partial_ord\",\n-    },\n-    Lint {\n-        name: \"neg_multiply\",\n-        group: \"style\",\n-        desc: \"multiplying integers with `-1`\",\n-        deprecation: None,\n-        module: \"neg_multiply\",\n-    },\n-    Lint {\n-        name: \"never_loop\",\n-        group: \"correctness\",\n-        desc: \"any loop that will always `break` or `return`\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"new_ret_no_self\",\n-        group: \"style\",\n-        desc: \"not returning type containing `Self` in a `new` method\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"new_without_default\",\n-        group: \"style\",\n-        desc: \"`fn new() -> Self` method without `Default` implementation\",\n-        deprecation: None,\n-        module: \"new_without_default\",\n-    },\n-    Lint {\n-        name: \"no_effect\",\n-        group: \"complexity\",\n-        desc: \"statements with no effect\",\n-        deprecation: None,\n-        module: \"no_effect\",\n-    },\n-    Lint {\n-        name: \"non_ascii_literal\",\n-        group: \"pedantic\",\n-        desc: \"using any literal non-ASCII chars in a string literal instead of using the `\\\\\\\\u` escape\",\n-        deprecation: None,\n-        module: \"unicode\",\n-    },\n-    Lint {\n-        name: \"nonminimal_bool\",\n-        group: \"complexity\",\n-        desc: \"boolean expressions that can be written more concisely\",\n-        deprecation: None,\n-        module: \"booleans\",\n-    },\n-    Lint {\n-        name: \"nonsensical_open_options\",\n-        group: \"correctness\",\n-        desc: \"nonsensical combination of options for opening a file\",\n-        deprecation: None,\n-        module: \"open_options\",\n-    },\n-    Lint {\n-        name: \"not_unsafe_ptr_arg_deref\",\n-        group: \"correctness\",\n-        desc: \"public functions dereferencing raw pointer arguments but not marked `unsafe`\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"ok_expect\",\n-        group: \"style\",\n-        desc: \"using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"op_ref\",\n-        group: \"style\",\n-        desc: \"taking a reference to satisfy the type constraints on `==`\",\n-        deprecation: None,\n-        module: \"eq_op\",\n-    },\n-    Lint {\n-        name: \"option_as_ref_deref\",\n-        group: \"complexity\",\n-        desc: \"using `as_ref().map(Deref::deref)`, which is more succinctly expressed as `as_deref()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"option_env_unwrap\",\n-        group: \"correctness\",\n-        desc: \"using `option_env!(...).unwrap()` to get environment variable\",\n-        deprecation: None,\n-        module: \"option_env_unwrap\",\n-    },\n-    Lint {\n-        name: \"option_if_let_else\",\n-        group: \"pedantic\",\n-        desc: \"reimplementation of Option::map_or\",\n-        deprecation: None,\n-        module: \"option_if_let_else\",\n-    },\n-    Lint {\n-        name: \"option_map_or_none\",\n-        group: \"style\",\n-        desc: \"using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"option_map_unit_fn\",\n-        group: \"complexity\",\n-        desc: \"using `option.map(f)`, where `f` is a function or closure that returns `()`\",\n-        deprecation: None,\n-        module: \"map_unit_fn\",\n-    },\n-    Lint {\n-        name: \"option_option\",\n-        group: \"pedantic\",\n-        desc: \"usage of `Option<Option<T>>`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"or_fun_call\",\n-        group: \"perf\",\n-        desc: \"using any `*or` method with a function call, which suggests `*or_else`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"out_of_bounds_indexing\",\n-        group: \"correctness\",\n-        desc: \"out of bounds constant indexing\",\n-        deprecation: None,\n-        module: \"indexing_slicing\",\n-    },\n-    Lint {\n-        name: \"overflow_check_conditional\",\n-        group: \"complexity\",\n-        desc: \"overflow checks inspired by C which are likely to panic\",\n-        deprecation: None,\n-        module: \"overflow_check_conditional\",\n-    },\n-    Lint {\n-        name: \"panic\",\n-        group: \"restriction\",\n-        desc: \"usage of the `panic!` macro\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"panic_in_result_fn\",\n-        group: \"restriction\",\n-        desc: \"functions of type `Result<..>` that contain `panic!()`, `todo!()` or `unreachable()` or `unimplemented()` \",\n-        deprecation: None,\n-        module: \"panic_in_result_fn\",\n-    },\n-    Lint {\n-        name: \"panicking_unwrap\",\n-        group: \"correctness\",\n-        desc: \"checks for calls of `unwrap[_err]()` that will always fail\",\n-        deprecation: None,\n-        module: \"unwrap\",\n-    },\n-    Lint {\n-        name: \"partialeq_ne_impl\",\n-        group: \"complexity\",\n-        desc: \"re-implementing `PartialEq::ne`\",\n-        deprecation: None,\n-        module: \"partialeq_ne_impl\",\n-    },\n-    Lint {\n-        name: \"path_buf_push_overwrite\",\n-        group: \"nursery\",\n-        desc: \"calling `push` with file system root on `PathBuf` can overwrite it\",\n-        deprecation: None,\n-        module: \"path_buf_push_overwrite\",\n-    },\n-    Lint {\n-        name: \"pattern_type_mismatch\",\n-        group: \"restriction\",\n-        desc: \"type of pattern does not match the expression type\",\n-        deprecation: None,\n-        module: \"pattern_type_mismatch\",\n-    },\n-    Lint {\n-        name: \"possible_missing_comma\",\n-        group: \"correctness\",\n-        desc: \"possible missing comma in array\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"precedence\",\n-        group: \"complexity\",\n-        desc: \"operations where precedence may be unclear\",\n-        deprecation: None,\n-        module: \"precedence\",\n-    },\n-    Lint {\n-        name: \"print_literal\",\n-        group: \"style\",\n-        desc: \"printing a literal with a format string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"print_stdout\",\n-        group: \"restriction\",\n-        desc: \"printing on stdout\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"print_with_newline\",\n-        group: \"style\",\n-        desc: \"using `print!()` with a format string that ends in a single newline\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"println_empty_string\",\n-        group: \"style\",\n-        desc: \"using `println!(\\\"\\\")` with an empty string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"ptr_arg\",\n-        group: \"style\",\n-        desc: \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\",\n-        deprecation: None,\n-        module: \"ptr\",\n-    },\n-    Lint {\n-        name: \"ptr_eq\",\n-        group: \"style\",\n-        desc: \"use `std::ptr::eq` when comparing raw pointers\",\n-        deprecation: None,\n-        module: \"ptr_eq\",\n-    },\n-    Lint {\n-        name: \"ptr_offset_with_cast\",\n-        group: \"complexity\",\n-        desc: \"unneeded pointer offset cast\",\n-        deprecation: None,\n-        module: \"ptr_offset_with_cast\",\n-    },\n-    Lint {\n-        name: \"pub_enum_variant_names\",\n-        group: \"pedantic\",\n-        desc: \"public enums where all variants share a prefix/postfix\",\n-        deprecation: None,\n-        module: \"enum_variants\",\n-    },\n-    Lint {\n-        name: \"question_mark\",\n-        group: \"style\",\n-        desc: \"checks for expressions that could be replaced by the question mark operator\",\n-        deprecation: None,\n-        module: \"question_mark\",\n-    },\n-    Lint {\n-        name: \"range_minus_one\",\n-        group: \"pedantic\",\n-        desc: \"`x..=(y-1)` reads better as `x..y`\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"range_plus_one\",\n-        group: \"pedantic\",\n-        desc: \"`x..(y+1)` reads better as `x..=y`\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"range_zip_with_len\",\n-        group: \"complexity\",\n-        desc: \"zipping iterator with a range when `enumerate()` would do\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"rc_buffer\",\n-        group: \"restriction\",\n-        desc: \"shared ownership of a buffer type\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"redundant_allocation\",\n-        group: \"perf\",\n-        desc: \"redundant allocation\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"redundant_clone\",\n-        group: \"perf\",\n-        desc: \"`clone()` of an owned value that is going to be dropped immediately\",\n-        deprecation: None,\n-        module: \"redundant_clone\",\n-    },\n-    Lint {\n-        name: \"redundant_closure\",\n-        group: \"style\",\n-        desc: \"redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\",\n-        deprecation: None,\n-        module: \"eta_reduction\",\n-    },\n-    Lint {\n-        name: \"redundant_closure_call\",\n-        group: \"complexity\",\n-        desc: \"throwaway closures called in the expression they are defined\",\n-        deprecation: None,\n-        module: \"redundant_closure_call\",\n-    },\n-    Lint {\n-        name: \"redundant_closure_for_method_calls\",\n-        group: \"pedantic\",\n-        desc: \"redundant closures for method calls\",\n-        deprecation: None,\n-        module: \"eta_reduction\",\n-    },\n-    Lint {\n-        name: \"redundant_field_names\",\n-        group: \"style\",\n-        desc: \"checks for fields in struct literals where shorthands could be used\",\n-        deprecation: None,\n-        module: \"redundant_field_names\",\n-    },\n-    Lint {\n-        name: \"redundant_pattern\",\n-        group: \"style\",\n-        desc: \"using `name @ _` in a pattern\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"redundant_pattern_matching\",\n-        group: \"style\",\n-        desc: \"use the proper utility function avoiding an `if let`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"redundant_pub_crate\",\n-        group: \"nursery\",\n-        desc: \"Using `pub(crate)` visibility on items that are not crate visible due to the visibility of the module that contains them.\",\n-        deprecation: None,\n-        module: \"redundant_pub_crate\",\n-    },\n-    Lint {\n-        name: \"redundant_static_lifetimes\",\n-        group: \"style\",\n-        desc: \"Using explicit `\\'static` lifetime for constants or statics when elision rules would allow omitting them.\",\n-        deprecation: None,\n-        module: \"redundant_static_lifetimes\",\n-    },\n-    Lint {\n-        name: \"ref_in_deref\",\n-        group: \"complexity\",\n-        desc: \"Use of reference in auto dereference expression.\",\n-        deprecation: None,\n-        module: \"reference\",\n-    },\n-    Lint {\n-        name: \"ref_option_ref\",\n-        group: \"pedantic\",\n-        desc: \"use `Option<&T>` instead of `&Option<&T>`\",\n-        deprecation: None,\n-        module: \"ref_option_ref\",\n-    },\n-    Lint {\n-        name: \"repeat_once\",\n-        group: \"complexity\",\n-        desc: \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \",\n-        deprecation: None,\n-        module: \"repeat_once\",\n-    },\n-    Lint {\n-        name: \"rest_pat_in_fully_bound_structs\",\n-        group: \"restriction\",\n-        desc: \"a match on a struct that binds all fields but still uses the wildcard pattern\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"result_map_or_into_option\",\n-        group: \"style\",\n-        desc: \"using `Result.map_or(None, Some)`, which is more succinctly expressed as `ok()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"result_map_unit_fn\",\n-        group: \"complexity\",\n-        desc: \"using `result.map(f)`, where `f` is a function or closure that returns `()`\",\n-        deprecation: None,\n-        module: \"map_unit_fn\",\n-    },\n-    Lint {\n-        name: \"result_unit_err\",\n-        group: \"style\",\n-        desc: \"public function returning `Result` with an `Err` type of `()`\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"reversed_empty_ranges\",\n-        group: \"correctness\",\n-        desc: \"reversing the limits of range expressions, resulting in empty ranges\",\n-        deprecation: None,\n-        module: \"ranges\",\n-    },\n-    Lint {\n-        name: \"same_functions_in_if_condition\",\n-        group: \"pedantic\",\n-        desc: \"consecutive `if`s with the same function call\",\n-        deprecation: None,\n-        module: \"copies\",\n-    },\n-    Lint {\n-        name: \"same_item_push\",\n-        group: \"style\",\n-        desc: \"the same item is pushed inside of a for loop\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"search_is_some\",\n-        group: \"complexity\",\n-        desc: \"using an iterator or string search followed by `is_some()`, which is more succinctly expressed as a call to `any()` or `contains()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"self_assignment\",\n-        group: \"correctness\",\n-        desc: \"explicit self-assignment\",\n-        deprecation: None,\n-        module: \"self_assignment\",\n-    },\n-    Lint {\n-        name: \"serde_api_misuse\",\n-        group: \"correctness\",\n-        desc: \"various things that will negatively affect your serde experience\",\n-        deprecation: None,\n-        module: \"serde_api\",\n-    },\n-    Lint {\n-        name: \"shadow_reuse\",\n-        group: \"restriction\",\n-        desc: \"rebinding a name to an expression that re-uses the original value, e.g., `let x = x + 1`\",\n-        deprecation: None,\n-        module: \"shadow\",\n-    },\n-    Lint {\n-        name: \"shadow_same\",\n-        group: \"restriction\",\n-        desc: \"rebinding a name to itself, e.g., `let mut x = &mut x`\",\n-        deprecation: None,\n-        module: \"shadow\",\n-    },\n-    Lint {\n-        name: \"shadow_unrelated\",\n-        group: \"pedantic\",\n-        desc: \"rebinding a name without even using the original value\",\n-        deprecation: None,\n-        module: \"shadow\",\n-    },\n-    Lint {\n-        name: \"short_circuit_statement\",\n-        group: \"complexity\",\n-        desc: \"using a short circuit boolean condition as a statement\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"should_implement_trait\",\n-        group: \"style\",\n-        desc: \"defining a method that should be implementing a std trait\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"similar_names\",\n-        group: \"pedantic\",\n-        desc: \"similarly named items and bindings\",\n-        deprecation: None,\n-        module: \"non_expressive_names\",\n-    },\n-    Lint {\n-        name: \"single_char_add_str\",\n-        group: \"style\",\n-        desc: \"`push_str()` or `insert_str()` used with a single-character string literal as parameter\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"single_char_pattern\",\n-        group: \"perf\",\n-        desc: \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"single_component_path_imports\",\n-        group: \"style\",\n-        desc: \"imports with single component path are redundant\",\n-        deprecation: None,\n-        module: \"single_component_path_imports\",\n-    },\n-    Lint {\n-        name: \"single_element_loop\",\n-        group: \"complexity\",\n-        desc: \"there is no reason to have a single element loop\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"single_match\",\n-        group: \"style\",\n-        desc: \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"single_match_else\",\n-        group: \"pedantic\",\n-        desc: \"a `match` statement with two arms where the second arm\\'s pattern is a placeholder instead of a specific match pattern\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"skip_while_next\",\n-        group: \"complexity\",\n-        desc: \"using `skip_while(p).next()`, which is more succinctly expressed as `.find(!p)`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"slow_vector_initialization\",\n-        group: \"perf\",\n-        desc: \"slow vector initialization\",\n-        deprecation: None,\n-        module: \"slow_vector_initialization\",\n-    },\n-    Lint {\n-        name: \"stable_sort_primitive\",\n-        group: \"perf\",\n-        desc: \"use of sort() when sort_unstable() is equivalent\",\n-        deprecation: None,\n-        module: \"stable_sort_primitive\",\n-    },\n-    Lint {\n-        name: \"string_add\",\n-        group: \"restriction\",\n-        desc: \"using `x + ..` where x is a `String` instead of `push_str()`\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_add_assign\",\n-        group: \"pedantic\",\n-        desc: \"using `x = x + ..` where x is a `String` instead of `push_str()`\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_extend_chars\",\n-        group: \"style\",\n-        desc: \"using `x.extend(s.chars())` where s is a `&str` or `String`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"string_from_utf8_as_bytes\",\n-        group: \"complexity\",\n-        desc: \"casting string slices to byte slices and back\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"string_lit_as_bytes\",\n-        group: \"nursery\",\n-        desc: \"calling `as_bytes` on a string literal instead of using a byte string literal\",\n-        deprecation: None,\n-        module: \"strings\",\n-    },\n-    Lint {\n-        name: \"struct_excessive_bools\",\n-        group: \"pedantic\",\n-        desc: \"using too many bools in a struct\",\n-        deprecation: None,\n-        module: \"excessive_bools\",\n-    },\n-    Lint {\n-        name: \"suboptimal_flops\",\n-        group: \"nursery\",\n-        desc: \"usage of sub-optimal floating point operations\",\n-        deprecation: None,\n-        module: \"floating_point_arithmetic\",\n-    },\n-    Lint {\n-        name: \"suspicious_arithmetic_impl\",\n-        group: \"correctness\",\n-        desc: \"suspicious use of operators in impl of arithmetic trait\",\n-        deprecation: None,\n-        module: \"suspicious_trait_impl\",\n-    },\n-    Lint {\n-        name: \"suspicious_assignment_formatting\",\n-        group: \"style\",\n-        desc: \"suspicious formatting of `*=`, `-=` or `!=`\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"suspicious_else_formatting\",\n-        group: \"style\",\n-        desc: \"suspicious formatting of `else`\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"suspicious_map\",\n-        group: \"complexity\",\n-        desc: \"suspicious usage of map\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"suspicious_op_assign_impl\",\n-        group: \"correctness\",\n-        desc: \"suspicious use of operators in impl of OpAssign trait\",\n-        deprecation: None,\n-        module: \"suspicious_trait_impl\",\n-    },\n-    Lint {\n-        name: \"suspicious_unary_op_formatting\",\n-        group: \"style\",\n-        desc: \"suspicious formatting of unary `-` or `!` on the RHS of a BinOp\",\n-        deprecation: None,\n-        module: \"formatting\",\n-    },\n-    Lint {\n-        name: \"tabs_in_doc_comments\",\n-        group: \"style\",\n-        desc: \"using tabs in doc comments is not recommended\",\n-        deprecation: None,\n-        module: \"tabs_in_doc_comments\",\n-    },\n-    Lint {\n-        name: \"temporary_assignment\",\n-        group: \"complexity\",\n-        desc: \"assignments to temporaries\",\n-        deprecation: None,\n-        module: \"temporary_assignment\",\n-    },\n-    Lint {\n-        name: \"to_digit_is_some\",\n-        group: \"style\",\n-        desc: \"`char.is_digit()` is clearer\",\n-        deprecation: None,\n-        module: \"to_digit_is_some\",\n-    },\n-    Lint {\n-        name: \"to_string_in_display\",\n-        group: \"correctness\",\n-        desc: \"`to_string` method used while implementing `Display` trait\",\n-        deprecation: None,\n-        module: \"to_string_in_display\",\n-    },\n-    Lint {\n-        name: \"todo\",\n-        group: \"restriction\",\n-        desc: \"`todo!` should not be present in production code\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"too_many_arguments\",\n-        group: \"complexity\",\n-        desc: \"functions with too many arguments\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"too_many_lines\",\n-        group: \"pedantic\",\n-        desc: \"functions with too many lines\",\n-        deprecation: None,\n-        module: \"functions\",\n-    },\n-    Lint {\n-        name: \"toplevel_ref_arg\",\n-        group: \"style\",\n-        desc: \"an entire binding declared as `ref`, in a function argument or a `let` statement\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"trait_duplication_in_bounds\",\n-        group: \"pedantic\",\n-        desc: \"Check if the same trait bounds are specified twice during a function declaration\",\n-        deprecation: None,\n-        module: \"trait_bounds\",\n-    },\n-    Lint {\n-        name: \"transmute_bytes_to_str\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a `&[u8]` to a `&str`\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_float_to_int\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a float to an integer\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_int_to_bool\",\n-        group: \"complexity\",\n-        desc: \"transmutes from an integer to a `bool`\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_int_to_char\",\n-        group: \"complexity\",\n-        desc: \"transmutes from an integer to a `char`\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_int_to_float\",\n-        group: \"complexity\",\n-        desc: \"transmutes from an integer to a float\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_ptr_to_ptr\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a pointer to a pointer / a reference to a reference\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmute_ptr_to_ref\",\n-        group: \"complexity\",\n-        desc: \"transmutes from a pointer to a reference type\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmutes_expressible_as_ptr_casts\",\n-        group: \"complexity\",\n-        desc: \"transmutes that could be a pointer cast\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"transmuting_null\",\n-        group: \"correctness\",\n-        desc: \"transmutes from a null pointer to a reference, which is undefined behavior\",\n-        deprecation: None,\n-        module: \"transmuting_null\",\n-    },\n-    Lint {\n-        name: \"trivial_regex\",\n-        group: \"style\",\n-        desc: \"trivial regular expressions\",\n-        deprecation: None,\n-        module: \"regex\",\n-    },\n-    Lint {\n-        name: \"trivially_copy_pass_by_ref\",\n-        group: \"pedantic\",\n-        desc: \"functions taking small copyable arguments by reference\",\n-        deprecation: None,\n-        module: \"pass_by_ref_or_value\",\n-    },\n-    Lint {\n-        name: \"try_err\",\n-        group: \"style\",\n-        desc: \"return errors explicitly rather than hiding them behind a `?`\",\n-        deprecation: None,\n-        module: \"try_err\",\n-    },\n-    Lint {\n-        name: \"type_complexity\",\n-        group: \"complexity\",\n-        desc: \"usage of very complex types that might be better factored into `type` definitions\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"type_repetition_in_bounds\",\n-        group: \"pedantic\",\n-        desc: \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\",\n-        deprecation: None,\n-        module: \"trait_bounds\",\n-    },\n-    Lint {\n-        name: \"undropped_manually_drops\",\n-        group: \"correctness\",\n-        desc: \"use of safe `std::mem::drop` function to drop a std::mem::ManuallyDrop, which will not drop the inner value\",\n-        deprecation: None,\n-        module: \"undropped_manually_drops\",\n-    },\n-    Lint {\n-        name: \"unicode_not_nfc\",\n-        group: \"pedantic\",\n-        desc: \"using a Unicode literal not in NFC normal form (see [Unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\",\n-        deprecation: None,\n-        module: \"unicode\",\n-    },\n-    Lint {\n-        name: \"unimplemented\",\n-        group: \"restriction\",\n-        desc: \"`unimplemented!` should not be present in production code\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"uninit_assumed_init\",\n-        group: \"correctness\",\n-        desc: \"`MaybeUninit::uninit().assume_init()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unit_arg\",\n-        group: \"complexity\",\n-        desc: \"passing unit to a function\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"unit_cmp\",\n-        group: \"correctness\",\n-        desc: \"comparing unit values\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"unit_return_expecting_ord\",\n-        group: \"correctness\",\n-        desc: \"fn arguments of type Fn(...) -> Ord returning the unit type ().\",\n-        deprecation: None,\n-        module: \"unit_return_expecting_ord\",\n-    },\n-    Lint {\n-        name: \"unknown_clippy_lints\",\n-        group: \"style\",\n-        desc: \"unknown_lints for scoped Clippy lints\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"unnecessary_cast\",\n-        group: \"complexity\",\n-        desc: \"cast to the same type, e.g., `x as i32` where `x: i32`\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"unnecessary_filter_map\",\n-        group: \"complexity\",\n-        desc: \"using `filter_map` when a more succinct alternative exists\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unnecessary_fold\",\n-        group: \"style\",\n-        desc: \"using `fold` when a more succinct alternative exists\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unnecessary_lazy_evaluations\",\n-        group: \"style\",\n-        desc: \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"unnecessary_mut_passed\",\n-        group: \"style\",\n-        desc: \"an argument passed as a mutable reference although the callee only demands an immutable reference\",\n-        deprecation: None,\n-        module: \"mut_reference\",\n-    },\n-    Lint {\n-        name: \"unnecessary_operation\",\n-        group: \"complexity\",\n-        desc: \"outer expressions with no effect\",\n-        deprecation: None,\n-        module: \"no_effect\",\n-    },\n-    Lint {\n-        name: \"unnecessary_sort_by\",\n-        group: \"complexity\",\n-        desc: \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\",\n-        deprecation: None,\n-        module: \"unnecessary_sort_by\",\n-    },\n-    Lint {\n-        name: \"unnecessary_unwrap\",\n-        group: \"complexity\",\n-        desc: \"checks for calls of `unwrap[_err]()` that cannot fail\",\n-        deprecation: None,\n-        module: \"unwrap\",\n-    },\n-    Lint {\n-        name: \"unnecessary_wraps\",\n-        group: \"complexity\",\n-        desc: \"functions that only return `Ok` or `Some`\",\n-        deprecation: None,\n-        module: \"unnecessary_wraps\",\n-    },\n-    Lint {\n-        name: \"unneeded_field_pattern\",\n-        group: \"restriction\",\n-        desc: \"struct fields bound to a wildcard instead of using `..`\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"unneeded_wildcard_pattern\",\n-        group: \"complexity\",\n-        desc: \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"unnested_or_patterns\",\n-        group: \"pedantic\",\n-        desc: \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\",\n-        deprecation: None,\n-        module: \"unnested_or_patterns\",\n-    },\n-    Lint {\n-        name: \"unreachable\",\n-        group: \"restriction\",\n-        desc: \"`unreachable!` should not be present in production code\",\n-        deprecation: None,\n-        module: \"panic_unimplemented\",\n-    },\n-    Lint {\n-        name: \"unreadable_literal\",\n-        group: \"pedantic\",\n-        desc: \"long integer literal without underscores\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"unsafe_derive_deserialize\",\n-        group: \"pedantic\",\n-        desc: \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\",\n-        deprecation: None,\n-        module: \"derive\",\n-    },\n-    Lint {\n-        name: \"unsafe_removed_from_name\",\n-        group: \"style\",\n-        desc: \"`unsafe` removed from API names on import\",\n-        deprecation: None,\n-        module: \"unsafe_removed_from_name\",\n-    },\n-    Lint {\n-        name: \"unseparated_literal_suffix\",\n-        group: \"pedantic\",\n-        desc: \"literals whose suffix is not separated by an underscore\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"unsound_collection_transmute\",\n-        group: \"correctness\",\n-        desc: \"transmute between collections of layout-incompatible types\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"unused_io_amount\",\n-        group: \"correctness\",\n-        desc: \"unused written/read amount\",\n-        deprecation: None,\n-        module: \"unused_io_amount\",\n-    },\n-    Lint {\n-        name: \"unused_self\",\n-        group: \"pedantic\",\n-        desc: \"methods that contain a `self` argument but don\\'t use it\",\n-        deprecation: None,\n-        module: \"unused_self\",\n-    },\n-    Lint {\n-        name: \"unused_unit\",\n-        group: \"style\",\n-        desc: \"needless unit expression\",\n-        deprecation: None,\n-        module: \"unused_unit\",\n-    },\n-    Lint {\n-        name: \"unusual_byte_groupings\",\n-        group: \"style\",\n-        desc: \"binary or hex literals that aren\\'t grouped by four\",\n-        deprecation: None,\n-        module: \"literal_representation\",\n-    },\n-    Lint {\n-        name: \"unwrap_in_result\",\n-        group: \"restriction\",\n-        desc: \"functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\",\n-        deprecation: None,\n-        module: \"unwrap_in_result\",\n-    },\n-    Lint {\n-        name: \"unwrap_used\",\n-        group: \"restriction\",\n-        desc: \"using `.unwrap()` on `Result` or `Option`, which should at least get a better message using `expect()`\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"use_debug\",\n-        group: \"restriction\",\n-        desc: \"use of `Debug`-based formatting\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"use_self\",\n-        group: \"nursery\",\n-        desc: \"unnecessary structure name repetition whereas `Self` is applicable\",\n-        deprecation: None,\n-        module: \"use_self\",\n-    },\n-    Lint {\n-        name: \"used_underscore_binding\",\n-        group: \"pedantic\",\n-        desc: \"using a binding which is prefixed with an underscore\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"useless_asref\",\n-        group: \"complexity\",\n-        desc: \"using `as_ref` where the types before and after the call are the same\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"useless_attribute\",\n-        group: \"correctness\",\n-        desc: \"use of lint attributes on `extern crate` items\",\n-        deprecation: None,\n-        module: \"attrs\",\n-    },\n-    Lint {\n-        name: \"useless_conversion\",\n-        group: \"complexity\",\n-        desc: \"calls to `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` which perform useless conversions to the same type\",\n-        deprecation: None,\n-        module: \"useless_conversion\",\n-    },\n-    Lint {\n-        name: \"useless_format\",\n-        group: \"complexity\",\n-        desc: \"useless use of `format!`\",\n-        deprecation: None,\n-        module: \"format\",\n-    },\n-    Lint {\n-        name: \"useless_let_if_seq\",\n-        group: \"nursery\",\n-        desc: \"unidiomatic `let mut` declaration followed by initialization in `if`\",\n-        deprecation: None,\n-        module: \"let_if_seq\",\n-    },\n-    Lint {\n-        name: \"useless_transmute\",\n-        group: \"nursery\",\n-        desc: \"transmutes that have the same to and from types or could be a cast/coercion\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"useless_vec\",\n-        group: \"perf\",\n-        desc: \"useless `vec!`\",\n-        deprecation: None,\n-        module: \"vec\",\n-    },\n-    Lint {\n-        name: \"vec_box\",\n-        group: \"complexity\",\n-        desc: \"usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap\",\n-        deprecation: None,\n-        module: \"types\",\n-    },\n-    Lint {\n-        name: \"vec_resize_to_zero\",\n-        group: \"correctness\",\n-        desc: \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\",\n-        deprecation: None,\n-        module: \"vec_resize_to_zero\",\n-    },\n-    Lint {\n-        name: \"verbose_bit_mask\",\n-        group: \"pedantic\",\n-        desc: \"expressions where a bit mask is less readable than the corresponding method call\",\n-        deprecation: None,\n-        module: \"bit_mask\",\n-    },\n-    Lint {\n-        name: \"verbose_file_reads\",\n-        group: \"restriction\",\n-        desc: \"use of `File::read_to_end` or `File::read_to_string`\",\n-        deprecation: None,\n-        module: \"verbose_file_reads\",\n-    },\n-    Lint {\n-        name: \"vtable_address_comparisons\",\n-        group: \"correctness\",\n-        desc: \"comparison with an address of a trait vtable\",\n-        deprecation: None,\n-        module: \"unnamed_address\",\n-    },\n-    Lint {\n-        name: \"while_immutable_condition\",\n-        group: \"correctness\",\n-        desc: \"variables used within while expression are not mutated in the body\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"while_let_loop\",\n-        group: \"complexity\",\n-        desc: \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"while_let_on_iterator\",\n-        group: \"style\",\n-        desc: \"using a while-let loop instead of a for loop on an iterator\",\n-        deprecation: None,\n-        module: \"loops\",\n-    },\n-    Lint {\n-        name: \"wildcard_dependencies\",\n-        group: \"cargo\",\n-        desc: \"wildcard dependencies being used\",\n-        deprecation: None,\n-        module: \"wildcard_dependencies\",\n-    },\n-    Lint {\n-        name: \"wildcard_enum_match_arm\",\n-        group: \"restriction\",\n-        desc: \"a wildcard enum match arm using `_`\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"wildcard_imports\",\n-        group: \"pedantic\",\n-        desc: \"lint `use _::*` statements\",\n-        deprecation: None,\n-        module: \"wildcard_imports\",\n-    },\n-    Lint {\n-        name: \"wildcard_in_or_patterns\",\n-        group: \"complexity\",\n-        desc: \"a wildcard pattern used with others patterns in same match arm\",\n-        deprecation: None,\n-        module: \"matches\",\n-    },\n-    Lint {\n-        name: \"write_literal\",\n-        group: \"style\",\n-        desc: \"writing a literal with a format string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"write_with_newline\",\n-        group: \"style\",\n-        desc: \"using `write!()` with a format string that ends in a single newline\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"writeln_empty_string\",\n-        group: \"style\",\n-        desc: \"using `writeln!(buf, \\\"\\\")` with an empty string\",\n-        deprecation: None,\n-        module: \"write\",\n-    },\n-    Lint {\n-        name: \"wrong_pub_self_convention\",\n-        group: \"restriction\",\n-        desc: \"defining a public method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"wrong_self_convention\",\n-        group: \"style\",\n-        desc: \"defining a method named with an established prefix (like \\\"into_\\\") that takes `self` with the wrong convention\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-    Lint {\n-        name: \"wrong_transmute\",\n-        group: \"correctness\",\n-        desc: \"transmutes that are confusing at best, undefined behaviour at worst and always useless\",\n-        deprecation: None,\n-        module: \"transmute\",\n-    },\n-    Lint {\n-        name: \"zero_divided_by_zero\",\n-        group: \"complexity\",\n-        desc: \"usage of `0.0 / 0.0` to obtain NaN instead of `f32::NAN` or `f64::NAN`\",\n-        deprecation: None,\n-        module: \"zero_div_zero\",\n-    },\n-    Lint {\n-        name: \"zero_prefixed_literal\",\n-        group: \"complexity\",\n-        desc: \"integer literals starting with `0`\",\n-        deprecation: None,\n-        module: \"misc_early\",\n-    },\n-    Lint {\n-        name: \"zero_ptr\",\n-        group: \"style\",\n-        desc: \"using `0 as *{const, mut} T`\",\n-        deprecation: None,\n-        module: \"misc\",\n-    },\n-    Lint {\n-        name: \"zst_offset\",\n-        group: \"correctness\",\n-        desc: \"Check for offset calculations on raw pointers to zero-sized types\",\n-        deprecation: None,\n-        module: \"methods\",\n-    },\n-]\n-// end lint list, do not remove this comment, it\u2019s used in `update_lints`\n-});"}]}