{"sha": "1b58ab73fdd97bde191e7d639c36849aad2b941c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNThhYjczZmRkOTdiZGUxOTFlN2Q2MzljMzY4NDlhYWQyYjk0MWM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-06-25T17:25:46Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-02T13:49:04Z"}, "message": "rustc_passes/reachable: avoid using TypeckTables::empty for ReachableContext.", "tree": {"sha": "bdb7012f22e5d7815ed419dc1f9149421d506c92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdb7012f22e5d7815ed419dc1f9149421d506c92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b58ab73fdd97bde191e7d639c36849aad2b941c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b58ab73fdd97bde191e7d639c36849aad2b941c", "html_url": "https://github.com/rust-lang/rust/commit/1b58ab73fdd97bde191e7d639c36849aad2b941c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b58ab73fdd97bde191e7d639c36849aad2b941c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c49b664e818c7b1860fcded9890350d5df171299", "url": "https://api.github.com/repos/rust-lang/rust/commits/c49b664e818c7b1860fcded9890350d5df171299", "html_url": "https://github.com/rust-lang/rust/commit/c49b664e818c7b1860fcded9890350d5df171299"}], "stats": {"total": 28, "additions": 18, "deletions": 10}, "files": [{"sha": "5109d8debeefd26e5c38e14829687298eb5ee751", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b58ab73fdd97bde191e7d639c36849aad2b941c/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b58ab73fdd97bde191e7d639c36849aad2b941c/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=1b58ab73fdd97bde191e7d639c36849aad2b941c", "patch": "@@ -8,6 +8,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "50fcefa3569ac422884c783471eed7f4878472e3", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1b58ab73fdd97bde191e7d639c36849aad2b941c/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b58ab73fdd97bde191e7d639c36849aad2b941c/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=1b58ab73fdd97bde191e7d639c36849aad2b941c", "patch": "@@ -60,10 +60,10 @@ fn method_might_be_inlined(\n }\n \n // Information needed while computing reachability.\n-struct ReachableContext<'a, 'tcx> {\n+struct ReachableContext<'tcx> {\n     // The type context.\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: HirIdSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -73,26 +73,25 @@ struct ReachableContext<'a, 'tcx> {\n     any_library: bool,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         let res = match expr.kind {\n-            hir::ExprKind::Path(ref qpath) => Some(self.tables.qpath_res(qpath, expr.hir_id)),\n+            hir::ExprKind::Path(ref qpath) => Some(self.tables().qpath_res(qpath, expr.hir_id)),\n             hir::ExprKind::MethodCall(..) => self\n-                .tables\n+                .tables()\n                 .type_dependent_def(expr.hir_id)\n                 .map(|(kind, def_id)| Res::Def(kind, def_id)),\n             _ => None,\n@@ -133,7 +132,15 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n+impl<'tcx> ReachableContext<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`ReachableContext::tables` called outside of body\")\n+    }\n+\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n@@ -381,7 +388,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n         });\n     let mut reachable_context = ReachableContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(None),\n+        maybe_typeck_tables: None,\n         reachable_symbols: Default::default(),\n         worklist: Vec::new(),\n         any_library,"}]}