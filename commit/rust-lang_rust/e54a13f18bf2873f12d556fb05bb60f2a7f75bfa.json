{"sha": "e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "node_id": "C_kwDOAAsO6NoAKGU1NGExM2YxOGJmMjg3M2YxMmQ1NTZmYjA1YmI2MGYyYTdmNzViZmE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-10-23T14:22:55Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-10-23T14:22:55Z"}, "message": "Merge commit '266e96785ab71834b917bf474f130a6d8fdecd4b' into sync_cg_clif-2022-10-23", "tree": {"sha": "aa307e1924204c6108c4a5fdf139ec643bf9ab47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa307e1924204c6108c4a5fdf139ec643bf9ab47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "html_url": "https://github.com/rust-lang/rust/commit/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "html_url": "https://github.com/rust-lang/rust/commit/9be2f35a4c1ed1b04aa4a6945b64763f599259ff"}, {"sha": "266e96785ab71834b917bf474f130a6d8fdecd4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/266e96785ab71834b917bf474f130a6d8fdecd4b", "html_url": "https://github.com/rust-lang/rust/commit/266e96785ab71834b917bf474f130a6d8fdecd4b"}], "stats": {"total": 1683, "additions": 1045, "deletions": 638}, "files": [{"sha": "5061010c86cd3451d4b8e7858b05cecf7efc8631", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -29,7 +29,11 @@ jobs:\n       matrix:\n         include:\n           - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n           - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n           # cross-compile from Linux to Windows using mingw\n           - os: ubuntu-latest\n             env:\n@@ -112,7 +116,7 @@ jobs:\n       if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n       uses: actions/upload-artifact@v2\n       with:\n-        name: cg_clif-${{ runner.os }}\n+        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar.xz\n \n     - name: Upload prebuilt cg_clif (cross compile)\n@@ -122,56 +126,89 @@ jobs:\n         name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n         path: cg_clif.tar.xz\n \n-  build_windows:\n-    runs-on: windows-latest\n+  windows:\n+    runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        include:\n+          # Native Windows build with MSVC\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          # cross-compile from Windows to Windows MinGW\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n+\n     steps:\n     - uses: actions/checkout@v3\n \n-    #- name: Cache cargo installed crates\n-    #  uses: actions/cache@v2\n-    #  with:\n-    #    path: ~/.cargo/bin\n-    #    key: ${{ runner.os }}-cargo-installed-crates\n-\n-    #- name: Cache cargo registry and index\n-    #  uses: actions/cache@v2\n-    #  with:\n-    #    path: |\n-    #        ~/.cargo/registry\n-    #        ~/.cargo/git\n-    #    key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n-    #- name: Cache cargo target dir\n-    #  uses: actions/cache@v2\n-    #  with:\n-    #    path: target\n-    #    key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n \n     - name: Prepare dependencies\n       run: |\n         git config --global user.email \"user@example.com\"\n         git config --global user.name \"User\"\n         git config --global core.autocrlf false\n-        rustup set default-host x86_64-pc-windows-gnu\n         rustc y.rs -o y.exe -g\n         ./y.exe prepare\n \n+    - name: Build without unstable features\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      # This is the config rust-lang/rust uses for builds\n+      run: ./y.rs build --no-unstable-features\n+\n     - name: Build\n-      #name: Test\n+      run: ./y.rs build --sysroot none\n+\n+    - name: Test\n       run: |\n         # Enable backtraces for easier debugging\n-        #$Env:RUST_BACKTRACE=1\n+        $Env:RUST_BACKTRACE=1\n \n         # Reduce amount of benchmark runs as they are slow\n-        #$Env:COMPILE_RUNS=2\n-        #$Env:RUN_RUNS=2\n+        $Env:COMPILE_RUNS=2\n+        $Env:RUN_RUNS=2\n \n         # Enable extra checks\n-        #$Env:CG_CLIF_ENABLE_VERIFIER=1\n-\n-        ./y.exe build\n+        $Env:CG_CLIF_ENABLE_VERIFIER=1\n+        \n+        # WIP Disable some tests\n+        \n+        # This fails due to some weird argument handling by hyperfine, not an actual regression\n+        # more of a build system issue\n+        (Get-Content config.txt) -replace '(bench.simple-raytracer)', '# $1' |  Out-File config.txt\n+        \n+        # This fails with a different output than expected \n+        (Get-Content config.txt) -replace '(test.regex-shootout-regex-dna)', '# $1' |  Out-File config.txt\n+\n+        ./y.exe test\n \n     - name: Package prebuilt cg_clif\n       # don't use compression as xzip isn't supported by tar on windows and bzip2 hangs\n@@ -180,5 +217,5 @@ jobs:\n     - name: Upload prebuilt cg_clif\n       uses: actions/upload-artifact@v2\n       with:\n-        name: cg_clif-${{ runner.os }}\n+        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar"}, {"sha": "fae09592c6ac0dc91be2641093896c0adc9559d8", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -15,8 +15,4 @@ perf.data.old\n /build_sysroot/compiler-builtins\n /build_sysroot/rustc_version\n /rust\n-/rand\n-/regex\n-/simple-raytracer\n-/portable-simd\n-/abi-checker\n+/download"}, {"sha": "13301bf20a5ed7d57051c9b45fa4165a98e8b7b5", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -7,7 +7,7 @@\n     \"rust-analyzer.cargo.features\": [\"unstable-features\"],\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n-        //\"./build_sysroot/sysroot_src/src/libstd/Cargo.toml\",\n+        //\"./build_sysroot/sysroot_src/library/std/Cargo.toml\",\n         {\n             \"roots\": [\n                 \"./example/mini_core.rs\",\n@@ -36,10 +36,10 @@\n             ]\n         },\n         {\n-            \"roots\": [\"./scripts/filter_profile.rs\"],\n+            \"roots\": [\"./example/std_example.rs\"],\n             \"crates\": [\n                 {\n-                    \"root_module\": \"./scripts/filter_profile.rs\",\n+                    \"root_module\": \"./example/std_example.rs\",\n                     \"edition\": \"2018\",\n                     \"deps\": [{ \"crate\": 1, \"name\": \"std\" }],\n                     \"cfg\": [],"}, {"sha": "3fa9d56cd01a381549991ed9fca4940e2b925d08", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -24,6 +24,12 @@ name = \"ar\"\n version = \"0.8.0\"\n source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8da52d66c7071e2e3fa2a1e5c6d088fec47b593032b254f5e980de8ea54454d6\"\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -36,6 +42,12 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"bumpalo\"\n+version = \"3.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c1ad822118d20d2c234f427000d5acc36eabe1e29a348c89b63dd60b13f28e5d\"\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.4.3\"\n@@ -50,19 +62,21 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93945adbccc8d731503d3038814a51e8317497c9e205411820348132fa01a358\"\n+checksum = \"44409ccf2d0f663920cab563d2b79fcd6b2e9a2bcc6e929fef76c8f82ad6c17a\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2b482acc9d0d0d1ad3288a90a8150ee648be3dce8dc8c8669ff026f72debdc31\"\n+checksum = \"98de2018ad96eb97f621f7d6b900a0cc661aec8d02ea4a50e56ecb48e5a2fcaf\"\n dependencies = [\n+ \"arrayvec\",\n+ \"bumpalo\",\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n@@ -77,30 +91,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f9ec188d71e663192ef9048f204e410a7283b609942efc9fcc77da6d496edbb8\"\n+checksum = \"5287ce36e6c4758fbaf298bd1a8697ad97a4f2375a3d1b61142ea538db4877e5\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ad794b1b1c2c7bd9f7b76cfe0f084eaf7753e55d56191c3f7d89e8fa4978b99\"\n+checksum = \"2855c24219e2f08827f3f4ffb2da92e134ae8d8ecc185b11ec8f9878cf5f588e\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"342da0d5056f4119d3c311c4aab2460ceb6ee6e127bb395b76dd2279a09ea7a5\"\n+checksum = \"0b65673279d75d34bf11af9660ae2dbd1c22e6d28f163f5c72f4e1dc56d56103\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dfff792f775b07d4d9cfe9f1c767ce755c6cbadda1bbd6db18a1c75ff9f7376a\"\n+checksum = \"3ed2b3d7a4751163f6c4a349205ab1b7d9c00eecf19dcea48592ef1f7688eefc\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -110,15 +124,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d51089478849f2ac8ef60a8a2d5346c8d4abfec0e45ac5b24530ef9f9499e1e\"\n+checksum = \"3be64cecea9d90105fc6a2ba2d003e98c867c1d6c4c86cc878f97ad9fb916293\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"095936e41720f86004b4c57ce88e6a13af28646bb3a6fb4afbebd5ae90c50029\"\n+checksum = \"f98ed42a70a0c9c388e34ec9477f57fc7300f541b1e5136a0e2ea02b1fac6015\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -134,19 +148,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"704a1aea4723d97eafe0fb7af110f6f6868b1ac95f5380bbc9adb2a3b8cf97e8\"\n+checksum = \"d658ac7f156708bfccb647216cc8b9387469f50d352ba4ad80150541e4ae2d49\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"885debe62f2078638d6585f54c9f05f5c2008f22ce5a2a9100ada785fc065dbd\"\n+checksum = \"c4a03a6ac1b063e416ca4b93f6247978c991475e8271465340caa6f92f3c16a4\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -155,9 +169,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aac1310cf1081ae8eca916c92cd163b977c77cab6e831fa812273c26ff921816\"\n+checksum = \"eef0b4119b645b870a43a036d76c0ada3a076b1f82e8b8487659304c8b09049b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -232,9 +246,9 @@ checksum = \"505e71a4706fa491e9b1b55f51b95d4037d0821ee40131190475f692b35b009b\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.7\"\n+version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"351a32417a12d5f7e82c368a66781e307834dae04c6ce0cd4456d52989229883\"\n+checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n dependencies = [\n  \"cfg-if\",\n  \"winapi\","}, {"sha": "09cf5b4a1edd8482ef98d33c5aeb295600947b6a", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -8,19 +8,19 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.87.0\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.87.0\"\n-cranelift-module = \"0.87.0\"\n-cranelift-native = \"0.87.0\"\n-cranelift-jit = { version = \"0.87.0\", optional = true }\n-cranelift-object = \"0.87.0\"\n+cranelift-codegen = { version = \"0.88.1\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.88.1\"\n+cranelift-module = \"0.88.1\"\n+cranelift-native = \"0.88.1\"\n+cranelift-jit = { version = \"0.88.1\", optional = true }\n+cranelift-object = \"0.88.1\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\"\n-libloading = { version = \"0.6.0\", optional = true }\n+libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\"\n smallvec = \"1.8.1\"\n "}, {"sha": "f6a9cb67290c7d88d591a72b2abfafaa2df67c28", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -54,11 +54,21 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.79\"\n+version = \"0.1.82\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f873ce2bd3550b0b565f878b3d04ea8253f4259dc3d20223af2e1ba86f5ecca\"\n+checksum = \"18cd7635fea7bb481ea543b392789844c1ad581299da70184c7175ce3af76603\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -123,9 +133,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.5\"\n+version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"897cd85af6387be149f55acf168e41be176a02de7872403aaab184afc2f327e6\"\n+checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -135,9 +145,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.132\"\n+version = \"0.2.135\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n+checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -182,7 +192,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -193,7 +203,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -245,7 +255,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"addr2line\",\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"dlmalloc\",\n@@ -267,7 +277,7 @@ dependencies = [\n name = \"std_detect\"\n version = \"0.1.5\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"libc\",\n  \"rustc-std-workspace-alloc\",\n@@ -289,7 +299,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"core\",\n  \"getopts\",\n  \"libc\",\n@@ -301,9 +311,9 @@ dependencies = [\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.9\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n+checksum = \"c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -315,7 +325,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\","}, {"sha": "fae5b27163680badc511023892f92fe462ddfbaf", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_cafe.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -0,0 +1,52 @@\n+use std::env;\n+use std::path::Path;\n+\n+use super::build_sysroot;\n+use super::config;\n+use super::prepare;\n+use super::utils::{cargo_command, spawn_and_wait};\n+use super::SysrootKind;\n+\n+pub(crate) fn run(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_dylib: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    if !config::get_bool(\"testsuite.abi-cafe\") {\n+        eprintln!(\"[SKIP] abi-cafe\");\n+        return;\n+    }\n+\n+    if host_triple != target_triple {\n+        eprintln!(\"[SKIP] abi-cafe (cross-compilation not supported)\");\n+        return;\n+    }\n+\n+    eprintln!(\"Building sysroot for abi-cafe\");\n+    build_sysroot::build_sysroot(\n+        channel,\n+        sysroot_kind,\n+        target_dir,\n+        cg_clif_dylib,\n+        host_triple,\n+        target_triple,\n+    );\n+\n+    eprintln!(\"Running abi-cafe\");\n+    let abi_cafe_path = prepare::ABI_CAFE.source_dir();\n+    env::set_current_dir(abi_cafe_path.clone()).unwrap();\n+\n+    let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n+\n+    let mut cmd = cargo_command(\"cargo\", \"run\", Some(target_triple), &abi_cafe_path);\n+    cmd.arg(\"--\");\n+    cmd.arg(\"--pairs\");\n+    cmd.args(pairs);\n+    cmd.arg(\"--add-rustc-codegen-backend\");\n+    cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib.display()));\n+\n+    spawn_and_wait(cmd);\n+}"}, {"sha": "67dbd0a38a4fb4d44d0579e907bbc1a4c6bc9de0", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_checker.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -1,60 +0,0 @@\n-use super::build_sysroot;\n-use super::config;\n-use super::utils::spawn_and_wait;\n-use build_system::SysrootKind;\n-use std::env;\n-use std::path::Path;\n-use std::process::Command;\n-\n-pub(crate) fn run(\n-    channel: &str,\n-    sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n-    cg_clif_build_dir: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n-) {\n-    if !config::get_bool(\"testsuite.abi-checker\") {\n-        eprintln!(\"[SKIP] abi-checker\");\n-        return;\n-    }\n-\n-    if host_triple != target_triple {\n-        eprintln!(\"[SKIP] abi-checker (cross-compilation not supported)\");\n-        return;\n-    }\n-\n-    eprintln!(\"Building sysroot for abi-checker\");\n-    build_sysroot::build_sysroot(\n-        channel,\n-        sysroot_kind,\n-        target_dir,\n-        cg_clif_build_dir,\n-        host_triple,\n-        target_triple,\n-    );\n-\n-    eprintln!(\"Running abi-checker\");\n-    let mut abi_checker_path = env::current_dir().unwrap();\n-    abi_checker_path.push(\"abi-checker\");\n-    env::set_current_dir(abi_checker_path.clone()).unwrap();\n-\n-    let build_dir = abi_checker_path.parent().unwrap().join(\"build\");\n-    let cg_clif_dylib_path = build_dir.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n-        env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n-    );\n-\n-    let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n-\n-    let mut cmd = Command::new(\"cargo\");\n-    cmd.arg(\"run\");\n-    cmd.arg(\"--target\");\n-    cmd.arg(target_triple);\n-    cmd.arg(\"--\");\n-    cmd.arg(\"--pairs\");\n-    cmd.args(pairs);\n-    cmd.arg(\"--add-rustc-codegen-backend\");\n-    cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib_path.display()));\n-\n-    spawn_and_wait(cmd);\n-}"}, {"sha": "cda468bcfa2dfc2e0bfe494bd5a1a9414a97eed6", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -1,16 +1,16 @@\n use std::env;\n-use std::path::{Path, PathBuf};\n-use std::process::Command;\n+use std::path::PathBuf;\n \n-use super::utils::is_ci;\n+use super::rustc_info::get_file_name;\n+use super::utils::{cargo_command, is_ci};\n \n pub(crate) fn build_backend(\n     channel: &str,\n     host_triple: &str,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let mut cmd = Command::new(\"cargo\");\n-    cmd.arg(\"build\").arg(\"--target\").arg(host_triple);\n+    let source_dir = std::env::current_dir().unwrap();\n+    let mut cmd = cargo_command(\"cargo\", \"build\", Some(host_triple), &source_dir);\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -41,5 +41,9 @@ pub(crate) fn build_backend(\n     eprintln!(\"[BUILD] rustc_codegen_cranelift\");\n     super::utils::spawn_and_wait(cmd);\n \n-    Path::new(\"target\").join(host_triple).join(channel)\n+    source_dir\n+        .join(\"target\")\n+        .join(host_triple)\n+        .join(channel)\n+        .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"))\n }"}, {"sha": "856aecc49fd1c05f476c91232c9bb0b429c4c907", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -3,14 +3,14 @@ use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n-use super::utils::{spawn_and_wait, try_hard_link};\n+use super::utils::{cargo_command, spawn_and_wait, try_hard_link};\n use super::SysrootKind;\n \n pub(crate) fn build_sysroot(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     target_dir: &Path,\n-    cg_clif_build_dir: &Path,\n+    cg_clif_dylib_src: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n@@ -23,7 +23,6 @@ pub(crate) fn build_sysroot(\n     fs::create_dir_all(target_dir.join(\"lib\")).unwrap();\n \n     // Copy the backend\n-    let cg_clif_dylib = get_file_name(\"rustc_codegen_cranelift\", \"dylib\");\n     let cg_clif_dylib_path = target_dir\n         .join(if cfg!(windows) {\n             // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n@@ -32,8 +31,8 @@ pub(crate) fn build_sysroot(\n         } else {\n             \"lib\"\n         })\n-        .join(&cg_clif_dylib);\n-    try_hard_link(cg_clif_build_dir.join(cg_clif_dylib), &cg_clif_dylib_path);\n+        .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n+    try_hard_link(cg_clif_dylib_src, &cg_clif_dylib_path);\n \n     // Build and copy rustc and cargo wrappers\n     for wrapper in [\"rustc-clif\", \"cargo-clif\"] {\n@@ -186,10 +185,10 @@ fn build_clif_sysroot_for_triple(\n     }\n \n     // Build sysroot\n-    let mut build_cmd = Command::new(\"cargo\");\n-    build_cmd.arg(\"build\").arg(\"--target\").arg(triple).current_dir(\"build_sysroot\");\n+    let mut build_cmd = cargo_command(\"cargo\", \"build\", Some(triple), Path::new(\"build_sysroot\"));\n     let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n+    rustflags.push_str(&format!(\" --sysroot={}\", target_dir.to_str().unwrap()));\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n         rustflags.push_str(\" -Zmir-opt-level=3\");"}, {"sha": "c31784e1097dc25f1b43a8a4dc1f59a4666c192f", "filename": "compiler/rustc_codegen_cranelift/build_system/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -1,4 +1,5 @@\n-use std::{fs, process};\n+use std::fs;\n+use std::process;\n \n fn load_config_file() -> Vec<(String, Option<String>)> {\n     fs::read_to_string(\"config.txt\")"}, {"sha": "b25270d832ceb4fd483cfdbad2b6b712a4ee1a50", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -4,7 +4,7 @@ use std::process;\n \n use self::utils::is_ci;\n \n-mod abi_checker;\n+mod abi_cafe;\n mod build_backend;\n mod build_sysroot;\n mod config;\n@@ -122,32 +122,23 @@ pub fn main() {\n         host_triple.clone()\n     };\n \n-    if target_triple.ends_with(\"-msvc\") {\n-        eprintln!(\"The MSVC toolchain is not yet supported by rustc_codegen_cranelift.\");\n-        eprintln!(\"Switch to the MinGW toolchain for Windows support.\");\n-        eprintln!(\"Hint: You can use `rustup set default-host x86_64-pc-windows-gnu` to\");\n-        eprintln!(\"set the global default target to MinGW\");\n-        process::exit(1);\n-    }\n-\n-    let cg_clif_build_dir =\n-        build_backend::build_backend(channel, &host_triple, use_unstable_features);\n+    let cg_clif_dylib = build_backend::build_backend(channel, &host_triple, use_unstable_features);\n     match command {\n         Command::Test => {\n             tests::run_tests(\n                 channel,\n                 sysroot_kind,\n                 &target_dir,\n-                &cg_clif_build_dir,\n+                &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );\n \n-            abi_checker::run(\n+            abi_cafe::run(\n                 channel,\n                 sysroot_kind,\n                 &target_dir,\n-                &cg_clif_build_dir,\n+                &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );\n@@ -157,7 +148,7 @@ pub fn main() {\n                 channel,\n                 sysroot_kind,\n                 &target_dir,\n-                &cg_clif_build_dir,\n+                &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );"}, {"sha": "f9ab8ae70412b0ec2d909767557777f268755cc3", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 123, "deletions": 67, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -1,64 +1,67 @@\n use std::env;\n use std::ffi::OsStr;\n-use std::ffi::OsString;\n use std::fs;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use super::utils::{copy_dir_recursively, spawn_and_wait};\n+use super::utils::{cargo_command, copy_dir_recursively, spawn_and_wait};\n+\n+pub(crate) const ABI_CAFE: GitRepo = GitRepo::github(\n+    \"Gankra\",\n+    \"abi-cafe\",\n+    \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\",\n+    \"abi-cafe\",\n+);\n+\n+pub(crate) const RAND: GitRepo =\n+    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n+\n+pub(crate) const REGEX: GitRepo =\n+    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n+\n+pub(crate) const PORTABLE_SIMD: GitRepo = GitRepo::github(\n+    \"rust-lang\",\n+    \"portable-simd\",\n+    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n+    \"portable-simd\",\n+);\n+\n+pub(crate) const SIMPLE_RAYTRACER: GitRepo = GitRepo::github(\n+    \"ebobby\",\n+    \"simple-raytracer\",\n+    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n+    \"<none>\",\n+);\n \n pub(crate) fn prepare() {\n+    if Path::new(\"download\").exists() {\n+        std::fs::remove_dir_all(Path::new(\"download\")).unwrap();\n+    }\n+    std::fs::create_dir_all(Path::new(\"download\")).unwrap();\n+\n     prepare_sysroot();\n \n+    // FIXME maybe install this only locally?\n     eprintln!(\"[INSTALL] hyperfine\");\n     Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n \n-    clone_repo_shallow_github(\n-        \"abi-checker\",\n-        \"Gankra\",\n-        \"abi-checker\",\n-        \"a2232d45f202846f5c02203c9f27355360f9a2ff\",\n-    );\n-    apply_patches(\"abi-checker\", Path::new(\"abi-checker\"));\n-\n-    clone_repo_shallow_github(\n-        \"rand\",\n-        \"rust-random\",\n-        \"rand\",\n-        \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\",\n-    );\n-    apply_patches(\"rand\", Path::new(\"rand\"));\n-\n-    clone_repo_shallow_github(\n-        \"regex\",\n-        \"rust-lang\",\n-        \"regex\",\n-        \"341f207c1071f7290e3f228c710817c280c8dca1\",\n-    );\n-\n-    clone_repo_shallow_github(\n-        \"portable-simd\",\n-        \"rust-lang\",\n-        \"portable-simd\",\n-        \"b8d6b6844602f80af79cd96401339ec594d472d8\",\n-    );\n-    apply_patches(\"portable-simd\", Path::new(\"portable-simd\"));\n-\n-    clone_repo_shallow_github(\n-        \"simple-raytracer\",\n-        \"ebobby\",\n-        \"simple-raytracer\",\n-        \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n-    );\n+    ABI_CAFE.fetch();\n+    RAND.fetch();\n+    REGEX.fetch();\n+    PORTABLE_SIMD.fetch();\n+    SIMPLE_RAYTRACER.fetch();\n \n     eprintln!(\"[LLVM BUILD] simple-raytracer\");\n-    let mut build_cmd = Command::new(\"cargo\");\n-    build_cmd.arg(\"build\").env_remove(\"CARGO_TARGET_DIR\").current_dir(\"simple-raytracer\");\n+    let build_cmd = cargo_command(\"cargo\", \"build\", None, &SIMPLE_RAYTRACER.source_dir());\n     spawn_and_wait(build_cmd);\n     fs::copy(\n-        Path::new(\"simple-raytracer/target/debug\").join(get_file_name(\"main\", \"bin\")),\n-        Path::new(\"simple-raytracer\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+        SIMPLE_RAYTRACER\n+            .source_dir()\n+            .join(\"target\")\n+            .join(\"debug\")\n+            .join(get_file_name(\"main\", \"bin\")),\n+        SIMPLE_RAYTRACER.source_dir().join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }\n@@ -90,38 +93,78 @@ fn prepare_sysroot() {\n     apply_patches(\"sysroot\", &sysroot_src);\n }\n \n+pub(crate) struct GitRepo {\n+    url: GitRepoUrl,\n+    rev: &'static str,\n+    patch_name: &'static str,\n+}\n+\n+enum GitRepoUrl {\n+    Github { user: &'static str, repo: &'static str },\n+}\n+\n+impl GitRepo {\n+    const fn github(\n+        user: &'static str,\n+        repo: &'static str,\n+        rev: &'static str,\n+        patch_name: &'static str,\n+    ) -> GitRepo {\n+        GitRepo { url: GitRepoUrl::Github { user, repo }, rev, patch_name }\n+    }\n+\n+    pub(crate) fn source_dir(&self) -> PathBuf {\n+        match self.url {\n+            GitRepoUrl::Github { user: _, repo } => {\n+                std::env::current_dir().unwrap().join(\"download\").join(repo)\n+            }\n+        }\n+    }\n+\n+    fn fetch(&self) {\n+        match self.url {\n+            GitRepoUrl::Github { user, repo } => {\n+                clone_repo_shallow_github(&self.source_dir(), user, repo, self.rev);\n+            }\n+        }\n+        apply_patches(self.patch_name, &self.source_dir());\n+    }\n+}\n+\n #[allow(dead_code)]\n-fn clone_repo(target_dir: &str, repo: &str, rev: &str) {\n+fn clone_repo(download_dir: &Path, repo: &str, rev: &str) {\n     eprintln!(\"[CLONE] {}\", repo);\n     // Ignore exit code as the repo may already have been checked out\n-    Command::new(\"git\").arg(\"clone\").arg(repo).arg(target_dir).spawn().unwrap().wait().unwrap();\n+    Command::new(\"git\").arg(\"clone\").arg(repo).arg(&download_dir).spawn().unwrap().wait().unwrap();\n \n     let mut clean_cmd = Command::new(\"git\");\n-    clean_cmd.arg(\"checkout\").arg(\"--\").arg(\".\").current_dir(target_dir);\n+    clean_cmd.arg(\"checkout\").arg(\"--\").arg(\".\").current_dir(&download_dir);\n     spawn_and_wait(clean_cmd);\n \n     let mut checkout_cmd = Command::new(\"git\");\n-    checkout_cmd.arg(\"checkout\").arg(\"-q\").arg(rev).current_dir(target_dir);\n+    checkout_cmd.arg(\"checkout\").arg(\"-q\").arg(rev).current_dir(download_dir);\n     spawn_and_wait(checkout_cmd);\n }\n \n-fn clone_repo_shallow_github(target_dir: &str, username: &str, repo: &str, rev: &str) {\n+fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &str) {\n     if cfg!(windows) {\n         // Older windows doesn't have tar or curl by default. Fall back to using git.\n-        clone_repo(target_dir, &format!(\"https://github.com/{}/{}.git\", username, repo), rev);\n+        clone_repo(download_dir, &format!(\"https://github.com/{}/{}.git\", user, repo), rev);\n         return;\n     }\n \n-    let archive_url = format!(\"https://github.com/{}/{}/archive/{}.tar.gz\", username, repo, rev);\n-    let archive_file = format!(\"{}.tar.gz\", rev);\n-    let archive_dir = format!(\"{}-{}\", repo, rev);\n+    let downloads_dir = std::env::current_dir().unwrap().join(\"download\");\n \n-    eprintln!(\"[DOWNLOAD] {}/{} from {}\", username, repo, archive_url);\n+    let archive_url = format!(\"https://github.com/{}/{}/archive/{}.tar.gz\", user, repo, rev);\n+    let archive_file = downloads_dir.join(format!(\"{}.tar.gz\", rev));\n+    let archive_dir = downloads_dir.join(format!(\"{}-{}\", repo, rev));\n+\n+    eprintln!(\"[DOWNLOAD] {}/{} from {}\", user, repo, archive_url);\n \n     // Remove previous results if they exists\n     let _ = std::fs::remove_file(&archive_file);\n     let _ = std::fs::remove_dir_all(&archive_dir);\n-    let _ = std::fs::remove_dir_all(target_dir);\n+    let _ = std::fs::remove_dir_all(&download_dir);\n \n     // Download zip archive\n     let mut download_cmd = Command::new(\"curl\");\n@@ -130,13 +173,13 @@ fn clone_repo_shallow_github(target_dir: &str, username: &str, repo: &str, rev:\n \n     // Unpack tar archive\n     let mut unpack_cmd = Command::new(\"tar\");\n-    unpack_cmd.arg(\"xf\").arg(&archive_file);\n+    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(downloads_dir);\n     spawn_and_wait(unpack_cmd);\n \n     // Rename unpacked dir to the expected name\n-    std::fs::rename(archive_dir, target_dir).unwrap();\n+    std::fs::rename(archive_dir, &download_dir).unwrap();\n \n-    init_git_repo(Path::new(target_dir));\n+    init_git_repo(&download_dir);\n \n     // Cleanup\n     std::fs::remove_file(archive_file).unwrap();\n@@ -156,26 +199,39 @@ fn init_git_repo(repo_dir: &Path) {\n     spawn_and_wait(git_commit_cmd);\n }\n \n-fn get_patches(crate_name: &str) -> Vec<OsString> {\n-    let mut patches: Vec<_> = fs::read_dir(\"patches\")\n+fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n+    let mut patches: Vec<_> = fs::read_dir(source_dir.join(\"patches\"))\n         .unwrap()\n         .map(|entry| entry.unwrap().path())\n         .filter(|path| path.extension() == Some(OsStr::new(\"patch\")))\n-        .map(|path| path.file_name().unwrap().to_owned())\n-        .filter(|file_name| {\n-            file_name.to_str().unwrap().split_once(\"-\").unwrap().1.starts_with(crate_name)\n+        .filter(|path| {\n+            path.file_name()\n+                .unwrap()\n+                .to_str()\n+                .unwrap()\n+                .split_once(\"-\")\n+                .unwrap()\n+                .1\n+                .starts_with(crate_name)\n         })\n         .collect();\n     patches.sort();\n     patches\n }\n \n fn apply_patches(crate_name: &str, target_dir: &Path) {\n-    for patch in get_patches(crate_name) {\n-        eprintln!(\"[PATCH] {:?} <- {:?}\", target_dir.file_name().unwrap(), patch);\n-        let patch_arg = env::current_dir().unwrap().join(\"patches\").join(patch);\n+    if crate_name == \"<none>\" {\n+        return;\n+    }\n+\n+    for patch in get_patches(&std::env::current_dir().unwrap(), crate_name) {\n+        eprintln!(\n+            \"[PATCH] {:?} <- {:?}\",\n+            target_dir.file_name().unwrap(),\n+            patch.file_name().unwrap()\n+        );\n         let mut apply_patch_cmd = Command::new(\"git\");\n-        apply_patch_cmd.arg(\"am\").arg(patch_arg).arg(\"-q\").current_dir(target_dir);\n+        apply_patch_cmd.arg(\"am\").arg(patch).arg(\"-q\").current_dir(target_dir);\n         spawn_and_wait(apply_patch_cmd);\n     }\n }"}, {"sha": "a414b60f4e06b2b79dccc1ee64bc233f32ae6ba1", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 85, "deletions": 94, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -1,7 +1,8 @@\n use super::build_sysroot;\n use super::config;\n+use super::prepare;\n use super::rustc_info::get_wrapper_file_name;\n-use super::utils::{spawn_and_wait, spawn_and_wait_with_input};\n+use super::utils::{cargo_command, hyperfine_command, spawn_and_wait, spawn_and_wait_with_input};\n use build_system::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n@@ -217,103 +218,95 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        runner.in_dir([\"rand\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n+        runner.in_dir(prepare::RAND.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n \n             if runner.host_triple == runner.target_triple {\n                 eprintln!(\"[TEST] rust-random/rand\");\n-                runner.run_cargo([\"test\", \"--workspace\"]);\n+                runner.run_cargo(\"test\", [\"--workspace\"]);\n             } else {\n                 eprintln!(\"[AOT] rust-random/rand\");\n-                runner.run_cargo([\n-                    \"build\",\n-                    \"--workspace\",\n-                    \"--target\",\n-                    &runner.target_triple,\n-                    \"--tests\",\n-                ]);\n+                runner.run_cargo(\"build\", [\"--workspace\", \"--tests\"]);\n             }\n         });\n     }),\n     TestCase::new(\"bench.simple-raytracer\", &|runner| {\n-        runner.in_dir([\"simple-raytracer\"], |runner| {\n-            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string());\n+        runner.in_dir(prepare::SIMPLE_RAYTRACER.source_dir(), |runner| {\n+            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n \n             if runner.host_triple == runner.target_triple {\n                 eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-                let mut bench_compile = Command::new(\"hyperfine\");\n-                bench_compile.arg(\"--runs\");\n-                bench_compile.arg(&run_runs);\n-                bench_compile.arg(\"--warmup\");\n-                bench_compile.arg(\"1\");\n-                bench_compile.arg(\"--prepare\");\n-                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"clean\"])));\n-\n-                if cfg!(windows) {\n-                    bench_compile.arg(\"cmd /C \\\"set RUSTFLAGS= && cargo build\\\"\");\n-                } else {\n-                    bench_compile.arg(\"RUSTFLAGS='' cargo build\");\n-                }\n+                let prepare = runner.cargo_command(\"clean\", []);\n+\n+                let llvm_build_cmd = cargo_command(\"cargo\", \"build\", None, Path::new(\".\"));\n+\n+                let cargo_clif = runner\n+                    .root_dir\n+                    .clone()\n+                    .join(\"build\")\n+                    .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+                let clif_build_cmd = cargo_command(cargo_clif, \"build\", None, Path::new(\".\"));\n+\n+                let bench_compile =\n+                    hyperfine_command(1, run_runs, Some(prepare), llvm_build_cmd, clif_build_cmd);\n \n-                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"build\"])));\n                 spawn_and_wait(bench_compile);\n \n                 eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n                 fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n                     .unwrap();\n \n-                let mut bench_run = Command::new(\"hyperfine\");\n-                bench_run.arg(\"--runs\");\n-                bench_run.arg(&run_runs);\n-                bench_run.arg(PathBuf::from(\"./raytracer_cg_llvm\"));\n-                bench_run.arg(PathBuf::from(\"./raytracer_cg_clif\"));\n+                let bench_run = hyperfine_command(\n+                    0,\n+                    run_runs,\n+                    None,\n+                    Command::new(\"./raytracer_cg_llvm\"),\n+                    Command::new(\"./raytracer_cg_clif\"),\n+                );\n                 spawn_and_wait(bench_run);\n             } else {\n-                runner.run_cargo([\"clean\"]);\n+                runner.run_cargo(\"clean\", []);\n                 eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n                 eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-                runner.run_cargo([\"build\", \"--target\", &runner.target_triple]);\n+                runner.run_cargo(\"build\", []);\n                 eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n             }\n         });\n     }),\n     TestCase::new(\"test.libcore\", &|runner| {\n-        runner.in_dir([\"build_sysroot\", \"sysroot_src\", \"library\", \"core\", \"tests\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n-\n-            if runner.host_triple == runner.target_triple {\n-                runner.run_cargo([\"test\"]);\n-            } else {\n-                eprintln!(\"Cross-Compiling: Not running tests\");\n-                runner.run_cargo([\"build\", \"--target\", &runner.target_triple, \"--tests\"]);\n-            }\n-        });\n+        runner.in_dir(\n+            std::env::current_dir()\n+                .unwrap()\n+                .join(\"build_sysroot\")\n+                .join(\"sysroot_src\")\n+                .join(\"library\")\n+                .join(\"core\")\n+                .join(\"tests\"),\n+            |runner| {\n+                runner.run_cargo(\"clean\", []);\n+\n+                if runner.host_triple == runner.target_triple {\n+                    runner.run_cargo(\"test\", []);\n+                } else {\n+                    eprintln!(\"Cross-Compiling: Not running tests\");\n+                    runner.run_cargo(\"build\", [\"--tests\"]);\n+                }\n+            },\n+        );\n     }),\n     TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        runner.in_dir([\"regex\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n+        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n \n             // newer aho_corasick versions throw a deprecation warning\n             let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n \n-            let mut build_cmd = runner.cargo_command([\n-                \"build\",\n-                \"--example\",\n-                \"shootout-regex-dna\",\n-                \"--target\",\n-                &runner.target_triple,\n-            ]);\n+            let mut build_cmd = runner.cargo_command(\"build\", [\"--example\", \"shootout-regex-dna\"]);\n             build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n             spawn_and_wait(build_cmd);\n \n             if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command([\n-                    \"run\",\n-                    \"--example\",\n-                    \"shootout-regex-dna\",\n-                    \"--target\",\n-                    &runner.target_triple,\n-                ]);\n+                let mut run_cmd = runner.cargo_command(\"run\", [\"--example\", \"shootout-regex-dna\"]);\n                 run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n \n                 let input =\n@@ -353,41 +346,43 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n         });\n     }),\n     TestCase::new(\"test.regex\", &|runner| {\n-        runner.in_dir([\"regex\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n+        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n \n             // newer aho_corasick versions throw a deprecation warning\n             let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n \n             if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command([\n+                let mut run_cmd = runner.cargo_command(\n                     \"test\",\n-                    \"--tests\",\n-                    \"--\",\n-                    \"--exclude-should-panic\",\n-                    \"--test-threads\",\n-                    \"1\",\n-                    \"-Zunstable-options\",\n-                    \"-q\",\n-                ]);\n+                    [\n+                        \"--tests\",\n+                        \"--\",\n+                        \"--exclude-should-panic\",\n+                        \"--test-threads\",\n+                        \"1\",\n+                        \"-Zunstable-options\",\n+                        \"-q\",\n+                    ],\n+                );\n                 run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n                 spawn_and_wait(run_cmd);\n             } else {\n                 eprintln!(\"Cross-Compiling: Not running tests\");\n                 let mut build_cmd =\n-                    runner.cargo_command([\"build\", \"--tests\", \"--target\", &runner.target_triple]);\n+                    runner.cargo_command(\"build\", [\"--tests\", \"--target\", &runner.target_triple]);\n                 build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n                 spawn_and_wait(build_cmd);\n             }\n         });\n     }),\n     TestCase::new(\"test.portable-simd\", &|runner| {\n-        runner.in_dir([\"portable-simd\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n-            runner.run_cargo([\"build\", \"--all-targets\", \"--target\", &runner.target_triple]);\n+        runner.in_dir(prepare::PORTABLE_SIMD.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n+            runner.run_cargo(\"build\", [\"--all-targets\", \"--target\", &runner.target_triple]);\n \n             if runner.host_triple == runner.target_triple {\n-                runner.run_cargo([\"test\", \"-q\"]);\n+                runner.run_cargo(\"test\", [\"-q\"]);\n             }\n         });\n     }),\n@@ -397,7 +392,7 @@ pub(crate) fn run_tests(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     target_dir: &Path,\n-    cg_clif_build_dir: &Path,\n+    cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n@@ -408,7 +403,7 @@ pub(crate) fn run_tests(\n             channel,\n             SysrootKind::None,\n             &target_dir,\n-            cg_clif_build_dir,\n+            cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n         );\n@@ -427,7 +422,7 @@ pub(crate) fn run_tests(\n             channel,\n             sysroot_kind,\n             &target_dir,\n-            cg_clif_build_dir,\n+            cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n         );\n@@ -521,16 +516,8 @@ impl TestRunner {\n         }\n     }\n \n-    fn in_dir<'a, I, F>(&self, dir: I, callback: F)\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-        F: FnOnce(&TestRunner),\n-    {\n+    fn in_dir(&self, new: impl AsRef<Path>, callback: impl FnOnce(&TestRunner)) {\n         let current = env::current_dir().unwrap();\n-        let mut new = current.clone();\n-        for d in dir {\n-            new.push(d);\n-        }\n \n         env::set_current_dir(new).unwrap();\n         callback(self);\n@@ -595,25 +582,29 @@ impl TestRunner {\n         spawn_and_wait(cmd);\n     }\n \n-    fn cargo_command<I, S>(&self, args: I) -> Command\n+    fn cargo_command<'a, I>(&self, subcommand: &str, args: I) -> Command\n     where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n+        I: IntoIterator<Item = &'a str>,\n     {\n         let mut cargo_clif = self.root_dir.clone();\n         cargo_clif.push(\"build\");\n         cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n \n-        let mut cmd = Command::new(cargo_clif);\n+        let mut cmd = cargo_command(\n+            cargo_clif,\n+            subcommand,\n+            if subcommand == \"clean\" { None } else { Some(&self.target_triple) },\n+            Path::new(\".\"),\n+        );\n         cmd.args(args);\n         cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n         cmd\n     }\n \n-    fn run_cargo<'a, I>(&self, args: I)\n+    fn run_cargo<'a, I>(&self, subcommand: &str, args: I)\n     where\n         I: IntoIterator<Item = &'a str>,\n     {\n-        spawn_and_wait(self.cargo_command(args));\n+        spawn_and_wait(self.cargo_command(subcommand, args));\n     }\n }"}, {"sha": "48da64906e2a4b30189c82535f560a899e547510", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -4,6 +4,52 @@ use std::io::Write;\n use std::path::Path;\n use std::process::{self, Command, Stdio};\n \n+pub(crate) fn cargo_command(\n+    cargo: impl AsRef<Path>,\n+    subcommand: &str,\n+    triple: Option<&str>,\n+    source_dir: &Path,\n+) -> Command {\n+    let mut cmd = Command::new(cargo.as_ref());\n+    cmd.arg(subcommand)\n+        .arg(\"--manifest-path\")\n+        .arg(source_dir.join(\"Cargo.toml\"))\n+        .arg(\"--target-dir\")\n+        .arg(source_dir.join(\"target\"));\n+\n+    if let Some(triple) = triple {\n+        cmd.arg(\"--target\").arg(triple);\n+    }\n+\n+    cmd\n+}\n+\n+pub(crate) fn hyperfine_command(\n+    warmup: u64,\n+    runs: u64,\n+    prepare: Option<Command>,\n+    a: Command,\n+    b: Command,\n+) -> Command {\n+    let mut bench = Command::new(\"hyperfine\");\n+\n+    if warmup != 0 {\n+        bench.arg(\"--warmup\").arg(warmup.to_string());\n+    }\n+\n+    if runs != 0 {\n+        bench.arg(\"--runs\").arg(runs.to_string());\n+    }\n+\n+    if let Some(prepare) = prepare {\n+        bench.arg(\"--prepare\").arg(format!(\"{:?}\", prepare));\n+    }\n+\n+    bench.arg(format!(\"{:?}\", a)).arg(format!(\"{:?}\", b));\n+\n+    bench\n+}\n+\n #[track_caller]\n pub(crate) fn try_hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) {\n     let src = src.as_ref();"}, {"sha": "fedab2433aa05f66f33949f35ea62cd88ec3f4ed", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -3,4 +3,8 @@ set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n rm -rf target/ build/ perf.data{,.old} y.bin\n-rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/\n+rm -rf download/\n+\n+# Kept for now in case someone updates their checkout of cg_clif before running clean_all.sh\n+# FIXME remove at some point in the future\n+rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/ abi-cafe/"}, {"sha": "0d539191b12f95936b65e6d134d460b31d96c3e6", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -49,4 +49,4 @@ test.regex-shootout-regex-dna\n test.regex\n test.portable-simd\n \n-testsuite.abi-checker\n+testsuite.abi-cafe"}, {"sha": "039100696331b638f7fc52afb60b9a6c6d05c8b8", "filename": "compiler/rustc_codegen_cranelift/example/issue-91827-extern-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -5,7 +5,6 @@\n // Test that we can handle unsized types with an extern type tail part.\n // Regression test for issue #91827.\n \n-#![feature(const_ptr_offset_from)]\n #![feature(extern_types)]\n \n use std::ptr::addr_of;"}, {"sha": "7f85b52f083a7c2a8de18913a937a65e711474b7", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -559,16 +559,22 @@ pub union MaybeUninit<T> {\n \n pub mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n+        #[rustc_safe_intrinsic]\n         pub fn size_of<T>() -> usize;\n         pub fn size_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        #[rustc_safe_intrinsic]\n         pub fn min_align_of<T>() -> usize;\n         pub fn min_align_of_val<T: ?::Sized>(val: *const T) -> usize;\n         pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n         pub fn transmute<T, U>(e: T) -> U;\n         pub fn ctlz_nonzero<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn needs_drop<T: ?::Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n         pub fn bitreverse<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn bswap<T>(x: T) -> T;\n         pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }"}, {"sha": "215d3556a17ca8cf2b5eb7a7673b5a090612da70", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -93,6 +93,7 @@ fn start<T: Termination + 'static>(\n     main: fn() -> T,\n     argc: isize,\n     argv: *const *const u8,\n+    _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n         unsafe { puts(*argv as *const i8); }"}, {"sha": "0e5e7cdfcdf1a44028d6ada6cc17c59ee28d96f2", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -0,0 +1,29 @@\n+From 2b15fee2bb5fd14e34c7e17e44d99cb34f4c555d Mon Sep 17 00:00:00 2001\n+From: Afonso Bordado <afonsobordado@az8.co>\n+Date: Tue, 27 Sep 2022 07:55:17 +0100\n+Subject: [PATCH] Disable some test on x86_64-pc-windows-gnu\n+\n+---\n+ src/report.rs | 6 ++++++\n+ 1 file changed, 6 insertions(+)\n+\n+diff --git a/src/report.rs b/src/report.rs\n+index eeec614..f582867 100644\n+--- a/src/report.rs\n++++ b/src/report.rs\n+@@ -48,6 +48,12 @@ pub fn get_test_rules(test: &TestKey, caller: &dyn AbiImpl, callee: &dyn AbiImpl\n+     //\n+     // THIS AREA RESERVED FOR VENDORS TO APPLY PATCHES\n+ \n++    // x86_64-pc-windows-gnu has some broken i128 tests that aren't disabled by default\n++    if cfg!(all(target_os = \"windows\", target_env = \"gnu\")) && test.test_name == \"ui128\" {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n+     // END OF VENDOR RESERVED AREA\n+     //\n+     //\n+-- \n+2.30.1.windows.1\n+"}, {"sha": "526366a7598760b95bb6d107ca3dbf20a8f0f871", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-checker-Disable-failing-tests.patch", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/9be2f35a4c1ed1b04aa4a6945b64763f599259ff/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch?ref=9be2f35a4c1ed1b04aa4a6945b64763f599259ff", "patch": "@@ -1,36 +0,0 @@\n-From 1a315ba225577dbbd1f449d9609f16f984f68708 Mon Sep 17 00:00:00 2001\n-From: Afonso Bordado <afonso360@users.noreply.github.com>\n-Date: Fri, 12 Aug 2022 22:51:58 +0000\n-Subject: [PATCH] Disable abi-checker tests\n-\n----\n- src/report.rs | 14 ++++++++++++++\n- 1 file changed, 14 insertions(+)\n-\n-diff --git a/src/report.rs b/src/report.rs\n-index 7346f5e..8347762 100644\n---- a/src/report.rs\n-+++ b/src/report.rs\n-@@ -45,6 +45,20 @@ pub fn get_test_rules(test: &TestKey, caller: &dyn AbiImpl, callee: &dyn AbiImpl\n-     //\n-     // THIS AREA RESERVED FOR VENDORS TO APPLY PATCHES\n-\n-+    // Currently MSVC has some broken ABI issues. Furthermore, they cause\n-+    // a STATUS_ACCESS_VIOLATION, so we can't even run them. Ensure that they compile and link.\n-+    if cfg!(windows) && (test.test_name == \"bool\" || test.test_name == \"ui128\") {\n-+        result.run = Link;\n-+        result.check = Pass(Link);\n-+    }\n-+\n-+    // structs is broken in the current release of cranelift for aarch64.\n-+    // It has been fixed for cranelift 0.88: https://github.com/bytecodealliance/wasmtime/pull/4634\n-+    if cfg!(target_arch = \"aarch64\") && test.test_name == \"structs\" {\n-+        result.run = Link;\n-+        result.check = Pass(Link);\n-+    }\n-+\n-     // END OF VENDOR RESERVED AREA\n-     //\n-     //\n---\n-2.34.1"}, {"sha": "89e2b61c1fc8553be9c7668525c66e97d5fdcd52", "filename": "compiler/rustc_codegen_cranelift/patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "modified", "additions": 12, "deletions": 84, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -1,107 +1,35 @@\n-From 97c473937382a5b5858d9cce3c947855d23b2dc5 Mon Sep 17 00:00:00 2001\n+From b742f03694b920cc14400727d54424e8e1b60928 Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n Date: Thu, 18 Nov 2021 19:28:40 +0100\n Subject: [PATCH] Disable unsupported tests\n \n ---\n- crates/core_simd/src/math.rs         | 6 ++++++\n- crates/core_simd/src/vector.rs       | 2 ++\n- crates/core_simd/tests/masks.rs      | 2 ++\n- crates/core_simd/tests/ops_macros.rs | 4 ++++\n- 4 files changed, 14 insertions(+)\n+ crates/core_simd/src/elements/int.rs     | 8 ++++++++\n+ crates/core_simd/src/elements/uint.rs    | 4 ++++\n+ crates/core_simd/src/masks/full_masks.rs | 6 ++++++\n+ crates/core_simd/src/vector.rs           | 2 ++\n+ crates/core_simd/tests/masks.rs          | 3 ---\n+ 5 files changed, 20 insertions(+), 3 deletions(-)\n \n-diff --git a/crates/core_simd/src/math.rs b/crates/core_simd/src/math.rs\n-index 2bae414..2f87499 100644\n---- a/crates/core_simd/src/math.rs\n-+++ b/crates/core_simd/src/math.rs\n-@@ -5,6 +5,7 @@ macro_rules! impl_uint_arith {\n-     ($($ty:ty),+) => {\n-         $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n- \n-+            /*\n-             /// Lanewise saturating add.\n-             ///\n-             /// # Examples\n-@@ -43,6 +44,7 @@ macro_rules! impl_uint_arith {\n-             pub fn saturating_sub(self, second: Self) -> Self {\n-                 unsafe { simd_saturating_sub(self, second) }\n-             }\n-+            */\n-         })+\n-     }\n- }\n-@@ -51,6 +53,7 @@ macro_rules! impl_int_arith {\n-     ($($ty:ty),+) => {\n-         $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n- \n-+            /*\n-             /// Lanewise saturating add.\n-             ///\n-             /// # Examples\n-@@ -89,6 +92,7 @@ macro_rules! impl_int_arith {\n-             pub fn saturating_sub(self, second: Self) -> Self {\n-                 unsafe { simd_saturating_sub(self, second) }\n-             }\n-+            */\n- \n-             /// Lanewise absolute value, implemented in Rust.\n-             /// Every lane becomes its absolute value.\n-@@ -109,6 +113,7 @@ macro_rules! impl_int_arith {\n-                 (self^m) - m\n-             }\n- \n-+            /*\n-             /// Lanewise saturating absolute value, implemented in Rust.\n-             /// As abs(), except the MIN value becomes MAX instead of itself.\n-             ///\n-@@ -151,6 +156,7 @@ macro_rules! impl_int_arith {\n-             pub fn saturating_neg(self) -> Self {\n-                 Self::splat(0).saturating_sub(self)\n-             }\n-+            */\n-         })+\n-     }\n- }\n diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n-index 7c5ec2b..c8631e8 100644\n+index e8e8f68..7173c24 100644\n --- a/crates/core_simd/src/vector.rs\n +++ b/crates/core_simd/src/vector.rs\n-@@ -75,6 +75,7 @@ where\n-         Self(array)\n+@@ -250,6 +250,7 @@ where\n+         unsafe { intrinsics::simd_cast(self) }\n      }\n  \n +    /*\n      /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n      /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n      ///\n-@@ -297,6 +298,7 @@ where\n+@@ -473,6 +474,7 @@ where\n              // Cleared \u2622\ufe0f *mut T Zone\n          }\n      }\n +    */\n  }\n  \n  impl<T, const LANES: usize> Copy for Simd<T, LANES>\n-diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n-index 6a8ecd3..68fcb49 100644\n---- a/crates/core_simd/tests/masks.rs\n-+++ b/crates/core_simd/tests/masks.rs\n-@@ -68,6 +68,7 @@ macro_rules! test_mask_api {\n-                 assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n-             }\n- \n-+            /*\n-             #[cfg(feature = \"generic_const_exprs\")]\n-             #[test]\n-             fn roundtrip_bitmask_conversion() {\n-@@ -80,6 +81,7 @@ macro_rules! test_mask_api {\n-                 assert_eq!(bitmask, [0b01001001, 0b10000011]);\n-                 assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n-             }\n-+            */\n-         }\n-     }\n- }\n -- \n-2.26.2.7.g19db9cfb68\n-\n+2.25.1"}, {"sha": "d8775e2d022a00d2ac490163670f8bc030c4555b", "filename": "compiler/rustc_codegen_cranelift/patches/0003-rand-Disable-rand-tests-on-mingw.patch", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -0,0 +1,47 @@\n+From eec874c889b8d24e5ad50faded24288150f057b1 Mon Sep 17 00:00:00 2001\n+From: Afonso Bordado <afonsobordado@az8.co>\n+Date: Tue, 27 Sep 2022 08:13:58 +0100\n+Subject: [PATCH] Disable rand tests on mingw\n+\n+---\n+ rand_distr/src/pareto.rs            | 2 ++\n+ rand_distr/tests/value_stability.rs | 4 ++++\n+ 2 files changed, 6 insertions(+)\n+\n+diff --git a/rand_distr/src/pareto.rs b/rand_distr/src/pareto.rs\n+index 217899e..9cedeb7 100644\n+--- a/rand_distr/src/pareto.rs\n++++ b/rand_distr/src/pareto.rs\n+@@ -107,6 +107,8 @@ mod tests {\n+     }\n+\n+     #[test]\n++    // This is broken on x86_64-pc-windows-gnu presumably due to a broken powf implementation\n++    #[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n+     fn value_stability() {\n+         fn test_samples<F: Float + core::fmt::Debug, D: Distribution<F>>(\n+             distr: D, zero: F, expected: &[F],\n+diff --git a/rand_distr/tests/value_stability.rs b/rand_distr/tests/value_stability.rs\n+index 192ba74..0101ace 100644\n+--- a/rand_distr/tests/value_stability.rs\n++++ b/rand_distr/tests/value_stability.rs\n+@@ -72,6 +72,8 @@ fn unit_disc_stability() {\n+ }\n+\n+ #[test]\n++// This is broken on x86_64-pc-windows-gnu\n++#[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n+ fn pareto_stability() {\n+     test_samples(213, Pareto::new(1.0, 1.0).unwrap(), &[\n+         1.0423688f32, 2.1235929, 4.132709, 1.4679428,\n+@@ -143,6 +145,8 @@ fn inverse_gaussian_stability() {\n+ }\n+\n+ #[test]\n++// This is broken on x86_64-pc-windows-gnu\n++#[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n+ fn gamma_stability() {\n+     // Gamma has 3 cases: shape == 1, shape < 1, shape > 1\n+     test_samples(223, Gamma::new(1.0, 5.0).unwrap(), &[\n+--\n+2.25.1"}, {"sha": "c0a2e7a7883fcb14031a9ea5a38289d564d30d4a", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-08-24\"\n+channel = \"nightly-2022-10-23\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "d6a37789599fe8d0621de8a2577fc77aa45b1be3", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -10,6 +10,8 @@ git fetch\n git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n+git am ../patches/*-sysroot-*.patch\n+\n git apply - <<EOF\n diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n index d95b5b7f17f..00b6f0e3635 100644\n@@ -66,3 +68,7 @@ popd\n \n # FIXME remove once inline asm is fully supported\n export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\"\n+\n+# Allow the testsuite to use llvm tools\n+host_triple=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n+export LLVM_BIN_DIR=\"$(rustc --print sysroot)/lib/rustlib/$host_triple/bin\""}, {"sha": "9b5db3cf81f0e3341f553398f6354c9320cf0640", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -29,10 +29,6 @@ rm src/test/incremental/change_crate_dep_kind.rs\n rm src/test/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abort instead of exit(101)\n \n # requires compiling with -Cpanic=unwind\n-rm src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-type.rs # \"Cannot run dynamic test fn out-of-process\"\n-rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n-rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n-rm src/test/ui/generator/size-moved-locals.rs # same\n rm -r src/test/ui/macros/rfc-2011-nicer-assert-messages/\n \n # vendor intrinsics\n@@ -67,6 +63,7 @@ rm src/test/ui/target-feature/missing-plusminus.rs # error not implemented\n rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r src/test/run-make/emit-named-files # requires full --emit support\n rm src/test/ui/abi/stack-probes.rs # stack probes not yet implemented\n+rm src/test/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n \n # optimization tests\n # ==================\n@@ -110,12 +107,13 @@ rm src/test/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unorde\n # bugs in the test suite\n # ======================\n rm src/test/ui/backtrace.rs # TODO warning\n-rm src/test/ui/empty_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/simple_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n # not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n rm -r src/test/run-make/native-link-modifier-bundle\n \n+rm src/test/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n+\n echo \"[TEST] rustc test suite\"\n RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui,incremental}\n popd"}, {"sha": "99059e788a074a12450d9022e210d27efc005978", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -465,7 +465,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n             let sig = fx.bcx.import_signature(sig);\n \n-            (CallTarget::Indirect(sig, method), Some(ptr))\n+            (CallTarget::Indirect(sig, method), Some(ptr.get_addr(fx)))\n         }\n \n         // Normal call\n@@ -560,7 +560,19 @@ pub(crate) fn codegen_drop<'tcx>(\n         // we don't actually need to drop anything\n     } else {\n         match ty.kind() {\n-            ty::Dynamic(..) => {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n+                // IN THIS ARM, WE HAVE:\n+                // ty = *mut (dyn Trait)\n+                // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n+                //                       args[0]    args[1]\n+                //\n+                // args = ( Data, Vtable )\n+                //                  |\n+                //                  v\n+                //                /-------\\\n+                //                | ...   |\n+                //                \\-------/\n+                //\n                 let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n@@ -578,6 +590,43 @@ pub(crate) fn codegen_drop<'tcx>(\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n             }\n+            ty::Dynamic(_, _, ty::DynStar) => {\n+                // IN THIS ARM, WE HAVE:\n+                // ty = *mut (dyn* Trait)\n+                // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n+                //\n+                // args = [ * ]\n+                //          |\n+                //          v\n+                //      ( Data, Vtable )\n+                //                |\n+                //                v\n+                //              /-------\\\n+                //              | ...   |\n+                //              \\-------/\n+                //\n+                //\n+                // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n+                //\n+                // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n+                // vtable = (*args[0]).1   // loads the vtable out\n+                // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n+                //\n+                // SO THEN WE CAN USE THE ABOVE CODE.\n+                let (data, vtable) = drop_place.to_cvalue(fx).dyn_star_force_data_on_stack(fx);\n+                let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable);\n+\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_instance.def_id(), 0),\n+                    substs: drop_instance.substs,\n+                };\n+                let fn_abi =\n+                    RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(virtual_drop, ty::List::empty());\n+\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n+                let sig = fx.bcx.import_signature(sig);\n+                fx.bcx.ins().call_indirect(sig, drop_fn, &[data]);\n+            }\n             _ => {\n                 assert!(!matches!(drop_instance.def, InstanceDef::Virtual(_, _)));\n "}, {"sha": "bad8a87b9bee4b809bbb5f20226b07b6cf2805e0", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -78,7 +78,7 @@ fn codegen_inner(\n         let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n         let mut ctx = Context::new();\n-        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n+        ctx.func.signature = sig.clone();\n         {\n             let mut func_ctx = FunctionBuilderContext::new();\n             let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n@@ -116,7 +116,7 @@ fn codegen_inner(\n     let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n-    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n+    ctx.func.signature = sig;\n     {\n         let mut func_ctx = FunctionBuilderContext::new();\n         let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);"}, {"sha": "31d3d0e06156bf3defc921299d5c61c3604c29ed", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -159,6 +159,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                         let err = err.to_string();\n                         if err == \"Unknown file magic\" {\n                             // Not an object file; skip it.\n+                        } else if object::read::archive::ArchiveFile::parse(&*data).is_ok() {\n+                            // Nested archive file; skip it.\n                         } else {\n                             sess.fatal(&format!(\n                                 \"error parsing `{}` during archive creation: {}\","}, {"sha": "a41b561598f68638f896c90bdbd855219a2c97a2", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -6,6 +6,8 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n+use cranelift_codegen::ir::UserFuncName;\n+\n use crate::constant::ConstantCx;\n use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n@@ -64,7 +66,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut func = cached_func;\n     func.clear();\n-    func.name = ExternalName::user(0, func_id.as_u32());\n+    func.name = UserFuncName::user(0, func_id.as_u32());\n     func.signature = sig;\n     func.collect_debug_info();\n \n@@ -706,9 +708,9 @@ fn codegen_stmt<'tcx>(\n                     let operand = codegen_operand(fx, operand);\n                     operand.unsize_value(fx, lval);\n                 }\n-                Rvalue::Cast(CastKind::DynStar, _, _) => {\n-                    // FIXME(dyn-star)\n-                    unimplemented!()\n+                Rvalue::Cast(CastKind::DynStar, ref operand, _) => {\n+                    let operand = codegen_operand(fx, operand);\n+                    operand.coerce_dyn_star(fx, lval);\n                 }\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n@@ -922,7 +924,7 @@ pub(crate) fn codegen_operand<'tcx>(\n             let cplace = codegen_place(fx, *place);\n             cplace.to_cvalue(fx)\n         }\n-        Operand::Constant(const_) => crate::constant::codegen_constant(fx, const_),\n+        Operand::Constant(const_) => crate::constant::codegen_constant_operand(fx, const_),\n     }\n }\n "}, {"sha": "f855e20e0a1a3732aa1a01374f57ebafd5f4a0b0", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -10,6 +10,7 @@ pub(super) struct ConcurrencyLimiter {\n     helper_thread: Option<HelperThread>,\n     state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n     available_token_condvar: Arc<Condvar>,\n+    finished: bool,\n }\n \n impl ConcurrencyLimiter {\n@@ -32,6 +33,7 @@ impl ConcurrencyLimiter {\n             helper_thread: Some(helper_thread),\n             state,\n             available_token_condvar: Arc::new(Condvar::new()),\n+            finished: false,\n         }\n     }\n \n@@ -56,16 +58,23 @@ impl ConcurrencyLimiter {\n         let mut state = self.state.lock().unwrap();\n         state.job_already_done();\n     }\n-}\n \n-impl Drop for ConcurrencyLimiter {\n-    fn drop(&mut self) {\n-        //\n+    pub(crate) fn finished(mut self) {\n         self.helper_thread.take();\n \n         // Assert that all jobs have finished\n         let state = Mutex::get_mut(Arc::get_mut(&mut self.state).unwrap()).unwrap();\n         state.assert_done();\n+\n+        self.finished = true;\n+    }\n+}\n+\n+impl Drop for ConcurrencyLimiter {\n+    fn drop(&mut self) {\n+        if !self.finished && !std::thread::panicking() {\n+            panic!(\"Forgot to call finished() on ConcurrencyLimiter\");\n+        }\n     }\n }\n "}, {"sha": "d4bc3543b2d1338ee0feea0db1543bba1a6ea0ca", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 39, "deletions": 48, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_span::DUMMY_SP;\n \n-use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n \n use crate::prelude::*;\n@@ -81,53 +80,46 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n     CValue::by_val(tls_ptr, layout)\n }\n \n-fn codegen_static_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    def_id: DefId,\n-    layout: TyAndLayout<'tcx>,\n-) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    if fx.clif_comments.enabled() {\n-        fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n-    }\n-    let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n-    assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n-    assert!(\n-        matches!(\n-            fx.bcx.func.global_values[local_data_id],\n-            GlobalValueData::Symbol { tls: false, .. }\n-        ),\n-        \"tls static referenced without Rvalue::ThreadLocalRef\"\n-    );\n-    CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n-}\n-\n-pub(crate) fn codegen_constant<'tcx>(\n+pub(crate) fn eval_mir_constant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n-) -> CValue<'tcx> {\n-    let (const_val, ty) = match fx.monomorphize(constant.literal) {\n-        ConstantKind::Ty(const_) => unreachable!(\"{:?}\", const_),\n-        ConstantKind::Unevaluated(mir::UnevaluatedConst { def, substs, promoted }, ty)\n+) -> (ConstValue<'tcx>, Ty<'tcx>) {\n+    let constant_kind = fx.monomorphize(constant.literal);\n+    let uv = match constant_kind {\n+        ConstantKind::Ty(const_) => match const_.kind() {\n+            ty::ConstKind::Unevaluated(uv) => uv.expand(),\n+            ty::ConstKind::Value(val) => {\n+                return (fx.tcx.valtree_to_const_val((const_.ty(), val)), const_.ty());\n+            }\n+            err => span_bug!(\n+                constant.span,\n+                \"encountered bad ConstKind after monomorphizing: {:?}\",\n+                err\n+            ),\n+        },\n+        ConstantKind::Unevaluated(mir::UnevaluatedConst { def, .. }, _)\n             if fx.tcx.is_static(def.did) =>\n         {\n-            assert!(substs.is_empty());\n-            assert!(promoted.is_none());\n-\n-            return codegen_static_ref(fx, def.did, fx.layout_of(ty)).to_cvalue(fx);\n-        }\n-        ConstantKind::Unevaluated(unevaluated, ty) => {\n-            match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n-                Ok(const_val) => (const_val, ty),\n-                Err(_) => {\n-                    span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n-                }\n-            }\n+            span_bug!(constant.span, \"MIR constant refers to static\");\n         }\n-        ConstantKind::Val(val, ty) => (val, ty),\n+        ConstantKind::Unevaluated(uv, _) => uv,\n+        ConstantKind::Val(val, _) => return (val, constant_kind.ty()),\n     };\n \n+    (\n+        fx.tcx.const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).unwrap_or_else(|_err| {\n+            span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n+        }),\n+        constant_kind.ty(),\n+    )\n+}\n+\n+pub(crate) fn codegen_constant_operand<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    constant: &Constant<'tcx>,\n+) -> CValue<'tcx> {\n+    let (const_val, ty) = eval_mir_constant(fx, constant);\n+\n     codegen_const_value(fx, const_val, ty)\n }\n \n@@ -244,7 +236,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n     }\n }\n \n-pub(crate) fn pointer_for_allocation<'tcx>(\n+fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: ConstAllocation<'tcx>,\n ) -> crate::pointer::Pointer {\n@@ -467,14 +459,13 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n     operand: &Operand<'tcx>,\n ) -> Option<ConstValue<'tcx>> {\n     match operand {\n-        Operand::Constant(const_) => match const_.literal {\n-            ConstantKind::Ty(const_) => fx\n-                .monomorphize(const_)\n-                .eval_for_mir(fx.tcx, ParamEnv::reveal_all())\n-                .try_to_value(fx.tcx),\n+        Operand::Constant(const_) => match fx.monomorphize(const_.literal) {\n+            ConstantKind::Ty(const_) => Some(\n+                const_.eval_for_mir(fx.tcx, ParamEnv::reveal_all()).try_to_value(fx.tcx).unwrap(),\n+            ),\n             ConstantKind::Val(val, _) => Some(val),\n             ConstantKind::Unevaluated(uv, _) => {\n-                fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).ok()\n+                Some(fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).unwrap())\n             }\n         },\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored"}, {"sha": "f873561c1713f37853821e3548ad6511a7981f58", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -106,7 +106,7 @@ impl OngoingCodegen {\n             }\n         }\n \n-        drop(self.concurrency_limiter);\n+        self.concurrency_limiter.finished();\n \n         (\n             CodegenResults {"}, {"sha": "6a430b5215e36d11b483213b5bb7e74c75425727", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -67,13 +67,12 @@ fn create_jit_module(\n     hotswap: bool,\n ) -> (JITModule, CodegenCx) {\n     let crate_info = CrateInfo::new(tcx, \"dummy_target_cpu\".to_string());\n-    let imported_symbols = load_imported_symbols_for_jit(tcx.sess, crate_info);\n \n     let isa = crate::build_isa(tcx.sess, backend_config);\n     let mut jit_builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());\n     jit_builder.hotswap(hotswap);\n     crate::compiler_builtins::register_functions_for_jit(&mut jit_builder);\n-    jit_builder.symbols(imported_symbols);\n+    jit_builder.symbol_lookup_fn(dep_symbol_lookup_fn(tcx.sess, crate_info));\n     jit_builder.symbol(\"__clif_jit_fn\", clif_jit_fn as *const u8);\n     let mut jit_module = JITModule::new(jit_builder);\n \n@@ -286,10 +285,10 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n     })\n }\n \n-fn load_imported_symbols_for_jit(\n+fn dep_symbol_lookup_fn(\n     sess: &Session,\n     crate_info: CrateInfo,\n-) -> Vec<(String, *const u8)> {\n+) -> Box<dyn Fn(&str) -> Option<*const u8>> {\n     use rustc_middle::middle::dependency_format::Linkage;\n \n     let mut dylib_paths = Vec::new();\n@@ -316,39 +315,23 @@ fn load_imported_symbols_for_jit(\n         }\n     }\n \n-    let mut imported_symbols = Vec::new();\n-    for path in dylib_paths {\n-        use object::{Object, ObjectSymbol};\n-        let lib = libloading::Library::new(&path).unwrap();\n-        let obj = std::fs::read(path).unwrap();\n-        let obj = object::File::parse(&*obj).unwrap();\n-        imported_symbols.extend(obj.dynamic_symbols().filter_map(|symbol| {\n-            let name = symbol.name().unwrap().to_string();\n-            if name.is_empty() || !symbol.is_global() || symbol.is_undefined() {\n-                return None;\n-            }\n-            if name.starts_with(\"rust_metadata_\") {\n-                // The metadata is part of a section that is not loaded by the dynamic linker in\n-                // case of cg_llvm.\n-                return None;\n-            }\n-            let dlsym_name = if cfg!(target_os = \"macos\") {\n-                // On macOS `dlsym` expects the name without leading `_`.\n-                assert!(name.starts_with('_'), \"{:?}\", name);\n-                &name[1..]\n-            } else {\n-                &name\n-            };\n-            let symbol: libloading::Symbol<'_, *const u8> =\n-                unsafe { lib.get(dlsym_name.as_bytes()) }.unwrap();\n-            Some((name, *symbol))\n-        }));\n-        std::mem::forget(lib)\n-    }\n+    let imported_dylibs = Box::leak(\n+        dylib_paths\n+            .into_iter()\n+            .map(|path| unsafe { libloading::Library::new(&path).unwrap() })\n+            .collect::<Box<[_]>>(),\n+    );\n \n     sess.abort_if_errors();\n \n-    imported_symbols\n+    Box::new(move |sym_name| {\n+        for dylib in &*imported_dylibs {\n+            if let Ok(sym) = unsafe { dylib.get::<*const u8>(sym_name.as_bytes()) } {\n+                return Some(*sym);\n+            }\n+        }\n+        None\n+    })\n }\n \n fn codegen_shim<'tcx>("}, {"sha": "3fcc84d39295f42328b1f1aa515ea7f0932ea543", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         }\n \n         // Used by stdarch\n-        if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+        if template[0] == InlineAsmTemplatePiece::String(\"mov \".to_string())\n             && matches!(\n                 template[1],\n                 InlineAsmTemplatePiece::Placeholder {\n@@ -36,24 +36,26 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     span: _\n                 }\n             )\n-            && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-            && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n-            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-            && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n+            && template[2] == InlineAsmTemplatePiece::String(\", rbx\".to_string())\n+            && template[3] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[4] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[6] == InlineAsmTemplatePiece::String(\"xchg \".to_string())\n             && matches!(\n-                template[6],\n+                template[7],\n                 InlineAsmTemplatePiece::Placeholder {\n                     operand_idx: 0,\n                     modifier: Some('r'),\n                     span: _\n                 }\n             )\n+            && template[8] == InlineAsmTemplatePiece::String(\", rbx\".to_string())\n         {\n             assert_eq!(operands.len(), 4);\n             let (leaf, eax_place) = match operands[1] {\n                 InlineAsmOperand::InOut {\n                     reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n-                    late: true,\n+                    late: _,\n                     ref in_value,\n                     out_place: Some(out_place),\n                 } => (\n@@ -68,15 +70,15 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                         InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n                             X86InlineAsmRegClass::reg,\n                         )),\n-                    late: true,\n+                    late: _,\n                     place: Some(place),\n                 } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n             let (sub_leaf, ecx_place) = match operands[2] {\n                 InlineAsmOperand::InOut {\n                     reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n-                    late: true,\n+                    late: _,\n                     ref in_value,\n                     out_place: Some(out_place),\n                 } => (\n@@ -88,7 +90,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             let edx_place = match operands[3] {\n                 InlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n-                    late: true,\n+                    late: _,\n                     place: Some(place),\n                 } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),"}, {"sha": "783d426c30bcc0d14cf94bb658b854e1e4b337fb", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -14,6 +14,10 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     target: Option<BasicBlock>,\n ) {\n     match intrinsic {\n+        \"llvm.x86.sse2.pause\" | \"llvm.aarch64.isb\" => {\n+            // Spin loop hint\n+        }\n+\n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n         \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\" => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n@@ -25,8 +29,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             let mut res = fx.bcx.ins().iconst(types::I32, 0);\n \n             for lane in (0..lane_count).rev() {\n-                let a_lane =\n-                    a.value_field(fx, mir::Field::new(lane.try_into().unwrap())).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n \n                 // cast float to int\n                 let a_lane = match lane_ty {"}, {"sha": "0302b843aa226345328a278674026baa33fda632", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -84,6 +84,30 @@ fn simd_for_each_lane<'tcx>(\n     }\n }\n \n+fn simd_pair_for_each_lane_typed<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    x: CValue<'tcx>,\n+    y: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: &dyn Fn(&mut FunctionCx<'_, '_, 'tcx>, CValue<'tcx>, CValue<'tcx>) -> CValue<'tcx>,\n+) {\n+    assert_eq!(x.layout(), y.layout());\n+    let layout = x.layout();\n+\n+    let (lane_count, _lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let (ret_lane_count, _ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane_idx in 0..lane_count {\n+        let x_lane = x.value_lane(fx, lane_idx);\n+        let y_lane = y.value_lane(fx, lane_idx);\n+\n+        let res_lane = f(fx, x_lane, y_lane);\n+\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n fn simd_pair_for_each_lane<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     x: CValue<'tcx>,\n@@ -504,37 +528,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 _ => unreachable!(),\n             };\n \n-            let signed = type_sign(lhs.layout().ty);\n-\n-            let checked_res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n-\n-            let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n-            let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n-\n-            let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n-\n-            let val = match (intrinsic, signed) {\n-                (sym::saturating_add, false) => fx.bcx.ins().select(has_overflow, max, val),\n-                (sym::saturating_sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n-                (sym::saturating_add, true) => {\n-                    let rhs = rhs.load_scalar(fx);\n-                    let rhs_ge_zero =\n-                        fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n-                    fx.bcx.ins().select(has_overflow, sat_val, val)\n-                }\n-                (sym::saturating_sub, true) => {\n-                    let rhs = rhs.load_scalar(fx);\n-                    let rhs_ge_zero =\n-                        fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n-                    fx.bcx.ins().select(has_overflow, sat_val, val)\n-                }\n-                _ => unreachable!(),\n-            };\n-\n-            let res = CValue::by_val(val, lhs.layout());\n-\n+            let res = crate::num::codegen_saturating_int_binop(fx, bin_op, lhs, rhs);\n             ret.write_cvalue(fx, res);\n         }\n         sym::rotate_left => {\n@@ -819,8 +813,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         sym::ptr_guaranteed_cmp => {\n             intrinsic_args!(fx, args => (a, b); intrinsic);\n \n-            let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b);\n-            ret.write_cvalue(fx, val);\n+            let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b).load_scalar(fx);\n+            ret.write_cvalue(fx, CValue::by_val(val, fx.layout_of(fx.tcx.types.u8)));\n         }\n \n         sym::caller_location => {\n@@ -1206,7 +1200,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             // FIXME once unwinding is supported, change this to actually catch panics\n             let f_sig = fx.bcx.func.import_signature(Signature {\n                 call_conv: fx.target_config.default_call_conv,\n-                params: vec![AbiParam::new(fx.bcx.func.dfg.value_type(data))],\n+                params: vec![AbiParam::new(pointer_ty(fx.tcx))],\n                 returns: vec![],\n             });\n "}, {"sha": "51fce8c854bdb5307149680f288fa590ed8a8b53", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 125, "deletions": 3, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::Symbol;\n+use rustc_target::abi::Endian;\n \n use super::*;\n use crate::prelude::*;\n@@ -26,7 +27,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     span: Span,\n ) {\n     match intrinsic {\n-        sym::simd_cast => {\n+        sym::simd_as | sym::simd_cast => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n \n             if !a.layout().ty.is_simd() {\n@@ -162,6 +163,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     }\n                 }\n             } else {\n+                // FIXME remove this case\n                 intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap()\n             };\n \n@@ -650,8 +652,128 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n         }\n \n-        // simd_saturating_*\n-        // simd_bitmask\n+        sym::simd_select_bitmask => {\n+            intrinsic_args!(fx, args => (m, a, b); intrinsic);\n+\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n+            assert_eq!(a.layout(), b.layout());\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_layout = fx.layout_of(lane_ty);\n+\n+            let m = m.load_scalar(fx);\n+\n+            for lane in 0..lane_count {\n+                let m_lane = fx.bcx.ins().ushr_imm(m, u64::from(lane) as i64);\n+                let m_lane = fx.bcx.ins().band_imm(m_lane, 1);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+\n+                let m_lane = fx.bcx.ins().icmp_imm(IntCC::Equal, m_lane, 0);\n+                let res_lane =\n+                    CValue::by_val(fx.bcx.ins().select(m_lane, b_lane, a_lane), lane_layout);\n+\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n+            }\n+        }\n+\n+        sym::simd_bitmask => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_clif_ty = fx.clif_type(lane_ty).unwrap();\n+\n+            // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+            // vector mask and returns the most significant bit (MSB) of each lane in the form\n+            // of either:\n+            // * an unsigned integer\n+            // * an array of `u8`\n+            // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+            //\n+            // The bit order of the result depends on the byte endianness, LSB-first for little\n+            // endian and MSB-first for big endian.\n+            let expected_int_bits = lane_count.max(8);\n+            let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+            match lane_ty.kind() {\n+                ty::Int(_) | ty::Uint(_) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            vector argument `{}`'s element type `{}`, expected integer element \\\n+                            type\",\n+                            a.layout().ty,\n+                            lane_ty\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res_type =\n+                Type::int_with_byte_size(u16::try_from(expected_bytes).unwrap()).unwrap();\n+            let mut res = fx.bcx.ins().iconst(res_type, 0);\n+\n+            let lanes = match fx.tcx.sess.target.endian {\n+                Endian::Big => Box::new(0..lane_count) as Box<dyn Iterator<Item = u64>>,\n+                Endian::Little => Box::new((0..lane_count).rev()) as Box<dyn Iterator<Item = u64>>,\n+            };\n+            for lane in lanes {\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_clif_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, res_type, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            match ret.layout().ty.kind() {\n+                ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {}\n+                ty::Array(elem, len)\n+                    if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                        && len.try_eval_usize(fx.tcx, ty::ParamEnv::reveal_all())\n+                            == Some(expected_bytes) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                            ret.layout().ty,\n+                            expected_int_bits,\n+                            expected_bytes\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res = CValue::by_val(res, ret.layout());\n+            ret.write_cvalue(fx, res);\n+        }\n+\n+        sym::simd_saturating_add | sym::simd_saturating_sub => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            let bin_op = match intrinsic {\n+                sym::simd_saturating_add => BinOp::Add,\n+                sym::simd_saturating_sub => BinOp::Sub,\n+                _ => unreachable!(),\n+            };\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane_typed(fx, x, y, ret, &|fx, x_lane, y_lane| {\n+                crate::num::codegen_saturating_int_binop(fx, bin_op, x_lane, y_lane)\n+            });\n+        }\n+\n+        // simd_arith_offset\n         // simd_scatter\n         // simd_gather\n         _ => {"}, {"sha": "629d79d501240217d17ac3a6294ff338ed29300c", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -96,8 +96,8 @@ mod prelude {\n     pub(crate) use cranelift_codegen::ir::function::Function;\n     pub(crate) use cranelift_codegen::ir::types;\n     pub(crate) use cranelift_codegen::ir::{\n-        AbiParam, Block, ExternalName, FuncRef, Inst, InstBuilder, MemFlags, Signature, SourceLoc,\n-        StackSlot, StackSlotData, StackSlotKind, TrapCode, Type, Value,\n+        AbiParam, Block, FuncRef, Inst, InstBuilder, MemFlags, Signature, SourceLoc, StackSlot,\n+        StackSlotData, StackSlotKind, TrapCode, Type, Value,\n     };\n     pub(crate) use cranelift_codegen::isa::{self, CallConv};\n     pub(crate) use cranelift_codegen::Context;\n@@ -251,7 +251,6 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n \n     let mut flags_builder = settings::builder();\n     flags_builder.enable(\"is_pic\").unwrap();\n-    flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     let enable_verifier = if backend_config.enable_verifier { \"true\" } else { \"false\" };\n     flags_builder.set(\"enable_verifier\", enable_verifier).unwrap();\n     flags_builder.set(\"regalloc_checker\", enable_verifier).unwrap();\n@@ -279,6 +278,15 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n     }\n \n+    if target_triple.architecture == target_lexicon::Architecture::X86_64 {\n+        // Windows depends on stack probes to grow the committed part of the stack\n+        flags_builder.enable(\"enable_probestack\").unwrap();\n+        flags_builder.set(\"probestack_strategy\", \"inline\").unwrap();\n+    } else {\n+        // __cranelift_probestack is not provided and inline stack probes are only supported on x86_64\n+        flags_builder.set(\"enable_probestack\", \"false\").unwrap();\n+    }\n+\n     let flags = settings::Flags::new(flags_builder);\n \n     let isa_builder = match sess.opts.cg.target_cpu.as_deref() {"}, {"sha": "cae6312a607351d93dc5101562c1760dbdb392a5", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         let main_func_id = m.declare_function(main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n-        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n+        ctx.func.signature = cmain_sig;\n         {\n             let mut func_ctx = FunctionBuilderContext::new();\n             let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);"}, {"sha": "ecbab408ded972889b6cbca8840daee8c2e837f4", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -150,18 +150,12 @@ pub(crate) fn codegen_int_binop<'tcx>(\n         BinOp::BitXor => b.bxor(lhs, rhs),\n         BinOp::BitAnd => b.band(lhs, rhs),\n         BinOp::BitOr => b.bor(lhs, rhs),\n-        BinOp::Shl => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            fx.bcx.ins().ishl(lhs, actual_shift)\n-        }\n+        BinOp::Shl => b.ishl(lhs, rhs),\n         BinOp::Shr => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n             if signed {\n-                fx.bcx.ins().sshr(lhs, actual_shift)\n+                b.sshr(lhs, rhs)\n             } else {\n-                fx.bcx.ins().ushr(lhs, actual_shift)\n+                b.ushr(lhs, rhs)\n             }\n         }\n         // Compare binops handles by `codegen_binop`.\n@@ -279,22 +273,15 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             }\n         }\n         BinOp::Shl => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let masked_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let val = fx.bcx.ins().ishl(lhs, masked_shift);\n+            let val = fx.bcx.ins().ishl(lhs, rhs);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n             let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let masked_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let val = if !signed {\n-                fx.bcx.ins().ushr(lhs, masked_shift)\n-            } else {\n-                fx.bcx.ins().sshr(lhs, masked_shift)\n-            };\n+            let val =\n+                if !signed { fx.bcx.ins().ushr(lhs, rhs) } else { fx.bcx.ins().sshr(lhs, rhs) };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n             let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n@@ -309,6 +296,42 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n+pub(crate) fn codegen_saturating_int_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    assert_eq!(lhs.layout().ty, rhs.layout().ty);\n+\n+    let signed = type_sign(lhs.layout().ty);\n+    let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n+    let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n+\n+    let checked_res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n+    let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n+\n+    let val = match (bin_op, signed) {\n+        (BinOp::Add, false) => fx.bcx.ins().select(has_overflow, max, val),\n+        (BinOp::Sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n+        (BinOp::Add, true) => {\n+            let rhs = rhs.load_scalar(fx);\n+            let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+            let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n+            fx.bcx.ins().select(has_overflow, sat_val, val)\n+        }\n+        (BinOp::Sub, true) => {\n+            let rhs = rhs.load_scalar(fx);\n+            let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+            let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n+            fx.bcx.ins().select(has_overflow, sat_val, val)\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    CValue::by_val(val, lhs.layout())\n+}\n+\n pub(crate) fn codegen_float_binop<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,"}, {"sha": "9c88f7dbcda33e424db7b163a8f9d3574699543d", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -25,7 +25,12 @@ pub(crate) fn unsized_info<'tcx>(\n             .bcx\n             .ins()\n             .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n-        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+        (\n+            &ty::Dynamic(ref data_a, _, src_dyn_kind),\n+            &ty::Dynamic(ref data_b, _, target_dyn_kind),\n+        ) => {\n+            assert_eq!(src_dyn_kind, target_dyn_kind);\n+\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -101,6 +106,21 @@ fn unsize_ptr<'tcx>(\n     }\n }\n \n+/// Coerces `src` to `dst_ty` which is guaranteed to be a `dyn*` type.\n+pub(crate) fn cast_to_dyn_star<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    src: Value,\n+    src_ty_and_layout: TyAndLayout<'tcx>,\n+    dst_ty: Ty<'tcx>,\n+    old_info: Option<Value>,\n+) -> (Value, Value) {\n+    assert!(\n+        matches!(dst_ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n+        \"destination type must be a dyn*\"\n+    );\n+    (src, unsized_info(fx, src_ty_and_layout.ty, dst_ty, old_info))\n+}\n+\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub(crate) fn coerce_unsized_into<'tcx>(\n@@ -147,6 +167,24 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n     }\n }\n \n+pub(crate) fn coerce_dyn_star<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    src: CValue<'tcx>,\n+    dst: CPlace<'tcx>,\n+) {\n+    let (data, extra) = if let ty::Dynamic(_, _, ty::DynStar) = src.layout().ty.kind() {\n+        let (data, vtable) = src.load_scalar_pair(fx);\n+        (data, Some(vtable))\n+    } else {\n+        let data = src.load_scalar(fx);\n+        (data, None)\n+    };\n+\n+    let (data, vtable) = cast_to_dyn_star(fx, data, src.layout(), dst.layout().ty, extra);\n+\n+    dst.write_cvalue(fx, CValue::by_val_pair(data, vtable, dst.layout()));\n+}\n+\n // Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n \n pub(crate) fn size_and_align_of_dst<'tcx>("}, {"sha": "c3dfbd37279f9eca6b984156b9d1500a3017ccd4", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -107,6 +107,50 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n+    // FIXME remove\n+    // Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n+    // vtable pointer.\n+    pub(crate) fn dyn_star_force_data_on_stack(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    ) -> (Value, Value) {\n+        assert!(self.1.ty.is_dyn_star());\n+\n+        match self.0 {\n+            CValueInner::ByRef(ptr, None) => {\n+                let (a_scalar, b_scalar) = match self.1.abi {\n+                    Abi::ScalarPair(a, b) => (a, b),\n+                    _ => unreachable!(\"dyn_star_force_data_on_stack({:?})\", self),\n+                };\n+                let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n+                let clif_ty2 = scalar_to_clif_type(fx.tcx, b_scalar);\n+                let mut flags = MemFlags::new();\n+                flags.set_notrap();\n+                let vtable = ptr.offset(fx, b_offset).load(fx, clif_ty2, flags);\n+                (ptr.get_addr(fx), vtable)\n+            }\n+            CValueInner::ByValPair(data, vtable) => {\n+                let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+                    // specify stack slot alignment.\n+                    size: (u32::try_from(fx.target_config.pointer_type().bytes()).unwrap() + 15)\n+                        / 16\n+                        * 16,\n+                });\n+                let data_ptr = Pointer::stack_slot(stack_slot);\n+                let mut flags = MemFlags::new();\n+                flags.set_notrap();\n+                data_ptr.store(fx, data, flags);\n+\n+                (data_ptr.get_addr(fx), vtable)\n+            }\n+            CValueInner::ByRef(_, Some(_)) | CValueInner::ByVal(_) => {\n+                unreachable!(\"dyn_star_force_data_on_stack({:?})\", self)\n+            }\n+        }\n+    }\n+\n     pub(crate) fn try_to_ptr(self) -> Option<(Pointer, Option<Value>)> {\n         match self.0 {\n             CValueInner::ByRef(ptr, meta) => Some((ptr, meta)),\n@@ -236,6 +280,10 @@ impl<'tcx> CValue<'tcx> {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n+    pub(crate) fn coerce_dyn_star(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n+        crate::unsize::coerce_dyn_star(fx, self, dest);\n+    }\n+\n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "f04fb82de8c81f17db8f21f0e48c8d5fcffe5d8a", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e54a13f18bf2873f12d556fb05bb60f2a7f75bfa/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=e54a13f18bf2873f12d556fb05bb60f2a7f75bfa", "patch": "@@ -45,12 +45,26 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     idx: usize,\n-) -> (Value, Value) {\n-    let (ptr, vtable) = if let Abi::ScalarPair(_, _) = arg.layout().abi {\n-        arg.load_scalar_pair(fx)\n-    } else {\n-        let (ptr, vtable) = arg.try_to_ptr().unwrap();\n-        (ptr.get_addr(fx), vtable.unwrap())\n+) -> (Pointer, Value) {\n+    let (ptr, vtable) = 'block: {\n+        if let ty::Ref(_, ty, _) = arg.layout().ty.kind() {\n+            if ty.is_dyn_star() {\n+                let inner_layout = fx.layout_of(arg.layout().ty.builtin_deref(true).unwrap().ty);\n+                let dyn_star = CPlace::for_ptr(Pointer::new(arg.load_scalar(fx)), inner_layout);\n+                let ptr = dyn_star.place_field(fx, mir::Field::new(0)).to_ptr();\n+                let vtable =\n+                    dyn_star.place_field(fx, mir::Field::new(1)).to_cvalue(fx).load_scalar(fx);\n+                break 'block (ptr, vtable);\n+            }\n+        }\n+\n+        if let Abi::ScalarPair(_, _) = arg.layout().abi {\n+            let (ptr, vtable) = arg.load_scalar_pair(fx);\n+            (Pointer::new(ptr), vtable)\n+        } else {\n+            let (ptr, vtable) = arg.try_to_ptr().unwrap();\n+            (ptr, vtable.unwrap())\n+        }\n     };\n \n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();"}]}