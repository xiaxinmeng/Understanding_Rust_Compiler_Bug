{"sha": "5393a2995bcea9a927c23d88a921c55bea886771", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzOTNhMjk5NWJjZWE5YTkyN2MyM2Q4OGE5MjFjNTViZWE4ODY3NzE=", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2020-05-16T17:44:31Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2020-06-14T23:56:21Z"}, "message": "Move convert_place_derefs_to_mutable out from check/method/confirm.rs\n\nThis can live inside FnCtxt rather than ConfirmContext, and would be\nuseful for other operations as well.", "tree": {"sha": "c8b8f290ab7cdf52d91467511bda2ae810c8e1e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8b8f290ab7cdf52d91467511bda2ae810c8e1e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5393a2995bcea9a927c23d88a921c55bea886771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5393a2995bcea9a927c23d88a921c55bea886771", "html_url": "https://github.com/rust-lang/rust/commit/5393a2995bcea9a927c23d88a921c55bea886771", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5393a2995bcea9a927c23d88a921c55bea886771/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06e47688bf15d0215edbe05b21603062f6d2eb5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/06e47688bf15d0215edbe05b21603062f6d2eb5d", "html_url": "https://github.com/rust-lang/rust/commit/06e47688bf15d0215edbe05b21603062f6d2eb5d"}], "stats": {"total": 305, "additions": 157, "deletions": 148}, "files": [{"sha": "867dacede6e44687b8b188c63259ba33d030d9fe", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 148, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/5393a2995bcea9a927c23d88a921c55bea886771/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5393a2995bcea9a927c23d88a921c55bea886771/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5393a2995bcea9a927c23d88a921c55bea886771", "patch": "@@ -1,12 +1,12 @@\n use super::{probe, MethodCallee};\n \n use crate::astconv::AstConv;\n-use crate::check::{callee, FnCtxt, Needs, PlaceOp};\n+use crate::check::{callee, FnCtxt, Needs};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n use rustc_hir as hir;\n use rustc_infer::infer::{self, InferOk};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -121,7 +121,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         let callee = MethodCallee { def_id: pick.item.def_id, substs: all_substs, sig: method_sig };\n \n         if let Some(hir::Mutability::Mut) = pick.autoref {\n-            self.convert_place_derefs_to_mutable();\n+            self.convert_place_derefs_to_mutable(self.self_expr);\n         }\n \n         ConfirmResult { callee, illegal_sized_bound }\n@@ -416,151 +416,6 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self.register_wf_obligation(fty.into(), self.span, traits::MiscObligation);\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // RECONCILIATION\n-\n-    /// When we select a method with a mutable autoref, we have to go convert any\n-    /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n-    /// respectively.\n-    fn convert_place_derefs_to_mutable(&self) {\n-        // Gather up expressions we want to munge.\n-        let mut exprs = vec![self.self_expr];\n-\n-        loop {\n-            match exprs.last().unwrap().kind {\n-                hir::ExprKind::Field(ref expr, _)\n-                | hir::ExprKind::Index(ref expr, _)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n-                _ => break,\n-            }\n-        }\n-\n-        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n-\n-        // Fix up autoderefs and derefs.\n-        for (i, &expr) in exprs.iter().rev().enumerate() {\n-            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n-\n-            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n-            // overloaded place ops, and will be fixed by them in order to get\n-            // the correct region.\n-            let mut source = self.node_ty(expr.hir_id);\n-            // Do not mutate adjustments in place, but rather take them,\n-            // and replace them after mutating them, to avoid having the\n-            // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments =\n-                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n-            if let Some(mut adjustments) = previous_adjustments {\n-                let needs = Needs::MutPlace;\n-                for adjustment in &mut adjustments {\n-                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n-                                *deref = OverloadedDeref { region, mutbl };\n-                            }\n-                        }\n-                    }\n-                    source = adjustment.target;\n-                }\n-                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n-            }\n-\n-            match expr.kind {\n-                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n-                    // We need to get the final type in case dereferences were needed for the trait\n-                    // to apply (#72002).\n-                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n-                    self.convert_place_op_to_mutable(\n-                        PlaceOp::Index,\n-                        expr,\n-                        base_expr,\n-                        &[index_expr_ty],\n-                    );\n-                }\n-                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n-                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    fn convert_place_op_to_mutable(\n-        &self,\n-        op: PlaceOp,\n-        expr: &hir::Expr<'_>,\n-        base_expr: &hir::Expr<'_>,\n-        arg_tys: &[Ty<'tcx>],\n-    ) {\n-        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n-        if !self.tables.borrow().is_method_call(expr) {\n-            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n-            return;\n-        }\n-\n-        let base_ty = self\n-            .tables\n-            .borrow()\n-            .expr_adjustments(base_expr)\n-            .last()\n-            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n-        let base_ty = self.resolve_vars_if_possible(&base_ty);\n-\n-        // Need to deref because overloaded place ops take self by-reference.\n-        let base_ty =\n-            base_ty.builtin_deref(false).expect(\"place op takes something that is not a ref\").ty;\n-\n-        let method = self.try_overloaded_place_op(expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n-        let method = match method {\n-            Some(ok) => self.register_infer_ok_obligations(ok),\n-            None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\"),\n-        };\n-        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.hir_id, method);\n-\n-        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind {\n-            (r, mutbl)\n-        } else {\n-            span_bug!(expr.span, \"input to place op is not a ref?\");\n-        };\n-\n-        // Convert the autoref in the base expr to mutable with the correct\n-        // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.hir_id);\n-        if let Some(adjustments) =\n-            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n-        {\n-            let mut source = base_expr_ty;\n-            for adjustment in &mut adjustments[..] {\n-                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n-                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded operators.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n-                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n-                    adjustment.target =\n-                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n-                }\n-                source = adjustment.target;\n-            }\n-\n-            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n-\n-            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n-                adjustments[..]\n-            {\n-                *target = method.sig.inputs()[0];\n-            }\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n "}, {"sha": "1e4085f02676841a5fe39a53304705f2261a5a33", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5393a2995bcea9a927c23d88a921c55bea886771/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5393a2995bcea9a927c23d88a921c55bea886771/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5393a2995bcea9a927c23d88a921c55bea886771", "patch": "@@ -79,6 +79,7 @@ pub mod intrinsic;\n pub mod method;\n mod op;\n mod pat;\n+mod reconciliation;\n mod regionck;\n mod upvar;\n mod wfcheck;"}, {"sha": "b05155ae2aedd43e3152924385b1c35d241a8742", "filename": "src/librustc_typeck/check/reconciliation.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5393a2995bcea9a927c23d88a921c55bea886771/src%2Flibrustc_typeck%2Fcheck%2Freconciliation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5393a2995bcea9a927c23d88a921c55bea886771/src%2Flibrustc_typeck%2Fcheck%2Freconciliation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Freconciliation.rs?ref=5393a2995bcea9a927c23d88a921c55bea886771", "patch": "@@ -0,0 +1,153 @@\n+use crate::check::{FnCtxt, Needs, PlaceOp};\n+use rustc_hir as hir;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n+use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::{self, Ty};\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`\n+    /// into `DerefMut` and `IndexMut` respectively.\n+    ///\n+    /// This is a second pass of typechecking derefs/indices. We need this we do not\n+    /// always know whether a place needs to be mutable or not in the first pass.\n+    /// This happens whether there is an implicit mutable reborrow, e.g. when the type\n+    /// is used as the receiver of a method call.\n+    pub fn convert_place_derefs_to_mutable(&self, expr: &hir::Expr<'_>) {\n+        // Gather up expressions we want to munge.\n+        let mut exprs = vec![expr];\n+\n+        loop {\n+            match exprs.last().unwrap().kind {\n+                hir::ExprKind::Field(ref expr, _)\n+                | hir::ExprKind::Index(ref expr, _)\n+                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n+                _ => break,\n+            }\n+        }\n+\n+        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n+            // Fix up the autoderefs. Autorefs can only occur immediately preceding\n+            // overloaded place ops, and will be fixed by them in order to get\n+            // the correct region.\n+            let mut source = self.node_ty(expr.hir_id);\n+            // Do not mutate adjustments in place, but rather take them,\n+            // and replace them after mutating them, to avoid having the\n+            // tables borrowed during (`deref_mut`) method resolution.\n+            let previous_adjustments =\n+                self.tables.borrow_mut().adjustments_mut().remove(expr.hir_id);\n+            if let Some(mut adjustments) = previous_adjustments {\n+                let needs = Needs::MutPlace;\n+                for adjustment in &mut adjustments {\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n+                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n+                                *deref = OverloadedDeref { region, mutbl };\n+                            }\n+                        }\n+                    }\n+                    source = adjustment.target;\n+                }\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n+            }\n+\n+            match expr.kind {\n+                hir::ExprKind::Index(ref base_expr, ref index_expr) => {\n+                    // We need to get the final type in case dereferences were needed for the trait\n+                    // to apply (#72002).\n+                    let index_expr_ty = self.tables.borrow().expr_ty_adjusted(index_expr);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Index,\n+                        expr,\n+                        base_expr,\n+                        &[index_expr_ty],\n+                    );\n+                }\n+                hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base_expr) => {\n+                    self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr, &[]);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn convert_place_op_to_mutable(\n+        &self,\n+        op: PlaceOp,\n+        expr: &hir::Expr<'_>,\n+        base_expr: &hir::Expr<'_>,\n+        arg_tys: &[Ty<'tcx>],\n+    ) {\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\", op, expr, base_expr, arg_tys);\n+        if !self.tables.borrow().is_method_call(expr) {\n+            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n+            return;\n+        }\n+\n+        let base_ty = self\n+            .tables\n+            .borrow()\n+            .expr_adjustments(base_expr)\n+            .last()\n+            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n+        let base_ty = self.resolve_vars_if_possible(&base_ty);\n+\n+        // Need to deref because overloaded place ops take self by-reference.\n+        let base_ty =\n+            base_ty.builtin_deref(false).expect(\"place op takes something that is not a ref\").ty;\n+\n+        let method = self.try_overloaded_place_op(expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n+        let method = match method {\n+            Some(ok) => self.register_infer_ok_obligations(ok),\n+            None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\"),\n+        };\n+        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n+        self.write_method_call(expr.hir_id, method);\n+\n+        let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind {\n+            (r, mutbl)\n+        } else {\n+            span_bug!(expr.span, \"input to place op is not a ref?\");\n+        };\n+\n+        // Convert the autoref in the base expr to mutable with the correct\n+        // region and mutability.\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) =\n+            self.tables.borrow_mut().adjustments_mut().get_mut(base_expr.hir_id)\n+        {\n+            let mut source = base_expr_ty;\n+            for adjustment in &mut adjustments[..] {\n+                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n+                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    let mutbl = match mutbl {\n+                        hir::Mutability::Not => AutoBorrowMutability::Not,\n+                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n+                            // For initial two-phase borrow\n+                            // deployment, conservatively omit\n+                            // overloaded operators.\n+                            allow_two_phase_borrow: AllowTwoPhase::No,\n+                        },\n+                    };\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n+                    adjustment.target =\n+                        self.tcx.mk_ref(region, ty::TypeAndMut { ty: source, mutbl: mutbl.into() });\n+                }\n+                source = adjustment.target;\n+            }\n+\n+            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n+\n+            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n+                adjustments[..]\n+            {\n+                *target = method.sig.inputs()[0];\n+            }\n+        }\n+    }\n+}"}]}