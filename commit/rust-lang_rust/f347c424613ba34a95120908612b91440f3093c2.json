{"sha": "f347c424613ba34a95120908612b91440f3093c2", "node_id": "C_kwDOAAsO6NoAKGYzNDdjNDI0NjEzYmEzNGE5NTEyMDkwODYxMmI5MTQ0MGYzMDkzYzI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-16T04:05:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-16T04:05:56Z"}, "message": "Rollup merge of #100384 - ridwanabdillahi:instr_profile_output, r=wesleywiser\n\nAdd support for generating unique profraw files by default when using `-C instrument-coverage`\n\nCurrently, enabling the rustc flag `-C instrument-coverage` instruments the given crate and by default uses the naming scheme `default.profraw` for any instrumented profile files generated during the execution of a binary linked against this crate. This leads to multiple binaries being executed overwriting one another and causing only the last executable run to contain actual coverage results.\n\nThis can be overridden by manually setting the environment variable `LLVM_PROFILE_FILE` to use a unique naming scheme.\n\nThis PR adds a change to add support for a reasonable default for rustc to use when enabling coverage instrumentation similar to how the Rust compiler treats generating these same `profraw` files when PGO is enabled.\n\nThe new naming scheme is set to `default_%m_%p.profraw` to ensure the uniqueness of each file being generated using [LLVMs special pattern strings](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#running-the-instrumented-program).\n\nToday the compiler sets the default for PGO `profraw` files to `default_%m.profraw` to ensure a unique file for each run. The same can be done for the instrumented profile files generated via the `-C instrument-coverage` flag as well which LLVM has API support for.\n\nLinked Issue: https://github.com/rust-lang/rust/issues/100381\n\nr? `@wesleywiser`", "tree": {"sha": "26d3cb1852f8793d214f40b8876d8e260f0313fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26d3cb1852f8793d214f40b8876d8e260f0313fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f347c424613ba34a95120908612b91440f3093c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi+xekCRBK7hj4Ov3rIwAAOzIIABH5A9eMKOjTkyme8sMajYtA\nnLRciyR3P7uZt00+Hgr8IFt3obEg8+Bb27fM61AdJAcCeN0xZ4CviNuPH31lzJbN\nTJo8leUeJvvI7I7GRBc5SSDnU03Nfy08WaxeRI4zou5DYTKrf61/zklIHQQIyb9U\nhN+/SR5VlF+7ZGaa39GR+6cpf/PX6026AciLBX0vjbCVb1PLYVhXjt3tjymXUyab\nkiFddfcQpODKIlgZaeFZBiJn4C3E7sz+KntnEihwaEaVv8GjJJQUuyM+ALPOvqUZ\nyvOv8OgC5qLPJJyV09q6yXweVx+2agn65TNVPgu7mI6QzLUdQvILw9CNUAYyeLM=\n=7KqW\n-----END PGP SIGNATURE-----\n", "payload": "tree 26d3cb1852f8793d214f40b8876d8e260f0313fb\nparent 836f706d9a9234893e70053f36fda99cb19a5fe6\nparent 7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1660622756 +0200\ncommitter GitHub <noreply@github.com> 1660622756 +0200\n\nRollup merge of #100384 - ridwanabdillahi:instr_profile_output, r=wesleywiser\n\nAdd support for generating unique profraw files by default when using `-C instrument-coverage`\n\nCurrently, enabling the rustc flag `-C instrument-coverage` instruments the given crate and by default uses the naming scheme `default.profraw` for any instrumented profile files generated during the execution of a binary linked against this crate. This leads to multiple binaries being executed overwriting one another and causing only the last executable run to contain actual coverage results.\n\nThis can be overridden by manually setting the environment variable `LLVM_PROFILE_FILE` to use a unique naming scheme.\n\nThis PR adds a change to add support for a reasonable default for rustc to use when enabling coverage instrumentation similar to how the Rust compiler treats generating these same `profraw` files when PGO is enabled.\n\nThe new naming scheme is set to `default_%m_%p.profraw` to ensure the uniqueness of each file being generated using [LLVMs special pattern strings](https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#running-the-instrumented-program).\n\nToday the compiler sets the default for PGO `profraw` files to `default_%m.profraw` to ensure a unique file for each run. The same can be done for the instrumented profile files generated via the `-C instrument-coverage` flag as well which LLVM has API support for.\n\nLinked Issue: https://github.com/rust-lang/rust/issues/100381\n\nr? `@wesleywiser`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f347c424613ba34a95120908612b91440f3093c2", "html_url": "https://github.com/rust-lang/rust/commit/f347c424613ba34a95120908612b91440f3093c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f347c424613ba34a95120908612b91440f3093c2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "836f706d9a9234893e70053f36fda99cb19a5fe6", "url": "https://api.github.com/repos/rust-lang/rust/commits/836f706d9a9234893e70053f36fda99cb19a5fe6", "html_url": "https://github.com/rust-lang/rust/commit/836f706d9a9234893e70053f36fda99cb19a5fe6"}, {"sha": "7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1", "html_url": "https://github.com/rust-lang/rust/commit/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1"}], "stats": {"total": 64, "additions": 54, "deletions": 10}, "files": [{"sha": "0913715b3c0b8a6742c34cf8b5599ac7bb4d8337", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f347c424613ba34a95120908612b91440f3093c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f347c424613ba34a95120908612b91440f3093c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=f347c424613ba34a95120908612b91440f3093c2", "patch": "@@ -423,6 +423,14 @@ fn get_pgo_sample_use_path(config: &ModuleConfig) -> Option<CString> {\n         .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap())\n }\n \n+fn get_instr_profile_output_path(config: &ModuleConfig) -> Option<CString> {\n+    if config.instrument_coverage {\n+        Some(CString::new(\"default_%m_%p.profraw\").unwrap())\n+    } else {\n+        None\n+    }\n+}\n+\n pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n@@ -438,6 +446,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     let pgo_use_path = get_pgo_use_path(config);\n     let pgo_sample_use_path = get_pgo_sample_use_path(config);\n     let is_lto = opt_stage == llvm::OptStage::ThinLTO || opt_stage == llvm::OptStage::FatLTO;\n+    let instr_profile_output_path = get_instr_profile_output_path(config);\n     // Sanitizer instrumentation is only inserted during the pre-link optimization stage.\n     let sanitizer_options = if !is_lto {\n         Some(llvm::SanitizerOptions {\n@@ -488,6 +497,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n         pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         config.instrument_coverage,\n+        instr_profile_output_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         config.instrument_gcov,\n         pgo_sample_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n         config.debug_info_for_profiling,"}, {"sha": "d676ea35090d268515e7f9ffa136d7d8a31f7748", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f347c424613ba34a95120908612b91440f3093c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f347c424613ba34a95120908612b91440f3093c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=f347c424613ba34a95120908612b91440f3093c2", "patch": "@@ -2360,6 +2360,7 @@ extern \"C\" {\n         PGOGenPath: *const c_char,\n         PGOUsePath: *const c_char,\n         InstrumentCoverage: bool,\n+        InstrProfileOutput: *const c_char,\n         InstrumentGCOV: bool,\n         PGOSampleUsePath: *const c_char,\n         DebugInfoForProfiling: bool,"}, {"sha": "bdf2a8525073064b95421f935bfe3ba20b3298cb", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f347c424613ba34a95120908612b91440f3093c2/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f347c424613ba34a95120908612b91440f3093c2/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=f347c424613ba34a95120908612b91440f3093c2", "patch": "@@ -822,7 +822,8 @@ LLVMRustOptimizeWithNewPassManager(\n     bool DisableSimplifyLibCalls, bool EmitLifetimeMarkers,\n     LLVMRustSanitizerOptions *SanitizerOptions,\n     const char *PGOGenPath, const char *PGOUsePath,\n-    bool InstrumentCoverage, bool InstrumentGCOV,\n+    bool InstrumentCoverage, const char *InstrProfileOutput,\n+    bool InstrumentGCOV,\n     const char *PGOSampleUsePath, bool DebugInfoForProfiling,\n     void* LlvmSelfProfiler,\n     LLVMRustSelfProfileBeforePassCallback BeforePassCallback,\n@@ -922,8 +923,11 @@ LLVMRustOptimizeWithNewPassManager(\n \n   if (InstrumentCoverage) {\n     PipelineStartEPCallbacks.push_back(\n-      [](ModulePassManager &MPM, OptimizationLevel Level) {\n+      [InstrProfileOutput](ModulePassManager &MPM, OptimizationLevel Level) {\n         InstrProfOptions Options;\n+        if (InstrProfileOutput) {\n+          Options.InstrProfileOutput = InstrProfileOutput;\n+        }\n         MPM.addPass(InstrProfiling(Options, false));\n       }\n     );"}, {"sha": "38fd5c96997631d1ce77b3348e88b7754a8ca63b", "filename": "src/doc/rustc/src/instrument-coverage.md", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f347c424613ba34a95120908612b91440f3093c2/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/f347c424613ba34a95120908612b91440f3093c2/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md?ref=f347c424613ba34a95120908612b91440f3093c2", "patch": "@@ -97,7 +97,17 @@ $ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n }\n ```\n \n-After running this program, a new file, `default.profraw`, should be in the current working directory. It's often preferable to set a specific file name or path. You can change the output file using the environment variable `LLVM_PROFILE_FILE`:\n+After running this program, a new file named like `default_11699812450447639123_0_20944` should be in the current working directory.\n+A new, unique file name will be generated each time the program is run to avoid overwriting previous data.\n+\n+```shell\n+$ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n+...\n+$ ls default_*.profraw\n+default_11699812450447639123_0_20944.profraw\n+```\n+\n+You can also set a specific file name or path for the generated `.profraw` files by using the environment variable `LLVM_PROFILE_FILE`:\n \n ```shell\n $ echo \"{some: 'thing'}\" \\\n@@ -115,6 +125,9 @@ If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing\n -   `%Nm` - the instrumented binary\u2019s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. `N` must be between `1` and `9`, and defaults to `1` if omitted (with simply `%m`).\n -   `%c` - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.\n \n+In the first example above, the value `11699812450447639123_0` in the generated filename is the instrumented binary's signature,\n+which replaced the `%m` pattern and the value `20944` is the process ID of the binary being executed.\n+\n ## Installing LLVM coverage tools\n \n LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 12 or higher, and processing the *raw* data may require exactly the LLVM version used by the compiler. (`llvm-cov --version` typically shows the tool's LLVM version number, and `rustc --verbose --version` shows the version of LLVM used by the Rust compiler.)\n@@ -181,11 +194,10 @@ A typical use case for coverage analysis is test coverage. Rust's source-based c\n \n The following example (using the [`json5format`] crate, for demonstration purposes) show how to generate and analyze coverage results for all tests in a crate.\n \n-Since `cargo test` both builds and runs the tests, we set both the additional `RUSTFLAGS`, to add the `-C instrument-coverage` flag, and `LLVM_PROFILE_FILE`, to set a custom filename for the raw profiling data generated during the test runs. Since there may be more than one test binary, apply `%m` in the filename pattern. This generates unique names for each test binary. (Otherwise, each executed test binary would overwrite the coverage results from the previous binary.)\n+Since `cargo test` both builds and runs the tests, we set the additional `RUSTFLAGS`, to add the `-C instrument-coverage` flag.\n \n ```shell\n $ RUSTFLAGS=\"-C instrument-coverage\" \\\n-    LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n     cargo test --tests\n ```\n \n@@ -210,7 +222,7 @@ test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n You should have one or more `.profraw` files now, one for each test binary. Run the `profdata` tool to merge them:\n \n ```shell\n-$ llvm-profdata merge -sparse json5format-*.profraw -o json5format.profdata\n+$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata\n ```\n \n Then run the `cov` tool, with the `profdata` file and all test binaries:\n@@ -230,6 +242,8 @@ $ llvm-cov show \\\n     --Xdemangler=rustfilt | less -R\n ```\n \n+> **Note**: If overriding the default `profraw` file name via the `LLVM_PROFILE_FILE` environment variable, it's highly recommended to use the `%m` and `%p` special pattern strings to generate unique file names in the case of more than a single test binary being executed.\n+\n > **Note**: The command line option `--ignore-filename-regex=/.cargo/registry`, which excludes the sources for dependencies from the coverage results.\\_\n \n ### Tips for listing the binaries automatically\n@@ -271,9 +285,8 @@ To include doc tests in the coverage results, drop the `--tests` flag, and apply\n ```bash\n $ RUSTFLAGS=\"-C instrument-coverage\" \\\n   RUSTDOCFLAGS=\"-C instrument-coverage -Z unstable-options --persist-doctests target/debug/doctestbins\" \\\n-  LLVM_PROFILE_FILE=\"json5format-%m.profraw\" \\\n     cargo test\n-$ llvm-profdata merge -sparse json5format-*.profraw -o json5format.profdata\n+$ llvm-profdata merge -sparse default_*.profraw -o json5format.profdata\n ```\n \n The `-Z unstable-options --persist-doctests` flag is required, to save the test binaries\n@@ -302,8 +315,7 @@ $ llvm-cov report \\\n > version without doc tests, include:\n \n -   The `cargo test ... --no-run` command is updated with the same environment variables\n-    and flags used to _build_ the tests, _including_ the doc tests. (`LLVM_PROFILE_FILE`\n-    is only used when _running_ the tests.)\n+    and flags used to _build_ the tests, _including_ the doc tests.\n -   The file glob pattern `target/debug/doctestbins/*/rust_out` adds the `rust_out`\n     binaries generated for doc tests (note, however, that some `rust_out` files may not\n     be executable binaries)."}, {"sha": "78f8875a2d90c5bb11aab95226772d7fb0465943", "filename": "src/test/codegen/instrument-coverage.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f347c424613ba34a95120908612b91440f3093c2/src%2Ftest%2Fcodegen%2Finstrument-coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f347c424613ba34a95120908612b91440f3093c2/src%2Ftest%2Fcodegen%2Finstrument-coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finstrument-coverage.rs?ref=f347c424613ba34a95120908612b91440f3093c2", "patch": "@@ -0,0 +1,17 @@\n+// Test that `-Cinstrument-coverage` creates expected __llvm_profile_filename symbol in LLVM IR.\n+\n+// needs-profiler-support\n+// compile-flags: -Cinstrument-coverage\n+\n+// CHECK: @__llvm_profile_filename = {{.*}}\"default_%m_%p.profraw\\00\"{{.*}}\n+\n+#![crate_type=\"lib\"]\n+\n+#[inline(never)]\n+fn some_function() {\n+\n+}\n+\n+pub fn some_other_function() {\n+    some_function();\n+}"}]}