{"sha": "f21197f081048e383ff10427216db7867b746832", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMTE5N2YwODEwNDhlMzgzZmYxMDQyNzIxNmRiNzg2N2I3NDY4MzI=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-06T23:12:13Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:23:32Z"}, "message": "Store the thread name.", "tree": {"sha": "faf60731008c4525531d99d72a4951011b69b2de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faf60731008c4525531d99d72a4951011b69b2de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f21197f081048e383ff10427216db7867b746832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f21197f081048e383ff10427216db7867b746832", "html_url": "https://github.com/rust-lang/rust/commit/f21197f081048e383ff10427216db7867b746832", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f21197f081048e383ff10427216db7867b746832/comments", "author": null, "committer": null, "parents": [{"sha": "52184193c363e030818a18a60123eed25b12c7c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/52184193c363e030818a18a60123eed25b12c7c9", "html_url": "https://github.com/rust-lang/rust/commit/52184193c363e030818a18a60123eed25b12c7c9"}], "stats": {"total": 59, "additions": 45, "deletions": 14}, "files": [{"sha": "4e08593d61c34603a07cb8d129a2a4aae4153222", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f21197f081048e383ff10427216db7867b746832/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21197f081048e383ff10427216db7867b746832/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=f21197f081048e383ff10427216db7867b746832", "patch": "@@ -329,6 +329,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.pthread_detach(args[0])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n+            \"prctl\" => {\n+                assert_eq!(args.len(), 5);\n+                let result = this.prctl(args[0], args[1], args[2], args[3], args[4])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n \n             \"pthread_attr_getguardsize\" => {\n                 assert_eq!(args.len(), 2);\n@@ -347,14 +352,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            \"prctl\" => {\n-                let option = this.read_scalar(args[0])?.not_undef()?.to_i32()?;\n-                assert_eq!(option, 0xf, \"Miri supports only PR_SET_NAME\");\n-\n-                // Return success (`0`).\n-                this.write_null(dest)?;\n-            }\n-\n             // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             | \"pthread_attr_init\""}, {"sha": "3a55fb3c706c90130c3ad5d75258d3d9b074fc9b", "filename": "src/shims/threads.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f21197f081048e383ff10427216db7867b746832/src%2Fshims%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21197f081048e383ff10427216db7867b746832/src%2Fshims%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fthreads.rs?ref=f21197f081048e383ff10427216db7867b746832", "patch": "@@ -79,6 +79,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let thread_id = this.read_scalar(thread)?.not_undef()?.to_machine_usize(this)?;\n         this.detach_thread(thread_id.into())?;\n \n+        Ok(0)\n+    }\n+    fn prctl(\n+        &mut self,\n+        option: OpTy<'tcx, Tag>,\n+        arg2: OpTy<'tcx, Tag>,\n+        _arg3: OpTy<'tcx, Tag>,\n+        _arg4: OpTy<'tcx, Tag>,\n+        _arg5: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let option = this.read_scalar(option)?.not_undef()?.to_i32()?;\n+        if option != this.eval_libc_i32(\"PR_SET_NAME\")? {\n+            throw_unsup_format!(\"Miri supports only PR_SET_NAME\");\n+        }\n+        let address = this.read_scalar(arg2)?.not_undef()?;\n+        let name = this.memory.read_c_str(address)?.to_owned();\n+        this.set_active_thread_name(name)?;\n+\n         Ok(0)\n     }\n }"}, {"sha": "4ce35d50abc35f89700c9dc9e5a552ec97dcc850", "filename": "src/threads.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f21197f081048e383ff10427216db7867b746832/src%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f21197f081048e383ff10427216db7867b746832/src%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthreads.rs?ref=f21197f081048e383ff10427216db7867b746832", "patch": "@@ -47,6 +47,8 @@ pub enum ThreadState {\n /// A thread.\n pub struct Thread<'mir, 'tcx> {\n     state: ThreadState,\n+    /// Name of the thread.\n+    thread_name: Option<Vec<u8>>,\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>>,\n     /// Is the thread detached?\n@@ -78,7 +80,7 @@ impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n \n impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n     fn default() -> Self {\n-        Self { state: ThreadState::Enabled, stack: Vec::new(), detached: false }\n+        Self { state: ThreadState::Enabled, thread_name: None, stack: Vec::new(), detached: false }\n     }\n }\n \n@@ -117,16 +119,20 @@ impl<'mir, 'tcx: 'mir> ThreadSet<'mir, 'tcx> {\n         new_thread_id\n     }\n     /// Set an active thread and return the id of the thread that was active before.\n-    fn set_active_thread(&mut self, id: ThreadId) -> ThreadId {\n+    fn set_active_thread_id(&mut self, id: ThreadId) -> ThreadId {\n         let active_thread_id = self.active_thread;\n         self.active_thread = id;\n         assert!(self.active_thread.index() < self.threads.len());\n         active_thread_id\n     }\n     /// Get the id of the currently active thread.\n-    fn get_active_thread(&self) -> ThreadId {\n+    fn get_active_thread_id(&self) -> ThreadId {\n         self.active_thread\n     }\n+    /// Get the borrow of the currently active thread.\n+    fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n+        &mut self.threads[self.active_thread]\n+    }\n     /// Mark the thread as detached, which means that no other thread will try\n     /// to join it and the thread is responsible for cleaning up.\n     fn detach_thread(&mut self, id: ThreadId) {\n@@ -152,6 +158,10 @@ impl<'mir, 'tcx: 'mir> ThreadSet<'mir, 'tcx> {\n             );\n         }\n     }\n+    /// Set the name of the active thread.\n+    fn set_thread_name(&mut self, new_thread_name: Vec<u8>) {\n+        self.active_thread_mut().thread_name = Some(new_thread_name);\n+    }\n     /// Get ids of all threads ever allocated.\n     fn get_all_thread_ids_with_states(&self) -> Vec<(ThreadId, ThreadState)> {\n         self.threads.iter_enumerated().map(|(id, thread)| (id, thread.state)).collect()\n@@ -266,11 +276,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_mut();\n         this.memory.extra.tls.set_active_thread(thread_id);\n-        Ok(this.machine.threads.set_active_thread(thread_id))\n+        Ok(this.machine.threads.set_active_thread_id(thread_id))\n     }\n     fn get_active_thread(&self) -> InterpResult<'tcx, ThreadId> {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.get_active_thread())\n+        Ok(this.machine.threads.get_active_thread_id())\n     }\n     fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         let this = self.eval_context_ref();\n@@ -280,6 +290,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.machine.threads.active_thread_stack_mut()\n     }\n+    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+        Ok(this.machine.threads.set_thread_name(new_thread_name))\n+    }\n     fn get_all_thread_ids_with_states(&mut self) -> Vec<(ThreadId, ThreadState)> {\n         let this = self.eval_context_mut();\n         this.machine.threads.get_all_thread_ids_with_states()\n@@ -291,7 +305,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         // Find the next thread to run.\n         if this.machine.threads.schedule()? {\n-            let active_thread = this.machine.threads.get_active_thread();\n+            let active_thread = this.machine.threads.get_active_thread_id();\n             this.memory.extra.tls.set_active_thread(active_thread);\n             Ok(true)\n         } else {"}]}