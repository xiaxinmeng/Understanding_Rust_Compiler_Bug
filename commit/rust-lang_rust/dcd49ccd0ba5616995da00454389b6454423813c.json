{"sha": "dcd49ccd0ba5616995da00454389b6454423813c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZDQ5Y2NkMGJhNTYxNjk5NWRhMDA0NTQzODliNjQ1NDQyMzgxM2M=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-24T22:12:26Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-24T22:20:01Z"}, "message": "Add Fractional, Real and RealExt traits", "tree": {"sha": "40b038e88befce213ceda6530737872db509e87e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40b038e88befce213ceda6530737872db509e87e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcd49ccd0ba5616995da00454389b6454423813c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd49ccd0ba5616995da00454389b6454423813c", "html_url": "https://github.com/rust-lang/rust/commit/dcd49ccd0ba5616995da00454389b6454423813c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcd49ccd0ba5616995da00454389b6454423813c/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fa054df968198eff4513e483dee07e1e3612dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa054df968198eff4513e483dee07e1e3612dad", "html_url": "https://github.com/rust-lang/rust/commit/6fa054df968198eff4513e483dee07e1e3612dad"}], "stats": {"total": 795, "additions": 724, "deletions": 71}, "files": [{"sha": "0a24fba666334c3e782cfcde53840112c3949608", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=dcd49ccd0ba5616995da00454389b6454423813c", "patch": "@@ -105,6 +105,7 @@ pub use iter::{ExtendedMutableIter};\n \n pub use num::{Num, NumCast};\n pub use num::{Signed, Unsigned, Integer};\n+pub use num::{Fractional, Real, RealExt};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "57ac6c551766b4d727bda2a31874ecd5c2685c14", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 192, "deletions": 19, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=dcd49ccd0ba5616995da00454389b6454423813c", "patch": "@@ -327,31 +327,176 @@ impl Signed for f32 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n-impl num::Round for f32 {\n-    #[inline(always)]\n-    fn round(&self, mode: num::RoundMode) -> f32 {\n-        match mode {\n-            num::RoundDown                           => floor(*self),\n-            num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if self.is_negative() => ceil(*self),\n-            num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if self.is_negative() => floor(*self),\n-            num::RoundFromZero                       => ceil(*self)\n-        }\n-    }\n+impl Fractional for f32 {\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline(always)]\n+    fn recip(&self) -> f32 { 1.0 / *self }\n+}\n+\n+impl Real for f32 {\n+    /// Archimedes' constant\n+    #[inline(always)]\n+    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n+\n+    /// 2.0 * pi\n+    #[inline(always)]\n+    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n+\n+    /// pi / 2.0\n+    #[inline(always)]\n+    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n+\n+    /// pi / 3.0\n+    #[inline(always)]\n+    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n+\n+    /// pi / 4.0\n+    #[inline(always)]\n+    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n+\n+    /// pi / 6.0\n+    #[inline(always)]\n+    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n+\n+    /// pi / 8.0\n+    #[inline(always)]\n+    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n+\n+    /// 1 .0/ pi\n+    #[inline(always)]\n+    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline(always)]\n+    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline(always)]\n+    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n+\n+    /// sqrt(2.0)\n+    #[inline(always)]\n+    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline(always)]\n+    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n+\n+    /// Euler's number\n+    #[inline(always)]\n+    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline(always)]\n+    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline(always)]\n+    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+\n+    /// log(2.0)\n+    #[inline(always)]\n+    fn log_2() -> f32 { 0.693147180559945309417232121458176568 }\n+\n+    /// log(10.0)\n+    #[inline(always)]\n+    fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n \n     #[inline(always)]\n     fn floor(&self) -> f32 { floor(*self) }\n+\n     #[inline(always)]\n     fn ceil(&self) -> f32 { ceil(*self) }\n+\n     #[inline(always)]\n-    fn fract(&self) -> f32 {\n-        if self.is_negative() {\n-            (*self) - ceil(*self)\n-        } else {\n-            (*self) - floor(*self)\n-        }\n-    }\n+    fn round(&self) -> f32 { round(*self) }\n+\n+    #[inline(always)]\n+    fn trunc(&self) -> f32 { trunc(*self) }\n+\n+    /// The fractional part of the number, calculated using: `n - floor(n)`\n+    #[inline(always)]\n+    fn fract(&self) -> f32 { *self - self.floor() }\n+\n+    #[inline(always)]\n+    fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n+\n+    #[inline(always)]\n+    fn exp(&self) -> f32 { exp(*self) }\n+\n+    #[inline(always)]\n+    fn exp2(&self) -> f32 { exp2(*self) }\n+\n+    #[inline(always)]\n+    fn expm1(&self) -> f32 { expm1(*self) }\n+\n+    #[inline(always)]\n+    fn ldexp(&self, n: int) -> f32 { ldexp(*self, n as c_int) }\n+\n+    #[inline(always)]\n+    fn log(&self) -> f32 { ln(*self) }\n+\n+    #[inline(always)]\n+    fn log2(&self) -> f32 { log2(*self) }\n+\n+    #[inline(always)]\n+    fn log10(&self) -> f32 { log10(*self) }\n+\n+    #[inline(always)]\n+    fn log_radix(&self) -> f32 { log_radix(*self) as f32 }\n+\n+    #[inline(always)]\n+    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+\n+    #[inline(always)]\n+    fn sqrt(&self) -> f32 { sqrt(*self) }\n+\n+    #[inline(always)]\n+    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n+\n+    #[inline(always)]\n+    fn cbrt(&self) -> f32 { cbrt(*self) }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline(always)]\n+    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline(always)]\n+    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n+\n+    #[inline(always)]\n+    fn hypot(&self, other: f32) -> f32 { hypot(*self, other) }\n+\n+    #[inline(always)]\n+    fn sin(&self) -> f32 { sin(*self) }\n+\n+    #[inline(always)]\n+    fn cos(&self) -> f32 { cos(*self) }\n+\n+    #[inline(always)]\n+    fn tan(&self) -> f32 { tan(*self) }\n+\n+    #[inline(always)]\n+    fn asin(&self) -> f32 { asin(*self) }\n+\n+    #[inline(always)]\n+    fn acos(&self) -> f32 { acos(*self) }\n+\n+    #[inline(always)]\n+    fn atan(&self) -> f32 { atan(*self) }\n+\n+    #[inline(always)]\n+    fn atan2(&self, other: f32) -> f32 { atan2(*self, other) }\n+\n+    #[inline(always)]\n+    fn sinh(&self) -> f32 { sinh(*self) }\n+\n+    #[inline(always)]\n+    fn cosh(&self) -> f32 { cosh(*self) }\n+\n+    #[inline(always)]\n+    fn tanh(&self) -> f32 { tanh(*self) }\n }\n \n /**\n@@ -577,11 +722,39 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    macro_rules! assert_fuzzy_eq(\n+        ($a:expr, $b:expr) => ({\n+            let a = $a, b = $b;\n+            if !((a - b).abs() < 1.0e-6) {\n+                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n+            }\n+        })\n+    )\n+\n     #[test]\n     fn test_num() {\n         num::test_num(10f32, 2f32);\n     }\n \n+    #[test]\n+    fn test_real_consts() {\n+        assert_fuzzy_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());\n+        assert_fuzzy_eq!(Real::frac_pi_2::<f32>(), Real::pi::<f32>() / 2f32);\n+        assert_fuzzy_eq!(Real::frac_pi_3::<f32>(), Real::pi::<f32>() / 3f32);\n+        assert_fuzzy_eq!(Real::frac_pi_4::<f32>(), Real::pi::<f32>() / 4f32);\n+        assert_fuzzy_eq!(Real::frac_pi_6::<f32>(), Real::pi::<f32>() / 6f32);\n+        assert_fuzzy_eq!(Real::frac_pi_8::<f32>(), Real::pi::<f32>() / 8f32);\n+        assert_fuzzy_eq!(Real::frac_1_pi::<f32>(), 1f32 / Real::pi::<f32>());\n+        assert_fuzzy_eq!(Real::frac_2_pi::<f32>(), 2f32 / Real::pi::<f32>());\n+        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<f32>(), 2f32 / Real::pi::<f32>().sqrt());\n+        assert_fuzzy_eq!(Real::sqrt2::<f32>(), 2f32.sqrt());\n+        assert_fuzzy_eq!(Real::frac_1_sqrt2::<f32>(), 1f32 / 2f32.sqrt());\n+        assert_fuzzy_eq!(Real::log2_e::<f32>(), Real::e::<f32>().log2());\n+        assert_fuzzy_eq!(Real::log10_e::<f32>(), Real::e::<f32>().log10());\n+        assert_fuzzy_eq!(Real::log_2::<f32>(), 2f32.log());\n+        assert_fuzzy_eq!(Real::log_10::<f32>(), 10f32.log());\n+    }\n+\n     #[test]\n     pub fn test_signed() {\n         assert_eq!(infinity.abs(), infinity);"}, {"sha": "53ad78c29f392370ec7ca93244b6b72a53b350b6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 221, "deletions": 18, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=dcd49ccd0ba5616995da00454389b6454423813c", "patch": "@@ -337,31 +337,206 @@ impl Signed for f64 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n-impl num::Round for f64 {\n-    #[inline(always)]\n-    fn round(&self, mode: num::RoundMode) -> f64 {\n-        match mode {\n-            num::RoundDown                           => floor(*self),\n-            num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if self.is_negative() => ceil(*self),\n-            num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if self.is_negative() => floor(*self),\n-            num::RoundFromZero                       => ceil(*self)\n-        }\n-    }\n+impl Fractional for f64 {\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline(always)]\n+    fn recip(&self) -> f64 { 1.0 / *self }\n+}\n+\n+impl Real for f64 {\n+    /// Archimedes' constant\n+    #[inline(always)]\n+    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n+\n+    /// 2.0 * pi\n+    #[inline(always)]\n+    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n+\n+    /// pi / 2.0\n+    #[inline(always)]\n+    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n+\n+    /// pi / 3.0\n+    #[inline(always)]\n+    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n+\n+    /// pi / 4.0\n+    #[inline(always)]\n+    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n+\n+    /// pi / 6.0\n+    #[inline(always)]\n+    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n+\n+    /// pi / 8.0\n+    #[inline(always)]\n+    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+\n+    /// 1.0 / pi\n+    #[inline(always)]\n+    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline(always)]\n+    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline(always)]\n+    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n+\n+    /// sqrt(2.0)\n+    #[inline(always)]\n+    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline(always)]\n+    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n+\n+    /// Euler's number\n+    #[inline(always)]\n+    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline(always)]\n+    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline(always)]\n+    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+\n+    /// log(2.0)\n+    #[inline(always)]\n+    fn log_2() -> f64 { 0.693147180559945309417232121458176568 }\n+\n+    /// log(10.0)\n+    #[inline(always)]\n+    fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n \n     #[inline(always)]\n     fn floor(&self) -> f64 { floor(*self) }\n+\n     #[inline(always)]\n     fn ceil(&self) -> f64 { ceil(*self) }\n+\n     #[inline(always)]\n-    fn fract(&self) -> f64 {\n-        if self.is_negative() {\n-            (*self) - ceil(*self)\n-        } else {\n-            (*self) - floor(*self)\n-        }\n+    fn round(&self) -> f64 { round(*self) }\n+\n+    #[inline(always)]\n+    fn trunc(&self) -> f64 { trunc(*self) }\n+\n+    /// The fractional part of the number, calculated using: `n - floor(n)`\n+    #[inline(always)]\n+    fn fract(&self) -> f64 { *self - self.floor() }\n+\n+    #[inline(always)]\n+    fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n+\n+    #[inline(always)]\n+    fn exp(&self) -> f64 { exp(*self) }\n+\n+    #[inline(always)]\n+    fn exp2(&self) -> f64 { exp2(*self) }\n+\n+    #[inline(always)]\n+    fn expm1(&self) -> f64 { expm1(*self) }\n+\n+    #[inline(always)]\n+    fn ldexp(&self, n: int) -> f64 { ldexp(*self, n as c_int) }\n+\n+    #[inline(always)]\n+    fn log(&self) -> f64 { ln(*self) }\n+\n+    #[inline(always)]\n+    fn log2(&self) -> f64 { log2(*self) }\n+\n+    #[inline(always)]\n+    fn log10(&self) -> f64 { log10(*self) }\n+\n+    #[inline(always)]\n+    fn log_radix(&self) -> f64 { log_radix(*self) }\n+\n+    #[inline(always)]\n+    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+\n+    #[inline(always)]\n+    fn sqrt(&self) -> f64 { sqrt(*self) }\n+\n+    #[inline(always)]\n+    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n+\n+    #[inline(always)]\n+    fn cbrt(&self) -> f64 { cbrt(*self) }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline(always)]\n+    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline(always)]\n+    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n+\n+    #[inline(always)]\n+    fn hypot(&self, other: f64) -> f64 { hypot(*self, other) }\n+\n+    #[inline(always)]\n+    fn sin(&self) -> f64 { sin(*self) }\n+\n+    #[inline(always)]\n+    fn cos(&self) -> f64 { cos(*self) }\n+\n+    #[inline(always)]\n+    fn tan(&self) -> f64 { tan(*self) }\n+\n+    #[inline(always)]\n+    fn asin(&self) -> f64 { asin(*self) }\n+\n+    #[inline(always)]\n+    fn acos(&self) -> f64 { acos(*self) }\n+\n+    #[inline(always)]\n+    fn atan(&self) -> f64 { atan(*self) }\n+\n+    #[inline(always)]\n+    fn atan2(&self, other: f64) -> f64 { atan2(*self, other) }\n+\n+    #[inline(always)]\n+    fn sinh(&self) -> f64 { sinh(*self) }\n+\n+    #[inline(always)]\n+    fn cosh(&self) -> f64 { cosh(*self) }\n+\n+    #[inline(always)]\n+    fn tanh(&self) -> f64 { tanh(*self) }\n+}\n+\n+impl RealExt for f64 {\n+    #[inline(always)]\n+    fn lgamma(&self) -> (int, f64) {\n+        let mut sign = 0;\n+        let result = lgamma(*self, &mut sign);\n+        (sign as int, result)\n     }\n+\n+    #[inline(always)]\n+    fn tgamma(&self) -> f64 { tgamma(*self) }\n+\n+    #[inline(always)]\n+    fn j0(&self) -> f64 { j0(*self) }\n+\n+    #[inline(always)]\n+    fn j1(&self) -> f64 { j1(*self) }\n+\n+    #[inline(always)]\n+    fn jn(&self, n: int) -> f64 { jn(n as c_int, *self) }\n+\n+    #[inline(always)]\n+    fn y0(&self) -> f64 { y0(*self) }\n+\n+    #[inline(always)]\n+    fn y1(&self) -> f64 { y1(*self) }\n+\n+    #[inline(always)]\n+    fn yn(&self, n: int) -> f64 { yn(n as c_int, *self) }\n }\n \n /**\n@@ -587,11 +762,39 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    macro_rules! assert_fuzzy_eq(\n+        ($a:expr, $b:expr) => ({\n+            let a = $a, b = $b;\n+            if !((a - b).abs() < 1.0e-6) {\n+                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n+            }\n+        })\n+    )\n+\n     #[test]\n     fn test_num() {\n         num::test_num(10f64, 2f64);\n     }\n \n+    #[test]\n+    fn test_real_consts() {\n+        assert_fuzzy_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());\n+        assert_fuzzy_eq!(Real::frac_pi_2::<f64>(), Real::pi::<f64>() / 2f64);\n+        assert_fuzzy_eq!(Real::frac_pi_3::<f64>(), Real::pi::<f64>() / 3f64);\n+        assert_fuzzy_eq!(Real::frac_pi_4::<f64>(), Real::pi::<f64>() / 4f64);\n+        assert_fuzzy_eq!(Real::frac_pi_6::<f64>(), Real::pi::<f64>() / 6f64);\n+        assert_fuzzy_eq!(Real::frac_pi_8::<f64>(), Real::pi::<f64>() / 8f64);\n+        assert_fuzzy_eq!(Real::frac_1_pi::<f64>(), 1f64 / Real::pi::<f64>());\n+        assert_fuzzy_eq!(Real::frac_2_pi::<f64>(), 2f64 / Real::pi::<f64>());\n+        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<f64>(), 2f64 / Real::pi::<f64>().sqrt());\n+        assert_fuzzy_eq!(Real::sqrt2::<f64>(), 2f64.sqrt());\n+        assert_fuzzy_eq!(Real::frac_1_sqrt2::<f64>(), 1f64 / 2f64.sqrt());\n+        assert_fuzzy_eq!(Real::log2_e::<f64>(), Real::e::<f64>().log2());\n+        assert_fuzzy_eq!(Real::log10_e::<f64>(), Real::e::<f64>().log10());\n+        assert_fuzzy_eq!(Real::log_2::<f64>(), 2f64.log());\n+        assert_fuzzy_eq!(Real::log_10::<f64>(), 10f64.log());\n+    }\n+\n     #[test]\n     pub fn test_signed() {\n         assert_eq!(infinity.abs(), infinity);"}, {"sha": "ae2d0ce0d71949a1bfd642a8ada9f80d10e136c2", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 223, "deletions": 26, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=dcd49ccd0ba5616995da00454389b6454423813c", "patch": "@@ -403,37 +403,206 @@ impl num::One for float {\n     fn one() -> float { 1.0 }\n }\n \n-impl num::Round for float {\n-    #[inline(always)]\n-    fn round(&self, mode: num::RoundMode) -> float {\n-        match mode {\n-            num::RoundDown\n-                => f64::floor(*self as f64) as float,\n-            num::RoundUp\n-                => f64::ceil(*self as f64) as float,\n-            num::RoundToZero   if self.is_negative()\n-                => f64::ceil(*self as f64) as float,\n-            num::RoundToZero\n-                => f64::floor(*self as f64) as float,\n-            num::RoundFromZero if self.is_negative()\n-                => f64::floor(*self as f64) as float,\n-            num::RoundFromZero\n-                => f64::ceil(*self as f64) as float\n-        }\n-    }\n+impl Fractional for float {\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline(always)]\n+    fn recip(&self) -> float { 1.0 / *self }\n+}\n \n+impl Real for float {\n+    /// Archimedes' constant\n     #[inline(always)]\n-    fn floor(&self) -> float { f64::floor(*self as f64) as float}\n+    fn pi() -> float { 3.14159265358979323846264338327950288 }\n+\n+    /// 2.0 * pi\n     #[inline(always)]\n-    fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n+    fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n+\n+    /// pi / 2.0\n     #[inline(always)]\n-    fn fract(&self) -> float {\n-        if self.is_negative() {\n-            (*self) - (f64::ceil(*self as f64) as float)\n-        } else {\n-            (*self) - (f64::floor(*self as f64) as float)\n-        }\n+    fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n+\n+    /// pi / 3.0\n+    #[inline(always)]\n+    fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n+\n+    /// pi / 4.0\n+    #[inline(always)]\n+    fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n+\n+    /// pi / 6.0\n+    #[inline(always)]\n+    fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n+\n+    /// pi / 8.0\n+    #[inline(always)]\n+    fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n+\n+    /// 1.0 / pi\n+    #[inline(always)]\n+    fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline(always)]\n+    fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n+\n+    /// 2 .0/ sqrt(pi)\n+    #[inline(always)]\n+    fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n+\n+    /// sqrt(2.0)\n+    #[inline(always)]\n+    fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline(always)]\n+    fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n+\n+    /// Euler's number\n+    #[inline(always)]\n+    fn e() -> float { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline(always)]\n+    fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline(always)]\n+    fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n+\n+    /// log(2.0)\n+    #[inline(always)]\n+    fn log_2() -> float { 0.693147180559945309417232121458176568 }\n+\n+    /// log(10.0)\n+    #[inline(always)]\n+    fn log_10() -> float { 2.30258509299404568401799145468436421 }\n+\n+    #[inline(always)]\n+    fn floor(&self) -> float { floor(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn ceil(&self) -> float { ceil(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn round(&self) -> float { round(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn trunc(&self) -> float { trunc(*self as f64) as float }\n+\n+    /// The fractional part of the number, calculated using: `n - floor(n)`\n+    #[inline(always)]\n+    fn fract(&self) -> float { *self - self.floor() }\n+\n+    #[inline(always)]\n+    fn pow(&self, n: float) -> float { pow(*self as f64, n as f64) as float }\n+\n+    #[inline(always)]\n+    fn exp(&self) -> float { exp(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn exp2(&self) -> float { exp2(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn expm1(&self) -> float { expm1(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn ldexp(&self, n: int) -> float { ldexp(*self as f64, n as c_int) as float }\n+\n+    #[inline(always)]\n+    fn log(&self) -> float { ln(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn log2(&self) -> float { log2(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn log10(&self) -> float { log10(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn log_radix(&self) -> float { log_radix(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn ilog_radix(&self) -> int { ilog_radix(*self as f64) as int }\n+\n+    #[inline(always)]\n+    fn sqrt(&self) -> float { sqrt(*self) }\n+\n+    #[inline(always)]\n+    fn rsqrt(&self) -> float { self.sqrt().recip() }\n+\n+    #[inline(always)]\n+    fn cbrt(&self) -> float { cbrt(*self as f64) as float }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline(always)]\n+    fn to_degrees(&self) -> float { *self * (180.0 / Real::pi::<float>()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline(always)]\n+    fn to_radians(&self) -> float { *self * (Real::pi::<float>() / 180.0) }\n+\n+    #[inline(always)]\n+    fn hypot(&self, other: float) -> float { hypot(*self as f64, other as f64) as float }\n+\n+    #[inline(always)]\n+    fn sin(&self) -> float { sin(*self) }\n+\n+    #[inline(always)]\n+    fn cos(&self) -> float { cos(*self) }\n+\n+    #[inline(always)]\n+    fn tan(&self) -> float { tan(*self) }\n+\n+    #[inline(always)]\n+    fn asin(&self) -> float { asin(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn acos(&self) -> float { acos(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn atan(&self) -> float { atan(*self) }\n+\n+    #[inline(always)]\n+    fn atan2(&self, other: float) -> float { atan2(*self as f64, other as f64) as float }\n+\n+    #[inline(always)]\n+    fn sinh(&self) -> float { sinh(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn cosh(&self) -> float { cosh(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn tanh(&self) -> float { tanh(*self as f64) as float }\n+}\n+\n+impl RealExt for float {\n+    #[inline(always)]\n+    fn lgamma(&self) -> (int, float) {\n+        let mut sign = 0;\n+        let result = lgamma(*self as f64, &mut sign);\n+        (sign as int, result as float)\n     }\n+\n+    #[inline(always)]\n+    fn tgamma(&self) -> float { tgamma(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn j0(&self) -> float { j0(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn j1(&self) -> float { j1(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn jn(&self, n: int) -> float { jn(n as c_int, *self as f64) as float }\n+\n+    #[inline(always)]\n+    fn y0(&self) -> float { y0(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn y1(&self) -> float { y1(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn yn(&self, n: int) -> float { yn(n as c_int, *self as f64) as float }\n }\n \n #[cfg(notest)]\n@@ -511,11 +680,39 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    macro_rules! assert_fuzzy_eq(\n+        ($a:expr, $b:expr) => ({\n+            let a = $a, b = $b;\n+            if !((a - b).abs() < 1.0e-6) {\n+                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n+            }\n+        })\n+    )\n+\n     #[test]\n     fn test_num() {\n         num::test_num(10f, 2f);\n     }\n \n+    #[test]\n+    fn test_real_consts() {\n+        assert_fuzzy_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n+        assert_fuzzy_eq!(Real::frac_pi_2::<float>(), Real::pi::<float>() / 2f);\n+        assert_fuzzy_eq!(Real::frac_pi_3::<float>(), Real::pi::<float>() / 3f);\n+        assert_fuzzy_eq!(Real::frac_pi_4::<float>(), Real::pi::<float>() / 4f);\n+        assert_fuzzy_eq!(Real::frac_pi_6::<float>(), Real::pi::<float>() / 6f);\n+        assert_fuzzy_eq!(Real::frac_pi_8::<float>(), Real::pi::<float>() / 8f);\n+        assert_fuzzy_eq!(Real::frac_1_pi::<float>(), 1f / Real::pi::<float>());\n+        assert_fuzzy_eq!(Real::frac_2_pi::<float>(), 2f / Real::pi::<float>());\n+        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<float>(), 2f / Real::pi::<float>().sqrt());\n+        assert_fuzzy_eq!(Real::sqrt2::<float>(), 2f.sqrt());\n+        assert_fuzzy_eq!(Real::frac_1_sqrt2::<float>(), 1f / 2f.sqrt());\n+        assert_fuzzy_eq!(Real::log2_e::<float>(), Real::e::<float>().log2());\n+        assert_fuzzy_eq!(Real::log10_e::<float>(), Real::e::<float>().log10());\n+        assert_fuzzy_eq!(Real::log_2::<float>(), 2f.log());\n+        assert_fuzzy_eq!(Real::log_10::<float>(), 10f.log());\n+    }\n+\n     #[test]\n     pub fn test_signed() {\n         assert_eq!(infinity.abs(), infinity);"}, {"sha": "733b37e2a4a62cee204e8e34d1ae3d60146b38d9", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 86, "deletions": 8, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=dcd49ccd0ba5616995da00454389b6454423813c", "patch": "@@ -77,19 +77,97 @@ pub trait Integer: Num\n     fn is_odd(&self) -> bool;\n }\n \n-pub trait Round {\n-    fn round(&self, mode: RoundMode) -> Self;\n+pub trait Fractional: Num\n+                    + Ord\n+                    + Quot<Self,Self> {\n+    fn recip(&self) -> Self;\n+}\n+\n+pub trait Real: Signed\n+              + Fractional {\n+    // FIXME (#5527): usages of `int` should be replaced with an associated\n+    // integer type once these are implemented\n \n+    // Common Constants\n+    // FIXME (#5527): These should be associated constants\n+    fn pi() -> Self;\n+    fn two_pi() -> Self;\n+    fn frac_pi_2() -> Self;\n+    fn frac_pi_3() -> Self;\n+    fn frac_pi_4() -> Self;\n+    fn frac_pi_6() -> Self;\n+    fn frac_pi_8() -> Self;\n+    fn frac_1_pi() -> Self;\n+    fn frac_2_pi() -> Self;\n+    fn frac_2_sqrtpi() -> Self;\n+    fn sqrt2() -> Self;\n+    fn frac_1_sqrt2() -> Self;\n+    fn e() -> Self;\n+    fn log2_e() -> Self;\n+    fn log10_e() -> Self;\n+    fn log_2() -> Self;\n+    fn log_10() -> Self;\n+\n+    // Rounding operations\n     fn floor(&self) -> Self;\n-    fn ceil(&self)  -> Self;\n+    fn ceil(&self) -> Self;\n+    fn round(&self) -> Self;\n+    fn trunc(&self) -> Self;\n     fn fract(&self) -> Self;\n+\n+    // Exponential functions\n+    fn pow(&self, n: Self) -> Self;\n+    fn exp(&self) -> Self;\n+    fn exp2(&self) -> Self;\n+    fn expm1(&self) -> Self;\n+    fn ldexp(&self, n: int) -> Self;\n+    fn log(&self) -> Self;\n+    fn log2(&self) -> Self;\n+    fn log10(&self) -> Self;\n+    fn log_radix(&self) -> Self;\n+    fn ilog_radix(&self) -> int;\n+    fn sqrt(&self) -> Self;\n+    fn rsqrt(&self) -> Self;\n+    fn cbrt(&self) -> Self;\n+\n+    // Angular conversions\n+    fn to_degrees(&self) -> Self;\n+    fn to_radians(&self) -> Self;\n+\n+    // Triganomic functions\n+    fn hypot(&self, other: Self) -> Self;\n+    fn sin(&self) -> Self;\n+    fn cos(&self) -> Self;\n+    fn tan(&self) -> Self;\n+\n+    // Inverse triganomic functions\n+    fn asin(&self) -> Self;\n+    fn acos(&self) -> Self;\n+    fn atan(&self) -> Self;\n+    fn atan2(&self, other: Self) -> Self;\n+\n+    // Hyperbolic triganomic functions\n+    fn sinh(&self) -> Self;\n+    fn cosh(&self) -> Self;\n+    fn tanh(&self) -> Self;\n }\n \n-pub enum RoundMode {\n-    RoundDown,\n-    RoundUp,\n-    RoundToZero,\n-    RoundFromZero\n+/// Methods that are harder to implement and not commonly used.\n+pub trait RealExt: Real {\n+    // FIXME (#5527): usages of `int` should be replaced with an associated\n+    // integer type once these are implemented\n+\n+    // Gamma functions\n+    fn lgamma(&self) -> (int, Self);\n+    fn tgamma(&self) -> Self;\n+\n+    // Bessel functions\n+    fn j0(&self) -> Self;\n+    fn j1(&self) -> Self;\n+    fn jn(&self, n: int) -> Self;\n+    fn y0(&self) -> Self;\n+    fn y1(&self) -> Self;\n+    fn yn(&self, n: int) -> Self;\n }\n \n /**"}, {"sha": "c161bd4cf59e255b100f506c931cce2e531ac2b4", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd49ccd0ba5616995da00454389b6454423813c/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=dcd49ccd0ba5616995da00454389b6454423813c", "patch": "@@ -39,6 +39,7 @@ pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n pub use num::{Num, NumCast};\n pub use num::{Signed, Unsigned, Integer};\n+pub use num::{Fractional, Real, RealExt};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}]}