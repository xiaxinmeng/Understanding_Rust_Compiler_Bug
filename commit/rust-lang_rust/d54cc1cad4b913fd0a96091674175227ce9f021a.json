{"sha": "d54cc1cad4b913fd0a96091674175227ce9f021a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NGNjMWNhZDRiOTEzZmQwYTk2MDkxNjc0MTc1MjI3Y2U5ZjAyMWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-19T14:30:31Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-19T14:33:45Z"}, "message": "Fix internal linking in the tutorial", "tree": {"sha": "cd44c5cc21f31d4701493aa39864cfdc7b1a5114", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd44c5cc21f31d4701493aa39864cfdc7b1a5114"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54cc1cad4b913fd0a96091674175227ce9f021a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54cc1cad4b913fd0a96091674175227ce9f021a", "html_url": "https://github.com/rust-lang/rust/commit/d54cc1cad4b913fd0a96091674175227ce9f021a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54cc1cad4b913fd0a96091674175227ce9f021a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df02ca1df96950175508191ef98c3b7914cbd9d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/df02ca1df96950175508191ef98c3b7914cbd9d9", "html_url": "https://github.com/rust-lang/rust/commit/df02ca1df96950175508191ef98c3b7914cbd9d9"}], "stats": {"total": 49, "additions": 16, "deletions": 33}, "files": [{"sha": "c6bfeed5cb14ae7e10f029fed7f9c82d53dd1ef7", "filename": "doc/tutorial.md", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d54cc1cad4b913fd0a96091674175227ce9f021a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d54cc1cad4b913fd0a96091674175227ce9f021a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d54cc1cad4b913fd0a96091674175227ce9f021a", "patch": "@@ -8,9 +8,7 @@ This is a tutorial for the Rust programming language. It assumes the\n reader is familiar with the basic concepts of programming, and has\n programmed in one or more other languages before. The tutorial covers\n the whole language, though not with the depth and precision of the\n-[language reference][1].\n-\n-[1]: http://www.rust-lang.org/doc/rust.html\n+[language reference](rust.html).\n \n ## Disclaimer\n \n@@ -106,7 +104,7 @@ live inside a function.\n Rust programs can also be compiled as libraries, and included in other\n programs. The `use std` directive that appears at the top of a lot of\n examples imports the [standard library][std]. This is described in more\n-detail [later on](mod.html).\n+detail [later on](#modules-and-crates).\n \n [std]: http://doc.rust-lang.org/doc/std/index/General.html\n \n@@ -332,10 +330,9 @@ type monster_size = uint;\n This will provide a synonym, `monster_size`, for unsigned integers. It\n will not actually create a new type\u2014`monster_size` and `uint` can be\n used interchangeably, and using one where the other is expected is not\n-a type error. Read about [single-variant enums][sve] further on if you\n-need to create a type name that's not just a synonym.\n-\n-[sve]: data.html#single_variant_enum\n+a type error. Read about [single-variant enums](#single_variant_enum)\n+further on if you need to create a type name that's not just a\n+synonym.\n \n ## Literals\n \n@@ -435,8 +432,6 @@ assert y == 4u;\n \n ## Attributes\n \n-<a name=\"conditional\"></a>\n-\n Every definition can be annotated with attributes. Attributes are meta\n information that can serve a variety of purposes. One of those is\n conditional compilation:\n@@ -457,12 +452,12 @@ Attributes are always wrapped in hash-braces (`#[attr]`). Inside the\n braces, a small minilanguage is supported, whose interpretation\n depends on the attribute that's being used. The simplest form is a\n plain name (as in `#[test]`, which is used by the [built-in test\n-framework](test.html '')). A name-value pair can be provided using an `=`\n+framework](#testing)). A name-value pair can be provided using an `=`\n character followed by a literal (as in `#[license = \"BSD\"]`, which is\n a valid way to annotate a Rust program as being released under a\n BSD-style license). Finally, you can have a name followed by a\n comma-separated list of nested attributes, as in the `cfg` example\n-above, or in this [crate](mod.html) metadata declaration:\n+above, or in this [crate](#modules-and-crates) metadata declaration:\n \n ~~~~\n ## ignore\n@@ -662,7 +657,7 @@ moment.\n \n ## Failure\n \n-The `fail` keyword causes the current [task][tasks] to fail. You use\n+The `fail` keyword causes the current [task](#tasks) to fail. You use\n it to indicate unexpected failure, much like you'd use `exit(1)` in a\n C program, except that in Rust, it is possible for other tasks to\n handle the failure, allowing the program to continue running.\n@@ -671,8 +666,6 @@ handle the failure, allowing the program to continue running.\n to access a vector out of bounds, or running a pattern match with no\n matching clauses, both result in the equivalent of a `fail`.\n \n-[tasks]: task.html\n-\n ## Logging\n \n Rust has a built-in logging mechanism, using the `log` statement.\n@@ -835,14 +828,12 @@ call_twice(bare_function);\n \n ### Unique closures\n \n-<a name=\"unique\"></a>\n-\n Unique closures, written `fn~` in analogy to the `~` pointer type (see\n next section), hold on to things that can safely be sent between\n processes. They copy the values they close over, much like boxed\n closures, but they also 'own' them\u2014meaning no other code can access\n them. Unique closures mostly exist to for spawning new\n-[tasks](task.html).\n+[tasks](#tasks).\n \n ### Shorthand syntax\n \n@@ -1151,8 +1142,6 @@ All pointer types can be dereferenced with the `*` unary operator.\n \n ### Shared boxes\n \n-<a name=\"shared-box\"></a>\n-\n Shared boxes are pointers to heap-allocated, reference counted memory.\n A cycle collector ensures that circular references do not result in\n memory leaks.\n@@ -1174,8 +1163,6 @@ Shared boxes never cross task boundaries.\n \n ### Unique boxes\n \n-<a name=\"unique-box\"></a>\n-\n In contrast to shared boxes, unique boxes are not reference counted.\n Instead, it is statically guaranteed that only a single owner of the\n box exists at any time.\n@@ -1414,7 +1401,7 @@ records and tags *are* passed by pointer, but single-word values, like\n integers and pointers, are simply passed by value. Most of the time,\n the programmer does not have to worry about this, as the compiler will\n simply pick the most efficient passing style. There is one exception,\n-which will be described in the section on [generics](generic.html).\n+which will be described in the section on [generics](#generics).\n \n To explicitly set the passing-style for a parameter, you prefix the\n argument name with a sigil. There are two special passing styles that\n@@ -1542,8 +1529,6 @@ without any sophistication).\n \n ## Kinds\n \n-<a name=\"kind\"></a>\n-\n Perhaps surprisingly, the 'copy' (duplicate) operation is not defined\n for all Rust types. Resource types (types with destructors) can not be\n copied, and neither can any type whose copying would require copying a\n@@ -1724,7 +1709,7 @@ A set of basic library routines, mostly related to built-in datatypes\n and the task system, are always implicitly linked and included in any\n Rust program, unless the `--no-core` compiler switch is given.\n \n-This library is document [here][core].\n+This library is documented [here][core].\n \n [core]: http://doc.rust-lang.org/doc/core/index/General.html\n \n@@ -2310,11 +2295,9 @@ supposed to point at, this is safe.\n Rust supports a system of lightweight tasks, similar to what is found\n in Erlang or other actor systems. Rust tasks communicate via messages\n and do not share data. However, it is possible to send data without\n-copying it by making use of [unique boxes][uniques], which allow the\n-sending task to release ownership of a value, so that the receiving\n-task can keep on using it.\n-\n-[uniques]: data.html#unique-box\n+copying it by making use of [unique boxes](#unique-boxes), which allow\n+the sending task to release ownership of a value, so that the\n+receiving task can keep on using it.\n \n NOTE: As Rust evolves, we expect the Task API to grow and change\n somewhat.  The tutorial documents the API as it exists today.\n@@ -2333,7 +2316,7 @@ let child_task = task::spawn {||\n ~~~~\n \n The argument to `task::spawn()` is a [unique\n-closure](func.html#unique) of type `fn~()`, meaning that it takes no\n+closure](#unique-closures) of type `fn~()`, meaning that it takes no\n arguments and generates no return value. The effect of `task::spawn()`\n is to fire up a child task that will execute the closure in parallel\n with the creator. The result is a task id, here stored into the\n@@ -2553,4 +2536,4 @@ ignored.\n A program compiled as a test runner will have the configuration flag\n `test` defined, so that you can add code that won't be included in a\n normal compile with the `#[cfg(test)]` attribute (see [conditional\n-compilation](syntax.md#conditional)).\n+compilation](#attributes))."}]}