{"sha": "26dbf56196ccd50a335f38755ea7546f6f1399bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZGJmNTYxOTZjY2Q1MGEzMzVmMzg3NTVlYTc1NDZmNmYxMzk5YmQ=", "commit": {"author": {"name": "kenta7777", "email": "k.hasegw7@gmail.com", "date": "2018-09-12T12:36:31Z"}, "committer": {"name": "kenta7777", "email": "k.hasegw7@gmail.com", "date": "2018-09-12T12:36:31Z"}, "message": "Merge branch 'master' into kenta7777#53719", "tree": {"sha": "6c099ff00be225c42e653384ca198cf457879cef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c099ff00be225c42e653384ca198cf457879cef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26dbf56196ccd50a335f38755ea7546f6f1399bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26dbf56196ccd50a335f38755ea7546f6f1399bd", "html_url": "https://github.com/rust-lang/rust/commit/26dbf56196ccd50a335f38755ea7546f6f1399bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26dbf56196ccd50a335f38755ea7546f6f1399bd/comments", "author": {"login": "kenta7777", "id": 16369171, "node_id": "MDQ6VXNlcjE2MzY5MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/16369171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kenta7777", "html_url": "https://github.com/kenta7777", "followers_url": "https://api.github.com/users/kenta7777/followers", "following_url": "https://api.github.com/users/kenta7777/following{/other_user}", "gists_url": "https://api.github.com/users/kenta7777/gists{/gist_id}", "starred_url": "https://api.github.com/users/kenta7777/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kenta7777/subscriptions", "organizations_url": "https://api.github.com/users/kenta7777/orgs", "repos_url": "https://api.github.com/users/kenta7777/repos", "events_url": "https://api.github.com/users/kenta7777/events{/privacy}", "received_events_url": "https://api.github.com/users/kenta7777/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kenta7777", "id": 16369171, "node_id": "MDQ6VXNlcjE2MzY5MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/16369171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kenta7777", "html_url": "https://github.com/kenta7777", "followers_url": "https://api.github.com/users/kenta7777/followers", "following_url": "https://api.github.com/users/kenta7777/following{/other_user}", "gists_url": "https://api.github.com/users/kenta7777/gists{/gist_id}", "starred_url": "https://api.github.com/users/kenta7777/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kenta7777/subscriptions", "organizations_url": "https://api.github.com/users/kenta7777/orgs", "repos_url": "https://api.github.com/users/kenta7777/repos", "events_url": "https://api.github.com/users/kenta7777/events{/privacy}", "received_events_url": "https://api.github.com/users/kenta7777/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "html_url": "https://github.com/rust-lang/rust/commit/8134ee25b88df98c79792d60cbf6745b6cb7ffc5"}, {"sha": "8586ec6980462c99a8926646201b2444d8938d29", "url": "https://api.github.com/repos/rust-lang/rust/commits/8586ec6980462c99a8926646201b2444d8938d29", "html_url": "https://github.com/rust-lang/rust/commit/8586ec6980462c99a8926646201b2444d8938d29"}], "stats": {"total": 5433, "additions": 3531, "deletions": 1902}, "files": [{"sha": "0e5b7170bc6b4e320c13d0574a9bb3760b9662d8", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -125,9 +125,9 @@ you have a more recent version installed the build system doesn't understand\n then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n-```\n-CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n-python x.py build\n+```batch\n+> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n+> python x.py build\n ```\n \n #### Specifying an ABI"}, {"sha": "1e01d68fb3a614c5c3f6ce415269490f52c62d47", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -8,14 +8,14 @@ system.\n \n The rustbuild build system has a primary entry point, a top level `x.py` script:\n \n-```\n-python ./x.py build\n+```sh\n+$ python ./x.py build\n ```\n \n Note that if you're on Unix you should be able to execute the script directly:\n \n-```\n-./x.py build\n+```sh\n+$ ./x.py build\n ```\n \n The script accepts commands, flags, and arguments to determine what to do:\n@@ -129,18 +129,18 @@ To follow this course of action, first thing you will want to do is to\n install a nightly, presumably using `rustup`. You will then want to\n configure your directory to use this build, like so:\n \n-```\n+```sh\n # configure to use local rust instead of downloading a beta.\n # `--local-rust-root` is optional here. If elided, we will\n # use whatever rustc we find on your PATH.\n-> ./configure --local-rust-root=~/.cargo/ --enable-local-rebuild\n+$ ./configure --local-rust-root=~/.cargo/ --enable-local-rebuild\n ```\n \n After that, you can use the `--incremental` flag to actually do\n incremental builds:\n \n-```\n-> ./x.py build --incremental\n+```sh\n+$ ./x.py build --incremental\n ```\n \n The `--incremental` flag will store incremental compilation artifacts\n@@ -159,7 +159,7 @@ will still be using the local nightly as your bootstrap).\n This build system houses all output under the `build` directory, which looks\n like this:\n \n-```\n+```sh\n # Root folder of all output. Everything is scoped underneath here\n build/\n "}, {"sha": "49c0026ce1a9b572d80989400df62d74a4199bc2", "filename": "src/doc/rustc/src/lints/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -12,7 +12,7 @@ $ cat main.rs\n fn main() {\n     let x = 5;\n }\n-> rustc main.rs\n+$ rustc main.rs\n warning: unused variable: `x`\n  --> main.rs:2:9\n   |"}, {"sha": "072c7585934e805a2209868043466317c48e1090", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -45,7 +45,7 @@ pub fn foo() {\n \n This will produce this warning:\n \n-```console\n+```bash\n $ rustc lib.rs --crate-type=lib\n warning: unused variable: `x`\n  --> lib.rs:2:9\n@@ -69,7 +69,7 @@ fn main() {\n ```\n \n ```bash\n-> rustc main.rs\n+$ rustc main.rs\n error: bitshift exceeds the type's number of bits\n  --> main.rs:2:13\n   |\n@@ -129,7 +129,10 @@ warning: missing documentation for a function\n   |\n 1 | pub fn foo() {}\n   | ^^^^^^^^^^^^\n-> rustc lib.rs --crate-type=lib -D missing-docs\n+```\n+\n+```bash\n+$ rustc lib.rs --crate-type=lib -D missing-docs\n error: missing documentation for crate\n  --> lib.rs:1:1\n   |\n@@ -150,21 +153,21 @@ error: aborting due to 2 previous errors\n You can also pass each flag more than once for changing multiple lints:\n \n ```bash\n-rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables\n+$ rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables\n ```\n \n And of course, you can mix these four flags together:\n \n ```bash\n-rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables\n+$ rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables\n ```\n \n ### Via an attribute\n \n You can also modify the lint level with a crate-wide attribute:\n \n ```bash\n-> cat lib.rs\n+$ cat lib.rs\n #![warn(missing_docs)]\n \n pub fn foo() {}"}, {"sha": "d49271382b60496d7e1b69d065f5408119e4f4d8", "filename": "src/doc/unstable-book/src/language-features/used.md", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,157 +0,0 @@\n-# `used`\n-\n-The tracking issue for this feature\n-is: [40289](https://github.com/rust-lang/rust/issues/40289).\n-\n-------------------------\n-\n-The `#[used]` attribute can be applied to `static` variables to prevent the Rust\n-compiler from optimizing them away even if they appear to be unused by the crate\n-(appear to be \"dead code\").\n-\n-``` rust\n-#![feature(used)]\n-\n-#[used]\n-static FOO: i32 = 1;\n-\n-static BAR: i32 = 2;\n-\n-fn main() {}\n-```\n-\n-If you compile this program into an object file, you'll see that `FOO` makes it\n-to the object file but `BAR` doesn't. Neither static variable is used by the\n-program.\n-\n-``` text\n-$ rustc -C opt-level=3 --emit=obj used.rs\n-\n-$ nm -C used.o\n-0000000000000000 T main\n-                 U std::rt::lang_start\n-0000000000000000 r used::FOO\n-0000000000000000 t used::main\n-```\n-\n-Note that the *linker* knows nothing about the `#[used]` attribute and will\n-remove `#[used]` symbols if they are not referenced by other parts of the\n-program:\n-\n-``` text\n-$ rustc -C opt-level=3 used.rs\n-\n-$ nm -C used | grep FOO\n-```\n-\n-\"This doesn't sound too useful then!\" you may think but keep reading.\n-\n-To preserve the symbols all the way to the final binary, you'll need the\n-cooperation of the linker. Here's one example:\n-\n-The ELF standard defines two special sections, `.init_array` and\n-`.pre_init_array`, that may contain function pointers which will be executed\n-*before* the `main` function is invoked. The linker will preserve symbols placed\n-in these sections (at least when linking programs that target the `*-*-linux-*`\n-targets).\n-\n-``` rust,ignore\n-#![feature(used)]\n-\n-extern \"C\" fn before_main() {\n-    println!(\"Hello, world!\");\n-}\n-\n-#[link_section = \".init_array\"]\n-#[used]\n-static INIT_ARRAY: [extern \"C\" fn(); 1] = [before_main];\n-\n-fn main() {}\n-```\n-\n-So, `#[used]` and `#[link_section]` can be combined to obtain \"life before\n-main\".\n-\n-``` text\n-$ rustc -C opt-level=3 before-main.rs\n-\n-$ ./before-main\n-Hello, world!\n-```\n-\n-Another example: ARM Cortex-M microcontrollers need their reset handler, a\n-pointer to the function that will executed right after the microcontroller is\n-turned on, to be placed near the start of their FLASH memory to boot properly.\n-\n-This condition can be met using `#[used]` and `#[link_section]` plus a linker\n-script.\n-\n-``` rust,ignore\n-#![feature(panic_handler)]\n-#![feature(used)]\n-#![no_main]\n-#![no_std]\n-\n-use core::panic::PanicInfo;\n-\n-extern \"C\" fn reset_handler() -> ! {\n-    loop {}\n-}\n-\n-#[link_section = \".reset_handler\"]\n-#[used]\n-static RESET_HANDLER: extern \"C\" fn() -> ! = reset_handler;\n-\n-#[panic_handler]\n-fn panic(info: &PanicInfo) -> ! {\n-    loop {}\n-}\n-```\n-\n-``` text\n-MEMORY\n-{\n-  FLASH : ORIGIN = 0x08000000, LENGTH = 128K\n-  RAM : ORIGIN = 0x20000000, LENGTH = 20K\n-}\n-\n-SECTIONS\n-{\n-  .text ORIGIN(FLASH) :\n-  {\n-    /* Vector table */\n-    LONG(ORIGIN(RAM) + LENGTH(RAM)); /* initial SP value */\n-    KEEP(*(.reset_handler));\n-\n-    /* Omitted: The rest of the vector table */\n-\n-    *(.text.*);\n-  } > FLASH\n-\n-  /DISCARD/ :\n-  {\n-    /* Unused unwinding stuff */\n-    *(.ARM.exidx.*)\n-  }\n-}\n-```\n-\n-``` text\n-$ xargo rustc --target thumbv7m-none-eabi --release -- \\\n-    -C link-arg=-Tlink.x -C link-arg=-nostartfiles\n-\n-$ arm-none-eabi-objdump -Cd target/thumbv7m-none-eabi/release/app\n-./target/thumbv7m-none-eabi/release/app:     file format elf32-littlearm\n-\n-\n-Disassembly of section .text:\n-\n-08000000 <app::RESET_HANDLER-0x4>:\n- 8000000:       20005000        .word   0x20005000\n-\n-08000004 <app::RESET_HANDLER>:\n- 8000004:       08000009                                ....\n-\n-08000008 <app::reset_handler>:\n- 8000008:       e7fe            b.n     8000008 <app::reset_handler>\n-```"}, {"sha": "12da0455cc56be021cf2bf90db516db6f44e5b61", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -122,6 +122,9 @@ nonzero_integers! {\n /// all standard arithmetic operations on the underlying value are\n /// intended to have wrapping semantics.\n ///\n+/// The underlying value can be retrieved through the `.0` index of the\n+/// `Wrapping` tuple.\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "93ee11aac36b000937eb5756e7293a3df57658a7", "filename": "src/libcore/result.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -470,6 +470,36 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n+    /// Maps a `Result<T, E>` to `U` by applying a function to a\n+    /// contained [`Ok`] value, or a fallback function to a\n+    /// contained [`Err`] value.\n+    ///\n+    /// This function can be used to unpack a successful result\n+    /// while handling an error.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(result_map_or_else)]\n+    /// let k = 21;\n+    ///\n+    /// let x : Result<_, &str> = Ok(\"foo\");\n+    /// assert_eq!(x.map_or_else(|e| k * 2, |v| v.len()), 3);\n+    ///\n+    /// let x : Result<&str, _> = Err(\"bar\");\n+    /// assert_eq!(x.map_or_else(|e| k * 2, |v| v.len()), 42);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_map_or_else\", issue = \"53268\")]\n+    pub fn map_or_else<U, M: FnOnce(T) -> U, F: FnOnce(E) -> U>(self, fallback: F, map: M) -> U {\n+        self.map(map).unwrap_or_else(fallback)\n+    }\n+\n     /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n     /// contained [`Err`] value, leaving an [`Ok`] value untouched.\n     ///"}, {"sha": "1de9cd35442995ae618b1b4d630d965358751546", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -15,10 +15,6 @@\n //! function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and\n //! custom derive attributes`#[proc_macro_derive]`.\n //!\n-//! Note that this crate is intentionally bare-bones currently.\n-//! This functionality is intended to be expanded over time as more surface\n-//! area for macro authors is stabilized.\n-//!\n //! See [the book](../book/first-edition/procedural-macros.html) for more.\n \n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n@@ -73,9 +69,6 @@ use syntax_pos::{Pos, FileName};\n ///\n /// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n /// and `#[proc_macro_derive]` definitions.\n-///\n-/// The API of this type is intentionally bare-bones, but it'll be expanded over\n-/// time!\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #[derive(Clone)]\n pub struct TokenStream(tokenstream::TokenStream);"}, {"sha": "cf832aee534d4cd6c1fb6e0cbf04cfcf7d4e98d1", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -76,23 +76,38 @@ impl<'a> DefCollector<'a> {\n     fn visit_async_fn(\n         &mut self,\n         id: NodeId,\n-        async_node_id: NodeId,\n-        return_impl_trait_id: NodeId,\n         name: Name,\n         span: Span,\n-        visit_fn: impl FnOnce(&mut DefCollector<'a>)\n+        header: &FnHeader,\n+        generics: &'a Generics,\n+        decl: &'a FnDecl,\n+        body: &'a Block,\n     ) {\n+        let (closure_id, return_impl_trait_id) = match header.asyncness {\n+            IsAsync::Async {\n+                closure_id,\n+                return_impl_trait_id,\n+            } => (closure_id, return_impl_trait_id),\n+            _ => unreachable!(),\n+        };\n+\n         // For async functions, we need to create their inner defs inside of a\n         // closure to match their desugared representation.\n         let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n         let fn_def = self.create_def(id, fn_def_data, ITEM_LIKE_SPACE, span);\n         return self.with_parent(fn_def, |this| {\n             this.create_def(return_impl_trait_id, DefPathData::ImplTrait, REGULAR_SPACE, span);\n-            let closure_def = this.create_def(async_node_id,\n+\n+            visit::walk_generics(this, generics);\n+            visit::walk_fn_decl(this, decl);\n+\n+            let closure_def = this.create_def(closure_id,\n                                   DefPathData::ClosureExpr,\n                                   REGULAR_SPACE,\n                                   span);\n-            this.with_parent(closure_def, visit_fn)\n+            this.with_parent(closure_def, |this| {\n+                visit::walk_block(this, body);\n+            })\n         })\n     }\n \n@@ -122,17 +137,20 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n-            ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async {\n-                closure_id,\n-                return_impl_trait_id,\n-            }, .. }, ..) => {\n+            ItemKind::Fn(\n+                ref decl,\n+                ref header @ FnHeader { asyncness: IsAsync::Async { .. }, .. },\n+                ref generics,\n+                ref body,\n+            ) => {\n                 return self.visit_async_fn(\n                     i.id,\n-                    closure_id,\n-                    return_impl_trait_id,\n                     i.ident.name,\n                     i.span,\n-                    |this| visit::walk_item(this, i)\n+                    header,\n+                    generics,\n+                    decl,\n+                    body,\n                 )\n             }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.as_interned_str()),\n@@ -233,18 +251,17 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(MethodSig {\n-                header: FnHeader { asyncness: IsAsync::Async {\n-                    closure_id,\n-                    return_impl_trait_id,\n-                }, .. }, ..\n-            }, ..) => {\n+                header: ref header @ FnHeader { asyncness: IsAsync::Async { .. }, .. },\n+                ref decl,\n+            }, ref body) => {\n                 return self.visit_async_fn(\n                     ii.id,\n-                    closure_id,\n-                    return_impl_trait_id,\n                     ii.ident.name,\n                     ii.span,\n-                    |this| visit::walk_impl_item(this, ii)\n+                    header,\n+                    &ii.generics,\n+                    decl,\n+                    body,\n                 )\n             }\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>"}, {"sha": "5f35c9fea0a337248d24634e744a0c6b5427fe99", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -24,6 +24,7 @@ impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     mutability,\n     ty,\n+    user_ty,\n     name,\n     source_info,\n     visibility_scope,\n@@ -255,9 +256,10 @@ for mir::StatementKind<'gcx> {\n                 op.hash_stable(hcx, hasher);\n                 places.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::UserAssertTy(ref c_ty, ref local) => {\n+            mir::StatementKind::AscribeUserType(ref place, ref variance, ref c_ty) => {\n+                place.hash_stable(hcx, hasher);\n+                variance.hash_stable(hcx, hasher);\n                 c_ty.hash_stable(hcx, hasher);\n-                local.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::Nop => {}\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {"}, {"sha": "e628a3458f9e628c0ed450caae519aea28dd4d12", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 396, "deletions": 335, "changes": 731, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -10,41 +10,41 @@\n \n //! See the Book for more information.\n \n+pub use self::freshen::TypeFreshener;\n pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n pub use ty::IntVarValue;\n-pub use self::freshen::TypeFreshener;\n \n+use arena::SyncDroplessArena;\n+use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n use middle::free_region::RegionRelations;\n-use middle::region;\n use middle::lang_items;\n-use ty::subst::{Kind, Substs};\n-use ty::{TyVid, IntVid, FloatVid};\n-use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n-use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n-use ty::relate::RelateResult;\n-use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use middle::region;\n use rustc_data_structures::unify as ut;\n-use std::cell::{Cell, RefCell, Ref, RefMut};\n+use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n-use errors::DiagnosticBuilder;\n-use syntax_pos::{self, Span};\n use syntax_pos::symbol::InternedString;\n+use syntax_pos::{self, Span};\n+use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use ty::fold::TypeFoldable;\n+use ty::relate::RelateResult;\n+use ty::subst::{Kind, Substs};\n+use ty::{self, GenericParamDefKind, Ty, TyCtxt};\n+use ty::{FloatVid, IntVid, TyVid};\n use util::nodemap::FxHashMap;\n-use arena::SyncDroplessArena;\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n-use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarInfos};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n+use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n+use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n@@ -54,16 +54,16 @@ pub mod canonical;\n mod combine;\n mod equate;\n pub mod error_reporting;\n+mod freshen;\n mod fudge;\n mod glb;\n mod higher_ranked;\n pub mod lattice;\n-mod lub;\n-pub mod region_constraints;\n mod lexical_region_resolve;\n+mod lub;\n pub mod outlives;\n+pub mod region_constraints;\n pub mod resolve;\n-mod freshen;\n mod sub;\n pub mod type_variable;\n pub mod unify_key;\n@@ -80,7 +80,7 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     /// During type-checking/inference of a body, `in_progress_tables`\n@@ -314,10 +314,10 @@ pub enum SubregionOrigin<'tcx> {\n /// Places that type/region parameters can appear.\n #[derive(Clone, Copy, Debug)]\n pub enum ParameterOrigin {\n-    Path, // foo::bar\n-    MethodCall, // foo.bar() <-- parameters on impl providing bar()\n+    Path,               // foo::bar\n+    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n     OverloadedOperator, // a + b when overloaded\n-    OverloadedDeref, // *a when overloaded\n+    OverloadedDeref,    // *a when overloaded\n }\n \n /// Times when we replace late-bound regions with variables:\n@@ -400,7 +400,7 @@ impl NLLRegionVariableOrigin {\n pub enum FixupError {\n     UnresolvedIntTy(IntVid),\n     UnresolvedFloatTy(FloatVid),\n-    UnresolvedTy(TyVid)\n+    UnresolvedTy(TyVid),\n }\n \n /// See the `region_obligations` field for more information.\n@@ -416,23 +416,25 @@ impl fmt::Display for FixupError {\n         use self::FixupError::*;\n \n         match *self {\n-            UnresolvedIntTy(_) => {\n-                write!(f, \"cannot determine the type of this integer; \\\n-                           add a suffix to specify the type explicitly\")\n-            }\n-            UnresolvedFloatTy(_) => {\n-                write!(f, \"cannot determine the type of this number; \\\n-                           add a suffix to specify the type explicitly\")\n-            }\n-            UnresolvedTy(_) => write!(f, \"unconstrained type\")\n+            UnresolvedIntTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this integer; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedFloatTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this number; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n         }\n     }\n }\n \n /// Helper type of a temporary returned by tcx.infer_ctxt().\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n-pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n@@ -444,7 +446,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             global_tcx: self,\n             arena: SyncDroplessArena::new(),\n             fresh_tables: None,\n-\n         }\n     }\n }\n@@ -458,48 +459,60 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n-        where F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R,\n     {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref arena,\n             ref fresh_tables,\n         } = *self;\n         let in_progress_tables = fresh_tables.as_ref();\n-        global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n-            tcx,\n-            in_progress_tables,\n-            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-            int_unification_table: RefCell::new(ut::UnificationTable::new()),\n-            float_unification_table: RefCell::new(ut::UnificationTable::new()),\n-            region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n-            lexical_region_resolutions: RefCell::new(None),\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n-            reported_trait_errors: RefCell::new(FxHashMap()),\n-            tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: tcx.sess.err_count(),\n-            in_snapshot: Cell::new(false),\n-            region_obligations: RefCell::new(vec![]),\n-            universe: Cell::new(ty::UniverseIndex::ROOT),\n-        }))\n+        global_tcx.enter_local(arena, |tcx| {\n+            f(InferCtxt {\n+                tcx,\n+                in_progress_tables,\n+                projection_cache: RefCell::new(traits::ProjectionCache::new()),\n+                type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+                int_unification_table: RefCell::new(ut::UnificationTable::new()),\n+                float_unification_table: RefCell::new(ut::UnificationTable::new()),\n+                region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n+                lexical_region_resolutions: RefCell::new(None),\n+                selection_cache: traits::SelectionCache::new(),\n+                evaluation_cache: traits::EvaluationCache::new(),\n+                reported_trait_errors: RefCell::new(FxHashMap()),\n+                tainted_by_errors_flag: Cell::new(false),\n+                err_count_on_creation: tcx.sess.err_count(),\n+                in_snapshot: Cell::new(false),\n+                region_obligations: RefCell::new(vec![]),\n+                universe: Cell::new(ty::UniverseIndex::ROOT),\n+            })\n+        })\n     }\n }\n \n impl<T> ExpectedFound<T> {\n     pub fn new(a_is_expected: bool, a: T, b: T) -> Self {\n         if a_is_expected {\n-            ExpectedFound {expected: a, found: b}\n+            ExpectedFound {\n+                expected: a,\n+                found: b,\n+            }\n         } else {\n-            ExpectedFound {expected: b, found: a}\n+            ExpectedFound {\n+                expected: b,\n+                found: a,\n+            }\n         }\n     }\n }\n \n impl<'tcx, T> InferOk<'tcx, T> {\n     pub fn unit(self) -> InferOk<'tcx, ()> {\n-        InferOk { value: (), obligations: self.obligations }\n+        InferOk {\n+            value: (),\n+            obligations: self.obligations,\n+        }\n     }\n \n     /// Extract `value`, registering any obligations into `fulfill_cx`\n@@ -523,7 +536,7 @@ impl<'tcx> InferOk<'tcx, ()> {\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot<'a, 'tcx:'a> {\n+pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n     int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n@@ -540,14 +553,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.get()\n     }\n \n-    pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n+    pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n         match ty.sty {\n             ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -557,22 +570,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty) -> UnconstrainedNumeric {\n         use ty::error::UnconstrainedNumeric::Neither;\n-        use ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n+        use ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.sty {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.int_unification_table\n+                    .borrow_mut()\n+                    .probe_value(vid)\n+                    .is_some()\n+                {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n-            },\n+            }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.float_unification_table\n+                    .borrow_mut()\n+                    .probe_value(vid)\n+                    .is_some()\n+                {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n                 }\n-            },\n+            }\n             _ => Neither,\n         }\n     }\n@@ -590,17 +611,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (0..int_unification_table.len())\n                     .map(|i| ty::IntVid { index: i as u32 })\n                     .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_int_var(v))\n-            ).chain(\n+                    .map(|v| self.tcx.mk_int_var(v)),\n+            )\n+            .chain(\n                 (0..float_unification_table.len())\n                     .map(|i| ty::FloatVid { index: i as u32 })\n                     .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_float_var(v))\n-            ).collect()\n+                    .map(|v| self.tcx.mk_float_var(v)),\n+            )\n+            .collect()\n     }\n \n-    fn combine_fields(&'a self, trace: TypeTrace<'tcx>, param_env: ty::ParamEnv<'tcx>)\n-                      -> CombineFields<'a, 'gcx, 'tcx> {\n+    fn combine_fields(\n+        &'a self,\n+        trace: TypeTrace<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n@@ -627,7 +653,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // escaping obligations in the main cx. In those cases, you can\n     // use this function.\n     pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-        where F: FnOnce(&Self) -> R\n+    where\n+        F: FnOnce(&Self) -> R,\n     {\n         let flag = self.in_snapshot.get();\n         self.in_snapshot.set(false);\n@@ -653,33 +680,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n-            _in_progress_tables: self.in_progress_tables.map(|tables| {\n-                tables.borrow()\n-            })\n+            _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n         }\n     }\n \n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_constraints_snapshot,\n-                               region_obligations_snapshot,\n-                               universe,\n-                               was_in_snapshot,\n-                               _in_progress_tables } = snapshot;\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot,\n+            universe,\n+            was_in_snapshot,\n+            _in_progress_tables,\n+        } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n \n         self.projection_cache\n             .borrow_mut()\n             .rollback_to(projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .rollback_to(type_snapshot);\n+        self.type_variables.borrow_mut().rollback_to(type_snapshot);\n         self.int_unification_table\n             .borrow_mut()\n             .rollback_to(int_snapshot);\n@@ -695,27 +720,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_constraints_snapshot,\n-                               region_obligations_snapshot: _,\n-                               universe: _,\n-                               was_in_snapshot,\n-                               _in_progress_tables } = snapshot;\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot: _,\n+            universe: _,\n+            was_in_snapshot,\n+            _in_progress_tables,\n+        } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n \n         self.projection_cache\n             .borrow_mut()\n             .commit(&projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .commit(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .commit(int_snapshot);\n+        self.type_variables.borrow_mut().commit(type_snapshot);\n+        self.int_unification_table.borrow_mut().commit(int_snapshot);\n         self.float_unification_table\n             .borrow_mut()\n             .commit(float_snapshot);\n@@ -724,7 +747,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings\n-    pub fn commit_unconditionally<R, F>(&self, f: F) -> R where\n+    pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n+    where\n         F: FnOnce() -> R,\n     {\n         debug!(\"commit()\");\n@@ -735,23 +759,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n-    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>\n+    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n     {\n         debug!(\"commit_if_ok()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n         debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n-            Ok(_) => { self.commit_from(snapshot); }\n-            Err(_) => { self.rollback_to(\"commit_if_ok -- error\", snapshot); }\n+            Ok(_) => {\n+                self.commit_from(snapshot);\n+            }\n+            Err(_) => {\n+                self.rollback_to(\"commit_if_ok -- error\", snapshot);\n+            }\n         }\n         r\n     }\n \n     // Execute `f` in a snapshot, and commit the bindings it creates\n-    pub fn in_snapshot<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T\n+    pub fn in_snapshot<T, F>(&self, f: F) -> T\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T,\n     {\n         debug!(\"in_snapshot()\");\n         let snapshot = self.start_snapshot();\n@@ -761,7 +791,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<R, F>(&self, f: F) -> R where\n+    pub fn probe<R, F>(&self, f: F) -> R\n+    where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n         debug!(\"probe()\");\n@@ -771,59 +802,57 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    pub fn add_given(&self,\n-                     sub: ty::Region<'tcx>,\n-                     sup: ty::RegionVid)\n-    {\n+    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n         self.borrow_region_constraints().add_given(sub, sup);\n     }\n \n-    pub fn can_sub<T>(&self,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      a: T,\n-                      b: T)\n-                      -> UnitResult<'tcx>\n-        where T: at::ToTrace<'tcx>\n+    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n+            self.at(origin, param_env)\n+                .sub(a, b)\n+                .map(|InferOk { obligations: _, .. }| {\n+                    // Ignore obligations, since we are unrolling\n+                    // everything anyway.\n+                })\n         })\n     }\n \n-    pub fn can_eq<T>(&self,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      a: T,\n-                      b: T)\n-                      -> UnitResult<'tcx>\n-        where T: at::ToTrace<'tcx>\n+    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n+            self.at(origin, param_env)\n+                .eq(a, b)\n+                .map(|InferOk { obligations: _, .. }| {\n+                    // Ignore obligations, since we are unrolling\n+                    // everything anyway.\n+                })\n         })\n     }\n \n-    pub fn sub_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: ty::Region<'tcx>,\n-                       b: ty::Region<'tcx>) {\n+    pub fn sub_regions(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.borrow_region_constraints()\n+            .make_subregion(origin, a, b);\n     }\n \n-    pub fn subtype_predicate(&self,\n-                             cause: &ObligationCause<'tcx>,\n-                             param_env: ty::ParamEnv<'tcx>,\n-                             predicate: &ty::PolySubtypePredicate<'tcx>)\n-        -> Option<InferResult<'tcx, ()>>\n-    {\n+    pub fn subtype_predicate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: &ty::PolySubtypePredicate<'tcx>,\n+    ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n         // `shallow_resolve` just ignores anything that is not a type\n         // variable, and because type variable's can't (at present, at\n@@ -845,8 +874,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         Some(self.commit_if_ok(|snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b}, skol_map) =\n-                self.skolemize_late_bound_regions(predicate);\n+            let (\n+                ty::SubtypePredicate {\n+                    a_is_expected,\n+                    a,\n+                    b,\n+                },\n+                skol_map,\n+            ) = self.skolemize_late_bound_regions(predicate);\n \n             let cause_span = cause.span;\n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n@@ -856,17 +891,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }))\n     }\n \n-    pub fn region_outlives_predicate(&self,\n-                                     cause: &traits::ObligationCause<'tcx>,\n-                                     predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n-        -> UnitResult<'tcx>\n-    {\n+    pub fn region_outlives_predicate(\n+        &self,\n+        cause: &traits::ObligationCause<'tcx>,\n+        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n+    ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate);\n-            let origin =\n-                SubregionOrigin::from_obligation_cause(cause,\n-                                                       || RelateRegionParamBound(cause.span));\n+            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n+                RelateRegionParamBound(cause.span)\n+            });\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n             self.leak_check(false, cause.span, &skol_map, snapshot)?;\n             Ok(self.pop_skolemized(skol_map, snapshot))\n@@ -888,27 +923,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n-        self.int_unification_table\n-            .borrow_mut()\n-            .new_key(None)\n+        self.int_unification_table.borrow_mut().new_key(None)\n     }\n \n     pub fn next_float_var_id(&self) -> FloatVid {\n-        self.float_unification_table\n-            .borrow_mut()\n-            .new_key(None)\n+        self.float_unification_table.borrow_mut().new_key(None)\n     }\n \n     /// Create a fresh region variable with the next available index.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `origin`: information about why we created this variable, for use\n-    ///   during diagnostics / error-reporting.\n-    pub fn next_region_var(&self, origin: RegionVariableOrigin)\n-                           -> ty::Region<'tcx> {\n+    /// The variable will be created in the maximum universe created\n+    /// thus far, allowing it to name any region created thus far.\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n+        self.next_region_var_in_universe(origin, self.universe())\n+    }\n+\n+    /// Create a fresh region variable with the next available index\n+    /// in the given universe; typically, you can use\n+    /// `next_region_var` and just use the maximal universe.\n+    pub fn next_region_var_in_universe(\n+        &self,\n+        origin: RegionVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> ty::Region<'tcx> {\n         let region_var = self.borrow_region_constraints()\n-            .new_region_var(self.universe(), origin);\n+            .new_region_var(universe, origin);\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n@@ -918,22 +956,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n-                               -> ty::Region<'tcx> {\n+    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var(RegionVariableOrigin::NLL(origin))\n     }\n \n-    pub fn var_for_def(&self,\n-                       span: Span,\n-                       param: &ty::GenericParamDef)\n-                       -> Kind<'tcx> {\n+    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    pub fn next_nll_region_var_in_universe(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> ty::Region<'tcx> {\n+        self.next_region_var_in_universe(RegionVariableOrigin::NLL(origin), universe)\n+    }\n+\n+    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> Kind<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 // Create a region inference variable for the given\n                 // region parameter definition.\n-                self.next_region_var(EarlyBoundRegion(span, param.name)).into()\n+                self.next_region_var(EarlyBoundRegion(span, param.name))\n+                    .into()\n             }\n-            GenericParamDefKind::Type {..} => {\n+            GenericParamDefKind::Type { .. } => {\n                 // Create a type inference variable for the given\n                 // type parameter definition. The substitutions are\n                 // for actual parameters that may be referred to by\n@@ -942,12 +986,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id =\n-                    self.type_variables\n-                        .borrow_mut()\n-                        .new_var(self.universe(),\n-                                    false,\n-                                    TypeVariableOrigin::TypeParameterDefinition(span, param.name));\n+                let ty_var_id = self.type_variables.borrow_mut().new_var(\n+                    self.universe(),\n+                    false,\n+                    TypeVariableOrigin::TypeParameterDefinition(span, param.name),\n+                );\n \n                 self.tcx.mk_var(ty_var_id).into()\n             }\n@@ -956,13 +999,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_item(&self,\n-                                 span: Span,\n-                                 def_id: DefId)\n-                                 -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx, def_id, |param, _| {\n-            self.var_for_def(span, param)\n-        })\n+    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n     }\n \n     /// True if errors have been reported since this infcx was\n@@ -971,11 +1009,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n     pub fn is_tainted_by_errors(&self) -> bool {\n-        debug!(\"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n-                tainted_by_errors_flag={})\",\n-               self.tcx.sess.err_count(),\n-               self.err_count_on_creation,\n-               self.tainted_by_errors_flag.get());\n+        debug!(\n+            \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n+             tainted_by_errors_flag={})\",\n+            self.tcx.sess.err_count(),\n+            self.err_count_on_creation,\n+            self.tainted_by_errors_flag.get()\n+        );\n \n         if self.tcx.sess.err_count() > self.err_count_on_creation {\n             return true; // errors reported since this infcx was made\n@@ -1018,12 +1058,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n     ) {\n-        self.resolve_regions_and_report_errors_inner(\n-            region_context,\n-            region_map,\n-            outlives_env,\n-            true,\n-        )\n+        self.resolve_regions_and_report_errors_inner(region_context, region_map, outlives_env, true)\n     }\n \n     fn resolve_regions_and_report_errors_inner(\n@@ -1033,22 +1068,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         will_later_be_reported_by_nll: bool,\n     ) {\n-        assert!(self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                self.region_obligations.borrow());\n-\n-        let region_rels = &RegionRelations::new(self.tcx,\n-                                                region_context,\n-                                                region_map,\n-                                                outlives_env.free_region_map());\n-        let (var_infos, data) = self.region_constraints.borrow_mut()\n-                                                         .take()\n-                                                         .expect(\"regions already resolved\")\n-                                                         .into_infos_and_data();\n+        assert!(\n+            self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.region_obligations.borrow()\n+        );\n+\n+        let region_rels = &RegionRelations::new(\n+            self.tcx,\n+            region_context,\n+            region_map,\n+            outlives_env.free_region_map(),\n+        );\n+        let (var_infos, data) = self.region_constraints\n+            .borrow_mut()\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n         let (lexical_region_resolutions, errors) =\n             lexical_region_resolve::resolve(region_rels, var_infos, data);\n \n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        let old_value = self.lexical_region_resolutions\n+            .replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n \n         if !self.is_tainted_by_errors() {\n@@ -1072,9 +1113,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// translate them into the form that the NLL solver\n     /// understands. See the NLL module for mode details.\n     pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(self.region_obligations.borrow().is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                self.region_obligations.borrow());\n+        assert!(\n+            self.region_obligations.borrow().is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.region_obligations.borrow()\n+        );\n \n         self.borrow_region_constraints().take_and_reset_data()\n     }\n@@ -1095,10 +1138,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region vairables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n-        let (var_infos, data) = self.region_constraints.borrow_mut()\n-                                                         .take()\n-                                                         .expect(\"regions already resolved\")\n-                                                         .into_infos_and_data();\n+        let (var_infos, data) = self.region_constraints\n+            .borrow_mut()\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n         assert!(data.is_empty());\n         var_infos\n     }\n@@ -1132,32 +1176,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n-                self.type_variables.borrow_mut()\n-                                   .probe(v)\n-                                   .known()\n-                                   .map(|t| self.shallow_resolve(t))\n-                                   .unwrap_or(typ)\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => {\n-                self.int_unification_table\n+                self.type_variables\n                     .borrow_mut()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(self.tcx))\n+                    .probe(v)\n+                    .known()\n+                    .map(|t| self.shallow_resolve(t))\n                     .unwrap_or(typ)\n             }\n \n-            ty::Infer(ty::FloatVar(v)) => {\n-                self.float_unification_table\n-                    .borrow_mut()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(self.tcx))\n-                    .unwrap_or(typ)\n-            }\n+            ty::Infer(ty::IntVar(v)) => self.int_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.tcx))\n+                .unwrap_or(typ),\n \n-            _ => {\n-                typ\n-            }\n+            ty::Infer(ty::FloatVar(v)) => self.float_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.tcx))\n+                .unwrap_or(typ),\n+\n+            _ => typ,\n         }\n     }\n \n@@ -1166,7 +1205,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         /*!\n          * Where possible, replaces type/int/float variables in\n@@ -1190,20 +1230,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// resolved type, so it's more efficient than\n     /// `resolve_type_vars_if_possible()`.\n     pub fn any_unresolved_type_vars<T>(&self, value: &T) -> bool\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let mut r = resolve::UnresolvedTypeFinder::new(self);\n         value.visit_with(&mut r)\n     }\n \n     pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let mut r = resolve::OpportunisticTypeAndRegionResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n-    pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n+    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n          * `value`. Region inference must have been run already (e.g.,\n@@ -1228,12 +1270,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // types using one of these methods, and should not call span_err directly for such\n     // errors.\n \n-    pub fn type_error_struct_with_diag<M>(&self,\n-                                          sp: Span,\n-                                          mk_diag: M,\n-                                          actual_ty: Ty<'tcx>)\n-                                          -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n+    pub fn type_error_struct_with_diag<M>(\n+        &self,\n+        sp: Span,\n+        mk_diag: M,\n+        actual_ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx>\n+    where\n+        M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n@@ -1246,12 +1290,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         mk_diag(self.ty_to_string(actual_ty))\n     }\n \n-    pub fn report_mismatched_types(&self,\n-                                   cause: &ObligationCause<'tcx>,\n-                                   expected: Ty<'tcx>,\n-                                   actual: Ty<'tcx>,\n-                                   err: TypeError<'tcx>)\n-                                   -> DiagnosticBuilder<'tcx> {\n+    pub fn report_mismatched_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err)\n     }\n@@ -1260,13 +1305,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: &ty::Binder<T>)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-        where T : TypeFoldable<'tcx>\n+        value: &ty::Binder<T>,\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n-        self.tcx.replace_late_bound_regions(\n-            value,\n-            |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n+        self.tcx.replace_late_bound_regions(value, |br| {\n+            self.next_region_var(LateBoundRegion(span, br, lbrct))\n+        })\n     }\n \n     /// Given a higher-ranked projection predicate like:\n@@ -1284,43 +1330,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n     /// details.\n-    pub fn match_poly_projection_predicate(&self,\n-                                           cause: ObligationCause<'tcx>,\n-                                           param_env: ty::ParamEnv<'tcx>,\n-                                           match_a: ty::PolyProjectionPredicate<'tcx>,\n-                                           match_b: ty::TraitRef<'tcx>)\n-                                           -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n-    {\n+    pub fn match_poly_projection_predicate(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        match_a: ty::PolyProjectionPredicate<'tcx>,\n+        match_b: ty::TraitRef<'tcx>,\n+    ) -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>> {\n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n         let trace = TypeTrace {\n             cause,\n-            values: TraitRefs(ExpectedFound::new(true, match_pair.skip_binder().0, match_b))\n+            values: TraitRefs(ExpectedFound::new(\n+                true,\n+                match_pair.skip_binder().0,\n+                match_b,\n+            )),\n         };\n \n         let mut combine = self.combine_fields(trace, param_env);\n         let result = combine.higher_ranked_match(&match_pair, &match_b, true)?;\n-        Ok(InferOk { value: result, obligations: combine.obligations })\n+        Ok(InferOk {\n+            value: result,\n+            obligations: combine.obligations,\n+        })\n     }\n \n     /// See `verify_generic_bound` method in `region_constraints`\n-    pub fn verify_generic_bound(&self,\n-                                origin: SubregionOrigin<'tcx>,\n-                                kind: GenericKind<'tcx>,\n-                                a: ty::Region<'tcx>,\n-                                bound: VerifyBound<'tcx>) {\n-        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n-               kind,\n-               a,\n-               bound);\n-\n-        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n-    }\n-\n-    pub fn type_moves_by_default(&self,\n-                                 param_env: ty::ParamEnv<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 span: Span)\n-                                 -> bool {\n+    pub fn verify_generic_bound(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n+\n+        self.borrow_region_constraints()\n+            .verify_generic_bound(origin, kind, a, bound);\n+    }\n+\n+    pub fn type_moves_by_default(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only.\n@@ -1342,11 +1396,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Obtains the latest type of the given closure; this may be a\n     /// closure in the current function, in which case its\n     /// `ClosureKind` may not yet be known.\n-    pub fn closure_kind(&self,\n-                        closure_def_id: DefId,\n-                        closure_substs: ty::ClosureSubsts<'tcx>)\n-                        -> Option<ty::ClosureKind>\n-    {\n+    pub fn closure_kind(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    ) -> Option<ty::ClosureKind> {\n         let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n         let closure_kind_ty = self.shallow_resolve(&closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n@@ -1359,7 +1413,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_sig(\n         &self,\n         def_id: DefId,\n-        substs: ty::ClosureSubsts<'tcx>\n+        substs: ty::ClosureSubsts<'tcx>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n         let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n@@ -1368,29 +1422,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Normalizes associated types in `value`, potentially returning\n     /// new obligations that must further be processed.\n-    pub fn partially_normalize_associated_types_in<T>(&self,\n-                                                      span: Span,\n-                                                      body_id: ast::NodeId,\n-                                                      param_env: ty::ParamEnv<'tcx>,\n-                                                      value: &T)\n-                                                      -> InferOk<'tcx, T>\n-        where T : TypeFoldable<'tcx>\n+    pub fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: ast::NodeId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = ObligationCause::misc(span, body_id);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value,\n-            obligations);\n+        debug!(\n+            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value, obligations\n+        );\n         InferOk { value, obligations }\n     }\n \n     pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n-        RefMut::map(\n-            self.region_constraints.borrow_mut(),\n-            |c| c.as_mut().expect(\"region constraints already solved\"))\n+        RefMut::map(self.region_constraints.borrow_mut(), |c| {\n+            c.as_mut().expect(\"region constraints already solved\")\n+        })\n     }\n \n     /// Clears the selection, evaluation, and projection cachesThis is useful when\n@@ -1423,14 +1480,15 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n         self.cause.span\n     }\n \n-    pub fn types(cause: &ObligationCause<'tcx>,\n-                 a_is_expected: bool,\n-                 a: Ty<'tcx>,\n-                 b: Ty<'tcx>)\n-                 -> TypeTrace<'tcx> {\n+    pub fn types(\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+    ) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: cause.clone(),\n-            values: Types(ExpectedFound::new(a_is_expected, a, b))\n+            values: Types(ExpectedFound::new(a_is_expected, a, b)),\n         }\n     }\n \n@@ -1440,7 +1498,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n             values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n-            })\n+            }),\n         }\n     }\n }\n@@ -1482,24 +1540,25 @@ impl<'tcx> SubregionOrigin<'tcx> {\n         }\n     }\n \n-    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>,\n-                                    default: F)\n-                                    -> Self\n-        where F: FnOnce() -> Self\n+    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>, default: F) -> Self\n+    where\n+        F: FnOnce() -> Self,\n     {\n         match cause.code {\n-            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n-                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span),\n-\n-            traits::ObligationCauseCode::CompareImplMethodObligation { item_name,\n-                                                                       impl_item_def_id,\n-                                                                       trait_item_def_id, } =>\n-                SubregionOrigin::CompareImplMethodObligation {\n-                    span: cause.span,\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                },\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {\n+                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n+            }\n+\n+            traits::ObligationCauseCode::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => SubregionOrigin::CompareImplMethodObligation {\n+                span: cause.span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            },\n \n             _ => default(),\n         }\n@@ -1534,8 +1593,10 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-               self.sub_region,\n-               self.sup_type)\n+        write!(\n+            f,\n+            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+            self.sub_region, self.sup_type\n+        )\n     }\n }"}, {"sha": "e22792305a0532c4991c03e67b69a621dfdf7550", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1117,6 +1117,13 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     }\n \n     fn visit_mac(&mut self, mac: &'a ast::Mac) {\n+        // FIXME(#54110): So, this setup isn't really right. I think\n+        // that (a) the libsyntax visitor ought to be doing this as\n+        // part of `walk_mac`, and (b) we should be calling\n+        // `visit_path`, *but* that would require a `NodeId`, and I\n+        // want to get #53686 fixed quickly. -nmatsakis\n+        ast_visit::walk_path(self, &mac.node.path);\n+\n         run_lints!(self, check_mac, mac);\n     }\n }"}, {"sha": "8d2851d1b77442403e9604969d22e8c8dcc6cf4d", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -53,7 +53,7 @@ use ty::query::Providers;\n use util::nodemap::NodeMap;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n-                        check_crate, check_ast_crate,\n+                        check_crate, check_ast_crate, CheckLintNameResult,\n                         FutureIncompatibleInfo, BufferedEarlyLint};\n \n /// Specification of a single lint."}, {"sha": "3450eec8082f37a2bf9885173b7cf438c50c697e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -640,6 +640,12 @@ pub struct LocalDecl<'tcx> {\n     /// Type of this local.\n     pub ty: Ty<'tcx>,\n \n+    /// If the user manually ascribed a type to this variable,\n+    /// e.g. via `let x: T`, then we carry that type here. The MIR\n+    /// borrow checker needs this information since it can affect\n+    /// region inference.\n+    pub user_ty: Option<CanonicalTy<'tcx>>,\n+\n     /// Name of the local, used in debuginfo and pretty-printing.\n     ///\n     /// Note that function arguments can also have this set to `Some(_)`\n@@ -802,6 +808,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         LocalDecl {\n             mutability,\n             ty,\n+            user_ty: None,\n             name: None,\n             source_info: SourceInfo {\n                 span,\n@@ -821,6 +828,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         LocalDecl {\n             mutability: Mutability::Mut,\n             ty: return_ty,\n+            user_ty: None,\n             source_info: SourceInfo {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE,\n@@ -1636,22 +1644,19 @@ pub enum StatementKind<'tcx> {\n     /// (The starting point(s) arise implicitly from borrows.)\n     EndRegion(region::Scope),\n \n-    /// Encodes a user's type assertion. These need to be preserved intact so that NLL can respect\n-    /// them. For example:\n-    ///\n-    ///     let (a, b): (T, U) = y;\n-    ///\n-    /// Here we would insert a `UserAssertTy<(T, U)>(y)` instruction to check that the type of `y`\n-    /// is the right thing.\n+    /// Encodes a user's type ascription. These need to be preserved\n+    /// intact so that NLL can respect them. For example:\n     ///\n-    /// `CanonicalTy` is used to capture \"inference variables\" from the user's types. For example:\n+    ///     let a: T = y;\n     ///\n-    ///     let x: Vec<_> = ...;\n-    ///     let y: &u32 = ...;\n+    /// The effect of this annotation is to relate the type `T_y` of the place `y`\n+    /// to the user-given type `T`. The effect depends on the specified variance:\n     ///\n-    /// would result in `Vec<?0>` and `&'?0 u32` respectively (where `?0` is a canonicalized\n-    /// variable).\n-    UserAssertTy(CanonicalTy<'tcx>, Local),\n+    /// - `Covariant` -- requires that `T_y <: T`\n+    /// - `Contravariant` -- requires that `T_y :> T`\n+    /// - `Invariant` -- requires that `T_y == T`\n+    /// - `Bivariant` -- no effect\n+    AscribeUserType(Place<'tcx>, ty::Variance, CanonicalTy<'tcx>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -1728,8 +1733,8 @@ impl<'tcx> Debug for Statement<'tcx> {\n                 ref outputs,\n                 ref inputs,\n             } => write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs),\n-            UserAssertTy(ref c_ty, ref local) => {\n-                write!(fmt, \"UserAssertTy({:?}, {:?})\", c_ty, local)\n+            AscribeUserType(ref place, ref variance, ref c_ty) => {\n+                write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n             Nop => write!(fmt, \"nop\"),\n         }\n@@ -2616,6 +2621,7 @@ BraceStructTypeFoldableImpl! {\n         is_user_variable,\n         internal,\n         ty,\n+        user_ty,\n         name,\n         source_info,\n         visibility_scope,\n@@ -2652,7 +2658,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n         (StatementKind::Validate)(a, b),\n         (StatementKind::EndRegion)(a),\n-        (StatementKind::UserAssertTy)(a, b),\n+        (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),\n     }\n }"}, {"sha": "0beb5ac0a3cb51e42e9e053a2f751b264ae11715", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -144,11 +144,12 @@ macro_rules! make_mir_visitor {\n                 self.super_operand(operand, location);\n             }\n \n-            fn visit_user_assert_ty(&mut self,\n-                                    c_ty: & $($mutability)* CanonicalTy<'tcx>,\n-                                    local: & $($mutability)* Local,\n-                                    location: Location) {\n-                self.super_user_assert_ty(c_ty, local, location);\n+            fn visit_ascribe_user_ty(&mut self,\n+                                     place: & $($mutability)* Place<'tcx>,\n+                                     variance: & $($mutability)* ty::Variance,\n+                                     c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                     location: Location) {\n+                self.super_ascribe_user_ty(place, variance, c_ty, location);\n             }\n \n             fn visit_place(&mut self,\n@@ -386,9 +387,12 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(input, location);\n                         }\n                     }\n-                    StatementKind::UserAssertTy(ref $($mutability)* c_ty,\n-                                                ref $($mutability)* local) => {\n-                        self.visit_user_assert_ty(c_ty, local, location);\n+                    StatementKind::AscribeUserType(\n+                        ref $($mutability)* place,\n+                        ref $($mutability)* variance,\n+                        ref $($mutability)* c_ty,\n+                    ) => {\n+                        self.visit_ascribe_user_ty(place, variance, c_ty, location);\n                     }\n                     StatementKind::Nop => {}\n                 }\n@@ -629,12 +633,13 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_user_assert_ty(&mut self,\n-                                    c_ty: & $($mutability)* CanonicalTy<'tcx>,\n-                                    local: & $($mutability)* Local,\n-                                    location: Location) {\n+            fn super_ascribe_user_ty(&mut self,\n+                                     place: & $($mutability)* Place<'tcx>,\n+                                     _variance: & $($mutability)* ty::Variance,\n+                                     c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                     location: Location) {\n+                self.visit_place(place, PlaceContext::Validate, location);\n                 self.visit_canonical_ty(c_ty);\n-                self.visit_local(local, PlaceContext::Validate, location);\n             }\n \n             fn super_place(&mut self,\n@@ -716,6 +721,7 @@ macro_rules! make_mir_visitor {\n                 let LocalDecl {\n                     mutability: _,\n                     ref $($mutability)* ty,\n+                    ref $($mutability)* user_ty,\n                     name: _,\n                     ref $($mutability)* source_info,\n                     ref $($mutability)* visibility_scope,\n@@ -727,6 +733,9 @@ macro_rules! make_mir_visitor {\n                     local,\n                     source_info: *source_info,\n                 });\n+                if let Some(user_ty) = user_ty {\n+                    self.visit_canonical_ty(user_ty);\n+                }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n             }"}, {"sha": "6cc648b572c24e7de0c1465e6326a93840c9ed6a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -356,8 +356,8 @@ pub struct TypeckTables<'tcx> {\n     /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n     field_indices: ItemLocalMap<usize>,\n \n-    /// Stores the canonicalized types provided by the user. See also `UserAssertTy` statement in\n-    /// MIR.\n+    /// Stores the canonicalized types provided by the user. See also\n+    /// `AscribeUserType` statement in MIR.\n     user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table"}, {"sha": "bd9dfc6b855144c0c7ea794eaa5aa1945f706f05", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -57,6 +57,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::ty::ClosureKind,\n     ::ty::IntVarValue,\n     ::ty::ParamTy,\n+    ::ty::Variance,\n     ::syntax_pos::Span,\n }\n "}, {"sha": "696c4d0043c14993dd374c9c10fc943d339174cc", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -42,7 +42,7 @@ const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord)]\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n@@ -74,17 +74,7 @@ impl<'tcx> UnpackedKind<'tcx> {\n \n impl<'tcx> Ord for Kind<'tcx> {\n     fn cmp(&self, other: &Kind) -> Ordering {\n-        match (self.unpack(), other.unpack()) {\n-            (UnpackedKind::Type(_), UnpackedKind::Lifetime(_)) => Ordering::Greater,\n-\n-            (UnpackedKind::Type(ty1), UnpackedKind::Type(ty2)) => {\n-                ty1.sty.cmp(&ty2.sty)\n-            }\n-\n-            (UnpackedKind::Lifetime(reg1), UnpackedKind::Lifetime(reg2)) => reg1.cmp(reg2),\n-\n-            (UnpackedKind::Lifetime(_), UnpackedKind::Type(_))  => Ordering::Less,\n-        }\n+        self.unpack().cmp(&other.unpack())\n     }\n }\n "}, {"sha": "51380db5b23df295c4f1125e5d12a3ec8f7d4c22", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::Session;\n use rustc::session::config::Sanitizer;\n use rustc::ty::TyCtxt;\n+use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::query::Providers;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::FxHashMap;\n@@ -32,12 +33,16 @@ use value::Value;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n-pub fn inline(val: &'ll Value, inline: InlineAttr) {\n+pub fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n         Hint   => Attribute::InlineHint.apply_llfn(Function, val),\n         Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n-        Never  => Attribute::NoInline.apply_llfn(Function, val),\n+        Never  => {\n+            if cx.tcx().sess.target.target.arch != \"amdgpu\" {\n+                Attribute::NoInline.apply_llfn(Function, val);\n+            }\n+        },\n         None   => {\n             Attribute::InlineHint.unapply_llfn(Function, val);\n             Attribute::AlwaysInline.unapply_llfn(Function, val);\n@@ -143,7 +148,7 @@ pub fn from_fn_attrs(\n     let codegen_fn_attrs = id.map(|id| cx.tcx.codegen_fn_attrs(id))\n         .unwrap_or(CodegenFnAttrs::new());\n \n-    inline(llfn, codegen_fn_attrs.inline);\n+    inline(cx, llfn, codegen_fn_attrs.inline);\n \n     // The `uwtable` attribute according to LLVM is:\n     //"}, {"sha": "e3526a5a2eead0888bb2b4e065a096ff84baa4bf", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -496,6 +496,14 @@ impl Builder<'a, 'll, 'tcx> {\n \n \n     pub fn range_metadata(&self, load: &'ll Value, range: Range<u128>) {\n+        if self.sess().target.target.arch == \"amdgpu\" {\n+            // amdgpu/LLVM does something weird and thinks a i64 value is\n+            // split into a v2i32, halving the bitwidth LLVM expects,\n+            // tripping an assertion. So, for now, just disable this\n+            // optimization.\n+            return;\n+        }\n+\n         unsafe {\n             let llty = val_ty(load);\n             let v = ["}, {"sha": "4b4ccb3b600b3a54f0d7a31dcac80ba472c2b828", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -96,7 +96,7 @@ pub fn get_fn(\n         debug!(\"get_fn: not casting pointer!\");\n \n         if instance.def.is_inline(tcx) {\n-            attributes::inline(llfn, attributes::InlineAttr::Hint);\n+            attributes::inline(cx, llfn, attributes::InlineAttr::Hint);\n         }\n         attributes::from_fn_attrs(cx, llfn, Some(instance.def.def_id()));\n "}, {"sha": "0cb8f99efc33fd66cb6a78db907aee2302ae660e", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -92,7 +92,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             mir::StatementKind::ReadForMatch(_) |\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Validate(..) |\n-            mir::StatementKind::UserAssertTy(..) |\n+            mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => bx,\n         }\n     }"}, {"sha": "a8502e9244768b8aee7835dd4167bfffeff311fb", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -180,7 +180,7 @@ fn predefine_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n     if instance.def.is_inline(cx.tcx) {\n-        attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+        attributes::inline(cx, lldecl, attributes::InlineAttr::Hint);\n     }\n     attributes::from_fn_attrs(cx, lldecl, Some(instance.def.def_id()));\n "}, {"sha": "681cf0d5fc9dedab38cdf14e37e83d053905b1b2", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -90,7 +90,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     macro_rules! add_pre_expansion_builtin {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_early_pass($sess, false, box $name);\n+                store.register_pre_expansion_pass($sess, box $name);\n                 )*}\n             )\n     }"}, {"sha": "7d01ed556c8ddbee7d76dbdc369c7cb937ab5480", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -81,7 +81,7 @@ fn main() {\n     let is_crossed = target != host;\n \n     let mut optional_components =\n-        vec![\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\",\n+        vec![\"x86\", \"arm\", \"aarch64\", \"amdgpu\", \"mips\", \"powerpc\",\n              \"systemz\", \"jsbackend\", \"webassembly\", \"msp430\", \"sparc\", \"nvptx\"];\n \n     let mut version_cmd = Command::new(&llvm_config);"}, {"sha": "60aeb92d91a6f30b7cf2075a365ebe53b8bf0ab4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -535,10 +535,10 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // flow_state already handled).\n             }\n             StatementKind::Nop\n-            | StatementKind::UserAssertTy(..)\n+            | StatementKind::AscribeUserType(..)\n             | StatementKind::Validate(..)\n             | StatementKind::StorageLive(..) => {\n-                // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "7e8e1b32d4d98450dfb7b121926effbfa1d4ca0e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n-use rustc::mir::{Local, Statement, Terminator};\n+use rustc::mir::{Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, RegionVid};\n@@ -175,10 +175,11 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_terminator(block, terminator, location);\n     }\n \n-    fn visit_user_assert_ty(\n+    fn visit_ascribe_user_ty(\n         &mut self,\n+        _place: &Place<'tcx>,\n+        _variance: &ty::Variance,\n         _c_ty: &CanonicalTy<'tcx>,\n-        _local: &Local,\n         _location: Location,\n     ) {\n     }"}, {"sha": "71345f22e443b455b2cb01b1cee80232570d6801", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -144,10 +144,10 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n             // EndRegion matters to older NLL/MIR AST borrowck, not to alias NLL\n             StatementKind::EndRegion(..) |\n             StatementKind::Nop |\n-            StatementKind::UserAssertTy(..) |\n+            StatementKind::AscribeUserType(..) |\n             StatementKind::Validate(..) |\n             StatementKind::StorageLive(..) => {\n-                // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "214628600b370675e5708a51baa90ece318b7a96", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -319,23 +319,34 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         for variable in self.definitions.indices() {\n+            let scc = self.constraint_sccs.scc(variable);\n+\n             match self.definitions[variable].origin {\n                 NLLRegionVariableOrigin::FreeRegion => {\n                     // For each free, universally quantified region X:\n \n                     // Add all nodes in the CFG to liveness constraints\n-                    let variable_scc = self.constraint_sccs.scc(variable);\n                     self.liveness_constraints.add_all_points(variable);\n-                    self.scc_values.add_all_points(variable_scc);\n+                    self.scc_values.add_all_points(scc);\n \n                     // Add `end(X)` into the set for X.\n-                    self.add_element_to_scc_of(variable, variable);\n+                    self.scc_values.add_element(scc, variable);\n                 }\n \n                 NLLRegionVariableOrigin::BoundRegion(ui) => {\n                     // Each placeholder region X outlives its\n-                    // associated universe but nothing else.\n-                    self.add_element_to_scc_of(variable, ui);\n+                    // associated universe but nothing else. Every\n+                    // placeholder region is always in a universe that\n+                    // contains `ui` -- but when placeholder regions\n+                    // are placed into an SCC, that SCC may include\n+                    // things from other universes that do not include\n+                    // `ui`.\n+                    let scc_universe = self.scc_universes[scc];\n+                    if ui.is_subset_of(scc_universe) {\n+                        self.scc_values.add_element(scc, ui);\n+                    } else {\n+                        self.add_incompatible_universe(scc);\n+                    }\n                 }\n \n                 NLLRegionVariableOrigin::Existential => {\n@@ -383,13 +394,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_universes[scc]\n     }\n \n-    /// Adds `elem` to the value of the SCC in which `v` appears.\n-    fn add_element_to_scc_of(&mut self, v: RegionVid, elem: impl ToElementIndex) {\n-        debug!(\"add_live_element({:?}, {:?})\", v, elem);\n-        let scc = self.constraint_sccs.scc(v);\n-        self.scc_values.add_element(scc, elem);\n-    }\n-\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -516,22 +520,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // merge the bits.\n                 self.scc_values.add_region(scc_a, scc_b);\n             } else {\n-                // Otherwise, the only way for `A` to outlive `B`\n-                // is for it to outlive static. This is actually stricter\n-                // than necessary: ideally, we'd support bounds like `for<'a: 'b`>`\n-                // that might then allow us to approximate `'a` with `'b` and not\n-                // `'static`. But it will have to do for now.\n-                //\n-                // The code here is a bit hacky: we grab the current\n-                // value of the SCC in which `'static` appears, but\n-                // this value may not be fully computed yet. That's ok\n-                // though: it will contain the base liveness values,\n-                // which include (a) the static free region element\n-                // and (b) all the points in the CFG, so it is \"good\n-                // enough\" to bring it in here for our purposes.\n-                let fr_static = self.universal_regions.fr_static;\n-                let scc_static = constraint_sccs.scc(fr_static);\n-                self.scc_values.add_region(scc_a, scc_static);\n+                self.add_incompatible_universe(scc_a);\n             }\n         }\n \n@@ -563,6 +552,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .all(|u| u.is_subset_of(universe_a))\n     }\n \n+    /// Extend `scc` so that it can outlive some placeholder region\n+    /// from a universe it can't name; at present, the only way for\n+    /// this to be true is if `scc` outlives `'static`. This is\n+    /// actually stricter than necessary: ideally, we'd support bounds\n+    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// `'a` with `'b` and not `'static`. But it will have to do for\n+    /// now.\n+    fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {\n+        let fr_static = self.universal_regions.fr_static;\n+        self.scc_values.add_all_points(scc);\n+        self.scc_values.add_element(scc, fr_static);\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:"}, {"sha": "d77863d598f663792fd9a7f0edd0b6779c5bb7f6", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n+use rustc::mir::{BasicBlock, Location, Mir, Place, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -112,8 +112,13 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_closure_substs: substs={:?}\", substs);\n     }\n \n-    fn visit_user_assert_ty(&mut self, _c_ty: &mut CanonicalTy<'tcx>, _local: &mut Local,\n-                            _location: Location) {\n+    fn visit_ascribe_user_ty(\n+        &mut self,\n+        _place: &mut Place<'tcx>,\n+        _variance: &mut ty::Variance,\n+        _c_ty: &mut CanonicalTy<'tcx>,\n+        _location: Location,\n+    ) {\n         // User-assert-ty statements represent types that the user added explicitly.\n         // We don't want to erase the regions from these types: rather, we want to\n         // add them as constraints at type-check time."}, {"sha": "de96539ec30f106a8e3df51123b22657992f89ce", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -17,7 +17,9 @@ use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n+use borrow_check::nll::type_check::free_region_relations::{\n+    CreateResult, UniversalRegionRelations,\n+};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n@@ -246,10 +248,12 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_type(constant, constant.ty);\n \n         if let Some(user_ty) = constant.user_ty {\n-            if let Err(terr) =\n-                self.cx\n-                    .eq_canonical_type_and_type(user_ty, constant.ty, location.boring())\n-            {\n+            if let Err(terr) = self.cx.relate_type_and_user_type(\n+                constant.ty,\n+                ty::Variance::Invariant,\n+                user_ty,\n+                location.boring(),\n+            ) {\n                 span_mirbug!(\n                     self,\n                     constant,\n@@ -271,6 +275,25 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n         self.super_local_decl(local, local_decl);\n         self.sanitize_type(local_decl, local_decl.ty);\n+\n+        if let Some(user_ty) = local_decl.user_ty {\n+            if let Err(terr) = self.cx.relate_type_and_user_type(\n+                local_decl.ty,\n+                ty::Variance::Invariant,\n+                user_ty,\n+                Locations::All,\n+            ) {\n+                span_mirbug!(\n+                    self,\n+                    local,\n+                    \"bad user type on variable {:?}: {:?} != {:?} ({:?})\",\n+                    local,\n+                    local_decl.ty,\n+                    local_decl.user_ty,\n+                    terr,\n+                );\n+            }\n+        }\n     }\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -850,15 +873,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n-    fn eq_canonical_type_and_type(\n+    fn relate_type_and_user_type(\n         &mut self,\n-        a: CanonicalTy<'tcx>,\n-        b: Ty<'tcx>,\n+        a: Ty<'tcx>,\n+        v: ty::Variance,\n+        b: CanonicalTy<'tcx>,\n         locations: Locations,\n     ) -> Fallible<()> {\n-        relate_tys::eq_canonical_type_and_type(\n+        relate_tys::relate_type_and_user_type(\n             self.infcx,\n             a,\n+            v,\n             b,\n             locations,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n@@ -879,8 +904,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let is_temp = if let Place::Local(l) = *place {\n-                    l != RETURN_PLACE &&\n-                    !mir.local_decls[l].is_user_variable.is_some()\n+                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n                 } else {\n                     false\n                 };\n@@ -905,9 +929,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(user_ty) = self.rvalue_user_ty(rv) {\n-                    if let Err(terr) = self.eq_canonical_type_and_type(\n-                        user_ty,\n+                    if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n+                        ty::Variance::Invariant,\n+                        user_ty,\n                         location.boring(),\n                     ) {\n                         span_mirbug!(\n@@ -955,15 +980,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::UserAssertTy(c_ty, local) => {\n-                let local_ty = mir.local_decls()[local].ty;\n-                if let Err(terr) = self.eq_canonical_type_and_type(c_ty, local_ty, Locations::All) {\n+            StatementKind::AscribeUserType(ref place, variance, c_ty) => {\n+                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                if let Err(terr) =\n+                    self.relate_type_and_user_type(place_ty, variance, c_ty, Locations::All)\n+                {\n                     span_mirbug!(\n                         self,\n                         stmt,\n-                        \"bad type assert ({:?} = {:?}): {:?}\",\n+                        \"bad type assert ({:?} <: {:?}): {:?}\",\n+                        place_ty,\n                         c_ty,\n-                        local_ty,\n                         terr\n                     );\n                 }\n@@ -1142,8 +1169,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n                 let is_temp = if let Place::Local(l) = *dest {\n-                    l != RETURN_PLACE &&\n-                    !mir.local_decls[l].is_user_variable.is_some()\n+                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n                 } else {\n                     false\n                 };\n@@ -1562,30 +1588,26 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// If this rvalue supports a user-given type annotation, then\n     /// extract and return it. This represents the final type of the\n     /// rvalue and will be unified with the inferred type.\n-    fn rvalue_user_ty(\n-        &self,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> Option<CanonicalTy<'tcx>> {\n+    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<CanonicalTy<'tcx>> {\n         match rvalue {\n-            Rvalue::Use(_) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Ref(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) =>\n-                None,\n+            Rvalue::Use(_)\n+            | Rvalue::Repeat(..)\n+            | Rvalue::Ref(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::Cast(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..) => None,\n \n             Rvalue::Aggregate(aggregate, _) => match **aggregate {\n                 AggregateKind::Adt(_, _, _, user_ty, _) => user_ty,\n                 AggregateKind::Array(_) => None,\n                 AggregateKind::Tuple => None,\n                 AggregateKind::Closure(_, _) => None,\n                 AggregateKind::Generator(_, _, _) => None,\n-            }\n+            },\n         }\n     }\n "}, {"sha": "06cb44ac9714d0e287eeed16c4c524554dda21a4", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 280, "deletions": 68, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -21,8 +21,8 @@ use rustc::ty::subst::Kind;\n use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use std::mem;\n \n+/// Adds sufficient constraints to ensure that `a <: b`.\n pub(super) fn sub_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n@@ -41,6 +41,7 @@ pub(super) fn sub_types<'tcx>(\n     Ok(())\n }\n \n+/// Adds sufficient constraints to ensure that `a == b`.\n pub(super) fn eq_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n@@ -59,28 +60,38 @@ pub(super) fn eq_types<'tcx>(\n     Ok(())\n }\n \n-pub(super) fn eq_canonical_type_and_type<'tcx>(\n+/// Adds sufficient constraints to ensure that `a <: b`, where `b` is\n+/// a user-given type (which means it may have canonical variables\n+/// encoding things like `_`).\n+pub(super) fn relate_type_and_user_type<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n-    a: CanonicalTy<'tcx>,\n-    b: Ty<'tcx>,\n+    a: Ty<'tcx>,\n+    v: ty::Variance,\n+    b: CanonicalTy<'tcx>,\n     locations: Locations,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\n-        \"eq_canonical_type_and_type(a={:?}, b={:?}, locations={:?})\",\n+        \"sub_type_and_user_type(a={:?}, b={:?}, locations={:?})\",\n         a, b, locations\n     );\n     let Canonical {\n-        variables: a_variables,\n-        value: a_value,\n-    } = a;\n+        variables: b_variables,\n+        value: b_value,\n+    } = b;\n+\n+    // The `TypeRelating` code assumes that the \"canonical variables\"\n+    // appear in the \"a\" side, so flip `Contravariant` ambient\n+    // variance to get the right relationship.\n+    let v1 = ty::Contravariant.xform(v);\n+\n     TypeRelating::new(\n         infcx,\n-        ty::Variance::Invariant,\n+        v1,\n         locations,\n         borrowck_context,\n-        a_variables,\n-    ).relate(&a_value, &b)?;\n+        b_variables,\n+    ).relate(&b_value, &a)?;\n     Ok(())\n }\n \n@@ -128,7 +139,7 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     /// how can we enforce that? I guess I could add some kind of\n     /// \"minimum universe constraint\" that we can feed to the NLL checker.\n     /// --> also, we know this doesn't happen\n-    canonical_var_values: IndexVec<CanonicalVar, Option<ScopesAndKind<'tcx>>>,\n+    canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -194,23 +205,44 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         scope\n     }\n \n+    /// When we encounter binders during the type traversal, we record\n+    /// the value to substitute for each of the things contained in\n+    /// that binder. (This will be either a universal placeholder or\n+    /// an existential inference variable.) Given the debruijn index\n+    /// `debruijn` (and name `br`) of some binder we have now\n+    /// encountered, this routine finds the value that we instantiated\n+    /// the region with; to do so, it indexes backwards into the list\n+    /// of ambient scopes `scopes`.\n+    fn lookup_bound_region(\n+        debruijn: ty::DebruijnIndex,\n+        br: &ty::BoundRegion,\n+        first_free_index: ty::DebruijnIndex,\n+        scopes: &[BoundRegionScope],\n+    ) -> RegionVid {\n+        // The debruijn index is a \"reverse index\" into the\n+        // scopes listing. So when we have INNERMOST (0), we\n+        // want the *last* scope pushed, and so forth.\n+        let debruijn_index = debruijn.index() - first_free_index.index();\n+        let scope = &scopes[scopes.len() - debruijn_index - 1];\n+\n+        // Find this bound region in that scope to map to a\n+        // particular region.\n+        scope.map[br]\n+    }\n+\n+    /// If `r` is a bound region, find the scope in which it is bound\n+    /// (from `scopes`) and return the value that we instantiated it\n+    /// with. Otherwise just return `r`.\n     fn replace_bound_region(\n         &self,\n         universal_regions: &UniversalRegions<'tcx>,\n         r: ty::Region<'tcx>,\n+        first_free_index: ty::DebruijnIndex,\n         scopes: &[BoundRegionScope],\n     ) -> RegionVid {\n         match r {\n             ty::ReLateBound(debruijn, br) => {\n-                // The debruijn index is a \"reverse index\" into the\n-                // scopes listing. So when we have INNERMOST (0), we\n-                // want the *last* scope pushed, and so forth.\n-                let debruijn_index = debruijn.index() - ty::INNERMOST.index();\n-                let scope = &scopes[scopes.len() - debruijn_index - 1];\n-\n-                // Find this bound region in that scope to map to a\n-                // particular region.\n-                scope.map[br]\n+                Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n             }\n \n             ty::ReVar(v) => *v,\n@@ -219,6 +251,8 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Push a new outlives requirement into our output set of\n+    /// constraints.\n     fn push_outlives(&mut self, sup: RegionVid, sub: RegionVid) {\n         debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n \n@@ -236,46 +270,55 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn equate_var(\n+    /// When we encounter a canonical variable `var` in the output,\n+    /// equate it with `kind`. If the variable has been previously\n+    /// equated, then equate it again.\n+    fn relate_var(\n         &mut self,\n         var: CanonicalVar,\n         b_kind: Kind<'tcx>,\n     ) -> RelateResult<'tcx, Kind<'tcx>> {\n         debug!(\"equate_var(var={:?}, b_kind={:?})\", var, b_kind);\n \n-        // We only encounter canonical variables when equating.\n-        assert_eq!(self.ambient_variance, ty::Variance::Invariant);\n-\n-        // The canonical variable already had a value. Equate that\n-        // value with `b`.\n-        let old_value = self.canonical_var_values[var].clone();\n-        if let Some(ScopesAndKind { scopes, kind }) = old_value {\n-            debug!(\"equate_var: installing kind={:?} scopes={:?}\", kind, scopes);\n-            let old_a_scopes = mem::replace(&mut self.a_scopes, scopes);\n-            let result = self.relate(&kind, &b_kind);\n-            self.a_scopes = old_a_scopes;\n-            debug!(\"equate_var: complete, result = {:?}\", result);\n-            return result;\n-        }\n+        let generalized_kind = match self.canonical_var_values[var] {\n+            Some(v) => v,\n+            None => {\n+                let generalized_kind = self.generalize_value(b_kind);\n+                self.canonical_var_values[var] = Some(generalized_kind);\n+                generalized_kind\n+            }\n+        };\n \n-        // Not yet. Capture the value from the RHS and carry on.\n-        self.canonical_var_values[var] = Some(ScopesAndKind {\n-            scopes: self.b_scopes.clone(),\n-            kind: b_kind,\n-        });\n-        debug!(\n-            \"equate_var: capturing value {:?}\",\n-            self.canonical_var_values[var]\n-        );\n+        // The generalized values we extract from `canonical_var_values` have\n+        // been fully instantiated and hence the set of scopes we have\n+        // doesn't matter -- just to be sure, put an empty vector\n+        // in there.\n+        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n+\n+        // Relate the generalized kind to the original one.\n+        let result = self.relate(&generalized_kind, &b_kind);\n+\n+        // Restore the old scopes now.\n+        self.a_scopes = old_a_scopes;\n+\n+        debug!(\"equate_var: complete, result = {:?}\", result);\n+        return result;\n+    }\n \n-        // FIXME -- technically, we should add some sort of\n-        // assertion that this value can be named in the universe\n-        // of the canonical variable. But in practice these\n-        // canonical variables only arise presently in cases where\n-        // they are in the root universe and the main typeck has\n-        // ensured there are no universe errors. So we just kind\n-        // of over look this right now.\n-        Ok(b_kind)\n+    fn generalize_value(\n+        &self,\n+        kind: Kind<'tcx>,\n+    ) -> Kind<'tcx> {\n+        TypeGeneralizer {\n+            type_rel: self,\n+            first_free_index: ty::INNERMOST,\n+            ambient_variance: self.ambient_variance,\n+\n+            // These always correspond to an `_` or `'_` written by\n+            // user, and those are always in the root universe.\n+            universe: ty::UniverseIndex::ROOT,\n+        }.relate(&kind, &kind)\n+            .unwrap()\n     }\n }\n \n@@ -326,7 +369,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         // Watch out for the case that we are matching a `?T` against the\n         // right-hand side.\n         if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n-            self.equate_var(var, b.into())?;\n+            self.relate_var(var, b.into())?;\n             Ok(a)\n         } else {\n             debug!(\n@@ -348,7 +391,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         }) = self.borrowck_context\n         {\n             if let ty::ReCanonical(var) = a {\n-                self.equate_var(*var, b.into())?;\n+                self.relate_var(*var, b.into())?;\n                 return Ok(a);\n             }\n \n@@ -357,8 +400,10 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n                 a, b, self.ambient_variance\n             );\n \n-            let v_a = self.replace_bound_region(universal_regions, a, &self.a_scopes);\n-            let v_b = self.replace_bound_region(universal_regions, b, &self.b_scopes);\n+            let v_a =\n+                self.replace_bound_region(universal_regions, a, ty::INNERMOST, &self.a_scopes);\n+            let v_b =\n+                self.replace_bound_region(universal_regions, b, ty::INNERMOST, &self.b_scopes);\n \n             debug!(\"regions: v_a = {:?}\", v_a);\n             debug!(\"regions: v_b = {:?}\", v_b);\n@@ -425,19 +470,30 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n             self.b_scopes.push(b_scope);\n             self.a_scopes.push(a_scope);\n \n-            // FIXME -- to be fully correct, we would set the ambient\n-            // variance to Covariant here. As is, we will sometimes\n-            // propagate down an ambient variance of Equal -- this in\n-            // turn causes us to report errors in some cases where\n-            // types perhaps *ought* to be equal. See the\n-            // `hr-fn-aau-eq-abu.rs` test for an example. Fixing this\n-            // though is a bit nontrivial: in particular, it would\n-            // require a more involved handling of canonical\n-            // variables, since we would no longer be able to rely on\n-            // having an `==` relationship for canonical variables.\n+            // Reset the ambient variance to covariant. This is needed\n+            // to correctly handle cases like\n+            //\n+            //     for<'a> fn(&'a u32, &'a u3) == for<'b, 'c> fn(&'b u32, &'c u32)\n+            //\n+            // Somewhat surprisingly, these two types are actually\n+            // **equal**, even though the one on the right looks more\n+            // polymorphic. The reason is due to subtyping. To see it,\n+            // consider that each function can call the other:\n+            //\n+            // - The left function can call the right with `'b` and\n+            //   `'c` both equal to `'a`\n+            //\n+            // - The right function can call the left with `'a` set to\n+            //   `{P}`, where P is the point in the CFG where the call\n+            //   itself occurs. Note that `'b` and `'c` must both\n+            //   include P. At the point, the call works because of\n+            //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n+            let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n \n             self.relate(a.skip_binder(), b.skip_binder())?;\n \n+            self.ambient_variance = variance;\n+\n             self.b_scopes.pop().unwrap();\n             self.a_scopes.pop().unwrap();\n         }\n@@ -458,8 +514,17 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n             self.a_scopes.push(a_scope);\n             self.b_scopes.push(b_scope);\n \n+            // Reset ambient variance to contravariance. See the\n+            // covariant case above for an explanation.\n+            let variance = ::std::mem::replace(\n+                &mut self.ambient_variance,\n+                ty::Variance::Contravariant,\n+            );\n+\n             self.relate(a.skip_binder(), b.skip_binder())?;\n \n+            self.ambient_variance = variance;\n+\n             self.b_scopes.pop().unwrap();\n             self.a_scopes.pop().unwrap();\n         }\n@@ -468,7 +533,14 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n     }\n }\n \n-struct ScopeInstantiator<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n+/// When we encounter a binder like `for<..> fn(..)`, we actually have\n+/// to walk the `fn` value to find all the values bound by the `for`\n+/// (these are not explicitly present in the ty representation right\n+/// now). This visitor handles that: it descends the type, tracking\n+/// binder depth, and finds late-bound regions targeting the\n+/// `for<..`>.  For each of those, it creates an entry in\n+/// `bound_region_scope`.\n+struct ScopeInstantiator<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n@@ -510,3 +582,143 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n         false\n     }\n }\n+\n+/// The \"type generalize\" is used when handling inference variables.\n+///\n+/// The basic strategy for handling a constraint like `?A <: B` is to\n+/// apply a \"generalization strategy\" to the type `B` -- this replaces\n+/// all the lifetimes in the type `B` with fresh inference\n+/// variables. (You can read more about the strategy in this [blog\n+/// post].)\n+///\n+/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n+/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n+/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n+/// establishes `'0: 'x` as a constraint.\n+///\n+/// As a side-effect of this generalization procedure, we also replace\n+/// all the bound regions that we have traversed with concrete values,\n+/// so that the resulting generalized type is independent from the\n+/// scopes.\n+///\n+/// [blog post]: https://is.gd/0hKvIr\n+struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    type_rel: &'me TypeRelating<'me, 'bccx, 'gcx, 'tcx>,\n+\n+    /// After we generalize this type, we are going to relative it to\n+    /// some other type. What will be the variance at this point?\n+    ambient_variance: ty::Variance,\n+\n+    first_free_index: ty::DebruijnIndex,\n+\n+    universe: ty::UniverseIndex,\n+}\n+\n+impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.type_rel.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n+\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+                bug!(\n+                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                    a\n+                );\n+            }\n+\n+            _ => relate::super_relate_tys(self, a, a),\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n+\n+        if let ty::ReLateBound(debruijn, _) = a {\n+            if *debruijn < self.first_free_index {\n+                return Ok(a);\n+            }\n+        }\n+\n+        // For now, we just always create a fresh region variable to\n+        // replace all the regions in the source type. In the main\n+        // type checker, we special case the case where the ambient\n+        // variance is `Invariant` and try to avoid creating a fresh\n+        // region variable, but since this comes up so much less in\n+        // NLL (only when users use `_` etc) it is much less\n+        // important.\n+        //\n+        // As an aside, since these new variables are created in\n+        // `self.universe` universe, this also serves to enforce the\n+        // universe scoping rules.\n+        //\n+        // FIXME(#54105) -- if the ambient variance is bivariant,\n+        // though, we may however need to check well-formedness or\n+        // risk a problem like #41677 again.\n+\n+        let replacement_region_vid = self.type_rel\n+            .infcx\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, self.universe);\n+\n+        Ok(replacement_region_vid)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        _: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n+\n+        self.first_free_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        self.first_free_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n+    }\n+}"}, {"sha": "c4cb7958fd3c35865cf6eef19165b5c206227ff0", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -106,7 +106,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     remainder_scope,\n                     init_scope,\n                     pattern,\n-                    ty,\n                     initializer,\n                     lint_level\n                 } => {\n@@ -136,24 +135,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n                                 let scope = (init_scope, source_info);\n                                 this.in_scope(scope, lint_level, block, |this| {\n-                                    this.expr_into_pattern(block, ty, pattern, init)\n+                                    this.expr_into_pattern(block, pattern, init)\n                                 })\n                             }));\n                     } else {\n                         scope = this.declare_bindings(\n                             None, remainder_span, lint_level, slice::from_ref(&pattern),\n                             ArmHasGuard(false), None);\n \n-                        // FIXME(#47184): We currently only insert `UserAssertTy` statements for\n-                        // patterns that are bindings, this is as we do not want to deconstruct\n-                        // the type being assertion to match the pattern.\n-                        if let PatternKind::Binding { var, .. } = *pattern.kind {\n-                            if let Some(ty) = ty {\n-                                this.user_assert_ty(block, ty, var, span);\n-                            }\n-                        }\n-\n-                        this.visit_bindings(&pattern, &mut |this, _, _, _, node, span, _| {\n+                        this.visit_bindings(&pattern, None, &mut |this, _, _, _, node, span, _, _| {\n                             this.storage_live_binding(block, node, span, OutsideGuard);\n                             this.schedule_drop_for_binding(node, span, OutsideGuard);\n                         })"}, {"sha": "5708ac4e6b50f7dfd58a57a374c9c8c87e366aa0", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -296,6 +296,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let ptr_temp = this.local_decls.push(LocalDecl {\n                         mutability: Mutability::Mut,\n                         ty: ptr_ty,\n+                        user_ty: None,\n                         name: None,\n                         source_info,\n                         visibility_scope: source_info.scope,"}, {"sha": "cef1fb77e5c9e68ade18b997619af33cf5a4e207", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 551, "deletions": 312, "changes": 863, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -13,16 +13,16 @@\n //! includes the high-level algorithm, the submodules contain the\n //! details.\n \n+use build::scope::{CachedBlock, DropKind};\n+use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n-use build::scope::{CachedBlock, DropKind};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitArray;\n-use rustc::ty::{self, Ty};\n-use rustc::mir::*;\n-use rustc::hir;\n use hair::*;\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::ty::{self, CanonicalTy, Ty};\n+use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Name, NodeId};\n use syntax_pos::Span;\n \n@@ -37,13 +37,14 @@ mod util;\n pub(crate) struct ArmHasGuard(pub bool);\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    pub fn match_expr(&mut self,\n-                      destination: &Place<'tcx>,\n-                      span: Span,\n-                      mut block: BasicBlock,\n-                      discriminant: ExprRef<'tcx>,\n-                      arms: Vec<Arm<'tcx>>)\n-                      -> BlockAnd<()> {\n+    pub fn match_expr(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        span: Span,\n+        mut block: BasicBlock,\n+        discriminant: ExprRef<'tcx>,\n+        arms: Vec<Arm<'tcx>>,\n+    ) -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n         let discriminant_span = discriminant.span();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n@@ -67,68 +68,83 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let dummy_access = Rvalue::Discriminant(discriminant_place.clone());\n         let dummy_ty = dummy_access.ty(&self.local_decls, tcx);\n         let dummy_temp = self.temp(dummy_ty, dummy_source_info.span);\n-        self.cfg.push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n+        self.cfg\n+            .push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n \n         let source_info = self.source_info(discriminant_span);\n         let borrowed_input_temp = if tcx.generate_borrow_of_any_match_input() {\n             // The region is unknown at this point; we rely on NLL\n             // inference to find an appropriate one. Therefore you can\n             // only use this when NLL is turned on.\n             assert!(tcx.use_mir_borrowck());\n-            let borrowed_input =\n-                Rvalue::Ref(tcx.types.re_empty, BorrowKind::Shared, discriminant_place.clone());\n+            let borrowed_input = Rvalue::Ref(\n+                tcx.types.re_empty,\n+                BorrowKind::Shared,\n+                discriminant_place.clone(),\n+            );\n             let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n             let borrowed_input_temp = self.temp(borrowed_input_ty, span);\n-            self.cfg.push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n+            self.cfg\n+                .push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n             Some(borrowed_input_temp)\n         } else {\n             None\n         };\n \n         let mut arm_blocks = ArmBlocks {\n-            blocks: arms.iter()\n-                        .map(|_| self.cfg.start_new_block())\n-                        .collect(),\n+            blocks: arms.iter().map(|_| self.cfg.start_new_block()).collect(),\n         };\n \n         // Get the arm bodies and their scopes, while declaring bindings.\n-        let arm_bodies: Vec<_> = arms.iter().map(|arm| {\n-            // BUG: use arm lint level\n-            let body = self.hir.mirror(arm.body.clone());\n-            let scope = self.declare_bindings(None, body.span,\n-                                              LintLevel::Inherited,\n-                                              &arm.patterns[..],\n-                                              ArmHasGuard(arm.guard.is_some()),\n-                                              Some((Some(&discriminant_place), discriminant_span)));\n-            (body, scope.unwrap_or(self.source_scope))\n-        }).collect();\n+        let arm_bodies: Vec<_> = arms.iter()\n+            .map(|arm| {\n+                // BUG: use arm lint level\n+                let body = self.hir.mirror(arm.body.clone());\n+                let scope = self.declare_bindings(\n+                    None,\n+                    body.span,\n+                    LintLevel::Inherited,\n+                    &arm.patterns[..],\n+                    ArmHasGuard(arm.guard.is_some()),\n+                    Some((Some(&discriminant_place), discriminant_span)),\n+                );\n+                (body, scope.unwrap_or(self.source_scope))\n+            })\n+            .collect();\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().fold(0, |ac, c| ac + c.patterns.len());\n         let pre_binding_blocks: Vec<_> = (0..candidate_count + 1)\n-            .map(|_| self.cfg.start_new_block()).collect();\n+            .map(|_| self.cfg.start_new_block())\n+            .collect();\n \n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n         // highest priority candidate comes first in the list.\n         // (i.e. same order as in source)\n \n-        let candidates: Vec<_> =\n-            arms.iter()\n-                .enumerate()\n-                .flat_map(|(arm_index, arm)| {\n-                    arm.patterns.iter().enumerate()\n-                        .map(move |(pat_index, pat)| {\n-                            (arm_index, pat_index, pat, arm.guard.clone())\n-                        })\n-                })\n-                .zip(pre_binding_blocks.iter().zip(pre_binding_blocks.iter().skip(1)))\n-                .map(|((arm_index, pat_index, pattern, guard),\n-                       (pre_binding_block, next_candidate_pre_binding_block))| {\n-\n-                    if let (true, Some(borrow_temp)) = (tcx.emit_read_for_match(),\n-                                                        borrowed_input_temp.clone()) {\n+        let candidates: Vec<_> = arms.iter()\n+            .enumerate()\n+            .flat_map(|(arm_index, arm)| {\n+                arm.patterns\n+                    .iter()\n+                    .enumerate()\n+                    .map(move |(pat_index, pat)| (arm_index, pat_index, pat, arm.guard.clone()))\n+            })\n+            .zip(\n+                pre_binding_blocks\n+                    .iter()\n+                    .zip(pre_binding_blocks.iter().skip(1)),\n+            )\n+            .map(\n+                |(\n+                    (arm_index, pat_index, pattern, guard),\n+                    (pre_binding_block, next_candidate_pre_binding_block),\n+                )| {\n+                    if let (true, Some(borrow_temp)) =\n+                        (tcx.emit_read_for_match(), borrowed_input_temp.clone())\n+                    {\n                         // inject a fake read of the borrowed input at\n                         // the start of each arm's pattern testing\n                         // code.\n@@ -137,10 +153,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         // the variant for an enum while you are in\n                         // the midst of matching on it.\n                         let pattern_source_info = self.source_info(pattern.span);\n-                        self.cfg.push(*pre_binding_block, Statement {\n-                            source_info: pattern_source_info,\n-                            kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n-                        });\n+                        self.cfg.push(\n+                            *pre_binding_block,\n+                            Statement {\n+                                source_info: pattern_source_info,\n+                                kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n+                            },\n+                        );\n                     }\n \n                     // One might ask: why not build up the match pair such that it\n@@ -168,18 +187,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         span: pattern.span,\n                         match_pairs: vec![MatchPair::new(discriminant_place.clone(), pattern)],\n                         bindings: vec![],\n+                        ascriptions: vec![],\n                         guard,\n                         arm_index,\n                         pat_index,\n                         pre_binding_block: *pre_binding_block,\n                         next_candidate_pre_binding_block: *next_candidate_pre_binding_block,\n                     }\n-                })\n-                .collect();\n+                },\n+            )\n+            .collect();\n \n         let outer_source_info = self.source_info(span);\n-        self.cfg.terminate(*pre_binding_blocks.last().unwrap(),\n-                           outer_source_info, TerminatorKind::Unreachable);\n+        self.cfg.terminate(\n+            *pre_binding_blocks.last().unwrap(),\n+            outer_source_info,\n+            TerminatorKind::Unreachable,\n+        );\n \n         // this will generate code to test discriminant_place and\n         // branch to the appropriate arm block\n@@ -198,7 +222,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             otherwise.sort();\n             otherwise.dedup(); // variant switches can introduce duplicate target blocks\n             for block in otherwise {\n-                self.cfg.terminate(block, source_info, TerminatorKind::Unreachable);\n+                self.cfg\n+                    .terminate(block, source_info, TerminatorKind::Unreachable);\n             }\n         }\n \n@@ -211,50 +236,75 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Re-enter the source scope we created the bindings in.\n             self.source_scope = source_scope;\n             unpack!(arm_block = self.into(destination, arm_block, body));\n-            self.cfg.terminate(arm_block, outer_source_info,\n-                               TerminatorKind::Goto { target: end_block });\n+            self.cfg.terminate(\n+                arm_block,\n+                outer_source_info,\n+                TerminatorKind::Goto { target: end_block },\n+            );\n         }\n         self.source_scope = outer_source_info.scope;\n \n         end_block.unit()\n     }\n \n-    pub fn user_assert_ty(&mut self, block: BasicBlock, hir_id: hir::HirId,\n-                          var: NodeId, span: Span) {\n-        if self.hir.tcx().sess.opts.debugging_opts.disable_nll_user_type_assert { return; }\n-\n-        let local_id = self.var_local_id(var, OutsideGuard);\n-        let source_info = self.source_info(span);\n-\n-        debug!(\"user_assert_ty: local_id={:?}\", hir_id.local_id);\n-        if let Some(c_ty) = self.hir.tables.user_provided_tys().get(hir_id) {\n-            debug!(\"user_assert_ty: c_ty={:?}\", c_ty);\n-            self.cfg.push(block, Statement {\n-                source_info,\n-                kind: StatementKind::UserAssertTy(*c_ty, local_id),\n-            });\n-        }\n-    }\n-\n-    pub fn expr_into_pattern(&mut self,\n-                             mut block: BasicBlock,\n-                             ty: Option<hir::HirId>,\n-                             irrefutable_pat: Pattern<'tcx>,\n-                             initializer: ExprRef<'tcx>)\n-                             -> BlockAnd<()> {\n-        // optimize the case of `let x = ...`\n+    pub fn expr_into_pattern(\n+        &mut self,\n+        mut block: BasicBlock,\n+        irrefutable_pat: Pattern<'tcx>,\n+        initializer: ExprRef<'tcx>,\n+    ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n-            PatternKind::Binding { mode: BindingMode::ByValue,\n-                                   var,\n-                                   subpattern: None, .. } => {\n-                let place = self.storage_live_binding(block, var, irrefutable_pat.span,\n-                                                      OutsideGuard);\n-\n-                if let Some(ty) = ty {\n-                    self.user_assert_ty(block, ty, var, irrefutable_pat.span);\n-                }\n+            // Optimize the case of `let x = ...` to write directly into `x`\n+            PatternKind::Binding {\n+                mode: BindingMode::ByValue,\n+                var,\n+                subpattern: None,\n+                ..\n+            } => {\n+                let place =\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n+                unpack!(block = self.into(&place, block, initializer));\n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n+                block.unit()\n+            }\n \n+            // Optimize the case of `let x: T = ...` to write directly\n+            // into `x` and then require that `T == typeof(x)`.\n+            //\n+            // Weirdly, this is needed to prevent the\n+            // `intrinsic-move-val.rs` test case from crashing. That\n+            // test works with uninitialized values in a rather\n+            // dubious way, so it may be that the test is kind of\n+            // broken.\n+            PatternKind::AscribeUserType {\n+                subpattern: Pattern {\n+                    kind: box PatternKind::Binding {\n+                        mode: BindingMode::ByValue,\n+                        var,\n+                        subpattern: None,\n+                        ..\n+                    },\n+                    ..\n+                },\n+                user_ty: ascription_user_ty,\n+            } => {\n+                let place =\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n                 unpack!(block = self.into(&place, block, initializer));\n+\n+                let source_info = self.source_info(irrefutable_pat.span);\n+                self.cfg.push(\n+                    block,\n+                    Statement {\n+                        source_info,\n+                        kind: StatementKind::AscribeUserType(\n+                            place.clone(),\n+                            ty::Variance::Invariant,\n+                            ascription_user_ty,\n+                        ),\n+                    },\n+                );\n+\n                 self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n@@ -265,35 +315,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn place_into_pattern(&mut self,\n-                               mut block: BasicBlock,\n-                               irrefutable_pat: Pattern<'tcx>,\n-                               initializer: &Place<'tcx>,\n-                               set_match_place: bool)\n-                               -> BlockAnd<()> {\n+    pub fn place_into_pattern(\n+        &mut self,\n+        mut block: BasicBlock,\n+        irrefutable_pat: Pattern<'tcx>,\n+        initializer: &Place<'tcx>,\n+        set_match_place: bool,\n+    ) -> BlockAnd<()> {\n         // create a dummy candidate\n         let mut candidate = Candidate {\n             span: irrefutable_pat.span,\n             match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n+            ascriptions: vec![],\n             guard: None,\n \n             // since we don't call `match_candidates`, next fields is unused\n             arm_index: 0,\n             pat_index: 0,\n             pre_binding_block: block,\n-            next_candidate_pre_binding_block: block\n+            next_candidate_pre_binding_block: block,\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n         // always convert all match-pairs into bindings.\n         unpack!(block = self.simplify_candidate(block, &mut candidate));\n \n         if !candidate.match_pairs.is_empty() {\n-            span_bug!(candidate.match_pairs[0].pattern.span,\n-                      \"match pairs {:?} remaining after simplifying \\\n-                       irrefutable pattern\",\n-                      candidate.match_pairs);\n+            span_bug!(\n+                candidate.match_pairs[0].pattern.span,\n+                \"match pairs {:?} remaining after simplifying \\\n+                 irrefutable pattern\",\n+                candidate.match_pairs\n+            );\n         }\n \n         // for matches and function arguments, the place that is being matched\n@@ -304,9 +358,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             for binding in &candidate.bindings {\n                 let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                if let Some(ClearCrossCrate::Set(BindingForm::Var(\n-                    VarBindingForm {opt_match_place: Some((ref mut match_place, _)), .. }\n-                ))) = self.local_decls[local].is_user_variable\n+                if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    opt_match_place: Some((ref mut match_place, _)),\n+                    ..\n+                }))) = self.local_decls[local].is_user_variable\n                 {\n                     *match_place = Some(initializer.clone());\n                 } else {\n@@ -315,6 +370,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        self.ascribe_types(block, &candidate.ascriptions);\n+\n         // now apply the bindings, which will also declare the variables\n         self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n \n@@ -325,124 +382,191 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n-    pub fn declare_bindings(&mut self,\n-                            mut visibility_scope: Option<SourceScope>,\n-                            scope_span: Span,\n-                            lint_level: LintLevel,\n-                            patterns: &[Pattern<'tcx>],\n-                            has_guard: ArmHasGuard,\n-                            opt_match_place: Option<(Option<&Place<'tcx>>, Span)>)\n-                            -> Option<SourceScope> {\n-        assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n-                \"can't have both a visibility and a lint scope at the same time\");\n+    pub fn declare_bindings(\n+        &mut self,\n+        mut visibility_scope: Option<SourceScope>,\n+        scope_span: Span,\n+        lint_level: LintLevel,\n+        patterns: &[Pattern<'tcx>],\n+        has_guard: ArmHasGuard,\n+        opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n+    ) -> Option<SourceScope> {\n+        assert!(\n+            !(visibility_scope.is_some() && lint_level.is_explicit()),\n+            \"can't have both a visibility and a lint scope at the same time\"\n+        );\n         let mut scope = self.source_scope;\n         let num_patterns = patterns.len();\n-        self.visit_bindings(&patterns[0], &mut |this, mutability, name, mode, var, span, ty| {\n-            if visibility_scope.is_none() {\n-                visibility_scope = Some(this.new_source_scope(scope_span,\n-                                                           LintLevel::Inherited,\n-                                                           None));\n-                // If we have lints, create a new source scope\n-                // that marks the lints for the locals. See the comment\n-                // on the `source_info` field for why this is needed.\n-                if lint_level.is_explicit() {\n-                    scope =\n-                        this.new_source_scope(scope_span, lint_level, None);\n+        self.visit_bindings(\n+            &patterns[0],\n+            None,\n+            &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n+                if visibility_scope.is_none() {\n+                    visibility_scope =\n+                        Some(this.new_source_scope(scope_span, LintLevel::Inherited, None));\n+                    // If we have lints, create a new source scope\n+                    // that marks the lints for the locals. See the comment\n+                    // on the `source_info` field for why this is needed.\n+                    if lint_level.is_explicit() {\n+                        scope = this.new_source_scope(scope_span, lint_level, None);\n+                    }\n                 }\n-            }\n-            let source_info = SourceInfo {\n-                span,\n-                scope,\n-            };\n-            let visibility_scope = visibility_scope.unwrap();\n-            this.declare_binding(source_info, visibility_scope, mutability, name, mode,\n-                                 num_patterns, var, ty, has_guard,\n-                                 opt_match_place.map(|(x, y)| (x.cloned(), y)),\n-                                 patterns[0].span);\n-        });\n+                let source_info = SourceInfo { span, scope };\n+                let visibility_scope = visibility_scope.unwrap();\n+                this.declare_binding(\n+                    source_info,\n+                    visibility_scope,\n+                    mutability,\n+                    name,\n+                    mode,\n+                    num_patterns,\n+                    var,\n+                    ty,\n+                    user_ty,\n+                    has_guard,\n+                    opt_match_place.map(|(x, y)| (x.cloned(), y)),\n+                    patterns[0].span,\n+                );\n+            },\n+        );\n         visibility_scope\n     }\n \n-    pub fn storage_live_binding(&mut self,\n-                                block: BasicBlock,\n-                                var: NodeId,\n-                                span: Span,\n-                                for_guard: ForGuard)\n-                            -> Place<'tcx>\n-    {\n+    pub fn storage_live_binding(\n+        &mut self,\n+        block: BasicBlock,\n+        var: NodeId,\n+        span: Span,\n+        for_guard: ForGuard,\n+    ) -> Place<'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n-        self.cfg.push(block, Statement {\n-            source_info,\n-            kind: StatementKind::StorageLive(local_id)\n-        });\n+        self.cfg.push(\n+            block,\n+            Statement {\n+                source_info,\n+                kind: StatementKind::StorageLive(local_id),\n+            },\n+        );\n         let place = Place::Local(local_id);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n-        self.schedule_drop(\n-            span, region_scope, &place, var_ty,\n-            DropKind::Storage,\n-        );\n+        self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n         place\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self,\n-                                     var: NodeId,\n-                                     span: Span,\n-                                     for_guard: ForGuard) {\n+    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n         self.schedule_drop(\n-            span, region_scope, &Place::Local(local_id), var_ty,\n+            span,\n+            region_scope,\n+            &Place::Local(local_id),\n+            var_ty,\n             DropKind::Value {\n                 cached_block: CachedBlock::default(),\n             },\n         );\n     }\n \n-    pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, f: &mut F)\n-        where F: FnMut(&mut Self, Mutability, Name, BindingMode, NodeId, Span, Ty<'tcx>)\n-    {\n+    pub fn visit_bindings(\n+        &mut self,\n+        pattern: &Pattern<'tcx>,\n+        mut pattern_user_ty: Option<CanonicalTy<'tcx>>,\n+        f: &mut impl FnMut(\n+            &mut Self,\n+            Mutability,\n+            Name,\n+            BindingMode,\n+            NodeId,\n+            Span,\n+            Ty<'tcx>,\n+            Option<CanonicalTy<'tcx>>,\n+        ),\n+    ) {\n         match *pattern.kind {\n-            PatternKind::Binding { mutability, name, mode, var, ty, ref subpattern, .. } => {\n-                f(self, mutability, name, mode, var, pattern.span, ty);\n+            PatternKind::Binding {\n+                mutability,\n+                name,\n+                mode,\n+                var,\n+                ty,\n+                ref subpattern,\n+                ..\n+            } => {\n+                match mode {\n+                    BindingMode::ByValue => { }\n+                    BindingMode::ByRef(..) => {\n+                        // If this is a `ref` binding (e.g., `let ref\n+                        // x: T = ..`), then the type of `x` is not\n+                        // `T` but rather `&T`, so ignore\n+                        // `pattern_user_ty` for now.\n+                        //\n+                        // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n+                        pattern_user_ty = None;\n+                    }\n+                }\n+\n+                f(self, mutability, name, mode, var, pattern.span, ty, pattern_user_ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.visit_bindings(subpattern, f);\n+                    self.visit_bindings(subpattern, pattern_user_ty, f);\n                 }\n             }\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatternKind::Array {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            }\n+            | PatternKind::Slice {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            } => {\n+                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.visit_bindings(subpattern, f);\n+                    self.visit_bindings(subpattern, None, f);\n                 }\n             }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n-            }\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n             PatternKind::Deref { ref subpattern } => {\n-                self.visit_bindings(subpattern, f);\n+                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n+                self.visit_bindings(subpattern, None, f);\n             }\n-            PatternKind::Leaf { ref subpatterns } |\n-            PatternKind::Variant { ref subpatterns, .. } => {\n+            PatternKind::AscribeUserType { ref subpattern, user_ty } => {\n+                // This corresponds to something like\n+                //\n+                // ```\n+                // let (p1: T1): T2 = ...;\n+                // ```\n+                //\n+                // Not presently possible, though maybe someday.\n+                assert!(pattern_user_ty.is_none());\n+                self.visit_bindings(subpattern, Some(user_ty), f)\n+            }\n+            PatternKind::Leaf { ref subpatterns }\n+            | PatternKind::Variant {\n+                ref subpatterns, ..\n+            } => {\n+                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n                 for subpattern in subpatterns {\n-                    self.visit_bindings(&subpattern.pattern, f);\n+                    self.visit_bindings(&subpattern.pattern, None, f);\n                 }\n             }\n         }\n     }\n }\n \n-\n /// List of blocks for each arm (and potentially other metadata in the\n /// future).\n struct ArmBlocks {\n     blocks: Vec<BasicBlock>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Candidate<'pat, 'tcx:'pat> {\n+pub struct Candidate<'pat, 'tcx: 'pat> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n \n@@ -452,6 +576,9 @@ pub struct Candidate<'pat, 'tcx:'pat> {\n     // ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n \n+    // ...these types asserted...\n+    ascriptions: Vec<Ascription<'tcx>>,\n+\n     // ...and the guard must be evaluated...\n     guard: Option<Guard<'tcx>>,\n \n@@ -477,8 +604,18 @@ struct Binding<'tcx> {\n     binding_mode: BindingMode<'tcx>,\n }\n \n+/// Indicates that the type of `source` must be a subtype of the\n+/// user-given type `user_ty`; this is basically a no-op but can\n+/// influence region inference.\n+#[derive(Clone, Debug)]\n+struct Ascription<'tcx> {\n+    span: Span,\n+    source: Place<'tcx>,\n+    user_ty: CanonicalTy<'tcx>,\n+}\n+\n #[derive(Clone, Debug)]\n-pub struct MatchPair<'pat, 'tcx:'pat> {\n+pub struct MatchPair<'pat, 'tcx: 'pat> {\n     // this place...\n     place: Place<'tcx>,\n \n@@ -490,7 +627,7 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n     // the \"rest\" part of the pattern right now has type &[T] and\n     // as such, it requires an Rvalue::Slice to be generated.\n     // See RFC 495 / issue #23121 for the eventual (proper) solution.\n-    slice_len_checked: bool\n+    slice_len_checked: bool,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -559,15 +696,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n     /// under control. See `test_candidates` for more details.\n-    fn match_candidates<'pat>(&mut self,\n-                              span: Span,\n-                              arm_blocks: &mut ArmBlocks,\n-                              mut candidates: Vec<Candidate<'pat, 'tcx>>,\n-                              mut block: BasicBlock)\n-                              -> Vec<BasicBlock>\n-    {\n-        debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n-               span, block, candidates);\n+    fn match_candidates<'pat>(\n+        &mut self,\n+        span: Span,\n+        arm_blocks: &mut ArmBlocks,\n+        mut candidates: Vec<Candidate<'pat, 'tcx>>,\n+        mut block: BasicBlock,\n+    ) -> Vec<BasicBlock> {\n+        debug!(\n+            \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n+            span, block, candidates\n+        );\n \n         // Start by simplifying candidates. Once this process is\n         // complete, all the match pairs which remain require some\n@@ -580,13 +719,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // whether the higher priority candidates (and hence at\n         // the front of the vec) have satisfied all their match\n         // pairs.\n-        let fully_matched =\n-            candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n-        debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n+        let fully_matched = candidates\n+            .iter()\n+            .take_while(|c| c.match_pairs.is_empty())\n+            .count();\n+        debug!(\n+            \"match_candidates: {:?} candidates fully matched\",\n+            fully_matched\n+        );\n         let mut unmatched_candidates = candidates.split_off(fully_matched);\n \n-        let fully_matched_with_guard =\n-            candidates.iter().take_while(|c| c.guard.is_some()).count();\n+        let fully_matched_with_guard = candidates.iter().take_while(|c| c.guard.is_some()).count();\n \n         let unreachable_candidates = if fully_matched_with_guard + 1 < candidates.len() {\n             candidates.split_off(fully_matched_with_guard + 1)\n@@ -603,20 +746,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // if None is returned, then any remaining candidates\n                 // are unreachable (at least not through this path).\n                 // Link them with false edges.\n-                debug!(\"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n-                       unreachable_candidates, unmatched_candidates);\n+                debug!(\n+                    \"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n+                    unreachable_candidates, unmatched_candidates\n+                );\n                 for candidate in unreachable_candidates {\n                     let source_info = self.source_info(candidate.span);\n                     let target = self.cfg.start_new_block();\n-                    if let Some(otherwise) = self.bind_and_guard_matched_candidate(target,\n-                                                                                   arm_blocks,\n-                                                                                   candidate) {\n-                        self.cfg.terminate(otherwise, source_info, TerminatorKind::Unreachable);\n+                    if let Some(otherwise) =\n+                        self.bind_and_guard_matched_candidate(target, arm_blocks, candidate)\n+                    {\n+                        self.cfg\n+                            .terminate(otherwise, source_info, TerminatorKind::Unreachable);\n                     }\n                 }\n \n                 if unmatched_candidates.is_empty() {\n-                    return vec![]\n+                    return vec![];\n                 } else {\n                     let target = self.cfg.start_new_block();\n                     return self.match_candidates(span, arm_blocks, unmatched_candidates, target);\n@@ -649,11 +795,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n     }\n \n-    fn join_otherwise_blocks(&mut self,\n-                             span: Span,\n-                             mut otherwise: Vec<BasicBlock>)\n-                             -> BasicBlock\n-    {\n+    fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n         let source_info = self.source_info(span);\n         otherwise.sort();\n         otherwise.dedup(); // variant switches can introduce duplicate target blocks\n@@ -662,8 +804,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         } else {\n             let join_block = self.cfg.start_new_block();\n             for block in otherwise {\n-                self.cfg.terminate(block, source_info,\n-                                   TerminatorKind::Goto { target: join_block });\n+                self.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Goto { target: join_block },\n+                );\n             }\n             join_block\n         }\n@@ -781,13 +926,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// In addition to avoiding exponential-time blowups, this algorithm\n     /// also has nice property that each guard and arm is only generated\n     /// once.\n-    fn test_candidates<'pat>(&mut self,\n-                             span: Span,\n-                             arm_blocks: &mut ArmBlocks,\n-                             candidates: &[Candidate<'pat, 'tcx>],\n-                             block: BasicBlock)\n-                             -> (Vec<BasicBlock>, usize)\n-    {\n+    fn test_candidates<'pat>(\n+        &mut self,\n+        span: Span,\n+        arm_blocks: &mut ArmBlocks,\n+        candidates: &[Candidate<'pat, 'tcx>],\n+        block: BasicBlock,\n+    ) -> (Vec<BasicBlock>, usize) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n@@ -797,66 +942,75 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // may want to add cases based on the candidates that are\n         // available\n         match test.kind {\n-            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n+            TestKind::SwitchInt {\n+                switch_ty,\n+                ref mut options,\n+                ref mut indices,\n+            } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_cases_to_switch(&match_pair.place,\n-                                                 candidate,\n-                                                 switch_ty,\n-                                                 options,\n-                                                 indices) {\n+                    if !self.add_cases_to_switch(\n+                        &match_pair.place,\n+                        candidate,\n+                        switch_ty,\n+                        options,\n+                        indices,\n+                    ) {\n                         break;\n                     }\n                 }\n             }\n-            TestKind::Switch { adt_def: _, ref mut variants} => {\n+            TestKind::Switch {\n+                adt_def: _,\n+                ref mut variants,\n+            } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_variants_to_switch(&match_pair.place,\n-                                                    candidate,\n-                                                    variants) {\n+                    if !self.add_variants_to_switch(&match_pair.place, candidate, variants) {\n                         break;\n                     }\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n \n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n         // apply if the test has that particular outcome.\n-        debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n+        debug!(\n+            \"match_candidates: test={:?} match_pair={:?}\",\n+            test, match_pair\n+        );\n         let target_blocks = self.perform_test(block, &match_pair.place, &test);\n         let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n \n         // Sort the candidates into the appropriate vector in\n         // `target_candidates`. Note that at some point we may\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n-        let tested_candidates =\n-            candidates.iter()\n-                      .take_while(|c| self.sort_candidate(&match_pair.place,\n-                                                          &test,\n-                                                          c,\n-                                                          &mut target_candidates))\n-                      .count();\n+        let tested_candidates = candidates\n+            .iter()\n+            .take_while(|c| {\n+                self.sort_candidate(&match_pair.place, &test, c, &mut target_candidates)\n+            })\n+            .count();\n         assert!(tested_candidates > 0); // at least the last candidate ought to be tested\n         debug!(\"tested_candidates: {}\", tested_candidates);\n-        debug!(\"untested_candidates: {}\", candidates.len() - tested_candidates);\n+        debug!(\n+            \"untested_candidates: {}\",\n+            candidates.len() - tested_candidates\n+        );\n \n         // For each outcome of test, process the candidates that still\n         // apply. Collect a list of blocks where control flow will\n         // branch if one of the `target_candidate` sets is not\n         // exhaustive.\n-        let otherwise: Vec<_> =\n-            target_blocks.into_iter()\n-                         .zip(target_candidates)\n-                         .flat_map(|(target_block, target_candidates)| {\n-                             self.match_candidates(span,\n-                                                   arm_blocks,\n-                                                   target_candidates,\n-                                                   target_block)\n-                         })\n-                         .collect();\n+        let otherwise: Vec<_> = target_blocks\n+            .into_iter()\n+            .zip(target_candidates)\n+            .flat_map(|(target_block, target_candidates)| {\n+                self.match_candidates(span, arm_blocks, target_candidates, target_block)\n+            })\n+            .collect();\n \n         (otherwise, tested_candidates)\n     }\n@@ -873,30 +1027,41 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// bindings, further tests would be a use-after-move (which would\n     /// in turn be detected by the borrowck code that runs on the\n     /// MIR).\n-    fn bind_and_guard_matched_candidate<'pat>(&mut self,\n-                                              mut block: BasicBlock,\n-                                              arm_blocks: &mut ArmBlocks,\n-                                              candidate: Candidate<'pat, 'tcx>)\n-                                              -> Option<BasicBlock> {\n-        debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n-               block, candidate);\n+    fn bind_and_guard_matched_candidate<'pat>(\n+        &mut self,\n+        mut block: BasicBlock,\n+        arm_blocks: &mut ArmBlocks,\n+        candidate: Candidate<'pat, 'tcx>,\n+    ) -> Option<BasicBlock> {\n+        debug!(\n+            \"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n+            block, candidate\n+        );\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n+        self.ascribe_types(block, &candidate.ascriptions);\n+\n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n         let candidate_source_info = self.source_info(candidate.span);\n \n-        self.cfg.terminate(block, candidate_source_info,\n-                               TerminatorKind::Goto { target: candidate.pre_binding_block });\n+        self.cfg.terminate(\n+            block,\n+            candidate_source_info,\n+            TerminatorKind::Goto {\n+                target: candidate.pre_binding_block,\n+            },\n+        );\n \n         block = self.cfg.start_new_block();\n-        self.cfg.terminate(candidate.pre_binding_block, candidate_source_info,\n-                               TerminatorKind::FalseEdges {\n-                                   real_target: block,\n-                                   imaginary_targets:\n-                                       vec![candidate.next_candidate_pre_binding_block],\n-                               });\n-\n+        self.cfg.terminate(\n+            candidate.pre_binding_block,\n+            candidate_source_info,\n+            TerminatorKind::FalseEdges {\n+                real_target: block,\n+                imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+            },\n+        );\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -980,13 +1145,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //      match input itself; it is up to us to create a place\n         //      holding a `&` or `&mut` that we can then borrow).\n \n-        let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n+        let autoref = self.hir\n+            .tcx()\n+            .all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n             if autoref {\n                 self.bind_matched_candidate_for_guard(\n-                    block, candidate.pat_index, &candidate.bindings);\n+                    block,\n+                    candidate.pat_index,\n+                    &candidate.bindings,\n+                );\n                 let guard_frame = GuardFrame {\n-                    locals: candidate.bindings.iter()\n+                    locals: candidate\n+                        .bindings\n+                        .iter()\n                         .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n                         .collect(),\n                 };\n@@ -1005,7 +1177,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n             if autoref {\n                 let guard_frame = self.guard_context.pop().unwrap();\n-                debug!(\"Exiting guard building context with locals: {:?}\", guard_frame);\n+                debug!(\n+                    \"Exiting guard building context with locals: {:?}\",\n+                    guard_frame\n+                );\n             }\n \n             let false_edge_block = self.cfg.start_new_block();\n@@ -1037,45 +1212,82 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // and that is clearly not correct.\n             let post_guard_block = self.cfg.start_new_block();\n-            self.cfg.terminate(block, source_info,\n-                               TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block,\n-                                                   false_edge_block));\n+            self.cfg.terminate(\n+                block,\n+                source_info,\n+                TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block, false_edge_block),\n+            );\n \n             if autoref {\n                 self.bind_matched_candidate_for_arm_body(post_guard_block, &candidate.bindings);\n             }\n \n-            self.cfg.terminate(post_guard_block, source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+            self.cfg.terminate(\n+                post_guard_block,\n+                source_info,\n+                TerminatorKind::Goto { target: arm_block },\n+            );\n \n             let otherwise = self.cfg.start_new_block();\n \n-            self.cfg.terminate(false_edge_block, source_info,\n-                               TerminatorKind::FalseEdges {\n-                                   real_target: otherwise,\n-                                   imaginary_targets:\n-                                       vec![candidate.next_candidate_pre_binding_block],\n-                               });\n+            self.cfg.terminate(\n+                false_edge_block,\n+                source_info,\n+                TerminatorKind::FalseEdges {\n+                    real_target: otherwise,\n+                    imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+                },\n+            );\n             Some(otherwise)\n         } else {\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n             self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-            self.cfg.terminate(block, candidate_source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+            self.cfg.terminate(\n+                block,\n+                candidate_source_info,\n+                TerminatorKind::Goto { target: arm_block },\n+            );\n             None\n         }\n     }\n \n+    /// Append `AscribeUserType` statements onto the end of `block`\n+    /// for each ascription\n+    fn ascribe_types<'pat>(\n+        &mut self,\n+        block: BasicBlock,\n+        ascriptions: &[Ascription<'tcx>],\n+    ) {\n+        for ascription in ascriptions {\n+            let source_info = self.source_info(ascription.span);\n+            self.cfg.push(\n+                block,\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::AscribeUserType(\n+                        ascription.source.clone(),\n+                        ty::Variance::Covariant,\n+                        ascription.user_ty,\n+                    ),\n+                },\n+            );\n+        }\n+    }\n+\n     // Only called when all_pat_vars_are_implicit_refs_within_guards,\n     // and thus all code/comments assume we are in that context.\n-    fn bind_matched_candidate_for_guard(&mut self,\n-                                        block: BasicBlock,\n-                                        pat_index: usize,\n-                                        bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n-               block, pat_index, bindings);\n+    fn bind_matched_candidate_for_guard(\n+        &mut self,\n+        block: BasicBlock,\n+        pat_index: usize,\n+        bindings: &[Binding<'tcx>],\n+    ) {\n+        debug!(\n+            \"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n+            block, pat_index, bindings\n+        );\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n@@ -1088,16 +1300,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // a reference R: &T pointing to the location matched by\n             // the pattern, and every occurrence of P within a guard\n             // denotes *R.\n-            let ref_for_guard = self.storage_live_binding(\n-                block, binding.var_id, binding.span, RefWithinGuard);\n+            let ref_for_guard =\n+                self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n             // Question: Why schedule drops if bindings are all\n             // shared-&'s?  Answer: Because schedule_drop_for_binding\n             // also emits StorageDead's for those locals.\n             self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(region, borrow_kind) => {\n                     // Tricky business: For `ref id` and `ref mut id`\n@@ -1114,9 +1327,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // used by the arm body itself. This eases\n                     // observing two-phase borrow restrictions.\n                     let val_for_guard = self.storage_live_binding(\n-                        block, binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                        block,\n+                        binding.var_id,\n+                        binding.span,\n+                        ValWithinGuard(pat_index),\n+                    );\n                     self.schedule_drop_for_binding(\n-                        binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                        binding.var_id,\n+                        binding.span,\n+                        ValWithinGuard(pat_index),\n+                    );\n \n                     // rust-lang/rust#27282: We reuse the two-phase\n                     // borrow infrastructure so that the mutable\n@@ -1126,27 +1346,36 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // discussion on rust-lang/rust#49870.\n                     let borrow_kind = match borrow_kind {\n                         BorrowKind::Shared | BorrowKind::Unique => borrow_kind,\n-                        BorrowKind::Mut { .. } => BorrowKind::Mut { allow_two_phase_borrow: true },\n+                        BorrowKind::Mut { .. } => BorrowKind::Mut {\n+                            allow_two_phase_borrow: true,\n+                        },\n                     };\n                     let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &val_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &val_for_guard, rvalue);\n                     let rvalue = Rvalue::Ref(region, BorrowKind::Shared, val_for_guard);\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n     }\n \n-    fn bind_matched_candidate_for_arm_body(&mut self,\n-                                           block: BasicBlock,\n-                                           bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\", block, bindings);\n+    fn bind_matched_candidate_for_arm_body(\n+        &mut self,\n+        block: BasicBlock,\n+        bindings: &[Binding<'tcx>],\n+    ) {\n+        debug!(\n+            \"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\",\n+            block, bindings\n+        );\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local = self.storage_live_binding(block, binding.var_id, binding.span,\n-                                                  OutsideGuard);\n+            let local =\n+                self.storage_live_binding(block, binding.var_id, binding.span, OutsideGuard);\n             self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue => {\n@@ -1175,22 +1404,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// parts of the matched data, and we want them to be distinct\n     /// temps in order to simplify checks performed by our internal\n     /// leveraging of two-phase borrows).\n-    fn declare_binding(&mut self,\n-                       source_info: SourceInfo,\n-                       visibility_scope: SourceScope,\n-                       mutability: Mutability,\n-                       name: Name,\n-                       mode: BindingMode,\n-                       num_patterns: usize,\n-                       var_id: NodeId,\n-                       var_ty: Ty<'tcx>,\n-                       has_guard: ArmHasGuard,\n-                       opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n-                       pat_span: Span)\n-    {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n-                visibility_scope={:?}, source_info={:?})\",\n-               var_id, name, mode, var_ty, visibility_scope, source_info);\n+    fn declare_binding(\n+        &mut self,\n+        source_info: SourceInfo,\n+        visibility_scope: SourceScope,\n+        mutability: Mutability,\n+        name: Name,\n+        mode: BindingMode,\n+        num_patterns: usize,\n+        var_id: NodeId,\n+        var_ty: Ty<'tcx>,\n+        user_var_ty: Option<CanonicalTy<'tcx>>,\n+        has_guard: ArmHasGuard,\n+        opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n+        pat_span: Span,\n+    ) {\n+        debug!(\n+            \"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n+             visibility_scope={:?}, source_info={:?})\",\n+            var_id, name, mode, var_ty, visibility_scope, source_info\n+        );\n \n         let tcx = self.hir.tcx();\n         let binding_mode = match mode {\n@@ -1199,7 +1432,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n         let local = LocalDecl::<'tcx> {\n             mutability,\n-            ty: var_ty.clone(),\n+            ty: var_ty,\n+            user_ty: user_var_ty,\n             name: Some(name),\n             source_info,\n             visibility_scope,\n@@ -1231,14 +1465,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // See previous comment.\n                 mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n+                user_ty: None,\n                 name: Some(name),\n                 source_info,\n                 visibility_scope,\n                 // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n-            LocalsForNode::ForGuard { vals_for_guard, ref_for_guard, for_arm_body }\n+            LocalsForNode::ForGuard {\n+                vals_for_guard,\n+                ref_for_guard,\n+                for_arm_body,\n+            }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}, {"sha": "14da8e9083892fb435c743a83573f5fc412f4839", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -23,7 +23,7 @@\n //! testing a value against a constant.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::matches::{Binding, MatchPair, Candidate};\n+use build::matches::{Ascription, Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n \n@@ -63,6 +63,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                  candidate: &mut Candidate<'pat, 'tcx>)\n                                  -> Result<(), MatchPair<'pat, 'tcx>> {\n         match *match_pair.pattern.kind {\n+            PatternKind::AscribeUserType { ref subpattern, user_ty } => {\n+                candidate.ascriptions.push(Ascription {\n+                    span: match_pair.pattern.span,\n+                    user_ty,\n+                    source: match_pair.place.clone(),\n+                });\n+\n+                candidate.match_pairs.push(MatchPair::new(match_pair.place, subpattern));\n+\n+                Ok(())\n+            }\n+\n             PatternKind::Wild => {\n                 // nothing left to do\n                 Ok(())"}, {"sha": "373c8e039f8de36a4479e144a4b992779dd26a98", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -70,13 +70,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Range { lo, hi, end } => {\n+            PatternKind::Range { lo, hi, ty, end } => {\n+                assert!(ty == match_pair.pattern.ty);\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n                         lo,\n                         hi,\n-                        ty: match_pair.pattern.ty.clone(),\n+                        ty,\n                         end,\n                     },\n                 }\n@@ -96,6 +97,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            PatternKind::AscribeUserType { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Slice { .. } |\n             PatternKind::Wild |\n@@ -138,6 +140,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n             PatternKind::Binding { .. } |\n+            PatternKind::AscribeUserType { .. } |\n             PatternKind::Leaf { .. } |\n             PatternKind::Deref { .. } => {\n                 // don't know how to add these patterns to a switch\n@@ -638,6 +641,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span: candidate.span,\n             match_pairs: other_match_pairs,\n             bindings: candidate.bindings.clone(),\n+            ascriptions: candidate.ascriptions.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n             pat_index: candidate.pat_index,\n@@ -702,6 +706,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span: candidate.span,\n             match_pairs: all_match_pairs,\n             bindings: candidate.bindings.clone(),\n+            ascriptions: candidate.ascriptions.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n             pat_index: candidate.pat_index,"}, {"sha": "576c91a02b08daed34dd64fb31da5371800ad30a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -730,6 +730,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n                 ty,\n+                user_ty: None,\n                 source_info,\n                 visibility_scope: source_info.scope,\n                 name,"}, {"sha": "cc92cdecc60768fab8d657ca7b1c3ee78ecef0a2", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n             mir::StatementKind::Validate(..) |\n-            mir::StatementKind::UserAssertTy(..) |\n+            mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => {}\n \n         }"}, {"sha": "5451d27082db75d2e2319de4f1fd1de7fa4c21a9", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -304,7 +304,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             }\n             StatementKind::EndRegion(_) |\n             StatementKind::Validate(..) |\n-            StatementKind::UserAssertTy(..) |\n+            StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "85a9734a601011234096a268834990f9b37ee5bc", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -76,14 +76,26 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             first_statement_index: region::FirstStatementIndex::new(index),\n                         });\n \n-                        let ty = local.ty.clone().map(|ty| ty.hir_id);\n-                        let pattern = cx.pattern_from_hir(&local.pat);\n+                        let mut pattern = cx.pattern_from_hir(&local.pat);\n+\n+                        if let Some(ty) = &local.ty {\n+                            if let Some(user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n+                                pattern = Pattern {\n+                                    ty: pattern.ty,\n+                                    span: pattern.span,\n+                                    kind: Box::new(PatternKind::AscribeUserType {\n+                                        user_ty: *user_ty,\n+                                        subpattern: pattern\n+                                    })\n+                                };\n+                            }\n+                        }\n+\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_scope,\n                                 init_scope: region::Scope::Node(hir_id.local_id),\n                                 pattern,\n-                                ty,\n                                 initializer: local.init.to_ref(),\n                                 lint_level: cx.lint_level_of(local.id),\n                             },"}, {"sha": "d86aee5431267b1e3e1fb7044dab29a64867c279", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -93,12 +93,11 @@ pub enum StmtKind<'tcx> {\n         /// lifetime of temporaries\n         init_scope: region::Scope,\n \n-        /// let <PAT>: ty = ...\n+        /// `let <PAT> = ...`\n+        ///\n+        /// if a type is included, it is added as an ascription pattern\n         pattern: Pattern<'tcx>,\n \n-        /// let pat: <TY> = init ...\n-        ty: Option<hir::HirId>,\n-\n         /// let pat: ty = <INIT> ...\n         initializer: Option<ExprRef<'tcx>>,\n "}, {"sha": "aa1c6902dce33d61b361e7f53800d08a122297bd", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 82, "deletions": 54, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -416,7 +416,7 @@ pub enum Constructor<'tcx> {\n     /// Literal values.\n     ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n+    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n     Slice(u64),\n }\n@@ -588,7 +588,12 @@ impl<'tcx> Witness<'tcx> {\n                 _ => {\n                     match *ctor {\n                         ConstantValue(value) => PatternKind::Constant { value },\n-                        ConstantRange(lo, hi, end) => PatternKind::Range { lo, hi, end },\n+                        ConstantRange(lo, hi, ty, end) => PatternKind::Range {\n+                            lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                            hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                            ty,\n+                            end,\n+                        },\n                         _ => PatternKind::Wild,\n                     }\n                 }\n@@ -648,34 +653,32 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 .collect()\n         }\n         ty::Char if exhaustive_integer_patterns => {\n-            let endpoint = |c: char| {\n-                let ty = ty::ParamEnv::empty().and(cx.tcx.types.char);\n-                ty::Const::from_bits(cx.tcx, c as u128, ty)\n-            };\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n-                ConstantRange(endpoint('\\u{0000}'), endpoint('\\u{D7FF}'), RangeEnd::Included),\n-                ConstantRange(endpoint('\\u{E000}'), endpoint('\\u{10FFFF}'), RangeEnd::Included),\n+                ConstantRange('\\u{0000}' as u128,\n+                              '\\u{D7FF}' as u128,\n+                              cx.tcx.types.char,\n+                              RangeEnd::Included\n+                ),\n+                ConstantRange('\\u{E000}' as u128,\n+                              '\\u{10FFFF}' as u128,\n+                              cx.tcx.types.char,\n+                              RangeEnd::Included\n+                ),\n             ]\n         }\n         ty::Int(ity) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = (1u128 << (bits - 1)) - 1;\n-            let ty = ty::ParamEnv::empty().and(pcx.ty);\n-            vec![ConstantRange(ty::Const::from_bits(cx.tcx, min as u128, ty),\n-                               ty::Const::from_bits(cx.tcx, max as u128, ty),\n-                               RangeEnd::Included)]\n+            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n         }\n         ty::Uint(uty) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n             let max = !0u128 >> (128 - bits);\n-            let ty = ty::ParamEnv::empty().and(pcx.ty);\n-            vec![ConstantRange(ty::Const::from_bits(cx.tcx, 0, ty),\n-                               ty::Const::from_bits(cx.tcx, max, ty),\n-                               RangeEnd::Included)]\n+            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n         }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n@@ -811,26 +814,18 @@ impl<'tcx> IntRange<'tcx> {\n                  ctor: &Constructor<'tcx>)\n                  -> Option<IntRange<'tcx>> {\n         match ctor {\n-            ConstantRange(lo, hi, end) => {\n-                assert_eq!(lo.ty, hi.ty);\n-                let ty = lo.ty;\n-                let env_ty = ty::ParamEnv::empty().and(ty);\n-                if let Some(lo) = lo.assert_bits(tcx, env_ty) {\n-                    if let Some(hi) = hi.assert_bits(tcx, env_ty) {\n-                        // Perform a shift if the underlying types are signed,\n-                        // which makes the interval arithmetic simpler.\n-                        let bias = IntRange::signed_bias(tcx, ty);\n-                        let (lo, hi) = (lo ^ bias, hi ^ bias);\n-                        // Make sure the interval is well-formed.\n-                        return if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n-                            None\n-                        } else {\n-                            let offset = (*end == RangeEnd::Excluded) as u128;\n-                            Some(IntRange { range: lo..=(hi - offset), ty })\n-                        };\n-                    }\n+            ConstantRange(lo, hi, ty, end) => {\n+                // Perform a shift if the underlying types are signed,\n+                // which makes the interval arithmetic simpler.\n+                let bias = IntRange::signed_bias(tcx, ty);\n+                let (lo, hi) = (lo ^ bias, hi ^ bias);\n+                // Make sure the interval is well-formed.\n+                if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n+                    None\n+                } else {\n+                    let offset = (*end == RangeEnd::Excluded) as u128;\n+                    Some(IntRange { range: lo..=(hi - offset), ty })\n                 }\n-                None\n             }\n             ConstantValue(val) => {\n                 let ty = val.ty;\n@@ -853,7 +848,12 @@ impl<'tcx> IntRange<'tcx> {\n                 -> Option<IntRange<'tcx>> {\n         Self::from_ctor(tcx, &match pat.kind {\n             box PatternKind::Constant { value } => ConstantValue(value),\n-            box PatternKind::Range { lo, hi, end } => ConstantRange(lo, hi, end),\n+            box PatternKind::Range { lo, hi, ty, end } => ConstantRange(\n+                lo.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                hi.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                ty,\n+                end,\n+            ),\n             _ => return None,\n         })\n     }\n@@ -876,14 +876,12 @@ impl<'tcx> IntRange<'tcx> {\n         r: RangeInclusive<u128>,\n     ) -> Constructor<'tcx> {\n         let bias = IntRange::signed_bias(tcx, ty);\n-        let ty = ty::ParamEnv::empty().and(ty);\n         let (lo, hi) = r.into_inner();\n         if lo == hi {\n+            let ty = ty::ParamEnv::empty().and(ty);\n             ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n         } else {\n-            ConstantRange(ty::Const::from_bits(tcx, lo ^ bias, ty),\n-                          ty::Const::from_bits(tcx, hi ^ bias, ty),\n-                          RangeEnd::Included)\n+            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included)\n         }\n     }\n \n@@ -1228,20 +1226,28 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n /// Slice patterns, however, can match slices of different lengths. For instance,\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n-/// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n+/// Returns None in case of a catch-all, which can't be specialized.\n+fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                           pat: &Pattern<'tcx>,\n                           pcx: PatternContext)\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n+        PatternKind::AscribeUserType { ref subpattern, .. } =>\n+            pat_constructors(cx, subpattern, pcx),\n         PatternKind::Binding { .. } | PatternKind::Wild => None,\n         PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].did)])\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n-        PatternKind::Range { lo, hi, end } => Some(vec![ConstantRange(lo, hi, end)]),\n+        PatternKind::Range { lo, hi, ty, end } =>\n+            Some(vec![ConstantRange(\n+                lo.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                hi.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                ty,\n+                end,\n+            )]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::Array(_, length) => Some(vec![\n                 Slice(length.unwrap_usize(cx.tcx))\n@@ -1381,10 +1387,13 @@ fn slice_pat_covered_by_constructor<'tcx>(\n // constructor is a range or constant with an integer type.\n fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     if tcx.features().exhaustive_integer_patterns {\n-        if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n-            if let ty::Char | ty::Int(_) | ty::Uint(_) = value.ty.sty {\n-                return true;\n-            }\n+        let ty = match ctor {\n+            ConstantValue(value) => value.ty,\n+            ConstantRange(_, _, ty, _) => ty,\n+            _ => return false,\n+        };\n+        if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.sty {\n+            return true;\n         }\n     }\n     false\n@@ -1535,7 +1544,7 @@ fn constructor_covered_by_range<'a, 'tcx>(\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n         box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatternKind::Range { lo, hi, end } => (lo, hi, end, lo.ty),\n+        box PatternKind::Range { lo, hi, ty, end } => (lo, hi, end, ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n@@ -1557,17 +1566,33 @@ fn constructor_covered_by_range<'a, 'tcx>(\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(value)) && end)\n         },\n-        ConstantRange(from, to, RangeEnd::Included) => {\n-            let to = some_or_ok!(cmp_to(to));\n+        ConstantRange(from, to, ty, RangeEnd::Included) => {\n+            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n+                tcx,\n+                to,\n+                ty::ParamEnv::empty().and(ty),\n+            )));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(from)) && end)\n+            Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n+                tcx,\n+                from,\n+                ty::ParamEnv::empty().and(ty),\n+            ))) && end)\n         },\n-        ConstantRange(from, to, RangeEnd::Excluded) => {\n-            let to = some_or_ok!(cmp_to(to));\n+        ConstantRange(from, to, ty, RangeEnd::Excluded) => {\n+            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n+                tcx,\n+                to,\n+                ty::ParamEnv::empty().and(ty)\n+            )));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(from)) && end)\n+            Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n+                tcx,\n+                from,\n+                ty::ParamEnv::empty().and(ty)))\n+            ) && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -1606,6 +1631,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     let pat = &r[0];\n \n     let head: Option<Vec<&Pattern>> = match *pat.kind {\n+        PatternKind::AscribeUserType { ref subpattern, .. } =>\n+            specialize(cx, ::std::slice::from_ref(&subpattern), constructor, wild_patterns),\n+\n         PatternKind::Binding { .. } | PatternKind::Wild => {\n             Some(wild_patterns.to_owned())\n         }"}, {"sha": "ee50322fbb355b2700760d7b04c09f7caf47bb30", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -20,7 +20,7 @@ use interpret::{const_field, const_variant_index};\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::{self, CanonicalTy, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -66,6 +66,11 @@ pub struct Pattern<'tcx> {\n pub enum PatternKind<'tcx> {\n     Wild,\n \n+    AscribeUserType {\n+        user_ty: CanonicalTy<'tcx>,\n+        subpattern: Pattern<'tcx>,\n+    },\n+\n     /// x, ref x, x @ P, etc\n     Binding {\n         mutability: Mutability,\n@@ -101,6 +106,7 @@ pub enum PatternKind<'tcx> {\n     Range {\n         lo: &'tcx ty::Const<'tcx>,\n         hi: &'tcx ty::Const<'tcx>,\n+        ty: Ty<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -125,6 +131,8 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self.kind {\n             PatternKind::Wild => write!(f, \"_\"),\n+            PatternKind::AscribeUserType { ref subpattern, .. } =>\n+                write!(f, \"{}: _\", subpattern),\n             PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n                 let is_mut = match mode {\n                     BindingMode::ByValue => mutability == Mutability::Mut,\n@@ -230,7 +238,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Constant { value } => {\n                 fmt_const_val(f, value)\n             }\n-            PatternKind::Range { lo, hi, end } => {\n+            PatternKind::Range { lo, hi, ty: _, end } => {\n                 fmt_const_val(f, lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n@@ -359,7 +367,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n-                                PatternKind::Range { lo, hi, end },\n+                                PatternKind::Range { lo, hi, ty, end },\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n                                     self.tcx.sess,\n@@ -373,7 +381,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 PatternKind::Constant { value: lo }\n                             }\n                             (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range { lo, hi, end }\n+                                PatternKind::Range { lo, hi, ty, end }\n                             }\n                             (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n@@ -939,7 +947,7 @@ macro_rules! CloneImpls {\n CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n-    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, CanonicalTy<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n@@ -973,6 +981,13 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             PatternKind::Wild => PatternKind::Wild,\n+            PatternKind::AscribeUserType {\n+                ref subpattern,\n+                user_ty,\n+            } => PatternKind::AscribeUserType {\n+                subpattern: subpattern.fold_with(folder),\n+                user_ty: user_ty.fold_with(folder),\n+            },\n             PatternKind::Binding {\n                 mutability,\n                 name,\n@@ -1017,10 +1032,12 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             PatternKind::Range {\n                 lo,\n                 hi,\n+                ty,\n                 end,\n             } => PatternKind::Range {\n                 lo: lo.fold_with(folder),\n                 hi: hi.fold_with(folder),\n+                ty: ty.fold_with(folder),\n                 end,\n             },\n             PatternKind::Slice {"}, {"sha": "cb8e1284d0968db49798a93a35f6a51658e66fcb", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n \n             EndRegion(..) => {}\n-            UserAssertTy(..) => {}\n+            AscribeUserType(..) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly."}, {"sha": "f2c011ccee6a5704ffed97ff84204987d05caf1b", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -39,6 +39,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(if_while_or_patterns)]\n #![feature(try_from)]\n #![feature(reverse_bits)]\n+#![feature(underscore_imports)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "a6c0397568578b0de33e84872883ff45a19318cd", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -140,7 +140,9 @@ enum CallKind {\n fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span };\n     LocalDecl {\n-        mutability, ty, name: None,\n+        mutability, ty,\n+        user_ty: None,\n+        name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,"}, {"sha": "6fbc2f85c08dab24068373d5571cc08e7b16516b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             StatementKind::StorageDead(..) |\n             StatementKind::EndRegion(..) |\n             StatementKind::Validate(..) |\n-            StatementKind::UserAssertTy(..) |\n+            StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }"}, {"sha": "9edb1a1f76a6d7bf6a92350d70d6e5fe0ba41535", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -12,7 +12,7 @@\n //!\n //!   - `CleanEndRegions`, that reduces the set of `EndRegion` statements\n //!     in the MIR.\n-//!   - `CleanUserAssertTy`, that replaces all `UserAssertTy` statements\n+//!   - `CleanAscribeUserType`, that replaces all `AscribeUserType` statements\n //!     with `Nop`.\n //!\n //! The `CleanEndRegions` \"pass\" is actually implemented as two\n@@ -24,10 +24,10 @@\n //! MIR and removes any `EndRegion` that is applied to a region that\n //! was not seen in the previous pass.\n //!\n-//! The `CleanUserAssertTy` pass runs at a distinct time from the\n-//! `CleanEndRegions` pass. It is important that the `CleanUserAssertTy`\n+//! The `CleanAscribeUserType` pass runs at a distinct time from the\n+//! `CleanEndRegions` pass. It is important that the `CleanAscribeUserType`\n //! pass runs after the MIR borrowck so that the NLL type checker can\n-//! perform the type assertion when it encounters the `UserAssertTy`\n+//! perform the type assertion when it encounters the `AscribeUserType`\n //! statements.\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -110,26 +110,26 @@ impl<'a, 'tcx> MutVisitor<'tcx> for DeleteTrivialEndRegions<'a> {\n     }\n }\n \n-pub struct CleanUserAssertTy;\n+pub struct CleanAscribeUserType;\n \n-pub struct DeleteUserAssertTy;\n+pub struct DeleteAscribeUserType;\n \n-impl MirPass for CleanUserAssertTy {\n+impl MirPass for CleanAscribeUserType {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let mut delete = DeleteUserAssertTy;\n+        let mut delete = DeleteAscribeUserType;\n         delete.visit_mir(mir);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for DeleteUserAssertTy {\n+impl<'tcx> MutVisitor<'tcx> for DeleteAscribeUserType {\n     fn visit_statement(&mut self,\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        if let StatementKind::UserAssertTy(..) = statement.kind {\n+        if let StatementKind::AscribeUserType(..) = statement.kind {\n             statement.make_nop();\n         }\n         self.super_statement(block, statement, location);"}, {"sha": "01edfd2bfc9f220a63192f962b350900c9edfbd0", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -303,6 +303,7 @@ fn replace_result_variable<'tcx>(\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n+        user_ty: None,\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n@@ -656,6 +657,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     mir.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_unit(),\n+        user_ty: None,\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n@@ -672,6 +674,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n             ty: gen_ty,\n             mutbl: hir::Mutability::MutMutable,\n         }),\n+        user_ty: None,\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,"}, {"sha": "19fb35be9d4e0567ba270723a76f622c92967c9b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -238,8 +238,8 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         simplify_branches::SimplifyBranches::new(\"initial\"),\n         remove_noop_landing_pads::RemoveNoopLandingPads,\n         simplify::SimplifyCfg::new(\"early-opt\"),\n-        // Remove all `UserAssertTy` statements.\n-        cleanup_post_borrowck::CleanUserAssertTy,\n+        // Remove all `AscribeUserType` statements.\n+        cleanup_post_borrowck::CleanAscribeUserType,\n \n         // These next passes must be executed together\n         add_call_guards::CriticalCallEdges,"}, {"sha": "a2175dce33a833aa9df8e63062fe523393715d80", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1098,7 +1098,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n                 StatementKind::Validate(..) |\n-                StatementKind::UserAssertTy(..) |\n+                StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {}\n             }\n         });"}, {"sha": "f7e44dde186fe04c4005fd4f0932c909362308ef", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -230,7 +230,7 @@ fn check_statement(\n         | StatementKind::StorageDead(_)\n         | StatementKind::Validate(..)\n         | StatementKind::EndRegion(_)\n-        | StatementKind::UserAssertTy(..)\n+        | StatementKind::AscribeUserType(..)\n         | StatementKind::Nop => Ok(()),\n     }\n }"}, {"sha": "a2561d3d79381d3f91be2496b8e45721df653979", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -53,7 +53,7 @@ impl RemoveNoopLandingPads {\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n                 StatementKind::EndRegion(_) |\n-                StatementKind::UserAssertTy(..) |\n+                StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {\n                     // These are all nops in a landing pad (there's some\n                     // borrowck interaction between EndRegion and storage"}, {"sha": "f3e0f5573632ad476f1695e233b29aa3438e7b34", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -163,7 +163,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Validate(..) |\n-            mir::StatementKind::UserAssertTy(..) |\n+            mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,"}, {"sha": "710ccb2053b8492a6a27573026c85d3537fa6c1f", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -17,6 +17,7 @@ use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Display;\n+use std::fmt::Write as _;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n@@ -493,14 +494,18 @@ fn write_scope_tree(\n             };\n \n             let indent = indent + INDENT.len();\n-            let indented_var = format!(\n-                \"{0:1$}let {2}{3:?}: {4:?};\",\n+            let mut indented_var = format!(\n+                \"{0:1$}let {2}{3:?}: {4:?}\",\n                 INDENT,\n                 indent,\n                 mut_str,\n                 local,\n                 var.ty\n             );\n+            if let Some(user_ty) = var.user_ty {\n+                write!(indented_var, \" as {:?}\", user_ty).unwrap();\n+            }\n+            indented_var.push_str(\";\");\n             writeln!(\n                 w,\n                 \"{0:1$} // \\\"{2}\\\" in {3}\","}, {"sha": "2ee5415018f934ece32799bb45f132a1139caac5", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 74, "deletions": 30, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -22,6 +22,7 @@ use syntax::ast::*;\n use syntax::attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::keywords;\n+use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n use errors;\n@@ -98,22 +99,19 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_trait_fn_not_const(&self, constness: Spanned<Constness>) {\n-        match constness.node {\n-            Constness::Const => {\n-                struct_span_err!(self.session, constness.span, E0379,\n-                                 \"trait fns cannot be declared const\")\n-                    .span_label(constness.span, \"trait fns cannot be const\")\n-                    .emit();\n-            }\n-            _ => {}\n+        if constness.node == Constness::Const {\n+            struct_span_err!(self.session, constness.span, E0379,\n+                             \"trait fns cannot be declared const\")\n+                .span_label(constness.span, \"trait fns cannot be const\")\n+                .emit();\n         }\n     }\n \n     fn no_questions_in_bounds(&self, bounds: &GenericBounds, where_: &str, is_trait: bool) {\n         for bound in bounds {\n             if let GenericBound::Trait(ref poly, TraitBoundModifier::Maybe) = *bound {\n                 let mut err = self.err_handler().struct_span_err(poly.span,\n-                                    &format!(\"`?Trait` is not permitted in {}\", where_));\n+                    &format!(\"`?Trait` is not permitted in {}\", where_));\n                 if is_trait {\n                     err.note(&format!(\"traits are `?{}` by default\", poly.trait_ref.path));\n                 }\n@@ -152,26 +150,76 @@ impl<'a> AstValidator<'a> {\n         // Check only lifetime parameters are present and that the lifetime\n         // parameters that are present have no bounds.\n         let non_lt_param_spans: Vec<_> = params.iter().filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    if !param.bounds.is_empty() {\n-                        let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.err_handler()\n-                            .span_err(spans, \"lifetime bounds cannot be used in this context\");\n-                    }\n-                    None\n+            GenericParamKind::Lifetime { .. } => {\n+                if !param.bounds.is_empty() {\n+                    let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n+                    self.err_handler()\n+                        .span_err(spans, \"lifetime bounds cannot be used in this context\");\n                 }\n-                _ => Some(param.ident.span),\n-            }).collect();\n+                None\n+            }\n+            _ => Some(param.ident.span),\n+        }).collect();\n         if !non_lt_param_spans.is_empty() {\n             self.err_handler().span_err(non_lt_param_spans,\n                 \"only lifetime parameters can be used in this context\");\n         }\n     }\n+\n+    /// With eRFC 2497, we need to check whether an expression is ambigious and warn or error\n+    /// depending on the edition, this function handles that.\n+    fn while_if_let_ambiguity(&self, expr: &P<Expr>) {\n+        if let Some((span, op_kind)) = self.while_if_let_expr_ambiguity(&expr) {\n+            let mut err = self.err_handler().struct_span_err(\n+                span, &format!(\"ambigious use of `{}`\", op_kind.to_string())\n+            );\n+\n+            err.note(\n+                \"this will be a error until the `let_chains` feature is stabilized\"\n+            );\n+            err.note(\n+                \"see rust-lang/rust#53668 for more information\"\n+            );\n+\n+            if let Ok(snippet) = self.session.source_map().span_to_snippet(span) {\n+                err.span_suggestion(\n+                    span, \"consider adding parentheses\", format!(\"({})\", snippet),\n+                );\n+            }\n+\n+            err.emit();\n+        }\n+    }\n+\n+    /// With eRFC 2497 adding if-let chains, there is a requirement that the parsing of\n+    /// `&&` and `||` in a if-let statement be unambigious. This function returns a span and\n+    /// a `BinOpKind` (either `&&` or `||` depending on what was ambigious) if it is determined\n+    /// that the current expression parsed is ambigious and will break in future.\n+    fn while_if_let_expr_ambiguity(&self, expr: &P<Expr>) -> Option<(Span, BinOpKind)> {\n+        debug!(\"while_if_let_expr_ambiguity: expr.node: {:?}\", expr.node);\n+        match &expr.node {\n+            ExprKind::Binary(op, _, _) if op.node == BinOpKind::And || op.node == BinOpKind::Or => {\n+                Some((expr.span, op.node))\n+            },\n+            ExprKind::Range(ref lhs, ref rhs, _) => {\n+                let lhs_ambigious = lhs.as_ref()\n+                    .and_then(|lhs| self.while_if_let_expr_ambiguity(lhs));\n+                let rhs_ambigious = rhs.as_ref()\n+                    .and_then(|rhs| self.while_if_let_expr_ambiguity(rhs));\n+\n+                lhs_ambigious.or(rhs_ambigious)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n }\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match expr.node {\n+            ExprKind::IfLet(_, ref expr, _, _) | ExprKind::WhileLet(_, ref expr, _, _) =>\n+                self.while_if_let_ambiguity(&expr),\n             ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n                 span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n             }\n@@ -387,7 +435,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.err_handler().span_err(item.span,\n                                                 \"tuple and unit unions are not permitted\");\n                 }\n-                if vdata.fields().len() == 0 {\n+                if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span,\n                                                 \"unions cannot have zero fields\");\n                 }\n@@ -414,14 +462,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_vis(&mut self, vis: &'a Visibility) {\n-        match vis.node {\n-            VisibilityKind::Restricted { ref path, .. } => {\n-                path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n-                    self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n-                                                \"generic arguments in visibility path\");\n-                });\n-            }\n-            _ => {}\n+        if let VisibilityKind::Restricted { ref path, .. } = vis.node {\n+            path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n+                self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n+                                            \"generic arguments in visibility path\");\n+            });\n         }\n \n         visit::walk_vis(self, vis)\n@@ -591,8 +636,7 @@ impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n             TyKind::ImplTrait(..) => {\n                 if self.is_banned {\n                     struct_span_err!(self.session, t.span, E0667,\n-                                 \"`impl Trait` is not allowed in path parameters\")\n-                        .emit();\n+                        \"`impl Trait` is not allowed in path parameters\").emit();\n                 }\n             }\n             TyKind::Path(ref qself, ref path) => {\n@@ -616,7 +660,7 @@ impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n \n                 for (i, segment) in path.segments.iter().enumerate() {\n                     // Allow `impl Trait` iff we're on the final path segment\n-                    if i == (path.segments.len() - 1) {\n+                    if i == path.segments.len() - 1 {\n                         visit::walk_path_segment(self, path.span, segment);\n                     } else {\n                         self.with_ban(|this|"}, {"sha": "b65a2e3f0e5306f3033f71269c2e0db136a5c07c", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -61,10 +61,8 @@ pub fn print_ast_stats<'v>(krate: &'v ast::Crate, title: &str) {\n impl<'k> StatCollector<'k> {\n \n     fn record<T>(&mut self, label: &'static str, id: Id, node: &T) {\n-        if id != Id::None {\n-            if !self.seen.insert(id) {\n-                return\n-            }\n+        if id != Id::None && !self.seen.insert(id) {\n+            return\n         }\n \n         let entry = self.data.entry(label).or_insert(NodeData {\n@@ -135,40 +133,46 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_item(self, i)\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-\n     fn visit_mod(&mut self, m: &'v hir::Mod, _s: Span, n: NodeId) {\n         self.record(\"Mod\", Id::None, m);\n         hir_visit::walk_mod(self, m, n)\n     }\n+\n     fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem) {\n         self.record(\"ForeignItem\", Id::Node(i.id), i);\n         hir_visit::walk_foreign_item(self, i)\n     }\n+\n     fn visit_local(&mut self, l: &'v hir::Local) {\n         self.record(\"Local\", Id::Node(l.id), l);\n         hir_visit::walk_local(self, l)\n     }\n+\n     fn visit_block(&mut self, b: &'v hir::Block) {\n         self.record(\"Block\", Id::Node(b.id), b);\n         hir_visit::walk_block(self, b)\n     }\n+\n     fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n         self.record(\"Stmt\", Id::Node(s.node.id()), s);\n         hir_visit::walk_stmt(self, s)\n     }\n+\n     fn visit_arm(&mut self, a: &'v hir::Arm) {\n         self.record(\"Arm\", Id::None, a);\n         hir_visit::walk_arm(self, a)\n     }\n+\n     fn visit_pat(&mut self, p: &'v hir::Pat) {\n         self.record(\"Pat\", Id::Node(p.id), p);\n         hir_visit::walk_pat(self, p)\n     }\n+\n     fn visit_decl(&mut self, d: &'v hir::Decl) {\n         self.record(\"Decl\", Id::None, d);\n         hir_visit::walk_decl(self, d)\n     }\n+\n     fn visit_expr(&mut self, ex: &'v hir::Expr) {\n         self.record(\"Expr\", Id::Node(ex.id), ex);\n         hir_visit::walk_expr(self, ex)\n@@ -198,6 +202,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"TraitItem\", Id::Node(ti.id), ti);\n         hir_visit::walk_trait_item(self, ti)\n     }\n+\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         self.record(\"ImplItem\", Id::Node(ii.id), ii);\n         hir_visit::walk_impl_item(self, ii)\n@@ -220,31 +225,38 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"Variant\", Id::None, v);\n         hir_visit::walk_variant(self, v, g, item_id)\n     }\n+\n     fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n         self.record(\"Lifetime\", Id::Node(lifetime.id), lifetime);\n         hir_visit::walk_lifetime(self, lifetime)\n     }\n+\n     fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: hir::HirId, span: Span) {\n         self.record(\"QPath\", Id::None, qpath);\n         hir_visit::walk_qpath(self, qpath, id, span)\n     }\n+\n     fn visit_path(&mut self, path: &'v hir::Path, _id: hir::HirId) {\n         self.record(\"Path\", Id::None, path);\n         hir_visit::walk_path(self, path)\n     }\n+\n     fn visit_path_segment(&mut self,\n                           path_span: Span,\n                           path_segment: &'v hir::PathSegment) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n     }\n+\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n         self.record(\"TypeBinding\", Id::Node(type_binding.id), type_binding);\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }\n+\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n         self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n+\n     fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n         self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);\n         hir_visit::walk_macro_def(self, macro_def)"}, {"sha": "61c2ac161bb08096d35fa7d930246940f0436d34", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -114,9 +114,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 };\n \n                 if loop_id != ast::DUMMY_NODE_ID {\n-                    match self.hir_map.find(loop_id).unwrap() {\n-                        Node::Block(_) => return,\n-                        _=> (),\n+                    if let Node::Block(_) = self.hir_map.find(loop_id).unwrap() {\n+                        return\n                     }\n                 }\n \n@@ -153,10 +152,10 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 self.require_break_cx(\"break\", e.span);\n             }\n-            hir::ExprKind::Continue(label) => {\n-                self.require_label_in_labeled_block(e.span, &label, \"continue\");\n+            hir::ExprKind::Continue(destination) => {\n+                self.require_label_in_labeled_block(e.span, &destination, \"continue\");\n \n-                match label.target_id {\n+                match destination.target_id {\n                     Ok(loop_id) => {\n                         if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n@@ -171,7 +170,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n                         self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n                     }\n-                    _ => {}\n+                    Err(_) => {}\n                 }\n                 self.require_break_cx(\"continue\", e.span)\n             },\n@@ -192,8 +191,7 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n \n     fn require_break_cx(&self, name: &str, span: Span) {\n         match self.cx {\n-            LabeledBlock |\n-            Loop(_) => {}\n+            LabeledBlock | Loop(_) => {}\n             Closure => {\n                 struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n                 .span_label(span, \"cannot break inside of a closure\")"}, {"sha": "0120b5bc5322f1239490cd405c588a6dd72c675e", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -65,15 +65,12 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_mir(mir);\n     }\n \n-    fn visit_basic_block_data(&mut self,\n-                              block: BasicBlock,\n-                              data: &BasicBlockData<'tcx>) {\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.record(\"BasicBlockData\", data);\n         self.super_basic_block_data(block, data);\n     }\n \n-    fn visit_source_scope_data(&mut self,\n-                                   scope_data: &SourceScopeData) {\n+    fn visit_source_scope_data(&mut self, scope_data: &SourceScopeData) {\n         self.record(\"SourceScopeData\", scope_data);\n         self.super_source_scope_data(scope_data);\n     }\n@@ -92,7 +89,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\",\n             StatementKind::InlineAsm { .. } => \"StatementKind::InlineAsm\",\n-            StatementKind::UserAssertTy(..) => \"StatementKind::UserAssertTy\",\n+            StatementKind::AscribeUserType(..) => \"StatementKind::AscribeUserType\",\n             StatementKind::Nop => \"StatementKind::Nop\",\n         }, &statement.kind);\n         self.super_statement(block, statement, location);\n@@ -130,9 +127,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_terminator_kind(block, kind, location);\n     }\n \n-    fn visit_assert_message(&mut self,\n-                            msg: &AssertMessage<'tcx>,\n-                            location: Location) {\n+    fn visit_assert_message(&mut self, msg: &AssertMessage<'tcx>, location: Location) {\n         self.record(\"AssertMessage\", msg);\n         self.record(match *msg {\n             EvalErrorKind::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n@@ -151,9 +146,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_assert_message(msg, location);\n     }\n \n-    fn visit_rvalue(&mut self,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.record(\"Rvalue\", rvalue);\n         let rvalue_kind = match *rvalue {\n             Rvalue::Use(..) => \"Rvalue::Use\",\n@@ -184,9 +177,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_operand(&mut self,\n-                     operand: &Operand<'tcx>,\n-                     location: Location) {\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         self.record(\"Operand\", operand);\n         self.record(match *operand {\n             Operand::Copy(..) => \"Operand::Copy\",\n@@ -234,42 +225,32 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_projection_elem(place, context, location);\n     }\n \n-    fn visit_constant(&mut self,\n-                      constant: &Constant<'tcx>,\n-                      location: Location) {\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.record(\"Constant\", constant);\n         self.super_constant(constant, location);\n     }\n \n-    fn visit_source_info(&mut self,\n-                         source_info: &SourceInfo) {\n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n         self.record(\"SourceInfo\", source_info);\n         self.super_source_info(source_info);\n     }\n \n-    fn visit_closure_substs(&mut self,\n-                            substs: &ClosureSubsts<'tcx>,\n-                            _: Location) {\n+    fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, _: Location) {\n         self.record(\"ClosureSubsts\", substs);\n         self.super_closure_substs(substs);\n     }\n \n-    fn visit_const(&mut self,\n-                   constant: &&'tcx ty::Const<'tcx>,\n-                   _: Location) {\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.record(\"Const\", constant);\n         self.super_const(constant);\n     }\n \n-    fn visit_local_decl(&mut self,\n-                        local: Local,\n-                        local_decl: &LocalDecl<'tcx>) {\n+    fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n         self.record(\"LocalDecl\", local_decl);\n         self.super_local_decl(local, local_decl);\n     }\n \n-    fn visit_source_scope(&mut self,\n-                              scope: &SourceScope) {\n+    fn visit_source_scope(&mut self, scope: &SourceScope) {\n         self.record(\"VisiblityScope\", scope);\n         self.super_source_scope(scope);\n     }"}, {"sha": "74b010f57b01d7c1279b7375ef0ddb1c30210cd4", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 37, "deletions": 53, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -41,8 +41,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax_pos::{Span, DUMMY_SP};\n use self::Promotability::*;\n-use std::ops::{BitAnd, BitOr};\n-\n+use std::ops::{BitAnd, BitAndAssign, BitOr};\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -114,7 +113,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n }\n \n #[must_use]\n-#[derive(Debug, PartialEq)]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n enum Promotability {\n     Promotable,\n     NotPromotable\n@@ -125,23 +124,25 @@ impl BitAnd for Promotability {\n \n     fn bitand(self, rhs: Self) -> Self {\n         match (self, rhs) {\n-            (Promotable, NotPromotable) => NotPromotable,\n-            (NotPromotable, Promotable) => NotPromotable,\n-            (NotPromotable, NotPromotable) => NotPromotable,\n             (Promotable, Promotable) => Promotable,\n+            _ => NotPromotable,\n         }\n     }\n }\n \n+impl BitAndAssign for Promotability {\n+    fn bitand_assign(&mut self, rhs: Self) {\n+        *self = *self & rhs\n+    }\n+}\n+\n impl BitOr for Promotability {\n     type Output = Self;\n \n     fn bitor(self, rhs: Self) -> Self {\n         match (self, rhs) {\n-            (Promotable, NotPromotable) => Promotable,\n-            (NotPromotable, Promotable) => Promotable,\n             (NotPromotable, NotPromotable) => NotPromotable,\n-            (Promotable, Promotable) => Promotable,\n+            _ => Promotable,\n         }\n     }\n }\n@@ -161,7 +162,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n     fn handle_const_fn_call(&mut self, def_id: DefId,\n                             ret_ty: Ty<'gcx>, span: Span) -> Promotability {\n-        if let NotPromotable = self.type_promotability(ret_ty) {\n+        if self.type_promotability(ret_ty) == NotPromotable {\n             return NotPromotable;\n         }\n \n@@ -266,9 +267,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                             }\n                         }\n \n-                        match local.init {\n-                            Some(ref expr) => { let _ = self.check_expr(&expr); },\n-                            None => {},\n+                        if let Some(ref expr) = local.init {\n+                            let _ = self.check_expr(&expr);\n                         }\n                         NotPromotable\n                     }\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_expr(&mut self, ex: &'tcx hir::Expr) -> Promotability {\n         let node_ty = self.tables.node_id_to_type(ex.hir_id);\n         let mut outer = check_expr_kind(self, ex, node_ty);\n-        outer = outer & check_adjustments(self, ex);\n+        outer &= check_adjustments(self, ex);\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n         if self.mut_rvalue_borrows.remove(&ex.id) {\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_block(&mut self, block: &'tcx hir::Block) -> Promotability {\n         let mut iter_result = Promotable;\n         for index in block.stmts.iter() {\n-            iter_result = iter_result & self.check_stmt(index);\n+            iter_result &= self.check_stmt(index);\n         }\n         match block.expr {\n             Some(ref box_expr) => iter_result & self.check_expr(&*box_expr),\n@@ -336,10 +336,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n         hir::ExprKind::Unary(op, ref expr) => {\n             let expr_promotability = v.check_expr(expr);\n-            if v.tables.is_method_call(e) {\n-                return NotPromotable;\n-            }\n-            if op == hir::UnDeref {\n+            if v.tables.is_method_call(e) || op == hir::UnDeref {\n                 return NotPromotable;\n             }\n             expr_promotability\n@@ -353,8 +350,8 @@ fn check_expr_kind<'a, 'tcx>(\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::RawPtr(_) => {\n                     assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n-                        op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n-                        op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n+                            op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n+                            op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n \n                     NotPromotable\n                 }\n@@ -400,7 +397,6 @@ fn check_expr_kind<'a, 'tcx>(\n                         debug!(\"Reference to Static(id={:?}) is unpromotable as it is not \\\n                                referenced from a static\", did);\n                         NotPromotable\n-\n                     }\n                 }\n \n@@ -425,7 +421,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Call(ref callee, ref hirvec) => {\n             let mut call_result = v.check_expr(callee);\n             for index in hirvec.iter() {\n-                call_result = call_result & v.check_expr(index);\n+                call_result &= v.check_expr(index);\n             }\n             let mut callee = &**callee;\n             loop {\n@@ -464,7 +460,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::MethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n             let mut method_call_result = Promotable;\n             for index in hirvec.iter() {\n-                method_call_result = method_call_result & v.check_expr(index);\n+                method_call_result &= v.check_expr(index);\n             }\n             if let Some(def) = v.tables.type_dependent_defs().get(e.hir_id) {\n                 let def_id = def.def_id();\n@@ -483,11 +479,10 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Struct(ref _qpath, ref hirvec, ref option_expr) => {\n             let mut struct_result = Promotable;\n             for index in hirvec.iter() {\n-                struct_result = struct_result & v.check_expr(&index.expr);\n+                struct_result &= v.check_expr(&index.expr);\n             }\n-            match *option_expr {\n-                Some(ref expr) => { struct_result = struct_result & v.check_expr(&expr); },\n-                None => {},\n+            if let Some(ref expr) = *option_expr {\n+                struct_result &= v.check_expr(&expr);\n             }\n             if let ty::Adt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n@@ -506,7 +501,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n-                         body_id, _span, _option_generator_movability) => {\n+                               body_id, _span, _option_generator_movability) => {\n             let nested_body_promotable = v.check_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n@@ -543,7 +538,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Array(ref hirvec) => {\n             let mut array_result = Promotable;\n             for index in hirvec.iter() {\n-                array_result = array_result & v.check_expr(index);\n+                array_result &= v.check_expr(index);\n             }\n             array_result\n         }\n@@ -555,7 +550,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Tup(ref hirvec) => {\n             let mut tup_result = Promotable;\n             for index in hirvec.iter() {\n-                tup_result = tup_result & v.check_expr(index);\n+                tup_result &= v.check_expr(index);\n             }\n             tup_result\n         }\n@@ -576,23 +571,19 @@ fn check_expr_kind<'a, 'tcx>(\n             let _ = v.check_expr(expr);\n             for index in hirvec_arm.iter() {\n                 let _ = v.check_expr(&*index.body);\n-                match index.guard {\n-                    Some(hir::Guard::If(ref expr)) => {\n-                        let _ = v.check_expr(&expr);\n-                    },\n-                    None => {},\n-                };\n+                if let Some(hir::Guard::If(ref expr)) = index.guard {\n+                    let _ = v.check_expr(&expr);\n+                }\n             }\n             NotPromotable\n         }\n \n         hir::ExprKind::If(ref lhs, ref rhs, ref option_expr) => {\n             let _ = v.check_expr(lhs);\n             let _ = v.check_expr(rhs);\n-            match option_expr {\n-                Some(ref expr) => { let _ = v.check_expr(&expr); },\n-                None => {},\n-            };\n+            if let Some(ref expr) = option_expr {\n+                let _ = v.check_expr(&expr);\n+            }\n             NotPromotable\n         }\n \n@@ -610,9 +601,8 @@ fn check_expr_kind<'a, 'tcx>(\n \n         // More control flow (also not very meaningful).\n         hir::ExprKind::Break(_, ref option_expr) | hir::ExprKind::Ret(ref option_expr) => {\n-            match *option_expr {\n-                Some(ref expr) => { let _ = v.check_expr(&expr); },\n-                None => {},\n+            if let Some(ref expr) = *option_expr {\n+                 let _ = v.check_expr(&expr);\n             }\n             NotPromotable\n         }\n@@ -635,10 +625,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         hir::ExprKind::InlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n-            for index in hirvec_lhs.iter() {\n-                let _ = v.check_expr(index);\n-            }\n-            for index in hirvec_rhs.iter() {\n+            for index in hirvec_lhs.iter().chain(hirvec_rhs.iter()) {\n                 let _ = v.check_expr(index);\n             }\n             NotPromotable\n@@ -703,11 +690,8 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n         // These occur when we convert a &T or *T to a *U, as well as\n         // when making a thin pointer (e.g., `*T`) into a fat pointer\n         // (e.g., `*Trait`).\n-        match loan_cause {\n-            euv::LoanCause::AutoUnsafe => {\n-                return;\n-            }\n-            _ => {}\n+        if let euv::LoanCause::AutoUnsafe = loan_cause {\n+            return;\n         }\n \n         let mut cur = cmt;"}, {"sha": "d1a05964c8f6497c0993fc342a40ee201c7e1817", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -39,6 +39,7 @@ use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n+use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::std_inject::injected_crate_name;\n use syntax::symbol::keywords;\n@@ -194,27 +195,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // ergonomically unacceptable.\n         let emit_uniform_paths_canary =\n             !uniform_paths_canary_emitted &&\n-            uniform_paths &&\n+            self.session.rust_2018() &&\n             starts_with_non_keyword;\n         if emit_uniform_paths_canary {\n             let source = prefix_start.unwrap();\n \n-            // HACK(eddyb) For `use x::{self, ...};`, use the ID of the\n-            // `self` nested import for the canary. This allows the\n-            // ambiguity reporting scope to ignore false positives\n-            // in the same way it does for `use x;` (by comparing IDs).\n-            let mut canary_id = id;\n-            if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n-                for &(ref use_tree, id) in items {\n-                    if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n-                        if use_tree.ident().name == keywords::SelfValue.name() {\n-                            canary_id = id;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n             // Helper closure to emit a canary with the given base path.\n             let emit = |this: &mut Self, base: Option<Ident>| {\n                 let subclass = SingleImport {\n@@ -234,7 +219,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     base.into_iter().collect(),\n                     subclass.clone(),\n                     source.span,\n-                    canary_id,\n+                    id,\n                     root_use_tree.span,\n                     root_id,\n                     ty::Visibility::Invisible,\n@@ -833,7 +818,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.macro_prelude.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.macro_use_prelude.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n@@ -1073,4 +1058,13 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n             }\n         }\n     }\n+\n+    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n+        if !attr.is_sugared_doc && is_builtin_attr(attr) {\n+            self.resolver.current_module.builtin_attrs.borrow_mut().push((\n+                attr.path.segments[0].ident, self.expansion, self.current_legacy_scope\n+            ));\n+        }\n+        visit::walk_attribute(self, attr);\n+    }\n }"}, {"sha": "8c769094f521181d3314d0180443c9c189804916", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -81,7 +81,7 @@ use std::mem::replace;\n use rustc_data_structures::sync::Lrc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding};\n+use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -160,8 +160,6 @@ enum ResolutionError<'a> {\n     SelfImportCanOnlyAppearOnceInTheList,\n     /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n     SelfImportOnlyInImportListWithNonEmptyPrefix,\n-    /// error E0432: unresolved import\n-    UnresolvedImport(Option<(Span, &'a str, &'a str)>),\n     /// error E0433: failed to resolve\n     FailedToResolve(&'a str),\n     /// error E0434: can't capture dynamic environment in a fn item\n@@ -370,17 +368,6 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n             err\n         }\n-        ResolutionError::UnresolvedImport(name) => {\n-            let (span, msg) = match name {\n-                Some((sp, n, _)) => (sp, format!(\"unresolved import `{}`\", n)),\n-                None => (span, \"unresolved import\".to_owned()),\n-            };\n-            let mut err = struct_span_err!(resolver.session, span, E0432, \"{}\", msg);\n-            if let Some((_, _, p)) = name {\n-                err.span_label(span, p);\n-            }\n-            err\n-        }\n         ResolutionError::FailedToResolve(msg) => {\n             let mut err = struct_span_err!(resolver.session, span, E0433,\n                                            \"failed to resolve. {}\", msg);\n@@ -1023,8 +1010,9 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, MacroKind, Option<Def>)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, Mark, LegacyScope<'a>, Option<Def>)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n+    builtin_attrs: RefCell<Vec<(Ident, Mark, LegacyScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<Mark>>,\n@@ -1063,6 +1051,7 @@ impl<'a> ModuleData<'a> {\n             resolutions: RefCell::new(FxHashMap()),\n             legacy_macro_resolutions: RefCell::new(Vec::new()),\n             macro_resolutions: RefCell::new(Vec::new()),\n+            builtin_attrs: RefCell::new(Vec::new()),\n             unresolved_invocations: RefCell::new(FxHashSet()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n@@ -1278,23 +1267,30 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n+    fn macro_kind(&self) -> Option<MacroKind> {\n+        match self.def_ignoring_ambiguity() {\n+            Def::Macro(_, kind) => Some(kind),\n+            Def::NonMacroAttr(..) => Some(MacroKind::Attr),\n+            _ => None,\n+        }\n+    }\n+\n     fn descr(&self) -> &'static str {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n \n-    // Suppose that we resolved macro invocation with `invoc_id` to binding `binding` at some\n-    // expansion round `max(invoc_id, binding)` when they both emerged from macros.\n+    // Suppose that we resolved macro invocation with `invoc_parent_expansion` to binding `binding`\n+    // at some expansion round `max(invoc, binding)` when they both emerged from macros.\n     // Then this function returns `true` if `self` may emerge from a macro *after* that\n     // in some later round and screw up our previously found resolution.\n     // See more detailed explanation in\n     // https://github.com/rust-lang/rust/pull/53778#issuecomment-419224049\n-    fn may_appear_after(&self, invoc_id: Mark, binding: &NameBinding) -> bool {\n-        // self > max(invoc_id, binding) => !(self <= invoc_id || self <= binding)\n+    fn may_appear_after(&self, invoc_parent_expansion: Mark, binding: &NameBinding) -> bool {\n+        // self > max(invoc, binding) => !(self <= invoc || self <= binding)\n         // Expansions are partially ordered, so \"may appear after\" is an inversion of\n         // \"certainly appears before or simultaneously\" and includes unordered cases.\n         let self_parent_expansion = self.expansion;\n         let other_parent_expansion = binding.expansion;\n-        let invoc_parent_expansion = invoc_id.parent();\n         let certainly_before_other_or_simultaneously =\n             other_parent_expansion.is_descendant_of(self_parent_expansion);\n         let certainly_before_invoc_or_simultaneously =\n@@ -1440,8 +1436,8 @@ pub struct Resolver<'a, 'b: 'a> {\n \n     crate_loader: &'a mut CrateLoader<'b>,\n     macro_names: FxHashSet<Ident>,\n-    macro_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n-    unshadowable_attrs: FxHashMap<Name, &'a NameBinding<'a>>,\n+    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Def>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n@@ -1757,8 +1753,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             crate_loader,\n             macro_names: FxHashSet(),\n-            macro_prelude: FxHashMap(),\n-            unshadowable_attrs: FxHashMap(),\n+            builtin_macros: FxHashMap(),\n+            macro_use_prelude: FxHashMap(),\n             all_macros: FxHashMap(),\n             macro_map: FxHashMap(),\n             invocations,\n@@ -3340,10 +3336,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 };\n             }\n         }\n-        let is_global = self.macro_prelude.get(&path[0].name).cloned()\n-            .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_global ||\n-                                     self.macro_names.contains(&path[0].modern())) {\n+        if primary_ns != MacroNS &&\n+           (self.macro_names.contains(&path[0].modern()) ||\n+            self.builtin_macros.get(&path[0].name).cloned()\n+                               .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang) ||\n+            self.macro_use_prelude.get(&path[0].name).cloned()\n+                                  .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n@@ -3497,16 +3495,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_invoc_id(base_module, path, opt_ns, Mark::root(),\n-                                        record_used, path_span, crate_lint)\n+        self.resolve_path_with_parent_expansion(base_module, path, opt_ns, Mark::root(),\n+                                                record_used, path_span, crate_lint)\n     }\n \n-    fn resolve_path_with_invoc_id(\n+    fn resolve_path_with_parent_expansion(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Ident],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n-        invoc_id: Mark,\n+        parent_expansion: Mark,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n@@ -3599,8 +3597,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, invoc_id, record_used,\n-                                                        record_used, false, path_span)\n+                self.resolve_lexical_macro_path_segment(ident, ns, None, parent_expansion,\n+                                                        record_used, record_used, path_span)\n                                                         .map(|(binding, _)| binding)\n             } else {\n                 let record_used_id ="}, {"sha": "7733ce475e339529662808efc1f26bd04d521f96", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 106, "deletions": 83, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -109,6 +109,13 @@ pub struct ProcMacError {\n     warn_msg: &'static str,\n }\n \n+// For compatibility bang macros are skipped when resolving potentially built-in attributes.\n+fn macro_kind_mismatch(name: Name, requirement: Option<MacroKind>, candidate: Option<MacroKind>)\n+                       -> bool {\n+    requirement == Some(MacroKind::Attr) && candidate == Some(MacroKind::Bang) &&\n+    (name == \"test\" || name == \"bench\" || is_builtin_attr_name(name))\n+}\n+\n impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -214,24 +221,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n-        self.macro_prelude.insert(ident.name, binding);\n-    }\n-\n-    fn add_unshadowable_attr(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n-        let def_id = DefId {\n-            krate: BUILTIN_MACROS_CRATE,\n-            index: DefIndex::from_array_index(self.macro_map.len(),\n-                                              DefIndexAddressSpace::Low),\n-        };\n-        let kind = ext.kind();\n-        self.macro_map.insert(def_id, ext);\n-        let binding = self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(Def::Macro(def_id, kind), false),\n-            span: DUMMY_SP,\n-            vis: ty::Visibility::Invisible,\n-            expansion: Mark::root(),\n-        });\n-        self.unshadowable_attrs.insert(ident.name, binding);\n+        if self.builtin_macros.insert(ident.name, binding).is_some() {\n+            self.session.span_err(ident.span,\n+                                  &format!(\"built-in macro `{}` was already defined\", ident));\n+        }\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -249,7 +242,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.macro_prelude.get(&name).cloned() {\n+            match self.builtin_macros.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -285,7 +278,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                     }\n                     let trait_name = traits[j].segments[0].ident.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n-                    if !self.macro_prelude.contains_key(&legacy_name) {\n+                    if !self.builtin_macros.contains_key(&legacy_name) {\n                         continue\n                     }\n                     let span = traits.remove(j).span;\n@@ -327,7 +320,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         None\n     }\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         let (path, kind, derives_in_scope) = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } =>\n@@ -340,7 +333,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n                 (path, MacroKind::Derive, &[][..]),\n         };\n \n-        let (def, ext) = self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?;\n+        let (def, ext) = self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n             self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n@@ -355,10 +348,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         Ok(Some(ext))\n     }\n \n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                           derives_in_scope: &[ast::Path], force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        Ok(self.resolve_macro_to_def(path, kind, scope, derives_in_scope, force)?.1)\n+        Ok(self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?.1)\n     }\n \n     fn check_unused_macros(&self) {\n@@ -380,10 +373,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n }\n \n impl<'a, 'cl> Resolver<'a, 'cl> {\n-    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                             derives_in_scope: &[ast::Path], force: bool)\n                             -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(path, kind, scope, derives_in_scope, force);\n+        let def = self.resolve_macro_to_def_inner(path, kind, invoc_id, derives_in_scope, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n         if def != Err(Determinacy::Undetermined) {\n@@ -453,8 +446,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         let invocation = self.invocations[&invoc_id];\n-        let module = invocation.module.get();\n-        self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n+        let parent_expansion = invoc_id.parent();\n+        let parent_legacy_scope = invocation.parent_legacy_scope.get();\n+        self.current_module = invocation.module.get().nearest_item_scope();\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n@@ -464,8 +458,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path_with_invoc_id(None, &path, Some(MacroNS), invoc_id,\n-                                                            false, span, CrateLint::No) {\n+            let def = match self.resolve_path_with_parent_expansion(None, &path, Some(MacroNS),\n+                                                                    parent_expansion, false, span,\n+                                                                    CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -485,25 +480,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n-            self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n+            self.current_module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n-        if kind == MacroKind::Attr {\n-            if let Some(ext) = self.unshadowable_attrs.get(&path[0].name) {\n-                return Ok(ext.def());\n-            }\n-        }\n-\n         let legacy_resolution = self.resolve_legacy_scope(\n-            path[0], invoc_id, invocation.parent_legacy_scope.get(), false\n+            path[0], Some(kind), parent_expansion, parent_legacy_scope, false\n         );\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, invoc_id, false, force,\n-                                                          kind == MacroKind::Attr, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, Some(kind),\n+                                                          parent_expansion, false, force, span) {\n                 Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n@@ -513,8 +502,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         };\n \n-        self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((invoc_id, path[0], kind, result.ok()));\n+        self.current_module.legacy_macro_resolutions.borrow_mut()\n+            .push((path[0], kind, parent_expansion, parent_legacy_scope, result.ok()));\n \n         if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n             return result;\n@@ -561,10 +550,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n-        invoc_id: Mark,\n+        kind: Option<MacroKind>,\n+        parent_expansion: Mark,\n         record_used: bool,\n         force: bool,\n-        is_attr: bool,\n         path_span: Span,\n     ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n         // General principles:\n@@ -585,14 +574,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // (Macro NS)\n         // 1. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled).\n-        // 2. Macro prelude (language, standard library, user-defined legacy plugins lumped into\n-        //    one set) (open, the open part is from macro expansions, not controlled).\n+        // 2. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n         // 2a. User-defined prelude from macro-use\n         //    (open, the open part is from macro expansions, not controlled).\n-        // 2b. Standard library prelude, currently just a macro-use (closed, controlled)\n-        // 2c. Language prelude, perhaps including builtin attributes\n-        //    (closed, controlled, except for legacy plugins).\n-        // 3. Builtin attributes (closed, controlled).\n+        // 2b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n+        // 3. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 4. Language prelude: builtin attributes (closed, controlled).\n \n         assert!(ns == TypeNS  || ns == MacroNS);\n         assert!(force || !record_used); // `record_used` implies `force`\n@@ -613,12 +600,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         enum WhereToResolve<'a> {\n             Module(Module<'a>),\n-            MacroPrelude,\n+            MacroUsePrelude,\n+            BuiltinMacros,\n             BuiltinAttrs,\n             ExternPrelude,\n             ToolPrelude,\n             StdLibPrelude,\n-            PrimitiveTypes,\n+            BuiltinTypes,\n         }\n \n         // Go through all the scopes and try to resolve the name.\n@@ -639,8 +627,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.current_module = orig_current_module;\n                     binding.map(|binding| (binding, FromPrelude(false)))\n                 }\n-                WhereToResolve::MacroPrelude => {\n-                    match self.macro_prelude.get(&ident.name).cloned() {\n+                WhereToResolve::MacroUsePrelude => {\n+                    match self.macro_use_prelude.get(&ident.name).cloned() {\n+                        Some(binding) => Ok((binding, FromPrelude(true))),\n+                        None => Err(Determinacy::Determined),\n+                    }\n+                }\n+                WhereToResolve::BuiltinMacros => {\n+                    match self.builtin_macros.get(&ident.name).cloned() {\n                         Some(binding) => Ok((binding, FromPrelude(true))),\n                         None => Err(Determinacy::Determined),\n                     }\n@@ -649,7 +643,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     // FIXME: Only built-in attributes are not considered as candidates for\n                     // non-attributes to fight off regressions on stable channel (#53205).\n                     // We need to come up with some more principled approach instead.\n-                    if is_attr && is_builtin_attr_name(ident.name) {\n+                    if kind == Some(MacroKind::Attr) && is_builtin_attr_name(ident.name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n@@ -708,7 +702,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                     result\n                 }\n-                WhereToResolve::PrimitiveTypes => {\n+                WhereToResolve::BuiltinTypes => {\n                     if let Some(prim_ty) =\n                             self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n@@ -728,26 +722,31 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                             None => {\n                                 use_prelude = !module.no_implicit_prelude;\n                                 if ns == MacroNS {\n-                                    WhereToResolve::MacroPrelude\n+                                    WhereToResolve::MacroUsePrelude\n                                 } else {\n                                     WhereToResolve::ExternPrelude\n                                 }\n                             }\n                         }\n                     }\n-                    WhereToResolve::MacroPrelude => WhereToResolve::BuiltinAttrs,\n+                    WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n+                    WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n                     WhereToResolve::BuiltinAttrs => break, // nowhere else to search\n                     WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                     WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n-                    WhereToResolve::StdLibPrelude => WhereToResolve::PrimitiveTypes,\n-                    WhereToResolve::PrimitiveTypes => break, // nowhere else to search\n+                    WhereToResolve::StdLibPrelude => WhereToResolve::BuiltinTypes,\n+                    WhereToResolve::BuiltinTypes => break, // nowhere else to search\n                 };\n \n                 continue;\n             }}\n \n             match result {\n                 Ok(result) => {\n+                    if macro_kind_mismatch(ident.name, kind, result.0.macro_kind()) {\n+                        continue_search!();\n+                    }\n+\n                     if !record_used {\n                         return Ok(result);\n                     }\n@@ -756,7 +755,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.0.def() != innermost_result.0.def() &&\n                            (innermost_result.0.is_glob_import() ||\n-                            innermost_result.0.may_appear_after(invoc_id, result.0)) {\n+                            innermost_result.0.may_appear_after(parent_expansion, result.0)) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result.0,\n@@ -784,9 +783,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let determinacy = Determinacy::determined(force);\n-        if determinacy == Determinacy::Determined && is_attr {\n+        if determinacy == Determinacy::Determined && kind == Some(MacroKind::Attr) {\n             // For single-segment attributes interpret determinate \"no resolution\" as a custom\n-            // attribute. (Lexical resolution implies the first segment and is_attr should imply\n+            // attribute. (Lexical resolution implies the first segment and attr kind should imply\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n             let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n@@ -800,10 +799,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     fn resolve_legacy_scope(&mut self,\n                             ident: Ident,\n-                            invoc_id: Mark,\n-                            invoc_parent_legacy_scope: LegacyScope<'a>,\n+                            kind: Option<MacroKind>,\n+                            parent_expansion: Mark,\n+                            parent_legacy_scope: LegacyScope<'a>,\n                             record_used: bool)\n                             -> Option<&'a NameBinding<'a>> {\n+        if macro_kind_mismatch(ident.name, kind, Some(MacroKind::Bang)) {\n+            return None;\n+        }\n+\n         let ident = ident.modern();\n \n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n@@ -820,7 +824,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<&NameBinding> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = invoc_parent_legacy_scope;\n+        let mut where_to_resolve = parent_legacy_scope;\n         loop {\n             let result = match where_to_resolve {\n                 LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n@@ -848,7 +852,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if let Some(innermost_result) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.def() != innermost_result.def() &&\n-                           innermost_result.may_appear_after(invoc_id, result) {\n+                           innermost_result.may_appear_after(parent_expansion, result) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result,\n@@ -885,14 +889,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        for &(invoc_id, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(ident, kind, parent_expansion, parent_legacy_scope, def)\n+                in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n-            let invocation = self.invocations[&invoc_id];\n             let legacy_resolution = self.resolve_legacy_scope(\n-                ident, invoc_id, invocation.parent_legacy_scope.get(), true\n+                ident, Some(kind), parent_expansion, parent_legacy_scope, true\n             );\n             let resolution = self.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n+                ident, MacroNS, Some(kind), parent_expansion, true, true, span\n             );\n \n             let check_consistency = |this: &Self, new_def: Def| {\n@@ -926,12 +930,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     err.emit();\n                 },\n                 (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n-                        if !from_prelude || legacy_binding.may_appear_after(invoc_id, binding) => {\n-                    if legacy_binding.def_ignoring_ambiguity() != binding.def_ignoring_ambiguity() {\n-                        self.report_ambiguity_error(ident, legacy_binding, binding);\n-                    }\n+                        if legacy_binding.def() != binding.def_ignoring_ambiguity() &&\n+                           (!from_prelude ||\n+                            legacy_binding.may_appear_after(parent_expansion, binding)) => {\n+                    self.report_ambiguity_error(ident, legacy_binding, binding);\n                 },\n                 // OK, non-macro-expanded legacy wins over prelude even if defs are different\n+                // Also, legacy and modern can co-exist if their defs are same\n                 (Some(legacy_binding), Ok(_)) |\n                 // OK, unambiguous resolution\n                 (Some(legacy_binding), Err(_)) => {\n@@ -947,6 +952,26 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n             };\n         }\n+\n+        for &(ident, parent_expansion, parent_legacy_scope)\n+                in module.builtin_attrs.borrow().iter() {\n+            let resolve_legacy = |this: &mut Self| this.resolve_legacy_scope(\n+                ident, Some(MacroKind::Attr), parent_expansion, parent_legacy_scope, true\n+            );\n+            let resolve_modern = |this: &mut Self| this.resolve_lexical_macro_path_segment(\n+                ident, MacroNS, Some(MacroKind::Attr), parent_expansion, true, true, ident.span\n+            ).map(|(binding, _)| binding).ok();\n+\n+            if let Some(binding) = resolve_legacy(self).or_else(|| resolve_modern(self)) {\n+                if binding.def_ignoring_ambiguity() !=\n+                        Def::NonMacroAttr(NonMacroAttrKind::Builtin) {\n+                    let builtin_binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n+                                           ty::Visibility::Public, ident.span, Mark::root())\n+                                           .to_name_binding(self.arenas);\n+                    self.report_ambiguity_error(ident, binding, builtin_binding);\n+                }\n+            }\n+        }\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n@@ -958,14 +983,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             None\n         // Then check global macros.\n         }.or_else(|| {\n-            // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-            let macro_prelude = self.macro_prelude.clone();\n-            let names = macro_prelude.iter().filter_map(|(name, binding)| {\n-                if binding.get_macro(self).kind() == kind {\n-                    Some(name)\n-                } else {\n-                    None\n-                }\n+            let names = self.builtin_macros.iter().chain(self.macro_use_prelude.iter())\n+                                                  .filter_map(|(name, binding)| {\n+                if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n             });\n             find_best_match_for_name(names, name, None)\n         // Then check modules.\n@@ -1063,6 +1083,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 self.define(module, ident, MacroNS,\n                             (def, vis, item.span, expansion, IsMacroExport));\n             } else {\n+                if !attr::contains_name(&item.attrs, \"rustc_doc_only_macro\") {\n+                    self.check_reserved_macro_name(ident, MacroNS);\n+                }\n                 self.unused_macros.insert(def_id);\n             }\n         } else {"}, {"sha": "dfbea0ffe2288e370e1589f4aca0a641b72ad110", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 110, "deletions": 35, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -31,7 +31,7 @@ use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::Span;\n+use syntax_pos::{MultiSpan, Span};\n \n use std::cell::{Cell, RefCell};\n use std::collections::BTreeMap;\n@@ -452,13 +452,24 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         })\n     }\n \n+    crate fn check_reserved_macro_name(&self, ident: Ident, ns: Namespace) {\n+        // Reserve some names that are not quite covered by the general check\n+        // performed on `Resolver::builtin_attrs`.\n+        if ns == MacroNS &&\n+           (ident.name == \"cfg\" || ident.name == \"cfg_attr\" || ident.name == \"derive\") {\n+            self.session.span_err(ident.span,\n+                                  &format!(\"name `{}` is reserved in macro namespace\", ident));\n+        }\n+    }\n+\n     // Define the name or return the existing binding if there is a collision.\n     pub fn try_define(&mut self,\n                       module: Module<'a>,\n                       ident: Ident,\n                       ns: Namespace,\n                       binding: &'a NameBinding<'a>)\n                       -> Result<(), &'a NameBinding<'a>> {\n+        self.check_reserved_macro_name(ident, ns);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n@@ -620,9 +631,9 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         }\n \n         #[derive(Default)]\n-        struct UniformPathsCanaryResult {\n-            module_scope: Option<Span>,\n-            block_scopes: Vec<Span>,\n+        struct UniformPathsCanaryResult<'a> {\n+            module_scope: Option<&'a NameBinding<'a>>,\n+            block_scopes: Vec<&'a NameBinding<'a>>,\n         }\n         // Collect all tripped `uniform_paths` canaries separately.\n         let mut uniform_paths_canaries: BTreeMap<\n@@ -632,6 +643,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         let mut errors = false;\n         let mut seen_spans = FxHashSet();\n+        let mut error_vec = Vec::new();\n+        let mut prev_root_id: NodeId = NodeId::new(0);\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n             let error = self.finalize_import(import);\n@@ -661,20 +674,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n                 self.per_ns(|_, ns| {\n                     if let Some(result) = result[ns].get().ok() {\n-                        if let NameBindingKind::Import { directive, .. } = result.kind {\n-                            // Skip canaries that resolve to the import itself.\n-                            // These come from `use crate_name;`, which isn't really\n-                            // ambiguous, as the import can't actually shadow itself.\n-                            if directive.id == import.id {\n-                                return;\n-                            }\n-                        }\n                         if has_explicit_self {\n                             // There should only be one `self::x` (module-scoped) canary.\n-                            assert_eq!(canary_results[ns].module_scope, None);\n-                            canary_results[ns].module_scope = Some(result.span);\n+                            assert!(canary_results[ns].module_scope.is_none());\n+                            canary_results[ns].module_scope = Some(result);\n                         } else {\n-                            canary_results[ns].block_scopes.push(result.span);\n+                            canary_results[ns].block_scopes.push(result);\n                         }\n                     }\n                 });\n@@ -694,29 +699,59 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n                 self.import_dummy_binding(import);\n+                if prev_root_id.as_u32() != 0 &&\n+                    prev_root_id.as_u32() != import.root_id.as_u32() &&\n+                    !error_vec.is_empty(){\n+                    // in case of new import line, throw diagnostic message\n+                    // for previous line.\n+                    let mut empty_vec = vec![];\n+                    mem::swap(&mut empty_vec, &mut error_vec);\n+                    self.throw_unresolved_import_error(empty_vec, None);\n+                }\n                 if !seen_spans.contains(&span) {\n                     let path = import_path_to_string(&import.module_path[..],\n                                                      &import.subclass,\n                                                      span);\n-                    let error = ResolutionError::UnresolvedImport(Some((span, &path, &err)));\n-                    resolve_error(self.resolver, span, error);\n+                    error_vec.push((span, path, err));\n                     seen_spans.insert(span);\n+                    prev_root_id = import.root_id;\n                 }\n             }\n         }\n \n+        let uniform_paths_feature = self.session.features_untracked().uniform_paths;\n         for ((span, _), (name, results)) in uniform_paths_canaries {\n             self.per_ns(|this, ns| {\n-                let results = &results[ns];\n+                let external_crate = if ns == TypeNS && this.extern_prelude.contains(&name) {\n+                    let crate_id =\n+                        this.crate_loader.process_path_extern(name, span);\n+                    Some(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n+                } else {\n+                    None\n+                };\n+                let result_filter = |result: &&NameBinding| {\n+                    // Ignore canaries that resolve to an import of the same crate.\n+                    // That is, we allow `use crate_name; use crate_name::foo;`.\n+                    if let Some(def_id) = external_crate {\n+                        if let Some(module) = result.module() {\n+                            if module.normal_ancestor_id == def_id {\n+                                return false;\n+                            }\n+                        }\n+                    }\n \n-                let has_external_crate =\n-                    ns == TypeNS && this.extern_prelude.contains(&name);\n+                    true\n+                };\n+                let module_scope = results[ns].module_scope.filter(result_filter);\n+                let block_scopes = || {\n+                    results[ns].block_scopes.iter().cloned().filter(result_filter)\n+                };\n \n                 // An ambiguity requires more than one possible resolution.\n                 let possible_resultions =\n-                    (has_external_crate as usize) +\n-                    (results.module_scope.is_some() as usize) +\n-                    (!results.block_scopes.is_empty() as usize);\n+                    (external_crate.is_some() as usize) +\n+                    (module_scope.is_some() as usize) +\n+                    (block_scopes().next().is_some() as usize);\n                 if possible_resultions <= 1 {\n                     return;\n                 }\n@@ -726,44 +761,80 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 let msg = format!(\"`{}` import is ambiguous\", name);\n                 let mut err = this.session.struct_span_err(span, &msg);\n                 let mut suggestion_choices = String::new();\n-                if has_external_crate {\n+                if external_crate.is_some() {\n                     write!(suggestion_choices, \"`::{}`\", name);\n                     err.span_label(span,\n                         format!(\"can refer to external crate `::{}`\", name));\n                 }\n-                if let Some(span) = results.module_scope {\n+                if let Some(result) = module_scope {\n                     if !suggestion_choices.is_empty() {\n                         suggestion_choices.push_str(\" or \");\n                     }\n                     write!(suggestion_choices, \"`self::{}`\", name);\n-                    err.span_label(span,\n-                        format!(\"can refer to `self::{}`\", name));\n+                    if uniform_paths_feature {\n+                        err.span_label(result.span,\n+                            format!(\"can refer to `self::{}`\", name));\n+                    } else {\n+                        err.span_label(result.span,\n+                            format!(\"may refer to `self::{}` in the future\", name));\n+                    }\n                 }\n-                for &span in &results.block_scopes {\n-                    err.span_label(span,\n+                for result in block_scopes() {\n+                    err.span_label(result.span,\n                         format!(\"shadowed by block-scoped `{}`\", name));\n                 }\n                 err.help(&format!(\"write {} explicitly instead\", suggestion_choices));\n-                err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n+                if uniform_paths_feature {\n+                    err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n+                } else {\n+                    err.note(\"in the future, `#![feature(uniform_paths)]` may become the default\");\n+                }\n                 err.emit();\n             });\n         }\n \n+        if !error_vec.is_empty() {\n+            self.throw_unresolved_import_error(error_vec.clone(), None);\n+        }\n+\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !errors {\n             for import in &self.indeterminate_imports {\n                 if import.is_uniform_paths_canary {\n                     continue;\n                 }\n-\n-                let error = ResolutionError::UnresolvedImport(None);\n-                resolve_error(self.resolver, import.span, error);\n+                self.throw_unresolved_import_error(error_vec, Some(MultiSpan::from(import.span)));\n                 break;\n             }\n         }\n     }\n \n+    fn throw_unresolved_import_error(&self, error_vec: Vec<(Span, String, String)>,\n+                                     span: Option<MultiSpan>) {\n+        let max_span_label_msg_count = 10;  // upper limit on number of span_label message.\n+        let (span,msg) = match error_vec.is_empty() {\n+            true => (span.unwrap(), \"unresolved import\".to_string()),\n+            false => {\n+                let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n+                                    .map(|elem: (Span, String, String)| { elem.0 }\n+                                    ).collect());\n+                let path_vec: Vec<String> = error_vec.clone().into_iter()\n+                                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) }\n+                                ).collect();\n+                let path = path_vec.join(\", \");\n+                let msg = format!(\"unresolved import{} {}\",\n+                                if path_vec.len() > 1 { \"s\" } else { \"\" },  path);\n+                (span, msg)\n+            }\n+        };\n+        let mut err = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n+        for span_error in error_vec.into_iter().take(max_span_label_msg_count) {\n+            err.span_label(span_error.0, span_error.2);\n+        }\n+        err.emit();\n+    }\n+\n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n@@ -930,11 +1001,15 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             _ => unreachable!(),\n         };\n \n+        // Do not record uses from canaries, to avoid interfering with other\n+        // diagnostics or suggestions that rely on some items not being used.\n+        let record_used = !directive.is_uniform_paths_canary;\n+\n         let mut all_ns_err = true;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n-                if this.record_use(ident, ns, binding) {\n+                if record_used && this.record_use(ident, ns, binding) {\n                     if let ModuleOrUniformRoot::Module(module) = module {\n                         this.resolution(module, ident, ns).borrow_mut().binding =\n                             Some(this.dummy_binding);\n@@ -946,7 +1021,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, true, span) {\n+                match this.resolve_ident_in_module(module, ident, ns, record_used, span) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }"}, {"sha": "62462f04d8f56574706e040b8daba5aa2988fde3", "filename": "src/librustc_target/abi/call/amdgpu.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Famdgpu.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use abi::call::{ArgType, FnType, };\n+use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+\n+fn classify_ret_ty<'a, Ty, C>(_tuncx: C, ret: &mut ArgType<'a, Ty>)\n+  where Ty: TyLayoutMethods<'a, C> + Copy,\n+        C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n+  ret.extend_integer_width_to(32);\n+}\n+\n+fn classify_arg_ty<'a, Ty, C>(_cx: C, arg: &mut ArgType<'a, Ty>)\n+  where Ty: TyLayoutMethods<'a, C> + Copy,\n+        C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n+  arg.extend_integer_width_to(32);\n+}\n+\n+pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>)\n+  where Ty: TyLayoutMethods<'a, C> + Copy,\n+        C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+{\n+  if !fty.ret.is_ignore() {\n+    classify_ret_ty(cx, &mut fty.ret);\n+  }\n+\n+  for arg in &mut fty.args {\n+    if arg.is_ignore() {\n+      continue;\n+    }\n+    classify_arg_ty(cx, arg);\n+  }\n+}"}, {"sha": "788497a378fe9ee549874dfd2063b3fe84a23d56", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -13,6 +13,7 @@ use abi::{HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n use spec::HasTargetSpec;\n \n mod aarch64;\n+mod amdgpu;\n mod arm;\n mod asmjs;\n mod hexagon;\n@@ -503,6 +504,7 @@ impl<'a, Ty> FnType<'a, Ty> {\n                 x86_64::compute_abi_info(cx, self);\n             },\n             \"aarch64\" => aarch64::compute_abi_info(cx, self),\n+            \"amdgpu\" => amdgpu::compute_abi_info(cx, self),\n             \"arm\" => arm::compute_abi_info(cx, self),\n             \"mips\" => mips::compute_abi_info(cx, self),\n             \"mips64\" => mips64::compute_abi_info(cx, self),"}, {"sha": "45a5e5115a39b0ed23d77d2bd248722109d3b667", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1257,9 +1257,11 @@ impl DocFolder for Cache {\n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = item.inner {\n             if let Some(did) = i.trait_.def_id() {\n-                self.implementors.entry(did).or_default().push(Impl {\n-                    impl_item: item.clone(),\n-                });\n+                if i.blanket_impl.is_none() {\n+                    self.implementors.entry(did).or_default().push(Impl {\n+                        impl_item: item.clone(),\n+                    });\n+                }\n             }\n         }\n \n@@ -2931,7 +2933,6 @@ fn item_trait(\n \n \n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) = local.iter()\n-            .filter(|i| i.inner_impl().blanket_impl.is_none())\n             .partition(|i| i.inner_impl().synthetic);\n \n         if !foreign.is_empty() {\n@@ -2941,17 +2942,14 @@ fn item_trait(\n                 </h2>\n             \")?;\n \n-            let mut foreign_cache = FxHashSet();\n             for implementor in foreign {\n-                if foreign_cache.insert(implementor.inner_impl().to_string()) {\n-                    let assoc_link = AssocItemLink::GotoSource(\n-                        implementor.impl_item.def_id,\n-                        &implementor.inner_impl().provided_trait_methods\n-                    );\n-                    render_impl(w, cx, &implementor, assoc_link,\n-                                RenderMode::Normal, implementor.impl_item.stable_since(), false,\n-                                None)?;\n-                }\n+                let assoc_link = AssocItemLink::GotoSource(\n+                    implementor.impl_item.def_id,\n+                    &implementor.inner_impl().provided_trait_methods\n+                );\n+                render_impl(w, cx, &implementor, assoc_link,\n+                            RenderMode::Normal, implementor.impl_item.stable_since(), false,\n+                            None)?;\n             }\n         }\n "}, {"sha": "804d43f4fc683a38bfd3a82168989fe7d4b2618c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -166,14 +166,14 @@ impl DefaultResizePolicy {\n // Our hash generation scheme consists of generating a 64-bit hash and\n // truncating the most significant bits. When moving to the new table, we\n // simply introduce a new bit to the front of the hash. Therefore, if an\n-// elements has ideal index i in the old table, it can have one of two ideal\n+// element has ideal index i in the old table, it can have one of two ideal\n // locations in the new table. If the new bit is 0, then the new ideal index\n // is i. If the new bit is 1, then the new ideal index is n + i. Intuitively,\n // we are producing two independent tables of size n, and for each element we\n // independently choose which table to insert it into with equal probability.\n-// However the rather than wrapping around themselves on overflowing their\n-// indexes, the first table overflows into the first, and the first into the\n-// second. Visually, our new table will look something like:\n+// However, rather than wrapping around themselves on overflowing their\n+// indexes, the first table overflows into the second, and the second into the\n+// first. Visually, our new table will look something like:\n //\n // [yy_xxx_xxxx_xxx|xx_yyy_yyyy_yyy]\n //"}, {"sha": "372f3e83e3dcdccbd0df8fc8a75318f15d1fc917", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -33,7 +33,7 @@ use sys;\n /// type is a static guarantee that the underlying bytes contain no interior 0\n /// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n ///\n-/// `CString` is to [`CStr`] as [`String`] is to [`&str`]: the former\n+/// `CString` is to [`&CStr`] as [`String`] is to [`&str`]: the former\n /// in each pair are owned strings; the latter are borrowed\n /// references.\n ///\n@@ -88,6 +88,7 @@ use sys;\n /// [slice.len]: ../primitive.slice.html#method.len\n /// [`Deref`]: ../ops/trait.Deref.html\n /// [`CStr`]: struct.CStr.html\n+/// [`&CStr`]: struct.CStr.html\n ///\n /// # Examples\n ///\n@@ -137,7 +138,7 @@ pub struct CString {\n /// converted to a Rust [`&str`] by performing UTF-8 validation, or\n /// into an owned [`CString`].\n ///\n-/// `CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n+/// `&CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n /// in each pair are borrowed references; the latter are owned\n /// strings.\n ///"}, {"sha": "278ee7951b3d210d7a2a22c76b9e66678b9154ed", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1330,7 +1330,8 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BufRead: Read {\n-    /// Fills the internal buffer of this object, returning the buffer contents.\n+    /// Returns the contents of the internal buffer, filling it with more data\n+    /// from the inner reader if it is empty.\n     ///\n     /// This function is a lower-level call. It needs to be paired with the\n     /// [`consume`] method to function properly. When calling this"}, {"sha": "5c9e88dc57ca6ea869c72dbca80edf95b7785fce", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -307,7 +307,7 @@\n #![feature(doc_cfg)]\n #![feature(doc_masked)]\n #![feature(doc_spotlight)]\n-#![cfg_attr(windows, feature(used))]\n+#![cfg_attr(all(windows, stage0), feature(used))]\n #![feature(doc_alias)]\n #![feature(doc_keyword)]\n #![feature(panic_info_message)]"}, {"sha": "07c3e578e5b04c88ae28d08574c60b88a47998a0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -721,17 +721,15 @@ pub trait Resolver {\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n-    fn add_unshadowable_attr(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n                               -> Option<Attribute>;\n \n-    fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n+    fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n-\n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n+    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n                           derives_in_scope: &[ast::Path], force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy>;\n \n@@ -761,16 +759,15 @@ impl Resolver for DummyResolver {\n     fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n                                             _derives: &[Mark]) {}\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n-    fn add_unshadowable_attr(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n                               -> Option<Attribute> { None }\n-    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _scope: Mark, _force: bool)\n+    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _invoc_id: Mark, _force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n-    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _scope: Mark,\n+    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _invoc_id: Mark,\n                           _derives_in_scope: &[ast::Path], _force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "7b4e1814a33d7bdc7f553bc88710df8593b69f7b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1074,6 +1074,21 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.collect(kind, InvocationKind::Attr { attr, traits, item })\n     }\n \n+    fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+        let attr = attrs.iter()\n+                        .position(|a| !attr::is_known(a) && !is_builtin_attr(a))\n+                        .map(|i| attrs.remove(i));\n+        if let Some(attr) = &attr {\n+            if !self.cx.ecfg.enable_custom_inner_attributes() &&\n+               attr.style == ast::AttrStyle::Inner && attr.path != \"test\" {\n+                emit_feature_err(&self.cx.parse_sess, \"custom_inner_attributes\",\n+                                 attr.span, GateIssue::Language,\n+                                 \"non-builtin inner attributes are unstable\");\n+            }\n+        }\n+        attr\n+    }\n+\n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n     fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)\n         where T: HasAttrs,\n@@ -1087,7 +1102,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = find_attr_invoc(&mut attrs);\n+            attr = self.find_attr_invoc(&mut attrs);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n             attrs\n         });\n@@ -1108,7 +1123,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = find_attr_invoc(&mut attrs);\n+            attr = self.find_attr_invoc(&mut attrs);\n             attrs\n         });\n \n@@ -1145,12 +1160,6 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n-pub fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n-    attrs.iter()\n-         .position(|a| !attr::is_known(a) && !is_builtin_attr(a))\n-         .map(|i| attrs.remove(i))\n-}\n-\n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let mut expr = self.cfg.configure_expr(expr).into_inner();\n@@ -1582,6 +1591,12 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn proc_macro_expr = proc_macro_expr,\n         fn proc_macro_non_items = proc_macro_non_items,\n     }\n+\n+    fn enable_custom_inner_attributes(&self) -> bool {\n+        self.features.map_or(false, |features| {\n+            features.custom_inner_attributes || features.custom_attribute || features.rustc_attrs\n+        })\n+    }\n }\n \n // A Marker adds the given mark to the syntax context."}, {"sha": "2b4daa6440c0cee481cead9042c16b7a35bff761", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -37,7 +37,7 @@ use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use symbol::{keywords, Symbol};\n \n-use std::{env, path};\n+use std::{env};\n \n macro_rules! set {\n     // The const_fn feature also enables the min_const_fn feature, because `min_const_fn` allows\n@@ -349,9 +349,6 @@ declare_features! (\n     // Allows the `try {...}` expression\n     (active, try_blocks, \"1.29.0\", Some(31436), None),\n \n-    // Used to preserve symbols (see llvm.used)\n-    (active, used, \"1.18.0\", Some(40289), None),\n-\n     // Allows module-level inline assembly by way of global_asm!()\n     (active, global_asm, \"1.18.0\", Some(35119), None),\n \n@@ -409,9 +406,6 @@ declare_features! (\n     // Resolve absolute paths as paths from other crates\n     (active, extern_absolute_paths, \"1.24.0\", Some(44660), Some(Edition::Edition2018)),\n \n-    // `foo.rs` as an alternative to `foo/mod.rs`\n-    (active, non_modrs_mods, \"1.24.0\", Some(44660), Some(Edition::Edition2018)),\n-\n     // `extern` in paths\n     (active, extern_in_paths, \"1.23.0\", Some(44660), None),\n \n@@ -518,6 +512,9 @@ declare_features! (\n     // #![test_runner]\n     // #[test_case]\n     (active, custom_test_frameworks, \"1.30.0\", Some(50297), None),\n+\n+    // Non-builtin attributes in inner attribute position\n+    (active, custom_inner_attributes, \"1.30.0\", Some(38356), None),\n );\n \n declare_features! (\n@@ -660,6 +657,8 @@ declare_features! (\n     (accepted, repr_transparent, \"1.28.0\", Some(43036), None),\n     // Defining procedural macros in `proc-macro` crates\n     (accepted, proc_macro, \"1.29.0\", Some(38356), None),\n+    // `foo.rs` as an alternative to `foo/mod.rs`\n+    (accepted, non_modrs_mods, \"1.30.0\", Some(44660), None),\n     // Allows use of the :vis macro fragment specifier\n     (accepted, macro_vis_matcher, \"1.30.0\", Some(41022), None),\n     // Allows importing and reexporting macros with `use`,\n@@ -674,6 +673,9 @@ declare_features! (\n     // Allows all literals in attribute lists and values of key-value pairs.\n     (accepted, attr_literals, \"1.30.0\", Some(34981), None),\n     (accepted, panic_handler, \"1.30.0\", Some(44489), None),\n+    // Used to preserve symbols (see llvm.used)\n+    (accepted, used, \"1.30.0\", Some(40289), None),\n+\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -1068,10 +1070,7 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                   \"unwind_attributes\",\n                                   \"#[unwind] is experimental\",\n                                   cfg_fn!(unwind_attributes))),\n-    (\"used\", Whitelisted, Gated(\n-        Stability::Unstable, \"used\",\n-        \"the `#[used]` attribute is an experimental feature\",\n-        cfg_fn!(used))),\n+    (\"used\", Whitelisted, Ungated),\n \n     // used in resolve\n     (\"prelude_import\", Whitelisted, Gated(Stability::Unstable,\n@@ -1498,31 +1497,6 @@ impl<'a> PostExpansionVisitor<'a> {\n     }\n }\n \n-impl<'a> PostExpansionVisitor<'a> {\n-    fn whole_crate_feature_gates(&mut self, _krate: &ast::Crate) {\n-        for &(ident, span) in &*self.context.parse_sess.non_modrs_mods.borrow() {\n-            if !span.allows_unstable() {\n-                let cx = &self.context;\n-                let level = GateStrength::Hard;\n-                let has_feature = cx.features.non_modrs_mods;\n-                let name = \"non_modrs_mods\";\n-                debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\",\n-                        name, span, has_feature);\n-\n-                if !has_feature && !span.allows_unstable() {\n-                    leveled_feature_err(\n-                        cx.parse_sess, name, span, GateIssue::Language,\n-                        \"mod statements in non-mod.rs files are unstable\", level\n-                    )\n-                    .help(&format!(\"on stable builds, rename this file to {}{}mod.rs\",\n-                                   ident, path::MAIN_SEPARATOR))\n-                    .emit();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if !attr.span.allows_unstable() {\n@@ -2092,7 +2066,6 @@ pub fn check_crate(krate: &ast::Crate,\n     };\n \n     let visitor = &mut PostExpansionVisitor { context: &ctx };\n-    visitor.whole_crate_feature_gates(krate);\n     visit::walk_crate(visitor, krate);\n }\n "}, {"sha": "aa47d5bf669bc0eb9f6015c78739094d9cb78951", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -66,10 +66,10 @@ pub struct StringReader<'a> {\n     /// The raw source span which *does not* take `override_span` into account\n     span_src_raw: Span,\n     open_braces: Vec<(token::DelimToken, Span)>,\n-    /// The type and spans for all braces that have different indentation.\n+    /// The type and spans for all braces\n     ///\n     /// Used only for error recovery when arriving to EOF with mismatched braces.\n-    suspicious_open_spans: Vec<(token::DelimToken, Span, Span)>,\n+    matching_delim_spans: Vec<(token::DelimToken, Span, Span)>,\n     crate override_span: Option<Span>,\n     last_unclosed_found_span: Option<Span>,\n }\n@@ -220,7 +220,7 @@ impl<'a> StringReader<'a> {\n             span: syntax_pos::DUMMY_SP,\n             span_src_raw: syntax_pos::DUMMY_SP,\n             open_braces: Vec::new(),\n-            suspicious_open_spans: Vec::new(),\n+            matching_delim_spans: Vec::new(),\n             override_span,\n             last_unclosed_found_span: None,\n         }"}, {"sha": "8047ab014651474d0a5b1bfafc1d3c03001c9768", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -44,6 +44,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn parse_token_tree(&mut self) -> PResult<'a, TokenStream> {\n+        let sm = self.sess.source_map();\n         match self.token {\n             token::Eof => {\n                 let msg = \"this file contains an un-closed delimiter\";\n@@ -53,20 +54,25 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 if let Some((delim, _)) = self.open_braces.last() {\n-                    if let Some((d, open_sp, close_sp)) = self.suspicious_open_spans.iter()\n-                        .filter(|(d, _, _)| delim == d)\n-                        .next()  // these are in reverse order as they get inserted on close, but\n-                    {            // we want the last open/first close\n-                        if d == delim {\n-                            err.span_label(\n-                                *open_sp,\n-                                \"this delimiter might not be properly closed...\",\n-                            );\n-                            err.span_label(\n-                                *close_sp,\n-                                \"...as it matches this but it has different indentation\",\n-                            );\n+                    if let Some((_, open_sp, close_sp)) = self.matching_delim_spans.iter()\n+                        .filter(|(d, open_sp, close_sp)| {\n+\n+                        if let Some(close_padding) = sm.span_to_margin(*close_sp) {\n+                            if let Some(open_padding) = sm.span_to_margin(*open_sp) {\n+                                return delim == d && close_padding != open_padding;\n+                            }\n                         }\n+                        false\n+                        }).next()  // these are in reverse order as they get inserted on close, but\n+                    {              // we want the last open/first close\n+                        err.span_label(\n+                            *open_sp,\n+                            \"this delimiter might not be properly closed...\",\n+                        );\n+                        err.span_label(\n+                            *close_sp,\n+                            \"...as it matches this but it has different indentation\",\n+                        );\n                     }\n                 }\n                 Err(err)\n@@ -87,20 +93,11 @@ impl<'a> StringReader<'a> {\n                 // Expand to cover the entire delimited token tree\n                 let delim_span = DelimSpan::from_pair(pre_span, self.span);\n \n-                let sm = self.sess.source_map();\n                 match self.token {\n                     // Correct delimiter.\n                     token::CloseDelim(d) if d == delim => {\n                         let (open_brace, open_brace_span) = self.open_braces.pop().unwrap();\n-                        if let Some(current_padding) = sm.span_to_margin(self.span) {\n-                            if let Some(padding) = sm.span_to_margin(open_brace_span) {\n-                                if current_padding != padding {\n-                                    self.suspicious_open_spans.push(\n-                                        (open_brace, open_brace_span, self.span),\n-                                    );\n-                                }\n-                            }\n-                        }\n+                        self.matching_delim_spans.push((open_brace, open_brace_span, self.span));\n                         // Parse the close delimiter.\n                         self.real_token();\n                     }"}, {"sha": "88af4a73a1515a93b58592f3c7628f54050decf7", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -72,18 +72,6 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          enable_quotes: bool) {\n     deriving::register_builtin_derives(resolver);\n \n-    {\n-        let mut register_unshadowable = |name, ext| {\n-            resolver.add_unshadowable_attr(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n-        };\n-\n-        register_unshadowable(Symbol::intern(\"test\"),\n-            MultiModifier(Box::new(test::expand_test)));\n-\n-        register_unshadowable(Symbol::intern(\"bench\"),\n-            MultiModifier(Box::new(test::expand_bench)));\n-    }\n-\n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n@@ -147,6 +135,8 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n     }\n \n     register(Symbol::intern(\"test_case\"), MultiModifier(Box::new(test_case::expand)));\n+    register(Symbol::intern(\"test\"), MultiModifier(Box::new(test::expand_test)));\n+    register(Symbol::intern(\"bench\"), MultiModifier(Box::new(test::expand_bench)));\n \n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),"}, {"sha": "5a081f0363340dd895d0958955d0c84661f60f05", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1 +1 @@\n-Subproject commit 2a1cdeadd3ea8e1eba9cc681037b83f07332763b\n+Subproject commit 5a081f0363340dd895d0958955d0c84661f60f05"}, {"sha": "29b7d508f1c1e5aa0f3bf53f02a7cc4ec1f6fc72", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2018-08-22\n+2018-09-11"}, {"sha": "cf2522be922e3068402f1cadf03cf2492f8620dc", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute-with-error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -11,6 +11,8 @@\n // aux-build:attribute-with-error.rs\n // ignore-stage1\n \n+#![feature(custom_inner_attributes)]\n+\n extern crate attribute_with_error;\n \n use attribute_with_error::foo;"}, {"sha": "e0922c452b5fb0afd8e23a3fb38a58d7fb72fe45", "filename": "src/test/compile-fail-fulldeps/proc-macro/issue-41211.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fissue-41211.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -13,6 +13,8 @@\n // FIXME: https://github.com/rust-lang/rust/issues/41430\n // This is a temporary regression test for the ICE reported in #41211\n \n+#![feature(custom_inner_attributes)]\n+\n #![emit_unchanged]\n //~^ ERROR attribute `emit_unchanged` is currently unknown to the compiler\n extern crate issue_41211;"}, {"sha": "c07e6e31d6287f684b5e2bed0beb8aa8e3fcf160", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-gates.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -22,14 +22,15 @@ extern crate proc_macro_gates as foo;\n use foo::*;\n \n fn _test_inner() {\n-    #![a] // OK\n+    #![a] //~ ERROR: non-builtin inner attributes are unstable\n }\n \n #[a] //~ ERROR: custom attributes cannot be applied to modules\n mod _test2 {}\n \n mod _test2_inner {\n     #![a] //~ ERROR: custom attributes cannot be applied to modules\n+          //~| ERROR: non-builtin inner attributes are unstable\n }\n \n #[a = y] //~ ERROR: must only be followed by a delimiter token"}, {"sha": "097cd66537539ac2bb3a4a7387998253de9ad482", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -49,7 +49,7 @@ pub fn add_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirValidated\")]\n+    except=\"HirBody,TypeckTables,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type() {\n     let _x: u32 = 2u32;"}, {"sha": "f04d4328929686a856ce14b605a80963c885d782", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -19,70 +19,53 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// check that codegen of assignment expressions is sane. Assignments\n-// tend to be absent in simple code, so subtle breakage in them can\n-// leave a quite hard-to-find trail of destruction.\n+// Check codegen for assignments (`a = b`) where the left-hand-side is\n+// not yet initialized. Assignments tend to be absent in simple code,\n+// so subtle breakage in them can leave a quite hard-to-find trail of\n+// destruction.\n \n // ignore-tidy-linelength\n \n fn main() {\n     let nodrop_x = false;\n     let nodrop_y;\n \n+    // Since boolean does not require drop, this can be a simple\n+    // assignment:\n     nodrop_y = nodrop_x;\n \n     let drop_x : Option<Box<u32>> = None;\n     let drop_y;\n \n+    // Since the type of `drop_y` has drop, we generate a `replace`\n+    // terminator:\n     drop_y = drop_x;\n }\n \n // END RUST SOURCE\n // START rustc.main.SimplifyCfg-initial.after.mir\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = const false;\n-//         StorageLive(_2);\n-//         StorageLive(_3);\n-//         _3 = _1;\n-//         _2 = move _3;\n-//         StorageDead(_3);\n-//         StorageLive(_4);\n-//         UserAssertTy(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }, _4);\n-//         _4 = std::option::Option<std::boxed::Box<u32>>::None;\n-//         StorageLive(_5);\n-//         StorageLive(_6);\n-//         _6 = move _4;\n-//         replace(_5 <-move _6) -> [return: bb2, unwind: bb5];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         drop(_6) -> [return: bb6, unwind: bb4];\n-//     }\n-//     bb3: {\n-//         drop(_4) -> bb1;\n-//     }\n-//     bb4: {\n-//         drop(_5) -> bb3;\n-//     }\n-//     bb5: {\n-//         drop(_6) -> bb4;\n-//     }\n-//     bb6: {\n-//         StorageDead(_6);\n-//         _0 = ();\n-//         drop(_5) -> [return: bb7, unwind: bb3];\n-//     }\n-//     bb7: {\n-//         StorageDead(_5);\n-//         drop(_4) -> [return: bb8, unwind: bb1];\n-//     }\n-//     bb8: {\n-//         StorageDead(_4);\n-//         StorageDead(_2);\n-//         StorageDead(_1);\n-//         return;\n-//     }\n+//    bb0: {\n+//        StorageLive(_1);\n+//        _1 = const false;\n+//        StorageLive(_2);\n+//        StorageLive(_3);\n+//        _3 = _1;\n+//        _2 = move _3;\n+//        StorageDead(_3);\n+//        StorageLive(_4);\n+//        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n+//        AscribeUserType(_4, o, Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> });\n+//        StorageLive(_5);\n+//        StorageLive(_6);\n+//        _6 = move _4;\n+//        replace(_5 <- move _6) -> [return: bb2, unwind: bb5];\n+//    }\n+//    ...\n+//    bb2: {\n+//        drop(_6) -> [return: bb6, unwind: bb4];\n+//    }\n+//    ...\n+//    bb5: {\n+//        drop(_6) -> bb4;\n+//    }\n // END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "8a7ea8962fc5d6ba21f626d5fd7d08d058ec2cf9", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Basic test for reborrow constraints: the region (`R5`) that appears\n-// in the type of `r_a` must outlive the region (`R7`) that appears in\n-// the type of `r_b`\n-\n-// compile-flags:-Zborrowck=mir -Zverbose\n-//                              ^^^^^^^^^ force compiler to dump more region information\n-\n-#![allow(warnings)]\n-\n-fn use_x(_: &mut i32) -> bool { true }\n-\n-fn main() {\n-    let mut foo: i32     = 22;\n-    let r_a: &mut i32 = &mut foo;\n-    let r_b: &mut i32 = &mut *r_a;\n-    use_x(r_b);\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-// | '_#7r    | U0 | {bb0[4], bb0[8..=17]}\n-// ...\n-// | '_#9r    | U0 | {bb0[10], bb0[14..=17]}\n-// ...\n-// let _4: &'_#9r mut i32;\n-// ...\n-// let _2: &'_#7r mut i32;\n-// END rustc.main.nll.0.mir"}, {"sha": "6992dd94af3bdda82df6fe9b6d3f86496ffe13d5", "filename": "src/test/run-make-fulldeps/used/used.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frun-make-fulldeps%2Fused%2Fused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frun-make-fulldeps%2Fused%2Fused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fused%2Fused.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![crate_type = \"lib\"]\n-#![feature(used)]\n \n #[used]\n static FOO: u32 = 0;"}, {"sha": "c6a6f23074de0633519ae33822f4a0f18bfb024f", "filename": "src/test/run-pass/.gitattributes", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frun-pass%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frun-pass%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2F.gitattributes?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,2 +1 @@\n lexer-crlf-line-endings-string-literal-doc-comment.rs -text\n-issue-16278.rs -text"}, {"sha": "f692f57abb9c3cd80f334410a37e52a40dc157a7", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -67,6 +67,13 @@ fn async_block(x: u8) -> impl Future<Output = u8> {\n     }\n }\n \n+fn async_block_with_borrow_named_lifetime<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n+    async move {\n+        await!(wake_and_yield_once());\n+        *x\n+    }\n+}\n+\n fn async_nonmove_block(x: u8) -> impl Future<Output = u8> {\n     async move {\n         let future = async {\n@@ -94,6 +101,23 @@ async fn async_fn_with_borrow(x: &u8) -> u8 {\n     *x\n }\n \n+async fn async_fn_with_borrow_named_lifetime<'a>(x: &'a u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+\n+fn async_fn_with_impl_future_named_lifetime<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n+    async move {\n+        await!(wake_and_yield_once());\n+        *x\n+    }\n+}\n+\n+async fn async_fn_with_named_lifetime_multiple_args<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+\n fn async_fn_with_internal_borrow(y: u8) -> impl Future<Output = u8> {\n     async move {\n         await!(async_fn_with_borrow(&y))\n@@ -138,16 +162,43 @@ where\n \n fn main() {\n     macro_rules! test {\n-        ($($fn_name:ident,)*) => { $(\n+        ($($fn_name:expr,)*) => { $(\n             test_future_yields_once_then_returns($fn_name);\n         )* }\n     }\n \n+    macro_rules! test_with_borrow {\n+        ($($fn_name:expr,)*) => { $(\n+            test_future_yields_once_then_returns(|x| {\n+                async move {\n+                    await!($fn_name(&x))\n+                }\n+            });\n+        )* }\n+    }\n+\n     test! {\n         async_block,\n         async_nonmove_block,\n         async_closure,\n         async_fn,\n         async_fn_with_internal_borrow,\n+        |x| {\n+            async move {\n+                unsafe { await!(unsafe_async_fn(x)) }\n+            }\n+        },\n+    }\n+\n+    test_with_borrow! {\n+        async_block_with_borrow_named_lifetime,\n+        async_fn_with_borrow,\n+        async_fn_with_borrow_named_lifetime,\n+        async_fn_with_impl_future_named_lifetime,\n+        |x| {\n+            async move {\n+                await!(async_fn_with_named_lifetime_multiple_args(x, x))\n+            }\n+        },\n     }\n }"}, {"sha": "7b7f9013ca3341a29ba95ff71a2f2ad264e90ebb", "filename": "src/test/rustdoc/auxiliary/issue-53689.rs", "status": "renamed", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-53689.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-53689.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-53689.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[used]\n-fn foo() {}\n-//~^^ ERROR the `#[used]` attribute is an experimental feature\n-\n-fn main() {}\n+pub struct MyStruct;", "previous_filename": "src/test/ui/feature-gates/feature-gate-used.rs"}, {"sha": "bfe5adf8888e6c44f6e2e54112e61c767dcb4f16", "filename": "src/test/rustdoc/issue-53689.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frustdoc%2Fissue-53689.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Frustdoc%2Fissue-53689.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-53689.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-53689.rs\n+\n+#![crate_name = \"foo\"]\n+\n+extern crate issue_53689;\n+\n+// @has foo/trait.MyTrait.html\n+// @!has - 'MyStruct'\n+// @count - '//*[code=\"impl<T> MyTrait for T\"]' 1\n+pub trait MyTrait {}\n+\n+impl<T> MyTrait for T {}\n+\n+mod a {\n+    pub use issue_53689::MyStruct;\n+}"}, {"sha": "6a47e50f62dbb6bbc0872213531d539760acdf70", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs-test.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,20 @@\n+// aux-build:builtin-attrs.rs\n+// compile-flags:--test\n+\n+#![feature(decl_macro, test)]\n+\n+extern crate test;\n+extern crate builtin_attrs;\n+use builtin_attrs::{test, bench};\n+\n+#[test] // OK, shadowed\n+fn test() {}\n+\n+#[bench] // OK, shadowed\n+fn bench(b: &mut test::Bencher) {}\n+\n+fn not_main() {\n+    Test;\n+    Bench;\n+    NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+}"}, {"sha": "db07055b6a1093334f06b7d8dfb21029b46f38f7", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs-test.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs-test.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `NonExistent` in this scope\n+  --> $DIR/ambiguous-builtin-attrs-test.rs:19:5\n+   |\n+LL |     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+   |     ^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "9f4f0abf32486ec3fbb1dd9943990fc2db68286b", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,31 @@\n+// aux-build:builtin-attrs.rs\n+\n+#![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n+\n+extern crate builtin_attrs;\n+use builtin_attrs::{test, bench};\n+use builtin_attrs::*;\n+\n+#[repr(C)] //~ ERROR `repr` is ambiguous\n+struct S;\n+#[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n+struct SCond;\n+\n+#[test] // OK, shadowed\n+fn test() {}\n+\n+#[bench] // OK, shadowed\n+fn bench() {}\n+\n+fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n+    match 0u8 {\n+        #[repr(C)] //~ ERROR `repr` is ambiguous\n+        _ => {}\n+    }\n+}\n+\n+fn main() {\n+    Test;\n+    Bench;\n+    NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+}"}, {"sha": "ea867faf47bb6b7ee017076e3d93bdec466f8bb6", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs.stderr", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,100 @@\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:9:3\n+   |\n+LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |   ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:9:3\n+   |\n+LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |   ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:11:19\n+   |\n+LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n+   |                   ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:11:19\n+   |\n+LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n+   |                   ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:20:34\n+   |\n+LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n+   |                                  ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:20:34\n+   |\n+LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n+   |                                  ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `repr` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:22:11\n+   |\n+LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |           ^^^^ ambiguous name\n+   |\n+note: `repr` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `repr` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:22:11\n+   |\n+LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n+   |           ^^^^\n+   = note: consider adding an explicit import of `repr` to disambiguate\n+\n+error[E0659]: `feature` is ambiguous\n+  --> $DIR/ambiguous-builtin-attrs.rs:3:4\n+   |\n+LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n+   |    ^^^^^^^ ambiguous name\n+   |\n+note: `feature` could refer to the name imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:7:5\n+   |\n+LL | use builtin_attrs::*;\n+   |     ^^^^^^^^^^^^^^^^\n+note: `feature` could also refer to the name defined here\n+  --> $DIR/ambiguous-builtin-attrs.rs:3:4\n+   |\n+LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n+   |    ^^^^^^^\n+   = note: consider adding an explicit import of `feature` to disambiguate\n+\n+error[E0425]: cannot find value `NonExistent` in this scope\n+  --> $DIR/ambiguous-builtin-attrs.rs:30:5\n+   |\n+LL |     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n+   |     ^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors occurred: E0425, E0659.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "e18ca57aab1fcdf9ca223dcb7de7c59e827bbfd3", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/builtin-attrs.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fbuiltin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fbuiltin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fbuiltin-attrs.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_attribute]\n+pub fn feature(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn repr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn test(_: TokenStream, input: TokenStream) -> TokenStream {\n+    \"struct Test;\".parse().unwrap()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn bench(_: TokenStream, input: TokenStream) -> TokenStream {\n+    \"struct Bench;\".parse().unwrap()\n+}"}, {"sha": "ff5984aa67c7acdc48af3a89c7cd73ee7520bc80", "filename": "src/test/ui-fulldeps/proc-macro/reserved-macro-names.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,22 @@\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_attribute]\n+pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n+    //~^ ERROR name `cfg` is reserved in macro namespace\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    //~^ ERROR name `cfg_attr` is reserved in macro namespace\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n+    //~^ ERROR name `derive` is reserved in macro namespace\n+    input\n+}"}, {"sha": "be6e80c3878e18498dfb16ee985fafe9abe5266c", "filename": "src/test/ui-fulldeps/proc-macro/reserved-macro-names.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Freserved-macro-names.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,20 @@\n+error: name `cfg` is reserved in macro namespace\n+  --> $DIR/reserved-macro-names.rs:7:8\n+   |\n+LL | pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n+   |        ^^^\n+\n+error: name `cfg_attr` is reserved in macro namespace\n+  --> $DIR/reserved-macro-names.rs:13:8\n+   |\n+LL | pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+   |        ^^^^^^^^\n+\n+error: name `derive` is reserved in macro namespace\n+  --> $DIR/reserved-macro-names.rs:19:8\n+   |\n+LL | pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n+   |        ^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "ed3e38486baf628a045b33d3709c250044c4d5dd", "filename": "src/test/ui/consts/const-eval/dont_promote_unstable_const_fn.nll.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn.nll.stderr?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,22 +0,0 @@\n-error: `foo` is not yet stable as a const fn\n-  --> $DIR/dont_promote_unstable_const_fn.rs:25:25\n-   |\n-LL | const fn bar() -> u32 { foo() } //~ ERROR `foo` is not yet stable as a const fn\n-   |                         ^^^^^\n-   |\n-   = help: in Nightly builds, add `#![feature(foo)]` to the crate attributes to enable\n-\n-error[E0597]: borrowed value does not live long enough\n-  --> $DIR/dont_promote_unstable_const_fn.rs:33:26\n-   |\n-LL |     let x: &'static _ = &std::time::Duration::from_millis(42).subsec_millis();\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n-LL |     //~^ does not live long enough\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "4c8f2f47d1e8dce593cc47e062c087cc95ba18fc", "filename": "src/test/ui/consts/const-eval/dont_promote_unstable_const_fn_cross_crate.nll.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn_cross_crate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn_cross_crate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn_cross_crate.nll.stderr?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,13 +0,0 @@\n-error[E0597]: borrowed value does not live long enough\n-  --> $DIR/dont_promote_unstable_const_fn_cross_crate.rs:19:29\n-   |\n-LL |     let _x: &'static u32 = &foo(); //~ ERROR does not live long enough\n-   |                             ^^^^^ temporary value does not live long enough\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "e2937573997fc941a313120c7a324f58b87b921f", "filename": "src/test/ui/directory_ownership/mod_file_not_owning.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmod_file_not_owning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmod_file_not_owning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmod_file_not_owning.stderr?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,15 +0,0 @@\n-error[E0658]: mod statements in non-mod.rs files are unstable (see issue #44660)\n-  --> $DIR/mod_file_not_owning_aux1.rs:14:17\n-   |\n-LL |     () => { mod mod_file_not_owning_aux2; }\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n-LL | }\n-LL | m!();\n-   | ----- in this macro invocation\n-   |\n-   = help: add #![feature(non_modrs_mods)] to the crate attributes to enable\n-   = help: on stable builds, rename this file to mod_file_not_owning_aux1/mod.rs\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "0c0b428143416e76ad597345a3f468bd61aecefa", "filename": "src/test/ui/directory_ownership/unowned_mod_with_path.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fdirectory_ownership%2Funowned_mod_with_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fdirectory_ownership%2Funowned_mod_with_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Funowned_mod_with_path.stderr?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,15 +0,0 @@\n-error[E0658]: mod statements in non-mod.rs files are unstable (see issue #44660)\n-  --> $DIR/mod_file_not_owning_aux1.rs:14:17\n-   |\n-LL |     () => { mod mod_file_not_owning_aux2; }\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n-LL | }\n-LL | m!();\n-   | ----- in this macro invocation\n-   |\n-   = help: add #![feature(non_modrs_mods)] to the crate attributes to enable\n-   = help: on stable builds, rename this file to foo/mod.rs\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "0a0b1d573dd04e9fcf64aa95d9a4644e71fbc5c5", "filename": "src/test/ui/dollar-crate/dollar-crate-is-keyword-2.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,17 +1,17 @@\n-error[E0432]: unresolved import `a::$crate`\n-  --> $DIR/dollar-crate-is-keyword-2.rs:15:13\n+error[E0433]: failed to resolve. `$crate` in paths can only be used in start position\n+  --> $DIR/dollar-crate-is-keyword-2.rs:16:16\n    |\n-LL |         use a::$crate; //~ ERROR unresolved import `a::$crate`\n-   |             ^^^^^^^^^ no `$crate` in `a`\n+LL |         use a::$crate::b; //~ ERROR `$crate` in paths can only be used in start position\n+   |                ^^^^^^ `$crate` in paths can only be used in start position\n ...\n LL | m!();\n    | ----- in this macro invocation\n \n-error[E0433]: failed to resolve. `$crate` in paths can only be used in start position\n-  --> $DIR/dollar-crate-is-keyword-2.rs:16:16\n+error[E0432]: unresolved import `a::$crate`\n+  --> $DIR/dollar-crate-is-keyword-2.rs:15:13\n    |\n-LL |         use a::$crate::b; //~ ERROR `$crate` in paths can only be used in start position\n-   |                ^^^^^^ `$crate` in paths can only be used in start position\n+LL |         use a::$crate; //~ ERROR unresolved import `a::$crate`\n+   |             ^^^^^^^^^ no `$crate` in `a`\n ...\n LL | m!();\n    | ----- in this macro invocation"}, {"sha": "d0adcf4025f7f75ac46a31f34551bbbca34e4b42", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-bench.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -20,6 +20,8 @@\n // See issue-12997-1.rs and issue-12997-2.rs to see how `#[bench]` is\n // handled in \"weird places\" when `--test` is passed.\n \n+#![feature(custom_inner_attributes)]\n+\n #![bench                   = \"4100\"]\n \n fn main() { }"}, {"sha": "711159647b76afa7538d8880acd72d55aed88bdb", "filename": "src/test/ui/feature-gates/feature-gate-linker-flavor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linker-flavor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linker-flavor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linker-flavor.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,6 +15,5 @@\n \n #[used]\n fn foo() {}\n-//~^^ ERROR the `#[used]` attribute is an experimental feature\n \n fn main() {}"}, {"sha": "7019a66654832d08629ff6dfd5e9409d58ba790c", "filename": "src/test/ui/feature-gates/feature-gate-linker-flavor.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linker-flavor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linker-flavor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-linker-flavor.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,11 +1,8 @@\n-error[E0658]: the `#[used]` attribute is an experimental feature (see issue #40289)\n+error: attribute must be applied to a `static` variable\n   --> $DIR/feature-gate-linker-flavor.rs:16:1\n    |\n LL | #[used]\n    | ^^^^^^^\n-   |\n-   = help: add #![feature(used)] to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "d650b5ebb3b1942afaacbcfe260366a780848a1f", "filename": "src/test/ui/feature-gates/feature-gate-used.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-used.stderr?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: the `#[used]` attribute is an experimental feature (see issue #40289)\n-  --> $DIR/feature-gate-used.rs:11:1\n-   |\n-LL | #[used]\n-   | ^^^^^^^\n-   |\n-   = help: add #![feature(used)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "2bf38296f2687c4ccf8c50ee529e78482c977688", "filename": "src/test/ui/issue-53565.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissue-53565.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissue-53565.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53565.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use std::time::{foo, bar, buzz};\n+use std::time::{abc, def};\n+fn main(){\n+   println!(\"Hello World!\");\n+}"}, {"sha": "945f5efe4a878103996f73487039d17be9a2a38a", "filename": "src/test/ui/issue-53565.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissue-53565.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissue-53565.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53565.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,20 @@\n+error[E0432]: unresolved imports `std::time::foo`, `std::time::bar`, `std::time::buzz`\n+  --> $DIR/issue-53565.rs:10:17\n+   |\n+LL | use std::time::{foo, bar, buzz};\n+   |                 ^^^  ^^^  ^^^^ no `buzz` in `time`\n+   |                 |    |\n+   |                 |    no `bar` in `time`\n+   |                 no `foo` in `time`\n+\n+error[E0432]: unresolved imports `std::time::abc`, `std::time::def`\n+  --> $DIR/issue-53565.rs:11:17\n+   |\n+LL | use std::time::{abc, def};\n+   |                 ^^^  ^^^ no `def` in `time`\n+   |                 |\n+   |                 no `abc` in `time`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "2e94a27838e433bb6b75fe90a5c5bddef6546656", "filename": "src/test/ui/issues/issue-11692-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -9,6 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    concat!(test!());\n-    //~^ error: cannot find macro `test!` in this scope\n+    concat!(test!()); //~ ERROR `test` can only be used in attributes\n }"}, {"sha": "186c59a61493d68a9863569436759baa8bffea62", "filename": "src/test/ui/issues/issue-11692-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,7 +1,7 @@\n-error: cannot find macro `test!` in this scope\n+error: `test` can only be used in attributes\n   --> $DIR/issue-11692-2.rs:12:13\n    |\n-LL |     concat!(test!());\n+LL |     concat!(test!()); //~ ERROR `test` can only be used in attributes\n    |             ^^^^\n \n error: aborting due to previous error"}, {"sha": "dd1c2a447300b5d16e879913d69f57b41c365593", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -20,8 +20,17 @@ fn make_it() -> for<'a> fn(&'a u32, &'a u32) -> &'a u32 {\n     panic!()\n }\n \n-fn main() {\n+fn foo() {\n     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n     //~^ ERROR higher-ranked subtype error\n     drop(a);\n }\n+\n+fn bar() {\n+    // The code path for patterns is mildly different, so go ahead and\n+    // test that too:\n+    let _: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+    //~^ ERROR higher-ranked subtype error\n+}\n+\n+fn main() { }"}, {"sha": "c9195395b878c47ffefd1df4fb1dfe26b6a1c2f0", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -4,5 +4,11 @@ error: higher-ranked subtype error\n LL |     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n    |                                                          ^^^^^^^^^\n \n-error: aborting due to previous error\n+error: higher-ranked subtype error\n+  --> $DIR/hr-fn-aaa-as-aba.rs:32:58\n+   |\n+LL |     let _: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+   |                                                          ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "bc7b031f72c0bc319fc8bddec7204fface35834d", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -16,9 +16,7 @@\n // another -- effectively, the single lifetime `'a` is just inferred\n // to be the intersection of the two distinct lifetimes.\n //\n-// FIXME: However, we currently reject this example with an error,\n-// because of how we handle binders and equality in `relate_tys`.\n-//\n+// compile-pass\n // compile-flags:-Zno-leak-check\n \n #![feature(nll)]\n@@ -31,7 +29,6 @@ fn make_cell_aa() -> Cell<for<'a> fn(&'a u32, &'a u32)> {\n \n fn aa_eq_ab() {\n     let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n-    //~^ ERROR higher-ranked subtype error\n     drop(a);\n }\n "}, {"sha": "17e8a32cb2ad95d790206326dc529fa310a1d5b1", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,8 +0,0 @@\n-error: higher-ranked subtype error\n-  --> $DIR/hr-fn-aau-eq-abu.rs:33:53\n-   |\n-LL |     let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n-   |                                                     ^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "cc86c8d02d3aac3214fdee460cf9583b3add305b", "filename": "src/test/ui/nll/relate_tys/universe-violation.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,17 @@\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning either argument CANNOT be upcast to one\n+// that returns always its first argument.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn make_it() -> fn(&'static u32) -> &'static u32 {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: fn(_) -> _ = make_it();\n+    let b: fn(&u32) -> &u32 = a;\n+    drop(a);\n+}"}, {"sha": "6dc78789564c71f496898c02885c9c190b96b268", "filename": "src/test/ui/nll/relate_tys/universe-violation.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/universe-violation.rs:15:31\n+   |\n+LL |     let b: fn(&u32) -> &u32 = a;\n+   |                               ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "02b3006c5315c49158668d0f9b49f1abeef88d73", "filename": "src/test/ui/nll/relate_tys/var-appears-twice.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning always its first argument can be upcast to one\n+// that returns either first or second argument.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+use std::cell::Cell;\n+\n+type DoubleCell<A> = Cell<(A, A)>;\n+type DoublePair<A> = (A, A);\n+\n+fn make_cell<'b>(x: &'b u32) -> Cell<(&'static u32, &'b u32)> {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: &'static u32 = &22;\n+    let b = 44;\n+\n+    // Here we get an error because `DoubleCell<_>` requires the same type\n+    // on both parts of the `Cell`, and we can't have that.\n+    let x: DoubleCell<_> = make_cell(&b); //~ ERROR\n+\n+    // Here we do not get an error because `DoublePair<_>` permits\n+    // variance on the lifetimes involved.\n+    let y: DoublePair<_> = make_cell(&b).get();\n+}"}, {"sha": "15c4cc2e100b511625582520edec60fd32a419a1", "filename": "src/test/ui/nll/relate_tys/var-appears-twice.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: `b` does not live long enough\n+  --> $DIR/var-appears-twice.rs:33:38\n+   |\n+LL |     let x: DoubleCell<_> = make_cell(&b); //~ ERROR\n+   |                                      ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `b` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "53d97360c869e3b034ece137fc2143743e1d53ea", "filename": "src/test/ui/nll/user-annotations/patterns.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,121 @@\n+// Test that various patterns also enforce types.\n+\n+#![feature(nll)]\n+\n+fn variable_no_initializer() {\n+    let x = 22;\n+    let y: &'static u32;\n+    y = &x; //~ ERROR\n+}\n+\n+fn tuple_no_initializer() {\n+    // FIXME(#47187): We are not propagating ascribed type through tuples.\n+\n+    let x = 22;\n+    let (y, z): (&'static u32, &'static u32);\n+    y = &x;\n+}\n+\n+fn ref_with_ascribed_static_type() -> u32 {\n+    // Check the behavior in some wacky cases.\n+    let x = 22;\n+    let y = &x; //~ ERROR\n+    let ref z: &'static u32 = y;\n+    **z\n+}\n+\n+fn ref_with_ascribed_any_type() -> u32 {\n+    let x = 22;\n+    let y = &x;\n+    let ref z: &u32 = y;\n+    **z\n+}\n+\n+struct Single<T> { value: T }\n+\n+fn struct_no_initializer() {\n+    // FIXME(#47187): We are not propagating ascribed type through patterns.\n+\n+    let x = 22;\n+    let Single { value: y }: Single<&'static u32>;\n+    y = &x;\n+}\n+\n+fn variable_with_initializer() {\n+    let x = 22;\n+    let y: &'static u32 = &x; //~ ERROR\n+}\n+\n+fn underscore_with_initializer() {\n+    let x = 22;\n+    let _: &'static u32 = &x; //~ ERROR\n+\n+    let _: Vec<&'static String> = vec![&String::new()];\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+\n+    let (_, a): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+\n+    let (_a, b): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+}\n+\n+fn pair_underscores_with_initializer() {\n+    let x = 22;\n+    let (_, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+}\n+\n+fn pair_variable_with_initializer() {\n+    let x = 22;\n+    let (y, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+}\n+\n+fn struct_single_field_variable_with_initializer() {\n+    let x = 22;\n+    let Single { value: y }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+}\n+\n+fn struct_single_field_underscore_with_initializer() {\n+    let x = 22;\n+    let Single { value: _ }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+}\n+\n+struct Double<T> { value1: T, value2: T }\n+\n+fn struct_double_field_underscore_with_initializer() {\n+    let x = 22;\n+    let Double { value1: _, value2: _ }: Double<&'static u32> = Double {\n+        value1: &x, //~ ERROR\n+        value2: &44,\n+    };\n+}\n+\n+fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n+    // The error in this test is inconsistency with\n+    // `static_to_a_to_static_through_tuple`, but \"feels right\" to\n+    // me. It occurs because we special case the single binding case\n+    // and force the type of `y` to be `&'a u32`, even though the\n+    // right-hand side has type `&'static u32`.\n+\n+    let y: &'a u32 = &22;\n+    y //~ ERROR\n+}\n+\n+fn static_to_a_to_static_through_tuple<'a>(x: &'a u32) -> &'static u32 {\n+    // FIXME(#47187): The fact that this type-checks is perhaps surprising.\n+    // What happens is that the right-hand side is constrained to have\n+    // type `&'a u32`, which is possible, because it has type\n+    // `&'static u32`. The variable `y` is then forced to have type\n+    // `&'static u32`, but it is constrained only by the right-hand\n+    // side, not the ascribed type, and hence it passes.\n+\n+    let (y, _z): (&'a u32, u32) = (&22, 44);\n+    y\n+}\n+\n+fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {\n+    let (y, _z): (&'static u32, u32) = (x, 44); //~ ERROR\n+    y\n+}\n+\n+fn main() { }"}, {"sha": "563de1a9e02e0caf99742ee945905e31b18eca4d", "filename": "src/test/ui/nll/user-annotations/patterns.stderr", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,143 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:8:9\n+   |\n+LL |     y = &x; //~ ERROR\n+   |         ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:22:13\n+   |\n+LL |     let y = &x; //~ ERROR\n+   |             ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:46:27\n+   |\n+LL |     let y: &'static u32 = &x; //~ ERROR\n+   |                           ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:51:27\n+   |\n+LL |     let _: &'static u32 = &x; //~ ERROR\n+   |                           ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/patterns.rs:53:41\n+   |\n+LL |     let _: Vec<&'static String> = vec![&String::new()];\n+   |                                         ^^^^^^^^^^^^^ - temporary value only lives until here\n+   |                                         |\n+   |                                         temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/patterns.rs:56:52\n+   |\n+LL |     let (_, a): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+   |                                                    ^^^^^^^^^^^^^      - temporary value only lives until here\n+   |                                                    |\n+   |                                                    temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/patterns.rs:59:53\n+   |\n+LL |     let (_a, b): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+   |                                                     ^^^^^^^^^^^^^      - temporary value only lives until here\n+   |                                                     |\n+   |                                                     temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:65:40\n+   |\n+LL |     let (_, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+   |                                        ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:70:40\n+   |\n+LL |     let (y, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+   |                                        ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:75:69\n+   |\n+LL |     let Single { value: y }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+   |                                                                     ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:80:69\n+   |\n+LL |     let Single { value: _ }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+   |                                                                     ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:88:17\n+   |\n+LL |         value1: &x, //~ ERROR\n+   |                 ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/patterns.rs:101:5\n+   |\n+LL | fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n+   |                                           -- lifetime `'a` defined here\n+...\n+LL |     y //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/patterns.rs:117:40\n+   |\n+LL | fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {\n+   |                            -- lifetime `'a` defined here\n+LL |     let (y, _z): (&'static u32, u32) = (x, 44); //~ ERROR\n+   |                                        ^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to 14 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "9dc85f4d3f92d7948f11bc3eacd9223484033a91", "filename": "src/test/ui/non_modrs_mods/non_modrs_mods.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fnon_modrs_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fnon_modrs_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fnon_modrs_mods.rs?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// Tests the formatting of the feature-gate errors for non_modrs_mods\n-//\n-// gate-test-non_modrs_mods\n-// ignore-windows\n-// ignore-pretty issue #37195\n-pub mod modrs_mod;\n-pub mod foors_mod;\n-\n-#[path = \"some_crazy_attr_mod_dir/arbitrary_name.rs\"]\n-pub mod attr_mod;\n-\n-pub fn main() {\n-    modrs_mod::inner_modrs_mod::innest::foo();\n-    modrs_mod::inner_foors_mod::innest::foo();\n-    foors_mod::inner_modrs_mod::innest::foo();\n-    foors_mod::inner_foors_mod::innest::foo();\n-    attr_mod::inner_modrs_mod::innest::foo();\n-}"}, {"sha": "c45ab734fd57903fb078e51fa4bc7d6edec92dc6", "filename": "src/test/ui/non_modrs_mods/non_modrs_mods.stderr", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fnon_modrs_mods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fnon_modrs_mods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fnon_modrs_mods.stderr?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,39 +0,0 @@\n-error[E0658]: mod statements in non-mod.rs files are unstable (see issue #44660)\n-  --> $DIR/modrs_mod/inner_foors_mod.rs:11:9\n-   |\n-LL | pub mod innest;\n-   |         ^^^^^^\n-   |\n-   = help: add #![feature(non_modrs_mods)] to the crate attributes to enable\n-   = help: on stable builds, rename this file to inner_foors_mod/mod.rs\n-\n-error[E0658]: mod statements in non-mod.rs files are unstable (see issue #44660)\n-  --> $DIR/foors_mod.rs:13:9\n-   |\n-LL | pub mod inner_modrs_mod;\n-   |         ^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(non_modrs_mods)] to the crate attributes to enable\n-   = help: on stable builds, rename this file to foors_mod/mod.rs\n-\n-error[E0658]: mod statements in non-mod.rs files are unstable (see issue #44660)\n-  --> $DIR/foors_mod.rs:14:9\n-   |\n-LL | pub mod inner_foors_mod;\n-   |         ^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(non_modrs_mods)] to the crate attributes to enable\n-   = help: on stable builds, rename this file to foors_mod/mod.rs\n-\n-error[E0658]: mod statements in non-mod.rs files are unstable (see issue #44660)\n-  --> $DIR/foors_mod/inner_foors_mod.rs:11:9\n-   |\n-LL | pub mod innest;\n-   |         ^^^^^^\n-   |\n-   = help: add #![feature(non_modrs_mods)] to the crate attributes to enable\n-   = help: on stable builds, rename this file to inner_foors_mod/mod.rs\n-\n-error: aborting due to 4 previous errors\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "339d49104b021f266c3cebce5e4b4d4b4b35d42d", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2015.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2015\n+\n+// Enabling `ireffutable_let_patterns` isn't necessary for what this tests, but it makes coming up\n+// with examples easier.\n+#![feature(irrefutable_let_patterns)]\n+\n+#[allow(irrefutable_let_patterns)]\n+fn main() {\n+    use std::ops::Range;\n+\n+    if let Range { start: _, end: _ } = true..true && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    if let Range { start: _, end: _ } = true..true || false { }\n+    //~^ ERROR ambigious use of `||`\n+\n+    while let Range { start: _, end: _ } = true..true && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    while let Range { start: _, end: _ } = true..true || false { }\n+    //~^ ERROR ambigious use of `||`\n+\n+    if let true = false && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    while let true = (1 == 2) && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    // The following cases are not an error as parenthesis are used to\n+    // clarify intent:\n+\n+    if let Range { start: _, end: _ } = true..(true || false) { }\n+\n+    if let Range { start: _, end: _ } = true..(true && false) { }\n+\n+    while let Range { start: _, end: _ } = true..(true || false) { }\n+\n+    while let Range { start: _, end: _ } = true..(true && false) { }\n+}"}, {"sha": "8597294913f2754fa92bb582bcff6e49522c6592", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2015.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,56 @@\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2015.rs:21:47\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true && false { }\n+   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `||`\n+  --> $DIR/syntax-ambiguity-2015.rs:24:47\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true || false { }\n+   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2015.rs:27:50\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true && false { }\n+   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `||`\n+  --> $DIR/syntax-ambiguity-2015.rs:30:50\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true || false { }\n+   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2015.rs:33:19\n+   |\n+LL |     if let true = false && false { }\n+   |                   ^^^^^^^^^^^^^^ help: consider adding parentheses: `(false && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2015.rs:36:22\n+   |\n+LL |     while let true = (1 == 2) && false { }\n+   |                      ^^^^^^^^^^^^^^^^^ help: consider adding parentheses: `((1 == 2) && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "baa90bcf8e97102faca8042f9f09b30a485b580a", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2018.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+// Enabling `ireffutable_let_patterns` isn't necessary for what this tests, but it makes coming up\n+// with examples easier.\n+#![feature(irrefutable_let_patterns)]\n+\n+#[allow(irrefutable_let_patterns)]\n+fn main() {\n+    use std::ops::Range;\n+\n+    if let Range { start: _, end: _ } = true..true && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    if let Range { start: _, end: _ } = true..true || false { }\n+    //~^ ERROR ambigious use of `||`\n+\n+    while let Range { start: _, end: _ } = true..true && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    while let Range { start: _, end: _ } = true..true || false { }\n+    //~^ ERROR ambigious use of `||`\n+\n+    if let true = false && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    while let true = (1 == 2) && false { }\n+    //~^ ERROR ambigious use of `&&`\n+\n+    // The following cases are not an error as parenthesis are used to\n+    // clarify intent:\n+\n+    if let Range { start: _, end: _ } = true..(true || false) { }\n+\n+    if let Range { start: _, end: _ } = true..(true && false) { }\n+\n+    while let Range { start: _, end: _ } = true..(true || false) { }\n+\n+    while let Range { start: _, end: _ } = true..(true && false) { }\n+}"}, {"sha": "86ee04747b29dbc80bf75287831923f8ed314df3", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2018.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,56 @@\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2018.rs:21:47\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true && false { }\n+   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `||`\n+  --> $DIR/syntax-ambiguity-2018.rs:24:47\n+   |\n+LL |     if let Range { start: _, end: _ } = true..true || false { }\n+   |                                               ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2018.rs:27:50\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true && false { }\n+   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `||`\n+  --> $DIR/syntax-ambiguity-2018.rs:30:50\n+   |\n+LL |     while let Range { start: _, end: _ } = true..true || false { }\n+   |                                                  ^^^^^^^^^^^^^ help: consider adding parentheses: `(true || false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2018.rs:33:19\n+   |\n+LL |     if let true = false && false { }\n+   |                   ^^^^^^^^^^^^^^ help: consider adding parentheses: `(false && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: ambigious use of `&&`\n+  --> $DIR/syntax-ambiguity-2018.rs:36:22\n+   |\n+LL |     while let true = (1 == 2) && false { }\n+   |                      ^^^^^^^^^^^^^^^^^ help: consider adding parentheses: `((1 == 2) && false)`\n+   |\n+   = note: this will be a error until the `let_chains` feature is stabilized\n+   = note: see rust-lang/rust#53668 for more information\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "4517a4a2f1eec82a9d8dfd6eb530ca15a9aedd8e", "filename": "src/test/ui/run-pass/issues/.gitattributes", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frun-pass%2Fissues%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frun-pass%2Fissues%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Fissues%2F.gitattributes?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1 @@\n+issue-16278.rs -text"}, {"sha": "c3b6c5a38bad75b80fb0350ef2de67c025081583", "filename": "src/test/ui/run-pass/issues/issue-16278.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frun-pass%2Fissues%2Fissue-16278.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frun-pass%2Fissues%2Fissue-16278.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Fissues%2Fissue-16278.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -13,8 +13,9 @@\n \n // this file has some special \\r\\n endings (use xxd to see them)\n \n-fn main() {assert_eq!(b\"\", b\"\\\n+fn main() {assert_eq!(b\"\", b\"\\\r\n                                    \");\n-assert_eq!(b\"\\n\", b\"\n+assert_eq!(b\"\\n\", b\"\r\n \");\n }\n+"}, {"sha": "f4b9588ff0567b8fdbfd9129a0865c440eb60d3b", "filename": "src/test/ui/run-pass/issues/issue-41628.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frun-pass%2Fissues%2Fissue-41628.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frun-pass%2Fissues%2Fissue-41628.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Fissues%2Fissue-41628.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -10,7 +10,6 @@\n \n // run-pass\n #![deny(dead_code)]\n-#![feature(used)]\n \n #[used]\n static FOO: u32 = 0;"}, {"sha": "a9b240be804e3402806a535fca62302d67be3aee", "filename": "src/test/ui/run-pass/non_modrs_mods/non_modrs_mods.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Frun-pass%2Fnon_modrs_mods%2Fnon_modrs_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8134ee25b88df98c79792d60cbf6745b6cb7ffc5/src%2Ftest%2Fui%2Frun-pass%2Fnon_modrs_mods%2Fnon_modrs_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Fnon_modrs_mods%2Fnon_modrs_mods.rs?ref=8134ee25b88df98c79792d60cbf6745b6cb7ffc5", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// run-pass\n-//\n-// ignore-pretty issue #37195\n-#![feature(non_modrs_mods)]\n-\n-pub mod modrs_mod;\n-pub mod foors_mod;\n-\n-#[path = \"some_crazy_attr_mod_dir/arbitrary_name.rs\"]\n-pub mod attr_mod;\n-\n-pub fn main() {\n-    modrs_mod::inner_modrs_mod::innest::foo();\n-    modrs_mod::inner_foors_mod::innest::foo();\n-    foors_mod::inner_modrs_mod::innest::foo();\n-    foors_mod::inner_foors_mod::innest::foo();\n-    attr_mod::inner_modrs_mod::innest::foo();\n-}"}, {"sha": "125e7c3773ae5e693cf3bebba01d26ccf47fc3ad", "filename": "src/test/ui/rust-2018/async-ident.fixed", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.fixed?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -26,7 +26,9 @@ macro_rules! foo {\n     //~| WARN hard error in the 2018 edition\n }\n \n-foo!(async);\n+foo!(r#async);\n+    //~^ ERROR async\n+    //~| WARN hard error in the 2018 edition\n \n mod dont_lint_raw {\n     fn r#async() {}"}, {"sha": "01b974bcbfb0bdb071bf68e3657054e47ec0bb13", "filename": "src/test/ui/rust-2018/async-ident.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -27,6 +27,8 @@ macro_rules! foo {\n }\n \n foo!(async);\n+    //~^ ERROR async\n+    //~| WARN hard error in the 2018 edition\n \n mod dont_lint_raw {\n     fn r#async() {}"}, {"sha": "46e6af84ab8147c7f99b6b93962646a7f7990bc8", "filename": "src/test/ui/rust-2018/async-ident.stderr", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fasync-ident.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -31,7 +31,16 @@ LL |     ($async:expr, async) => {};\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:36:11\n+  --> $DIR/async-ident.rs:29:6\n+   |\n+LL | foo!(async);\n+   |      ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `async` is a keyword in the 2018 edition\n+  --> $DIR/async-ident.rs:38:11\n    |\n LL |     trait async {}\n    |           ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -40,7 +49,7 @@ LL |     trait async {}\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:40:10\n+  --> $DIR/async-ident.rs:42:10\n    |\n LL |     impl async for MyStruct {}\n    |          ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -49,7 +58,7 @@ LL |     impl async for MyStruct {}\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:46:12\n+  --> $DIR/async-ident.rs:48:12\n    |\n LL |     static async: u32 = 0;\n    |            ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -58,7 +67,7 @@ LL |     static async: u32 = 0;\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:52:11\n+  --> $DIR/async-ident.rs:54:11\n    |\n LL |     const async: u32 = 0;\n    |           ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -67,7 +76,7 @@ LL |     const async: u32 = 0;\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:58:15\n+  --> $DIR/async-ident.rs:60:15\n    |\n LL | impl Foo { fn async() {} }\n    |               ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -76,7 +85,7 @@ LL | impl Foo { fn async() {} }\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:63:12\n+  --> $DIR/async-ident.rs:65:12\n    |\n LL |     struct async {}\n    |            ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -85,7 +94,7 @@ LL |     struct async {}\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:66:9\n+  --> $DIR/async-ident.rs:68:9\n    |\n LL |     let async: async = async {};\n    |         ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -94,7 +103,7 @@ LL |     let async: async = async {};\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:66:16\n+  --> $DIR/async-ident.rs:68:16\n    |\n LL |     let async: async = async {};\n    |                ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -103,7 +112,7 @@ LL |     let async: async = async {};\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:66:24\n+  --> $DIR/async-ident.rs:68:24\n    |\n LL |     let async: async = async {};\n    |                        ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -112,7 +121,7 @@ LL |     let async: async = async {};\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:77:19\n+  --> $DIR/async-ident.rs:79:19\n    |\n LL |     () => (pub fn async() {})\n    |                   ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n@@ -121,13 +130,13 @@ LL |     () => (pub fn async() {})\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n error: `async` is a keyword in the 2018 edition\n-  --> $DIR/async-ident.rs:84:6\n+  --> $DIR/async-ident.rs:86:6\n    |\n LL |     (async) => (1)\n    |      ^^^^^ help: you can use a raw identifier to stay compatible: `r#async`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n    = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "c65f0fc30ef0ab99644540689b3bc07acd5ef4a3", "filename": "src/test/ui/rust-2018/try-macro.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.fixed?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,16 @@\n+// Test that `try!` macros are rewritten.\n+\n+// run-rustfix\n+// compile-pass\n+\n+#![warn(rust_2018_compatibility)]\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+\n+fn foo() -> Result<usize, ()> {\n+    let x: Result<usize, ()> = Ok(22);\n+    r#try!(x);\n+    Ok(44)\n+}\n+\n+fn main() { }"}, {"sha": "f435890a61dcb0c8424937a17beedd9292c92f2a", "filename": "src/test/ui/rust-2018/try-macro.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,16 @@\n+// Test that `try!` macros are rewritten.\n+\n+// run-rustfix\n+// compile-pass\n+\n+#![warn(rust_2018_compatibility)]\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+\n+fn foo() -> Result<usize, ()> {\n+    let x: Result<usize, ()> = Ok(22);\n+    try!(x);\n+    Ok(44)\n+}\n+\n+fn main() { }"}, {"sha": "40a4564cc3d6d689f3a0edca1a2131c5deb87091", "filename": "src/test/ui/rust-2018/try-macro.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Ftry-macro.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,15 @@\n+warning: `try` is a keyword in the 2018 edition\n+  --> $DIR/try-macro.rs:12:5\n+   |\n+LL |     try!(x);\n+   |     ^^^ help: you can use a raw identifier to stay compatible: `r#try`\n+   |\n+note: lint level defined here\n+  --> $DIR/try-macro.rs:6:9\n+   |\n+LL | #![warn(rust_2018_compatibility)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: #[warn(keyword_idents)] implied by #[warn(rust_2018_compatibility)]\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+"}, {"sha": "590e83b07819a24e4f33994fc1b9f72d0f14c55a", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+// This test is similar to `ambiguity-macros.rs`, but nested in a module.\n+\n+mod foo {\n+    pub use std::io;\n+    //~^ ERROR `std` import is ambiguous\n+\n+    macro_rules! m {\n+        () => {\n+            mod std {\n+                pub struct io;\n+            }\n+        }\n+    }\n+    m!();\n+}\n+\n+fn main() {}"}, {"sha": "948043cff7614ee3cf0b5187d24e108d444caf0d", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,16 @@\n+error: `std` import is ambiguous\n+  --> $DIR/ambiguity-macros-nested.rs:16:13\n+   |\n+LL |       pub use std::io;\n+   |               ^^^ can refer to external crate `::std`\n+...\n+LL | /             mod std {\n+LL | |                 pub struct io;\n+LL | |             }\n+   | |_____________- may refer to `self::std` in the future\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+\n+error: aborting due to previous error\n+"}, {"sha": "861efba14f80c9ccf098c011b3e80312e6f7299d", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+// This test is similar to `ambiguity.rs`, but with macros defining local items.\n+\n+use std::io;\n+//~^ ERROR `std` import is ambiguous\n+\n+macro_rules! m {\n+    () => {\n+        mod std {\n+            pub struct io;\n+        }\n+    }\n+}\n+m!();\n+\n+fn main() {}"}, {"sha": "40cceea2440b95330876db764e4f0482b0bcdf12", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,16 @@\n+error: `std` import is ambiguous\n+  --> $DIR/ambiguity-macros.rs:15:5\n+   |\n+LL |   use std::io;\n+   |       ^^^ can refer to external crate `::std`\n+...\n+LL | /         mod std {\n+LL | |             pub struct io;\n+LL | |         }\n+   | |_________- may refer to `self::std` in the future\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+\n+error: aborting due to previous error\n+"}, {"sha": "a69eb101917fa50bd4b711fbd939e00339b782a3", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+// This test is similar to `ambiguity.rs`, but nested in a module.\n+\n+mod foo {\n+    pub use std::io;\n+    //~^ ERROR `std` import is ambiguous\n+\n+    mod std {\n+        pub struct io;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7538d3d2d917a2a5988c9154328c99521cfcee37", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,16 @@\n+error: `std` import is ambiguous\n+  --> $DIR/ambiguity-nested.rs:16:13\n+   |\n+LL |       pub use std::io;\n+   |               ^^^ can refer to external crate `::std`\n+...\n+LL | /     mod std {\n+LL | |         pub struct io;\n+LL | |     }\n+   | |_____- may refer to `self::std` in the future\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+\n+error: aborting due to previous error\n+"}, {"sha": "500e9f6c63ff87901671b965ddd82d69af5fe6a0", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.rs", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: mod statements in non-mod.rs files are unstable\n+// edition:2018\n \n-mod mod_file_not_owning_aux1;\n+use std::io;\n+//~^ ERROR `std` import is ambiguous\n+\n+mod std {\n+    pub struct io;\n+}\n \n fn main() {}", "previous_filename": "src/test/ui/directory_ownership/mod_file_not_owning.rs"}, {"sha": "7b64b8f02464af6025435535d8de29daa2b6012e", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,16 @@\n+error: `std` import is ambiguous\n+  --> $DIR/ambiguity.rs:13:5\n+   |\n+LL |   use std::io;\n+   |       ^^^ can refer to external crate `::std`\n+...\n+LL | / mod std {\n+LL | |     pub struct io;\n+LL | | }\n+   | |_- may refer to `self::std` in the future\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+\n+error: aborting due to previous error\n+"}, {"sha": "ca488fec5162de71299105f3e913850c2599e880", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: mod statements in non-mod.rs files are unstable\n+// edition:2018\n \n-// This is not a directory owner since the file name is not \"mod.rs\".\n-#[path = \"mod_file_not_owning_aux1.rs\"]\n-mod foo;\n+struct std;\n+\n+fn main() {\n+    fn std() {}\n+    enum std {}\n+    use std as foo;\n+    //~^ ERROR `std` import is ambiguous\n+    //~| ERROR `std` import is ambiguous\n+}", "previous_filename": "src/test/ui/directory_ownership/unowned_mod_with_path.rs"}, {"sha": "27e0e883691272dab890cab8fc4b1b643a014bca", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,31 @@\n+error: `std` import is ambiguous\n+  --> $DIR/block-scoped-shadow.rs:18:9\n+   |\n+LL | struct std;\n+   | ----------- may refer to `self::std` in the future\n+...\n+LL |     enum std {}\n+   |     ----------- shadowed by block-scoped `std`\n+LL |     use std as foo;\n+   |         ^^^ can refer to external crate `::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+\n+error: `std` import is ambiguous\n+  --> $DIR/block-scoped-shadow.rs:18:9\n+   |\n+LL | struct std;\n+   | ----------- may refer to `self::std` in the future\n+...\n+LL |     fn std() {}\n+   |     ----------- shadowed by block-scoped `std`\n+LL |     enum std {}\n+LL |     use std as foo;\n+   |         ^^^\n+   |\n+   = help: write `self::std` explicitly instead\n+   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "05048cfd451050e39382c4bf39b22df15476c412", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/redundant.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fredundant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fredundant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fredundant.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// edition:2018\n+\n+use std;\n+use std::io;\n+\n+mod foo {\n+    pub use std as my_std;\n+}\n+\n+mod bar {\n+    pub use std::{self};\n+}\n+\n+fn main() {\n+    io::stdout();\n+    self::std::io::stdout();\n+    foo::my_std::io::stdout();\n+    bar::std::io::stdout();\n+}"}, {"sha": "745ac18e059b9c895a5261e52cdd0917fc18bbed", "filename": "src/test/ui/rust-2018/uniform-paths/redundant.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fredundant.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// run-pass\n // edition:2018\n \n #![feature(uniform_paths)]\n \n use std;\n+use std::io;\n \n mod foo {\n     pub use std as my_std;\n@@ -23,6 +25,7 @@ mod bar {\n }\n \n fn main() {\n+    io::stdout();\n     self::std::io::stdout();\n     foo::my_std::io::stdout();\n     bar::std::io::stdout();", "previous_filename": "src/test/run-pass/redundant.rs"}, {"sha": "fbe1535caaed25f008805012ea33b999d37c2c80", "filename": "src/test/ui/span/issue-36530.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// gate-test-custom_inner_attributes\n+\n #[foo] //~ ERROR is currently unknown to the compiler\n mod foo {\n     #![foo] //~ ERROR is currently unknown to the compiler\n+            //~| ERROR non-builtin inner attributes are unstable\n }"}, {"sha": "78d81ad0493068b7e92529994b490ee0814049d0", "filename": "src/test/ui/span/issue-36530.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,19 +1,27 @@\n error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/issue-36530.rs:11:3\n+  --> $DIR/issue-36530.rs:13:3\n    |\n LL | #[foo] //~ ERROR is currently unknown to the compiler\n    |   ^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n+error[E0658]: non-builtin inner attributes are unstable (see issue #38356)\n+  --> $DIR/issue-36530.rs:15:5\n+   |\n+LL |     #![foo] //~ ERROR is currently unknown to the compiler\n+   |     ^^^^^^^\n+   |\n+   = help: add #![feature(custom_inner_attributes)] to the crate attributes to enable\n+\n error[E0658]: The attribute `foo` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n-  --> $DIR/issue-36530.rs:13:8\n+  --> $DIR/issue-36530.rs:15:8\n    |\n LL |     #![foo] //~ ERROR is currently unknown to the compiler\n    |        ^^^\n    |\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "4e24b17bdd5872874cfabd2bb2d1b10b1b89d78c", "filename": "src/test/ui/test-shadowing/test-cant-be-shadowed.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -16,3 +16,8 @@\n \n #[test]\n fn foo(){}\n+\n+macro_rules! test { () => () }\n+\n+#[test]\n+fn bar() {}"}, {"sha": "ebf56dc9835f4928842586f30424f8f2e8d83e43", "filename": "src/test/ui/try-block/try-block-bad-lifetime.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,13 +1,14 @@\n error[E0597]: `my_string` does not live long enough\n   --> $DIR/try-block-bad-lifetime.rs:25:33\n    |\n+LL |         let result: Result<(), &str> = try {\n+   |             ------ borrow later used here\n+LL |             let my_string = String::from(\"\");\n LL |             let my_str: & str = & my_string;\n    |                                 ^^^^^^^^^^^ borrowed value does not live long enough\n ...\n LL |         };\n    |         - `my_string` dropped here while still borrowed\n-LL |         do_something_with(result);\n-   |                           ------ borrow later used here\n \n error[E0506]: cannot assign to `i` because it is borrowed\n   --> $DIR/try-block-bad-lifetime.rs:39:13"}, {"sha": "b3ed8601988d18eec128e447a8aab97c527f7bf7", "filename": "src/test/ui/used.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fused.rs?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(used)]\n-\n #[used]\n static FOO: u32 = 0; // OK\n "}, {"sha": "351fb9404268e2148798981273fe9426d817fcfa", "filename": "src/test/ui/used.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fused.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26dbf56196ccd50a335f38755ea7546f6f1399bd/src%2Ftest%2Fui%2Fused.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fused.stderr?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1,23 +1,23 @@\n error: attribute must be applied to a `static` variable\n-  --> $DIR/used.rs:16:1\n+  --> $DIR/used.rs:14:1\n    |\n LL | #[used] //~ ERROR attribute must be applied to a `static` variable\n    | ^^^^^^^\n \n error: attribute must be applied to a `static` variable\n-  --> $DIR/used.rs:19:1\n+  --> $DIR/used.rs:17:1\n    |\n LL | #[used] //~ ERROR attribute must be applied to a `static` variable\n    | ^^^^^^^\n \n error: attribute must be applied to a `static` variable\n-  --> $DIR/used.rs:22:1\n+  --> $DIR/used.rs:20:1\n    |\n LL | #[used] //~ ERROR attribute must be applied to a `static` variable\n    | ^^^^^^^\n \n error: attribute must be applied to a `static` variable\n-  --> $DIR/used.rs:25:1\n+  --> $DIR/used.rs:23:1\n    |\n LL | #[used] //~ ERROR attribute must be applied to a `static` variable\n    | ^^^^^^^"}, {"sha": "b917e35248fe57d11765c5a835de33e335babb7e", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1 +1 @@\n-Subproject commit 2fb77a49b43bf7266793c07a19a06749e6a8ad5a\n+Subproject commit b917e35248fe57d11765c5a835de33e335babb7e"}, {"sha": "fa922de1e5e1f02b576b7a5aa6ded16935693ec5", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=26dbf56196ccd50a335f38755ea7546f6f1399bd", "patch": "@@ -1 +1 @@\n-Subproject commit 5b5cd9d45719414196e254ec17baa598acc8cd25\n+Subproject commit fa922de1e5e1f02b576b7a5aa6ded16935693ec5"}]}