{"sha": "a611496ddfb3f510635d9921dd1463cc3512d84d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTE0OTZkZGZiM2Y1MTA2MzVkOTkyMWRkMTQ2M2NjMzUxMmQ4NGQ=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-11-23T00:39:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-25T00:21:13Z"}, "message": "std: added missing calls to math; covers C95 completely now, includes tests", "tree": {"sha": "a89784e74517d445646e424208199f2a8ab69189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a89784e74517d445646e424208199f2a8ab69189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a611496ddfb3f510635d9921dd1463cc3512d84d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a611496ddfb3f510635d9921dd1463cc3512d84d", "html_url": "https://github.com/rust-lang/rust/commit/a611496ddfb3f510635d9921dd1463cc3512d84d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a611496ddfb3f510635d9921dd1463cc3512d84d/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd405fb457a42a02e85fc116192ba663ac791146", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd405fb457a42a02e85fc116192ba663ac791146", "html_url": "https://github.com/rust-lang/rust/commit/bd405fb457a42a02e85fc116192ba663ac791146"}], "stats": {"total": 367, "additions": 336, "deletions": 31}, "files": [{"sha": "c870392e6b606fa63d329f612544d0a9454bfb82", "filename": "src/lib/math.rs", "status": "modified", "additions": 111, "deletions": 22, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a611496ddfb3f510635d9921dd1463cc3512d84d/src%2Flib%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a611496ddfb3f510635d9921dd1463cc3512d84d/src%2Flib%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmath.rs?ref=a611496ddfb3f510635d9921dd1463cc3512d84d", "patch": "@@ -5,16 +5,18 @@ export min, max;\n \n export f32, f64;\n \n-// Currently this module supports from -lmath\n-// C95 - frexp - ldexp - fmod - modf + log2 + log1p\n+// Currently this module supports from -lmath:\n+// C95 + log2 + log1p + trunc + round + rint\n \n export\n-    acos, asin, atan, atan2, ceil, cos, cosh, exp, abs, floor,\n-    ln, ln1p, log10, log2, pow, sin, sinh, sqrt, tan, tanh;\n+    acos, asin, atan, atan2, ceil, cos, cosh, exp, abs, floor, fmod, frexp,\n+    ldexp, ln, ln1p, log10, log2, modf, rint, round, pow, sin, sinh, sqrt,\n+    tan, tanh, trunc;\n \n // These two must match in width according to architecture\n \n import ctypes::c_float;\n+import ctypes::c_int;\n import c_float = f64;\n \n \n@@ -34,16 +36,23 @@ native mod f64 {\n     pure fn exp(n: f64) -> f64;\n     #[link_name=\"fabs\"] pure fn abs(n: f64) -> f64;\n     pure fn floor(n: f64) -> f64;\n+    pure fn fmod(x: f64, y: f64) -> f64;\n+    pure fn frexp(n: f64, &value: c_int) -> f64;\n+    pure fn ldexp(x: f64, n: c_int) -> f64;\n     #[link_name=\"log\"] pure fn ln(n: f64) -> f64;\n     #[link_name=\"log1p\"] pure fn ln1p(n: f64) -> f64;\n     pure fn log10(n: f64) -> f64;\n     pure fn log2(n: f64) -> f64;\n+    pure fn modf(n: f64, &iptr: f64) -> f64;\n     pure fn pow(n: f64, e: f64) -> f64;\n+    pure fn rint(n: f64) -> f64;\n+    pure fn round(n: f64) -> f64;\n     pure fn sin(n: f64) -> f64;\n     pure fn sinh(n: f64) -> f64;\n     pure fn sqrt(n: f64) -> f64;\n     pure fn tan(n: f64) -> f64;\n     pure fn tanh(n: f64) -> f64;\n+    pure fn trunc(n: f64) -> f64;\n }\n \n #[link_name = \"m\"]\n@@ -62,19 +71,25 @@ native mod f32 {\n     #[link_name=\"expf\"] pure fn exp(n: f32) -> f32;\n     #[link_name=\"fabsf\"] pure fn abs(n: f32) -> f32;\n     #[link_name=\"floorf\"] pure fn floor(n: f32) -> f32;\n+    #[link_name=\"frexpf\"] pure fn frexp(n: f64, &value: c_int) -> f32;\n+    #[link_name=\"fmodf\"] pure fn fmod(x: f32, y: f32) -> f32;\n+    #[link_name=\"ldexpf\"] pure fn ldexp(x: f32, n: c_int) -> f32;\n+    #[link_name=\"logf\"] pure fn ln(n: f32) -> f32;\n+    #[link_name=\"log1p\"] pure fn ln1p(n: f64) -> f64;\n+    #[link_name=\"log2f\"] pure fn log2(n: f32) -> f32;\n+    #[link_name=\"log10f\"] pure fn log10(n: f32) -> f32;\n+    #[link_name=\"modff\"] pure fn modf(n: f32, &iptr: f32) -> f32;\n     #[link_name=\"powf\"] pure fn pow(n: f32, e: f32) -> f32;\n+    #[link_name=\"rintf\"] pure fn rint(n: f32) -> f32;\n+    #[link_name=\"roundf\"] pure fn round(n: f32) -> f32;\n     #[link_name=\"sinf\"] pure fn sin(n: f32) -> f32;\n     #[link_name=\"sinhf\"] pure fn sinh(n: f32) -> f32;\n     #[link_name=\"sqrtf\"] pure fn sqrt(n: f32) -> f32;\n     #[link_name=\"tanf\"] pure fn tan(n: f32) -> f32;\n     #[link_name=\"tanhf\"] pure fn tanh(n: f32) -> f32;\n-    #[link_name=\"logf\"] pure fn ln(n: f32) -> f32;\n-    #[link_name=\"log1p\"] pure fn ln1p(n: f64) -> f64;\n-    #[link_name=\"log2f\"] pure fn log2(n: f32) -> f32;\n-    #[link_name=\"log10f\"] pure fn log10(n: f32) -> f32;\n+    #[link_name=\"truncf\"] pure fn trunc(n: f32) -> f32;\n }\n \n-\n mod consts {\n     /*\n     Const: pi\n@@ -219,9 +234,7 @@ pure fn atan2(y: float, x: float) -> float\n /*\n Function: ceil\n \n-Returns:\n-\n-The smallest integral value less than or equal to `n`\n+Returns the smallest integral value less than or equal to `n`\n */\n pure fn ceil(n: float) -> float\n     { c_float::ceil(n as c_float) as float }\n@@ -247,34 +260,35 @@ pure fn cosh(x: float) -> float\n /*\n Function: exp\n \n-Returns:\n-\n-e to the power of `n*\n+Returns `consts::e` to the power of `n*\n */\n pure fn exp(n: float) -> float\n     { c_float::exp(n as c_float) as float }\n \n /*\n Function: abs\n \n-Returns:\n-\n-The absolute value of  `n`\n-\n+Returns the absolute value of  `n`\n */\n pure fn abs(n: float) -> float\n     { c_float::abs(n as c_float) as float }\n \n /*\n Function: floor\n \n-Returns:\n-\n-The largest integral value less than or equal to `n`\n+Returns the largest integral value less than or equal to `n`\n */\n pure fn floor(n: float) -> float\n     { c_float::floor(n as c_float) as float }\n \n+/*\n+Function: fmod\n+\n+Returns the floating-point remainder of `x/y`\n+*/\n+pure fn fmod(x: float, y: float) -> float\n+    { c_float::fmod(x as c_float, y as c_float) as float }\n+\n /*\n Function: ln\n \n@@ -283,6 +297,14 @@ Returns the natural logaritm of `n`\n pure fn ln(n: float) -> float\n     { c_float::ln(n as c_float) as float }\n \n+/*\n+Function: ldexp\n+\n+Returns `x` multiplied by 2 to the power of `n`\n+*/\n+pure fn ldexp(n: float, i: int) -> float\n+    { c_float::ldexp(n as c_float, i as c_int) as float }\n+\n /*\n Function: ln1p\n \n@@ -308,13 +330,71 @@ Returns the logarithm to base 2 of `n`\n pure fn log2(n: float) -> float\n     { c_float::log2(n as c_float) as float }\n \n+\n+/*\n+Function: modf\n+\n+Breaks `n` into integral and fractional parts such that both\n+have the same sign as `n`\n+\n+The integral part is stored in `iptr`.\n+\n+Returns:\n+\n+The fractional part of `n`\n+*/\n+pure fn modf(n: float, &iptr: float) -> float {\n+    unchecked {\n+        let f = iptr as c_float;\n+        let r = c_float::modf(n as c_float, f) as float;\n+        iptr  = f as float;\n+        ret r;\n+    }\n+}\n+\n+/*\n+Function: frexp\n+\n+Breaks `n` into a normalized fraction and an integral power of 2\n+\n+The inegral part is stored in iptr.\n+\n+The functions return a number x such that x has a magnitude in the interval\n+[1/2, 1) or 0, and `n == x*(2 to the power of exp)`.\n+\n+Returns:\n+\n+The fractional part of `n`\n+*/\n+pure fn frexp(n: float, &exp: c_int) -> float\n+    { c_float::frexp(n as c_float, exp) as float }\n+\n /*\n Function: pow\n */\n pure fn pow(v: float, e: float) -> float\n     { c_float::pow(v as c_float, e as c_float) as float }\n \n \n+/*\n+Function: rint\n+\n+Returns the integral value nearest to `x` (according to the\n+prevailing rounding mode) in floating-point format\n+*/\n+pure fn rint(x: float) -> float\n+    { c_float::rint(x as c_float) as float }\n+\n+/*\n+Function: round\n+\n+\n+Return the integral value nearest to `x` rounding half-way\n+cases away from zero, regardless of the current rounding direction.\n+*/\n+pure fn round(x: float) -> float\n+    { c_float::round(x as c_float) as float }\n+\n /*\n Function: sin\n \n@@ -357,6 +437,15 @@ Returns the hyperbolic tangent of an angle `x` (measured in rad)\n pure fn tanh(x: float) -> float\n     { c_float::tanh(x as c_float) as float }\n \n+/*\n+Function: trunc\n+\n+Returns the integral value nearest to but no larger in magnitude than `x`\n+\n+*/\n+pure fn trunc(x: float) -> float\n+    { c_float::trunc(x as c_float) as float }\n+\n \n \n "}, {"sha": "c7b3c45bd6b19c1ba6fc85e8f96b4fe69188f6c8", "filename": "src/test/stdtest/math.rs", "status": "modified", "additions": 225, "deletions": 9, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/a611496ddfb3f510635d9921dd1463cc3512d84d/src%2Ftest%2Fstdtest%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a611496ddfb3f510635d9921dd1463cc3512d84d/src%2Ftest%2Fstdtest%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmath.rs?ref=a611496ddfb3f510635d9921dd1463cc3512d84d", "patch": "@@ -1,14 +1,8 @@\n use std;\n+\n import std::math::*;\n import std::float;\n-\n-#[test]\n-fn test_sqrt() {\n-    assert sqrt(9.0) == 3.0;\n-    assert sqrt(4.0) == 2.0;\n-    assert sqrt(1.0) == 1.0;\n-    assert sqrt(0.0) == 0.0;\n-}\n+import c_int = std::ctypes::c_int;\n \n #[test]\n fn test_max_min() {\n@@ -20,6 +14,229 @@ fn test_max_min() {\n     assert min(0.0, 1.0) == 0.0;\n }\n \n+// FIXME use macros to execute the tests below for all float types\n+\n+#[test]\n+fn test_trig() {\n+    assert sin(0.0) == 0.0;\n+    assert sin(-0.0) == 0.0;\n+    assert float::isNaN(sin(float::infinity));\n+    assert float::isNaN(sin(float::neg_infinity));\n+\n+    assert cos(0.0) == 1.0;\n+    assert cos(-0.0) == 1.0;\n+    assert float::isNaN(cos(float::infinity));\n+    assert float::isNaN(cos(float::neg_infinity));\n+\n+    assert tan(0.0) == 0.0;\n+    assert tan(-0.0) == 0.0;;\n+    assert float::isNaN(tan(float::infinity));\n+    assert float::isNaN(tan(float::neg_infinity));\n+}\n+\n+#[test]\n+fn test_inv_trig() {\n+    assert asin(0.0) == 0.0;\n+    assert asin(-0.0) == -0.0;\n+    assert float::isNaN(asin(1.1));\n+    assert float::isNaN(asin(-1.1));\n+\n+    assert acos(1.0) == 0.0;\n+    assert float::isNaN(acos(1.1));\n+    assert float::isNaN(acos(-1.1));\n+\n+    assert atan(0.0) == 0.0;\n+    assert atan(-0.0) == 0.0;\n+    assert atan(float::infinity) == consts::frac_pi_2;\n+    assert atan(float::neg_infinity) == - consts::frac_pi_2;\n+\n+    assert atan2(0.0, -0.0) == consts::pi;\n+    assert atan2(-0.0, -0.0) == -consts::pi;\n+\n+    assert atan2(0.0, 0.0) == 0.0;\n+    assert atan2(-0.0, 0.0) == -0.0;\n+\n+    assert atan2(0.0, -1.0) == consts::pi;\n+    assert atan2(-0.0, -1.0) == -consts::pi;\n+\n+    assert atan2(0.0, 1.0) == 0.0;\n+    assert atan2(-0.0, 1.0) == -0.0;\n+\n+    assert atan2(1.0, 0.0) == consts::frac_pi_2;\n+    assert atan2(1.0, -0.0) == consts::frac_pi_2;\n+}\n+\n+#[test]\n+fn test_pow() {\n+    assert pow(2.0, 4.0) == 16.0;\n+\n+    assert pow(0.0, -3.0) == float::infinity;\n+    assert pow(-0.0, -3.0) == float::neg_infinity;\n+\n+    assert pow(0.0, -4.0) == float::infinity;\n+    assert pow(-0.0, -4.0) == float::infinity;\n+\n+    assert pow(0.0, 3.0) == 0.0;\n+    assert pow(-0.0, 3.0) == -0.0;\n+    assert pow(0.0, 4.0) == 0.0;\n+    assert pow(-0.0, 4.0) == 0.0;\n+\n+    assert pow(-1.0, float::infinity) == 1.0;\n+    assert pow(-1.0, float::neg_infinity) == 1.0;\n+\n+    assert pow(1.0, 4.0) == 1.0;\n+    assert pow(1.0, 0.0) == 1.0;\n+    assert pow(1.0, -0.0) == 1.0;\n+    assert pow(1.0, float::NaN) == 1.0;\n+    assert pow(1.0, float::infinity) == 1.0;\n+    assert pow(1.0, float::neg_infinity) == 1.0;\n+    assert pow(1.0, -3.0) == 1.0;\n+    assert pow(1.0, -4.0) == 1.0;\n+\n+    assert pow(4.0, 0.0) == 1.0;\n+    assert pow(0.0, 0.0) == 1.0;\n+    assert pow(-0.0, 0.0) == 1.0;\n+    assert pow(float::NaN, 0.0) == 1.0;\n+    assert pow(float::infinity, 0.0) == 1.0;\n+    assert pow(float::neg_infinity, 0.0) == 1.0;\n+    assert pow(-3.0, 0.0) == 1.0;\n+    assert pow(-4.0, 0.0) == 1.0;\n+\n+    assert pow(4.0, -0.0) == 1.0;\n+    assert pow(0.0, -0.0) == 1.0;\n+    assert pow(-0.0, -0.0) == 1.0;\n+    assert pow(float::NaN, -0.0) == 1.0;\n+    assert pow(float::infinity, -0.0) == 1.0;\n+    assert pow(float::neg_infinity, -0.0) == 1.0;\n+    assert pow(-3.0, -0.0) == 1.0;\n+    assert pow(-4.0, -0.0) == 1.0;\n+\n+    assert float::isNaN(pow(-1.0, -1.5));\n+    assert float::isNaN(pow(-1.0, 1.5));\n+\n+    assert float::isNaN(pow(-1.2, -1.5));\n+    assert float::isNaN(pow(-1.2, 1.5));\n+\n+    assert pow(0.5, float::neg_infinity) == float::infinity;\n+    assert pow(-0.5, float::neg_infinity) == float::infinity;\n+\n+    assert pow(1.5, float::neg_infinity) == 0.0;\n+    assert pow(-1.5, float::neg_infinity) == 0.0;\n+\n+    assert pow(0.5, float::infinity) == 0.0;\n+    assert pow(-0.5, float::infinity) == 0.0;\n+\n+    assert pow(-1.5, float::infinity) == float::infinity;\n+    assert pow(1.5, float::infinity) == float::infinity;\n+\n+    assert pow(float::neg_infinity, -3.0) == -0.0;\n+    assert pow(float::neg_infinity, -4.0) == 0.0;\n+\n+    assert pow(float::neg_infinity, 3.0) == float::neg_infinity;\n+    assert pow(float::neg_infinity, 4.0) == float::infinity;\n+\n+    assert pow(float::infinity, -16.0) == 0.0;\n+    assert pow(float::infinity, 16.0) == float::infinity;\n+}\n+\n+#[test]\n+fn test_exp_and_mod() {\n+    assert exp(0.0) == 1.0;\n+    assert exp(-0.0) == 1.0;\n+    assert exp(float::neg_infinity) == 0.0;\n+    assert exp(float::infinity) == float::infinity;\n+\n+    let d1: c_int = 1 as c_int;\n+    assert frexp(0.0, d1) == 0.0;\n+    assert frexp(-0.0, d1) == 0.0;\n+    assert frexp(float::infinity, d1) == float::infinity;\n+    assert frexp(float::neg_infinity, d1) == float::neg_infinity;\n+    assert float::isNaN(frexp(float::NaN, d1));\n+\n+    let d2: float = 1.0;\n+    assert modf(float::infinity, d2) == 0.0;\n+    assert modf(float::neg_infinity, d2) == -0.0;\n+    assert float::isNaN(modf(float::NaN, d2));\n+}\n+\n+#[test]\n+fn test_round_and_abs() {\n+    assert abs(0.0) == 0.0;\n+    assert abs(-0.0) == 0.0;\n+    assert abs(float::infinity) == float::infinity;\n+    assert abs(float::neg_infinity) == float::infinity;\n+\n+    assert abs(-2.5) == 2.5;\n+    assert abs(2.5) == 2.5;\n+\n+    assert ceil(0.0) == 0.0;\n+    assert ceil(-0.0) == -0.0;\n+    assert ceil(float::infinity) == float::infinity;\n+    assert ceil(float::neg_infinity) == float::neg_infinity;\n+\n+    assert ceil(1.9) == 2.0;\n+    assert ceil(-1.9) == -1.0;\n+\n+    assert floor(0.0) == 0.0;\n+    assert floor(-0.0) == -0.0;\n+    assert floor(float::infinity) == float::infinity;\n+    assert floor(float::neg_infinity) == float::neg_infinity;\n+\n+    assert floor(1.9) == 1.0;\n+    assert floor(-1.9) == -2.0;\n+\n+    assert trunc(0.0) == 0.0;\n+    assert trunc(-0.0) == -0.0;\n+    assert trunc(float::infinity) == float::infinity;\n+    assert trunc(float::neg_infinity) == float::neg_infinity;\n+\n+    assert trunc(1.5) == 1.0;\n+    assert trunc(1.2) == 1.0;\n+    assert trunc(1.0) == 1.0;\n+    assert trunc(1.9) == 1.0;\n+    assert trunc(-1.5) == -1.0;\n+    assert trunc(-1.2) == -1.0;\n+    assert trunc(-1.0) == -1.0;\n+    assert trunc(-1.9) == -1.0;\n+\n+    assert round(0.0) == 0.0;\n+    assert round(-0.0) == -0.0;\n+    assert round(float::infinity) == float::infinity;\n+    assert round(float::neg_infinity) == float::neg_infinity;\n+\n+    assert rint(0.0) == 0.0;\n+    assert rint(-0.0) == -0.0;\n+    assert rint(float::infinity) == float::infinity;\n+    assert rint(float::neg_infinity) == float::neg_infinity;\n+}\n+\n+#[test]\n+fn test_hyp_trig() {\n+    assert sinh(0.0) == 0.0;\n+    assert sinh(-0.0) == 0.0;\n+    assert sinh(float::infinity) == float::infinity;\n+    assert sinh(float::neg_infinity) == float::neg_infinity;\n+\n+    assert cosh(0.0) == 1.0;\n+    assert cosh(-0.0) == 1.0;\n+    assert cosh(float::infinity) == float::infinity;\n+    assert cosh(float::neg_infinity) == float::infinity;\n+\n+    assert tanh(0.0) == 0.0;\n+    assert tanh(-0.0) == 0.0;\n+    assert tanh(float::infinity) == 1.0;\n+    assert tanh(float::neg_infinity) == -1.0;\n+}\n+\n+#[test]\n+fn test_sqrt() {\n+    assert sqrt(9.0) == 3.0;\n+    assert sqrt(4.0) == 2.0;\n+    assert sqrt(1.0) == 1.0;\n+    assert sqrt(0.0) == 0.0;\n+}\n+\n+\n #[test]\n fn test_angle() {\n     fn angle(vec: (float, float)) -> float {\n@@ -36,7 +253,6 @@ fn test_angle() {\n \n \n #[test]\n-#[ignore]\n fn test_log_functions() {\n     assert ln(1.0) == 0.0;\n     assert log2(1.0) == 0.0;"}]}