{"sha": "3eaead7d51f3d680bdae596e9c4ef00bdc03403e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYWVhZDdkNTFmM2Q2ODBiZGFlNTk2ZTljNGVmMDBiZGMwMzQwM2U=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-07-03T10:14:05Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-07-30T11:59:01Z"}, "message": "Don't emit clashing decl lint for FFI-safe enums.\n\nAn example of an FFI-safe enum conversion is when converting\nOption<NonZeroUsize> to usize. Because the Some value must be non-zero,\nrustc can use 0 to represent the None variant, making this conversion is\nsafe. Furthermore, it can be relied on (and removing this optimisation\nalready would be a breaking change).", "tree": {"sha": "b975d9f98665096f24081c6f55a0db61dfb00a1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b975d9f98665096f24081c6f55a0db61dfb00a1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eaead7d51f3d680bdae596e9c4ef00bdc03403e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eaead7d51f3d680bdae596e9c4ef00bdc03403e", "html_url": "https://github.com/rust-lang/rust/commit/3eaead7d51f3d680bdae596e9c4ef00bdc03403e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eaead7d51f3d680bdae596e9c4ef00bdc03403e/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4da72f538752aad2ab4b77dad115ef5889365baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4da72f538752aad2ab4b77dad115ef5889365baf", "html_url": "https://github.com/rust-lang/rust/commit/4da72f538752aad2ab4b77dad115ef5889365baf"}], "stats": {"total": 162, "additions": 137, "deletions": 25}, "files": [{"sha": "47d1c7ba6f1f4c6687e64466262b5cf3d4d791f7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3eaead7d51f3d680bdae596e9c4ef00bdc03403e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eaead7d51f3d680bdae596e9c4ef00bdc03403e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3eaead7d51f3d680bdae596e9c4ef00bdc03403e", "patch": "@@ -2155,14 +2155,16 @@ impl ClashingExternDeclarations {\n             let a_kind = &a.kind;\n             let b_kind = &b.kind;\n \n+            use rustc_target::abi::LayoutOf;\n+            let compare_layouts = |a, b| {\n+                let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n+                let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n+                let result = a_layout == b_layout;\n+                result\n+            };\n+\n             match (a_kind, b_kind) {\n-                (Adt(..), Adt(..)) => {\n-                    // Adts are pretty straightforward: just compare the layouts.\n-                    use rustc_target::abi::LayoutOf;\n-                    let a_layout = cx.layout_of(a).unwrap().layout;\n-                    let b_layout = cx.layout_of(b).unwrap().layout;\n-                    a_layout == b_layout\n-                }\n+                (Adt(..), Adt(..)) => compare_layouts(a, b),\n                 (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n                     // For arrays, we also check the constness of the type.\n                     a_const.val == b_const.val\n@@ -2179,10 +2181,10 @@ impl ClashingExternDeclarations {\n                     a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty)\n                 }\n                 (FnDef(..), FnDef(..)) => {\n-                    // As we don't compare regions, skip_binder is fine.\n                     let a_poly_sig = a.fn_sig(tcx);\n                     let b_poly_sig = b.fn_sig(tcx);\n \n+                    // As we don't compare regions, skip_binder is fine.\n                     let a_sig = a_poly_sig.skip_binder();\n                     let b_sig = b_poly_sig.skip_binder();\n \n@@ -2210,7 +2212,56 @@ impl ClashingExternDeclarations {\n                 | (Opaque(..), Opaque(..)) => false,\n                 // These definitely should have been caught above.\n                 (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n-                _ => false,\n+\n+                // Disjoint kinds.\n+                (_, _) => {\n+                    // First, check if the conversion is FFI-safe. This can be so if the type is an\n+                    // enum with a non-null field (see improper_ctypes).\n+                    let is_primitive_or_pointer =\n+                        |ty: Ty<'tcx>| ty.is_primitive() || matches!(ty.kind, RawPtr(..));\n+                    if (is_primitive_or_pointer(a) || is_primitive_or_pointer(b))\n+                        && !(is_primitive_or_pointer(a) && is_primitive_or_pointer(b))\n+                        && (matches!(a_kind, Adt(..)) || matches!(b_kind, Adt(..)))\n+                    /* ie, 1 adt and 1 primitive */\n+                    {\n+                        let (primitive_ty, adt_ty) =\n+                            if is_primitive_or_pointer(a) { (a, b) } else { (b, a) };\n+                        // First, check that the Adt is FFI-safe to use.\n+                        use crate::types::{ImproperCTypesMode, ImproperCTypesVisitor};\n+                        let vis =\n+                            ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Declarations };\n+\n+                        if let Adt(def, substs) = adt_ty.kind {\n+                            let repr_nullable = vis.is_repr_nullable_ptr(adt_ty, def, substs);\n+                            if let Some(safe_ty) = repr_nullable {\n+                                let safe_ty_layout = &cx.layout_of(safe_ty).unwrap();\n+                                let primitive_ty_layout = &cx.layout_of(primitive_ty).unwrap();\n+\n+                                use rustc_target::abi::Abi::*;\n+                                match (&safe_ty_layout.abi, &primitive_ty_layout.abi) {\n+                                    (Scalar(safe), Scalar(primitive)) => {\n+                                        // The two types are safe to convert between if `safe` is\n+                                        // the non-zero version of `primitive`.\n+                                        use std::ops::RangeInclusive;\n+\n+                                        let safe_range: &RangeInclusive<_> = &safe.valid_range;\n+                                        let primitive_range: &RangeInclusive<_> =\n+                                            &primitive.valid_range;\n+\n+                                        return primitive_range.end() == safe_range.end()\n+                                            // This check works for both signed and unsigned types due to wraparound.\n+                                            && *safe_range.start() == 1\n+                                            && *primitive_range.start() == 0;\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                        }\n+                    }\n+                    // Otherwise, just compare the layouts. This may be underapproximate, but at\n+                    // the very least, will stop reads into uninitialised memory.\n+                    compare_layouts(a, b)\n+                }\n             }\n         }\n     }"}, {"sha": "3d1080bea4c9c2bbde2bfc517d81738922fabe24", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3eaead7d51f3d680bdae596e9c4ef00bdc03403e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eaead7d51f3d680bdae596e9c4ef00bdc03403e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=3eaead7d51f3d680bdae596e9c4ef00bdc03403e", "patch": "@@ -509,14 +509,14 @@ declare_lint! {\n \n declare_lint_pass!(ImproperCTypesDefinitions => [IMPROPER_CTYPES_DEFINITIONS]);\n \n-enum ImproperCTypesMode {\n+crate enum ImproperCTypesMode {\n     Declarations,\n     Definitions,\n }\n \n-struct ImproperCTypesVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mode: ImproperCTypesMode,\n+crate struct ImproperCTypesVisitor<'a, 'tcx> {\n+    crate cx: &'a LateContext<'tcx>,\n+    crate mode: ImproperCTypesMode,\n }\n \n enum FfiResult<'tcx> {\n@@ -562,17 +562,18 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if this enum can be safely exported based on the \"nullable pointer optimization\".\n-    /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n-    /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n-    fn is_repr_nullable_ptr(\n+    /// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If\n+    /// the type is it is, return the known non-null field type, else None.  Currently restricted\n+    /// to function pointers, boxes, references, `core::num::NonZero*`, `core::ptr::NonNull`, and\n+    /// `#[repr(transparent)]` newtypes.\n+    crate fn is_repr_nullable_ptr(\n         &self,\n         ty: Ty<'tcx>,\n         ty_def: &'tcx ty::AdtDef,\n         substs: SubstsRef<'tcx>,\n-    ) -> bool {\n+    ) -> Option<Ty<'tcx>> {\n         if ty_def.variants.len() != 2 {\n-            return false;\n+            return None;\n         }\n \n         let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n@@ -582,16 +583,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         } else if variant_fields[1].is_empty() {\n             &variant_fields[0]\n         } else {\n-            return false;\n+            return None;\n         };\n \n         if fields.len() != 1 {\n-            return false;\n+            return None;\n         }\n \n         let field_ty = fields[0].ty(self.cx.tcx, substs);\n         if !self.ty_is_known_nonnull(field_ty) {\n-            return false;\n+            return None;\n         }\n \n         // At this point, the field's type is known to be nonnull and the parent enum is\n@@ -603,7 +604,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n         }\n \n-        true\n+        Some(field_ty)\n     }\n \n     /// Check if the type is array and emit an unsafe type lint.\n@@ -753,7 +754,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // discriminant.\n                         if !def.repr.c() && !def.repr.transparent() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n-                            if !self.is_repr_nullable_ptr(ty, def, substs) {\n+                            if self.is_repr_nullable_ptr(ty, def, substs).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n                                     reason: \"enum has no representation hint\".into(),"}, {"sha": "49a9d044a2fae3ba7a8452705beb1ca1810de530", "filename": "src/test/ui/lint/clashing-extern-fn.stderr", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3eaead7d51f3d680bdae596e9c4ef00bdc03403e/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3eaead7d51f3d680bdae596e9c4ef00bdc03403e/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=3eaead7d51f3d680bdae596e9c4ef00bdc03403e", "patch": "@@ -105,5 +105,65 @@ LL |             fn draw_point(p: Point);\n    = note: expected `unsafe extern \"C\" fn(sameish_members::a::Point)`\n               found `unsafe extern \"C\" fn(sameish_members::b::Point)`\n \n-warning: 8 warnings emitted\n+warning: `missing_return_type` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:208:13\n+   |\n+LL |             fn missing_return_type() -> usize;\n+   |             ---------------------------------- `missing_return_type` previously declared here\n+...\n+LL |             fn missing_return_type();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> usize`\n+              found `unsafe extern \"C\" fn()`\n+\n+warning: `non_zero_usize` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:226:13\n+   |\n+LL |             fn non_zero_usize() -> core::num::NonZeroUsize;\n+   |             ----------------------------------------------- `non_zero_usize` previously declared here\n+...\n+LL |             fn non_zero_usize() -> usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> std::num::NonZeroUsize`\n+              found `unsafe extern \"C\" fn() -> usize`\n+\n+warning: `non_null_ptr` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:228:13\n+   |\n+LL |             fn non_null_ptr() -> core::ptr::NonNull<usize>;\n+   |             ----------------------------------------------- `non_null_ptr` previously declared here\n+...\n+LL |             fn non_null_ptr() -> *const usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> std::ptr::NonNull<usize>`\n+              found `unsafe extern \"C\" fn() -> *const usize`\n+\n+warning: `option_non_zero_usize_incorrect` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:254:13\n+   |\n+LL |             fn option_non_zero_usize_incorrect() -> usize;\n+   |             ---------------------------------------------- `option_non_zero_usize_incorrect` previously declared here\n+...\n+LL |             fn option_non_zero_usize_incorrect() -> isize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> usize`\n+              found `unsafe extern \"C\" fn() -> isize`\n+\n+warning: `option_non_null_ptr_incorrect` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:256:13\n+   |\n+LL |             fn option_non_null_ptr_incorrect() -> *const usize;\n+   |             --------------------------------------------------- `option_non_null_ptr_incorrect` previously declared here\n+...\n+LL |             fn option_non_null_ptr_incorrect() -> *const isize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> *const usize`\n+              found `unsafe extern \"C\" fn() -> *const isize`\n+\n+warning: 13 warnings emitted\n "}]}