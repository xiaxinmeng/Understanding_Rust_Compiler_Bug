{"sha": "de8f72aad9d708fd26e450779623dd5cd4e38568", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOGY3MmFhZDlkNzA4ZmQyNmU0NTA3Nzk2MjNkZDVjZDRlMzg1Njg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-27T05:40:18Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-27T05:40:18Z"}, "message": "Merge #1052\n\n1052: Flip binary expression assist r=matklad a=marcogroppo\n\nAdds an assist that can flip these binary comparison operators: `==`, `!=`, `>`, `>=`, `<`, `<=`.\r\n\r\nThis is a small extension to the 'flip ==' assist.\r\nIn theory we could easily flip ANY binary expression, but I'm not sure it would be a good idea (IMHO we should try not to change the meaning of the expression).\r\n\r\nDoes it make sense?\n\nCo-authored-by: Marco Groppo <marco.groppo@gmail.com>", "tree": {"sha": "a08d008c4faf2c1defe803f66e2d3fef8b1ea60e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a08d008c4faf2c1defe803f66e2d3fef8b1ea60e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de8f72aad9d708fd26e450779623dd5cd4e38568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de8f72aad9d708fd26e450779623dd5cd4e38568", "html_url": "https://github.com/rust-lang/rust/commit/de8f72aad9d708fd26e450779623dd5cd4e38568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de8f72aad9d708fd26e450779623dd5cd4e38568/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "1011e37f3a260b0565f88c84d3c49fac1ec7b879", "url": "https://api.github.com/repos/rust-lang/rust/commits/1011e37f3a260b0565f88c84d3c49fac1ec7b879", "html_url": "https://github.com/rust-lang/rust/commit/1011e37f3a260b0565f88c84d3c49fac1ec7b879"}, {"sha": "7b81c088f79a19289008f635d2e2e4105a750b96", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b81c088f79a19289008f635d2e2e4105a750b96", "html_url": "https://github.com/rust-lang/rust/commit/7b81c088f79a19289008f635d2e2e4105a750b96"}], "stats": {"total": 231, "additions": 143, "deletions": 88}, "files": [{"sha": "ec377642e022ee1223340a7f4d2088ea98f6e59e", "filename": "crates/ra_assists/src/flip_binexpr.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/de8f72aad9d708fd26e450779623dd5cd4e38568/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8f72aad9d708fd26e450779623dd5cd4e38568/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_binexpr.rs?ref=de8f72aad9d708fd26e450779623dd5cd4e38568", "patch": "@@ -0,0 +1,141 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n+\n+use crate::{AssistCtx, Assist, AssistId};\n+\n+/// Flip binary expression assist.\n+pub(crate) fn flip_binexpr(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let expr = ctx.node_at_offset::<BinExpr>()?;\n+    let lhs = expr.lhs()?.syntax();\n+    let rhs = expr.rhs()?.syntax();\n+    let op_range = expr.op()?.range();\n+    // The assist should be applied only if the cursor is on the operator\n+    let cursor_in_range = ctx.frange.range.is_subrange(&op_range);\n+    if !cursor_in_range {\n+        return None;\n+    }\n+    let action: FlipAction = expr.op_kind()?.into();\n+    // The assist should not be applied for certain operators\n+    if let FlipAction::DontFlip = action {\n+        return None;\n+    }\n+\n+    ctx.add_action(AssistId(\"flip_binexpr\"), \"flip binary expression\", |edit| {\n+        edit.target(op_range);\n+        if let FlipAction::FlipAndReplaceOp(new_op) = action {\n+            edit.replace(op_range, new_op);\n+        }\n+        edit.replace(lhs.range(), rhs.text());\n+        edit.replace(rhs.range(), lhs.text());\n+    });\n+\n+    ctx.build()\n+}\n+\n+enum FlipAction {\n+    // Flip the expression\n+    Flip,\n+    // Flip the expression and replace the operator with this string\n+    FlipAndReplaceOp(&'static str),\n+    // Do not flip the expression\n+    DontFlip,\n+}\n+\n+impl From<BinOp> for FlipAction {\n+    fn from(op_kind: BinOp) -> Self {\n+        match op_kind {\n+            BinOp::Assignment => FlipAction::DontFlip,\n+            BinOp::AddAssign => FlipAction::DontFlip,\n+            BinOp::DivAssign => FlipAction::DontFlip,\n+            BinOp::MulAssign => FlipAction::DontFlip,\n+            BinOp::RemAssign => FlipAction::DontFlip,\n+            BinOp::ShrAssign => FlipAction::DontFlip,\n+            BinOp::ShlAssign => FlipAction::DontFlip,\n+            BinOp::SubAssign => FlipAction::DontFlip,\n+            BinOp::BitOrAssign => FlipAction::DontFlip,\n+            BinOp::BitAndAssign => FlipAction::DontFlip,\n+            BinOp::BitXorAssign => FlipAction::DontFlip,\n+            BinOp::GreaterTest => FlipAction::FlipAndReplaceOp(\"<\"),\n+            BinOp::GreaterEqualTest => FlipAction::FlipAndReplaceOp(\"<=\"),\n+            BinOp::LesserTest => FlipAction::FlipAndReplaceOp(\">\"),\n+            BinOp::LesserEqualTest => FlipAction::FlipAndReplaceOp(\">=\"),\n+            _ => FlipAction::Flip,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::helpers::{ check_assist, check_assist_target, check_assist_not_applicable };\n+\n+    #[test]\n+    fn flip_binexpr_target_is_the_op() {\n+        check_assist_target(flip_binexpr, \"fn f() { let res = 1 ==<|> 2; }\", \"==\")\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_not_applicable_for_assignment() {\n+        check_assist_not_applicable(flip_binexpr, \"fn f() { let mut _x = 1; _x +=<|> 2 }\")\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_eq() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = 1 ==<|> 2; }\",\n+            \"fn f() { let res = 2 ==<|> 1; }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_gt() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = 1 ><|> 2; }\",\n+            \"fn f() { let res = 2 <<|> 1; }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_lteq() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = 1 <=<|> 2; }\",\n+            \"fn f() { let res = 2 >=<|> 1; }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_for_complex_expr() {\n+        check_assist(\n+            flip_binexpr,\n+            \"fn f() { let res = (1 + 1) ==<|> (2 + 2); }\",\n+            \"fn f() { let res = (2 + 2) ==<|> (1 + 1); }\",\n+        )\n+    }\n+\n+    #[test]\n+    fn flip_binexpr_works_inside_match() {\n+        check_assist(\n+            flip_binexpr,\n+            r#\"\n+            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n+                match other.downcast_ref::<Self>() {\n+                    None => false,\n+                    Some(it) => it ==<|> self,\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n+                match other.downcast_ref::<Self>() {\n+                    None => false,\n+                    Some(it) => self ==<|> it,\n+                }\n+            }\n+            \"#,\n+        )\n+    }\n+}"}, {"sha": "df0bb689da55e5614d565846c8b694391de38ae1", "filename": "crates/ra_assists/src/flip_eq_operands.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1011e37f3a260b0565f88c84d3c49fac1ec7b879/crates%2Fra_assists%2Fsrc%2Fflip_eq_operands.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1011e37f3a260b0565f88c84d3c49fac1ec7b879/crates%2Fra_assists%2Fsrc%2Fflip_eq_operands.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_eq_operands.rs?ref=1011e37f3a260b0565f88c84d3c49fac1ec7b879", "patch": "@@ -1,86 +0,0 @@\n-use hir::db::HirDatabase;\n-use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n-\n-use crate::{AssistCtx, Assist, AssistId};\n-\n-pub(crate) fn flip_eq_operands(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let expr = ctx.node_at_offset::<BinExpr>()?;\n-    let lhs = expr.lhs()?.syntax();\n-    let rhs = expr.rhs()?.syntax();\n-    let op_range = expr.op()?.range();\n-    let cursor_in_range = ctx.frange.range.is_subrange(&op_range);\n-    let allowed_ops = [BinOp::EqualityTest, BinOp::NegatedEqualityTest];\n-    let expr_op = expr.op_kind()?;\n-    if !cursor_in_range || !allowed_ops.iter().any(|o| *o == expr_op) {\n-        return None;\n-    }\n-    ctx.add_action(AssistId(\"flip_eq_operands\"), \"flip equality operands\", |edit| {\n-        edit.target(op_range);\n-        edit.replace(lhs.range(), rhs.text());\n-        edit.replace(rhs.range(), lhs.text());\n-    });\n-\n-    ctx.build()\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use crate::helpers::{check_assist, check_assist_target};\n-\n-    #[test]\n-    fn flip_eq_operands_for_simple_stmt() {\n-        check_assist(\n-            flip_eq_operands,\n-            \"fn f() { let res = 1 ==<|> 2; }\",\n-            \"fn f() { let res = 2 ==<|> 1; }\",\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_neq_operands_for_simple_stmt() {\n-        check_assist(\n-            flip_eq_operands,\n-            \"fn f() { let res = 1 !=<|> 2; }\",\n-            \"fn f() { let res = 2 !=<|> 1; }\",\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_eq_operands_for_complex_stmt() {\n-        check_assist(\n-            flip_eq_operands,\n-            \"fn f() { let res = (1 + 1) ==<|> (2 + 2); }\",\n-            \"fn f() { let res = (2 + 2) ==<|> (1 + 1); }\",\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_eq_operands_in_match_expr() {\n-        check_assist(\n-            flip_eq_operands,\n-            r#\"\n-            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n-                match other.downcast_ref::<Self>() {\n-                    None => false,\n-                    Some(it) => it ==<|> self,\n-                }\n-            }\n-            \"#,\n-            r#\"\n-            fn dyn_eq(&self, other: &dyn Diagnostic) -> bool {\n-                match other.downcast_ref::<Self>() {\n-                    None => false,\n-                    Some(it) => self ==<|> it,\n-                }\n-            }\n-            \"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn flip_eq_operands_target() {\n-        check_assist_target(flip_eq_operands, \"fn f() { let res = 1 ==<|> 2; }\", \"==\")\n-    }\n-}"}, {"sha": "c1514f8e5237ced832f627d3950657651af84438", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de8f72aad9d708fd26e450779623dd5cd4e38568/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8f72aad9d708fd26e450779623dd5cd4e38568/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=de8f72aad9d708fd26e450779623dd5cd4e38568", "patch": "@@ -88,7 +88,7 @@ where\n mod add_derive;\n mod add_impl;\n mod flip_comma;\n-mod flip_eq_operands;\n+mod flip_binexpr;\n mod change_visibility;\n mod fill_match_arms;\n mod fill_struct_fields;\n@@ -108,7 +108,7 @@ fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assis\n         fill_match_arms::fill_match_arms,\n         fill_struct_fields::fill_struct_fields,\n         flip_comma::flip_comma,\n-        flip_eq_operands::flip_eq_operands,\n+        flip_binexpr::flip_binexpr,\n         introduce_variable::introduce_variable,\n         replace_if_let_with_match::replace_if_let_with_match,\n         split_import::split_import,"}]}