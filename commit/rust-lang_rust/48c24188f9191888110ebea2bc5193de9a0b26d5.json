{"sha": "48c24188f9191888110ebea2bc5193de9a0b26d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YzI0MTg4ZjkxOTE4ODgxMTBlYmVhMmJjNTE5M2RlOWEwYjI2ZDU=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-25T01:53:04Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-25T01:53:04Z"}, "message": "Restore Round trait and move appropriate methods out of Real", "tree": {"sha": "86fcdf4534945f60963fee8d359b33578a7f9589", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86fcdf4534945f60963fee8d359b33578a7f9589"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48c24188f9191888110ebea2bc5193de9a0b26d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48c24188f9191888110ebea2bc5193de9a0b26d5", "html_url": "https://github.com/rust-lang/rust/commit/48c24188f9191888110ebea2bc5193de9a0b26d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48c24188f9191888110ebea2bc5193de9a0b26d5/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd49ccd0ba5616995da00454389b6454423813c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd49ccd0ba5616995da00454389b6454423813c", "html_url": "https://github.com/rust-lang/rust/commit/dcd49ccd0ba5616995da00454389b6454423813c"}], "stats": {"total": 374, "additions": 307, "deletions": 67}, "files": [{"sha": "71bbaf557ce38691be3755e00160d52bef7e287d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=48c24188f9191888110ebea2bc5193de9a0b26d5", "patch": "@@ -105,7 +105,7 @@ pub use iter::{ExtendedMutableIter};\n \n pub use num::{Num, NumCast};\n pub use num::{Signed, Unsigned, Integer};\n-pub use num::{Fractional, Real, RealExt};\n+pub use num::{Round, Fractional, Real, RealExt};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "7d5807ba5462c8525bf9e5697bb10c3158d1928a", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 98, "deletions": 16, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=48c24188f9191888110ebea2bc5193de9a0b26d5", "patch": "@@ -327,6 +327,34 @@ impl Signed for f32 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n+impl Round for f32 {\n+    /// Round half-way cases toward `neg_infinity`\n+    #[inline(always)]\n+    fn floor(&self) -> f32 { floor(*self) }\n+\n+    /// Round half-way cases toward `infinity`\n+    #[inline(always)]\n+    fn ceil(&self) -> f32 { ceil(*self) }\n+\n+    /// Round half-way cases away from `0.0`\n+    #[inline(always)]\n+    fn round(&self) -> f32 { round(*self) }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline(always)]\n+    fn trunc(&self) -> f32 { trunc(*self) }\n+\n+    ///\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(x == trunc(x) + fract(x))\n+    /// ~~~\n+    ///\n+    #[inline(always)]\n+    fn fract(&self) -> f32 { *self - self.trunc() }\n+}\n+\n impl Fractional for f32 {\n     /// The reciprocal (multiplicative inverse) of the number\n     #[inline(always)]\n@@ -402,22 +430,6 @@ impl Real for f32 {\n     #[inline(always)]\n     fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n \n-    #[inline(always)]\n-    fn floor(&self) -> f32 { floor(*self) }\n-\n-    #[inline(always)]\n-    fn ceil(&self) -> f32 { ceil(*self) }\n-\n-    #[inline(always)]\n-    fn round(&self) -> f32 { round(*self) }\n-\n-    #[inline(always)]\n-    fn trunc(&self) -> f32 { trunc(*self) }\n-\n-    /// The fractional part of the number, calculated using: `n - floor(n)`\n-    #[inline(always)]\n-    fn fract(&self) -> f32 { *self - self.floor() }\n-\n     #[inline(always)]\n     fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n \n@@ -736,6 +748,76 @@ mod tests {\n         num::test_num(10f32, 2f32);\n     }\n \n+    #[test]\n+    fn test_floor() {\n+        assert_fuzzy_eq!(1.0f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(1.5f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(1.7f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(0.0f32.floor(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).floor(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).floor(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).floor(), -2.0f32);\n+        assert_fuzzy_eq!((-1.5f32).floor(), -2.0f32);\n+        assert_fuzzy_eq!((-1.7f32).floor(), -2.0f32);\n+    }\n+\n+    #[test]\n+    fn test_ceil() {\n+        assert_fuzzy_eq!(1.0f32.ceil(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.ceil(), 2.0f32);\n+        assert_fuzzy_eq!(1.5f32.ceil(), 2.0f32);\n+        assert_fuzzy_eq!(1.7f32.ceil(), 2.0f32);\n+        assert_fuzzy_eq!(0.0f32.ceil(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).ceil(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).ceil(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).ceil(), -1.0f32);\n+        assert_fuzzy_eq!((-1.5f32).ceil(), -1.0f32);\n+        assert_fuzzy_eq!((-1.7f32).ceil(), -1.0f32);\n+    }\n+\n+    #[test]\n+    fn test_round() {\n+        assert_fuzzy_eq!(1.0f32.round(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.round(), 1.0f32);\n+        assert_fuzzy_eq!(1.5f32.round(), 2.0f32);\n+        assert_fuzzy_eq!(1.7f32.round(), 2.0f32);\n+        assert_fuzzy_eq!(0.0f32.round(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).round(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).round(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).round(), -1.0f32);\n+        assert_fuzzy_eq!((-1.5f32).round(), -2.0f32);\n+        assert_fuzzy_eq!((-1.7f32).round(), -2.0f32);\n+    }\n+\n+    #[test]\n+    fn test_trunc() {\n+        assert_fuzzy_eq!(1.0f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(1.5f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(1.7f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(0.0f32.trunc(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).trunc(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).trunc(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).trunc(), -1.0f32);\n+        assert_fuzzy_eq!((-1.5f32).trunc(), -1.0f32);\n+        assert_fuzzy_eq!((-1.7f32).trunc(), -1.0f32);\n+    }\n+\n+    #[test]\n+    fn test_fract() {\n+        assert_fuzzy_eq!(1.0f32.fract(), 0.0f32);\n+        assert_fuzzy_eq!(1.3f32.fract(), 0.3f32);\n+        assert_fuzzy_eq!(1.5f32.fract(), 0.5f32);\n+        assert_fuzzy_eq!(1.7f32.fract(), 0.7f32);\n+        assert_fuzzy_eq!(0.0f32.fract(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).fract(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).fract(), -0.0f32);\n+        assert_fuzzy_eq!((-1.3f32).fract(), -0.3f32);\n+        assert_fuzzy_eq!((-1.5f32).fract(), -0.5f32);\n+        assert_fuzzy_eq!((-1.7f32).fract(), -0.7f32);\n+    }\n+\n     #[test]\n     fn test_real_consts() {\n         assert_fuzzy_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());"}, {"sha": "3b6198bfc472ecb81e18ffd7fe2613bba0744fba", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 100, "deletions": 17, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=48c24188f9191888110ebea2bc5193de9a0b26d5", "patch": "@@ -337,6 +337,34 @@ impl Signed for f64 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n+impl Round for f64 {\n+    /// Round half-way cases toward `neg_infinity`\n+    #[inline(always)]\n+    fn floor(&self) -> f64 { floor(*self) }\n+\n+    /// Round half-way cases toward `infinity`\n+    #[inline(always)]\n+    fn ceil(&self) -> f64 { ceil(*self) }\n+\n+    /// Round half-way cases away from `0.0`\n+    #[inline(always)]\n+    fn round(&self) -> f64 { round(*self) }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline(always)]\n+    fn trunc(&self) -> f64 { trunc(*self) }\n+\n+    ///\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(x == trunc(x) + fract(x))\n+    /// ~~~\n+    ///\n+    #[inline(always)]\n+    fn fract(&self) -> f64 { *self - self.trunc() }\n+}\n+\n impl Fractional for f64 {\n     /// The reciprocal (multiplicative inverse) of the number\n     #[inline(always)]\n@@ -412,22 +440,6 @@ impl Real for f64 {\n     #[inline(always)]\n     fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n \n-    #[inline(always)]\n-    fn floor(&self) -> f64 { floor(*self) }\n-\n-    #[inline(always)]\n-    fn ceil(&self) -> f64 { ceil(*self) }\n-\n-    #[inline(always)]\n-    fn round(&self) -> f64 { round(*self) }\n-\n-    #[inline(always)]\n-    fn trunc(&self) -> f64 { trunc(*self) }\n-\n-    /// The fractional part of the number, calculated using: `n - floor(n)`\n-    #[inline(always)]\n-    fn fract(&self) -> f64 { *self - self.floor() }\n-\n     #[inline(always)]\n     fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n \n@@ -766,7 +778,8 @@ mod tests {\n         ($a:expr, $b:expr) => ({\n             let a = $a, b = $b;\n             if !((a - b).abs() < 1.0e-6) {\n-                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n+                fail!(fmt!(\"The values were not approximately equal. \\\n+                            Found: %? and expected %?\", a, b));\n             }\n         })\n     )\n@@ -776,6 +789,76 @@ mod tests {\n         num::test_num(10f64, 2f64);\n     }\n \n+    #[test]\n+    fn test_floor() {\n+        assert_fuzzy_eq!(1.0f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(1.5f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(1.7f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(0.0f64.floor(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).floor(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).floor(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).floor(), -2.0f64);\n+        assert_fuzzy_eq!((-1.5f64).floor(), -2.0f64);\n+        assert_fuzzy_eq!((-1.7f64).floor(), -2.0f64);\n+    }\n+\n+    #[test]\n+    fn test_ceil() {\n+        assert_fuzzy_eq!(1.0f64.ceil(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.ceil(), 2.0f64);\n+        assert_fuzzy_eq!(1.5f64.ceil(), 2.0f64);\n+        assert_fuzzy_eq!(1.7f64.ceil(), 2.0f64);\n+        assert_fuzzy_eq!(0.0f64.ceil(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).ceil(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).ceil(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).ceil(), -1.0f64);\n+        assert_fuzzy_eq!((-1.5f64).ceil(), -1.0f64);\n+        assert_fuzzy_eq!((-1.7f64).ceil(), -1.0f64);\n+    }\n+\n+    #[test]\n+    fn test_round() {\n+        assert_fuzzy_eq!(1.0f64.round(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.round(), 1.0f64);\n+        assert_fuzzy_eq!(1.5f64.round(), 2.0f64);\n+        assert_fuzzy_eq!(1.7f64.round(), 2.0f64);\n+        assert_fuzzy_eq!(0.0f64.round(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).round(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).round(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).round(), -1.0f64);\n+        assert_fuzzy_eq!((-1.5f64).round(), -2.0f64);\n+        assert_fuzzy_eq!((-1.7f64).round(), -2.0f64);\n+    }\n+\n+    #[test]\n+    fn test_trunc() {\n+        assert_fuzzy_eq!(1.0f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(1.5f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(1.7f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(0.0f64.trunc(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).trunc(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).trunc(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).trunc(), -1.0f64);\n+        assert_fuzzy_eq!((-1.5f64).trunc(), -1.0f64);\n+        assert_fuzzy_eq!((-1.7f64).trunc(), -1.0f64);\n+    }\n+\n+    #[test]\n+    fn test_fract() {\n+        assert_fuzzy_eq!(1.0f64.fract(), 0.0f64);\n+        assert_fuzzy_eq!(1.3f64.fract(), 0.3f64);\n+        assert_fuzzy_eq!(1.5f64.fract(), 0.5f64);\n+        assert_fuzzy_eq!(1.7f64.fract(), 0.7f64);\n+        assert_fuzzy_eq!(0.0f64.fract(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).fract(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).fract(), -0.0f64);\n+        assert_fuzzy_eq!((-1.3f64).fract(), -0.3f64);\n+        assert_fuzzy_eq!((-1.5f64).fract(), -0.5f64);\n+        assert_fuzzy_eq!((-1.7f64).fract(), -0.7f64);\n+    }\n+\n     #[test]\n     fn test_real_consts() {\n         assert_fuzzy_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());"}, {"sha": "9c0412b422f52bd49188d96cd7dec7b2ac23968a", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 98, "deletions": 25, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=48c24188f9191888110ebea2bc5193de9a0b26d5", "patch": "@@ -403,6 +403,34 @@ impl num::One for float {\n     fn one() -> float { 1.0 }\n }\n \n+impl Round for float {\n+    /// Round half-way cases toward `neg_infinity`\n+    #[inline(always)]\n+    fn floor(&self) -> float { floor(*self as f64) as float }\n+\n+    /// Round half-way cases toward `infinity`\n+    #[inline(always)]\n+    fn ceil(&self) -> float { ceil(*self as f64) as float }\n+\n+    /// Round half-way cases away from `0.0`\n+    #[inline(always)]\n+    fn round(&self) -> float { round(*self as f64) as float }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline(always)]\n+    fn trunc(&self) -> float { trunc(*self as f64) as float }\n+\n+    ///\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(x == trunc(x) + fract(x))\n+    /// ~~~\n+    ///\n+    #[inline(always)]\n+    fn fract(&self) -> float { *self - self.trunc() }\n+}\n+\n impl Fractional for float {\n     /// The reciprocal (multiplicative inverse) of the number\n     #[inline(always)]\n@@ -478,22 +506,6 @@ impl Real for float {\n     #[inline(always)]\n     fn log_10() -> float { 2.30258509299404568401799145468436421 }\n \n-    #[inline(always)]\n-    fn floor(&self) -> float { floor(*self as f64) as float }\n-\n-    #[inline(always)]\n-    fn ceil(&self) -> float { ceil(*self as f64) as float }\n-\n-    #[inline(always)]\n-    fn round(&self) -> float { round(*self as f64) as float }\n-\n-    #[inline(always)]\n-    fn trunc(&self) -> float { trunc(*self as f64) as float }\n-\n-    /// The fractional part of the number, calculated using: `n - floor(n)`\n-    #[inline(always)]\n-    fn fract(&self) -> float { *self - self.floor() }\n-\n     #[inline(always)]\n     fn pow(&self, n: float) -> float { pow(*self as f64, n as f64) as float }\n \n@@ -694,6 +706,76 @@ mod tests {\n         num::test_num(10f, 2f);\n     }\n \n+    #[test]\n+    fn test_floor() {\n+        assert_fuzzy_eq!(1.0f.floor(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.floor(), 1.0f);\n+        assert_fuzzy_eq!(1.5f.floor(), 1.0f);\n+        assert_fuzzy_eq!(1.7f.floor(), 1.0f);\n+        assert_fuzzy_eq!(0.0f.floor(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).floor(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).floor(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).floor(), -2.0f);\n+        assert_fuzzy_eq!((-1.5f).floor(), -2.0f);\n+        assert_fuzzy_eq!((-1.7f).floor(), -2.0f);\n+    }\n+\n+    #[test]\n+    fn test_ceil() {\n+        assert_fuzzy_eq!(1.0f.ceil(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.ceil(), 2.0f);\n+        assert_fuzzy_eq!(1.5f.ceil(), 2.0f);\n+        assert_fuzzy_eq!(1.7f.ceil(), 2.0f);\n+        assert_fuzzy_eq!(0.0f.ceil(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).ceil(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).ceil(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).ceil(), -1.0f);\n+        assert_fuzzy_eq!((-1.5f).ceil(), -1.0f);\n+        assert_fuzzy_eq!((-1.7f).ceil(), -1.0f);\n+    }\n+\n+    #[test]\n+    fn test_round() {\n+        assert_fuzzy_eq!(1.0f.round(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.round(), 1.0f);\n+        assert_fuzzy_eq!(1.5f.round(), 2.0f);\n+        assert_fuzzy_eq!(1.7f.round(), 2.0f);\n+        assert_fuzzy_eq!(0.0f.round(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).round(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).round(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).round(), -1.0f);\n+        assert_fuzzy_eq!((-1.5f).round(), -2.0f);\n+        assert_fuzzy_eq!((-1.7f).round(), -2.0f);\n+    }\n+\n+    #[test]\n+    fn test_trunc() {\n+        assert_fuzzy_eq!(1.0f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(1.5f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(1.7f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(0.0f.trunc(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).trunc(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).trunc(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).trunc(), -1.0f);\n+        assert_fuzzy_eq!((-1.5f).trunc(), -1.0f);\n+        assert_fuzzy_eq!((-1.7f).trunc(), -1.0f);\n+    }\n+\n+    #[test]\n+    fn test_fract() {\n+        assert_fuzzy_eq!(1.0f.fract(), 0.0f);\n+        assert_fuzzy_eq!(1.3f.fract(), 0.3f);\n+        assert_fuzzy_eq!(1.5f.fract(), 0.5f);\n+        assert_fuzzy_eq!(1.7f.fract(), 0.7f);\n+        assert_fuzzy_eq!(0.0f.fract(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).fract(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).fract(), -0.0f);\n+        assert_fuzzy_eq!((-1.3f).fract(), -0.3f);\n+        assert_fuzzy_eq!((-1.5f).fract(), -0.5f);\n+        assert_fuzzy_eq!((-1.7f).fract(), -0.7f);\n+    }\n+\n     #[test]\n     fn test_real_consts() {\n         assert_fuzzy_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n@@ -893,15 +975,6 @@ mod tests {\n         assert_eq!(to_str_digits(infinity, 10u), ~\"inf\");\n         assert_eq!(to_str_digits(-infinity, 10u), ~\"-inf\");\n     }\n-\n-    #[test]\n-    pub fn test_round() {\n-        assert_eq!(round(5.8), 6.0);\n-        assert_eq!(round(5.2), 5.0);\n-        assert_eq!(round(3.0), 3.0);\n-        assert_eq!(round(2.5), 3.0);\n-        assert_eq!(round(-3.5), -4.0);\n-    }\n }\n \n //"}, {"sha": "e19afdc69c32fb15097a29ed5f1f9731be420681", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=48c24188f9191888110ebea2bc5193de9a0b26d5", "patch": "@@ -77,8 +77,17 @@ pub trait Integer: Num\n     fn is_odd(&self) -> bool;\n }\n \n+pub trait Round {\n+    fn floor(&self) -> Self;\n+    fn ceil(&self) -> Self;\n+    fn round(&self) -> Self;\n+    fn trunc(&self) -> Self;\n+    fn fract(&self) -> Self;\n+}\n+\n pub trait Fractional: Num\n                     + Ord\n+                    + Round\n                     + Quot<Self,Self> {\n     fn recip(&self) -> Self;\n }\n@@ -108,13 +117,6 @@ pub trait Real: Signed\n     fn log_2() -> Self;\n     fn log_10() -> Self;\n \n-    // Rounding operations\n-    fn floor(&self) -> Self;\n-    fn ceil(&self) -> Self;\n-    fn round(&self) -> Self;\n-    fn trunc(&self) -> Self;\n-    fn fract(&self) -> Self;\n-\n     // Exponential functions\n     fn pow(&self, n: Self) -> Self;\n     fn exp(&self) -> Self;"}, {"sha": "553bb8268102b901a1c0e7ceb91f0ae1bd59e79a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48c24188f9191888110ebea2bc5193de9a0b26d5/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=48c24188f9191888110ebea2bc5193de9a0b26d5", "patch": "@@ -39,7 +39,7 @@ pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n pub use num::{Num, NumCast};\n pub use num::{Signed, Unsigned, Integer};\n-pub use num::{Fractional, Real, RealExt};\n+pub use num::{Round, Fractional, Real, RealExt};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}]}