{"sha": "fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "node_id": "C_kwDOAAsO6NoAKGZlN2M1MTYwODQ2MjUxZjZmM2Y2MmI0YTAyZjk5ZjVmYWZhMzhjZmE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-23T08:34:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-23T08:34:51Z"}, "message": "Merge #10602\n\n10602: Add qualify method call assist r=Veykril a=qepasa\n\nThis adds `qualify_method_call` assist that allows to replace a method (or trait) call that resolves with its fully qualified path.\r\n\r\nFor example, for stuct method:\r\n```rust\r\nstruct Foo;\r\nimpl Foo {\r\n    fn foo(&self) {}\r\n}\r\n```\r\n```\r\nlet foo = Foo {};\r\nfoo.fo$0o();\r\n```\r\n\r\nbecomes\r\n```rust\r\nlet foo = Foo {};\r\nFoo::foo(&foo);\r\n```\r\n\r\nfor a trait method:\r\n\r\n```rust\r\nstruct Foo;\r\ntrait FooTrait {\r\n    fn foo(&self) {}\r\n}\r\nimpl FooTrait for Foo {\r\n    fn foo(&self) {}\r\n}\r\n```\r\nfollowing call:\r\n```rust\r\nlet foo = Foo {};\r\nfoo.fo$0o();\r\n```\r\n\r\nbecomes:\r\n```rust\r\nlet foo = Foo {};\r\nFooTrait::foo(&foo);\r\n```\r\n\r\nfixes #10453 \n\nCo-authored-by: Pawe\u0142 Palenica <pawelpalenica11@gmail.com>", "tree": {"sha": "74f2980dc56dbffd1920aa404906e822a589b406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74f2980dc56dbffd1920aa404906e822a589b406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhc8krCRBK7hj4Ov3rIwAAaF0IAFRF98EB64fzIyKbST0WTk6u\ngN92ZG4bRZeXPRLNr88S9PPevobeh1DLSbWsmjsUfMnGZZLive4E4x6zBftZBV+x\niQ6jpXBnNEFegy2xK6yXIbVO/K+QVls5jy9ZZqPO69RX2bZHa85lyyBH9rMyEi+v\nvbbVg21v6qCLLyNnFrvyKMn/GCUPbgWDhsKK3sIcSwJohmqsY1WZ4SAGbVwPbY8H\nnOSX9Qshv+X1WWkQ4YDZH4cxNdzRiD5nSj2OYHq1cyGhPfxHZbmw8i2Ajb1ApM9e\nH2tu02lJDMBeaRYtIhSZKO0RM1tcVWxyawPZqnvaOhloZAlz+4f2stSG4M/W2Sg=\n=HYO5\n-----END PGP SIGNATURE-----\n", "payload": "tree 74f2980dc56dbffd1920aa404906e822a589b406\nparent a75353e8acc63d660b2bcb2e70f496ddc0567789\nparent bfc86f64c3f1498ce0939ab75e301a20cb03b36b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634978091 +0000\ncommitter GitHub <noreply@github.com> 1634978091 +0000\n\nMerge #10602\n\n10602: Add qualify method call assist r=Veykril a=qepasa\n\nThis adds `qualify_method_call` assist that allows to replace a method (or trait) call that resolves with its fully qualified path.\r\n\r\nFor example, for stuct method:\r\n```rust\r\nstruct Foo;\r\nimpl Foo {\r\n    fn foo(&self) {}\r\n}\r\n```\r\n```\r\nlet foo = Foo {};\r\nfoo.fo$0o();\r\n```\r\n\r\nbecomes\r\n```rust\r\nlet foo = Foo {};\r\nFoo::foo(&foo);\r\n```\r\n\r\nfor a trait method:\r\n\r\n```rust\r\nstruct Foo;\r\ntrait FooTrait {\r\n    fn foo(&self) {}\r\n}\r\nimpl FooTrait for Foo {\r\n    fn foo(&self) {}\r\n}\r\n```\r\nfollowing call:\r\n```rust\r\nlet foo = Foo {};\r\nfoo.fo$0o();\r\n```\r\n\r\nbecomes:\r\n```rust\r\nlet foo = Foo {};\r\nFooTrait::foo(&foo);\r\n```\r\n\r\nfixes #10453 \n\nCo-authored-by: Pawe\u0142 Palenica <pawelpalenica11@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "html_url": "https://github.com/rust-lang/rust/commit/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a75353e8acc63d660b2bcb2e70f496ddc0567789", "url": "https://api.github.com/repos/rust-lang/rust/commits/a75353e8acc63d660b2bcb2e70f496ddc0567789", "html_url": "https://github.com/rust-lang/rust/commit/a75353e8acc63d660b2bcb2e70f496ddc0567789"}, {"sha": "bfc86f64c3f1498ce0939ab75e301a20cb03b36b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc86f64c3f1498ce0939ab75e301a20cb03b36b", "html_url": "https://github.com/rust-lang/rust/commit/bfc86f64c3f1498ce0939ab75e301a20cb03b36b"}], "stats": {"total": 597, "additions": 586, "deletions": 11}, "files": [{"sha": "43878879edf5564162803aecf82a1c9679fd6418", "filename": "crates/ide_assists/src/handlers/qualify_method_call.rs", "status": "added", "additions": 531, "deletions": 0, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "patch": "@@ -0,0 +1,531 @@\n+use hir::{ItemInNs, ModuleDef};\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    helpers::import_assets::item_for_path_search,\n+};\n+use syntax::{ast, AstNode};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    handlers::qualify_path::QualifyCandidate,\n+};\n+\n+// Assist: qualify_method_call\n+//\n+// Replaces the method call with a qualified function call.\n+//\n+// ```\n+// struct Foo;\n+// impl Foo {\n+//     fn foo(&self) {}\n+// }\n+// fn main() {\n+//     let foo = Foo;\n+//     foo.fo$0o();\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Foo;\n+// impl Foo {\n+//     fn foo(&self) {}\n+// }\n+// fn main() {\n+//     let foo = Foo;\n+//     Foo::foo(&foo);\n+// }\n+// ```\n+pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let name: ast::NameRef = ctx.find_node_at_offset()?;\n+    let call = name.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+\n+    let ident = name.ident_token()?;\n+\n+    let range = call.syntax().text_range();\n+    let resolved_call = ctx.sema.resolve_method_call(&call)?;\n+\n+    let current_module = ctx.sema.scope(&call.syntax()).module()?;\n+    let target_module_def = ModuleDef::from(resolved_call);\n+    let item_in_ns = ItemInNs::from(target_module_def);\n+    let receiver_path = current_module\n+        .find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+\n+    let qualify_candidate = QualifyCandidate::ImplMethod(ctx.sema.db, call, resolved_call);\n+\n+    acc.add(\n+        AssistId(\"qualify_method_call\", AssistKind::RefactorInline),\n+        format!(\"Qualify `{}` method call\", ident.text()),\n+        range,\n+        |builder| {\n+            qualify_candidate.qualify(\n+                |replace_with: String| builder.replace(range, replace_with),\n+                &receiver_path,\n+                item_in_ns,\n+            )\n+        },\n+    );\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn struct_method() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o()\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(&foo)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_multi_params() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(&foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_consume() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_exclusive() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&mut self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&mut self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(&mut foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_cross_crate() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub struct Foo;\n+    impl Foo {\n+        pub fn foo(&mut self, p1: i32, p2: u32) {}\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    dep::test_mod::Foo::foo(&mut foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_generic() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo<T>(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o::<()>()\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo<T>(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo::<()>(&foo)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od()\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(&test_struct)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_multi_params() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od(12, 32u)\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(&test_struct, 12, 32u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_consume() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od(12, 32u)\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(test_struct, 12, 32u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_exclusive() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od(12, 32u)\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(&mut test_struct, 12, 32u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_cross_crate() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub struct Foo;\n+    impl Foo {\n+        pub fn foo(&mut self, p1: i32, p2: u32) {}\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    dep::test_mod::Foo::foo(&mut foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_generic() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method<T>(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method<T>(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = TestStruct {};\n+    test_struct.test_meth$0od::<()>()\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method<T>(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method<T>(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = TestStruct {};\n+    TestTrait::test_method::<()>(&test_struct)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_over_stuct_instance() {\n+        check_assist_not_applicable(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    f$0oo.foo()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_over_stuct_instance() {\n+        check_assist_not_applicable(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    tes$0t_struct.test_method()\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "29f2c785bc23d0277bc69dae90404f2f0ff697e8", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "patch": "@@ -91,16 +91,16 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     }\n     Some(())\n }\n-\n-enum QualifyCandidate<'db> {\n+pub(crate) enum QualifyCandidate<'db> {\n     QualifierStart(ast::PathSegment, Option<ast::GenericArgList>),\n     UnqualifiedName(Option<ast::GenericArgList>),\n     TraitAssocItem(ast::Path, ast::PathSegment),\n     TraitMethod(&'db RootDatabase, ast::MethodCallExpr),\n+    ImplMethod(&'db RootDatabase, ast::MethodCallExpr, hir::Function),\n }\n \n impl QualifyCandidate<'_> {\n-    fn qualify(\n+    pub(crate) fn qualify(\n         &self,\n         mut replacer: impl FnMut(String),\n         import: &hir::ModPath,\n@@ -122,24 +122,26 @@ impl QualifyCandidate<'_> {\n             QualifyCandidate::TraitMethod(db, mcall_expr) => {\n                 Self::qualify_trait_method(db, mcall_expr, replacer, import, item);\n             }\n+            QualifyCandidate::ImplMethod(db, mcall_expr, hir_fn) => {\n+                Self::qualify_fn_call(db, mcall_expr, replacer, import, hir_fn);\n+            }\n         }\n     }\n \n-    fn qualify_trait_method(\n+    fn qualify_fn_call(\n         db: &RootDatabase,\n         mcall_expr: &ast::MethodCallExpr,\n         mut replacer: impl FnMut(String),\n         import: ast::Path,\n-        item: hir::ItemInNs,\n+        hir_fn: &hir::Function,\n     ) -> Option<()> {\n         let receiver = mcall_expr.receiver()?;\n-        let trait_method_name = mcall_expr.name_ref()?;\n+        let method_name = mcall_expr.name_ref()?;\n         let generics =\n             mcall_expr.generic_arg_list().as_ref().map_or_else(String::new, ToString::to_string);\n         let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n-        let trait_ = item_as_trait(db, item)?;\n-        let method = find_trait_method(db, trait_, &trait_method_name)?;\n-        if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n+\n+        if let Some(self_access) = hir_fn.self_param(db).map(|sp| sp.access(db)) {\n             let receiver = match self_access {\n                 hir::Access::Shared => make::expr_ref(receiver, false),\n                 hir::Access::Exclusive => make::expr_ref(receiver, true),\n@@ -148,7 +150,7 @@ impl QualifyCandidate<'_> {\n             replacer(format!(\n                 \"{}::{}{}{}\",\n                 import,\n-                trait_method_name,\n+                method_name,\n                 generics,\n                 match arg_list {\n                     Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n@@ -158,6 +160,19 @@ impl QualifyCandidate<'_> {\n         }\n         Some(())\n     }\n+\n+    fn qualify_trait_method(\n+        db: &RootDatabase,\n+        mcall_expr: &ast::MethodCallExpr,\n+        replacer: impl FnMut(String),\n+        import: ast::Path,\n+        item: hir::ItemInNs,\n+    ) -> Option<()> {\n+        let trait_method_name = mcall_expr.name_ref()?;\n+        let trait_ = item_as_trait(db, item)?;\n+        let method = find_trait_method(db, trait_, &trait_method_name)?;\n+        Self::qualify_fn_call(db, mcall_expr, replacer, import, &method)\n+    }\n }\n \n fn find_trait_method("}, {"sha": "8f9ae6c15405610352c8f87c4aaed3e849ad9e5b", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "patch": "@@ -161,6 +161,7 @@ mod handlers {\n     mod promote_local_to_const;\n     mod pull_assignment_up;\n     mod qualify_path;\n+    mod qualify_method_call;\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n@@ -242,6 +243,7 @@ mod handlers {\n             pull_assignment_up::pull_assignment_up,\n             promote_local_to_const::promote_local_to_const,\n             qualify_path::qualify_path,\n+            qualify_method_call::qualify_method_call,\n             raw_string::add_hash,\n             raw_string::make_usual_string,\n             raw_string::remove_hash,"}, {"sha": "43d30e84b3b0986a4f6fdc9c43907ad42e24e459", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "patch": "@@ -1531,6 +1531,33 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_qualify_method_call() {\n+    check_doc_test(\n+        \"qualify_method_call\",\n+        r#####\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+fn main() {\n+    let foo = Foo;\n+    foo.fo$0o();\n+}\n+\"#####,\n+        r#####\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+fn main() {\n+    let foo = Foo;\n+    Foo::foo(&foo);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_qualify_path() {\n     check_doc_test("}, {"sha": "f1e8ee4935db428c4a7f44da60f0f41383212d52", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe7c5160846251f6f3f62b4a02f99f5fafa38cfa/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=fe7c5160846251f6f3f62b4a02f99f5fafa38cfa", "patch": "@@ -372,7 +372,7 @@ fn import_for_item(\n     })\n }\n \n-fn item_for_path_search(db: &RootDatabase, item: ItemInNs) -> Option<ItemInNs> {\n+pub fn item_for_path_search(db: &RootDatabase, item: ItemInNs) -> Option<ItemInNs> {\n     Some(match item {\n         ItemInNs::Types(_) | ItemInNs::Values(_) => match item_as_assoc(db, item) {\n             Some(assoc_item) => match assoc_item.container(db) {"}]}