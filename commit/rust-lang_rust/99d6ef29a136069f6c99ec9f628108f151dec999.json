{"sha": "99d6ef29a136069f6c99ec9f628108f151dec999", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZDZlZjI5YTEzNjA2OWY2Yzk5ZWM5ZjYyODEwOGYxNTFkZWM5OTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-01T09:28:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T09:28:22Z"}, "message": "Merge #5160\n\n5160: Use the existing Semantics in auto_import r=matklad a=lnicola\n\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>", "tree": {"sha": "4376f563f0a039bd489ada030b36d3f966280f42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4376f563f0a039bd489ada030b36d3f966280f42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99d6ef29a136069f6c99ec9f628108f151dec999", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/Fc2CRBK7hj4Ov3rIwAAdHIIALJz2v7BtLzVYOci9rt2qjWa\nid1MBhHMdA/Jjh+X0Ne6CM2uMB6MfWGTynxDDteEdW6njEvb4I1PiCN8noWV4Sws\nNEDfIKKGPQ34kQOTF7BayLNQTzhOfl6pBivMbG5rS1d6fjkiX/RPoZsHZYd8vzEC\nKC/QfNMh7SMZKcBtV1+hoPAPOa/siFv9R60PFAM0Z0+13Wo5Al5qWSbxmSSEktYt\nnqGCJcmwDyAKxSbsOuGLqp/8uNgjNegdqIpbErWtkBxTQM6OGewQs0U/ukhhQ96m\n+EjMSEmvn4RLCcF9z4FCFFYCrPHxz9f43YC8MESSlxfx734e/NI54QgJEe3c40I=\n=uZ0u\n-----END PGP SIGNATURE-----\n", "payload": "tree 4376f563f0a039bd489ada030b36d3f966280f42\nparent d34fd372bbcce4600fe7dd1ca61b9b213a7f5ced\nparent c1139a5a4404f3a36c3b826d4ceb0b53da7c69b1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593595702 +0000\ncommitter GitHub <noreply@github.com> 1593595702 +0000\n\nMerge #5160\n\n5160: Use the existing Semantics in auto_import r=matklad a=lnicola\n\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99d6ef29a136069f6c99ec9f628108f151dec999", "html_url": "https://github.com/rust-lang/rust/commit/99d6ef29a136069f6c99ec9f628108f151dec999", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99d6ef29a136069f6c99ec9f628108f151dec999/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d34fd372bbcce4600fe7dd1ca61b9b213a7f5ced", "url": "https://api.github.com/repos/rust-lang/rust/commits/d34fd372bbcce4600fe7dd1ca61b9b213a7f5ced", "html_url": "https://github.com/rust-lang/rust/commit/d34fd372bbcce4600fe7dd1ca61b9b213a7f5ced"}, {"sha": "c1139a5a4404f3a36c3b826d4ceb0b53da7c69b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1139a5a4404f3a36c3b826d4ceb0b53da7c69b1", "html_url": "https://github.com/rust-lang/rust/commit/c1139a5a4404f3a36c3b826d4ceb0b53da7c69b1"}], "stats": {"total": 100, "additions": 48, "deletions": 52}, "files": [{"sha": "7b6499a08830822ad22ec5e3df7c3e8d14e6d32f", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99d6ef29a136069f6c99ec9f628108f151dec999/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6ef29a136069f6c99ec9f628108f151dec999/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=99d6ef29a136069f6c99ec9f628108f151dec999", "patch": "@@ -5,7 +5,7 @@ use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n };\n-use ra_ide_db::{imports_locator::ImportsLocator, RootDatabase};\n+use ra_ide_db::{imports_locator, RootDatabase};\n use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -35,8 +35,8 @@ use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists, Group\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let auto_import_assets = AutoImportAssets::new(&ctx)?;\n-    let proposed_imports = auto_import_assets.search_for_imports(ctx.db());\n+    let auto_import_assets = AutoImportAssets::new(ctx)?;\n+    let proposed_imports = auto_import_assets.search_for_imports(ctx);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n@@ -127,11 +127,11 @@ impl AutoImportAssets {\n         GroupLabel(name)\n     }\n \n-    fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n+    fn search_for_imports(&self, ctx: &AssistContext) -> BTreeSet<ModPath> {\n         let _p = profile(\"auto_import::search_for_imports\");\n+        let db = ctx.db();\n         let current_crate = self.module_with_name_to_import.krate();\n-        ImportsLocator::new(db, current_crate)\n-            .find_imports(&self.get_search_query())\n+        imports_locator::find_imports(&ctx.sema, current_crate, &self.get_search_query())\n             .into_iter()\n             .filter_map(|candidate| match &self.import_candidate {\n                 ImportCandidate::TraitAssocItem(assoc_item_type, _) => {"}, {"sha": "1fba71ff85cb2305d348a4d0a4c3da24d02026c0", "filename": "crates/ra_ide_db/src/imports_locator.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/99d6ef29a136069f6c99ec9f628108f151dec999/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d6ef29a136069f6c99ec9f628108f151dec999/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs?ref=99d6ef29a136069f6c99ec9f628108f151dec999", "patch": "@@ -13,57 +13,53 @@ use crate::{\n use either::Either;\n use rustc_hash::FxHashSet;\n \n-pub struct ImportsLocator<'a> {\n-    sema: Semantics<'a, RootDatabase>,\n+pub fn find_imports<'a>(\n+    sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n-}\n-\n-impl<'a> ImportsLocator<'a> {\n-    pub fn new(db: &'a RootDatabase, krate: Crate) -> Self {\n-        Self { sema: Semantics::new(db), krate }\n-    }\n+    name_to_import: &str,\n+) -> Vec<Either<ModuleDef, MacroDef>> {\n+    let _p = profile(\"search_for_imports\");\n+    let db = sema.db;\n \n-    pub fn find_imports(&mut self, name_to_import: &str) -> Vec<Either<ModuleDef, MacroDef>> {\n-        let _p = profile(\"search_for_imports\");\n-        let db = self.sema.db;\n+    // Query dependencies first.\n+    let mut candidates: FxHashSet<_> =\n+        krate.query_external_importables(db, name_to_import).collect();\n \n-        // Query dependencies first.\n-        let mut candidates: FxHashSet<_> =\n-            self.krate.query_external_importables(db, name_to_import).collect();\n+    // Query the local crate using the symbol index.\n+    let local_results = {\n+        let mut query = Query::new(name_to_import.to_string());\n+        query.exact();\n+        query.limit(40);\n+        symbol_index::crate_symbols(db, krate.into(), query)\n+    };\n \n-        // Query the local crate using the symbol index.\n-        let local_results = {\n-            let mut query = Query::new(name_to_import.to_string());\n-            query.exact();\n-            query.limit(40);\n-            symbol_index::crate_symbols(db, self.krate.into(), query)\n-        };\n+    candidates.extend(\n+        local_results\n+            .into_iter()\n+            .filter_map(|import_candidate| get_name_definition(sema, &import_candidate))\n+            .filter_map(|name_definition_to_import| match name_definition_to_import {\n+                Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n+                Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n+                _ => None,\n+            }),\n+    );\n \n-        candidates.extend(\n-            local_results\n-                .into_iter()\n-                .filter_map(|import_candidate| self.get_name_definition(&import_candidate))\n-                .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                    Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n-                    Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n-                    _ => None,\n-                }),\n-        );\n-\n-        candidates.into_iter().collect()\n-    }\n+    candidates.into_iter().collect()\n+}\n \n-    fn get_name_definition(&mut self, import_candidate: &FileSymbol) -> Option<Definition> {\n-        let _p = profile(\"get_name_definition\");\n-        let file_id = import_candidate.file_id;\n+fn get_name_definition<'a>(\n+    sema: &Semantics<'a, RootDatabase>,\n+    import_candidate: &FileSymbol,\n+) -> Option<Definition> {\n+    let _p = profile(\"get_name_definition\");\n+    let file_id = import_candidate.file_id;\n \n-        let candidate_node = import_candidate.ptr.to_node(self.sema.parse(file_id).syntax());\n-        let candidate_name_node = if candidate_node.kind() != NAME {\n-            candidate_node.children().find(|it| it.kind() == NAME)?\n-        } else {\n-            candidate_node\n-        };\n-        let name = ast::Name::cast(candidate_name_node)?;\n-        classify_name(&self.sema, &name)?.into_definition()\n-    }\n+    let candidate_node = import_candidate.ptr.to_node(sema.parse(file_id).syntax());\n+    let candidate_name_node = if candidate_node.kind() != NAME {\n+        candidate_node.children().find(|it| it.kind() == NAME)?\n+    } else {\n+        candidate_node\n+    };\n+    let name = ast::Name::cast(candidate_name_node)?;\n+    classify_name(sema, &name)?.into_definition()\n }"}]}