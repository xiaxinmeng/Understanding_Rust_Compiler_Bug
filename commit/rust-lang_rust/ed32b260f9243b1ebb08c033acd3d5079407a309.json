{"sha": "ed32b260f9243b1ebb08c033acd3d5079407a309", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzJiMjYwZjkyNDNiMWViYjA4YzAzM2FjZDNkNTA3OTQwN2EzMDk=", "commit": {"author": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-02T01:46:42Z"}, "committer": {"name": "JCTyBlaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-11-02T02:57:06Z"}, "message": "Add tests, and fix bug in atomic RMW relaxed stores", "tree": {"sha": "baf043ed882b0d2e1a8162097d6ca4daa644a6dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baf043ed882b0d2e1a8162097d6ca4daa644a6dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed32b260f9243b1ebb08c033acd3d5079407a309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed32b260f9243b1ebb08c033acd3d5079407a309", "html_url": "https://github.com/rust-lang/rust/commit/ed32b260f9243b1ebb08c033acd3d5079407a309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed32b260f9243b1ebb08c033acd3d5079407a309/comments", "author": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89814f1b3f6c239f472dea4798a1189a30d7efa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/89814f1b3f6c239f472dea4798a1189a30d7efa2", "html_url": "https://github.com/rust-lang/rust/commit/89814f1b3f6c239f472dea4798a1189a30d7efa2"}], "stats": {"total": 326, "additions": 315, "deletions": 11}, "files": [{"sha": "ac928071bef1826c875924e3098bd8cf503b835e", "filename": "src/data_race.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -404,8 +404,9 @@ impl AtomicReleaseSequences {\n     fn clear_and_retain(&mut self, thread: ThreadId) {\n         match self {\n             Self::ReleaseOneOrEmpty(id, rel_clock) => {\n-                // Keep or forget depending on id\n-                if *id == Some(thread) {\n+                // If the id is the same, then reatin the value\n+                //  otherwise delete and clear the release vector clock\n+                if *id != Some(thread) {\n                     *id = None;\n                     rel_clock.set_zero_vector();\n                 }"}, {"sha": "e823a7d88d6a9db54bd2ee11e4a65f6ceaa980d3", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -15,8 +15,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.tcx.sess.warn(\n-            \"thread support is experimental. \\\n-             For example, Miri does not detect data races yet.\",\n+            \"thread support is experimental.\",\n         );\n \n         // Create the new thread"}, {"sha": "ece99b4a87a11b7db6c86fa906f0df1e75ce3042", "filename": "tests/compile-fail/data_race/read_write_race.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fread_write_race.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -0,0 +1,26 @@\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0\n+        });\n+\n+        let j2 = spawn(move || {\n+            *c.0 = 64; //~ ERROR Data race\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "cc96083546a29f85f242cbde8ed0aec9c1cf626e", "filename": "tests/compile-fail/data_race/relax_acquire_race.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frelax_acquire_race.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -0,0 +1,42 @@\n+\n+use std::thread::spawn;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+static SYNC: AtomicUsize = AtomicUsize::new(0);\n+\n+pub fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 1;\n+            SYNC.store(1, Ordering::Release);\n+        });\n+\n+        let j2 = spawn(move || {\n+            if SYNC.load(Ordering::Acquire) == 1 {\n+                SYNC.store(2, Ordering::Relaxed);\n+            }\n+        });\n+\n+        let j3 = spawn(move || {\n+            if SYNC.load(Ordering::Acquire) == 2 {\n+                *c.0 //~ ERROR Data race\n+            }else{\n+                0\n+            }\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+        j3.join().unwrap();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "8b3ffbcd9dd88c7e228276a4e2203685c582be87", "filename": "tests/compile-fail/data_race/release_seq_race.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frelease_seq_race.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -0,0 +1,46 @@\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread::{spawn, sleep};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::time::Duration;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+static SYNC: AtomicUsize = AtomicUsize::new(0);\n+\n+pub fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 1;\n+            SYNC.store(1, Ordering::Release);\n+            sleep(Duration::from_millis(100));\n+            SYNC.store(3, Ordering::Relaxed);\n+        });\n+\n+        let j2 = spawn(move || {\n+            // Blocks the acquire-release sequence\n+            SYNC.store(2, Ordering::Relaxed);\n+        });\n+\n+        let j3 = spawn(move || {\n+            sleep(Duration::from_millis(1000));\n+            if SYNC.load(Ordering::Acquire) == 3 {\n+                *c.0 //~ ERROR Data race\n+            }else{\n+                0\n+            }\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+        j3.join().unwrap();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "9c31c79ebf13101d675d742dcfc5347b8a3459f8", "filename": "tests/compile-fail/data_race/rmw_race.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Frmw_race.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -0,0 +1,43 @@\n+\n+use std::thread::spawn;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+static SYNC: AtomicUsize = AtomicUsize::new(0);\n+\n+pub fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 1;\n+            SYNC.store(1, Ordering::Release);\n+        });\n+\n+        let j2 = spawn(move || {\n+            if SYNC.swap(2, Ordering::Relaxed) == 1 {\n+                // Blocks the acquire-release sequence\n+                SYNC.store(3, Ordering::Relaxed);\n+            }\n+        });\n+\n+        let j3 = spawn(move || {\n+            if SYNC.load(Ordering::Acquire) == 3 {\n+                *c.0 //~ ERROR Data race\n+            }else{\n+                0\n+            }\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+        j3.join().unwrap();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "22caf5f0f7f3476d5b2e0da0aeb3e19b0e21138c", "filename": "tests/compile-fail/data_race/write_write_race.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdata_race%2Fwrite_write_race.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -0,0 +1,26 @@\n+\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+pub fn main() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 32;\n+        });\n+\n+        let j2 = spawn(move || {\n+            *c.0 = 64; //~ ERROR Data race\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "bc4a4e30e89154f555e008f52e3ec1bb086d0403", "filename": "tests/run-pass/concurrency/data_race.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fdata_race.rs?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -0,0 +1,119 @@\n+use std::sync::atomic::{AtomicUsize, fence, Ordering};\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+static SYNC: AtomicUsize = AtomicUsize::new(0);\n+\n+fn test_fence_sync() {\n+    let mut var = 0u32;\n+    let ptr = &mut var as *mut u32;\n+    let evil_ptr = EvilSend(ptr);\n+    \n+    \n+    let j1 = spawn(move || {\n+        unsafe { *evil_ptr.0 = 1; }\n+        fence(Ordering::Release);\n+        SYNC.store(1, Ordering::Relaxed)   \n+    });\n+\n+    let j2 = spawn(move || {\n+        if SYNC.load(Ordering::Relaxed) == 1 {\n+            fence(Ordering::Acquire);\n+            unsafe { *evil_ptr.0 }\n+        }else{\n+            0\n+        }\n+    });\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+}\n+\n+\n+fn test_multiple_reads() {\n+    let mut var = 42u32;\n+    let ptr = &mut var as *mut u32;\n+    let evil_ptr = EvilSend(ptr);\n+\n+    let j1 = spawn(move || unsafe {*evil_ptr.0});\n+    let j2 = spawn(move || unsafe {*evil_ptr.0});\n+    let j3 = spawn(move || unsafe {*evil_ptr.0});\n+    let j4 = spawn(move || unsafe {*evil_ptr.0});\n+\n+    assert_eq!(j1.join().unwrap(), 42);\n+    assert_eq!(j2.join().unwrap(), 42);\n+    assert_eq!(j3.join().unwrap(), 42);\n+    assert_eq!(j4.join().unwrap(), 42);\n+\n+    var = 10;\n+    assert_eq!(var, 10);\n+}\n+\n+pub fn test_rmw_no_block() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 1;\n+            SYNC.store(1, Ordering::Release);\n+        });\n+\n+        let j2 = spawn(move || {\n+            if SYNC.swap(2, Ordering::Relaxed) == 1 {\n+                //No op, blocking store removed\n+            }\n+        });\n+\n+        let j3 = spawn(move || {\n+            if SYNC.load(Ordering::Acquire) == 2 {\n+                *c.0\n+            }else{\n+                0\n+            }\n+        });\n+\n+        j1.join().unwrap();\n+        j2.join().unwrap();\n+        let v = j3.join().unwrap();\n+        assert!(v == 1 || v == 2);\n+    }\n+}\n+\n+pub fn test_release_no_block() {\n+    let mut a = 0u32;\n+    let b = &mut a as *mut u32;\n+    let c = EvilSend(b);\n+\n+    unsafe {\n+        let j1 = spawn(move || {\n+            *c.0 = 1;\n+            SYNC.store(1, Ordering::Release);\n+            SYNC.store(3, Ordering::Relaxed);\n+        });\n+\n+        let j2 = spawn(move || {\n+            if SYNC.load(Ordering::Acquire) == 3 {\n+                *c.0\n+            }else{\n+                0\n+            }\n+        });\n+\n+        j1.join().unwrap();\n+        assert_eq!(j2.join().unwrap(),1);\n+    }\n+}\n+\n+pub fn main() {\n+    test_fence_sync();\n+    test_multiple_reads();\n+    test_rmw_no_block();\n+    test_release_no_block();\n+}\n\\ No newline at end of file"}, {"sha": "b01247aea4e0eab803382c49bad5c4cd1ee2c35e", "filename": "tests/run-pass/concurrency/data_race.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fdata_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fdata_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fdata_race.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental.\n+"}, {"sha": "b01247aea4e0eab803382c49bad5c4cd1ee2c35e", "filename": "tests/run-pass/concurrency/linux-futex.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -1,2 +1,2 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n+warning: thread support is experimental.\n "}, {"sha": "f1550dd25aa0cfca909fd6481d0ae73602e1f14e", "filename": "tests/run-pass/concurrency/simple.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fsimple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fsimple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsimple.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -1,4 +1,4 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n+warning: thread support is experimental.\n \n thread '<unnamed>' panicked at 'Hello!', $DIR/simple.rs:54:9\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "b01247aea4e0eab803382c49bad5c4cd1ee2c35e", "filename": "tests/run-pass/concurrency/sync.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fsync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fsync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -1,2 +1,2 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n+warning: thread support is experimental.\n "}, {"sha": "b01247aea4e0eab803382c49bad5c4cd1ee2c35e", "filename": "tests/run-pass/concurrency/thread_locals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fthread_locals.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -1,2 +1,2 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n+warning: thread support is experimental.\n "}, {"sha": "b01247aea4e0eab803382c49bad5c4cd1ee2c35e", "filename": "tests/run-pass/concurrency/tls_lib_drop.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -1,2 +1,2 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n+warning: thread support is experimental.\n "}, {"sha": "b01247aea4e0eab803382c49bad5c4cd1ee2c35e", "filename": "tests/run-pass/libc.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Flibc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Flibc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -1,2 +1,2 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n+warning: thread support is experimental.\n "}, {"sha": "ca6031e57b402a608ea8b0370cd63539989105ed", "filename": "tests/run-pass/panic/concurrent-panic.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed32b260f9243b1ebb08c033acd3d5079407a309/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.stderr?ref=ed32b260f9243b1ebb08c033acd3d5079407a309", "patch": "@@ -1,4 +1,4 @@\n-warning: thread support is experimental. For example, Miri does not detect data races yet.\n+warning: thread support is experimental.\n \n Thread 1 starting, will block on mutex\n Thread 1 reported it has started"}]}