{"sha": "2ea38750e92e199654968aa4dbb3462de71f7b50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYTM4NzUwZTkyZTE5OTY1NDk2OGFhNGRiYjM0NjJkZTcxZjdiNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T13:21:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T13:21:58Z"}, "message": "auto merge of #19617 : nikomatsakis/rust/issue-19261-2, r=nrc\n\n**First commit.** Patch up debruijn indices. Fixes #19537. \r\n\r\n**Second commit.** Stop reborrowing so much. Fixes #19147. Fixes #19261.\r\n\r\nr? @nick29581", "tree": {"sha": "878188cc3b519728eace80d24763ca14a11e577a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/878188cc3b519728eace80d24763ca14a11e577a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea38750e92e199654968aa4dbb3462de71f7b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea38750e92e199654968aa4dbb3462de71f7b50", "html_url": "https://github.com/rust-lang/rust/commit/2ea38750e92e199654968aa4dbb3462de71f7b50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea38750e92e199654968aa4dbb3462de71f7b50/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2e2bd1b442948d4754bb1eb09ff1914a83604dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e2bd1b442948d4754bb1eb09ff1914a83604dd", "html_url": "https://github.com/rust-lang/rust/commit/d2e2bd1b442948d4754bb1eb09ff1914a83604dd"}, {"sha": "061a87e5194cde49b5501323ff5ca7ca5a172441", "url": "https://api.github.com/repos/rust-lang/rust/commits/061a87e5194cde49b5501323ff5ca7ca5a172441", "html_url": "https://github.com/rust-lang/rust/commit/061a87e5194cde49b5501323ff5ca7ca5a172441"}], "stats": {"total": 187, "additions": 164, "deletions": 23}, "files": [{"sha": "edcc8edaf7f92da65d59af8a933bbc154edad27f", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -535,10 +535,10 @@ impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n     /// Copies the value into a new location. This function always preserves the existing datum as\n     /// a valid value. Therefore, it does not consume `self` and, also, cannot be applied to affine\n     /// values (since they must never be duplicated).\n-    pub fn shallow_copy<'blk, 'tcx>(&self,\n-                                    bcx: Block<'blk, 'tcx>,\n-                                    dst: ValueRef)\n-                                    -> Block<'blk, 'tcx> {\n+    pub fn shallow_copy<'blk>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              dst: ValueRef)\n+                              -> Block<'blk, 'tcx> {\n         /*!\n          * Copies the value into a new location. This function always\n          * preserves the existing datum as a valid value. Therefore,"}, {"sha": "790d882f836f5b8230173673db6bdfa020015138", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -54,6 +54,7 @@ use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty::{mod, Ty};\n+use middle::ty_fold;\n use rscope::{mod, UnelidableRscope, RegionScope, SpecificRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n@@ -1062,7 +1063,8 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                            opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n                            decl: &ast::FnDecl)\n                            -> (ty::BareFnTy<'tcx>,\n-                               Option<ty::ExplicitSelfCategory>) {\n+                               Option<ty::ExplicitSelfCategory>)\n+{\n     debug!(\"ty_of_method_or_bare_fn\");\n \n     // New region names that appear inside of the arguments of the function\n@@ -1078,6 +1080,11 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     let (self_ty, mut implied_output_region) = match opt_self_info {\n         None => (None, None),\n         Some(self_info) => {\n+            // Shift regions in the self type by 1 to account for the binding\n+            // level introduced by the function itself.\n+            let untransformed_self_ty =\n+                ty_fold::shift_regions(this.tcx(), 1, &self_info.untransformed_self_ty);\n+\n             // Figure out and record the explicit self category.\n             let explicit_self_category =\n                 determine_explicit_self_category(this, &rb, &self_info);\n@@ -1087,21 +1094,19 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                     (None, None)\n                 }\n                 ty::ByValueExplicitSelfCategory => {\n-                    (Some(self_info.untransformed_self_ty), None)\n+                    (Some(untransformed_self_ty), None)\n                 }\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n                     (Some(ty::mk_rptr(this.tcx(),\n                                       region,\n                                       ty::mt {\n-                                        ty: self_info.untransformed_self_ty,\n+                                        ty: untransformed_self_ty,\n                                         mutbl: mutability\n                                       })),\n                      Some(region))\n                 }\n                 ty::ByBoxExplicitSelfCategory => {\n-                    (Some(ty::mk_uniq(this.tcx(),\n-                                      self_info.untransformed_self_ty)),\n-                     None)\n+                    (Some(ty::mk_uniq(this.tcx(), untransformed_self_ty)), None)\n                 }\n             }\n         }"}, {"sha": "53bda93b28e0216607050d38b188a9b7c3b6c091", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -100,6 +100,7 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            call_expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n+    let self_ty = fcx.infcx().resolve_type_vars_if_possible(self_ty);\n     let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr.id));\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }"}, {"sha": "18ab4f79b0b9a81830aa031cf01dae1e11bf7878", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -168,7 +168,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         check::autoderef(\n             fcx, span, self_ty, None, NoPreference,\n             |t, d| {\n-                let adjustment = consider_reborrow(t, d);\n+                let adjustment = AutoDeref(d);\n                 steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n                 None::<()> // keep iterating until we can't anymore\n             });\n@@ -185,14 +185,6 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     return steps;\n-\n-    fn consider_reborrow(ty: Ty, d: uint) -> PickAdjustment {\n-        // Insert a `&*` or `&mut *` if this is a reference type:\n-        match ty.sty {\n-            ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n-            _ => AutoDeref(d),\n-        }\n-    }\n }\n \n impl<'a,'tcx> ProbeContext<'a,'tcx> {\n@@ -626,7 +618,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return None;\n         }\n \n-        match self.pick_adjusted_method(step) {\n+        match self.pick_by_value_method(step) {\n             Some(result) => return Some(result),\n             None => {}\n         }\n@@ -644,11 +636,34 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn pick_adjusted_method(&mut self,\n+    fn pick_by_value_method(&mut self,\n                             step: &CandidateStep<'tcx>)\n                             -> Option<PickResult<'tcx>>\n     {\n-        self.pick_method(step.self_ty).map(|r| self.adjust(r, step.adjustment.clone()))\n+        /*!\n+         * For each type `T` in the step list, this attempts to find a\n+         * method where the (transformed) self type is exactly `T`. We\n+         * do however do one transformation on the adjustment: if we\n+         * are passing a region pointer in, we will potentially\n+         * *reborrow* it to a shorter lifetime. This allows us to\n+         * transparently pass `&mut` pointers, in particular, without\n+         * consuming them for their entire lifetime.\n+         */\n+\n+        let adjustment = match step.adjustment {\n+            AutoDeref(d) => consider_reborrow(step.self_ty, d),\n+            AutoUnsizeLength(..) | AutoRef(..) => step.adjustment.clone(),\n+        };\n+\n+        return self.pick_method(step.self_ty).map(|r| self.adjust(r, adjustment.clone()));\n+\n+        fn consider_reborrow(ty: Ty, d: uint) -> PickAdjustment {\n+            // Insert a `&*` or `&mut *` if this is a reference type:\n+            match ty.sty {\n+                ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n+                _ => AutoDeref(d),\n+            }\n+        }\n     }\n \n     fn pick_autorefd_method(&mut self,"}, {"sha": "4ad6dc292a72dea910aa223402e0e04331d8bb64", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -1055,7 +1055,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n-            let ty_generics = ty_generics_for_type(\n+            let ty_generics = ty_generics_for_impl(\n                     ccx,\n                     generics,\n                     CreateTypeParametersForAssociatedTypes);\n@@ -1655,6 +1655,24 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     generics\n }\n \n+fn ty_generics_for_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                  generics: &ast::Generics,\n+                                  create_type_parameters_for_associated_types:\n+                                      CreateTypeParametersForAssociatedTypesFlag)\n+                                  -> ty::Generics<'tcx>\n+{\n+    let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n+    debug!(\"ty_generics_for_impl: early_lifetimes={}\",\n+           early_lifetimes);\n+    ty_generics(ccx,\n+                subst::TypeSpace,\n+                early_lifetimes.as_slice(),\n+                generics.ty_params.as_slice(),\n+                ty::Generics::empty(),\n+                &generics.where_clause,\n+                create_type_parameters_for_associated_types)\n+}\n+\n fn ty_generics_for_fn_or_method<'tcx,AC>(\n         this: &AC,\n         generics: &ast::Generics,"}, {"sha": "7529943f0bc5947b40ef75099a898db5cc0b419c", "filename": "src/test/compile-fail/borrowck-return-variable-on-stack-via-clone.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Ftest%2Fcompile-fail%2Fborrowck-return-variable-on-stack-via-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Ftest%2Fcompile-fail%2Fborrowck-return-variable-on-stack-via-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-return-variable-on-stack-via-clone.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that when we clone a `&T` pointer we properly relate the\n+// lifetime of the pointer which results to the pointer being cloned.\n+// Bugs in method resolution have sometimes broken this connection.\n+// Issue #19261.\n+\n+fn leak<'a, T>(x: T) -> &'a T {\n+    (&x).clone() //~ ERROR `x` does not live long enough\n+}\n+\n+fn main() { }"}, {"sha": "2dbd16107b0d5ddf9ef10da2f1116872bdd8335d", "filename": "src/test/compile-fail/hrtb-debruijn-in-receiver.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Ftest%2Fcompile-fail%2Fhrtb-debruijn-in-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Ftest%2Fcompile-fail%2Fhrtb-debruijn-in-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-debruijn-in-receiver.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test the case where the `Self` type has a bound lifetime that must\n+// be adjusted in the fn signature. Issue #19537.\n+\n+use std::collections::HashMap;\n+\n+struct Foo<'a> {\n+    map: HashMap<uint, &'a str>\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn new() -> Foo<'a> { panic!() }\n+    fn insert(&'a mut self) { }\n+}\n+fn main() {\n+    let mut foo = Foo::new();\n+    foo.insert();\n+    foo.insert(); //~ ERROR cannot borrow\n+}"}, {"sha": "00319d57f8da64e5cb16cc6c1ce30e559876066e", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea38750e92e199654968aa4dbb3462de71f7b50/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=2ea38750e92e199654968aa4dbb3462de71f7b50", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that an `&mut self` method, when invoked on an lvalue whose\n+// type is `&mut [u8]`, passes in a pointer to the lvalue and not a\n+// temporary. Issue #19147.\n+\n+use std::raw;\n+use std::mem;\n+use std::slice;\n+use std::io::IoResult;\n+\n+trait MyWriter {\n+    fn my_write(&mut self, buf: &[u8]) -> IoResult<()>;\n+}\n+\n+impl<'a> MyWriter for &'a mut [u8] {\n+    fn my_write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        slice::bytes::copy_memory(*self, buf);\n+\n+        let write_len = buf.len();\n+        unsafe {\n+            *self = mem::transmute(raw::Slice {\n+                data: self.as_ptr().offset(write_len as int),\n+                len: self.len() - write_len,\n+            });\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+fn main() {\n+    let mut buf = [0_u8, .. 6];\n+\n+    {\n+        let mut writer = buf.as_mut_slice();\n+        writer.my_write(&[0, 1, 2]).unwrap();\n+        writer.my_write(&[3, 4, 5]).unwrap();\n+    }\n+\n+    // If `my_write` is not modifying `buf` in place, then we will\n+    // wind up with `[3, 4, 5, 0, 0, 0]` because the first call to\n+    // `my_write()` doesn't update the starting point for the write.\n+\n+    assert_eq!(buf, [0, 1, 2, 3, 4, 5]);\n+}"}]}