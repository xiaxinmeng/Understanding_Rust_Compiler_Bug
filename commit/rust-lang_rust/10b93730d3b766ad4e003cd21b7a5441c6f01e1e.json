{"sha": "10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYjkzNzMwZDNiNzY2YWQ0ZTAwM2NkMjFiN2E1NDQxYzZmMDFlMWU=", "commit": {"author": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-11-09T09:42:45Z"}, "committer": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-11-09T09:42:45Z"}, "message": "Fix merge conflicts", "tree": {"sha": "91b8f66e8c60be235caada833c0dcf477abc42e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91b8f66e8c60be235caada833c0dcf477abc42e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "html_url": "https://github.com/rust-lang/rust/commit/10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef", "html_url": "https://github.com/rust-lang/rust/commit/4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef"}, {"sha": "8355437d5d0e747b7e7239cd0a2af8a3825bd912", "url": "https://api.github.com/repos/rust-lang/rust/commits/8355437d5d0e747b7e7239cd0a2af8a3825bd912", "html_url": "https://github.com/rust-lang/rust/commit/8355437d5d0e747b7e7239cd0a2af8a3825bd912"}], "stats": {"total": 618, "additions": 391, "deletions": 227}, "files": [{"sha": "b9e112aa08608bf9e8708757c6e92cc9598c750f", "filename": ".appveyor.yml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/.appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/.appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.appveyor.yml?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -28,11 +28,12 @@ install:\n     - set PATH=%USERPROFILE%\\.cargo\\bin;%PATH%\n     - rustup default stable\n     - rustup uninstall beta\n-    - rustup component remove rust-docs & exit 0\n     - rustup update\n     # Install \"master\" toolchain\n     - cargo install rustup-toolchain-install-master & exit 0\n-    - rustup-toolchain-install-master -f -n master %RUSTC_HASH% -c cargo -c rust-src\n+    # We need to install cargo here as well or else the DLL search path inside `cargo run`\n+    # will be for the wrong toolchain. (On Unix, `./miri` takes care of this, but not here.)\n+    - rustup-toolchain-install-master -f -n master %RUSTC_HASH% -c rust-src -c rustc-dev -c cargo\n     - rustup default master\n     - rustc --version\n     - cargo --version"}, {"sha": "a080ab55b94f2326d2aef074e8b26c183dbe84fb", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -35,11 +35,10 @@ before_script:\n - export PATH=$HOME/.cargo/bin:$PATH\n - rustup default stable\n - rustup uninstall beta\n-- rustup component remove rust-docs || echo \"rust-docs already gone\"\n - rustup update\n # Install \"master\" toolchain\n - cargo install rustup-toolchain-install-master || echo \"rustup-toolchain-install-master already installed\"\n-- travis_retry rustup-toolchain-install-master -f -n master $RUSTC_HASH -c rust-src\n+- travis_retry rustup-toolchain-install-master -f -n master $RUSTC_HASH -c rust-src -c rustc-dev\n - rustup default master\n - rustc --version\n - cargo --version"}, {"sha": "d6436873938ed604fd25176f9674ea77a3120020", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -31,8 +31,10 @@ Miri heavily relies on internal rustc interfaces to execute MIR.  Still, some\n things (like adding support for a new intrinsic or a shim for an external\n function being called) can be done by working just on the Miri side.\n \n-To prepare, make sure you are using a nightly Rust compiler.  Then you should be\n-able to just `cargo build` Miri.\n+To prepare, make sure you are using a nightly Rust compiler.  You also need to\n+have the `rust-src` and `rustc-dev` components installed, which you can add via\n+`rustup component add rust-src rustc-dev`.  Then you should be able to just\n+`cargo build` Miri.\n \n In case this fails, your nightly might be incompatible with Miri master.  The\n `rust-version` file contains the commit hash of rustc that Miri is currently\n@@ -41,7 +43,7 @@ to wait for the next nightly to get released. You can also use\n [`rustup-toolchain-install-master`](https://github.com/kennytm/rustup-toolchain-install-master)\n to install that exact version of rustc as a toolchain:\n ```\n-rustup-toolchain-install-master $(cat rust-version) -c rust-src\n+rustup-toolchain-install-master $(cat rust-version) -c rust-src -c rustc-dev\n ```\n \n Another common problem is outdated dependencies: Miri does not come with a"}, {"sha": "fb7ab619281f5d064e076816d1e25981ee2d2522", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -98,7 +98,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.8.2\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -216,7 +216,7 @@ dependencies = [\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.6.2\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"atty 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -282,7 +282,7 @@ dependencies = [\n \n [[package]]\n name = \"hex\"\n-version = \"0.3.2\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -335,13 +335,13 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cargo_metadata 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"colored 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiletest_rs 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"directories 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getrandom 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hex 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -783,7 +783,7 @@ dependencies = [\n \"checksum blake2b_simd 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5850aeee1552f495dd0250014cf64b82b7c8879a89d83b33bbdace2cc4f63182\"\n \"checksum byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5\"\n \"checksum c2-chacha 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"214238caa1bf3a496ec3392968969cab8549f96ff30652c9e56885329315f6bb\"\n-\"checksum cargo_metadata 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"700b3731fd7d357223d0000f4dbf1808401b694609035c3c411fbc0cd375c426\"\n+\"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n \"checksum cc 1.0.46 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0213d356d3c4ea2c18c40b037c3be23cd639825c18f25ee670ac7813beeef99c\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \"checksum cgmath 0.16.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64a4b57c8f4e3a2e9ac07e0f6abc9c24b6fc9e1b54c3478cfb598f3d0023e51c\"\n@@ -796,14 +796,14 @@ dependencies = [\n \"checksum diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a\"\n \"checksum directories 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"551a778172a450d7fc12e629ca3b0428d00f6afa9a43da1b630d54604e97371c\"\n \"checksum dirs-sys 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afa0b23de8fd801745c471deffa6e12d248f962c9fd4b4c33787b055599bde7b\"\n-\"checksum env_logger 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aafcde04e90a5226a6443b7aabdb016ba2f8307c847d524724bd9b346dd1a2d3\"\n+\"checksum env_logger 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44533bbbb3bb3c1fa17d9f2e4e38bbbaf8396ba82193c4cb1b6445d711445d36\"\n \"checksum failure 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8273f13c977665c5db7eb2b99ae520952fe5ac831ae4cd09d80c4c7042b5ed9\"\n \"checksum failure_derive 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0bc225b78e0391e4b8683440bf2e63c2deeeb2ce5189eab46e2b68c6d3725d08\"\n \"checksum filetime 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6bd7380b54ced79dda72ecc35cc4fbbd1da6bba54afaa37e96fd1c2a308cd469\"\n \"checksum fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba\"\n \"checksum getopts 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n \"checksum getrandom 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n-\"checksum hex 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n+\"checksum hex 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"023b39be39e3a2da62a94feb433e91e8bcd37676fbc8bea371daf52b7a769a3e\"\n \"checksum humantime 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f\"\n \"checksum itoa 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"501266b7edd0174f8530248f87f99c88fbe60ca4ef3dd486835b8d8d53136f7f\"\n \"checksum lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\""}, {"sha": "ba31dd848ab41298982d7e58aefd10c1377dddee", "filename": "Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -30,15 +30,15 @@ doctest = false # and no doc tests\n required-features = [\"rustc_tests\"]\n \n [dependencies]\n-cargo_metadata = { version = \"0.8\", optional = true }\n+cargo_metadata = { version = \"0.9.0\", optional = true }\n directories = { version = \"2.0\", optional = true }\n rustc_version = { version = \"0.2.3\", optional = true }\n getrandom = { version = \"0.1.8\", features = [\"std\"] }\n byteorder = \"1.3\"\n-env_logger = \"0.6\"\n+env_logger = \"0.7.1\"\n log = \"0.4\"\n shell-escape = \"0.1.4\"\n-hex = \"0.3.2\"\n+hex = \"0.4.0\"\n rand = \"0.7\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack."}, {"sha": "ec45e1f973071457e966dddad355fda78db34c99", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -1 +1 @@\n-55e00631e5bc5b16d40232914e57deeea197a8e4\n+9e346646e93cc243567e27bb0f4e8716d56ad1f1"}, {"sha": "36545766d101d94e2351b4a760e46e72e7fcf55f", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -6,6 +6,8 @@ use std::path::{PathBuf, Path};\n use std::process::Command;\n use std::ops::Not;\n \n+const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 17);\n+\n const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n \n Usage:\n@@ -258,7 +260,7 @@ fn setup(ask_user: bool) {\n     }\n \n     // First, we need xargo.\n-    if xargo_version().map_or(true, |v| v < (0, 3, 16)) {\n+    if xargo_version().map_or(true, |v| v < XARGO_MIN_VERSION) {\n         if std::env::var(\"XARGO\").is_ok() {\n             // The user manually gave us a xargo binary; don't do anything automatically.\n             show_error(format!(\"Your xargo is too old; please upgrade to the latest version\"))"}, {"sha": "b09fb5918c874755720e66e0f5fdf327d1cba622", "filename": "src/eval.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -4,12 +4,12 @@ use rand::rngs::StdRng;\n use rand::SeedableRng;\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::layout::{Align, LayoutOf, Size};\n+use rustc::ty::layout::{LayoutOf, Size};\n use rustc::ty::{self, TyCtxt};\n use syntax::source_map::DUMMY_SP;\n \n use crate::{\n-    struct_error, EnvVars, Evaluator, FnVal, HelpersEvalContextExt, InterpCx, InterpError,\n+    EnvVars, Evaluator, FnVal, HelpersEvalContextExt, InterpCx, InterpError,\n     InterpResult, MemoryExtra, MiriMemoryKind, Pointer, Scalar, StackPopCleanup, Tag,\n     TlsEvalContextExt,\n };\n@@ -48,7 +48,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     EnvVars::init(&mut ecx, config.excluded_env_vars);\n \n     // Setup first stack-frame\n-    let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n+    let main_instance = ty::Instance::mono(tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def, None)?;\n \n     if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n@@ -59,11 +59,10 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let main_ret_ty = tcx.fn_sig(main_id).output();\n     let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n     let start_instance = ty::Instance::resolve(\n-        ecx.tcx.tcx,\n+        tcx,\n         ty::ParamEnv::reveal_all(),\n         start_id,\n-        ecx.tcx\n-            .mk_substs(::std::iter::once(ty::subst::GenericArg::from(main_ret_ty))),\n+        tcx.mk_substs(::std::iter::once(ty::subst::GenericArg::from(main_ret_ty))),\n     )\n     .unwrap();\n     let start_mir = ecx.load_mir(start_instance.def, None)?;\n@@ -106,7 +105,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     {\n         let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argc, argc_place.into())?;\n-        ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n+        ecx.machine.argc = Some(argc_place.ptr);\n     }\n \n     // Third argument (`argv`): created from `config.args`.\n@@ -134,8 +133,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     }\n     // Make an array with all these pointers, in the Miri memory.\n     let argvs_layout = ecx.layout_of(\n-        ecx.tcx\n-            .mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64),\n+        tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), argvs.len() as u64),\n     )?;\n     let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n     for (idx, arg) in argvs.into_iter().enumerate() {\n@@ -151,36 +149,26 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     {\n         let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argv, argv_place.into())?;\n-        ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n+        ecx.machine.argv = Some(argv_place.ptr);\n     }\n     // Store command line as UTF-16 for Windows `GetCommandLineW`.\n     {\n         let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n-        let cmd_ptr = ecx.memory.allocate(\n-            Size::from_bytes(cmd_utf16.len() as u64 * 2),\n-            Align::from_bytes(2).unwrap(),\n-            MiriMemoryKind::Env.into(),\n-        );\n-        ecx.machine.cmd_line = Some(cmd_ptr);\n+        let cmd_type = tcx.mk_array(tcx.types.u16, cmd_utf16.len() as u64);\n+        let cmd_place = ecx.allocate(ecx.layout_of(cmd_type)?, MiriMemoryKind::Env.into());\n+        ecx.machine.cmd_line = Some(cmd_place.ptr);\n         // Store the UTF-16 string. We just allocated so we know the bounds are fine.\n         let char_size = Size::from_bytes(2);\n-        let cmd_alloc = ecx.memory.get_mut(cmd_ptr.alloc_id)?;\n-        let mut cur_ptr = cmd_ptr;\n-        for &c in cmd_utf16.iter() {\n-            cmd_alloc.write_scalar(\n-                &*ecx.tcx,\n-                cur_ptr,\n-                Scalar::from_uint(c, char_size).into(),\n-                char_size,\n-            )?;\n-            cur_ptr = cur_ptr.offset(char_size, &*ecx.tcx)?;\n+        for (idx, &c) in cmd_utf16.iter().enumerate() {\n+            let place = ecx.mplace_field(cmd_place, idx as u64)?;\n+            ecx.write_scalar(Scalar::from_uint(c, char_size), place.into())?;\n         }\n     }\n \n     args.next().expect_none(\"start lang item has more arguments than expected\");\n \n     // Set the last_error to 0\n-    let errno_layout = ecx.layout_of(ecx.tcx.types.u32)?;\n+    let errno_layout = ecx.layout_of(tcx.types.u32)?;\n     let errno_place = ecx.allocate(errno_layout, MiriMemoryKind::Static.into());\n     ecx.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n     ecx.machine.last_error = Some(errno_place);\n@@ -233,7 +221,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) {\n                 };\n \n                 let msg = format!(\"Miri evaluation error: {}\", msg);\n-                let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n+                let mut err = ecx.tcx.sess.struct_span_err(span, msg.as_str());\n                 let frames = ecx.generate_stacktrace(None);\n                 err.span_label(span, msg);\n                 // We iterate with indices because we need to look at the next frame (the caller)."}, {"sha": "ae117d5fb352f2bb63e51e8ac888ef4cf350269b", "filename": "src/helpers.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -5,6 +5,7 @@ use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use rustc::ty::{\n     self,\n+    List,\n     layout::{self, LayoutOf, Size, TyLayout},\n };\n \n@@ -75,7 +76,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Get the `Place` for a local\n     fn local_place(&mut self, local: mir::Local) -> InterpResult<'tcx, PlaceTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n-        let place = mir::Place { base: mir::PlaceBase::Local(local), projection: Box::new([]) };\n+        let place = mir::Place { base: mir::PlaceBase::Local(local), projection: List::empty() };\n         this.eval_place(&place)\n     }\n "}, {"sha": "a55c58c13add7834f7425a6eef894f22e88114cb", "filename": "src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -63,7 +63,7 @@ impl<'mir, 'tcx> GlobalState {\n                 // This never overflows because `int >= glb`\n                 let offset = int - glb;\n                 // If the offset exceeds the size of the allocation, this access is illegal\n-                if offset <= memory.get(alloc_id)?.size.bytes() {\n+                if offset <= memory.get_size_and_align(alloc_id, AllocCheck::MaybeDead)?.0.bytes() {\n                     // This pointer is untagged because it was created from a cast\n                     Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged)\n                 } else {"}, {"sha": "c76cc2e568f4f35465a014534b444c41344c8cad", "filename": "src/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -14,8 +14,7 @@ use rustc::ty::{\n     layout::{LayoutOf, Size},\n     Ty, TyCtxt,\n };\n-use syntax::attr;\n-use syntax::symbol::sym;\n+use syntax::{attr, source_map::Span, symbol::sym};\n \n use crate::*;\n \n@@ -87,9 +86,9 @@ pub struct Evaluator<'tcx> {\n     /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n     /// These are *pointers* to argc/argv because macOS.\n     /// We also need the full command line as one string because of Windows.\n-    pub(crate) argc: Option<Pointer<Tag>>,\n-    pub(crate) argv: Option<Pointer<Tag>>,\n-    pub(crate) cmd_line: Option<Pointer<Tag>>,\n+    pub(crate) argc: Option<Scalar<Tag>>,\n+    pub(crate) argv: Option<Scalar<Tag>>,\n+    pub(crate) cmd_line: Option<Scalar<Tag>>,\n \n     /// Last OS error location in memory. It is a 32-bit integer.\n     pub(crate) last_error: Option<MPlaceTy<'tcx, Tag>>,\n@@ -192,11 +191,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn call_intrinsic(\n         ecx: &mut rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        ecx.call_intrinsic(instance, args, dest)\n+        ecx.call_intrinsic(span, instance, args, dest)\n     }\n \n     #[inline(always)]"}, {"sha": "6b2c12e6b0b0451d0ce6cf52c1a02525b2dd1f07", "filename": "src/operator.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -1,16 +1,11 @@\n use std::convert::TryFrom;\n \n-use rustc::ty::{Ty, layout::LayoutOf};\n+use rustc::ty::{Ty, layout::{Size, LayoutOf}};\n use rustc::mir;\n \n use crate::*;\n \n pub trait EvalContextExt<'tcx> {\n-    fn pointer_inbounds(\n-        &self,\n-        ptr: Pointer<Tag>\n-    ) -> InterpResult<'tcx>;\n-\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -33,13 +28,6 @@ pub trait EvalContextExt<'tcx> {\n }\n \n impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n-    /// Test if the pointer is in-bounds of a live allocation.\n-    #[inline]\n-    fn pointer_inbounds(&self, ptr: Pointer<Tag>) -> InterpResult<'tcx> {\n-        let (size, _align) = self.memory.get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n-        ptr.check_inbounds_alloc(size, CheckInAllocMsg::InboundsTest)\n-    }\n-\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -87,7 +75,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 let ptr = self.pointer_offset_inbounds(\n                     left.to_scalar()?,\n                     pointee_ty,\n-                    right.to_scalar()?.to_isize(self)?,\n+                    right.to_scalar()?.to_machine_isize(self)?,\n                 )?;\n                 (ptr, false, left.layout.ty)\n             }\n@@ -110,9 +98,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n     }\n \n     /// Raises an error if the offset moves the pointer outside of its allocation.\n-    /// We consider ZSTs their own huge allocation that doesn't overlap with anything (and nothing\n-    /// moves in there because the size is 0). We also consider the NULL pointer its own separate\n-    /// allocation, and all the remaining integers pointers their own allocation.\n+    /// For integers, we consider each of them their own tiny allocation of size 0,\n+    /// so offset-by-0 is okay for them -- except for NULL, which we rule out entirely.\n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar<Tag>,\n@@ -123,25 +110,24 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         let offset = offset\n             .checked_mul(pointee_size)\n             .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n-        // Now let's see what kind of pointer this is.\n-        let ptr = if offset == 0 {\n-            match ptr {\n-                Scalar::Ptr(ptr) => ptr,\n-                Scalar::Raw { .. } => {\n-                    // Offset 0 on an integer. We accept that, pretending there is\n-                    // a little zero-sized allocation here.\n-                    return Ok(ptr);\n-                }\n-            }\n+        // We do this first, to rule out overflows.\n+        let offset_ptr = ptr.ptr_signed_offset(offset, self)?;\n+        // What we need to check is that starting at `min(ptr, offset_ptr)`,\n+        // we could do an access of size `abs(offset)`. Alignment does not matter.\n+        let (min_ptr, abs_offset) = if offset >= 0 {\n+            (ptr, u64::try_from(offset).unwrap())\n         } else {\n-            // Offset > 0. We *require* a pointer.\n-            self.force_ptr(ptr)?\n+            // Negative offset.\n+            // If the negation overflows, the result will be negative so the try_from will fail.\n+            (offset_ptr, u64::try_from(-offset).unwrap())\n         };\n-        // Both old and new pointer must be in-bounds of a *live* allocation.\n-        // (Of the same allocation, but that part is trivial with our representation.)\n-        self.pointer_inbounds(ptr)?;\n-        let ptr = ptr.signed_offset(offset, self)?;\n-        self.pointer_inbounds(ptr)?;\n-        Ok(Scalar::Ptr(ptr))\n+        self.memory.check_ptr_access_align(\n+            min_ptr,\n+            Size::from_bytes(abs_offset),\n+            None,\n+            CheckInAllocMsg::InboundsTest,\n+        )?;\n+        // That's it!\n+        Ok(offset_ptr)\n     }\n }"}, {"sha": "ca53f5d23015a6f94bb526fbe2348fed9b45a3cb", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -40,7 +40,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match dlsym {\n             GetEntropy => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 this.gen_random(ptr, len as usize)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "44896fd9bbd563a22d33293fa7058f9a517e3e4e", "filename": "src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -124,7 +124,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.check_no_isolation(\"getcwd\")?;\n \n         let buf = this.read_scalar(buf_op)?.not_undef()?;\n-        let size = this.read_scalar(size_op)?.to_usize(&*this.tcx)?;\n+        let size = this.read_scalar(size_op)?.to_machine_usize(&*this.tcx)?;\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {"}, {"sha": "1f43a83576f62da0a215f54ad5cb53fb4bb85f53", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -144,13 +144,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ret = ret.expect(\"dest is `Some` but ret is `None`\");\n         match link_name {\n             \"malloc\" => {\n-                let size = this.read_scalar(args[0])?.to_usize(this)?;\n+                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n-                let items = this.read_scalar(args[0])?.to_usize(this)?;\n-                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                let items = this.read_scalar(args[0])?.to_machine_usize(this)?;\n+                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 let size = items\n                     .checked_mul(len)\n                     .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n@@ -159,8 +159,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"posix_memalign\" => {\n                 let ret = this.deref_operand(args[0])?;\n-                let align = this.read_scalar(args[1])?.to_usize(this)?;\n-                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 if !align.is_power_of_two() {\n                     throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n@@ -190,14 +190,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n+                let new_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_scalar(res, dest)?;\n             }\n \n             \"__rust_alloc\" => {\n-                let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                let align = this.read_scalar(args[1])?.to_usize(this)?;\n+                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 if size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -212,8 +212,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n-                let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                let align = this.read_scalar(args[1])?.to_usize(this)?;\n+                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 if size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -233,8 +233,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_dealloc\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let old_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let align = this.read_scalar(args[2])?.to_usize(this)?;\n+                let old_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 if old_size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -253,9 +253,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_realloc\" => {\n                 let ptr = this.read_scalar(args[0])?.to_ptr()?;\n-                let old_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let align = this.read_scalar(args[2])?.to_usize(this)?;\n-                let new_size = this.read_scalar(args[3])?.to_usize(this)?;\n+                let old_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let align = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let new_size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n                 if old_size == 0 || new_size == 0 {\n                     throw_unsup!(HeapAllocZeroBytes);\n                 }\n@@ -277,11 +277,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let sys_getrandom = this\n                     .eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n                     .expect(\"Failed to get libc::SYS_getrandom\")\n-                    .to_usize(this)?;\n+                    .to_machine_usize(this)?;\n \n                 // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                 // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n-                match this.read_scalar(args[0])?.to_usize(this)? {\n+                match this.read_scalar(args[0])?.to_machine_usize(this)? {\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id,\n                         // so skip over it.\n@@ -357,7 +357,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"memcmp\" => {\n                 let left = this.read_scalar(args[0])?.not_undef()?;\n                 let right = this.read_scalar(args[1])?.not_undef()?;\n-                let n = Size::from_bytes(this.read_scalar(args[2])?.to_usize(this)?);\n+                let n = Size::from_bytes(this.read_scalar(args[2])?.to_machine_usize(this)?);\n \n                 let result = {\n                     let left_bytes = this.memory.read_bytes(left, n)?;\n@@ -377,7 +377,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"memrchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n-                let num = this.read_scalar(args[2])?.to_usize(this)?;\n+                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 if let Some(idx) = this\n                     .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n@@ -395,7 +395,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"memchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n-                let num = this.read_scalar(args[2])?.to_usize(this)?;\n+                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let idx = this\n                     .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n@@ -462,7 +462,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"write\" => {\n                 let fd = this.read_scalar(args[0])?.to_i32()?;\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n-                let n = this.read_scalar(args[2])?.to_usize(tcx)?;\n+                let n = this.read_scalar(args[2])?.to_machine_usize(tcx)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n@@ -765,13 +765,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // FIXME: register the destructor.\n             }\n             \"_NSGetArgc\" => {\n-                this.write_scalar(Scalar::Ptr(this.machine.argc.unwrap()), dest)?;\n+                this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"_NSGetArgv\" => {\n-                this.write_scalar(Scalar::Ptr(this.machine.argv.unwrap()), dest)?;\n+                this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"SecRandomCopyBytes\" => {\n-                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 this.gen_random(ptr, len as usize)?;\n                 this.write_null(dest)?;\n@@ -786,25 +786,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n             }\n             \"HeapAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(args[1])?.to_u32()?;\n-                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n                 let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_int(1, Size::from_bytes(4)), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                let size = this.read_scalar(args[3])?.to_usize(this)?;\n+                let size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n                 let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(res, dest)?;\n             }\n@@ -883,7 +883,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n             }\n             \"WriteFile\" => {\n-                let handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n                 let n = this.read_scalar(args[2])?.to_u32()?;\n                 let written_place = this.deref_operand(args[3])?;\n@@ -927,7 +927,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"GetCommandLineW\" => {\n-                this.write_scalar(Scalar::Ptr(this.machine.cmd_line.unwrap()), dest)?;\n+                this.write_scalar(this.machine.cmd_line.expect(\"machine must be initialized\"), dest)?;\n             }\n             // The actual name of 'RtlGenRandom'\n             \"SystemFunction036\" => {\n@@ -973,7 +973,7 @@ fn linux_getrandom<'tcx>(\n     dest: PlaceTy<'tcx, Tag>,\n ) -> InterpResult<'tcx> {\n     let ptr = this.read_scalar(args[0])?.not_undef()?;\n-    let len = this.read_scalar(args[1])?.to_usize(this)?;\n+    let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n \n     // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n     // neither of which have any effect on our current PRNG."}, {"sha": "4d1b7fdf06c906acc31c232d25f54a2f38fd82cc", "filename": "src/shims/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -166,7 +166,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"read\")?;\n \n-        let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n+        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n         // Reading zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);\n@@ -211,7 +211,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"write\")?;\n \n-        let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n+        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n         // Writing zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);"}, {"sha": "7470090f5208fb7500ba6d21e5f5ddcac62bbac9", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -5,6 +5,7 @@ use rustc::mir;\n use rustc::mir::interpret::{InterpResult, PointerArithmetic};\n use rustc::ty::layout::{self, LayoutOf, Size, Align};\n use rustc::ty;\n+use syntax::source_map::Span;\n \n use crate::{\n     PlaceTy, OpTy, Immediate, Scalar, Tag,\n@@ -15,12 +16,13 @@ impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tc\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn call_intrinsic(\n         &mut self,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if this.emulate_intrinsic(instance, args, dest)? {\n+        if this.emulate_intrinsic(span, instance, args, dest)? {\n             return Ok(());\n         }\n         let tcx = &{this.tcx.tcx};\n@@ -33,7 +35,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let intrinsic_name = &*tcx.item_name(instance.def_id()).as_str();\n         match intrinsic_name {\n             \"arith_offset\" => {\n-                let offset = this.read_scalar(args[1])?.to_isize(this)?;\n+                let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n \n                 let pointee_ty = substs.type_at(0);\n@@ -204,7 +206,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let elem_ty = substs.type_at(0);\n                 let elem_layout = this.layout_of(elem_ty)?;\n                 let elem_size = elem_layout.size.bytes();\n-                let count = this.read_scalar(args[2])?.to_usize(this)?;\n+                let count = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let elem_align = elem_layout.align.abi;\n \n                 let size = Size::from_bytes(count * elem_size);\n@@ -311,23 +313,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_f64(res), dest)?;\n             }\n \n-            \"exact_div\" => {\n-                // Performs an exact division, resulting in undefined behavior where\n-                // `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n-                let a = this.read_immediate(args[0])?;\n-                let b = this.read_immediate(args[1])?;\n-                // check x % y != 0\n-                if this.overflowing_binary_op(mir::BinOp::Rem, a, b)?.0.to_bits(dest.layout.size)? != 0 {\n-                    // Check if `b` is -1, which is the \"min_value / -1\" case.\n-                    let minus1 = Scalar::from_int(-1, dest.layout.size);\n-                    return Err(if b.to_scalar().unwrap() == minus1 {\n-                        err_ub_format!(\"exact_div: result of dividing MIN by -1 cannot be represented\")\n-                    } else {\n-                        err_ub_format!(\"exact_div: {:?} cannot be divided by {:?} without remainder\", *a, *b)\n-                    }.into());\n-                }\n-                this.binop_ignore_overflow(mir::BinOp::Div, a, b, dest)?;\n-            },\n+            \"exact_div\" =>\n+                this.exact_div(\n+                    this.read_immediate(args[0])?,\n+                    this.read_immediate(args[1])?,\n+                    dest,\n+                )?,\n \n             \"forget\" => {}\n \n@@ -380,7 +371,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"offset\" => {\n-                let offset = this.read_scalar(args[1])?.to_isize(this)?;\n+                let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let result_ptr = this.pointer_offset_inbounds(ptr, substs.type_at(0), offset)?;\n                 this.write_scalar(result_ptr, dest)?;\n@@ -390,7 +381,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ty = substs.type_at(0);\n                 let layout = this.layout_of(ty)?;\n                 if layout.abi.is_uninhabited() {\n-                    throw_ub_format!(\"Trying to instantiate uninhabited type {}\", ty)\n+                    // FIXME: This should throw a panic in the interpreted program instead.\n+                    throw_unsup_format!(\"Trying to instantiate uninhabited type {}\", ty)\n                 }\n             }\n \n@@ -550,7 +542,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             let ptr = mplace.ptr.to_ptr()?;\n                             // We know the return place is in-bounds\n                             this.memory\n-                                .get_mut(ptr.alloc_id)?\n+                                .get_raw_mut(ptr.alloc_id)?\n                                 .mark_definedness(ptr, dest.layout.size, false);\n                         }\n                     }\n@@ -562,7 +554,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ty_layout = this.layout_of(ty)?;\n                 let val_byte = this.read_scalar(args[1])?.to_u8()?;\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let count = this.read_scalar(args[2])?.to_usize(this)?;\n+                let count = this.read_scalar(args[2])?.to_machine_usize(this)?;\n                 let byte_count = ty_layout.size * count;\n                 this.memory.write_bytes(ptr, iter::repeat(val_byte).take(byte_count.bytes() as usize))?;\n             }"}, {"sha": "3302143f48cbacb8aa824a7126b8ecad43f5502f", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -75,7 +75,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let ptr_scalar = this.read_scalar(ptr_op)?.not_undef()?;\n \n         if let Ok(ptr) = this.force_ptr(ptr_scalar) {\n-            let cur_align = this.memory.get(ptr.alloc_id)?.align.bytes() as usize;\n+            let cur_align = this.memory.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)?.1.bytes() as usize;\n             if cur_align >= req_align {\n                 // if the allocation alignment is at least the required alignment we use the\n                 // libcore implementation"}, {"sha": "94e69203437bfaa5058a98e89f95f3e8126c6aaf", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -241,7 +241,7 @@ impl<'tcx> Stack {\n \n     /// Find the first write-incompatible item above the given one --\n     /// i.e, find the height to which the stack will be truncated when writing to `granting`.\n-    fn find_first_write_incompaible(&self, granting: usize) -> usize {\n+    fn find_first_write_incompatible(&self, granting: usize) -> usize {\n         let perm = self.borrows[granting].perm;\n         match perm {\n             Permission::SharedReadOnly =>\n@@ -309,7 +309,7 @@ impl<'tcx> Stack {\n         if access == AccessKind::Write {\n             // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n             // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n-            let first_incompatible_idx = self.find_first_write_incompaible(granting_idx);\n+            let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n                 Stack::check_protector(&item, Some(tag), global)?;\n@@ -391,7 +391,7 @@ impl<'tcx> Stack {\n             // access.  Instead of popping the stack, we insert the item at the place the stack would\n             // be popped to (i.e., we insert it above all the write-compatible items).\n             // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n-            self.find_first_write_incompaible(granting_idx)\n+            self.find_first_write_incompatible(granting_idx)\n         } else {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n@@ -540,8 +540,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n-        let alloc = this.memory.get(ptr.alloc_id)?;\n-        let stacked_borrows = alloc.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+        let extra = &this.memory.get_raw(ptr.alloc_id)?.extra;\n+        let stacked_borrows = extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!"}, {"sha": "904bbbc6cd46bfe4391ca2498ea8a228d6916366", "filename": "test-cargo-miri/tests/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/test-cargo-miri%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/test-cargo-miri%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftests%2Ftest.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -39,5 +39,6 @@ fn entropy_rng() {\n \n #[test]\n fn num_cpus() {\n+    #[cfg(not(windows))] // FIXME: enable on Windows again once https://github.com/seanmonstar/num_cpus/pull/90 gets released.\n     assert_eq!(num_cpus::get(), 1);\n }"}, {"sha": "f4400d0d8ae2232711608f0fa6dbf87158c34d9d", "filename": "tests/compile-fail/exact_div2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fexact_div2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fexact_div2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexact_div2.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n     // divison with a remainder\n-    unsafe { std::intrinsics::exact_div(2u16, 3); } //~ ERROR Scalar(0x0002) cannot be divided by Scalar(0x0003) without remainder\n+    unsafe { std::intrinsics::exact_div(2u16, 3); } //~ ERROR 2 cannot be divided by 3 without remainder\n }"}, {"sha": "0460e412e45e225c2effcb3ed6cc5bc39c31846f", "filename": "tests/compile-fail/exact_div3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fexact_div3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fexact_div3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexact_div3.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n     // signed divison with a remainder\n-    unsafe { std::intrinsics::exact_div(-19i8, 2); } //~ ERROR Scalar(0xed) cannot be divided by Scalar(0x02) without remainder\n+    unsafe { std::intrinsics::exact_div(-19i8, 2); } //~ ERROR 237 cannot be divided by 2 without remainder\n }"}, {"sha": "96a9fb8402f689f2007cbe344fe33ae4c7b567d2", "filename": "tests/compile-fail/ptr_offset_0_plus_0.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fptr_offset_0_plus_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fptr_offset_0_plus_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_0_plus_0.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern: invalid use of NULL pointer\n+\n+fn main() {\n+    let x = 0 as *mut i32;\n+    let _x = x.wrapping_offset(8); // ok, this has no inbounds tag\n+    let _x = unsafe { x.offset(0) }; // UB despite offset 0, NULL is never inbounds\n+}"}, {"sha": "8f1e184ed22e53410e0027a05ac48cc88cf3a161", "filename": "tests/compile-fail/validity/invalid_wide_raw.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fvalidity%2Finvalid_wide_raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompile-fail%2Fvalidity%2Finvalid_wide_raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Finvalid_wide_raw.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -1,3 +1,5 @@\n+#![allow(invalid_value)]\n+\n fn main() {\n     trait T { }\n     #[derive(Debug)]"}, {"sha": "bc1ba2eda56879f52d520d6e9f5c40a981c5179a", "filename": "tests/compiletest.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -66,9 +66,8 @@ fn compile_fail(path: &str, target: &str, opt: bool) {\n \n     let mut flags = Vec::new();\n     if opt {\n-        // Optimizing too aggressivley makes UB detection harder, but test at least\n-        // the default value.\n-        // FIXME: Opt level 3 ICEs during stack trace generation.\n+        // FIXME: Opt level 2 ICEs during stack trace generation.\n+        // See https://github.com/rust-lang/rust/issues/66077.\n         flags.push(\"-Zmir-opt-level=1\".to_owned());\n     }\n "}, {"sha": "1202fd00be157a8b6176f766533ce7e3a8b71ac7", "filename": "tests/run-pass/align_offset.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Falign_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Falign_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Falign_offset.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -71,8 +71,31 @@ fn test_from_utf8() {\n     println!(\"{:?}\", std::str::from_utf8(content).unwrap());\n }\n \n+fn test_u64_array() {\n+    #[derive(Default)]\n+    #[repr(align(8))]\n+    struct AlignToU64<T>(T);\n+\n+    const BYTE_LEN: usize = std::mem::size_of::<[u64; 4]>();\n+    type Data = AlignToU64<[u8; BYTE_LEN]>;\n+\n+    fn example(data: &Data) {\n+        let (head, u64_arrays, tail) = unsafe { data.0.align_to::<[u64; 4]>() };\n+\n+        assert!(head.is_empty(), \"buffer was not aligned for 64-bit numbers\");\n+        assert_eq!(u64_arrays.len(), 1, \"buffer was not long enough\");\n+        assert!(tail.is_empty(), \"buffer was too long\");\n+\n+        let u64_array = &u64_arrays[0];\n+        let _val = u64_array[0]; // make sure we can actually load this\n+    }\n+\n+    example(&Data::default());\n+}\n+\n fn main() {\n     test_align_offset();\n     test_align_to();\n     test_from_utf8();\n+    test_u64_array();\n }"}, {"sha": "e7620cd42f7000111bd3c669887445878ef55143", "filename": "tests/run-pass/box_box_trait.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef/tests%2Frun-pass%2Fbox_box_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef/tests%2Frun-pass%2Fbox_box_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbox_box_trait.rs?ref=4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef", "patch": "@@ -1,31 +0,0 @@\n-#![feature(box_syntax)]\n-\n-struct DroppableStruct;\n-\n-static mut DROPPED: bool = false;\n-\n-impl Drop for DroppableStruct {\n-    fn drop(&mut self) {\n-        unsafe { DROPPED = true; }\n-    }\n-}\n-\n-trait MyTrait { fn dummy(&self) { } }\n-impl MyTrait for Box<DroppableStruct> {}\n-\n-#[allow(dead_code)]\n-struct Whatever { w: Box<dyn MyTrait+'static> }\n-\n-impl  Whatever {\n-    fn new(w: Box<dyn MyTrait+'static>) -> Whatever {\n-        Whatever { w: w }\n-    }\n-}\n-\n-fn main() {\n-    {\n-        let f: Box<_> = box DroppableStruct;\n-        let _a = Whatever::new(box f as Box<dyn MyTrait>);\n-    }\n-    assert!(unsafe { DROPPED });\n-}"}, {"sha": "5e2e0f87bdaff22725d5a6e794ed53318f37ddb3", "filename": "tests/run-pass/closures.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fclosures.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -40,10 +40,21 @@ fn fn_once_closure_with_multiple_args() -> i64 {\n     }\n }\n \n-fn boxed(f: Box<dyn FnOnce() -> i32>) -> i32 {\n+fn boxed_fn_once(f: Box<dyn FnOnce() -> i32>) -> i32 {\n     f()\n }\n \n+fn box_dyn() {\n+    let x: Box<dyn Fn(i32) -> i32> = Box::new(|x| x * 2);\n+    assert_eq!(x(21), 42);\n+    let mut i = 5;\n+    {\n+        let mut x: Box<dyn FnMut()> = Box::new(|| i *= 2);\n+        x(); x();\n+    }\n+    assert_eq!(i, 20);\n+}\n+\n fn fn_item_as_closure_trait_object() {\n     fn foo() {}\n     let f: &dyn Fn() = &foo;\n@@ -96,8 +107,9 @@ fn main() {\n     assert_eq!(crazy_closure(), (84, 10, 10));\n     assert_eq!(closure_arg_adjustment_problem(), 3);\n     assert_eq!(fn_once_closure_with_multiple_args(), 6);\n-    assert_eq!(boxed(Box::new({let x = 13; move || x})), 13);\n+    assert_eq!(boxed_fn_once(Box::new({let x = 13; move || x})), 13);\n \n+    box_dyn();\n     fn_item_as_closure_trait_object();\n     fn_item_with_args_as_closure_trait_object();\n     fn_item_with_multiple_args_as_closure_trait_object();"}, {"sha": "c9b59f635e14506815a4d8f410b6d5fb47f5326e", "filename": "tests/run-pass/drop_on_array_elements.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_on_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_on_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_on_array_elements.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "previous_filename": "tests/run-pass/call_drop_on_array_elements.rs"}, {"sha": "36162d320212ae6ffc7c555d3e0c694308d8ecaf", "filename": "tests/run-pass/drop_on_fat_ptr_array_elements.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_on_fat_ptr_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_on_fat_ptr_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_on_fat_ptr_array_elements.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "previous_filename": "tests/run-pass/call_drop_on_fat_ptr_array_elements.rs"}, {"sha": "1887130fdd8a4704b64990e5228e8c03ef0dd67f", "filename": "tests/run-pass/drop_on_zst_array_elements.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_on_zst_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_on_zst_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_on_zst_array_elements.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "previous_filename": "tests/run-pass/call_drop_on_zst_array_elements.rs"}, {"sha": "3ec6be65ed8b6f8bc8bb35d560a42ef3c2f0dfb5", "filename": "tests/run-pass/drop_through_owned_slice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_through_owned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_through_owned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_through_owned_slice.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "previous_filename": "tests/run-pass/call_drop_through_owned_slice.rs"}, {"sha": "97ba69c9fe2882a81ba99b92241dcd8d571c1db2", "filename": "tests/run-pass/drop_through_trait_object.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_through_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_through_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_through_trait_object.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "previous_filename": "tests/run-pass/call_drop_through_trait_object.rs"}, {"sha": "172a4580dc10548f0692f658cf0bde59fcdfffa9", "filename": "tests/run-pass/drop_through_trait_object_rc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_through_trait_object_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdrop_through_trait_object_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_through_trait_object_rc.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "previous_filename": "tests/run-pass/call_drop_through_trait_object_rc.rs"}, {"sha": "33d1f4fc1cf0caac47eb0a21da611c0d7f68b231", "filename": "tests/run-pass/dyn-traits.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdyn-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fdyn-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdyn-traits.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -0,0 +1,145 @@\n+#![feature(unsized_locals)]\n+\n+fn ref_box_dyn() {\n+    struct Struct(i32);\n+\n+    trait Trait {\n+        fn method(&self);\n+\n+        fn box_method(self: Box<Self>);\n+    }\n+\n+    impl Trait for Struct {\n+        fn method(&self) {\n+            assert_eq!(self.0, 42);\n+        }\n+\n+        fn box_method(self: Box<Self>) {\n+            assert_eq!(self.0, 7);\n+        }\n+    }\n+\n+    struct Foo<T: ?Sized>(T);\n+\n+    let y: &dyn Trait = &Struct(42);\n+    y.method();\n+\n+    let x: Foo<Struct> = Foo(Struct(42));\n+    let y: &Foo<dyn Trait> = &x;\n+    y.0.method();\n+\n+    let y: Box<dyn Trait> = Box::new(Struct(42));\n+    y.method();\n+\n+    let y = &y;\n+    y.method();\n+\n+    let y: Box<dyn Trait> = Box::new(Struct(7));\n+    y.box_method();\n+}\n+\n+\n+fn box_box_trait() {\n+    struct DroppableStruct;\n+\n+    static mut DROPPED: bool = false;\n+\n+    impl Drop for DroppableStruct {\n+        fn drop(&mut self) {\n+            unsafe { DROPPED = true; }\n+        }\n+    }\n+\n+    trait MyTrait { fn dummy(&self) { } }\n+    impl MyTrait for Box<DroppableStruct> {}\n+\n+    struct Whatever { w: Box<dyn MyTrait+'static> }\n+\n+    impl  Whatever {\n+        fn new(w: Box<dyn MyTrait+'static>) -> Whatever {\n+            Whatever { w: w }\n+        }\n+    }\n+\n+    {\n+        let f = Box::new(DroppableStruct);\n+        let a = Whatever::new(Box::new(f) as Box<dyn MyTrait>);\n+        a.w.dummy();\n+    }\n+    assert!(unsafe { DROPPED });\n+}\n+\n+fn unsized_dyn() {\n+    pub trait Foo {\n+        fn foo(self) -> String;\n+    }\n+\n+    struct A;\n+\n+    impl Foo for A {\n+        fn foo(self) -> String {\n+            format!(\"hello\")\n+        }\n+    }\n+\n+    let x = *(Box::new(A) as Box<dyn Foo>);\n+    assert_eq!(x.foo(), format!(\"hello\"));\n+\n+    // I'm not sure whether we want this to work\n+    let x = Box::new(A) as Box<dyn Foo>;\n+    assert_eq!(x.foo(), format!(\"hello\"));\n+}\n+\n+fn unsized_dyn_autoderef() {\n+    pub trait Foo {\n+        fn foo(self) -> String;\n+    }\n+\n+    impl Foo for [char] {\n+        fn foo(self) -> String {\n+            self.iter().collect()\n+        }\n+    }\n+\n+    impl Foo for str {\n+        fn foo(self) -> String {\n+            self.to_owned()\n+        }\n+    }\n+\n+    impl Foo for dyn FnMut() -> String {\n+        fn foo(mut self) -> String {\n+            self()\n+        }\n+    }\n+\n+    let x = *(Box::new(['h', 'e', 'l', 'l', 'o']) as Box<[char]>);\n+    assert_eq!(&x.foo() as &str, \"hello\");\n+\n+    let x = Box::new(['h', 'e', 'l', 'l', 'o']) as Box<[char]>;\n+    assert_eq!(&x.foo() as &str, \"hello\");\n+\n+    let x = \"hello\".to_owned().into_boxed_str();\n+    assert_eq!(&x.foo() as &str, \"hello\");\n+\n+    let x = *(\"hello\".to_owned().into_boxed_str());\n+    assert_eq!(&x.foo() as &str, \"hello\");\n+\n+    let x = \"hello\".to_owned().into_boxed_str();\n+    assert_eq!(&x.foo() as &str, \"hello\");\n+\n+    let x = *(Box::new(|| \"hello\".to_owned()) as Box<dyn FnMut() -> String>);\n+    assert_eq!(&x.foo() as &str, \"hello\");\n+\n+    let x = Box::new(|| \"hello\".to_owned()) as Box<dyn FnMut() -> String>;\n+    assert_eq!(&x.foo() as &str, \"hello\");\n+}\n+\n+fn main() {\n+    ref_box_dyn();\n+    box_box_trait();\n+\n+    // \"exotic\" receivers\n+    unsized_dyn();\n+    unsized_dyn_autoderef();\n+}"}, {"sha": "6192dd0d37e895c0cc82902817fd902ca109dcab", "filename": "tests/run-pass/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -30,7 +30,7 @@ fn iter_any() {\n     let h = |(), (), x: &u8| { 10u8 == *x };\n     h((), (), &1u8);\n \n-    [1, 2, 3u8].into_iter().any(|elt| 10 == *elt);\n+    [1, 2, 3u8].iter().any(|elt| 10 == *elt);\n }\n \n fn main() {"}, {"sha": "92eb3f6e46e3c825976d6d85db1c38c460a6339e", "filename": "tests/run-pass/ptr_offset_from.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fptr_offset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fptr_offset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_offset_from.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -0,0 +1,29 @@\n+#![feature(ptr_offset_from)]\n+\n+fn test_raw() { unsafe {\n+    let buf = [0u32; 4];\n+\n+    let x = buf.as_ptr() as *const u8;\n+    let y = x.offset(12);\n+\n+    assert_eq!(y.offset_from(x), 12);\n+    assert_eq!(x.offset_from(y), -12);\n+    assert_eq!((y as *const u32).offset_from(x as *const u32), 12/4);\n+    assert_eq!((x as *const u32).offset_from(y as *const u32), -12/4);\n+    \n+    let x = (((x as usize) * 2) / 2) as *const u8;\n+    assert_eq!(y.offset_from(x), 12);\n+    assert_eq!(x.offset_from(y), -12);\n+} }\n+\n+// This also internally uses offset_from.\n+fn test_vec_into_iter() {\n+    let v = Vec::<i32>::new();\n+    let i = v.into_iter();\n+    i.size_hint();\n+}\n+\n+fn main() {\n+    test_raw();\n+    test_vec_into_iter();\n+}"}, {"sha": "fe6a9a54d4f34ad0afeed535e887e50cda3b708e", "filename": "tests/run-pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -11,6 +11,7 @@ fn main() {\n     direct_mut_to_const_raw();\n     two_raw();\n     shr_and_raw();\n+    disjoint_mutable_subborrows();\n }\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n@@ -138,3 +139,31 @@ fn shr_and_raw() { /* unsafe {\n     *y2 += 1;\n     // TODO: Once this works, add compile-fail test that tries to read from y1 again.\n } */ }\n+\n+fn disjoint_mutable_subborrows() {\n+    struct Foo {\n+        a: String,\n+        b: Vec<u32>,\n+    }\n+\n+    unsafe fn borrow_field_a<'a>(this:*mut Foo) -> &'a mut String {\n+        &mut (*this).a\n+    }\n+\n+    unsafe fn borrow_field_b<'a>(this:*mut Foo) -> &'a mut Vec<u32> {\n+        &mut (*this).b\n+    }\n+\n+    let mut foo = Foo {\n+        a: \"hello\".into(),\n+        b: vec![0,1,2],\n+    };\n+\n+    let ptr = &mut foo as *mut Foo;\n+\n+    let a = unsafe{ borrow_field_a(ptr) };\n+    let b = unsafe{ borrow_field_b(ptr) };\n+    b.push(4);\n+    a.push_str(\" world\");\n+    dbg!(a,b);\n+}"}, {"sha": "4493d45ae157a17c81eb7b14cb82a97d3443f3e6", "filename": "tests/run-pass/stacked-borrows/stacked-borrows.stderr", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10b93730d3b766ad4e003cd21b7a5441c6f01e1e/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.stderr?ref=10b93730d3b766ad4e003cd21b7a5441c6f01e1e", "patch": "@@ -0,0 +1,7 @@\n+[$DIR/stacked-borrows.rs:168] a = \"hello world\"\n+[$DIR/stacked-borrows.rs:168] b = [\n+    0,\n+    1,\n+    2,\n+    4,\n+]"}, {"sha": "03d2db400f01368fb26bdd55a6bd088d33c53afb", "filename": "tests/run-pass/traits.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef/tests%2Frun-pass%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef/tests%2Frun-pass%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftraits.rs?ref=4bbaa72dc92ca385b2595f6a072b96f36fa4a1ef", "patch": "@@ -1,30 +0,0 @@\n-struct Struct(i32);\n-\n-trait Trait {\n-    fn method(&self);\n-}\n-\n-impl Trait for Struct {\n-    fn method(&self) {\n-        assert_eq!(self.0, 42);\n-    }\n-}\n-\n-struct Foo<T: ?Sized>(T);\n-\n-fn main() {\n-    let y: &dyn Trait = &Struct(42);\n-    y.method();\n-    let x: Foo<Struct> = Foo(Struct(42));\n-    let y: &Foo<dyn Trait> = &x;\n-    y.0.method();\n-\n-    let x: Box<dyn Fn(i32) -> i32> = Box::new(|x| x * 2);\n-    assert_eq!(x(21), 42);\n-    let mut i = 5;\n-    {\n-        let mut x: Box<dyn FnMut()> = Box::new(|| i *= 2);\n-        x(); x();\n-    }\n-    assert_eq!(i, 20);\n-}"}]}