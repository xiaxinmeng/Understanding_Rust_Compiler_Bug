{"sha": "461435adabb7ddfb4eb65109db6c2fcc191d8049", "node_id": "C_kwDOAAsO6NoAKDQ2MTQzNWFkYWJiN2RkZmI0ZWI2NTEwOWRiNmMyZmNjMTkxZDgwNDk", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-17T10:48:25Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-17T11:17:09Z"}, "message": "Enforce builtin binop expectations on single references\n\nAlso don't enforce them on non-builtin types", "tree": {"sha": "b3b3f5cfe8b62d0c47773858756d7ce4480376c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3b3f5cfe8b62d0c47773858756d7ce4480376c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/461435adabb7ddfb4eb65109db6c2fcc191d8049", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmPGg7UACgkQ4laYqTBY\nYXHr7A//XWOkWZw7PsvE1UQg4bJIsR4LdwUEgpY06gcMc/uTR0WfUdJDLX3GOC41\necDE0R5GkuU595+eUtuXBU/SQEXrnCCtA5en0EDyDhyA8YeToy8KFHsI7j9k4JTJ\n3GV5LYYUqxrPhLT5EbX/oEonhknegI5C3eSKrolOmV5OfHdicq3gTbJvUFDxgohd\nT5X0r4dZ6umDQobHiLWgZmPVuCvyGiCko24ka5564P/t3ccIKYP0NctCWKT5Foo5\nK7VrZsD+puvKCspHAhBP4gF9mYL9iYDAEhwd5ZmdfPTtXydBOOnCE2sFW3SoXBGi\nbw8Wx18PjEJWnkuOGSgit8XnlGmSBhn+JEVZdjwyR8snfVaK3X7xmbh5HHb2yoWq\nyeszz64nvATY/0hmHxSu6x6BicRMm65rn3XP1q/q8z7o71NMPvS9++XyFij/fM/C\n4JBm83nhP5MHYYM1ML7IzQrN6HheGRW/c2gl5SpinbV/Rq2axTqBFQvfDbh5YJgD\nfOxSGkI1Aq0VtTSP+PJKOGuN7Nnk6ToZzJn0JYbYKF2vwbsIZqh5qa3yN1eiEUkI\nLLUB+RuqhjDEH9pNXo1/C6RkYZL5Xjun9pcdpXy7RvBb33+cEoWF2FATPaTT9CkC\niEmNHzToi2xMLgQcXx/ivorhwychVTTOb6QdaSmTzXVr11BT3p4=\n=4Gfx\n-----END PGP SIGNATURE-----", "payload": "tree b3b3f5cfe8b62d0c47773858756d7ce4480376c3\nparent fa874627f0adcd5a834b116c7a475b56611317c6\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1673952505 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1673954229 +0900\n\nEnforce builtin binop expectations on single references\n\nAlso don't enforce them on non-builtin types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/461435adabb7ddfb4eb65109db6c2fcc191d8049", "html_url": "https://github.com/rust-lang/rust/commit/461435adabb7ddfb4eb65109db6c2fcc191d8049", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/461435adabb7ddfb4eb65109db6c2fcc191d8049/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa874627f0adcd5a834b116c7a475b56611317c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa874627f0adcd5a834b116c7a475b56611317c6", "html_url": "https://github.com/rust-lang/rust/commit/fa874627f0adcd5a834b116c7a475b56611317c6"}], "stats": {"total": 276, "additions": 243, "deletions": 33}, "files": [{"sha": "0244b6c653e2dbaa88c7fc718d3d78f6e6dd6c99", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/461435adabb7ddfb4eb65109db6c2fcc191d8049/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461435adabb7ddfb4eb65109db6c2fcc191d8049/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=461435adabb7ddfb4eb65109db6c2fcc191d8049", "patch": "@@ -1,6 +1,6 @@\n //! Various extensions traits for Chalk types.\n \n-use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, UintTy};\n+use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n     generics::TypeOrConstParamData,\n@@ -18,6 +18,8 @@ use crate::{\n \n pub trait TyExt {\n     fn is_unit(&self) -> bool;\n+    fn is_integral(&self) -> bool;\n+    fn is_floating_point(&self) -> bool;\n     fn is_never(&self) -> bool;\n     fn is_unknown(&self) -> bool;\n     fn is_ty_var(&self) -> bool;\n@@ -51,6 +53,21 @@ impl TyExt for Ty {\n         matches!(self.kind(Interner), TyKind::Tuple(0, _))\n     }\n \n+    fn is_integral(&self) -> bool {\n+        matches!(\n+            self.kind(Interner),\n+            TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n+                | TyKind::InferenceVar(_, TyVariableKind::Integer)\n+        )\n+    }\n+\n+    fn is_floating_point(&self) -> bool {\n+        matches!(\n+            self.kind(Interner),\n+            TyKind::Scalar(Scalar::Float(_)) | TyKind::InferenceVar(_, TyVariableKind::Float)\n+        )\n+    }\n+\n     fn is_never(&self) -> bool {\n         matches!(self.kind(Interner), TyKind::Never)\n     }"}, {"sha": "eda41ba854ffba089b517030a119900a91f26678", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 127, "deletions": 6, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/461435adabb7ddfb4eb65109db6c2fcc191d8049/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461435adabb7ddfb4eb65109db6c2fcc191d8049/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=461435adabb7ddfb4eb65109db6c2fcc191d8049", "patch": "@@ -1071,11 +1071,9 @@ impl<'a> InferenceContext<'a> {\n \n         let ret_ty = self.normalize_associated_types_in(ret_ty);\n \n-        // use knowledge of built-in binary ops, which can sometimes help inference\n-        if let Some(builtin_rhs) = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone()) {\n-            self.unify(&builtin_rhs, &rhs_ty);\n-        }\n-        if let Some(builtin_ret) = self.builtin_binary_op_return_ty(op, lhs_ty, rhs_ty) {\n+        if self.is_builtin_binop(&lhs_ty, &rhs_ty, op) {\n+            // use knowledge of built-in binary ops, which can sometimes help inference\n+            let builtin_ret = self.enforce_builtin_binop_types(&lhs_ty, &rhs_ty, op);\n             self.unify(&builtin_ret, &ret_ty);\n         }\n \n@@ -1545,7 +1543,10 @@ impl<'a> InferenceContext<'a> {\n     fn builtin_binary_op_rhs_expectation(&mut self, op: BinaryOp, lhs_ty: Ty) -> Option<Ty> {\n         Some(match op {\n             BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n-            BinaryOp::Assignment { op: None } => lhs_ty,\n+            BinaryOp::Assignment { op: None } => {\n+                stdx::never!(\"Simple assignment operator is not binary op.\");\n+                return None;\n+            }\n             BinaryOp::CmpOp(CmpOp::Eq { .. }) => match self\n                 .resolve_ty_shallow(&lhs_ty)\n                 .kind(Interner)\n@@ -1565,6 +1566,126 @@ impl<'a> InferenceContext<'a> {\n         })\n     }\n \n+    /// Dereferences a single level of immutable referencing.\n+    fn deref_ty_if_possible(&mut self, ty: &Ty) -> Ty {\n+        let ty = self.resolve_ty_shallow(ty);\n+        match ty.kind(Interner) {\n+            TyKind::Ref(Mutability::Not, _, inner) => self.resolve_ty_shallow(inner),\n+            _ => ty,\n+        }\n+    }\n+\n+    /// Enforces expectations on lhs type and rhs type depending on the operator and returns the\n+    /// output type of the binary op.\n+    fn enforce_builtin_binop_types(&mut self, lhs: &Ty, rhs: &Ty, op: BinaryOp) -> Ty {\n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).\n+        let lhs = self.deref_ty_if_possible(lhs);\n+        let rhs = self.deref_ty_if_possible(rhs);\n+\n+        let (op, is_assign) = match op {\n+            BinaryOp::Assignment { op: Some(inner) } => (BinaryOp::ArithOp(inner), true),\n+            _ => (op, false),\n+        };\n+\n+        let output_ty = match op {\n+            BinaryOp::LogicOp(_) => {\n+                let bool_ = self.result.standard_types.bool_.clone();\n+                self.unify(&lhs, &bool_);\n+                self.unify(&rhs, &bool_);\n+                bool_\n+            }\n+\n+            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n+                // result type is same as LHS always\n+                lhs\n+            }\n+\n+            BinaryOp::ArithOp(_) => {\n+                // LHS, RHS, and result will have the same type\n+                self.unify(&lhs, &rhs);\n+                lhs\n+            }\n+\n+            BinaryOp::CmpOp(_) => {\n+                // LHS and RHS will have the same type\n+                self.unify(&lhs, &rhs);\n+                self.result.standard_types.bool_.clone()\n+            }\n+\n+            BinaryOp::Assignment { op: None } => {\n+                stdx::never!(\"Simple assignment operator is not binary op.\");\n+                lhs\n+            }\n+\n+            BinaryOp::Assignment { .. } => unreachable!(\"handled above\"),\n+        };\n+\n+        if is_assign {\n+            self.result.standard_types.unit.clone()\n+        } else {\n+            output_ty\n+        }\n+    }\n+\n+    fn is_builtin_binop(&mut self, lhs: &Ty, rhs: &Ty, op: BinaryOp) -> bool {\n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).\n+        let lhs = self.deref_ty_if_possible(lhs);\n+        let rhs = self.deref_ty_if_possible(rhs);\n+\n+        let op = match op {\n+            BinaryOp::Assignment { op: Some(inner) } => BinaryOp::ArithOp(inner),\n+            _ => op,\n+        };\n+\n+        match op {\n+            BinaryOp::LogicOp(_) => true,\n+\n+            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n+                lhs.is_integral() && rhs.is_integral()\n+            }\n+\n+            BinaryOp::ArithOp(\n+                ArithOp::Add | ArithOp::Sub | ArithOp::Mul | ArithOp::Div | ArithOp::Rem,\n+            ) => {\n+                lhs.is_integral() && rhs.is_integral()\n+                    || lhs.is_floating_point() && rhs.is_floating_point()\n+            }\n+\n+            BinaryOp::ArithOp(ArithOp::BitAnd | ArithOp::BitOr | ArithOp::BitXor) => {\n+                lhs.is_integral() && rhs.is_integral()\n+                    || lhs.is_floating_point() && rhs.is_floating_point()\n+                    || matches!(\n+                        (lhs.kind(Interner), rhs.kind(Interner)),\n+                        (TyKind::Scalar(Scalar::Bool), TyKind::Scalar(Scalar::Bool))\n+                    )\n+            }\n+\n+            BinaryOp::CmpOp(_) => {\n+                let is_scalar = |kind| {\n+                    matches!(\n+                        kind,\n+                        &TyKind::Scalar(_)\n+                            | TyKind::FnDef(..)\n+                            | TyKind::Function(_)\n+                            | TyKind::Raw(..)\n+                            | TyKind::InferenceVar(\n+                                _,\n+                                TyVariableKind::Integer | TyVariableKind::Float\n+                            )\n+                    )\n+                };\n+                is_scalar(lhs.kind(Interner)) && is_scalar(rhs.kind(Interner))\n+            }\n+\n+            BinaryOp::Assignment { op: None } => {\n+                stdx::never!(\"Simple assignment operator is not binary op.\");\n+                false\n+            }\n+\n+            BinaryOp::Assignment { .. } => unreachable!(\"handled above\"),\n+        }\n+    }\n+\n     fn with_breakable_ctx<T>(\n         &mut self,\n         kind: BreakableKind,"}, {"sha": "4c560702a1b4568301d229e7e7d05a6d5fe16281", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 98, "deletions": 26, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/461435adabb7ddfb4eb65109db6c2fcc191d8049/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/461435adabb7ddfb4eb65109db6c2fcc191d8049/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=461435adabb7ddfb4eb65109db6c2fcc191d8049", "patch": "@@ -3507,14 +3507,9 @@ trait Request {\n fn bin_op_adt_with_rhs_primitive() {\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"add\"]\n-pub trait Add<Rhs = Self> {\n-    type Output;\n-    fn add(self, rhs: Rhs) -> Self::Output;\n-}\n-\n+//- minicore: add\n struct Wrapper(u32);\n-impl Add<u32> for Wrapper {\n+impl core::ops::Add<u32> for Wrapper {\n     type Output = Self;\n     fn add(self, rhs: u32) -> Wrapper {\n         Wrapper(rhs)\n@@ -3527,29 +3522,106 @@ fn main(){\n \n }\"#,\n         expect![[r#\"\n-            72..76 'self': Self\n-            78..81 'rhs': Rhs\n-            192..196 'self': Wrapper\n-            198..201 'rhs': u32\n-            219..247 '{     ...     }': Wrapper\n-            229..236 'Wrapper': Wrapper(u32) -> Wrapper\n-            229..241 'Wrapper(rhs)': Wrapper\n-            237..240 'rhs': u32\n-            259..345 '{     ...um;  }': ()\n-            269..276 'wrapped': Wrapper\n-            279..286 'Wrapper': Wrapper(u32) -> Wrapper\n-            279..290 'Wrapper(10)': Wrapper\n-            287..289 '10': u32\n-            300..303 'num': u32\n-            311..312 '2': u32\n-            322..325 'res': Wrapper\n-            328..335 'wrapped': Wrapper\n-            328..341 'wrapped + num': Wrapper\n-            338..341 'num': u32\n+            95..99 'self': Wrapper\n+            101..104 'rhs': u32\n+            122..150 '{     ...     }': Wrapper\n+            132..139 'Wrapper': Wrapper(u32) -> Wrapper\n+            132..144 'Wrapper(rhs)': Wrapper\n+            140..143 'rhs': u32\n+            162..248 '{     ...um;  }': ()\n+            172..179 'wrapped': Wrapper\n+            182..189 'Wrapper': Wrapper(u32) -> Wrapper\n+            182..193 'Wrapper(10)': Wrapper\n+            190..192 '10': u32\n+            203..206 'num': u32\n+            214..215 '2': u32\n+            225..228 'res': Wrapper\n+            231..238 'wrapped': Wrapper\n+            231..244 'wrapped + num': Wrapper\n+            241..244 'num': u32\n         \"#]],\n     )\n }\n \n+#[test]\n+fn builtin_binop_expectation_works_on_single_reference() {\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+impl Add<i32> for i32 { type Output = i32 }\n+impl Add<&i32> for i32 { type Output = i32 }\n+impl Add<u32> for u32 { type Output = u32 }\n+impl Add<&u32> for u32 { type Output = u32 }\n+\n+struct V<T>;\n+impl<T> V<T> {\n+    fn default() -> Self { loop {} }\n+    fn get(&self, _: &T) -> &T { loop {} }\n+}\n+\n+fn take_u32(_: u32) {}\n+fn minimized() {\n+    let v = V::default();\n+    let p = v.get(&0);\n+      //^ &u32\n+    take_u32(42 + p);\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_builtin_binop_expectation_for_general_ty_var() {\n+    // FIXME: Ideally type mismatch should be reported on `take_u32(42 - p)`.\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+impl Add<i32> for i32 { type Output = i32; }\n+impl Add<&i32> for i32 { type Output = i32; }\n+// This is needed to prevent chalk from giving unique solution to `i32: Add<&?0>` after applying\n+// fallback to integer type variable for `42`.\n+impl Add<&()> for i32 { type Output = (); }\n+\n+struct V<T>;\n+impl<T> V<T> {\n+    fn default() -> Self { loop {} }\n+    fn get(&self) -> &T { loop {} }\n+}\n+\n+fn take_u32(_: u32) {}\n+fn minimized() {\n+    let v = V::default();\n+    let p = v.get();\n+      //^ &{unknown}\n+    take_u32(42 + p);\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_builtin_binop_expectation_for_non_builtin_types() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: default, eq\n+struct S;\n+impl Default for S { fn default() -> Self { S } }\n+impl Default for i32 { fn default() -> Self { 0 } }\n+impl PartialEq<S> for i32 { fn eq(&self, _: &S) -> bool { true } }\n+impl PartialEq<i32> for i32 { fn eq(&self, _: &S) -> bool { true } }\n+\n+fn take_s(_: S) {}\n+fn test() {\n+    let s = Default::default();\n+    let _eq = 0 == s;\n+    take_s(s);\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn array_length() {\n     check_infer("}]}