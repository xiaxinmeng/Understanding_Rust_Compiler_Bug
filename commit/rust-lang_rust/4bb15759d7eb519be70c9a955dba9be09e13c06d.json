{"sha": "4bb15759d7eb519be70c9a955dba9be09e13c06d", "node_id": "C_kwDOAAsO6NoAKDRiYjE1NzU5ZDdlYjUxOWJlNzBjOWE5NTVkYmE5YmUwOWUxM2MwNmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-03T11:28:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-03T11:28:33Z"}, "message": "Auto merge of #105183 - GuillaumeGomez:merge-and-dedup-predicates, r=notriddle\n\nMerge generics and where predicates and prevent duplicates in where predicates\n\nPart of #104886 (I didn't include bounds from parent trait yet as I think the PR is already big enough).\n\nAlso we'll need to run a perf check.\n\ncc `@fmease` since you worked a bit on this.\nr? `@notriddle`", "tree": {"sha": "f32a5f27ca6cf631d3b20134377d452a5839a1d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f32a5f27ca6cf631d3b20134377d452a5839a1d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bb15759d7eb519be70c9a955dba9be09e13c06d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb15759d7eb519be70c9a955dba9be09e13c06d", "html_url": "https://github.com/rust-lang/rust/commit/4bb15759d7eb519be70c9a955dba9be09e13c06d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bb15759d7eb519be70c9a955dba9be09e13c06d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "703d95e183fbb678249d8f61cabc732e46884e00", "url": "https://api.github.com/repos/rust-lang/rust/commits/703d95e183fbb678249d8f61cabc732e46884e00", "html_url": "https://github.com/rust-lang/rust/commit/703d95e183fbb678249d8f61cabc732e46884e00"}, {"sha": "269704a4a09502ae64f3916058b157d94e6cba99", "url": "https://api.github.com/repos/rust-lang/rust/commits/269704a4a09502ae64f3916058b157d94e6cba99", "html_url": "https://github.com/rust-lang/rust/commit/269704a4a09502ae64f3916058b157d94e6cba99"}], "stats": {"total": 156, "additions": 117, "deletions": 39}, "files": [{"sha": "2a2a9470d25c0ee4da19badf253f0207a6dcdda7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4bb15759d7eb519be70c9a955dba9be09e13c06d", "patch": "@@ -12,7 +12,7 @@ pub(crate) mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -598,47 +598,105 @@ pub(crate) fn clean_generics<'tcx>(\n         })\n         .collect::<Vec<_>>();\n \n+    let mut bound_predicates = FxIndexMap::default();\n+    let mut region_predicates = FxIndexMap::default();\n+    let mut eq_predicates = ThinVec::default();\n+    for pred in gens.predicates.iter().filter_map(|x| clean_where_predicate(x, cx)) {\n+        match pred {\n+            WherePredicate::BoundPredicate { ty, bounds, bound_params } => {\n+                match bound_predicates.entry(ty) {\n+                    IndexEntry::Vacant(v) => {\n+                        v.insert((bounds, bound_params));\n+                    }\n+                    IndexEntry::Occupied(mut o) => {\n+                        // we merge both bounds.\n+                        for bound in bounds {\n+                            if !o.get().0.contains(&bound) {\n+                                o.get_mut().0.push(bound);\n+                            }\n+                        }\n+                        for bound_param in bound_params {\n+                            if !o.get().1.contains(&bound_param) {\n+                                o.get_mut().1.push(bound_param);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            WherePredicate::RegionPredicate { lifetime, bounds } => {\n+                match region_predicates.entry(lifetime) {\n+                    IndexEntry::Vacant(v) => {\n+                        v.insert(bounds);\n+                    }\n+                    IndexEntry::Occupied(mut o) => {\n+                        // we merge both bounds.\n+                        for bound in bounds {\n+                            if !o.get().contains(&bound) {\n+                                o.get_mut().push(bound);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            WherePredicate::EqPredicate { lhs, rhs, bound_params } => {\n+                eq_predicates.push(WherePredicate::EqPredicate { lhs, rhs, bound_params });\n+            }\n+        }\n+    }\n+\n     let mut params = ThinVec::with_capacity(gens.params.len());\n+    // In this loop, we gather the generic parameters (`<'a, B: 'a>`) and check if they have\n+    // bounds in the where predicates. If so, we move their bounds into the where predicates\n+    // while also preventing duplicates.\n     for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-        let p = clean_generic_param(cx, Some(gens), p);\n+        let mut p = clean_generic_param(cx, Some(gens), p);\n+        match &mut p.kind {\n+            GenericParamDefKind::Lifetime { ref mut outlives } => {\n+                if let Some(region_pred) = region_predicates.get_mut(&Lifetime(p.name)) {\n+                    // We merge bounds in the `where` clause.\n+                    for outlive in outlives.drain(..) {\n+                        let outlive = GenericBound::Outlives(outlive);\n+                        if !region_pred.contains(&outlive) {\n+                            region_pred.push(outlive);\n+                        }\n+                    }\n+                }\n+            }\n+            GenericParamDefKind::Type { bounds, synthetic: false, .. } => {\n+                if let Some(bound_pred) = bound_predicates.get_mut(&Type::Generic(p.name)) {\n+                    // We merge bounds in the `where` clause.\n+                    for bound in bounds.drain(..) {\n+                        if !bound_pred.0.contains(&bound) {\n+                            bound_pred.0.push(bound);\n+                        }\n+                    }\n+                }\n+            }\n+            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                // nothing to do here.\n+            }\n+        }\n         params.push(p);\n     }\n     params.extend(impl_trait_params);\n \n-    let mut generics = Generics {\n+    Generics {\n         params,\n-        where_predicates: gens\n-            .predicates\n-            .iter()\n-            .filter_map(|x| clean_where_predicate(x, cx))\n+        where_predicates: bound_predicates\n+            .into_iter()\n+            .map(|(ty, (bounds, bound_params))| WherePredicate::BoundPredicate {\n+                ty,\n+                bounds,\n+                bound_params,\n+            })\n+            .chain(\n+                region_predicates\n+                    .into_iter()\n+                    .map(|(lifetime, bounds)| WherePredicate::RegionPredicate { lifetime, bounds }),\n+            )\n+            .chain(eq_predicates.into_iter())\n             .collect(),\n-    };\n-\n-    // Some duplicates are generated for ?Sized bounds between type params and where\n-    // predicates. The point in here is to move the bounds definitions from type params\n-    // to where predicates when such cases occur.\n-    for where_pred in &mut generics.where_predicates {\n-        match *where_pred {\n-            WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds, .. } => {\n-                if bounds.is_empty() {\n-                    for param in &mut generics.params {\n-                        match param.kind {\n-                            GenericParamDefKind::Lifetime { .. } => {}\n-                            GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n-                                if &param.name == name {\n-                                    mem::swap(bounds, ty_bounds);\n-                                    break;\n-                                }\n-                            }\n-                            GenericParamDefKind::Const { .. } => {}\n-                        }\n-                    }\n-                }\n-            }\n-            _ => continue,\n-        }\n     }\n-    generics\n }\n \n fn clean_ty_generics<'tcx>("}, {"sha": "279e3c148887e8bc4e8ea128d71dfd4a39c8c943", "filename": "src/test/rustdoc/bounds-in-multiple-parts.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fbounds-in-multiple-parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fbounds-in-multiple-parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fbounds-in-multiple-parts.rs?ref=4bb15759d7eb519be70c9a955dba9be09e13c06d", "patch": "@@ -0,0 +1,20 @@\n+#![crate_name = \"foo\"]\n+\n+pub trait Eq {}\n+pub trait Eq2 {}\n+\n+// Checking that \"where predicates\" and \"generics params\" are merged.\n+// @has 'foo/trait.T.html'\n+// @has - \"//*[@id='tymethod.f']/h4\" \"fn f<'a, 'b, 'c, T>()where Self: Eq, T: Eq + 'a, 'c: 'b + 'a,\"\n+pub trait T {\n+    fn f<'a, 'b, 'c: 'a, T: Eq + 'a>()\n+        where Self: Eq, Self: Eq, T: Eq, 'c: 'b;\n+}\n+\n+// Checking that a duplicated \"where predicate\" is removed.\n+// @has 'foo/trait.T2.html'\n+// @has - \"//*[@id='tymethod.f']/h4\" \"fn f<T>()where Self: Eq + Eq2, T: Eq2 + Eq,\"\n+pub trait T2 {\n+    fn f<T: Eq>()\n+        where Self: Eq, Self: Eq2, T: Eq2;\n+}"}, {"sha": "90cbb77cb6b60a013b1b8475bfa9bdde21204227", "filename": "src/test/rustdoc/impl-parts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fimpl-parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpl-parts.rs?ref=4bb15759d7eb519be70c9a955dba9be09e13c06d", "patch": "@@ -6,7 +6,7 @@ pub auto trait AnAutoTrait {}\n pub struct Foo<T> { field: T }\n \n // @has impl_parts/struct.Foo.html '//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header\"]' \\\n-//     \"impl<T: Clone> !AnAutoTrait for Foo<T>where T: Sync,\"\n+//     \"impl<T> !AnAutoTrait for Foo<T>where T: Sync + Clone,\"\n // @has impl_parts/trait.AnAutoTrait.html '//*[@id=\"implementors-list\"]//h3[@class=\"code-header\"]' \\\n-//     \"impl<T: Clone> !AnAutoTrait for Foo<T>where T: Sync,\"\n+//     \"impl<T> !AnAutoTrait for Foo<T>where T: Sync + Clone,\"\n impl<T: Clone> !AnAutoTrait for Foo<T> where T: Sync {}"}, {"sha": "7ed9d6729b647a67523462e6ec57a04be926a407", "filename": "src/test/rustdoc/rfc-2632-const-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frfc-2632-const-trait-impl.rs?ref=4bb15759d7eb519be70c9a955dba9be09e13c06d", "patch": "@@ -61,7 +61,7 @@ impl<T> S<T> {\n     // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/a[@class=\"trait\"]' 'Clone'\n     // @!has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where\"]' '~const'\n     // @has - '//section[@id=\"method.foo\"]/h4[@class=\"code-header\"]/span[@class=\"where fmt-newline\"]' ': Clone'\n-    pub const fn foo<B: ~const Clone + ~const Destruct>()\n+    pub const fn foo<B, C: ~const Clone + ~const Destruct>()\n     where\n         B: ~const Clone + ~const Destruct,\n     {"}, {"sha": "f7663e4616ae6784ca44d04afe6af378232d98ea", "filename": "src/test/rustdoc/whitespace-after-where-clause.enum.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "raw_url": "https://github.com/rust-lang/rust/raw/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.enum.html?ref=4bb15759d7eb519be70c9a955dba9be09e13c06d", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"item-decl\"><pre class=\"rust enum\"><code>pub enum Cow&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n+<div class=\"item-decl\"><pre class=\"rust enum\"><code>pub enum Cow&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     Borrowed(<a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B),\n     Whatever(<a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>),\n }</code></pre></div>\n\\ No newline at end of file"}, {"sha": "fa3f224e7ad0f5d21deb3fc66599eb2bd162d3d5", "filename": "src/test/rustdoc/whitespace-after-where-clause.struct.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "raw_url": "https://github.com/rust-lang/rust/raw/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.struct.html?ref=4bb15759d7eb519be70c9a955dba9be09e13c06d", "patch": "@@ -1,4 +1,4 @@\n-<div class=\"item-decl\"><pre class=\"rust struct\"><code>pub struct Struct&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n+<div class=\"item-decl\"><pre class=\"rust struct\"><code>pub struct Struct&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     pub a: <a class=\"primitive\" href=\"{{channel}}/std/primitive.reference.html\">&amp;'a </a>B,\n     pub b: <a class=\"primitive\" href=\"{{channel}}/std/primitive.u32.html\">u32</a>,\n }</code></pre></div>\n\\ No newline at end of file"}, {"sha": "7bb177debc3a8c828e6526c0f5a0e45ba47af870", "filename": "src/test/rustdoc/whitespace-after-where-clause.union.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "raw_url": "https://github.com/rust-lang/rust/raw/4bb15759d7eb519be70c9a955dba9be09e13c06d/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fwhitespace-after-where-clause.union.html?ref=4bb15759d7eb519be70c9a955dba9be09e13c06d", "patch": "@@ -1,3 +1,3 @@\n-<div class=\"item-decl\"><pre class=\"rust union\"><code>pub union Union&lt;'a, B:&#160;?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt;,</span>{\n+<div class=\"item-decl\"><pre class=\"rust union\"><code>pub union Union&lt;'a, B&gt;<span class=\"where fmt-newline\">where<br />&#160;&#160;&#160;&#160;B: <a class=\"trait\" href=\"trait.ToOwned.html\" title=\"trait foo::ToOwned\">ToOwned</a>&lt;dyn <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>&gt; + ?<a class=\"trait\" href=\"{{channel}}/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a> + 'a,</span>{\n     /* private fields */\n }</code></pre></div>\n\\ No newline at end of file"}]}