{"sha": "00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYjExMmM0NWE2MDRmYTZmNGI1OWFmMmE0MGM5ZGVlYWRmZGI3YzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-08T18:40:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-08T18:40:04Z"}, "message": "auto merge of #20760 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "b7ebe956eeb308942c79bb1cd8ca1c4fc016fe83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7ebe956eeb308942c79bb1cd8ca1c4fc016fe83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "html_url": "https://github.com/rust-lang/rust/commit/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "html_url": "https://github.com/rust-lang/rust/commit/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7"}, {"sha": "7541f82faba6b2839b5e640605d7caab6cc6ec4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7541f82faba6b2839b5e640605d7caab6cc6ec4f", "html_url": "https://github.com/rust-lang/rust/commit/7541f82faba6b2839b5e640605d7caab6cc6ec4f"}], "stats": {"total": 18544, "additions": 9141, "deletions": 9403}, "files": [{"sha": "e858e91773b9288e6df572d205f419ac067963c1", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -6,14 +6,14 @@ documentation.\n ## Quick Start\n \n 1. Download a [binary installer][installer] for your platform.\n-2. Read the [guide].\n+2. Read [The Rust Programming Language][trpl].\n 3. Enjoy!\n \n > ***Note:*** Windows users can read the detailed\n > [using Rust on Windows][win-wiki] notes on the wiki.\n \n [installer]: http://www.rust-lang.org/install.html\n-[guide]: http://doc.rust-lang.org/guide.html\n+[trpl]: http://doc.rust-lang.org/book/index.html\n [win-wiki]: https://github.com/rust-lang/rust/wiki/Using-Rust-on-Windows\n \n ## Building from Source\n@@ -53,7 +53,7 @@ documentation.\n     When complete, `make install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool.\n-3. Read the [guide].\n+3. Read [The Rust Programming Language][trpl].\n 4. Enjoy!\n \n ### Building on Windows\n@@ -75,7 +75,7 @@ To easily build on windows we can use [MSYS2](http://sourceforge.net/projects/ms\n \n [repo]: https://github.com/rust-lang/rust\n [tarball]: https://static.rust-lang.org/dist/rust-nightly.tar.gz\n-[guide]: http://doc.rust-lang.org/guide.html\n+[trpl]: http://doc.rust-lang.org/book/index.html\n \n ## Notes\n "}, {"sha": "b75fde6fd3268fb8775264111f0c82c3b714d130", "filename": "RELEASES.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -19,8 +19,10 @@ Version 1.0.0-alpha (January 2015)\n       distribution into the Cargo ecosystem so they can evolve\n       separately and don't need to be stabilized as quickly, including\n       'time', 'getopts', 'num', 'regex', and 'term'.\n-    * Documentation continues to be expanded with more guides, more\n-      API coverage and more examples.\n+    * Documentation continues to be expanded with more API coverage, more\n+      examples, and more in-depth explanations. The guides have been\n+      consolidated into [The Rust Programming Language][trpl].\n+    * \"Rust By Example\" is now maintained by the Rust team.\n     * All official Rust binary installers now come with [Cargo], the\n       Rust package manager.\n \n@@ -179,6 +181,7 @@ Version 1.0.0-alpha (January 2015)\n [objsafe]: https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md\n [assoc]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n [ints]: https://github.com/rust-lang/rfcs/pull/544#issuecomment-68760871\n+[trpl]: http://doc.rust-lang.org/book/index.html\n \n Version 0.12.0 (October 2014)\n -----------------------------"}, {"sha": "d0b99b12fd90d080b054bb9ffb0d32ca648363f2", "filename": "configure", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/configure", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -1055,18 +1055,6 @@ do\n     make_dir $h/test/debuginfo-gdb\n     make_dir $h/test/debuginfo-lldb\n     make_dir $h/test/codegen\n-    make_dir $h/test/doc-guide\n-    make_dir $h/test/doc-guide-ffi\n-    make_dir $h/test/doc-guide-runtime\n-    make_dir $h/test/doc-guide-macros\n-    make_dir $h/test/doc-guide-ownership\n-    make_dir $h/test/doc-guide-pointers\n-    make_dir $h/test/doc-guide-container\n-    make_dir $h/test/doc-guide-tasks\n-    make_dir $h/test/doc-guide-plugin\n-    make_dir $h/test/doc-guide-crates\n-    make_dir $h/test/doc-guide-error-handling\n-    make_dir $h/test/doc-reference\n done\n \n # Configure submodules"}, {"sha": "5b8772c4e0af5e9ee4bd6bd80a2274b3feeabc8c", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -57,7 +57,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n-TOOLS := compiletest rustdoc rustc\n+TOOLS := compiletest rustdoc rustc rustbook\n \n DEPS_core :=\n DEPS_libc := core\n@@ -99,9 +99,11 @@ DEPS_fmt_macros = std\n TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc\n TOOL_DEPS_rustc := rustc_driver\n+TOOL_DEPS_rustbook := std regex rustdoc\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n+TOOL_SOURCE_rustbook := $(S)src/rustbook/main.rs\n \n ONLY_RLIB_core := 1\n ONLY_RLIB_libc := 1"}, {"sha": "1104c3eb6dbb5040fcd6c8dd0a7e53d590325431", "filename": "mk/docs.mk", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n # except according to those terms.\n \n ######################################################################\n-# The various pieces of standalone documentation: guides, manual, etc\n+# The various pieces of standalone documentation.\n #\n # The DOCS variable is their names (with no file extension).\n #\n@@ -25,13 +25,11 @@\n # L10N_LANGS are the languages for which the docs have been\n # translated.\n ######################################################################\n-DOCS := index intro tutorial guide guide-ffi guide-macros guide-ownership \\\n-\tguide-tasks guide-container guide-pointers guide-testing \\\n-\tguide-plugin guide-crates complement-bugreport guide-error-handling \\\n-\tcomplement-lang-faq complement-design-faq complement-project-faq \\\n-    rustdoc guide-unsafe guide-strings reference\n+DOCS := index intro tutorial complement-bugreport \\\n+    complement-lang-faq complement-design-faq complement-project-faq \\\n+    rustdoc reference\n \n-PDF_DOCS := guide reference\n+PDF_DOCS := reference\n \n RUSTDOC_DEPS_reference := doc/full-toc.inc\n RUSTDOC_FLAGS_reference := --html-in-header=doc/full-toc.inc\n@@ -61,9 +59,15 @@ RUSTDOC_EXE = $(HBIN2_H_$(CFG_BUILD))/rustdoc$(X_$(CFG_BUILD))\n # ./configure\n RUSTDOC = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(RUSTDOC_EXE)\n \n+# The rustbook executable...\n+RUSTBOOK_EXE = $(HBIN2_H_$(CFG_BUILD))/rustbook$(X_$(CFG_BUILD))\n+# ...with rpath included in case --disable-rpath was provided to\n+# ./configure\n+RUSTBOOK = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(RUSTBOOK_EXE)\n+\n D := $(S)src/doc\n \n-DOC_TARGETS :=\n+DOC_TARGETS := trpl\n COMPILER_DOC_TARGETS :=\n DOC_L10N_TARGETS :=\n \n@@ -270,3 +274,9 @@ endif\n \n docs: $(DOC_TARGETS)\n compiler-docs: $(COMPILER_DOC_TARGETS)\n+\n+trpl: doc/book/index.html\n+\n+doc/book/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/trpl/*.md)\n+\t$(Q)rm -rf doc/book\n+\t$(Q)$(RUSTBOOK) build $(S)src/doc/trpl doc/book"}, {"sha": "6a5daeb690941f98097570ce3676e24bc101a67c", "filename": "mk/prepare.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -70,7 +70,7 @@ define PREPARE_MAN\n \t$(Q)$(PREPARE_MAN_CMD) $(PREPARE_SOURCE_MAN_DIR)/$(1) $(PREPARE_DEST_MAN_DIR)/$(1)\n endef\n \n-PREPARE_TOOLS = $(filter-out compiletest, $(TOOLS))\n+PREPARE_TOOLS = $(filter-out compiletest rustbook, $(TOOLS))\n \n \n # $(1) is tool"}, {"sha": "c8c4beb11531bc2c65dba186f7e6ba687e5b9ec0", "filename": "mk/tests.mk", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -147,6 +147,17 @@ else\n CFG_ADB_TEST_DIR=\n endif\n \n+# $(1) - name of doc test\n+# $(2) - file of the test\n+define DOCTEST\n+DOC_NAMES := $$(DOC_NAMES) $(1)\n+DOCFILE_$(1) := $(2)\n+endef\n+\n+$(foreach doc,$(DOCS), \\\n+  $(eval $(call DOCTEST,md-$(doc),$(S)src/doc/$(doc).md)))\n+$(foreach file,$(wildcard $(S)src/doc/trpl/*.md), \\\n+  $(eval $(call DOCTEST,$(file:$(S)src/doc/trpl/%.md=trpl-%),$(file))))\n \n ######################################################################\n # Main test targets\n@@ -292,6 +303,7 @@ tidy:\n \t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n \n+\n endif\n \n \n@@ -339,8 +351,8 @@ check-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec: \\\n            check-stage$(1)-T-$(2)-H-$(3)-doc-crate-$$(crate)-exec)\n \n check-stage$(1)-T-$(2)-H-$(3)-doc-exec: \\\n-        $$(foreach docname,$$(DOCS), \\\n-           check-stage$(1)-T-$(2)-H-$(3)-doc-$$(docname)-exec)\n+        $$(foreach docname,$$(DOC_NAMES), \\\n+           check-stage$(1)-T-$(2)-H-$(3)-doc-$$(docname)-exec) \\\n \n check-stage$(1)-T-$(2)-H-$(3)-pretty-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-rpass-exec \\\n@@ -795,17 +807,18 @@ check-stage$(1)-T-$(2)-H-$(3)-doc-$(4)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(3)\n # rustdoc etc.\n ifeq ($(NO_REBUILD),)\n DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = \\\n-\t$$(D)/$(4).md \\\n+\t$$(DOCFILE_$(4)) \\\n \t$$(TEST_SREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(RUSTDOC_EXE_$(1)_T_$(2)_H_$(3))\n else\n-DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(D)/$(4).md\n+DOCTESTDEP_$(1)_$(2)_$(3)_$(4) = $$(DOCFILE_$(4))\n endif\n \n ifeq ($(2),$$(CFG_BUILD))\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)): $$(DOCTESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, run doc-$(4) [$(2)])\n-\t$$(Q)$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --cfg dox --test $$< --test-args \"$$(TESTARGS)\" && touch $$@\n+\t$$(Q)$$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --cfg dox --test $$< \\\n+\t\t--test-args \"$$(TESTARGS)\" && touch $$@\n else\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-$(4)):\n \ttouch $$@\n@@ -815,7 +828,7 @@ endef\n $(foreach host,$(CFG_HOST), \\\n  $(foreach target,$(CFG_TARGET), \\\n   $(foreach stage,$(STAGES), \\\n-   $(foreach docname,$(DOCS), \\\n+   $(foreach docname,$(DOC_NAMES), \\\n     $(eval $(call DEF_DOC_TEST,$(stage),$(target),$(host),$(docname)))))))\n \n # Crates\n@@ -877,7 +890,7 @@ TEST_GROUPS = \\\n \tdebuginfo-lldb \\\n \tcodegen \\\n \tdoc \\\n-\t$(foreach docname,$(DOCS),doc-$(docname)) \\\n+\t$(foreach docname,$(DOC_NAMES),doc-$(docname)) \\\n \tpretty \\\n \tpretty-rpass \\\n     pretty-rpass-valgrind \\\n@@ -946,7 +959,7 @@ $(foreach stage,$(STAGES), \\\n    $(eval $(call DEF_CHECK_FOR_STAGE_AND_HOSTS_AND_GROUP,$(stage),$(host),$(group))))))\n \n define DEF_CHECK_DOC_FOR_STAGE\n-check-stage$(1)-docs: $$(foreach docname,$$(DOCS), \\\n+check-stage$(1)-docs: $$(foreach docname,$$(DOC_NAMES), \\\n                        check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-$$(docname)) \\\n                      $$(foreach crate,$$(TEST_DOC_CRATES), \\\n                        check-stage$(1)-T-$$(CFG_BUILD)-H-$$(CFG_BUILD)-doc-crate-$$(crate))"}, {"sha": "802fb05796d665d91b8e5ffc0d42ee03aba47a51", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,6 +12,7 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n+#![feature(int_uint)]\n \n #![deny(warnings)]\n "}, {"sha": "e9bda17f4bc7d9956d5dadd65c8ccf0cb9fdc108", "filename": "src/doc/guide-container.md", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -1,6 +0,0 @@\n-% The Rust Containers and Iterators Guide\n-\n-This guide has been removed, with no direct replacement.\n-\n-You may enjoy reading the [iterator](std/iter/index.html) and\n-[collections](std/collections/index.html) documentation."}, {"sha": "43cc8483bcec54a6784ed71a6c0209b36711f29a", "filename": "src/doc/guide-strings.md", "status": "removed", "additions": 0, "deletions": 308, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fdoc%2Fguide-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fdoc%2Fguide-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-strings.md?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7", "patch": "@@ -1,308 +0,0 @@\n-% The Guide to Rust Strings\n-\n-Strings are an important concept to master in any programming language. If you\n-come from a managed language background, you may be surprised at the complexity\n-of string handling in a systems programming language. Efficient access and\n-allocation of memory for a dynamically sized structure involves a lot of\n-details. Luckily, Rust has lots of tools to help us here.\n-\n-A **string** is a sequence of unicode scalar values encoded as a stream of\n-UTF-8 bytes. All strings are guaranteed to be validly-encoded UTF-8 sequences.\n-Additionally, strings are not null-terminated and can contain null bytes.\n-\n-Rust has two main types of strings: `&str` and `String`.\n-\n-# &str\n-\n-The first kind is a `&str`. This is pronounced a 'string slice'.\n-String literals are of the type `&str`:\n-\n-```{rust}\n-let string = \"Hello there.\";\n-```\n-\n-Like any Rust type, string slices have an associated lifetime. A string literal\n-is a `&'static str`.  A string slice can be written without an explicit\n-lifetime in many cases, such as in function arguments. In these cases the\n-lifetime will be inferred:\n-\n-```{rust}\n-fn takes_slice(slice: &str) {\n-    println!(\"Got: {}\", slice);\n-}\n-```\n-\n-Like vector slices, string slices are simply a pointer plus a length. This\n-means that they're a 'view' into an already-allocated string, such as a\n-`&'static str` or a `String`.\n-\n-# String\n-\n-A `String` is a heap-allocated string. This string is growable, and is also\n-guaranteed to be UTF-8.\n-\n-```{rust}\n-let mut s = \"Hello\".to_string();\n-println!(\"{}\", s);\n-\n-s.push_str(\", world.\");\n-println!(\"{}\", s);\n-```\n-\n-You can coerce a `String` into a `&str` with the `as_slice()` method:\n-\n-```{rust}\n-fn takes_slice(slice: &str) {\n-    println!(\"Got: {}\", slice);\n-}\n-\n-fn main() {\n-    let s = \"Hello\".to_string();\n-    takes_slice(s.as_slice());\n-}\n-```\n-\n-You can also get a `&str` from a stack-allocated array of bytes:\n-\n-```{rust}\n-use std::str;\n-\n-let x: &[u8] = &[b'a', b'b'];\n-let stack_str: &str = str::from_utf8(x).unwrap();\n-```\n-\n-# Best Practices\n-\n-## `String` vs. `&str`\n-\n-In general, you should prefer `String` when you need ownership, and `&str` when\n-you just need to borrow a string. This is very similar to using `Vec<T>` vs. `&[T]`,\n-and `T` vs `&T` in general.\n-\n-This means starting off with this:\n-\n-```{rust,ignore}\n-fn foo(s: &str) {\n-```\n-\n-and only moving to this:\n-\n-```{rust,ignore}\n-fn foo(s: String) {\n-```\n-\n-If you have good reason. It's not polite to hold on to ownership you don't\n-need, and it can make your lifetimes more complex.\n-\n-## Generic functions\n-\n-To write a function that's generic over types of strings, use `&str`.\n-\n-```{rust}\n-fn some_string_length(x: &str) -> uint {\n-        x.len()\n-}\n-\n-fn main() {\n-    let s = \"Hello, world\";\n-\n-    println!(\"{}\", some_string_length(s));\n-\n-    let s = \"Hello, world\".to_string();\n-\n-    println!(\"{}\", some_string_length(s.as_slice()));\n-}\n-```\n-\n-Both of these lines will print `12`. \n-\n-## Comparisons\n-\n-To compare a String to a constant string, prefer `as_slice()`...\n-\n-```{rust}\n-fn compare(x: String) {\n-    if x.as_slice() == \"Hello\" {\n-        println!(\"yes\");\n-    }\n-}\n-```\n-\n-... over `to_string()`:\n-\n-```{rust}\n-fn compare(x: String) {\n-    if x == \"Hello\".to_string() {\n-        println!(\"yes\");\n-    }\n-}\n-```\n-\n-Converting a `String` to a `&str` is cheap, but converting the `&str` to a\n-`String` involves an allocation.\n-\n-## Indexing strings\n-\n-You may be tempted to try to access a certain character of a `String`, like\n-this:\n-\n-```{rust,ignore}\n-let s = \"hello\".to_string();\n-\n-println!(\"{}\", s[0]);\n-```\n-\n-This does not compile. This is on purpose. In the world of UTF-8, direct\n-indexing is basically never what you want to do. The reason is that each\n-character can be a variable number of bytes. This means that you have to iterate\n-through the characters anyway, which is an O(n) operation.\n-\n-There's 3 basic levels of unicode (and its encodings):\n-\n-- code units, the underlying data type used to store everything\n-- code points/unicode scalar values (char)\n-- graphemes (visible characters)\n-\n-Rust provides iterators for each of these situations:\n-\n-- `.bytes()` will iterate over the underlying bytes\n-- `.chars()` will iterate over the code points\n-- `.graphemes()` will iterate over each grapheme\n-\n-Usually, the `graphemes()` method on `&str` is what you want:\n-\n-```{rust}\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.graphemes(true) {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This prints:\n-\n-```{text}\n-u\u0354\n-n\u030e\u0348\u0330\n-i\u0319\u032e\u035a\u0326\n-c\u0309\u035a\n-o\u0357\u033c\u0329\u0330\n-d\u0306\u0343\u0365\u0354\n-e\u0301\n-```\n-\n-Note that `l` has the type `&str` here, since a single grapheme can consist of\n-multiple codepoints, so a `char` wouldn't be appropriate.\n-\n-This will print out each visible character in turn, as you'd expect: first \"u\u0354\", then\n-\"n\u030e\u0348\u0330\", etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n-\n-```{rust}\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.chars() {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This prints:\n-\n-```{text}\n-u\n-\u0354\n-n\n-\u030e\n-\u0348\n-\u0330\n-i\n-\u0319\n-\u032e\n-\u035a\n-\u0326\n-c\n-\u0309\n-\u035a\n-o\n-\u0357\n-\u033c\n-\u0329\n-\u0330\n-d\n-\u0306\n-\u0343\n-\u0365\n-\u0354\n-e\n-\u0301\n-```\n-\n-You can see how some of them are combining characters, and therefore the output\n-looks a bit odd.\n-\n-If you want the individual byte representation of each codepoint, you can use\n-`.bytes()`:\n-\n-```{rust}\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.bytes() {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This will print:\n-\n-```{text}\n-117\n-205\n-148\n-110\n-204\n-142\n-205\n-136\n-204\n-176\n-105\n-204\n-153\n-204\n-174\n-205\n-154\n-204\n-166\n-99\n-204\n-137\n-205\n-154\n-111\n-205\n-151\n-204\n-188\n-204\n-169\n-204\n-176\n-100\n-204\n-134\n-205\n-131\n-205\n-165\n-205\n-148\n-101\n-204\n-129\n-```\n-\n-Many more bytes than graphemes!\n-\n-# Other Documentation\n-\n-* [the `&str` API documentation](std/str/index.html)\n-* [the `String` API documentation](std/string/index.html)"}, {"sha": "5ab3063033fc2123a26bbde921c9e41ba826f0e1", "filename": "src/doc/guide.md", "status": "removed", "additions": 0, "deletions": 5520, "changes": 5520, "blob_url": "https://github.com/rust-lang/rust/blob/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=a8a210b57ef6b2f5f66b8798c80acfde70c9d2e7"}, {"sha": "25dcc10d893639b598ba57a3313a67a2b3ae5793", "filename": "src/doc/index.md", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,10 +9,11 @@ If you haven't seen Rust at all yet, the first thing you should read is the [30\n minute intro](intro.html). It will give you an overview of the basic ideas of Rust\n at a high level.\n \n-Once you know you really want to learn Rust, the next step is reading [the\n-guide](guide.html). It is a lengthy explanation of Rust, its syntax, and its\n-concepts. Upon completing the guide, you'll be an intermediate Rust developer,\n-and will have a good grasp of the fundamental ideas behind Rust.\n+Once you know you really want to learn Rust, the next step is reading [The\n+Rust Programming Language](book/index.html). It is a lengthy explanation of\n+Rust, its syntax, and its concepts. Upon completing the book, you'll be an\n+intermediate Rust developer, and will have a good grasp of the fundamental\n+ideas behind Rust.\n \n # Community & Getting Help\n \n@@ -48,24 +49,6 @@ development of Rust itself is discussed.\n Rust does not have an exact specification, but an effort to describe as much of\n the language in as much detail as possible is in [the reference](reference.html).\n \n-# Guides\n-\n-Rust Guides are in-depth looks at a particular topic that's relevant to Rust\n-development. If you're trying to figure out how to do something, there may be\n-a guide that can help you out:\n-\n-* [Ownership](guide-ownership.html)\n-* [Strings](guide-strings.html)\n-* [Pointers](guide-pointers.html)\n-* [Crates and modules](guide-crates.html)\n-* [Threads and Communication](guide-tasks.html)\n-* [Error Handling](guide-error-handling.html)\n-* [Foreign Function Interface](guide-ffi.html)\n-* [Writing Unsafe and Low-Level Code](guide-unsafe.html)\n-* [Macros](guide-macros.html)\n-* [Testing](guide-testing.html)\n-* [Compiler Plugins](guide-plugin.html)\n-\n # Tools\n \n Rust's still a young language, so there isn't a ton of tooling yet, but the"}, {"sha": "cb28586d103ec29dd6ea2be6ab28c0b56334e0a6", "filename": "src/doc/intro.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -7,8 +7,8 @@ This introduction will give you a rough idea of what Rust is like, eliding many\n details. It does not require prior experience with systems programming, but you\n may find the syntax easier if you've used a 'curly brace' programming language\n before, like C or JavaScript. The concepts are more important than the syntax,\n-so don't worry if you don't get every last detail: you can read [the\n-Guide](guide.html) to get a more complete explanation.\n+so don't worry if you don't get every last detail: you can read [The\n+Rust Programming Language](book/index.html) to get a more complete explanation.\n \n Because this is about high-level concepts, you don't need to actually install\n Rust to follow along. If you'd like to anyway, check out [the\n@@ -587,5 +587,6 @@ the type system helps you find bugs, how Rust can help you write correct\n concurrent code, and how you don't have to pay a speed cost for much of this\n safety.\n \n-To continue your Rustic education, read [the guide](guide.html) for a more\n-in-depth exploration of Rust's syntax and concepts.\n+To continue your Rustic education, read [The Rust Programming\n+Language](book/index.html) for a more in-depth exploration of Rust's syntax and\n+concepts."}, {"sha": "2486466c8696d464d36cddefcd3a16db2b0d9950", "filename": "src/doc/reference.md", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,7 +14,7 @@ provides three kinds of material:\n     influenced the design.\n \n This document does not serve as an introduction to the language. Background\n-familiarity with the language is assumed. A separate [guide] is available to\n+familiarity with the language is assumed. A separate [book] is available to\n help acquire such background familiarity.\n \n This document also does not serve as a reference to the [standard] library\n@@ -23,7 +23,7 @@ separately by extracting documentation attributes from their source code. Many\n of the features that one might expect to be language features are library\n features in Rust, so what you're looking for may be there, not here.\n \n-[guide]: guide.html\n+[book]: book/index.html\n [standard]: std/index.html\n \n # Notation\n@@ -647,10 +647,10 @@ All of the above extensions are expressions with values.\n \n Users of `rustc` can define new syntax extensions in two ways:\n \n-* [Compiler plugins](guide-plugin.html#syntax-extensions) can include arbitrary\n+* [Compiler plugins](book/syntax-extensions.html) can include arbitrary\n   Rust code that manipulates syntax trees at compile time.\n \n-* [Macros](guide-macros.html) define new syntax in a higher-level,\n+* [Macros](book/macros.html) define new syntax in a higher-level,\n   declarative way.\n \n ## Macros\n@@ -2076,7 +2076,7 @@ On `struct`s:\n   list of names `#[macro_use(foo, bar)]` restricts the import to just those\n   macros named.  The `extern crate` must appear at the crate root, not inside\n   `mod`, which ensures proper function of the [`$crate` macro\n-  variable](guide-macros.html#the-variable-$crate).\n+  variable](book/macros.html#the-variable-$crate).\n \n - `macro_reexport` on an `extern crate` \u2014 re-export the named macros.\n \n@@ -2090,8 +2090,9 @@ On `struct`s:\n - `no_link` on an `extern crate` \u2014 even if we load this crate for macros or\n   compiler plugins, don't link it into the output.\n \n-See the [macros guide](guide-macros.html#scoping-and-macro-import/export) for\n-more information on macro scope.\n+See the [macros section of the\n+book](book/macros.html#scoping-and-macro-import/export) for more information on\n+macro scope.\n \n \n ### Miscellaneous attributes\n@@ -2193,7 +2194,7 @@ For any lint check `C`:\n \n The lint checks supported by the compiler can be found via `rustc -W help`,\n along with their default settings.  [Compiler\n-plugins](guide-plugin.html#lint-plugins) can provide additional lint checks.\n+plugins](book/plugin.html#lint-plugins) can provide additional lint checks.\n \n ```{.ignore}\n mod m1 {\n@@ -4227,7 +4228,7 @@ communication facilities.\n The Rust compiler supports various methods to link crates together both\n statically and dynamically. This section will explore the various methods to\n link Rust crates together, and more information about native libraries can be\n-found in the [ffi guide][ffi].\n+found in the [ffi section of the book][ffi].\n \n In one session of compilation, the compiler can generate multiple artifacts\n through the usage of either command line flags or the `crate_type` attribute.\n@@ -4359,5 +4360,5 @@ that have since been removed):\n * [Unicode Annex #31](http://www.unicode.org/reports/tr31/): identifier and\n   pattern syntax\n \n-[ffi]: guide-ffi.html\n-[plugin]: guide-plugin.html\n+[ffi]: book/ffi.html\n+[plugin]: book/plugin.html"}, {"sha": "0202e873b36449464524e4a0ad10f9c1dc2d293e", "filename": "src/doc/trpl/README.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,35 @@\n+% The Rust Programming Language\n+\n+Welcome! This book will teach you about [the Rust Programming\n+Language](http://www.rust-lang.org/). Rust is a modern systems programming\n+language focusing on safety and speed. It accomplishes these goals by being\n+memory safe without using garbage collection.\n+\n+\"The Rust Programming Language\" is split into three sections, which you can\n+navigate through the menu on the left.\n+\n+## Basics\n+\n+This section is a linear introduction to the basic syntax and semantics of\n+Rust. It has individual sections on each part of Rust's syntax, and cumulates\n+in a small project: a guessing game.\n+\n+After reading \"Basics,\" you will have a good foundation to learn more about\n+Rust, and can write very simple programs.\n+\n+## Intermediate\n+\n+This section contains individual chapters, which are self-contained. They focus\n+on specific topics, and can be read in any order.\n+\n+After reading \"Intermediate,\" you will have a solid understanding of Rust,\n+and will be able to understand most Rust code and write more complex programs.\n+\n+## Advanced\n+\n+In a similar fashion to \"Intermediate,\" this setion is full of individual,\n+deep-dive chapters, which stand alone and can be read in any order. These\n+chapters focus on the most complex features, as well as some things that\n+are only available in upcoming versions of Rust.\n+\n+After reading \"Advanced,\" you'll be a Rust expert!"}, {"sha": "1a61c6d216b68054cda09231b979b8cfe7bdaa1b", "filename": "src/doc/trpl/SUMMARY.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,36 @@\n+# Summary\n+\n+* [I: The Basics](basic.md)\n+    * [Installing Rust](installing-rust.md)\n+    * [Hello, world!](hello-world.md)\n+    * [Hello, Cargo!](hello-cargo.md)\n+    * [Variable Bindings](variable-bindings.md)\n+    * [If](if.md)\n+    * [Functions](functions.md)\n+    * [Comments](comments.md)\n+    * [Compound Data Types](compound-data-types.md)\n+    * [Match](match.md)\n+    * [Looping](looping.md)\n+    * [Strings](strings.md)\n+    * [Arrays, Vectors, and Slices](arrays-vectors-and-slices.md)\n+    * [Standard Input](standard-input.md)\n+    * [Guessing Game](guessing-game.md)\n+* [II: Intermediate Rust](intermediate.md)\n+    * [Crates and Modules](crates-and-modules.md)\n+    * [Testing](testing.md)\n+    * [Pointers](pointers.md)\n+    * [Ownership](ownership.md)\n+    * [Patterns](patterns.md)\n+    * [Method Syntax](method-syntax.md)\n+    * [Closures](closures.md)\n+    * [Iterators](iterators.md)\n+    * [Generics](generics.md)\n+    * [Traits](traits.md)\n+    * [Tasks](tasks.md)\n+    * [Error Handling](error-handling.md)\n+* [III: Advanced Topics](advanced.md)\n+    * [FFI](ffi.md)\n+    * [Unsafe Code](unsafe.md)\n+    * [Macros](macros.md)\n+    * [Compiler Plugins](plugins.md)\n+* [Conclusion](conclusion.md)"}, {"sha": "138db523b9a21ff6cb030672a72319f1698ac82b", "filename": "src/doc/trpl/advanced.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fadvanced.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fadvanced.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,8 @@\n+% Advanced\n+\n+In a similar fashion to \"Intermediate,\" this setion is full of individual,\n+deep-dive chapters, which stand alone and can be read in any order. These\n+chapters focus on the most complex features, as well as some things that\n+are only available in upcoming versions of Rust.\n+\n+After reading \"Advanced,\" you'll be a Rust expert!"}, {"sha": "24d60dd2e4e3c1395be26564fef29943bdeacad7", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,99 @@\n+% Arrays, Vectors, and Slices\n+\n+Like many programming languages, Rust has list types to represent a sequence of\n+things. The most basic is the **array**, a fixed-size list of elements of the\n+same type. By default, arrays are immutable.\n+\n+```{rust}\n+let a = [1, 2, 3];     // a: [i32; 3]\n+let mut m = [1, 2, 3]; // mut m: [i32; 3]\n+```\n+\n+There's a shorthand for initializing each element of an array to the same\n+value. In this example, each element of `a` will be initialized to `0`:\n+\n+```{rust}\n+let a = [0; 20]; // a: [i32; 20]\n+```\n+\n+Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we\n+cover generics.\n+\n+You can get the number of elements in an array `a` with `a.len()`, and use\n+`a.iter()` to iterate over them with a for loop. This code will print each\n+number in order:\n+\n+```{rust}\n+let a = [1, 2, 3];\n+\n+println!(\"a has {} elements\", a.len());\n+for e in a.iter() {\n+    println!(\"{}\", e);\n+}\n+```\n+\n+You can access a particular element of an array with **subscript notation**:\n+\n+```{rust}\n+let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n+\n+println!(\"The second name is: {}\", names[1]);\n+```\n+\n+Subscripts start at zero, like in most programming languages, so the first name\n+is `names[0]` and the second name is `names[1]`. The above example prints\n+`The second name is: Brian`. If you try to use a subscript that is not in the\n+array, you will get an error: array access is bounds-checked at run-time. Such\n+errant access is the source of many bugs in other systems programming\n+languages.\n+\n+A **vector** is a dynamic or \"growable\" array, implemented as the standard\n+library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n+later). Vectors are to arrays what `String` is to `&str`. You can create them\n+with the `vec!` macro:\n+\n+```{rust}\n+let v = vec![1, 2, 3]; // v: Vec<i32>\n+```\n+\n+(Notice that unlike the `println!` macro we've used in the past, we use square\n+brackets `[]` with `vec!`. Rust allows you to use either in either situation,\n+this is just convention.)\n+\n+You can get the length of, iterate over, and subscript vectors just like\n+arrays. In addition, (mutable) vectors can grow automatically:\n+\n+```{rust}\n+let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n+\n+nums.push(4);\n+\n+println!(\"The length of nums is now {}\", nums.len());   // Prints 4\n+```\n+\n+Vectors have many more useful methods.\n+\n+A **slice** is a reference to (or \"view\" into) an array. They are useful for\n+allowing safe, efficient access to a portion of an array without copying. For\n+example, you might want to reference just one line of a file read into memory.\n+By nature, a slice is not created directly, but from an existing variable.\n+Slices have a length, can be mutable or not, and in many ways behave like\n+arrays:\n+\n+```{rust}\n+let a = [0, 1, 2, 3, 4];\n+let middle = a.slice(1, 4);     // A slice of a: just the elements [1,2,3]\n+\n+for e in middle.iter() {\n+    println!(\"{}\", e);          // Prints 1, 2, 3\n+}\n+```\n+\n+You can also take a slice of a vector, `String`, or `&str`, because they are\n+backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n+generics.\n+\n+We have now learned all of the most basic Rust concepts. We're ready to start\n+building our guessing game, we just need to know one last thing: how to get\n+input from the keyboard. You can't have a guessing game without the ability to\n+guess!"}, {"sha": "087121d0e7dc3d30e35240165ff9090bd7fcd452", "filename": "src/doc/trpl/basic.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fbasic.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fbasic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbasic.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,8 @@\n+% Basics\n+\n+This section is a linear introduction to the basic syntax and semantics of\n+Rust. It has individual sections on each part of Rust's syntax, and cumulates\n+in a small project: a guessing game.\n+\n+After reading \"Basics,\" you will have a good foundation to learn more about\n+Rust, and can write very simple programs."}, {"sha": "6413b90ee71e00ffa5b0d437a6c8030f9774bb88", "filename": "src/doc/trpl/closures.md", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,185 @@\n+% Closures\n+\n+So far, we've made lots of functions in Rust, but we've given them all names.\n+Rust also allows us to create anonymous functions. Rust's anonymous\n+functions are called **closure**s. By themselves, closures aren't all that\n+interesting, but when you combine them with functions that take closures as\n+arguments, really powerful things are possible.\n+\n+Let's make a closure:\n+\n+```{rust}\n+let add_one = |&: x| { 1 + x };\n+\n+println!(\"The sum of 5 plus 1 is {}.\", add_one(5));\n+```\n+\n+We create a closure using the `|...| { ... }` syntax, and then we create a\n+binding so we can use it later. Note that we call the function using the\n+binding name and two parentheses, just like we would for a named function.\n+\n+Let's compare syntax. The two are pretty close:\n+\n+```{rust}\n+let add_one = |&: x: i32| -> i32 { 1 + x };\n+fn  add_one      (x: i32) -> i32 { 1 + x }\n+```\n+\n+As you may have noticed, closures infer their argument and return types, so you\n+don't need to declare one. This is different from named functions, which\n+default to returning unit (`()`).\n+\n+There's one big difference between a closure and named functions, and it's in\n+the name: a closure \"closes over its environment.\" What does that mean? It means\n+this:\n+\n+```{rust}\n+fn main() {\n+    let x: i32 = 5;\n+\n+    let printer = |&:| { println!(\"x is: {}\", x); };\n+\n+    printer(); // prints \"x is: 5\"\n+}\n+```\n+\n+The `||` syntax means this is an anonymous closure that takes no arguments.\n+Without it, we'd just have a block of code in `{}`s.\n+\n+In other words, a closure has access to variables in the scope where it's\n+defined. The closure borrows any variables it uses, so this will error:\n+\n+```{rust,ignore}\n+fn main() {\n+    let mut x = 5;\n+\n+    let printer = |&:| { println!(\"x is: {}\", x); };\n+\n+    x = 6; // error: cannot assign to `x` because it is borrowed\n+}\n+```\n+\n+## Moving closures\n+\n+Rust has a second type of closure, called a **moving closure**. Moving\n+closures are indicated using the `move` keyword (e.g., `move || x *\n+x`). The difference between a moving closure and an ordinary closure\n+is that a moving closure always takes ownership of all variables that\n+it uses. Ordinary closures, in contrast, just create a reference into\n+the enclosing stack frame. Moving closures are most useful with Rust's\n+concurrency features, and so we'll just leave it at this for\n+now. We'll talk about them more in the \"Threads\" section of the guide.\n+\n+## Accepting closures as arguments\n+\n+Closures are most useful as an argument to another function. Here's an example:\n+\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n+    f(x) + f(x)\n+}\n+\n+fn main() {\n+    let square = |&: x: i32| { x * x };\n+\n+    twice(5, square); // evaluates to 50\n+}\n+```\n+\n+Let's break the example down, starting with `main`:\n+\n+```{rust}\n+let square = |&: x: i32| { x * x };\n+```\n+\n+We've seen this before. We make a closure that takes an integer, and returns\n+its square.\n+\n+```{rust}\n+# fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 { f(x) + f(x) }\n+# let square = |&: x: i32| { x * x };\n+twice(5, square); // evaluates to 50\n+```\n+\n+This line is more interesting. Here, we call our function, `twice`, and we pass\n+it two arguments: an integer, `5`, and our closure, `square`. This is just like\n+passing any other two variable bindings to a function, but if you've never\n+worked with closures before, it can seem a little complex. Just think: \"I'm\n+passing two variables: one is an i32, and one is a function.\"\n+\n+Next, let's look at how `twice` is defined:\n+\n+```{rust,ignore}\n+fn twice(x: i32, f: |i32| -> i32) -> i32 {\n+```\n+\n+`twice` takes two arguments, `x` and `f`. That's why we called it with two\n+arguments. `x` is an `i32`, we've done that a ton of times. `f` is a function,\n+though, and that function takes an `i32` and returns an `i32`. Notice\n+how the `|i32| -> i32` syntax looks a lot like our definition of `square`\n+above, if we added the return type in:\n+\n+```{rust}\n+let square = |&: x: i32| -> i32 { x * x };\n+//           |i32|       -> i32\n+```\n+\n+This function takes an `i32` and returns an `i32`.\n+\n+This is the most complicated function signature we've seen yet! Give it a read\n+a few times until you can see how it works. It takes a teeny bit of practice, and\n+then it's easy.\n+\n+Finally, `twice` returns an `i32` as well.\n+\n+Okay, let's look at the body of `twice`:\n+\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n+  f(x) + f(x)\n+}\n+```\n+\n+Since our closure is named `f`, we can call it just like we called our closures\n+before, and we pass in our `x` argument to each one, hence the name `twice`.\n+\n+If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.\n+\n+Play around with this concept until you're comfortable with it. Rust's standard\n+library uses lots of closures where appropriate, so you'll be using\n+this technique a lot.\n+\n+If we didn't want to give `square` a name, we could just define it inline.\n+This example is the same as the previous one:\n+\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n+    f(x) + f(x)\n+}\n+\n+fn main() {\n+    twice(5, |x: i32| { x * x }); // evaluates to 50\n+}\n+```\n+\n+A named function's name can be used wherever you'd use a closure. Another\n+way of writing the previous example:\n+\n+```{rust}\n+fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n+    f(x) + f(x)\n+}\n+\n+fn square(x: i32) -> i32 { x * x }\n+\n+fn main() {\n+    twice(5, square); // evaluates to 50\n+}\n+```\n+\n+Doing this is not particularly common, but it's useful every once in a while.\n+\n+That's all you need to get the hang of closures! Closures are a little bit\n+strange at first, but once you're used to them, you'll miss them\n+in other languages. Passing functions to other functions is\n+incredibly powerful, as you will see in the following chapter about iterators."}, {"sha": "f02c1ad9a183e8672326497761b0d025b2027f4d", "filename": "src/doc/trpl/comments.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,46 @@\n+% Comments\n+\n+Now that we have some functions, it's a good idea to learn about comments.\n+Comments are notes that you leave to other programmers to help explain things\n+about your code. The compiler mostly ignores them.\n+\n+Rust has two kinds of comments that you should care about: **line comment**s\n+and **doc comment**s.\n+\n+```{rust}\n+// Line comments are anything after '//' and extend to the end of the line.\n+\n+let x = 5; // this is also a line comment.\n+\n+// If you have a long explanation for something, you can put line comments next\n+// to each other. Put a space between the // and your comment so that it's\n+// more readable.\n+```\n+\n+The other kind of comment is a doc comment. Doc comments use `///` instead of\n+`//`, and support Markdown notation inside:\n+\n+```{rust}\n+/// `hello` is a function that prints a greeting that is personalized based on\n+/// the name given.\n+///\n+/// # Arguments\n+///\n+/// * `name` - The name of the person you'd like to greet.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// let name = \"Steve\";\n+/// hello(name); // prints \"Hello, Steve!\"\n+/// ```\n+fn hello(name: &str) {\n+    println!(\"Hello, {}!\", name);\n+}\n+```\n+\n+When writing doc comments, adding sections for any arguments, return values,\n+and providing some examples of usage is very, very helpful.\n+\n+You can use the [`rustdoc`](../rustdoc.html) tool to generate HTML documentation\n+from these doc comments."}, {"sha": "b80d248bc41d1b6059ceb2b8d0fb9fc1a0302351", "filename": "src/doc/trpl/compound-data-types.md", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,353 @@\n+% Compound Data Types\n+\n+Rust, like many programming languages, has a number of different data types\n+that are built-in. You've already done some simple work with integers and\n+strings, but next, let's talk about some more complicated ways of storing data.\n+\n+## Tuples\n+\n+The first compound data type we're going to talk about are called **tuple**s.\n+Tuples are an ordered list of a fixed size. Like this:\n+\n+```rust\n+let x = (1, \"hello\");\n+```\n+\n+The parentheses and commas form this two-length tuple. Here's the same code, but\n+with the type annotated:\n+\n+```rust\n+let x: (i32, &str) = (1, \"hello\");\n+```\n+\n+As you can see, the type of a tuple looks just like the tuple, but with each\n+position having a type name rather than the value. Careful readers will also\n+note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n+You haven't seen `&str` as a type before, and we'll discuss the details of\n+strings later. In systems programming languages, strings are a bit more complex\n+than in other languages. For now, just read `&str` as \"a string slice,\" and\n+we'll learn more soon.\n+\n+You can access the fields in a tuple through a **destructuring let**. Here's\n+an example:\n+\n+```rust\n+let (x, y, z) = (1, 2, 3);\n+\n+println!(\"x is {}\", x);\n+```\n+\n+Remember before when I said the left-hand side of a `let` statement was more\n+powerful than just assigning a binding? Here we are. We can put a pattern on\n+the left-hand side of the `let`, and if it matches up to the right-hand side,\n+we can assign multiple bindings at once. In this case, `let` 'destructures,'\n+or 'breaks up,' the tuple, and assigns the bits to three bindings.\n+\n+This pattern is very powerful, and we'll see it repeated more later.\n+\n+There are also a few things you can do with a tuple as a whole, without\n+destructuring. You can assign one tuple into another, if they have the same\n+arity and contained types.\n+\n+```rust\n+let mut x = (1, 2); // x: (i32, i32)\n+let y = (2, 3);     // y: (i32, i32)\n+\n+x = y;\n+```\n+\n+You can also check for equality with `==`. Again, this will only compile if the\n+tuples have the same type.\n+\n+```rust\n+let x = (1, 2, 3);\n+let y = (2, 2, 4);\n+\n+if x == y {\n+    println!(\"yes\");\n+} else {\n+    println!(\"no\");\n+}\n+```\n+\n+This will print `no`, because some of the values aren't equal.\n+\n+One other use of tuples is to return multiple values from a function:\n+\n+```rust\n+fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }\n+\n+fn main() {\n+    let (x, y) = next_two(5);\n+    println!(\"x, y = {}, {}\", x, y);\n+}\n+```\n+\n+Even though Rust functions can only return one value, a tuple _is_ one value,\n+that happens to be made up of more than one value. You can also see in this example how you\n+can destructure a pattern returned by a function, as well.\n+\n+Tuples are a very simple data structure, and so are not often what you want.\n+Let's move on to their bigger sibling, structs.\n+\n+## Structs\n+\n+A struct is another form of a 'record type,' just like a tuple. There's a\n+difference: structs give each element that they contain a name, called a\n+'field' or a 'member.' Check it out:\n+\n+```rust\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let origin = Point { x: 0, y: 0 }; // origin: Point\n+\n+    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n+}\n+```\n+\n+There's a lot going on here, so let's break it down. We declare a struct with\n+the `struct` keyword, and then with a name. By convention, structs begin with a\n+capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n+\n+We can create an instance of our struct via `let`, as usual, but we use a `key:\n+value` style syntax to set each field. The order doesn't need to be the same as\n+in the original declaration.\n+\n+Finally, because fields have names, we can access the field through dot\n+notation: `origin.x`.\n+\n+The values in structs are immutable by default, like other bindings in Rust.\n+Use `mut` to make them mutable:\n+\n+```{rust}\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut point = Point { x: 0, y: 0 };\n+\n+    point.x = 5;\n+\n+    println!(\"The point is at ({}, {})\", point.x, point.y);\n+}\n+```\n+\n+This will print `The point is at (5, 0)`.\n+\n+## Tuple Structs and Newtypes\n+\n+Rust has another data type that's like a hybrid between a tuple and a struct,\n+called a **tuple struct**. Tuple structs do have a name, but their fields\n+don't:\n+\n+\n+```{rust}\n+struct Color(i32, i32, i32);\n+struct Point(i32, i32, i32);\n+```\n+\n+These two will not be equal, even if they have the same values:\n+\n+```{rust}\n+# struct Color(i32, i32, i32);\n+# struct Point(i32, i32, i32);\n+let black  = Color(0, 0, 0);\n+let origin = Point(0, 0, 0);\n+```\n+\n+It is almost always better to use a struct than a tuple struct. We would write\n+`Color` and `Point` like this instead:\n+\n+```{rust}\n+struct Color {\n+    red: i32,\n+    blue: i32,\n+    green: i32,\n+}\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+```\n+\n+Now, we have actual names, rather than positions. Good names are important,\n+and with a struct, we have actual names.\n+\n+There _is_ one case when a tuple struct is very useful, though, and that's a\n+tuple struct with only one element. We call this a 'newtype,' because it lets\n+you create a new type that's a synonym for another one:\n+\n+```{rust}\n+struct Inches(i32);\n+\n+let length = Inches(10);\n+\n+let Inches(integer_length) = length;\n+println!(\"length is {} inches\", integer_length);\n+```\n+\n+As you can see here, you can extract the inner integer type through a\n+destructuring `let`.\n+\n+## Enums\n+\n+Finally, Rust has a \"sum type\", an **enum**. Enums are an incredibly useful\n+feature of Rust, and are used throughout the standard library. This is an enum\n+that is provided by the Rust standard library:\n+\n+```{rust}\n+enum Ordering {\n+    Less,\n+    Equal,\n+    Greater,\n+}\n+```\n+\n+An `Ordering` can only be _one_ of `Less`, `Equal`, or `Greater` at any given\n+time.\n+\n+Because `Ordering` is provided by the standard library, we can use the `use`\n+keyword to use it in our code. We'll learn more about `use` later, but it's\n+used to bring names into scope.\n+\n+Here's an example of how to use `Ordering`:\n+\n+```{rust}\n+use std::cmp::Ordering;\n+\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n+\n+    let ordering = cmp(x, y); // ordering: Ordering\n+\n+    if ordering == Ordering::Less {\n+        println!(\"less\");\n+    } else if ordering == Ordering::Greater {\n+        println!(\"greater\");\n+    } else if ordering == Ordering::Equal {\n+        println!(\"equal\");\n+    }\n+}\n+```\n+\n+There's a symbol here we haven't seen before: the double colon (`::`).\n+This is used to indicate a namespace. In this case, `Ordering` lives in\n+the `cmp` submodule of the `std` module. We'll talk more about modules\n+later in the guide. For now, all you need to know is that you can `use`\n+things from the standard library if you need them.\n+\n+Okay, let's talk about the actual code in the example. `cmp` is a function that\n+compares two things, and returns an `Ordering`. We return either\n+`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on if\n+the two values are greater, less, or equal. Note that each variant of the\n+`enum` is namespaced under the `enum` itself: it's `Ordering::Greater` not\n+`Greater`.\n+\n+The `ordering` variable has the type `Ordering`, and so contains one of the\n+three values. We can then do a bunch of `if`/`else` comparisons to check which\n+one it is. However, repeated `if`/`else` comparisons get quite tedious. Rust\n+has a feature that not only makes them nicer to read, but also makes sure that\n+you never miss a case. Before we get to that, though, let's talk about another\n+kind of enum: one with values.\n+\n+This enum has two variants, one of which has a value:\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(i32),\n+    Missing,\n+}\n+```\n+\n+This enum represents an `i32` that we may or may not have. In the `Missing`\n+case, we have no value, but in the `Value` case, we do. This enum is specific\n+to `i32`s, though. We can make it usable by any type, but we haven't quite\n+gotten there yet!\n+\n+You can also have any number of values in an enum:\n+\n+```{rust}\n+enum OptionalColor {\n+    Color(i32, i32, i32),\n+    Missing,\n+}\n+```\n+\n+And you can also have something like this:\n+\n+```{rust}\n+enum StringResult {\n+    StringOK(String),\n+    ErrorReason(String),\n+}\n+```\n+Where a `StringResult` is either a `StringResult::StringOK`, with the result of\n+a computation, or an `StringResult::ErrorReason` with a `String` explaining\n+what caused the computation to fail. These kinds of `enum`s are actually very\n+useful and are even part of the standard library.\n+\n+Here is an example of using our `StringResult`:\n+\n+```rust\n+enum StringResult {\n+    StringOK(String),\n+    ErrorReason(String),\n+}\n+\n+fn respond(greeting: &str) -> StringResult {\n+    if greeting == \"Hello\" {\n+        StringResult::StringOK(\"Good morning!\".to_string())\n+    } else {\n+        StringResult::ErrorReason(\"I didn't understand you!\".to_string())\n+    }\n+}\n+```\n+\n+That's a lot of typing! We can use the `use` keyword to make it shorter:\n+\n+```rust\n+use StringResult::StringOK;\n+use StringResult::ErrorReason;\n+\n+enum StringResult {\n+    StringOK(String),\n+    ErrorReason(String),\n+}\n+\n+# fn main() {}\n+\n+fn respond(greeting: &str) -> StringResult {\n+    if greeting == \"Hello\" {\n+        StringOK(\"Good morning!\".to_string())\n+    } else {\n+        ErrorReason(\"I didn't understand you!\".to_string())\n+    }\n+}\n+```\n+\n+`use` declarations must come before anything else, which looks a little strange in this example,\n+since we `use` the variants before we define them. Anyway, in the body of `respond`, we can just\n+say `StringOK` now, rather than the full `StringResult::StringOK`. Importing variants can be\n+convenient, but can also cause name conflicts, so do this with caution. It's considered good style\n+to rarely import variants for this reason.\n+\n+As you can see, `enum`s with values are quite a powerful tool for data representation,\n+and can be even more useful when they're generic across types. Before we get to generics,\n+though, let's talk about how to use them with pattern matching, a tool that will\n+let us deconstruct this sum type (the type theory term for enums) in a very elegant\n+way and avoid all these messy `if`/`else`s."}, {"sha": "0472787e948d96ff7f720e890e666d74005a3862", "filename": "src/doc/trpl/conclusion.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fconclusion.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fconclusion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconclusion.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,10 @@\n+% Conclusion\n+\n+We covered a lot of ground here. When you've mastered everything in this Guide,\n+you will have a firm grasp of basic Rust development. There's a whole lot more\n+out there, we've just covered the surface. There's tons of topics that you can\n+dig deeper into, and we've built specialized guides for many of them. To learn\n+more, dig into the [full documentation\n+index](index.html).\n+\n+Happy hacking!"}, {"sha": "ba825c2c9a8008e6ea22cda292cd213269ca0d0f", "filename": "src/doc/trpl/crates-and-modules.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "previous_filename": "src/doc/guide-crates.md"}, {"sha": "98b46511f04584fbfff7f5d6be4b11a8ed28b40e", "filename": "src/doc/trpl/error-handling.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "previous_filename": "src/doc/guide-error-handling.md"}, {"sha": "1f12c05f37e34475d9f892eae3274c1f1220343e", "filename": "src/doc/trpl/ffi.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "previous_filename": "src/doc/guide-ffi.md"}, {"sha": "e3827d962c3313fe9dbc90d54e6987642e1661b2", "filename": "src/doc/trpl/functions.md", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,146 @@\n+% Functions\n+\n+You've already seen one function so far, the `main` function:\n+\n+```{rust}\n+fn main() {\n+}\n+```\n+\n+This is the simplest possible function declaration. As we mentioned before,\n+`fn` says 'this is a function,' followed by the name, some parentheses because\n+this function takes no arguments, and then some curly braces to indicate the\n+body. Here's a function named `foo`:\n+\n+```{rust}\n+fn foo() {\n+}\n+```\n+\n+So, what about taking arguments? Here's a function that prints a number:\n+\n+```{rust}\n+fn print_number(x: i32) {\n+    println!(\"x is: {}\", x);\n+}\n+```\n+\n+Here's a complete program that uses `print_number`:\n+\n+```{rust}\n+fn main() {\n+    print_number(5);\n+}\n+\n+fn print_number(x: i32) {\n+    println!(\"x is: {}\", x);\n+}\n+```\n+\n+As you can see, function arguments work very similar to `let` declarations:\n+you add a type to the argument name, after a colon.\n+\n+Here's a complete program that adds two numbers together and prints them:\n+\n+```{rust}\n+fn main() {\n+    print_sum(5, 6);\n+}\n+\n+fn print_sum(x: i32, y: i32) {\n+    println!(\"sum is: {}\", x + y);\n+}\n+```\n+\n+You separate arguments with a comma, both when you call the function, as well\n+as when you declare it.\n+\n+Unlike `let`, you _must_ declare the types of function arguments. This does\n+not work:\n+\n+```{ignore}\n+fn print_number(x, y) {\n+    println!(\"x is: {}\", x + y);\n+}\n+```\n+\n+You get this error:\n+\n+```text\n+hello.rs:5:18: 5:19 error: expected `:` but found `,`\n+hello.rs:5 fn print_number(x, y) {\n+```\n+\n+This is a deliberate design decision. While full-program inference is possible,\n+languages which have it, like Haskell, often suggest that documenting your\n+types explicitly is a best-practice. We agree that forcing functions to declare\n+types while allowing for inference inside of function bodies is a wonderful\n+sweet spot between full inference and no inference.\n+\n+What about returning a value? Here's a function that adds one to an integer:\n+\n+```{rust}\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+```\n+\n+Rust functions return exactly one value, and you declare the type after an\n+'arrow', which is a dash (`-`) followed by a greater-than sign (`>`).\n+\n+You'll note the lack of a semicolon here. If we added it in:\n+\n+```{ignore}\n+fn add_one(x: i32) -> i32 {\n+    x + 1;\n+}\n+```\n+\n+We would get an error:\n+\n+```text\n+error: not all control paths return a value\n+fn add_one(x: i32) -> i32 {\n+     x + 1;\n+}\n+\n+help: consider removing this semicolon:\n+     x + 1;\n+          ^\n+```\n+\n+Remember our earlier discussions about semicolons and `()`? Our function claims\n+to return an `i32`, but with a semicolon, it would return `()` instead. Rust\n+realizes this probably isn't what we want, and suggests removing the semicolon.\n+\n+This is very much like our `if` statement before: the result of the block\n+(`{}`) is the value of the expression. Other expression-oriented languages,\n+such as Ruby, work like this, but it's a bit unusual in the systems programming\n+world. When people first learn about this, they usually assume that it\n+introduces bugs. But because Rust's type system is so strong, and because unit\n+is its own unique type, we have never seen an issue where adding or removing a\n+semicolon in a return position would cause a bug.\n+\n+But what about early returns? Rust does have a keyword for that, `return`:\n+\n+```{rust}\n+fn foo(x: i32) -> i32 {\n+    if x < 5 { return x; }\n+\n+    x + 1\n+}\n+```\n+\n+Using a `return` as the last line of a function works, but is considered poor\n+style:\n+\n+```{rust}\n+fn foo(x: i32) -> i32 {\n+    if x < 5 { return x; }\n+\n+    return x + 1;\n+}\n+```\n+\n+There are some additional ways to define functions, but they involve features\n+that we haven't learned about yet, so let's just leave it at that for now."}, {"sha": "137b66ea15af0d213e31ae8d0f2a5e63cbfd6f4b", "filename": "src/doc/trpl/generics.md", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,177 @@\n+% Generics\n+\n+Sometimes, when writing a function or data type, we may want it to work for\n+multiple types of arguments. For example, remember our `OptionalInt` type?\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(int),\n+    Missing,\n+}\n+```\n+\n+If we wanted to also have an `OptionalFloat64`, we would need a new enum:\n+\n+```{rust}\n+enum OptionalFloat64 {\n+    Valuef64(f64),\n+    Missingf64,\n+}\n+```\n+\n+This is really unfortunate. Luckily, Rust has a feature that gives us a better\n+way: generics. Generics are called **parametric polymorphism** in type theory,\n+which means that they are types or functions that have multiple forms (\"poly\"\n+is multiple, \"morph\" is form) over a given parameter (\"parametric\").\n+\n+Anyway, enough with type theory declarations, let's check out the generic form\n+of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+\n+```rust\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+```\n+\n+The `<T>` part, which you've seen a few times before, indicates that this is\n+a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n+we substitute that type for the same type used in the generic. Here's an\n+example of using `Option<T>`, with some extra type annotations:\n+\n+```{rust}\n+let x: Option<int> = Some(5i);\n+```\n+\n+In the type declaration, we say `Option<int>`. Note how similar this looks to\n+`Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n+the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n+Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n+match, we'd get an error:\n+\n+```{rust,ignore}\n+let x: Option<f64> = Some(5i);\n+// error: mismatched types: expected `core::option::Option<f64>`\n+// but found `core::option::Option<int>` (expected f64 but found int)\n+```\n+\n+That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n+match up:\n+\n+```{rust}\n+let x: Option<int> = Some(5i);\n+let y: Option<f64> = Some(5.0f64);\n+```\n+\n+This is just fine. One definition, multiple uses.\n+\n+Generics don't have to only be generic over one type. Consider Rust's built-in\n+`Result<T, E>` type:\n+\n+```{rust}\n+enum Result<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+```\n+\n+This type is generic over _two_ types: `T` and `E`. By the way, the capital letters\n+can be any letter you'd like. We could define `Result<T, E>` as:\n+\n+```{rust}\n+enum Result<H, N> {\n+    Ok(H),\n+    Err(N),\n+}\n+```\n+\n+if we wanted to. Convention says that the first generic parameter should be\n+`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+\n+The `Result<T, E>` type is intended to\n+be used to return the result of a computation, and to have the ability to\n+return an error if it didn't work out. Here's an example:\n+\n+```{rust}\n+let x: Result<f64, String> = Ok(2.3f64);\n+let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n+```\n+\n+This particular Result will return an `f64` if there's a success, and a\n+`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n+\n+```{rust}\n+fn inverse(x: f64) -> Result<f64, String> {\n+    if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0f64 / x)\n+}\n+```\n+\n+We don't want to take the inverse of zero, so we check to make sure that we\n+weren't passed zero. If we were, then we return an `Err`, with a message. If\n+it's okay, we return an `Ok`, with the answer.\n+\n+Why does this matter? Well, remember how `match` does exhaustive matches?\n+Here's how this function gets used:\n+\n+```{rust}\n+# fn inverse(x: f64) -> Result<f64, String> {\n+#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+#     Ok(1.0f64 / x)\n+# }\n+let x = inverse(25.0f64);\n+\n+match x {\n+    Ok(x) => println!(\"The inverse of 25 is {}\", x),\n+    Err(msg) => println!(\"Error: {}\", msg),\n+}\n+```\n+\n+The `match` enforces that we handle the `Err` case. In addition, because the\n+answer is wrapped up in an `Ok`, we can't just use the result without doing\n+the match:\n+\n+```{rust,ignore}\n+let x = inverse(25.0f64);\n+println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied\n+           // to type `core::result::Result<f64,collections::string::String>`\n+```\n+\n+This function is great, but there's one other problem: it only works for 64 bit\n+floating point values. What if we wanted to handle 32 bit floating point as\n+well? We'd have to write this:\n+\n+```{rust}\n+fn inverse32(x: f32) -> Result<f32, String> {\n+    if x == 0.0f32 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0f32 / x)\n+}\n+```\n+\n+Bummer. What we need is a **generic function**. Luckily, we can write one!\n+However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n+A generic version of `inverse` would look something like this:\n+\n+```{rust,ignore}\n+fn inverse<T>(x: T) -> Result<T, String> {\n+    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0 / x)\n+}\n+```\n+\n+Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n+We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n+of the `Result` has type `T`. However, if we try to compile that example, we'll get\n+an error:\n+\n+```text\n+error: binary operation `==` cannot be applied to type `T`\n+```\n+\n+Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n+and therefore, the first line would be wrong. What do we do?\n+\n+To fix this example, we need to learn about another Rust feature: traits."}, {"sha": "2847964f15f5018e427f31869dadde16570ab728", "filename": "src/doc/trpl/guessing-game.md", "status": "added", "additions": 891, "deletions": 0, "changes": 891, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,891 @@\n+% Guessing Game\n+\n+Okay! We've got the basics of Rust down. Let's write a bigger program.\n+\n+For our first project, we'll implement a classic beginner programming problem:\n+the guessing game. Here's how it works: Our program will generate a random\n+integer between one and a hundred. It will then prompt us to enter a guess.\n+Upon entering our guess, it will tell us if we're too low or too high. Once we\n+guess correctly, it will congratulate us. Sound good?\n+\n+## Set up\n+\n+Let's set up a new project. Go to your projects directory. Remember how we\n+had to create our directory structure and a `Cargo.toml` for `hello_world`? Cargo\n+has a command that does that for us. Let's give it a shot:\n+\n+```{bash}\n+$ cd ~/projects\n+$ cargo new guessing_game --bin\n+$ cd guessing_game\n+```\n+\n+We pass the name of our project to `cargo new`, and then the `--bin` flag,\n+since we're making a binary, rather than a library.\n+\n+Check out the generated `Cargo.toml`:\n+\n+```toml\n+[package]\n+\n+name = \"guessing_game\"\n+version = \"0.0.1\"\n+authors = [\"Your Name <you@example.com>\"]\n+```\n+\n+Cargo gets this information from your environment. If it's not correct, go ahead\n+and fix that.\n+\n+Finally, Cargo generated a \"Hello, world!\" for us. Check out `src/main.rs`:\n+\n+```{rust}\n+fn main() {\n+    println!(\"Hello, world!\")\n+}\n+```\n+\n+Let's try compiling what Cargo gave us:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+```\n+\n+Excellent! Open up your `src/main.rs` again. We'll be writing all of\n+our code in this file. We'll talk about multiple-file projects later on in the\n+guide.\n+\n+Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n+is kind of like `cargo build`, but it also then runs the produced executable.\n+Try it out:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Hello, world!\n+```\n+\n+Great! The `run` command comes in handy when you need to rapidly iterate on a project.\n+Our game is just such a project, we need to quickly test each iteration before moving on to the next one.\n+\n+## Processing a Guess\n+\n+Let's get to it! The first thing we need to do for our guessing game is\n+allow our player to input a guess. Put this in your `src/main.rs`:\n+\n+```{rust,no_run}\n+use std::io;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+You've seen this code before, when we talked about standard input. We\n+import the `std::io` module with `use`, and then our `main` function contains\n+our program's logic. We print a little message announcing the game, ask the\n+user to input a guess, get their input, and then print it out.\n+\n+Because we talked about this in the section on standard I/O, I won't go into\n+more details here. If you need a refresher, go re-read that section.\n+\n+## Generating a secret number\n+\n+Next, we need to generate a secret number. To do that, we need to use Rust's\n+random number generation, which we haven't talked about yet. Rust includes a\n+bunch of interesting functions in its standard library. If you need a bit of\n+code, it's possible that it's already been written for you! In this case,\n+we do know that Rust has random number generation, but we don't know how to\n+use it.\n+\n+Enter the docs. Rust has a page specifically to document the standard library.\n+You can find that page [here](../std/index.html). There's a lot of information on\n+that page, but the best part is the search bar. Right up at the top, there's\n+a box that you can enter in a search term. The search is pretty primitive\n+right now, but is getting better all the time. If you type 'random' in that\n+box, the page will update to [this one](../std/index.html?search=random). The very\n+first result is a link to [`std::rand::random`](../std/rand/fn.random.html). If we\n+click on that result, we'll be taken to its documentation page.\n+\n+This page shows us a few things: the type signature of the function, some\n+explanatory text, and then an example. Let's try to modify our code to add in the\n+`random` function and see what happens:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random() % 100) + 1; // secret_number: i32\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+The first thing we changed was to `use std::rand`, as the docs\n+explained.  We then added in a `let` expression to create a variable binding\n+named `secret_number`, and we printed out its result.\n+\n+Also, you may wonder why we are using `%` on the result of `rand::random()`.\n+This operator is called 'modulo', and it returns the remainder of a division.\n+By taking the modulo of the result of `rand::random()`, we're limiting the\n+values to be between 0 and 99. Then, we add one to the result, making it from 1\n+to 100. Using modulo can give you a very, very small bias in the result, but\n+for this example, it is not important.\n+\n+Let's try to compile this using `cargo build`:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+src/main.rs:7:26: 7:34 error: the type of this value must be known in this context\n+src/main.rs:7     let secret_number = (rand::random() % 100) + 1;\n+                                       ^~~~~~~~\n+error: aborting due to previous error\n+```\n+\n+It didn't work! Rust says \"the type of this value must be known in this\n+context.\" What's up with that? Well, as it turns out, `rand::random()` can\n+generate many kinds of random values, not just integers. And in this case, Rust\n+isn't sure what kind of value `random()` should generate. So we have to help\n+it. With number literals, we can just add an `i32` onto the end to tell Rust they're\n+integers, but that does not work with functions. There's a different syntax,\n+and it looks like this:\n+\n+```{rust,ignore}\n+rand::random::<i32>();\n+```\n+\n+This says \"please give me a random `i32` value.\" We can change our code to use\n+this hint:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<i32>() % 100) + 1;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+Try running our new program a few times:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 7\n+Please input your guess.\n+4\n+You guessed: 4\n+$ ./target/guessing_game\n+Guess the number!\n+The secret number is: 83\n+Please input your guess.\n+5\n+You guessed: 5\n+$ ./target/guessing_game\n+Guess the number!\n+The secret number is: -29\n+Please input your guess.\n+42\n+You guessed: 42\n+```\n+\n+Wait. Negative 29? We wanted a number between one and a hundred! We have two\n+options here: we can either ask `random()` to generate an unsigned integer, which\n+can only be positive, or we can use the `abs()` function. Let's go with the\n+unsigned integer approach. If we want a random positive number, we should ask for\n+a random positive number. Our code looks like this now:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+And trying it out:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 57\n+Please input your guess.\n+3\n+You guessed: 3\n+```\n+\n+Great! Next up: let's compare our guess to the secret guess.\n+\n+## Comparing guesses\n+\n+If you remember, earlier in the guide, we made a `cmp` function that compared\n+two numbers. Let's add that in, along with a `match` statement to compare our\n+guess to the secret number:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+\n+    match cmp(input, secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+If we try to compile, we'll get some errors:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+src/main.rs:20:15: 20:20 error: mismatched types: expected `i32` but found `collections::string::String` (expected i32 but found struct collections::string::String)\n+src/main.rs:20     match cmp(input, secret_number) {\n+                             ^~~~~\n+src/main.rs:20:22: 20:35 error: mismatched types: expected `i32` but found `uint` (expected i32 but found uint)\n+src/main.rs:20     match cmp(input, secret_number) {\n+                                    ^~~~~~~~~~~~~\n+error: aborting due to 2 previous errors\n+```\n+\n+This often happens when writing Rust programs, and is one of Rust's greatest\n+strengths. You try out some code, see if it compiles, and Rust tells you that\n+you've done something wrong. In this case, our `cmp` function works on integers,\n+but we've given it unsigned integers. In this case, the fix is easy, because\n+we wrote the `cmp` function! Let's change it to take `uint`s:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+\n+    match cmp(input, secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+And try compiling again:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+src/main.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String)\n+src/main.rs:20     match cmp(input, secret_number) {\n+                             ^~~~~\n+error: aborting due to previous error\n+```\n+\n+This error is similar to the last one: we expected to get a `uint`, but we got\n+a `String` instead! That's because our `input` variable is coming from the\n+standard input, and you can guess anything. Try it:\n+\n+```bash\n+$ ./target/guessing_game\n+Guess the number!\n+The secret number is: 73\n+Please input your guess.\n+hello\n+You guessed: hello\n+```\n+\n+Oops! Also, you'll note that we just ran our program even though it didn't compile.\n+This works because the older version we did successfully compile was still lying\n+around. Gotta be careful!\n+\n+Anyway, we have a `String`, but we need a `uint`. What to do? Well, there's\n+a function for that:\n+\n+```{rust,ignore}\n+let input = io::stdin().read_line()\n+                       .ok()\n+                       .expect(\"Failed to read line\");\n+let input_num: Option<uint> = input.parse();\n+```\n+\n+The `parse` function takes in a `&str` value and converts it into something.\n+We tell it what kind of something with a type hint. Remember our type hint with\n+`random()`? It looked like this:\n+\n+```{rust,ignore}\n+rand::random::<uint>();\n+```\n+\n+There's an alternate way of providing a hint too, and that's declaring the type\n+in a `let`:\n+\n+```{rust,ignore}\n+let x: uint = rand::random();\n+```\n+\n+In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n+tell `random()` what to generate. In a similar fashion, both of these work:\n+\n+```{rust,ignore}\n+let input_num = \"5\".parse::<uint>();         // input_num: Option<uint>\n+let input_num: Option<uint> = \"5\".parse();   // input_num: Option<uint>\n+```\n+\n+Anyway, with us now converting our input to a number, our code looks like this:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = input.parse();\n+\n+    println!(\"You guessed: {}\", input_num);\n+\n+    match cmp(input_num, secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+Let's try it out!\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+src/main.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option<uint>` (expected uint but found enum core::option::Option)\n+src/main.rs:22     match cmp(input_num, secret_number) {\n+                             ^~~~~~~~~\n+error: aborting due to previous error\n+```\n+\n+Oh yeah! Our `input_num` has the type `Option<uint>`, rather than `uint`. We\n+need to unwrap the Option. If you remember from before, `match` is a great way\n+to do that. Try this code:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = input.parse();\n+\n+    let num = match input_num {\n+        Some(num) => num,\n+        None      => {\n+            println!(\"Please input a number!\");\n+            return;\n+        }\n+    };\n+\n+\n+    println!(\"You guessed: {}\", num);\n+\n+    match cmp(num, secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+We use a `match` to either give us the `uint` inside of the `Option`, or else\n+print an error message and return. Let's give this a shot:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 17\n+Please input your guess.\n+5\n+Please input a number!\n+```\n+\n+Uh, what? But we did!\n+\n+... actually, we didn't. See, when you get a line of input from `stdin()`,\n+you get all the input. Including the `\\n` character from you pressing Enter.\n+Therefore, `parse()` sees the string `\"5\\n\"` and says \"nope, that's not a\n+number; there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n+method we can use defined on them: `trim()`. One small modification, and our\n+code looks like this:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = input.trim().parse();\n+\n+    let num = match input_num {\n+        Some(num) => num,\n+        None      => {\n+            println!(\"Please input a number!\");\n+            return;\n+        }\n+    };\n+\n+\n+    println!(\"You guessed: {}\", num);\n+\n+    match cmp(num, secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+Let's try it!\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 58\n+Please input your guess.\n+  76\n+You guessed: 76\n+Too big!\n+```\n+\n+Nice! You can see I even added spaces before my guess, and it still figured\n+out that I guessed 76. Run the program a few times, and verify that guessing\n+the number works, as well as guessing a number too small.\n+\n+The Rust compiler helped us out quite a bit there! This technique is called\n+\"lean on the compiler\", and it's often useful when working on some code. Let\n+the error messages help guide you towards the correct types.\n+\n+Now we've got most of the game working, but we can only make one guess. Let's\n+change that by adding loops!\n+\n+## Looping\n+\n+As we already discussed, the `loop` keyword gives us an infinite loop.\n+Let's add that in:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = input.trim().parse();\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                return;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => println!(\"You win!\"),\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+And try it out. But wait, didn't we just add an infinite loop? Yup. Remember\n+that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 59\n+Please input your guess.\n+45\n+You guessed: 45\n+Too small!\n+Please input your guess.\n+60\n+You guessed: 60\n+Too big!\n+Please input your guess.\n+59\n+You guessed: 59\n+You win!\n+Please input your guess.\n+quit\n+Please input a number!\n+```\n+\n+Ha! `quit` actually quits. As does any other non-number input. Well, this is\n+suboptimal to say the least. First, let's actually quit when you win the game:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = input.trim().parse();\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                return;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+By adding the `return` line after the `You win!`, we'll exit the program when\n+we win. We have just one more tweak to make: when someone inputs a non-number,\n+we don't want to quit, we just want to ignore it. Change that `return` to\n+`continue`:\n+\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = input.trim().parse();\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                continue;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+Now we should be good! Let's try:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 61\n+Please input your guess.\n+10\n+You guessed: 10\n+Too small!\n+Please input your guess.\n+99\n+You guessed: 99\n+Too big!\n+Please input your guess.\n+foo\n+Please input a number!\n+Please input your guess.\n+61\n+You guessed: 61\n+You win!\n+```\n+\n+Awesome! With one tiny last tweak, we have finished the guessing game. Can you\n+think of what it is? That's right, we don't want to print out the secret number.\n+It was good for testing, but it kind of ruins the game. Here's our final source:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+use std::cmp::Ordering;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = input.trim().parse();\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                continue;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+```\n+\n+## Complete!\n+\n+At this point, you have successfully built the Guessing Game! Congratulations!\n+\n+You've now learned the basic syntax of Rust. All of this is relatively close to\n+various other programming languages you have used in the past. These\n+fundamental syntactical and semantic elements will form the foundation for the\n+rest of your Rust education.\n+\n+Now that you're an expert at the basics, it's time to learn about some of\n+Rust's more unique features."}, {"sha": "d8acd95b59d8fcd99934b29f945b59315e62d4bf", "filename": "src/doc/trpl/hello-cargo.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,108 @@\n+% Hello, Cargo!\n+\n+[Cargo](http://crates.io) is a tool that Rustaceans use to help manage their\n+Rust projects. Cargo is currently in an alpha state, just like Rust, and so it\n+is still a work in progress. However, it is already good enough to use for many\n+Rust projects, and so it is assumed that Rust projects will use Cargo from the\n+beginning.\n+\n+Cargo manages three things: building your code, downloading the dependencies\n+your code needs, and building the dependencies your code needs.  At first, your\n+program doesn't have any dependencies, so we'll only be using the first part of\n+its functionality. Eventually, we'll add more. Since we started off by using\n+Cargo, it'll be easy to add later.\n+\n+If you installed Rust via the official installers you will also have\n+Cargo. If you installed Rust some other way, you may want to [check\n+the Cargo\n+README](https://github.com/rust-lang/cargo#installing-cargo-from-nightlies)\n+for specific instructions about installing it.\n+\n+Let's convert Hello World to Cargo.\n+\n+To Cargo-ify our project, we need to do two things: Make a `Cargo.toml`\n+configuration file, and put our source file in the right place. Let's\n+do that part first:\n+\n+```{bash}\n+$ mkdir src\n+$ mv main.rs src/main.rs\n+```\n+\n+Cargo expects your source files to live inside a `src` directory. That leaves\n+the top level for other things, like READMEs, license information, and anything\n+not related to your code. Cargo helps us keep our projects nice and tidy. A\n+place for everything, and everything in its place.\n+\n+Next, our configuration file:\n+\n+```{bash}\n+$ editor Cargo.toml\n+```\n+\n+Make sure to get this name right: you need the capital `C`!\n+\n+Put this inside:\n+\n+```toml\n+[package]\n+\n+name = \"hello_world\"\n+version = \"0.0.1\"\n+authors = [ \"Your name <you@example.com>\" ]\n+\n+[[bin]]\n+\n+name = \"hello_world\"\n+```\n+\n+This file is in the [TOML](https://github.com/toml-lang/toml) format. Let's let\n+it explain itself to you:\n+\n+> TOML aims to be a minimal configuration file format that's easy to read due\n+> to obvious semantics. TOML is designed to map unambiguously to a hash table.\n+> TOML should be easy to parse into data structures in a wide variety of\n+> languages.\n+\n+TOML is very similar to INI, but with some extra goodies.\n+\n+Anyway, there are two **table**s in this file: `package` and `bin`. The first\n+tells Cargo metadata about your package. The second tells Cargo that we're\n+interested in building a binary, not a library (though we could do both!), as\n+well as what it is named.\n+\n+Once you have this file in place, we should be ready to build! Try this:\n+\n+```{bash}\n+$ cargo build\n+   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n+$ ./target/hello_world\n+Hello, world!\n+```\n+\n+Bam! We build our project with `cargo build`, and run it with\n+`./target/hello_world`. This hasn't bought us a whole lot over our simple use\n+of `rustc`, but think about the future: when our project has more than one\n+file, we would need to call `rustc` more than once, and pass it a bunch of options to\n+tell it to build everything together. With Cargo, as our project grows, we can\n+just `cargo build` and it'll work the right way.\n+\n+You'll also notice that Cargo has created a new file: `Cargo.lock`.\n+\n+```toml\n+[root]\n+name = \"hello_world\"\n+version = \"0.0.1\"\n+```\n+\n+This file is used by Cargo to keep track of dependencies in your application.\n+Right now, we don't have any, so it's a bit sparse. You won't ever need\n+to touch this file yourself, just let Cargo handle it.\n+\n+That's it! We've successfully built `hello_world` with Cargo. Even though our\n+program is simple, it's using much of the real tooling that you'll use for the\n+rest of your Rust career.\n+\n+Now that you've got the tools down, let's actually learn more about the Rust\n+language itself. These are the basics that will serve you well through the rest\n+of your time with Rust."}, {"sha": "f9cc1ebf0bf13d2ee2c8e1c50b0ab1bf56491e7a", "filename": "src/doc/trpl/hello-world.md", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,164 @@\n+% Hello, world!\n+\n+Now that you have Rust installed, let's write your first Rust program. It's\n+traditional to make your first program in any new language one that prints the\n+text \"Hello, world!\" to the screen. The nice thing about starting with such a\n+simple program is that you can verify that your compiler isn't just installed,\n+but also working properly. And printing information to the screen is a pretty\n+common thing to do.\n+\n+The first thing that we need to do is make a file to put our code in. I like\n+to make a `projects` directory in my home directory, and keep all my projects\n+there. Rust does not care where your code lives.\n+\n+This actually leads to one other concern we should address: this guide will\n+assume that you have basic familiarity with the command line. Rust does not\n+require that you know a whole ton about the command line, but until the\n+language is in a more finished state, IDE support is spotty. Rust makes no\n+specific demands on your editing tooling, or where your code lives.\n+\n+With that said, let's make a directory in our projects directory.\n+\n+```{bash}\n+$ mkdir ~/projects\n+$ cd ~/projects\n+$ mkdir hello_world\n+$ cd hello_world\n+```\n+\n+If you're on Windows and not using PowerShell, the `~` may not work. Consult\n+the documentation for your shell for more details.\n+\n+Let's make a new source file next. I'm going to use the syntax `editor\n+filename` to represent editing a file in these examples, but you should use\n+whatever method you want. We'll call our file `main.rs`:\n+\n+```{bash}\n+$ editor main.rs\n+```\n+\n+Rust files always end in a `.rs` extension. If you're using more than one word\n+in your filename, use an underscore. `hello_world.rs` rather than\n+`helloworld.rs`.\n+\n+Now that you've got your file open, type this in:\n+\n+```{rust}\n+fn main() {\n+    println!(\"Hello, world!\");\n+}\n+```\n+\n+Save the file, and then type this into your terminal window:\n+\n+```{bash}\n+$ rustc main.rs\n+$ ./main # or main.exe on Windows\n+Hello, world!\n+```\n+\n+You can also run these examples on [play.rust-lang.org](http://play.rust-lang.org/) by clicking on the arrow that appears in the upper right of the example when you mouse over the code.\n+\n+Success! Let's go over what just happened in detail.\n+\n+```{rust}\n+fn main() {\n+\n+}\n+```\n+\n+These lines define a **function** in Rust. The `main` function is special:\n+it's the beginning of every Rust program. The first line says \"I'm declaring a\n+function named `main`, which takes no arguments and returns nothing.\" If there\n+were arguments, they would go inside the parentheses (`(` and `)`), and because\n+we aren't returning anything from this function, we've dropped that notation\n+entirely.  We'll get to it later.\n+\n+You'll also note that the function is wrapped in curly braces (`{` and `}`).\n+Rust requires these around all function bodies. It is also considered good\n+style to put the opening curly brace on the same line as the function\n+declaration, with one space in between.\n+\n+Next up is this line:\n+\n+```{rust}\n+    println!(\"Hello, world!\");\n+```\n+\n+This line does all of the work in our little program. There are a number of\n+details that are important here. The first is that it's indented with four\n+spaces, not tabs. Please configure your editor of choice to insert four spaces\n+with the tab key. We provide some [sample configurations for various\n+editors](https://github.com/rust-lang/rust/tree/master/src/etc).\n+\n+The second point is the `println!()` part. This is calling a Rust **macro**,\n+which is how metaprogramming is done in Rust. If it were a function instead, it\n+would look like this: `println()`. For our purposes, we don't need to worry\n+about this difference. Just know that sometimes, you'll see a `!`, and that\n+means that you're calling a macro instead of a normal function. Rust implements\n+`println!` as a macro rather than a function for good reasons, but that's a\n+very advanced topic. You'll learn more when we talk about macros later. One\n+last thing to mention: Rust's macros are significantly different from C macros,\n+if you've used those. Don't be scared of using macros. We'll get to the details\n+eventually, you'll just have to trust us for now.\n+\n+Next, `\"Hello, world!\"` is a **string**. Strings are a surprisingly complicated\n+topic in a systems programming language, and this is a **statically allocated**\n+string. We will talk more about different kinds of allocation later. We pass\n+this string as an argument to `println!`, which prints the string to the\n+screen. Easy enough!\n+\n+Finally, the line ends with a semicolon (`;`). Rust is an **expression\n+oriented** language, which means that most things are expressions. The `;` is\n+used to indicate that this expression is over, and the next one is ready to\n+begin. Most lines of Rust code end with a `;`. We will cover this in-depth\n+later in the guide.\n+\n+Finally, actually **compiling** and **running** our program. We can compile\n+with our compiler, `rustc`, by passing it the name of our source file:\n+\n+```{bash}\n+$ rustc main.rs\n+```\n+\n+This is similar to `gcc` or `clang`, if you come from a C or C++ background. Rust\n+will output a binary executable. You can see it with `ls`:\n+\n+```{bash}\n+$ ls\n+main  main.rs\n+```\n+\n+Or on Windows:\n+\n+```{bash}\n+$ dir\n+main.exe  main.rs\n+```\n+\n+There are now two files: our source code, with the `.rs` extension, and the\n+executable (`main.exe` on Windows, `main` everywhere else)\n+\n+```{bash}\n+$ ./main  # or main.exe on Windows\n+```\n+\n+This prints out our `Hello, world!` text to our terminal.\n+\n+If you come from a dynamically typed language like Ruby, Python, or JavaScript,\n+you may not be used to these two steps being separate. Rust is an\n+**ahead-of-time compiled language**, which means that you can compile a\n+program, give it to someone else, and they don't need to have Rust installed.\n+If you give someone a `.rb` or `.py` or `.js` file, they need to have\n+Ruby/Python/JavaScript installed, but you just need one command to both compile\n+and run your program. Everything is a tradeoff in language design, and Rust has\n+made its choice.\n+\n+Congratulations! You have officially written a Rust program. That makes you a\n+Rust programmer! Welcome.\n+\n+Next, I'd like to introduce you to another tool, Cargo, which is used to write\n+real-world Rust programs. Just using `rustc` is nice for simple things, but as\n+your project grows, you'll want something to help you manage all of the options\n+that it has, and to make it easy to share your code with other people and\n+projects."}, {"sha": "6f81a27b2b7d3031ab4c10bd83191ad5bea3855c", "filename": "src/doc/trpl/if.md", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,141 @@\n+% `if`\n+\n+Rust's take on `if` is not particularly complex, but it's much more like the\n+`if` you'll find in a dynamically typed language than in a more traditional\n+systems language. So let's talk about it, to make sure you grasp the nuances.\n+\n+`if` is a specific form of a more general concept, the 'branch.' The name comes\n+from a branch in a tree: a decision point, where depending on a choice,\n+multiple paths can be taken.\n+\n+In the case of `if`, there is one choice that leads down two paths:\n+\n+```rust\n+let x = 5;\n+\n+if x == 5 {\n+    println!(\"x is five!\");\n+}\n+```\n+\n+If we changed the value of `x` to something else, this line would not print.\n+More specifically, if the expression after the `if` evaluates to `true`, then\n+the block is executed. If it's `false`, then it is not.\n+\n+If you want something to happen in the `false` case, use an `else`:\n+\n+```{rust}\n+let x = 5;\n+\n+if x == 5 {\n+    println!(\"x is five!\");\n+} else {\n+    println!(\"x is not five :(\");\n+}\n+```\n+\n+This is all pretty standard. However, you can also do this:\n+\n+\n+```{rust}\n+let x = 5;\n+\n+let y = if x == 5 {\n+    10\n+} else {\n+    15\n+}; // y: i32\n+```\n+\n+Which we can (and probably should) write like this:\n+\n+```{rust}\n+let x = 5;\n+\n+let y = if x == 5 { 10 } else { 15 }; // y: i32\n+```\n+\n+This reveals two interesting things about Rust: it is an expression-based\n+language, and semicolons are different from semicolons in other 'curly brace\n+and semicolon'-based languages. These two things are related.\n+\n+## Expressions vs. Statements\n+\n+Rust is primarily an expression based language. There are only two kinds of\n+statements, and everything else is an expression.\n+\n+So what's the difference? Expressions return a value, and statements do not.\n+In many languages, `if` is a statement, and therefore, `let x = if ...` would\n+make no sense. But in Rust, `if` is an expression, which means that it returns\n+a value. We can then use this value to initialize the binding.\n+\n+Speaking of which, bindings are a kind of the first of Rust's two statements.\n+The proper name is a **declaration statement**. So far, `let` is the only kind\n+of declaration statement we've seen. Let's talk about that some more.\n+\n+In some languages, variable bindings can be written as expressions, not just\n+statements. Like Ruby:\n+\n+```{ruby}\n+x = y = 5\n+```\n+\n+In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n+following will produce a compile-time error:\n+\n+```{ignore}\n+let x = (let y = 5); // expected identifier, found keyword `let`\n+```\n+\n+The compiler is telling us here that it was expecting to see the beginning of\n+an expression, and a `let` can only begin a statement, not an expression.\n+\n+Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n+expression, although its value is not particularly useful. Unlike C, where an\n+assignment evaluates to the assigned value (e.g. `5` in the previous example),\n+in Rust the value of an assignment is the unit type `()` (which we'll cover later).\n+\n+The second kind of statement in Rust is the **expression statement**. Its\n+purpose is to turn any expression into a statement. In practical terms, Rust's\n+grammar expects statements to follow other statements. This means that you use\n+semicolons to separate expressions from each other. This means that Rust\n+looks a lot like most other languages that require you to use semicolons\n+at the end of every line, and you will see semicolons at the end of almost\n+every line of Rust code you see.\n+\n+What is this exception that makes us say 'almost?' You saw it already, in this\n+code:\n+\n+```{rust}\n+let x = 5;\n+\n+let y: i32 = if x == 5 { 10 } else { 15 };\n+```\n+\n+Note that I've added the type annotation to `y`, to specify explicitly that I\n+want `y` to be an integer.\n+\n+This is not the same as this, which won't compile:\n+\n+```{ignore}\n+let x = 5;\n+\n+let y: i32 = if x == 5 { 10; } else { 15; };\n+```\n+\n+Note the semicolons after the 10 and 15. Rust will give us the following error:\n+\n+```text\n+error: mismatched types: expected `i32` but found `()` (expected i32 but found ())\n+```\n+\n+We expected an integer, but we got `()`. `()` is pronounced 'unit', and is a\n+special type in Rust's type system. In Rust, `()` is _not_ a valid value for a\n+variable of type `i32`. It's only a valid value for variables of the type `()`,\n+which aren't very useful. Remember how we said statements don't return a value?\n+Well, that's the purpose of unit in this case. The semicolon turns any\n+expression into a statement by throwing away its value and returning unit\n+instead.\n+\n+There's one more time in which you won't see a semicolon at the end of a line\n+of Rust code. For that, we'll need our next concept: functions."}, {"sha": "5893b51a4208cb2122cbc48f3c585333dd1bbab2", "filename": "src/doc/trpl/installing-rust.md", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,89 @@\n+% Installing Rust\n+\n+The first step to using Rust is to install it! There are a number of ways to\n+install Rust, but the easiest is to use the `rustup` script. If you're on\n+Linux or a Mac, all you need to do is this (note that you don't need to type\n+in the `$`s, they just indicate the start of each command):\n+\n+```bash\n+$ curl -L https://static.rust-lang.org/rustup.sh | sudo sh\n+```\n+\n+If you're concerned about the [potential insecurity](http://curlpipesh.tumblr.com/) of using `curl | sudo sh`,\n+please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:\n+\n+```bash\n+$ curl -L https://static.rust-lang.org/rustup.sh -O\n+$ sudo sh rustup.sh\n+```\n+\n+If you're on Windows, please download either the [32-bit\n+installer](https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.exe)\n+or the [64-bit\n+installer](https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.exe)\n+and run it.\n+\n+If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n+Not every programming language is great for everyone. Just pass an argument to\n+the script:\n+\n+```bash\n+$ curl -s https://static.rust-lang.org/rustup.sh | sudo sh -s -- --uninstall\n+```\n+\n+If you used the Windows installer, just re-run the `.exe` and it will give you\n+an uninstall option.\n+\n+You can re-run this script any time you want to update Rust. Which, at this\n+point, is often. Rust is still pre-1.0, and so people assume that you're using\n+a very recent Rust.\n+\n+This brings me to one other point: some people, and somewhat rightfully so, get\n+very upset when we tell you to `curl | sudo sh`. And they should be! Basically,\n+when you do this, you are trusting that the good people who maintain Rust\n+aren't going to hack your computer and do bad things. That's a good instinct!\n+If you're one of those people, please check out the documentation on [building\n+Rust from Source](https://github.com/rust-lang/rust#building-from-source), or\n+[the official binary downloads](http://www.rust-lang.org/install.html). And we\n+promise that this method will not be the way to install Rust forever: it's just\n+the easiest way to keep people updated while Rust is in its alpha state.\n+\n+Oh, we should also mention the officially supported platforms:\n+\n+* Windows (7, 8, Server 2008 R2)\n+* Linux (2.6.18 or later, various distributions), x86 and x86-64\n+* OSX 10.7 (Lion) or greater, x86 and x86-64\n+\n+We extensively test Rust on these platforms, and a few others, too, like\n+Android. But these are the ones most likely to work, as they have the most\n+testing.\n+\n+Finally, a comment about Windows. Rust considers Windows to be a first-class\n+platform upon release, but if we're honest, the Windows experience isn't as\n+integrated as the Linux/OS X experience is. We're working on it! If anything\n+does not work, it is a bug. Please let us know if that happens. Each and every\n+commit is tested against Windows just like any other platform.\n+\n+If you've got Rust installed, you can open up a shell, and type this:\n+\n+```bash\n+$ rustc --version\n+```\n+\n+You should see some output that looks something like this:\n+\n+```bash\n+rustc 1.0.0-nightly (f11f3e7ba 2015-01-04 20:02:14 +0000)\n+```\n+\n+If you did, Rust has been installed successfully! Congrats!\n+\n+If not, there are a number of places where you can get help. The easiest is\n+[the #rust IRC channel on irc.mozilla.org](irc://irc.mozilla.org/#rust), which\n+you can access through\n+[Mibbit](http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust). Click\n+that link, and you'll be chatting with other Rustaceans (a silly nickname we\n+call ourselves), and we can help you out. Other great resources include [our\n+forum](http://discuss.rust-lang.org/), [the /r/rust\n+subreddit](http://www.reddit.com/r/rust), and [Stack\n+Overflow](http://stackoverflow.com/questions/tagged/rust)."}, {"sha": "73370a32231ebec4d452ed56f65343959ccf6891", "filename": "src/doc/trpl/intermediate.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fintermediate.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fintermediate.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintermediate.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,7 @@\n+% Intermediate\n+\n+This section contains individual chapters, which are self-contained. They focus\n+on specific topics, and can be read in any order.\n+\n+After reading \"Intermediate,\" you will have a solid understanding of Rust,\n+and will be able to understand most Rust code and write more complex programs."}, {"sha": "a773b7329dbaf376521b83fc0155eeedc148b824", "filename": "src/doc/trpl/iterators.md", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,339 @@\n+% Iterators\n+\n+Let's talk about loops.\n+\n+Remember Rust's `for` loop? Here's an example:\n+\n+```{rust}\n+for x in range(0i, 10i) {\n+    println!(\"{}\", x);\n+}\n+```\n+\n+Now that you know more Rust, we can talk in detail about how this works. The\n+`range` function returns an **iterator**. An iterator is something that we can\n+call the `.next()` method on repeatedly, and it gives us a sequence of things.\n+\n+Like this:\n+\n+```{rust}\n+let mut range = range(0i, 10i);\n+\n+loop {\n+    match range.next() {\n+        Some(x) => {\n+            println!(\"{}\", x);\n+        },\n+        None => { break }\n+    }\n+}\n+```\n+\n+We make a mutable binding to the return value of `range`, which is our iterator.\n+We then `loop`, with an inner `match`. This `match` is used on the result of\n+`range.next()`, which gives us a reference to the next value of the iterator.\n+`next` returns an `Option<int>`, in this case, which will be `Some(int)` when\n+we have a value and `None` once we run out. If we get `Some(int)`, we print it\n+out, and if we get `None`, we `break` out of the loop.\n+\n+This code sample is basically the same as our `for` loop version. The `for`\n+loop is just a handy way to write this `loop`/`match`/`break` construct.\n+\n+`for` loops aren't the only thing that uses iterators, however. Writing your\n+own iterator involves implementing the `Iterator` trait. While doing that is\n+outside of the scope of this guide, Rust provides a number of useful iterators\n+to accomplish various tasks. Before we talk about those, we should talk about a\n+Rust anti-pattern. And that's `range`.\n+\n+Yes, we just talked about how `range` is cool. But `range` is also very\n+primitive. For example, if you needed to iterate over the contents of\n+a vector, you may be tempted to write this:\n+\n+```{rust}\n+let nums = vec![1i, 2i, 3i];\n+\n+for i in range(0u, nums.len()) {\n+    println!(\"{}\", nums[i]);\n+}\n+```\n+\n+This is strictly worse than using an actual iterator. The `.iter()` method on\n+vectors returns an iterator which iterates through a reference to each element\n+of the vector in turn. So write this:\n+\n+```{rust}\n+let nums = vec![1i, 2i, 3i];\n+\n+for num in nums.iter() {\n+    println!(\"{}\", num);\n+}\n+```\n+\n+There are two reasons for this. First, this more directly expresses what we\n+mean. We iterate through the entire vector, rather than iterating through\n+indexes, and then indexing the vector. Second, this version is more efficient:\n+the first version will have extra bounds checking because it used indexing,\n+`nums[i]`. But since we yield a reference to each element of the vector in turn\n+with the iterator, there's no bounds checking in the second example. This is\n+very common with iterators: we can ignore unnecessary bounds checks, but still\n+know that we're safe.\n+\n+There's another detail here that's not 100% clear because of how `println!`\n+works. `num` is actually of type `&int`. That is, it's a reference to an `int`,\n+not an `int` itself. `println!` handles the dereferencing for us, so we don't\n+see it. This code works fine too:\n+\n+```{rust}\n+let nums = vec![1i, 2i, 3i];\n+\n+for num in nums.iter() {\n+    println!(\"{}\", *num);\n+}\n+```\n+\n+Now we're explicitly dereferencing `num`. Why does `iter()` give us references?\n+Well, if it gave us the data itself, we would have to be its owner, which would\n+involve making a copy of the data and giving us the copy. With references,\n+we're just borrowing a reference to the data, and so it's just passing\n+a reference, without needing to do the copy.\n+\n+So, now that we've established that `range` is often not what you want, let's\n+talk about what you do want instead.\n+\n+There are three broad classes of things that are relevant here: iterators,\n+**iterator adapters**, and **consumers**. Here's some definitions:\n+\n+* 'iterators' give you a sequence of values.\n+* 'iterator adapters' operate on an iterator, producing a new iterator with a\n+  different output sequence.\n+* 'consumers' operate on an iterator, producing some final set of values.\n+\n+Let's talk about consumers first, since you've already seen an iterator,\n+`range`.\n+\n+## Consumers\n+\n+A 'consumer' operates on an iterator, returning some kind of value or values.\n+The most common consumer is `collect()`. This code doesn't quite compile,\n+but it shows the intention:\n+\n+```{rust,ignore}\n+let one_to_one_hundred = range(1i, 101i).collect();\n+```\n+\n+As you can see, we call `collect()` on our iterator. `collect()` takes\n+as many values as the iterator will give it, and returns a collection\n+of the results. So why won't this compile? Rust can't determine what\n+type of things you want to collect, and so you need to let it know.\n+Here's the version that does compile:\n+\n+```{rust}\n+let one_to_one_hundred = range(1i, 101i).collect::<Vec<int>>();\n+```\n+\n+If you remember, the `::<>` syntax allows us to give a type hint,\n+and so we tell it that we want a vector of integers.\n+\n+`collect()` is the most common consumer, but there are others too. `find()`\n+is one:\n+\n+```{rust}\n+let greater_than_forty_two = range(0i, 100i)\n+                             .find(|x| *x > 42);\n+\n+match greater_than_forty_two {\n+    Some(_) => println!(\"We got some numbers!\"),\n+    None    => println!(\"No numbers found :(\"),\n+}\n+```\n+\n+`find` takes a closure, and works on a reference to each element of an\n+iterator. This closure returns `true` if the element is the element we're\n+looking for, and `false` otherwise. Because we might not find a matching\n+element, `find` returns an `Option` rather than the element itself.\n+\n+Another important consumer is `fold`. Here's what it looks like:\n+\n+```{rust}\n+let sum = range(1i, 4i)\n+              .fold(0i, |sum, x| sum + x);\n+```\n+\n+`fold()` is a consumer that looks like this:\n+`fold(base, |accumulator, element| ...)`. It takes two arguments: the first\n+is an element called the \"base\". The second is a closure that itself takes two\n+arguments: the first is called the \"accumulator,\" and the second is an\n+\"element.\" Upon each iteration, the closure is called, and the result is the\n+value of the accumulator on the next iteration. On the first iteration, the\n+base is the value of the accumulator.\n+\n+Okay, that's a bit confusing. Let's examine the values of all of these things\n+in this iterator:\n+\n+| base | accumulator | element | closure result |\n+|------|-------------|---------|----------------|\n+| 0i   | 0i          | 1i      | 1i             |\n+| 0i   | 1i          | 2i      | 3i             |\n+| 0i   | 3i          | 3i      | 6i             |\n+\n+We called `fold()` with these arguments:\n+\n+```{rust}\n+# range(1i, 4i)\n+.fold(0i, |sum, x| sum + x);\n+```\n+\n+So, `0i` is our base, `sum` is our accumulator, and `x` is our element.  On the\n+first iteration, we set `sum` to `0i`, and `x` is the first element of `nums`,\n+`1i`. We then add `sum` and `x`, which gives us `0i + 1i = 1i`. On the second\n+iteration, that value becomes our accumulator, `sum`, and the element is\n+the second element of the array, `2i`. `1i + 2i = 3i`, and so that becomes\n+the value of the accumulator for the last iteration. On that iteration,\n+`x` is the last element, `3i`, and `3i + 3i = 6i`, which is our final\n+result for our sum. `1 + 2 + 3 = 6`, and that's the result we got.\n+\n+Whew. `fold` can be a bit strange the first few times you see it, but once it\n+clicks, you can use it all over the place. Any time you have a list of things,\n+and you want a single result, `fold` is appropriate.\n+\n+Consumers are important due to one additional property of iterators we haven't\n+talked about yet: laziness. Let's talk some more about iterators, and you'll\n+see why consumers matter.\n+\n+## Iterators\n+\n+As we've said before, an iterator is something that we can call the\n+`.next()` method on repeatedly, and it gives us a sequence of things.\n+Because you need to call the method, this means that iterators\n+are **lazy** and don't need to generate all of the values upfront.\n+This code, for example, does not actually generate the numbers\n+`1-100`, and just creates a value that represents the sequence:\n+\n+```{rust}\n+let nums = range(1i, 100i);\n+```\n+\n+Since we didn't do anything with the range, it didn't generate the sequence.\n+Let's add the consumer:\n+\n+```{rust}\n+let nums = range(1i, 100i).collect::<Vec<int>>();\n+```\n+\n+Now, `collect()` will require that `range()` give it some numbers, and so\n+it will do the work of generating the sequence.\n+\n+`range` is one of two basic iterators that you'll see. The other is `iter()`,\n+which you've used before. `iter()` can turn a vector into a simple iterator\n+that gives you each element in turn:\n+\n+```{rust}\n+let nums = [1i, 2i, 3i];\n+\n+for num in nums.iter() {\n+   println!(\"{}\", num);\n+}\n+```\n+\n+These two basic iterators should serve you well. There are some more\n+advanced iterators, including ones that are infinite. Like `count`:\n+\n+```{rust}\n+std::iter::count(1i, 5i);\n+```\n+\n+This iterator counts up from one, adding five each time. It will give\n+you a new integer every time, forever (well, technically, until it reaches the\n+maximum number representable by an `int`). But since iterators are lazy,\n+that's okay! You probably don't want to use `collect()` on it, though...\n+\n+That's enough about iterators. Iterator adapters are the last concept\n+we need to talk about with regards to iterators. Let's get to it!\n+\n+## Iterator adapters\n+\n+\"Iterator adapters\" take an iterator and modify it somehow, producing\n+a new iterator. The simplest one is called `map`:\n+\n+```{rust,ignore}\n+range(1i, 100i).map(|x| x + 1i);\n+```\n+\n+`map` is called upon another iterator, and produces a new iterator where each\n+element reference has the closure it's been given as an argument called on it.\n+So this would give us the numbers from `2-100`. Well, almost! If you\n+compile the example, you'll get a warning:\n+\n+```{notrust,ignore}\n+warning: unused result which must be used: iterator adaptors are lazy and\n+         do nothing unless consumed, #[warn(unused_must_use)] on by default\n+ range(1i, 100i).map(|x| x + 1i);\n+ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+Laziness strikes again! That closure will never execute. This example\n+doesn't print any numbers:\n+\n+```{rust,ignore}\n+range(1i, 100i).map(|x| println!(\"{}\", x));\n+```\n+\n+If you are trying to execute a closure on an iterator for its side effects,\n+just use `for` instead.\n+\n+There are tons of interesting iterator adapters. `take(n)` will return an\n+iterator over the next `n` elements of the original iterator, note that this\n+has no side effect on the original iterator. Let's try it out with our infinite\n+iterator from before, `count()`:\n+\n+```{rust}\n+for i in std::iter::count(1i, 5i).take(5) {\n+    println!(\"{}\", i);\n+}\n+```\n+\n+This will print\n+\n+```{notrust,ignore}\n+1\n+6\n+11\n+16\n+21\n+```\n+\n+`filter()` is an adapter that takes a closure as an argument. This closure\n+returns `true` or `false`. The new iterator `filter()` produces\n+only the elements that that closure returns `true` for:\n+\n+```{rust}\n+for i in range(1i, 100i).filter(|&x| x % 2 == 0) {\n+    println!(\"{}\", i);\n+}\n+```\n+\n+This will print all of the even numbers between one and a hundred.\n+(Note that because `filter` doesn't consume the elements that are\n+being iterated over, it is passed a reference to each element, and\n+thus the filter predicate uses the `&x` pattern to extract the integer\n+itself.)\n+\n+You can chain all three things together: start with an iterator, adapt it\n+a few times, and then consume the result. Check it out:\n+\n+```{rust}\n+range(1i, 1000i)\n+    .filter(|&x| x % 2 == 0)\n+    .filter(|&x| x % 3 == 0)\n+    .take(5)\n+    .collect::<Vec<int>>();\n+```\n+\n+This will give you a vector containing `6`, `12`, `18`, `24`, and `30`.\n+\n+This is just a small taste of what iterators, iterator adapters, and consumers\n+can help you with. There are a number of really useful iterators, and you can\n+write your own as well. Iterators provide a safe, efficient way to manipulate\n+all kinds of lists. They're a little unusual at first, but if you play with\n+them, you'll get hooked. For a full list of the different iterators and\n+consumers, check out the [iterator module documentation](../std/iter/index.html)."}, {"sha": "80926c99e872fd78f11a5397b74a92d7e994b49d", "filename": "src/doc/trpl/looping.md", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,133 @@\n+% Looping\n+\n+Looping is the last basic construct that we haven't learned yet in Rust. Rust has\n+two main looping constructs: `for` and `while`.\n+\n+## `for`\n+\n+The `for` loop is used to loop a particular number of times. Rust's `for` loops\n+work a bit differently than in other systems languages, however. Rust's `for`\n+loop doesn't look like this \"C-style\" `for` loop:\n+\n+```{c}\n+for (x = 0; x < 10; x++) {\n+    printf( \"%d\\n\", x );\n+}\n+```\n+\n+Instead, it looks like this:\n+\n+```{rust}\n+for x in range(0, 10) {\n+    println!(\"{}\", x); // x: i32\n+}\n+```\n+\n+In slightly more abstract terms,\n+\n+```{ignore}\n+for var in expression {\n+    code\n+}\n+```\n+\n+The expression is an iterator, which we will discuss in more depth later in the\n+guide. The iterator gives back a series of elements. Each element is one\n+iteration of the loop. That value is then bound to the name `var`, which is\n+valid for the loop body. Once the body is over, the next value is fetched from\n+the iterator, and we loop another time. When there are no more values, the\n+`for` loop is over.\n+\n+In our example, `range` is a function that takes a start and an end position,\n+and gives an iterator over those values. The upper bound is exclusive, though,\n+so our loop will print `0` through `9`, not `10`.\n+\n+Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n+each element of the loop is complicated and error prone, even for experienced C\n+developers.\n+\n+We'll talk more about `for` when we cover **iterator**s, later in the Guide.\n+\n+## `while`\n+\n+The other kind of looping construct in Rust is the `while` loop. It looks like\n+this:\n+\n+```{rust}\n+let mut x = 5u;       // mut x: uint\n+let mut done = false; // mut done: bool\n+\n+while !done {\n+    x += x - 3;\n+    println!(\"{}\", x);\n+    if x % 5 == 0 { done = true; }\n+}\n+```\n+\n+`while` loops are the correct choice when you're not sure how many times\n+you need to loop.\n+\n+If you need an infinite loop, you may be tempted to write this:\n+\n+```{rust,ignore}\n+while true {\n+```\n+\n+However, Rust has a dedicated keyword, `loop`, to handle this case:\n+\n+```{rust,ignore}\n+loop {\n+```\n+\n+Rust's control-flow analysis treats this construct differently than a\n+`while true`, since we know that it will always loop. The details of what\n+that _means_ aren't super important to understand at this stage, but in\n+general, the more information we can give to the compiler, the better it\n+can do with safety and code generation, so you should always prefer\n+`loop` when you plan to loop infinitely.\n+\n+## Ending iteration early\n+\n+Let's take a look at that `while` loop we had earlier:\n+\n+```{rust}\n+let mut x = 5u;\n+let mut done = false;\n+\n+while !done {\n+    x += x - 3;\n+    println!(\"{}\", x);\n+    if x % 5 == 0 { done = true; }\n+}\n+```\n+\n+We had to keep a dedicated `mut` boolean variable binding, `done`, to know\n+when we should exit out of the loop. Rust has two keywords to help us with\n+modifying iteration: `break` and `continue`.\n+\n+In this case, we can write the loop in a better way with `break`:\n+\n+```{rust}\n+let mut x = 5u;\n+\n+loop {\n+    x += x - 3;\n+    println!(\"{}\", x);\n+    if x % 5 == 0 { break; }\n+}\n+```\n+\n+We now loop forever with `loop` and use `break` to break out early.\n+\n+`continue` is similar, but instead of ending the loop, goes to the next\n+iteration. This will only print the odd numbers:\n+\n+```{rust}\n+for x in range(0, 10) {\n+    if x % 2 == 0 { continue; }\n+\n+    println!(\"{}\", x);\n+}\n+```\n+\n+Both `continue` and `break` are valid in both kinds of loops."}, {"sha": "c694806b4bab9f60203f0c485da1160bf611399d", "filename": "src/doc/trpl/macros.md", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -507,7 +507,7 @@ When this library is loaded with `#[use_macros] extern crate`, only `m2` will\n be imported.\n \n The Rust Reference has a [listing of macro-related\n-attributes](reference.html#macro--and-plugin-related-attributes).\n+attributes](../reference.html#macro--and-plugin-related-attributes).\n \n # The variable `$crate`\n \n@@ -567,7 +567,7 @@ intermediate states out, and passing the flag `--pretty expanded` as a\n command-line argument to the compiler will show the result of expansion.\n \n If Rust's macro system can't do what you need, you may want to write a\n-[compiler plugin](guide-plugin.html) instead. Compared to `macro_rules!`\n+[compiler plugin](plugin.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n and the warnings about debugging apply ten-fold. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax", "previous_filename": "src/doc/guide-macros.md"}, {"sha": "c120142cf5c72835a4ad88d21a1e9fd371901b17", "filename": "src/doc/trpl/match.md", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,156 @@\n+% Match\n+\n+Often, a simple `if`/`else` isn't enough, because you have more than two\n+possible options. Also, `else` conditions can get incredibly complicated, so\n+what's the solution?\n+\n+Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n+groupings with something more powerful. Check it out:\n+\n+```{rust}\n+let x = 5;\n+\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    4 => println!(\"four\"),\n+    5 => println!(\"five\"),\n+    _ => println!(\"something else\"),\n+}\n+```\n+\n+`match` takes an expression and then branches based on its value. Each 'arm' of\n+the branch is of the form `val => expression`. When the value matches, that arm's\n+expression will be evaluated. It's called `match` because of the term 'pattern\n+matching', which `match` is an implementation of.\n+\n+So what's the big advantage here? Well, there are a few. First of all, `match`\n+enforces 'exhaustiveness checking'. Do you see that last arm, the one with the\n+underscore (`_`)? If we remove that arm, Rust will give us an error:\n+\n+```text\n+error: non-exhaustive patterns: `_` not covered\n+```\n+\n+In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n+integer, Rust knows that it can have a number of different values \u2013 for example,\n+`6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n+to compile. `_` acts like a 'catch-all arm'. If none of the other arms match,\n+the arm with `_` will, and since we have this catch-all arm, we now have an arm\n+for every possible value of `x`, and so our program will compile successfully.\n+\n+`match` statements also destructure enums, as well. Remember this code from the\n+section on enums?\n+\n+```{rust}\n+use std::cmp::Ordering;\n+\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n+\n+    let ordering = cmp(x, y);\n+\n+    if ordering == Ordering::Less {\n+        println!(\"less\");\n+    } else if ordering == Ordering::Greater {\n+        println!(\"greater\");\n+    } else if ordering == Ordering::Equal {\n+        println!(\"equal\");\n+    }\n+}\n+```\n+\n+We can re-write this as a `match`:\n+\n+```{rust}\n+use std::cmp::Ordering;\n+\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n+\n+    match cmp(x, y) {\n+        Ordering::Less    => println!(\"less\"),\n+        Ordering::Greater => println!(\"greater\"),\n+        Ordering::Equal   => println!(\"equal\"),\n+    }\n+}\n+```\n+\n+This version has way less noise, and it also checks exhaustively to make sure\n+that we have covered all possible variants of `Ordering`. With our `if`/`else`\n+version, if we had forgotten the `Greater` case, for example, our program would\n+have happily compiled. If we forget in the `match`, it will not. Rust helps us\n+make sure to cover all of our bases.\n+\n+`match` expressions also allow us to get the values contained in an `enum`\n+(also known as destructuring) as follows:\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(i32),\n+    Missing,\n+}\n+\n+fn main() {\n+    let x = OptionalInt::Value(5);\n+    let y = OptionalInt::Missing;\n+\n+    match x {\n+        OptionalInt::Value(n) => println!(\"x is {}\", n),\n+        OptionalInt::Missing  => println!(\"x is missing!\"),\n+    }\n+\n+    match y {\n+        OptionalInt::Value(n) => println!(\"y is {}\", n),\n+        OptionalInt::Missing  => println!(\"y is missing!\"),\n+    }\n+}\n+```\n+\n+That is how you can get and use the values contained in `enum`s.\n+It can also allow us to handle errors or unexpected computations; for example, a\n+function that is not guaranteed to be able to compute a result (an `i32` here)\n+could return an `OptionalInt`, and we would handle that value with a `match`.\n+As you can see, `enum` and `match` used together are quite useful!\n+\n+`match` is also an expression, which means we can use it on the right-hand\n+side of a `let` binding or directly where an expression is used. We could\n+also implement the previous example like this:\n+\n+```{rust}\n+use std::cmp::Ordering;\n+\n+fn cmp(a: i32, b: i32) -> Ordering {\n+    if a < b { Ordering::Less }\n+    else if a > b { Ordering::Greater }\n+    else { Ordering::Equal }\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = 10;\n+\n+    println!(\"{}\", match cmp(x, y) {\n+        Ordering::Less    => \"less\",\n+        Ordering::Greater => \"greater\",\n+        Ordering::Equal   => \"equal\",\n+    });\n+}\n+```\n+\n+Sometimes, it's a nice pattern."}, {"sha": "54e9cdf51911583112c93b02afcfc349827b92b4", "filename": "src/doc/trpl/method-syntax.md", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,88 @@\n+% Method Syntax\n+\n+Functions are great, but if you want to call a bunch of them on some data, it\n+can be awkward. Consider this code:\n+\n+```{rust,ignore}\n+baz(bar(foo(x)));\n+```\n+\n+We would read this left-to right, and so we see 'baz bar foo.' But this isn't the\n+order that the functions would get called in, that's inside-out: 'foo bar baz.'\n+Wouldn't it be nice if we could do this instead?\n+\n+```{rust,ignore}\n+x.foo().bar().baz();\n+```\n+\n+Luckily, as you may have guessed with the leading question, you can! Rust provides\n+the ability to use this **method call syntax** via the `impl` keyword.\n+\n+Here's how it works:\n+\n+```{rust}\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+\n+fn main() {\n+    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n+    println!(\"{}\", c.area());\n+}\n+```\n+\n+This will print `12.566371`.\n+\n+We've made a struct that represents a circle. We then write an `impl` block,\n+and inside it, define a method, `area`. Methods take a  special first\n+parameter, `&self`. There are three variants: `self`, `&self`, and `&mut self`.\n+You can think of this first parameter as being the `x` in `x.foo()`. The three\n+variants correspond to the three kinds of thing `x` could be: `self` if it's\n+just a value on the stack, `&self` if it's a reference, and `&mut self` if it's\n+a mutable reference. We should default to using `&self`, as it's the most\n+common.\n+\n+Finally, as you may remember, the value of the area of a circle is `\u03c0*r\u00b2`.\n+Because we took the `&self` parameter to `area`, we can use it just like any\n+other parameter. Because we know it's a `Circle`, we can access the `radius`\n+just like we would with any other struct. An import of \u03c0 and some\n+multiplications later, and we have our area.\n+\n+You can also define methods that do not take a `self` parameter. Here's a\n+pattern that's very common in Rust code:\n+\n+```{rust}\n+# #![allow(non_shorthand_field_patterns)]\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl Circle {\n+    fn new(x: f64, y: f64, radius: f64) -> Circle {\n+        Circle {\n+            x: x,\n+            y: y,\n+            radius: radius,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let c = Circle::new(0.0, 0.0, 2.0);\n+}\n+```\n+\n+This **static method** builds a new `Circle` for us. Note that static methods\n+are called with the `Struct::method()` syntax, rather than the `ref.method()`\n+syntax.\n+"}, {"sha": "3db4da73f932ebf73d8c13a909ffd8d6702a2eff", "filename": "src/doc/trpl/ownership.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "previous_filename": "src/doc/guide-ownership.md"}, {"sha": "282703c43874c1b8479fbcb80069407a8774d915", "filename": "src/doc/trpl/patterns.md", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,199 @@\n+% Patterns\n+\n+We've made use of patterns a few times in the guide: first with `let` bindings,\n+then with `match` statements. Let's go on a whirlwind tour of all of the things\n+patterns can do!\n+\n+A quick refresher: you can match against literals directly, and `_` acts as an\n+'any' case:\n+\n+```{rust}\n+let x = 1i;\n+\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    _ => println!(\"anything\"),\n+}\n+```\n+\n+You can match multiple patterns with `|`:\n+\n+```{rust}\n+let x = 1i;\n+\n+match x {\n+    1 | 2 => println!(\"one or two\"),\n+    3 => println!(\"three\"),\n+    _ => println!(\"anything\"),\n+}\n+```\n+\n+You can match a range of values with `...`:\n+\n+```{rust}\n+let x = 1i;\n+\n+match x {\n+    1 ... 5 => println!(\"one through five\"),\n+    _ => println!(\"anything\"),\n+}\n+```\n+\n+Ranges are mostly used with integers and single characters.\n+\n+If you're matching multiple things, via a `|` or a `...`, you can bind\n+the value to a name with `@`:\n+\n+```{rust}\n+let x = 1i;\n+\n+match x {\n+    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n+}\n+```\n+\n+If you're matching on an enum which has variants, you can use `..` to\n+ignore the value and type in the variant:\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(int),\n+    Missing,\n+}\n+\n+let x = OptionalInt::Value(5i);\n+\n+match x {\n+    OptionalInt::Value(..) => println!(\"Got an int!\"),\n+    OptionalInt::Missing   => println!(\"No such luck.\"),\n+}\n+```\n+\n+You can introduce **match guards** with `if`:\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(int),\n+    Missing,\n+}\n+\n+let x = OptionalInt::Value(5i);\n+\n+match x {\n+    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n+    OptionalInt::Value(..) => println!(\"Got an int!\"),\n+    OptionalInt::Missing   => println!(\"No such luck.\"),\n+}\n+```\n+\n+If you're matching on a pointer, you can use the same syntax as you declared it\n+with. First, `&`:\n+\n+```{rust}\n+let x = &5i;\n+\n+match x {\n+    &val => println!(\"Got a value: {}\", val),\n+}\n+```\n+\n+Here, the `val` inside the `match` has type `int`. In other words, the left-hand\n+side of the pattern destructures the value. If we have `&5i`, then in `&val`, `val`\n+would be `5i`.\n+\n+If you want to get a reference, use the `ref` keyword:\n+\n+```{rust}\n+let x = 5i;\n+\n+match x {\n+    ref r => println!(\"Got a reference to {}\", r),\n+}\n+```\n+\n+Here, the `r` inside the `match` has the type `&int`. In other words, the `ref`\n+keyword _creates_ a reference, for use in the pattern. If you need a mutable\n+reference, `ref mut` will work in the same way:\n+\n+```{rust}\n+let mut x = 5i;\n+\n+match x {\n+    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n+}\n+```\n+\n+If you have a struct, you can destructure it inside of a pattern:\n+\n+```{rust}\n+# #![allow(non_shorthand_field_patterns)]\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+let origin = Point { x: 0i, y: 0i };\n+\n+match origin {\n+    Point { x: x, y: y } => println!(\"({},{})\", x, y),\n+}\n+```\n+\n+If we only care about some of the values, we don't have to give them all names:\n+\n+```{rust}\n+# #![allow(non_shorthand_field_patterns)]\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+let origin = Point { x: 0i, y: 0i };\n+\n+match origin {\n+    Point { x: x, .. } => println!(\"x is {}\", x),\n+}\n+```\n+\n+You can do this kind of match on any member, not just the first:\n+\n+```{rust}\n+# #![allow(non_shorthand_field_patterns)]\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+let origin = Point { x: 0i, y: 0i };\n+\n+match origin {\n+    Point { y: y, .. } => println!(\"y is {}\", y),\n+}\n+```\n+\n+If you want to match against a slice or array, you can use `[]`:\n+\n+```{rust}\n+fn main() {\n+    let v = vec![\"match_this\", \"1\"];\n+\n+    match v.as_slice() {\n+        [\"match_this\", second] => println!(\"The second element is {}\", second),\n+        _ => {},\n+    }\n+}\n+```\n+\n+Whew! That's a lot of different ways to match things, and they can all be\n+mixed and matched, depending on what you're doing:\n+\n+```{rust,ignore}\n+match x {\n+    Foo { x: Some(ref name), y: None } => ...\n+}\n+```\n+\n+Patterns are very powerful.  Make good use of them."}, {"sha": "2a0710d018c4ef3d3369e7efa128e67cabafc67c", "filename": "src/doc/trpl/plugins.md", "status": "renamed", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -5,20 +5,20 @@\n <p>\n <b>Warning:</b> Plugins are an advanced, unstable feature! For many details,\n the only available documentation is the <a\n-href=\"syntax/index.html\"><code>libsyntax</code></a> and <a\n-href=\"rustc/index.html\"><code>librustc</code></a> API docs, or even the source\n+href=\"../syntax/index.html\"><code>libsyntax</code></a> and <a\n+href=\"../rustc/index.html\"><code>librustc</code></a> API docs, or even the source\n code itself. These internal compiler APIs are also subject to change at any\n time.\n </p>\n \n <p>\n For defining new syntax it is often much easier to use Rust's <a\n-href=\"guide-macros.html\">built-in macro system</a>.\n+href=\"macros.html\">built-in macro system</a>.\n </p>\n \n <p style=\"margin-bottom: 0\">\n The code in this document uses language features not covered in the Rust\n-Guide.  See the <a href=\"reference.html\">Reference Manual</a> for more\n+Guide.  See the <a href=\"../reference.html\">Reference Manual</a> for more\n information.\n </p>\n \n@@ -32,19 +32,19 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n A plugin is a dynamic library crate with a designated \"registrar\" function that\n registers extensions with `rustc`. Other crates can use these extensions by\n loading the plugin crate with `#[plugin] extern crate`. See the\n-[`rustc::plugin`](rustc/plugin/index.html) documentation for more about the\n+[`rustc::plugin`](../rustc/plugin/index.html) documentation for more about the\n mechanics of defining and loading a plugin.\n \n Arguments passed as `#[plugin=...]` or `#[plugin(...)]` are not interpreted by\n rustc itself.  They are provided to the plugin through the `Registry`'s [`args`\n-method](rustc/plugin/registry/struct.Registry.html#method.args).\n+method](../rustc/plugin/registry/struct.Registry.html#method.args).\n \n # Syntax extensions\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n is the procedural macro. These are invoked the same way as [ordinary\n-macros](guide-macros.html), but the expansion is performed by arbitrary Rust\n-code that manipulates [syntax trees](syntax/ast/index.html) at\n+macros](macros.html), but the expansion is performed by arbitrary Rust\n+code that manipulates [syntax trees](../syntax/ast/index.html) at\n compile time.\n \n Let's write a plugin\n@@ -126,14 +126,13 @@ The advantages over a simple `fn(&str) -> uint` are:\n   a way to define new literal syntax for any data type.\n \n In addition to procedural macros, you can define new\n-[`deriving`](reference.html#deriving)-like attributes and other kinds of\n+[`deriving`](../reference.html#deriving)-like attributes and other kinds of\n extensions.  See\n-[`Registry::register_syntax_extension`](rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)\n+[`Registry::register_syntax_extension`](../rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)\n and the [`SyntaxExtension`\n enum](http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html).  For\n a more involved macro example, see\n-[`src/libregex_macros/lib.rs`](https://github.com/rust-lang/rust/blob/master/src/libregex_macros/lib.rs)\n-in the Rust distribution.\n+[`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n \n ## Tips and tricks\n@@ -147,7 +146,7 @@ variables of the same name (but different syntax contexts) are in play\n in the same scope. In this case `--pretty expanded,hygiene` will tell\n you about the syntax contexts.\n \n-You can use [`syntax::parse`](syntax/parse/index.html) to turn token trees into\n+You can use [`syntax::parse`](../syntax/parse/index.html) to turn token trees into\n higher-level syntax elements like expressions:\n \n ```ignore\n@@ -163,31 +162,31 @@ Looking through [`libsyntax` parser\n code](https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs)\n will give you a feel for how the parsing infrastructure works.\n \n-Keep the [`Span`s](syntax/codemap/struct.Span.html) of\n+Keep the [`Span`s](../syntax/codemap/struct.Span.html) of\n everything you parse, for better error reporting. You can wrap\n-[`Spanned`](syntax/codemap/struct.Spanned.html) around\n+[`Spanned`](../syntax/codemap/struct.Spanned.html) around\n your custom data structures.\n \n Calling\n-[`ExtCtxt::span_fatal`](syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)\n+[`ExtCtxt::span_fatal`](../syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)\n will immediately abort compilation. It's better to instead call\n-[`ExtCtxt::span_err`](syntax/ext/base/struct.ExtCtxt.html#method.span_err)\n+[`ExtCtxt::span_err`](../syntax/ext/base/struct.ExtCtxt.html#method.span_err)\n and return\n-[`DummyResult`](syntax/ext/base/struct.DummyResult.html),\n+[`DummyResult`](../syntax/ext/base/struct.DummyResult.html),\n so that the compiler can continue and find further errors.\n \n The example above produced an integer literal using\n-[`AstBuilder::expr_uint`](syntax/ext/build/trait.AstBuilder.html#tymethod.expr_uint).\n+[`AstBuilder::expr_uint`](../syntax/ext/build/trait.AstBuilder.html#tymethod.expr_uint).\n As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of\n-[quasiquote macros](syntax/ext/quote/index.html).  They are undocumented and\n+[quasiquote macros](../syntax/ext/quote/index.html).  They are undocumented and\n very rough around the edges.  However, the implementation may be a good\n starting point for an improved quasiquote as an ordinary plugin library.\n \n \n # Lint plugins\n \n Plugins can extend [Rust's lint\n-infrastructure](reference.html#lint-check-attributes) with additional checks for\n+infrastructure](../reference.html#lint-check-attributes) with additional checks for\n code style, safety, etc. You can see\n [`src/test/auxiliary/lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs)\n for a full example, the core of which is reproduced here:\n@@ -236,11 +235,11 @@ foo.rs:4 fn lintme() { }\n The components of a lint plugin are:\n \n * one or more `declare_lint!` invocations, which define static\n-  [`Lint`](rustc/lint/struct.Lint.html) structs;\n+  [`Lint`](../rustc/lint/struct.Lint.html) structs;\n \n * a struct holding any state needed by the lint pass (here, none);\n \n-* a [`LintPass`](rustc/lint/trait.LintPass.html)\n+* a [`LintPass`](../rustc/lint/trait.LintPass.html)\n   implementation defining how to check each syntax element. A single\n   `LintPass` may call `span_lint` for several different `Lint`s, but should\n   register them all through the `get_lints` method.\n@@ -252,7 +251,7 @@ mostly use the same infrastructure as lint plugins, and provide examples of how\n to access type information.\n \n Lints defined by plugins are controlled by the usual [attributes and compiler\n-flags](reference.html#lint-check-attributes), e.g. `#[allow(test_lint)]` or\n+flags](../reference.html#lint-check-attributes), e.g. `#[allow(test_lint)]` or\n `-A test-lint`. These identifiers are derived from the first argument to\n `declare_lint!`, with appropriate case and punctuation conversion.\n ", "previous_filename": "src/doc/guide-plugin.md"}, {"sha": "ad80d2812d07794fa7588184b91b13d8d955b4f4", "filename": "src/doc/trpl/pointers.md", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -409,7 +409,7 @@ test.rs:4         let y = &x;\n \n As you might guess, this kind of analysis is complex for a human, and therefore\n hard for a computer, too! There is an entire [guide devoted to references, ownership,\n-and lifetimes](guide-ownership.html) that goes into this topic in\n+and lifetimes](ownership.html) that goes into this topic in\n great detail, so if you want the full details, check that out.\n \n ## Best practices\n@@ -542,7 +542,7 @@ with some improvements:\n 4. Rust enforces that no other writeable pointers alias to this heap memory,\n    which means writing to an invalid pointer is not possible.\n \n-See the section on references or the [ownership guide](guide-ownership.html)\n+See the section on references or the [ownership guide](ownership.html)\n for more detail on how lifetimes work.\n \n Using boxes and references together is very common. For example:\n@@ -780,6 +780,6 @@ Here's a quick rundown of Rust's pointer types:\n \n # Related resources\n \n-* [API documentation for Box](std/boxed/index.html)\n-* [Ownership guide](guide-ownership.html)\n+* [API documentation for Box](../std/boxed/index.html)\n+* [Ownership guide](ownership.html)\n * [Cyclone paper on regions](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf), which inspired Rust's lifetime system", "previous_filename": "src/doc/guide-pointers.md"}, {"sha": "3d08de40f55aaecdfa3135b647c3971e4c126057", "filename": "src/doc/trpl/rust-book.css", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Frust-book.css", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Frust-book.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frust-book.css?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,59 @@\n+\n+@import url(\"//static.rust-lang.org/doc/master/rust.css\");\n+\n+body {\n+    max-width:none;\n+}\n+\n+#toc {\n+    position: absolute;\n+    left: 0px;\n+    top: 0px;\n+    bottom: 0px;\n+    width: 250px;\n+    overflow-y: auto;\n+    border-right: 1px solid rgba(0, 0, 0, 0.07);\n+    padding: 10px 10px;\n+    font-size: 16px;\n+    background: none repeat scroll 0% 0% #FFF;\n+    box-sizing: border-box;\n+}\n+\n+#page-wrapper {\n+    position: absolute;\n+    overflow-y: auto;\n+    left: 260px;\n+    right: 0px;\n+    top: 0px;\n+    bottom: 0px;\n+    box-sizing: border-box;\n+    background: none repeat scroll 0% 0% #FFF;\n+}\n+\n+#page {\n+    margin-left: auto;\n+    margin-right:auto;\n+    width: 750px;\n+}\n+\n+.chapter {\n+    list-style: none outside none;\n+    padding-left: 0px;\n+    line-height: 30px;\n+}\n+\n+.section {\n+    list-style: none outside none;\n+    padding-left: 20px;\n+    line-height: 30px;\n+}\n+\n+.section li {\n+    text-overflow: ellipsis;\n+    overflow: hidden;\n+    white-space: nowrap;\n+}\n+\n+.chapter li a {\n+    color: #000000;\n+}"}, {"sha": "2d31f06ebaae14317d8bc324d60a17879b21b4ee", "filename": "src/doc/trpl/standard-input.md", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,159 @@\n+% Standard Input\n+\n+Getting input from the keyboard is pretty easy, but uses some things\n+we haven't seen before. Here's a simple program that reads some input,\n+and then prints it back out:\n+\n+```{rust,ignore}\n+fn main() {\n+    println!(\"Type something!\");\n+\n+    let input = std::io::stdin().read_line().ok().expect(\"Failed to read line\");\n+\n+    println!(\"{}\", input);\n+}\n+```\n+\n+Let's go over these chunks, one by one:\n+\n+```{rust,ignore}\n+std::io::stdin();\n+```\n+\n+This calls a function, `stdin()`, that lives inside the `std::io` module. As\n+you can imagine, everything in `std` is provided by Rust, the 'standard\n+library.' We'll talk more about the module system later.\n+\n+Since writing the fully qualified name all the time is annoying, we can use\n+the `use` statement to import it in:\n+\n+```{rust}\n+use std::io::stdin;\n+\n+stdin();\n+```\n+\n+However, it's considered better practice to not import individual functions, but\n+to import the module, and only use one level of qualification:\n+\n+```{rust}\n+use std::io;\n+\n+io::stdin();\n+```\n+\n+Let's update our example to use this style:\n+\n+```{rust,ignore}\n+use std::io;\n+\n+fn main() {\n+    println!(\"Type something!\");\n+\n+    let input = io::stdin().read_line().ok().expect(\"Failed to read line\");\n+\n+    println!(\"{}\", input);\n+}\n+```\n+\n+Next up:\n+\n+```{rust,ignore}\n+.read_line()\n+```\n+\n+The `read_line()` method can be called on the result of `stdin()` to return\n+a full line of input. Nice and easy.\n+\n+```{rust,ignore}\n+.ok().expect(\"Failed to read line\");\n+```\n+\n+Do you remember this code?\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(i32),\n+    Missing,\n+}\n+\n+fn main() {\n+    let x = OptionalInt::Value(5);\n+    let y = OptionalInt::Missing;\n+\n+    match x {\n+        OptionalInt::Value(n) => println!(\"x is {}\", n),\n+        OptionalInt::Missing  => println!(\"x is missing!\"),\n+    }\n+\n+    match y {\n+        OptionalInt::Value(n) => println!(\"y is {}\", n),\n+        OptionalInt::Missing  => println!(\"y is missing!\"),\n+    }\n+}\n+```\n+\n+We had to match each time to see if we had a value or not. In this case,\n+though, we _know_ that `x` has a `Value`, but `match` forces us to handle\n+the `missing` case. This is what we want 99% of the time, but sometimes, we\n+know better than the compiler.\n+\n+Likewise, `read_line()` does not return a line of input. It _might_ return a\n+line of input, though it might also fail to do so. This could happen if our program\n+isn't running in a terminal, but as part of a cron job, or some other context\n+where there's no standard input. Because of this, `read_line` returns a type\n+very similar to our `OptionalInt`: an `IoResult<T>`. We haven't talked about\n+`IoResult<T>` yet because it is the **generic** form of our `OptionalInt`.\n+Until then, you can think of it as being the same thing, just for any type \u2013\n+not just `i32`s.\n+\n+Rust provides a method on these `IoResult<T>`s called `ok()`, which does the\n+same thing as our `match` statement but assumes that we have a valid value.\n+We then call `expect()` on the result, which will terminate our program if we\n+don't have a valid value. In this case, if we can't get input, our program\n+doesn't work, so we're okay with that. In most cases, we would want to handle\n+the error case explicitly. `expect()` allows us to give an error message if\n+this crash happens.\n+\n+We will cover the exact details of how all of this works later in the Guide.\n+For now, this gives you enough of a basic understanding to work with.\n+\n+Back to the code we were working on! Here's a refresher:\n+\n+```{rust,ignore}\n+use std::io;\n+\n+fn main() {\n+    println!(\"Type something!\");\n+\n+    let input = io::stdin().read_line().ok().expect(\"Failed to read line\");\n+\n+    println!(\"{}\", input);\n+}\n+```\n+\n+With long lines like this, Rust gives you some flexibility with the whitespace.\n+We _could_ write the example like this:\n+\n+```{rust,ignore}\n+use std::io;\n+\n+fn main() {\n+    println!(\"Type something!\");\n+\n+                                                  // here, we'll show the types at each step\n+\n+    let input = io::stdin()                       // std::io::stdio::StdinReader\n+                  .read_line()                    // IoResult<String>\n+                  .ok()                           // Option<String>\n+                  .expect(\"Failed to read line\"); // String\n+\n+    println!(\"{}\", input);\n+}\n+```\n+\n+Sometimes, this makes things more readable \u2013 sometimes, less. Use your judgement\n+here.\n+\n+That's all you need to get basic input from the standard input! It's not too\n+complicated, but there are a number of small parts."}, {"sha": "a40e748dae7b09707da1e4d7017218346d07a8d1", "filename": "src/doc/trpl/strings.md", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,79 @@\n+% Strings\n+\n+Strings are an important concept for any programmer to master. Rust's string\n+handling system is a bit different from other languages, due to its systems\n+focus. Any time you have a data structure of variable size, things can get\n+tricky, and strings are a re-sizable data structure. That being said, Rust's\n+strings also work differently than in some other systems languages, such as C.\n+\n+Let's dig into the details. A **string** is a sequence of Unicode scalar values\n+encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n+validly encoded UTF-8 sequences. Additionally, strings are not null-terminated\n+and can contain null bytes.\n+\n+Rust has two main types of strings: `&str` and `String`.\n+\n+The first kind is a `&str`. This is pronounced a 'string slice.' String literals\n+are of the type `&str`:\n+\n+```{rust}\n+let string = \"Hello there.\"; // string: &str\n+```\n+\n+This string is statically allocated, meaning that it's saved inside our\n+compiled program, and exists for the entire duration it runs. The `string`\n+binding is a reference to this statically allocated string. String slices\n+have a fixed size, and cannot be mutated.\n+\n+A `String`, on the other hand, is an in-memory string.  This string is\n+growable, and is also guaranteed to be UTF-8.\n+\n+```{rust}\n+let mut s = \"Hello\".to_string(); // mut s: String\n+println!(\"{}\", s);\n+\n+s.push_str(\", world.\");\n+println!(\"{}\", s);\n+```\n+\n+You can get a `&str` view into a `String` with the `as_slice()` method:\n+\n+```{rust}\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+\n+fn main() {\n+    let s = \"Hello\".to_string();\n+    takes_slice(s.as_slice());\n+}\n+```\n+\n+To compare a String to a constant string, prefer `as_slice()`...\n+\n+```{rust}\n+fn compare(string: String) {\n+    if string.as_slice() == \"Hello\" {\n+        println!(\"yes\");\n+    }\n+}\n+```\n+\n+... over `to_string()`:\n+\n+```{rust}\n+fn compare(string: String) {\n+    if string == \"Hello\".to_string() {\n+        println!(\"yes\");\n+    }\n+}\n+```\n+\n+Viewing a `String` as a `&str` is cheap, but converting the `&str` to a\n+`String` involves allocating memory. No reason to do that unless you have to!\n+\n+That's the basics of strings in Rust! They're probably a bit more complicated\n+than you are used to, if you come from a scripting language, but when the\n+low-level details matter, they really matter. Just remember that `String`s\n+allocate memory and control their data, while `&str`s are a reference to\n+another string, and you'll be all set."}, {"sha": "8e9f40b0f4ec2ab985ca6c7b39d3c44d96c9ccc4", "filename": "src/doc/trpl/tasks.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ftasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ftasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftasks.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -369,7 +369,7 @@ Unlike `spawn`, the function spawned using `try` may return a value, which\n child thread terminates successfully, `try` will return an `Ok` result; if the\n child thread panics, `try` will return an `Error` result.\n \n-[`Result`]: std/result/index.html\n+[`Result`]: ../std/result/index.html\n \n > *Note:* A panicked thread does not currently produce a useful error\n > value (`try` always returns `Err(())`). In the", "previous_filename": "src/doc/guide-tasks.md"}, {"sha": "4c3d93bdfbe5feb70333c8aa1fc7f1b419f66db7", "filename": "src/doc/trpl/testing.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "previous_filename": "src/doc/guide-testing.md"}, {"sha": "04c644da2abbcd8f57145788ab7c0521c54082f8", "filename": "src/doc/trpl/traits.md", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,317 @@\n+% Traits\n+\n+Do you remember the `impl` keyword, used to call a function with method\n+syntax?\n+\n+```{rust}\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+```\n+\n+Traits are similar, except that we define a trait with just the method\n+signature, then implement the trait for that struct. Like this:\n+\n+```{rust}\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+impl HasArea for Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+```\n+\n+As you can see, the `trait` block looks very similar to the `impl` block,\n+but we don't define a body, just a type signature. When we `impl` a trait,\n+we use `impl Trait for Item`, rather than just `impl Item`.\n+\n+So what's the big deal? Remember the error we were getting with our generic\n+`inverse` function?\n+\n+```text\n+error: binary operation `==` cannot be applied to type `T`\n+```\n+\n+We can use traits to constrain our generics. Consider this function, which\n+does not compile, and gives us a similar error:\n+\n+```{rust,ignore}\n+fn print_area<T>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+```\n+\n+Rust complains:\n+\n+```text\n+error: type `T` does not implement any method in scope named `area`\n+```\n+\n+Because `T` can be any type, we can't be sure that it implements the `area`\n+method. But we can add a **trait constraint** to our generic `T`, ensuring\n+that it does:\n+\n+```{rust}\n+# trait HasArea {\n+#     fn area(&self) -> f64;\n+# }\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+```\n+\n+The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n+Because traits define function type signatures, we can be sure that any type\n+which implements `HasArea` will have an `.area()` method.\n+\n+Here's an extended example of how this works:\n+\n+```{rust}\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl HasArea for Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+\n+struct Square {\n+    x: f64,\n+    y: f64,\n+    side: f64,\n+}\n+\n+impl HasArea for Square {\n+    fn area(&self) -> f64 {\n+        self.side * self.side\n+    }\n+}\n+\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    let s = Square {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        side: 1.0f64,\n+    };\n+\n+    print_area(c);\n+    print_area(s);\n+}\n+```\n+\n+This program outputs:\n+\n+```text\n+This shape has an area of 3.141593\n+This shape has an area of 1\n+```\n+\n+As you can see, `print_area` is now generic, but also ensures that we\n+have passed in the correct types. If we pass in an incorrect type:\n+\n+```{rust,ignore}\n+print_area(5i);\n+```\n+\n+We get a compile-time error:\n+\n+```text\n+error: failed to find an implementation of trait main::HasArea for int\n+```\n+\n+So far, we've only added trait implementations to structs, but you can\n+implement a trait for any type. So technically, we _could_ implement\n+`HasArea` for `int`:\n+\n+```{rust}\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+impl HasArea for int {\n+    fn area(&self) -> f64 {\n+        println!(\"this is silly\");\n+\n+        *self as f64\n+    }\n+}\n+\n+5i.area();\n+```\n+\n+It is considered poor style to implement methods on such primitive types, even\n+though it is possible.\n+\n+This may seem like the Wild West, but there are two other restrictions around\n+implementing traits that prevent this from getting out of hand. First, traits\n+must be `use`d in any scope where you wish to use the trait's method. So for\n+example, this does not work:\n+\n+```{rust,ignore}\n+mod shapes {\n+    use std::f64::consts;\n+\n+    trait HasArea {\n+        fn area(&self) -> f64;\n+    }\n+\n+    struct Circle {\n+        x: f64,\n+        y: f64,\n+        radius: f64,\n+    }\n+\n+    impl HasArea for Circle {\n+        fn area(&self) -> f64 {\n+            consts::PI * (self.radius * self.radius)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let c = shapes::Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    println!(\"{}\", c.area());\n+}\n+```\n+\n+Now that we've moved the structs and traits into their own module, we get an\n+error:\n+\n+```text\n+error: type `shapes::Circle` does not implement any method in scope named `area`\n+```\n+\n+If we add a `use` line right above `main` and make the right things public,\n+everything is fine:\n+\n+```{rust}\n+use shapes::HasArea;\n+\n+mod shapes {\n+    use std::f64::consts;\n+\n+    pub trait HasArea {\n+        fn area(&self) -> f64;\n+    }\n+\n+    pub struct Circle {\n+        pub x: f64,\n+        pub y: f64,\n+        pub radius: f64,\n+    }\n+\n+    impl HasArea for Circle {\n+        fn area(&self) -> f64 {\n+            consts::PI * (self.radius * self.radius)\n+        }\n+    }\n+}\n+\n+\n+fn main() {\n+    let c = shapes::Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    println!(\"{}\", c.area());\n+}\n+```\n+\n+This means that even if someone does something bad like add methods to `int`,\n+it won't affect you, unless you `use` that trait.\n+\n+There's one more restriction on implementing traits. Either the trait or the\n+type you're writing the `impl` for must be inside your crate. So, we could\n+implement the `HasArea` type for `int`, because `HasArea` is in our crate.  But\n+if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n+not, because both the trait and the type aren't in our crate.\n+\n+One last thing about traits: generic functions with a trait bound use\n+**monomorphization** (\"mono\": one, \"morph\": form), so they are statically\n+dispatched. What's that mean? Well, let's take a look at `print_area` again:\n+\n+```{rust,ignore}\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle { ... };\n+\n+    let s = Square { ... };\n+\n+    print_area(c);\n+    print_area(s);\n+}\n+```\n+\n+When we use this trait with `Circle` and `Square`, Rust ends up generating\n+two different functions with the concrete type, and replacing the call sites with\n+calls to the concrete implementations. In other words, you get something like\n+this:\n+\n+```{rust,ignore}\n+fn __print_area_circle(shape: Circle) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn __print_area_square(shape: Square) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle { ... };\n+\n+    let s = Square { ... };\n+\n+    __print_area_circle(c);\n+    __print_area_square(s);\n+}\n+```\n+\n+The names don't actually change to this, it's just for illustration. But\n+as you can see, there's no overhead of deciding which version to call here,\n+hence 'statically dispatched.' The downside is that we have two copies of\n+the same function, so our binary is a little bit larger."}, {"sha": "3e0a1ef13454a499225de546fb09c006f63aa091", "filename": "src/doc/trpl/unsafe.md", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@ block which allows the programmer to dodge some of the compiler's\n checks and do a wide range of operations, such as:\n \n - dereferencing [raw pointers](#raw-pointers)\n-- calling a function via FFI ([covered by the FFI guide](guide-ffi.html))\n+- calling a function via FFI ([covered by the FFI guide](ffi.html))\n - casting between types bitwise (`transmute`, aka \"reinterpret cast\")\n - [inline assembly](#inline-assembly)\n \n@@ -37,7 +37,7 @@ build safe interfaces.\n ## References\n \n One of Rust's biggest features is memory safety.  This is achieved in\n-part via [the ownership system](guide-ownership.html), which is how the\n+part via [the ownership system](ownership.html), which is how the\n compiler can guarantee that every `&` reference is always valid, and,\n for example, never pointing to freed memory.\n \n@@ -504,7 +504,7 @@ shouldn't get triggered.\n The second of these three functions, `eh_personality`, is used by the\n failure mechanisms of the compiler. This is often mapped to GCC's\n personality function (see the\n-[libstd implementation](std/rt/unwind/index.html) for more\n+[libstd implementation](../std/rt/unwind/index.html) for more\n information), but crates which do not trigger a panic can be assured\n that this function is never called. The final function, `panic_fmt`, is\n also used by the failure mechanisms of the compiler.\n@@ -517,7 +517,7 @@ also used by the failure mechanisms of the compiler.\n With the above techniques, we've got a bare-metal executable running some Rust\n code. There is a good deal of functionality provided by the standard library,\n however, that is necessary to be productive in Rust. If the standard library is\n-not sufficient, then [libcore](core/index.html) is designed to be used\n+not sufficient, then [libcore](../core/index.html) is designed to be used\n instead.\n \n The core library has very few dependencies and is much more portable than the", "previous_filename": "src/doc/guide-unsafe.md"}, {"sha": "4e2e7bd2fe2f442ca91b7ec63ff2820ff1199abf", "filename": "src/doc/trpl/variable-bindings.md", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,174 @@\n+% Variable bindings\n+\n+The first thing we'll learn about are 'variable bindings.' They look like this:\n+\n+```{rust}\n+fn main() {\n+    let x = 5;\n+}\n+```\n+\n+Putting `fn main() {` in each example is a bit tedious, so we'll leave that out\n+in the future. If you're following along, make sure to edit your `main()`\n+function, rather than leaving it off. Otherwise, you'll get an error.\n+\n+In many languages, this is called a 'variable.' But Rust's variable bindings\n+have a few tricks up their sleeves. Rust has a very powerful feature called\n+'pattern matching' that we'll get into detail with later, but the left\n+hand side of a `let` expression is a full pattern, not just a variable name.\n+This means we can do things like:\n+\n+```{rust}\n+let (x, y) = (1, 2);\n+```\n+\n+After this expression is evaluated, `x` will be one, and `y` will be two.\n+Patterns are really powerful, but this is about all we can do with them so far.\n+So let's just keep this in the back of our minds as we go forward.\n+\n+Rust is a statically typed language, which means that we specify our types up\n+front. So why does our first example compile? Well, Rust has this thing called\n+\"type inference.\" If it can figure out what the type of something is, Rust\n+doesn't require you to actually type it out.\n+\n+We can add the type if we want to, though. Types come after a colon (`:`):\n+\n+```{rust}\n+let x: i32 = 5;\n+```\n+\n+If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n+is a binding with the type `i32` and the value `five`.\"\n+\n+In future examples, we may annotate the type in a comment. The examples will\n+look like this:\n+\n+```{rust}\n+fn main() {\n+    let x = 5; // x: i32\n+}\n+```\n+\n+Note the similarities between this annotation and the syntax you use with `let`.\n+Including these kinds of comments is not idiomatic Rust, but we'll occasionally\n+include them to help you understand what the types that Rust infers are.\n+\n+By default, bindings are **immutable**. This code will not compile:\n+\n+```{ignore}\n+let x = 5;\n+x = 10;\n+```\n+\n+It will give you this error:\n+\n+```text\n+error: re-assignment of immutable variable `x`\n+     x = 10;\n+     ^~~~~~~\n+```\n+\n+If you want a binding to be mutable, you can use `mut`:\n+\n+```{rust}\n+let mut x = 5; // mut x: i32\n+x = 10;\n+```\n+\n+There is no single reason that bindings are immutable by default, but we can\n+think about it through one of Rust's primary focuses: safety. If you forget to\n+say `mut`, the compiler will catch it, and let you know that you have mutated\n+something you may not have intended to mutate. If bindings were mutable by\n+default, the compiler would not be able to tell you this. If you _did_ intend\n+mutation, then the solution is quite easy: add `mut`.\n+\n+There are other good reasons to avoid mutable state when possible, but they're\n+out of the scope of this guide. In general, you can often avoid explicit\n+mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n+what you need, so it's not verboten.\n+\n+Let's get back to bindings. Rust variable bindings have one more aspect that\n+differs from other languages: bindings are required to be initialized with a\n+value before you're allowed to use them. If we try...\n+\n+```{ignore}\n+let x;\n+```\n+\n+...we'll get an error:\n+\n+```text\n+src/main.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type\n+src/main.rs:2     let x;\n+                      ^\n+```\n+\n+Giving it a type will compile, though:\n+\n+```{rust}\n+let x: i32;\n+```\n+\n+Let's try it out. Change your `src/main.rs` file to look like this:\n+\n+```{rust}\n+fn main() {\n+    let x: i32;\n+\n+    println!(\"Hello world!\");\n+}\n+```\n+\n+You can use `cargo build` on the command line to build it. You'll get a warning,\n+but it will still print \"Hello, world!\":\n+\n+```text\n+   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n+src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n+src/main.rs:2     let x: i32;\n+                      ^\n+```\n+\n+Rust warns us that we never use the variable binding, but since we never use it,\n+no harm, no foul. Things change if we try to actually use this `x`, however. Let's\n+do that. Change your program to look like this:\n+\n+```{rust,ignore}\n+fn main() {\n+    let x: i32;\n+\n+    println!(\"The value of x is: {}\", x);\n+}\n+```\n+\n+And try to build it. You'll get an error:\n+\n+```{bash}\n+$ cargo build\n+   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n+src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\n+src/main.rs:4     println!(\"The value of x is: {}\", x);\n+                                                    ^\n+note: in expansion of format_args!\n+<std macros>:2:23: 2:77 note: expansion site\n+<std macros>:1:1: 3:2 note: in expansion of println!\n+src/main.rs:4:5: 4:42 note: expansion site\n+error: aborting due to previous error\n+Could not compile `hello_world`.\n+```\n+\n+Rust will not let us use a value that has not been initialized. Next, let's\n+talk about this stuff we've added to `println!`.\n+\n+If you include two curly braces (`{}`, some call them moustaches...) in your\n+string to print, Rust will interpret this as a request to interpolate some sort\n+of value. **String interpolation** is a computer science term that means \"stick\n+in the middle of a string.\" We add a comma, and then `x`, to indicate that we\n+want `x` to be the value we're interpolating. The comma is used to separate\n+arguments we pass to functions and macros, if you're passing more than one.\n+\n+When you just use the curly braces, Rust will attempt to display the\n+value in a meaningful way by checking out its type. If you want to specify the\n+format in a more detailed manner, there are a [wide number of options\n+available](../std/fmt/index.html). For now, we'll just stick to the default:\n+integers aren't very complicated to print."}, {"sha": "290dd21d666a40a36775edd0b882646848fa7bd6", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -126,7 +126,7 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n /// between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[unstable = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -179,7 +179,7 @@ impl<T> Arc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[experimental = \"Weak pointers may not belong in this module.\"]\n+    #[unstable = \"Weak pointers may not belong in this module.\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n         self.inner().weak.fetch_add(1, Relaxed);\n@@ -200,12 +200,12 @@ impl<T> Arc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n #[stable]\n@@ -271,7 +271,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[experimental]\n+    #[unstable]\n     pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as a weak reference, so we only\n         // clone if there is an additional reference of either kind.\n@@ -355,7 +355,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     }\n }\n \n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[unstable = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -393,7 +393,7 @@ impl<T: Sync + Send> Weak<T> {\n     }\n }\n \n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[unstable = \"Weak pointers may not belong in this module.\"]\n impl<T: Sync + Send> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -604,7 +604,7 @@ impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n }\n \n #[cfg(test)]\n-#[allow(experimental)]\n+#[allow(unstable)]\n mod tests {\n     use std::clone::Clone;\n     use std::sync::mpsc::channel;"}, {"sha": "458eb3dce57a80f5bcf48fa06e601f6ceaa79181", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -44,7 +44,7 @@ use core::ops::{Deref, DerefMut};\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n-#[experimental = \"may be renamed; uncertain about custom allocator design\"]\n+#[unstable = \"may be renamed; uncertain about custom allocator design\"]\n pub static HEAP: () = ();\n \n /// A type that represents a uniquely-owned value."}, {"sha": "4a85637625a22ff09465e7b73e83b950ddd32ce3", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -57,7 +57,7 @@\n //! default global allocator. It is not compatible with the libc allocator API.\n \n #![crate_name = \"alloc\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -68,6 +68,7 @@\n #![allow(unknown_features)]\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n #[macro_use]\n extern crate core;"}, {"sha": "f42c6dbdc15a592721d2f7422e53bc2c8e3cb68e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -221,7 +221,7 @@ impl<T> Rc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[experimental = \"Weak pointers may not belong in this module\"]\n+    #[unstable = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak {\n@@ -234,12 +234,12 @@ impl<T> Rc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n@@ -255,7 +255,7 @@ pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n /// rc::is_unique(&five);\n /// ```\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n     weak_count(rc) == 0 && strong_count(rc) == 1\n }\n@@ -277,7 +277,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n /// ```\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n     if is_unique(&rc) {\n         unsafe {\n@@ -311,7 +311,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n     if is_unique(rc) {\n         let inner = unsafe { &mut **rc._ptr };\n@@ -337,7 +337,7 @@ impl<T: Clone> Rc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[experimental]\n+    #[unstable]\n     pub fn make_unique(&mut self) -> &mut T {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n@@ -615,7 +615,7 @@ impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     }\n }\n \n-#[experimental = \"Show is experimental.\"]\n+#[unstable = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Rc({:?})\", **self)\n@@ -635,7 +635,7 @@ impl<T: fmt::String> fmt::String for Rc<T> {\n ///\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[unstable = \"Weak pointers may not belong in this module.\"]\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -644,7 +644,7 @@ pub struct Weak<T> {\n     _noshare: marker::NoSync\n }\n \n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[unstable = \"Weak pointers may not belong in this module.\"]\n impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -717,7 +717,7 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n-#[experimental = \"Weak pointers may not belong in this module.\"]\n+#[unstable = \"Weak pointers may not belong in this module.\"]\n impl<T> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -739,7 +739,7 @@ impl<T> Clone for Weak<T> {\n     }\n }\n \n-#[experimental = \"Show is experimental.\"]\n+#[unstable = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n@@ -780,7 +780,7 @@ impl<T> RcBoxPtr<T> for Weak<T> {\n }\n \n #[cfg(test)]\n-#[allow(experimental)]\n+#[allow(unstable)]\n mod tests {\n     use super::{Rc, Weak, weak_count, strong_count};\n     use std::cell::RefCell;"}, {"sha": "e3d075c0f39b9066ab67db49862c1b2eb150b582", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -20,7 +20,7 @@\n //! more complex, slower arena which can hold objects of any type.\n \n #![crate_name = \"arena\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -32,6 +32,7 @@\n #![feature(unsafe_destructor)]\n #![feature(unboxed_closures)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![allow(missing_docs)]\n \n extern crate alloc;"}, {"sha": "54ab26c4f7763d694b6757f491e0be212003caab", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,7 +14,7 @@\n \n \n #![crate_name = \"collections\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -27,6 +27,7 @@\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n #![feature(old_impl_check)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![no_std]\n \n #[macro_use]"}, {"sha": "9a1f22ef7a643067ae4314c9fe77fbbf01c21775", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -166,7 +166,7 @@ pub trait SliceExt {\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n-    #[experimental = \"uncertain about this API approach\"]\n+    #[unstable = \"uncertain about this API approach\"]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n     /// Returns a subslice spanning the interval [`start`, `end`).\n@@ -175,23 +175,23 @@ pub trait SliceExt {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[experimental = \"will be replaced by slice syntax\"]\n+    #[unstable = \"will be replaced by slice syntax\"]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[experimental = \"will be replaced by slice syntax\"]\n+    #[unstable = \"will be replaced by slice syntax\"]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[experimental = \"will be replaced by slice syntax\"]\n+    #[unstable = \"will be replaced by slice syntax\"]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -284,11 +284,11 @@ pub trait SliceExt {\n     fn first(&self) -> Option<&Self::Item>;\n \n     /// Returns all but the first element of a slice.\n-    #[experimental = \"likely to be renamed\"]\n+    #[unstable = \"likely to be renamed\"]\n     fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n-    #[experimental = \"likely to be renamed\"]\n+    #[unstable = \"likely to be renamed\"]\n     fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n@@ -384,23 +384,23 @@ pub trait SliceExt {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[experimental = \"will be replaced by slice syntax\"]\n+    #[unstable = \"will be replaced by slice syntax\"]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[experimental = \"will be replaced by slice syntax\"]\n+    #[unstable = \"will be replaced by slice syntax\"]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[experimental = \"will be replaced by slice syntax\"]\n+    #[unstable = \"will be replaced by slice syntax\"]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n@@ -412,11 +412,11 @@ pub trait SliceExt {\n     fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns all but the first element of a mutable slice\n-    #[experimental = \"likely to be renamed or removed\"]\n+    #[unstable = \"likely to be renamed or removed\"]\n     fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n-    #[experimental = \"likely to be renamed or removed\"]\n+    #[unstable = \"likely to be renamed or removed\"]\n     fn init_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns a mutable pointer to the last item in the slice.\n@@ -588,7 +588,7 @@ pub trait SliceExt {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    #[experimental]\n+    #[unstable]\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n \n     /// Sorts the slice, in place.\n@@ -677,11 +677,11 @@ pub trait SliceExt {\n     fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Find the first index containing a matching value.\n-    #[experimental]\n+    #[unstable]\n     fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Find the last index containing a matching value.\n-    #[experimental]\n+    #[unstable]\n     fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Return true if the slice contains an element with the given value.\n@@ -697,7 +697,7 @@ pub trait SliceExt {\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Convert `self` into a vector without clones or allocation.\n-    #[experimental]\n+    #[unstable]\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n@@ -1034,7 +1034,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n ///\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n-#[experimental]\n+#[unstable]\n #[derive(Clone)]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n@@ -1046,7 +1046,7 @@ pub struct ElementSwaps {\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[experimental]\n+    #[unstable]\n     pub fn new(length: uint) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the"}, {"sha": "5991fc832e9686d890087d67636b975df8b3837d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -92,7 +92,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n-    #[experimental = \"needs investigation to see if to_string() can match perf\"]\n+    #[unstable = \"needs investigation to see if to_string() can match perf\"]\n     pub fn from_str(string: &str) -> String {\n         String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n     }\n@@ -719,7 +719,7 @@ impl<'a> FromIterator<&'a str> for String {\n     }\n }\n \n-#[experimental = \"waiting on Extend stabilization\"]\n+#[unstable = \"waiting on Extend stabilization\"]\n impl Extend<char> for String {\n     fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n         let (lower_bound, _) = iterator.size_hint();\n@@ -730,7 +730,7 @@ impl Extend<char> for String {\n     }\n }\n \n-#[experimental = \"waiting on Extend stabilization\"]\n+#[unstable = \"waiting on Extend stabilization\"]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n         // A guess that at least one byte per iterator element will be needed.\n@@ -790,7 +790,7 @@ impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[experimental = \"waiting on Str stabilization\"]\n+#[unstable = \"waiting on Str stabilization\"]\n impl Str for String {\n     #[inline]\n     #[stable]\n@@ -814,22 +814,22 @@ impl fmt::String for String {\n     }\n }\n \n-#[experimental = \"waiting on fmt stabilization\"]\n+#[unstable = \"waiting on fmt stabilization\"]\n impl fmt::Show for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(&**self, f)\n     }\n }\n \n-#[experimental = \"waiting on Hash stabilization\"]\n+#[unstable = \"waiting on Hash stabilization\"]\n #[cfg(stage0)]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n-#[experimental = \"waiting on Hash stabilization\"]\n+#[unstable = \"waiting on Hash stabilization\"]\n #[cfg(not(stage0))]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n@@ -887,7 +887,7 @@ impl ops::Deref for String {\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n-#[experimental]\n+#[unstable]\n pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n@@ -914,7 +914,7 @@ impl<'a> Deref for DerefString<'a> {\n /// let string = as_string(\"foo\").clone();\n /// string_consumer(string);\n /// ```\n-#[experimental]\n+#[unstable]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }"}, {"sha": "47afc78bc1213b13ab8496085fa33e660e4ec5a3", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -376,7 +376,7 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n-    #[experimental]\n+    #[unstable]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n@@ -777,7 +777,7 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    #[experimental = \"API may change to provide stronger guarantees\"]\n+    #[unstable = \"API may change to provide stronger guarantees\"]\n     pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n         // size.\n@@ -995,7 +995,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[experimental = \"likely to be replaced by a more optimized extend\"]\n+    #[unstable = \"likely to be replaced by a more optimized extend\"]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n@@ -1200,7 +1200,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[experimental = \"waiting on Index stability\"]\n+#[unstable = \"waiting on Index stability\"]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1304,7 +1304,7 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n-#[experimental = \"waiting on Extend stability\"]\n+#[unstable = \"waiting on Extend stability\"]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n@@ -1457,7 +1457,7 @@ impl<T> Default for Vec<T> {\n     }\n }\n \n-#[experimental = \"waiting on Show stability\"]\n+#[unstable = \"waiting on Show stability\"]\n impl<T: fmt::Show> fmt::Show for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(self.as_slice(), f)\n@@ -1475,7 +1475,7 @@ impl<'a> fmt::Writer for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[experimental = \"unclear how valuable this alias is\"]\n+#[unstable = \"unclear how valuable this alias is\"]\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n@@ -1693,13 +1693,13 @@ impl<'a, T> Drop for Drain<'a, T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n-#[experimental]\n+#[unstable]\n pub struct DerefVec<'a, T> {\n     x: Vec<T>,\n     l: ContravariantLifetime<'a>\n }\n \n-#[experimental]\n+#[unstable]\n impl<'a, T> Deref for DerefVec<'a, T> {\n     type Target = Vec<T>;\n \n@@ -1719,7 +1719,7 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n }\n \n /// Convert a slice to a wrapper type providing a `&Vec<T>` reference.\n-#[experimental]\n+#[unstable]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {"}, {"sha": "797687a9ad96ee6efc577f94ab158995438e84aa", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -89,7 +89,7 @@ use intrinsics::TypeId;\n #[stable]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n-    #[experimental = \"this method will likely be replaced by an associated static\"]\n+    #[unstable = \"this method will likely be replaced by an associated static\"]\n     fn get_type_id(&self) -> TypeId;\n }\n "}, {"sha": "c07fac108d6f390a95fd7a8f8a14d1176bac3792", "filename": "src/libcore/array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n \n-#![experimental] // not yet reviewed\n+#![unstable] // not yet reviewed\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};"}, {"sha": "6db01b7cb7afe67d6d26b12f4f9c0881092ff967", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -202,7 +202,7 @@ impl<T:Copy> Cell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[experimental]\n+    #[unstable]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -332,7 +332,7 @@ impl<T> RefCell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[experimental]\n+    #[unstable]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -424,7 +424,7 @@ impl<'b, T> Deref for Ref<'b, T> {\n ///\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n-#[experimental = \"likely to be moved to a method, pending language changes\"]\n+#[unstable = \"likely to be moved to a method, pending language changes\"]\n pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n         _value: orig._value,"}, {"sha": "ffa6d0855435e2b854f8178d7d507380a88cf029", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -81,7 +81,7 @@ clone_impl! { char }\n \n macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n-        #[experimental = \"this may not be sufficient for fns with region parameters\"]\n+        #[unstable = \"this may not be sufficient for fns with region parameters\"]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Return a copy of a function pointer\n             #[inline]"}, {"sha": "c1f1997df740ea7a2d4061f4979e231c2813c792", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -290,7 +290,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) | Some(Equal) => Some(v1),\n@@ -303,7 +303,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) => Some(v2),"}, {"sha": "a21ec892dd77a64abfc60a564c3268f04ecb6a1c", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -32,7 +32,7 @@\n //! # }\n //! ```\n \n-#![experimental]\n+#![unstable]\n \n use ops::{Drop, FnMut, FnOnce};\n "}, {"sha": "67d5482898ee5f87f9bbfdf08fc4c01e49cdd4aa", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -36,7 +36,7 @@ mod num;\n mod float;\n pub mod rt;\n \n-#[experimental = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable = \"core and I/O reconciliation may alter this definition\"]\n /// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n \n@@ -45,7 +45,7 @@ pub type Result = result::Result<(), Error>;\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-#[experimental = \"core and I/O reconciliation may alter this definition\"]\n+#[unstable = \"core and I/O reconciliation may alter this definition\"]\n #[derive(Copy)]\n pub struct Error;\n \n@@ -58,7 +58,7 @@ pub struct Error;\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n-#[experimental = \"waiting for core and I/O reconciliation\"]\n+#[unstable = \"waiting for core and I/O reconciliation\"]\n pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n@@ -123,7 +123,7 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-#[experimental = \"implementation detail of the `format_args!` macro\"]\n+#[unstable = \"implementation detail of the `format_args!` macro\"]\n #[derive(Copy)]\n pub struct Argument<'a> {\n     value: &'a Void,\n@@ -162,7 +162,7 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[experimental = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable = \"implementation detail of the `format_args!` macro\"]\n     pub fn new(pieces: &'a [&'a str],\n                args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n@@ -179,7 +179,7 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[experimental = \"implementation detail of the `format_args!` macro\"]\n+    #[unstable = \"implementation detail of the `format_args!` macro\"]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n                              fmt: &'a [rt::Argument<'a>],\n                              args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -301,7 +301,7 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n-#[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n+#[unstable = \"libcore and I/O have yet to be reconciled, and this is an \\\n                   implementation detail which should not otherwise be exported\"]\n pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n@@ -563,7 +563,7 @@ impl<'a> Formatter<'a> {\n     }\n \n     /// Flags for formatting (packed version of rt::Flag)\n-    #[experimental = \"return type may change and method was just created\"]\n+    #[unstable = \"return type may change and method was just created\"]\n     pub fn flags(&self) -> uint { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n@@ -592,7 +592,7 @@ impl Show for Error {\n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-#[experimental = \"implementation detail of the `format_args!` macro\"]\n+#[unstable = \"implementation detail of the `format_args!` macro\"]\n pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     Argument::new(t, f)\n@@ -601,7 +601,7 @@ pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n-#[experimental = \"implementation detail of the `format_args!` macro\"]\n+#[unstable = \"implementation detail of the `format_args!` macro\"]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     Argument::from_uint(s)\n }"}, {"sha": "8d8e8c4b703032b34e0d607ac1ee2580ef11b526", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,7 +14,7 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![experimental = \"implementation detail of the `format_args!` macro\"]\n+#![unstable = \"implementation detail of the `format_args!` macro\"]\n \n pub use self::Alignment::*;\n pub use self::Count::*;"}, {"sha": "5924d515dda595c5e785608d110108e5aeae1e97", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -39,7 +39,7 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![experimental]\n+#![unstable]\n #![allow(missing_docs)]\n \n #[cfg(not(stage0))]\n@@ -333,7 +333,7 @@ extern \"rust-intrinsic\" {\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[experimental = \"uncertain about naming and semantics\"]\n+    #[unstable = \"uncertain about naming and semantics\"]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "d4aa4c99a76bd48f20c5d1cc8e97a1e2047f5781", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -942,7 +942,7 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Use an iterator to reverse a container in place.\n-    #[experimental = \"uncertain about placement or widespread use\"]\n+    #[unstable = \"uncertain about placement or widespread use\"]\n     fn reverse_in_place<'a, T: 'a>(&mut self) where\n         Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n     {\n@@ -974,7 +974,7 @@ pub trait DoubleEndedIterator: Iterator {\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n-#[experimental = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n+#[unstable = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::uint::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n@@ -1049,7 +1049,7 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n@@ -1084,7 +1084,7 @@ impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterat\n }\n \n /// A trait for iterators over elements which can be added together\n-#[experimental = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n@@ -1102,7 +1102,7 @@ pub trait AdditiveIterator<A> {\n \n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n-        #[experimental = \"trait is experimental\"]\n+        #[unstable = \"trait is experimental\"]\n         impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n             #[inline]\n             fn sum(self) -> $A {\n@@ -1125,7 +1125,7 @@ impl_additive! { f32,  0.0 }\n impl_additive! { f64,  0.0 }\n \n /// A trait for iterators over elements which can be multiplied together.\n-#[experimental = \"needs to be re-evaluated as part of numerics reform\"]\n+#[unstable = \"needs to be re-evaluated as part of numerics reform\"]\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n     ///\n@@ -1146,7 +1146,7 @@ pub trait MultiplicativeIterator<A> {\n \n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n-        #[experimental = \"trait is experimental\"]\n+        #[unstable = \"trait is experimental\"]\n         impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n             fn product(self) -> $A {\n@@ -1287,7 +1287,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n@@ -1372,7 +1372,7 @@ impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=T>,\n@@ -1464,7 +1464,7 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=U>,\n@@ -1546,7 +1546,7 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1735,7 +1735,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1961,7 +1961,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2016,7 +2016,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2229,7 +2229,7 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2246,7 +2246,7 @@ impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n-    #[experimental = \"seems marginal\"]\n+    #[unstable = \"seems marginal\"]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2315,7 +2315,7 @@ impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2364,7 +2364,7 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///     println!(\"{}\", i);\n /// }\n /// ```\n-#[experimental]\n+#[unstable]\n pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n@@ -2385,7 +2385,7 @@ impl<A, St, F> Clone for Unfold<A, St, F> where\n     }\n }\n \n-#[experimental]\n+#[unstable]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n@@ -2778,7 +2778,7 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> uint { uint::MAX }\n@@ -2790,12 +2790,12 @@ type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n-#[experimental]\n+#[unstable]\n pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n-#[experimental]\n+#[unstable]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     T: Clone,\n     F: FnMut(T) -> T,"}, {"sha": "28f8cf588bea9a1a408876d308837a45b3e9bdd4", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -48,7 +48,7 @@\n // separate crate, libcoretest, to avoid bizarre issues.\n \n #![crate_name = \"core\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -59,9 +59,10 @@\n #![no_std]\n #![allow(unknown_features, raw_pointer_derive)]\n #![cfg_attr(stage0, allow(unused_attributes))]\n-#![feature(intrinsics, lang_items)]\n+#![allow(unknown_features)] #![feature(intrinsics, lang_items)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n \n #[macro_use]"}, {"sha": "f6415518864bf934e80e8f62adcaa66b61af14a6", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,15 +15,15 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     );\n     ($msg:expr) => ({\n-        static _MSG_FILE_LINE: (&'static str, &'static str, uint) = ($msg, file!(), line!());\n+        static _MSG_FILE_LINE: (&'static str, &'static str, usize) = ($msg, file!(), line!());\n         ::core::panicking::panic(&_MSG_FILE_LINE)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n         // The leading _'s are to avoid dead code warnings if this is\n         // used inside a dead function. Just `#[allow(dead_code)]` is\n         // insufficient, since the user may have\n         // `#[forbid(dead_code)]` and which cannot be overridden.\n-        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        static _FILE_LINE: (&'static str, usize) = (file!(), line!());\n         ::core::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n     });\n }"}, {"sha": "abaf252932300a0023a77ac665c6fb3ca080da9b", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -32,7 +32,7 @@ unsafe impl Zeroable for u64 {}\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show)]\n-#[experimental]\n+#[unstable]\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {"}, {"sha": "57415f4331d6d87394d7a5eae66379a9e2f0e8ed", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -726,7 +726,7 @@ impl UnsignedInt for u32 {}\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number.\n-#[experimental = \"trait is likely to be removed\"]\n+#[unstable = \"trait is likely to be removed\"]\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n     #[inline]\n@@ -991,7 +991,7 @@ impl_to_primitive_float! { f32 }\n impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n-#[experimental = \"trait is likely to be removed\"]\n+#[unstable = \"trait is likely to be removed\"]\n pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n@@ -1073,73 +1073,73 @@ pub trait FromPrimitive : ::marker::Sized {\n }\n \n /// A utility function that just calls `FromPrimitive::from_int`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n     FromPrimitive::from_int(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i8`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n     FromPrimitive::from_i8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i16`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n     FromPrimitive::from_i16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i32`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n     FromPrimitive::from_i32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i64`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n     FromPrimitive::from_i64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_uint`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n     FromPrimitive::from_uint(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u8`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n     FromPrimitive::from_u8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u16`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n     FromPrimitive::from_u16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u32`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n     FromPrimitive::from_u32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u64`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n     FromPrimitive::from_u64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f32`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n     FromPrimitive::from_f32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f64`.\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n     FromPrimitive::from_f64(n)\n }\n@@ -1190,13 +1190,13 @@ impl_from_primitive! { f64, to_f64 }\n /// ```\n ///\n #[inline]\n-#[experimental = \"likely to be removed\"]\n+#[unstable = \"likely to be removed\"]\n pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n     NumCast::from(n)\n }\n \n /// An interface for casting between machine scalars.\n-#[experimental = \"trait is likely to be removed\"]\n+#[unstable = \"trait is likely to be removed\"]\n pub trait NumCast: ToPrimitive {\n     /// Creates a number from another value that can be converted into a primitive via the\n     /// `ToPrimitive` trait.\n@@ -1394,20 +1394,20 @@ pub trait Float\n }\n \n /// A generic trait for converting a string with a radix (base) to a value\n-#[experimental = \"might need to return Result\"]\n+#[unstable = \"might need to return Result\"]\n pub trait FromStrRadix {\n     fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n-#[experimental = \"might need to return Result\"]\n+#[unstable = \"might need to return Result\"]\n pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n-        #[experimental = \"might need to return Result\"]\n+        #[unstable = \"might need to return Result\"]\n         impl FromStr for $T {\n             /// Convert a string in base 10 to a float.\n             /// Accepts an optional decimal exponent.\n@@ -1440,7 +1440,7 @@ macro_rules! from_str_radix_float_impl {\n             }\n         }\n \n-        #[experimental = \"might need to return Result\"]\n+        #[unstable = \"might need to return Result\"]\n         impl FromStrRadix for $T {\n             /// Convert a string in a given base to a float.\n             ///\n@@ -1604,15 +1604,15 @@ from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n-        #[experimental = \"might need to return Result\"]\n+        #[unstable = \"might need to return Result\"]\n         impl FromStr for $T {\n             #[inline]\n             fn from_str(src: &str) -> Option<$T> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[experimental = \"might need to return Result\"]\n+        #[unstable = \"might need to return Result\"]\n         impl FromStrRadix for $T {\n             fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n                 assert!(radix >= 2 && radix <= 36,"}, {"sha": "41eecb4649d97decab6b9961dd61fd3e61d7f9fc", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -477,7 +477,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or(0i), Err(0i));\n     /// ```\n     #[inline]\n-    #[experimental]\n+    #[unstable]\n     pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -498,7 +498,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or_else(|| 0i), Err(0i));\n     /// ```\n     #[inline]\n-    #[experimental]\n+    #[unstable]\n     pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),"}, {"sha": "ab1e69f0060644d5f3d7525ca9574c5c669fcd8f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -106,7 +106,7 @@ pub use intrinsics::copy_nonoverlapping_memory;\n #[unstable]\n pub use intrinsics::copy_memory;\n \n-#[experimental = \"uncertain about naming and semantics\"]\n+#[unstable = \"uncertain about naming and semantics\"]\n pub use intrinsics::set_memory;\n \n "}, {"sha": "13a387c7cb0ed6c49580605c2fe7ed443729f642", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![experimental]\n+#![unstable]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!"}, {"sha": "f7421203336c3571e2b55a686ebbea52eac22577", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -953,7 +953,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-#[experimental]\n+#[unstable]\n pub fn fold<T,\n             V,\n             E,"}, {"sha": "b73910d7c068c2e6afb216b53d985e859ff9607e", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -19,7 +19,7 @@\n //! provided beyond this module.\n //!\n //! ```rust\n-//! #[allow(experimental)];\n+//! #[allow(unstable)];\n //!\n //! fn main() {\n //!     use std::simd::f32x4;\n@@ -37,7 +37,7 @@\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -46,26 +46,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -74,32 +74,32 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[experimental]\n+#[unstable]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]"}, {"sha": "7e47c5257a344942cfab44a2f0465dce27712f5f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -457,7 +457,7 @@ impl<T> SliceExt for [T] {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    #[experimental]\n+    #[unstable]\n     fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -488,7 +488,7 @@ impl<T> SliceExt for [T] {\n         true\n     }\n \n-    #[experimental]\n+    #[unstable]\n     fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -630,25 +630,25 @@ impl<T> ops::IndexMut<ops::FullRange> for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[experimental = \"will be replaced by slice syntax\"]\n+#[unstable = \"will be replaced by slice syntax\"]\n pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n@@ -754,7 +754,7 @@ pub struct Iter<'a, T: 'a> {\n     marker: marker::ContravariantLifetime<'a>\n }\n \n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -763,7 +763,7 @@ impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -772,7 +772,7 @@ impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -781,7 +781,7 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -795,7 +795,7 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n-    #[experimental]\n+    #[unstable]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n@@ -813,7 +813,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -847,31 +847,31 @@ pub struct IterMut<'a, T: 'a> {\n }\n \n \n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -880,31 +880,31 @@ impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     }\n }\n \n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[experimental]\n+#[unstable]\n impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -921,7 +921,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n-    #[experimental]\n+    #[unstable]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n@@ -1269,7 +1269,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n-#[experimental = \"trait is experimental\"]\n+#[unstable = \"trait is experimental\"]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1417,7 +1417,7 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n //\n \n /// Operations on `[u8]`.\n-#[experimental = \"needs review\"]\n+#[unstable = \"needs review\"]\n pub mod bytes {\n     use ptr;\n     use slice::SliceExt;\n@@ -1430,7 +1430,7 @@ pub mod bytes {\n \n     impl MutableByteVector for [u8] {\n         #[inline]\n-        #[allow(experimental)]\n+        #[allow(unstable)]\n         fn set_memory(&mut self, value: u8) {\n             unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n         }\n@@ -1506,7 +1506,7 @@ impl<T: PartialOrd> PartialOrd for [T] {\n }\n \n /// Extension methods for slices containing integers.\n-#[experimental]\n+#[unstable]\n pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n@@ -1521,7 +1521,7 @@ pub trait IntSliceExt<U, S> {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n-        #[experimental]\n+        #[unstable]\n         impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }"}, {"sha": "a808593ffbd7d61f1cd39515c69adba34799e27a", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -114,7 +114,7 @@ fn discard_doesnt_unborrow() {\n }\n \n #[test]\n-#[allow(experimental)]\n+#[allow(unstable)]\n fn clone_ref_updates_flag() {\n     let x = RefCell::new(0i);\n     {"}, {"sha": "0d371dbe15375bd1c0d14c210939ee160f2d920c", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,6 +11,7 @@\n #![feature(unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate core;\n extern crate test;"}, {"sha": "fb6c98515f7f004375247f771fb22c7d52fd50d1", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,8 +15,9 @@\n //! [mz]: https://code.google.com/p/miniz/\n \n #![crate_name = \"flate\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "70ad8d28d271ff727f6841c3f2fd8a8e63d60e53", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,7 +15,7 @@\n //! generated instead.\n \n #![crate_name = \"fmt_macros\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -25,6 +25,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(slicing_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n pub use self::Piece::*;\n pub use self::Position::*;"}, {"sha": "470ef6e7e57a3df4136e3508edbea919ad074dde", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -78,7 +78,7 @@\n //! ```\n \n #![crate_name = \"getopts\"]\n-#![experimental = \"use the crates.io `getopts` library instead\"]\n+#![unstable = \"use the crates.io `getopts` library instead\"]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -87,6 +87,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(slicing_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n \n #[cfg(test)] #[macro_use] extern crate log;"}, {"sha": "b48fe2e42786d67188e806dfb17dea480de8d288", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -265,14 +265,15 @@\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n #![crate_name = \"graphviz\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(slicing_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n use self::LabelText::*;\n "}, {"sha": "34964bbae51bcfc2b11138c3dc09184c2a61ceb8", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,8 +10,9 @@\n \n #![crate_name = \"libc\"]\n #![crate_type = \"rlib\"]\n-#![cfg_attr(not(feature = \"cargo-build\"), experimental)]\n+#![cfg_attr(not(feature = \"cargo-build\"), unstable)]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\","}, {"sha": "a166dc369cb1bfa5eb8f671a205833896fcab888", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -156,7 +156,7 @@\n //! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n-#![experimental = \"use the crates.io `log` library instead\"]\n+#![unstable = \"use the crates.io `log` library instead\"]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -168,6 +168,7 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n \n extern crate regex;"}, {"sha": "e248de10df4965c2a9a9856ba7120ba304a566be", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,7 +17,7 @@\n //! internally. The `IndependentSample` trait is for generating values\n //! that do not need to record state.\n \n-#![experimental]\n+#![unstable]\n \n use core::prelude::*;\n use core::num::{Float, Int};"}, {"sha": "4d605253ab06474c6671c4cdd8f416e45d373099", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -22,9 +22,9 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![no_std]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n \n #[macro_use]"}, {"sha": "6a7062a419e59d7bed2ff483bec4202c7e9e56a5", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,7 +16,7 @@\n //!     http://www.matroska.org/technical/specs/rfc/index.html\n \n #![crate_name = \"rbml\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -26,6 +26,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate serialize;\n #[macro_use] extern crate log;"}, {"sha": "45f42336ceb45707091a06a3b44a705e02b9abfe", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,7 +16,7 @@\n #![crate_name = \"regex\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n-#![experimental = \"use the crates.io `regex` library instead\"]\n+#![unstable = \"use the crates.io `regex` library instead\"]\n #![staged_api]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n@@ -26,6 +26,7 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n \n #[cfg(test)]"}, {"sha": "abc51d6240409511fba2615d017ad27abf0ea839", "filename": "src/libregex/re.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -255,7 +255,7 @@ impl Regex {\n     }\n \n     #[doc(hidden)]\n-    #[experimental]\n+    #[unstable]\n     pub fn names_iter<'a>(&'a self) -> NamesIter<'a> {\n         match *self {\n             Native(ref n) => NamesIterNative(n.names.iter()),\n@@ -410,7 +410,7 @@ pub struct Captures<'t> {\n }\n \n impl<'t> Captures<'t> {\n-    #[allow(experimental)]\n+    #[allow(unstable)]\n     fn new(re: &Regex, search: &'t str, locs: CaptureLocs)\n           -> Option<Captures<'t>> {\n         if !has_match(&locs) {"}, {"sha": "fb7c5296d020e38ac637f6e7cc9ffbd0f5d2a59e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -27,8 +27,8 @@\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(old_impl_check)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "620b8f277dddcd95a5a7959a96b6c31699d91d24", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -216,7 +216,7 @@ impl LintPass for TypeLimits {\n                         match lit.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                                let int_type = if t == ast::TyIs {\n+                                let int_type = if let ast::TyIs(_) = t {\n                                     cx.sess().target.int_type\n                                 } else { t };\n                                 let (min, max) = int_ty_range(int_type);\n@@ -233,7 +233,7 @@ impl LintPass for TypeLimits {\n                         };\n                     },\n                     ty::ty_uint(t) => {\n-                        let uint_type = if t == ast::TyUs {\n+                        let uint_type = if let ast::TyUs(_) = t {\n                             cx.sess().target.uint_type\n                         } else { t };\n                         let (min, max) = uint_ty_range(uint_type);\n@@ -296,7 +296,7 @@ impl LintPass for TypeLimits {\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::TyIs=>    (i64::MIN,        i64::MAX),\n+                ast::TyIs(_) =>    (i64::MIN,        i64::MAX),\n                 ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n                 ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n                 ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n@@ -306,7 +306,7 @@ impl LintPass for TypeLimits {\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::TyUs=>   (u64::MIN,         u64::MAX),\n+                ast::TyUs(_) =>   (u64::MIN,         u64::MAX),\n                 ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n                 ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n                 ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n@@ -323,7 +323,7 @@ impl LintPass for TypeLimits {\n \n         fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyIs=>    int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyIs(_) =>    int_ty_bits(target_int_ty, target_int_ty),\n                 ast::TyI8 =>   i8::BITS  as u64,\n                 ast::TyI16 =>  i16::BITS as u64,\n                 ast::TyI32 =>  i32::BITS as u64,\n@@ -333,7 +333,7 @@ impl LintPass for TypeLimits {\n \n         fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyUs=>    uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyUs(_) =>    uint_ty_bits(target_uint_ty, target_uint_ty),\n                 ast::TyU8 =>   u8::BITS  as u64,\n                 ast::TyU16 =>  u16::BITS as u64,\n                 ast::TyU32 =>  u32::BITS as u64,\n@@ -404,12 +404,12 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n         match self.cx.tcx.def_map.borrow()[path_id].clone() {\n-            def::DefPrimTy(ast::TyInt(ast::TyIs)) => {\n+            def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `isize` in foreign module, while \\\n                                    libc::c_int or libc::c_long should be used\");\n             }\n-            def::DefPrimTy(ast::TyUint(ast::TyUs)) => {\n+            def::DefPrimTy(ast::TyUint(ast::TyUs(_))) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `usize` in foreign module, while \\\n                                    libc::c_uint or libc::c_ulong should be used\");\n@@ -1630,36 +1630,29 @@ declare_lint! {\n     Warn,\n     \"detects use of #[deprecated] items\"\n }\n-// FIXME #6875: Change to Warn after std library stabilization is complete\n-declare_lint! {\n-    EXPERIMENTAL,\n-    Allow,\n-    \"detects use of #[experimental] items\"\n-}\n \n declare_lint! {\n     UNSTABLE,\n-    Allow,\n+    Warn,\n     \"detects use of #[unstable] items (incl. items with no stability attribute)\"\n }\n \n-declare_lint!(STAGED_EXPERIMENTAL, Warn,\n-              \"detects use of #[experimental] items in staged builds\");\n-\n-declare_lint!(STAGED_UNSTABLE, Warn,\n-              \"detects use of #[unstable] items (incl. items with no stability attribute) \\\n-               in staged builds\");\n-\n-/// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n+/// Checks for use of items with `#[deprecated]`, `#[unstable]` and\n /// `#[unstable]` attributes, or no stability attribute.\n #[derive(Copy)]\n-pub struct Stability;\n+pub struct Stability { this_crate_staged: bool }\n \n impl Stability {\n+    pub fn new() -> Stability { Stability { this_crate_staged: false } }\n+\n     fn lint(&self, cx: &Context, id: ast::DefId, span: Span) {\n \n         let ref stability = stability::lookup(cx.tcx, id);\n         let cross_crate = !ast_util::is_local(id);\n+        let staged = (!cross_crate && self.this_crate_staged)\n+            || (cross_crate && stability::is_staged_api(cx.tcx, id));\n+\n+        if !staged { return }\n \n         // stability attributes are promises made across crates; only\n         // check DEPRECATED for crate-local usage.\n@@ -1668,21 +1661,12 @@ impl Stability {\n             None if cross_crate => (UNSTABLE, \"unmarked\"),\n             Some(attr::Stability { level: attr::Unstable, .. }) if cross_crate =>\n                 (UNSTABLE, \"unstable\"),\n-            Some(attr::Stability { level: attr::Experimental, .. }) if cross_crate =>\n-                (EXPERIMENTAL, \"experimental\"),\n             Some(attr::Stability { level: attr::Deprecated, .. }) =>\n                 (DEPRECATED, \"deprecated\"),\n             _ => return\n         };\n \n         output(cx, span, stability, lint, label);\n-        if cross_crate && stability::is_staged_api(cx.tcx, id) {\n-            if lint.name == UNSTABLE.name {\n-                output(cx, span, stability, STAGED_UNSTABLE, label);\n-            } else if lint.name == EXPERIMENTAL.name {\n-                output(cx, span, stability, STAGED_EXPERIMENTAL, label);\n-            }\n-        }\n \n         fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n@@ -1706,7 +1690,7 @@ impl Stability {\n \n impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(DEPRECATED, EXPERIMENTAL, UNSTABLE, STAGED_EXPERIMENTAL, STAGED_UNSTABLE)\n+        lint_array!(DEPRECATED, UNSTABLE)\n     }\n \n     fn check_crate(&mut self, _: &Context, c: &ast::Crate) {\n@@ -1717,6 +1701,7 @@ impl LintPass for Stability {\n                 match attr.node.value.node {\n                     ast::MetaWord(_) => {\n                         attr::mark_used(attr);\n+                        self.this_crate_staged = true;\n                     }\n                     _ => (/*pass*/)\n                 }"}, {"sha": "95e1e8d44bfc5044aec739ec98f5c89ec5aaeb7e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -209,7 +209,6 @@ impl LintStore {\n                      UnsafeBlocks,\n                      UnusedMut,\n                      UnusedAllocation,\n-                     Stability,\n                      MissingCopyImplementations,\n                      UnstableFeatures,\n         );\n@@ -218,6 +217,7 @@ impl LintStore {\n                               TypeLimits,\n                               RawPointerDerive,\n                               MissingDoc,\n+                              Stability,\n         );\n \n         add_lint_group!(sess, \"bad_style\",\n@@ -308,18 +308,21 @@ impl LintStore {\n             UnstableFeatures::Cheat => Allow\n         };\n         match self.by_name.get(\"unstable_features\") {\n-            Some(&Id(lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n-            Some(&Renamed(_, lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n-            None => unreachable!()\n-        }\n-        match self.by_name.get(\"staged_unstable\") {\n-            Some(&Id(lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n-            Some(&Renamed(_, lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+            Some(&Id(lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n+                self.set_level(lint_id, (lvl, ReleaseChannel))\n+            },\n+            Some(&Renamed(_, lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n+                self.set_level(lint_id, (lvl, ReleaseChannel))\n+            },\n             None => unreachable!()\n         }\n-        match self.by_name.get(\"staged_experimental\") {\n-            Some(&Id(lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n-            Some(&Renamed(_, lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+        match self.by_name.get(\"unstable\") {\n+            Some(&Id(lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n+                self.set_level(lint_id, (lvl, ReleaseChannel))\n+            },\n+            Some(&Renamed(_, lint_id)) => if self.get_level_source(lint_id).0 != Forbid {\n+                self.set_level(lint_id, (lvl, ReleaseChannel))\n+            },\n             None => unreachable!()\n         }\n     }"}, {"sha": "826a35e3bb529b9229f5cea1ffbe7b284f475b18", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -40,7 +40,7 @@ use syntax::ast;\n pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs};\n \n /// Specification of a single lint.\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub struct Lint {\n     /// A string identifier for the lint.\n     ///\n@@ -208,7 +208,7 @@ impl LintId {\n }\n \n /// Setting for how to handle a lint.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord)]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }"}, {"sha": "bdd08ad6c4952038af1029b1982de787ee9c047b", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -61,7 +61,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {\n             match t {\n-                ast::TyIs => mywrite!(w, \"is\"),\n+                ast::TyIs(_) => mywrite!(w, \"is\"),\n                 ast::TyI8 => mywrite!(w, \"MB\"),\n                 ast::TyI16 => mywrite!(w, \"MW\"),\n                 ast::TyI32 => mywrite!(w, \"ML\"),\n@@ -70,7 +70,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         }\n         ty::ty_uint(t) => {\n             match t {\n-                ast::TyUs => mywrite!(w, \"us\"),\n+                ast::TyUs(_) => mywrite!(w, \"us\"),\n                 ast::TyU8 => mywrite!(w, \"Mb\"),\n                 ast::TyU16 => mywrite!(w, \"Mw\"),\n                 ast::TyU32 => mywrite!(w, \"Ml\"),"}, {"sha": "52352e920ce36a3922683413684780e822e951d9", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -528,12 +528,12 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n \n         eval_const_expr_partial(tcx, &**base)\n             .and_then(|val| define_casts!(val, {\n-                ty::ty_int(ast::TyIs) => (int, const_int, i64),\n+                ty::ty_int(ast::TyIs(_)) => (int, const_int, i64),\n                 ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n                 ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n                 ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n                 ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-                ty::ty_uint(ast::TyUs) => (uint, const_uint, u64),\n+                ty::ty_uint(ast::TyUs(_)) => (uint, const_uint, u64),\n                 ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n                 ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n                 ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),"}, {"sha": "51ec75284326c4f76f9b790ef99b19cc654b76a4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 97, "deletions": 39, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -75,7 +75,7 @@ use middle::def;\n use middle::region;\n use middle::ty::{self, Ty};\n use util::nodemap::{NodeMap};\n-use util::ppaux::{Repr};\n+use util::ppaux::{Repr, UserString};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -113,10 +113,17 @@ pub struct Upvar {\n // different kinds of pointers:\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub enum PointerKind {\n+    /// `Box<T>`\n     Unique,\n+\n+    /// `&T`\n     BorrowedPtr(ty::BorrowKind, ty::Region),\n-    Implicit(ty::BorrowKind, ty::Region),     // Implicit deref of a borrowed ptr.\n-    UnsafePtr(ast::Mutability)\n+\n+    /// `*T`\n+    UnsafePtr(ast::Mutability),\n+\n+    /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n+    Implicit(ty::BorrowKind, ty::Region),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -453,7 +460,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n-            cmt = try!(self.cat_deref(expr, cmt, deref, false));\n+            cmt = try!(self.cat_deref(expr, cmt, deref));\n         }\n         return Ok(cmt);\n     }\n@@ -465,7 +472,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n             let base_cmt = try!(self.cat_expr(&**e_base));\n-            self.cat_deref(expr, base_cmt, 0, false)\n+            self.cat_deref(expr, base_cmt, 0)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n@@ -489,10 +496,23 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     // If this is an index implemented by a method call, then it\n                     // will include an implicit deref of the result.\n                     let ret_ty = self.overloaded_method_return_ty(method_ty);\n-                    self.cat_deref(expr,\n-                                   self.cat_rvalue_node(expr.id(),\n-                                                        expr.span(),\n-                                                        ret_ty), 1, true)\n+\n+                    // The index method always returns an `&T`, so\n+                    // dereference it to find the result type.\n+                    let elem_ty = match ret_ty.sty {\n+                        ty::ty_rptr(_, mt) => mt.ty,\n+                        _ => {\n+                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {}?\",\n+                                   ret_ty.repr(self.tcx()));\n+                            return Err(());\n+                        }\n+                    };\n+\n+                    // The call to index() returns a `&T` value, which\n+                    // is an rvalue. That is what we will be\n+                    // dereferencing.\n+                    let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n+                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, true)\n                 }\n                 None => {\n                     self.cat_index(expr, try!(self.cat_expr(&**base)))\n@@ -837,8 +857,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: uint,\n-                             implicit: bool)\n+                             deref_cnt: uint)\n                              -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => ty::AutoObject,\n@@ -866,7 +885,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let base_cmt_ty = base_cmt.ty;\n         match ty::deref(base_cmt_ty, true) {\n-            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, implicit),\n+            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty,\n+                                              /* implicit: */ false),\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n                        base_cmt_ty.repr(self.tcx()));\n@@ -1236,7 +1256,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatRegion since that information is already contained\n             // in the type.\n-            let subcmt = try!(self.cat_deref(pat, cmt, 0, false));\n+            let subcmt = try!(self.cat_deref(pat, cmt, 0));\n               try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }\n \n@@ -1392,22 +1412,6 @@ impl<'tcx> cmt_<'tcx> {\n \n \n     pub fn descriptive_string(&self, tcx: &ty::ctxt) -> String {\n-        fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n-            if upvar.is_unboxed {\n-                let kind = match upvar.kind {\n-                    ty::FnUnboxedClosureKind => \"Fn\",\n-                    ty::FnMutUnboxedClosureKind => \"FnMut\",\n-                    ty::FnOnceUnboxedClosureKind => \"FnOnce\"\n-                };\n-                format!(\"captured outer variable in an `{}` closure\", kind)\n-            } else {\n-                (match (upvar.kind, is_copy) {\n-                    (ty::FnOnceUnboxedClosureKind, true) => \"captured outer variable in a proc\",\n-                    _ => \"captured outer variable\"\n-                }).to_string()\n-            }\n-        }\n-\n         match self.cat {\n             cat_static_item => {\n                 \"static item\".to_string()\n@@ -1427,16 +1431,23 @@ impl<'tcx> cmt_<'tcx> {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n                     Some(&cat_upvar(ref var)) => {\n-                        upvar_to_string(var, false)\n+                        var.user_string(tcx)\n                     }\n                     Some(_) => unreachable!(),\n                     None => {\n                         match pk {\n                             Implicit(..) => {\n-                                \"dereference (dereference is implicit, due to indexing)\".to_string()\n+                                format!(\"indexed content\")\n+                            }\n+                            Unique => {\n+                                format!(\"`Box` content\")\n+                            }\n+                            UnsafePtr(..) => {\n+                                format!(\"dereference of unsafe pointer\")\n+                            }\n+                            BorrowedPtr(..) => {\n+                                format!(\"borrowed content\")\n                             }\n-                            Unique => format!(\"dereference of `{}`\", ptr_sigil(pk)),\n-                            _ => format!(\"dereference of `{}`-pointer\", ptr_sigil(pk))\n                         }\n                     }\n                 }\n@@ -1447,14 +1458,12 @@ impl<'tcx> cmt_<'tcx> {\n             cat_interior(_, InteriorField(PositionalField(_))) => {\n                 \"anonymous field\".to_string()\n             }\n-            cat_interior(_, InteriorElement(VecElement)) => {\n-                \"vec content\".to_string()\n-            }\n+            cat_interior(_, InteriorElement(VecElement)) |\n             cat_interior(_, InteriorElement(OtherElement)) => {\n                 \"indexed content\".to_string()\n             }\n             cat_upvar(ref var) => {\n-                upvar_to_string(var, true)\n+                var.user_string(tcx)\n             }\n             cat_downcast(ref cmt, _) => {\n                 cmt.descriptive_string(tcx)\n@@ -1483,7 +1492,7 @@ impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(ref cmt, derefs, ptr) => {\n-                format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr_sigil(ptr), derefs)\n+                format!(\"{}-{}{}->\", cmt.cat.repr(tcx), ptr.repr(tcx), derefs)\n             }\n             cat_interior(ref cmt, interior) => {\n                 format!(\"{}.{}\", cmt.cat.repr(tcx), interior.repr(tcx))\n@@ -1504,7 +1513,32 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n         Implicit(ty::MutBorrow, _) => \"&mut\",\n         BorrowedPtr(ty::UniqueImmBorrow, _) |\n         Implicit(ty::UniqueImmBorrow, _) => \"&unique\",\n-        UnsafePtr(_) => \"*\"\n+        UnsafePtr(_) => \"*\",\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for PointerKind {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            Unique => {\n+                format!(\"Box\")\n+            }\n+            BorrowedPtr(ty::ImmBorrow, ref r) |\n+            Implicit(ty::ImmBorrow, ref r) => {\n+                format!(\"&{}\", r.repr(tcx))\n+            }\n+            BorrowedPtr(ty::MutBorrow, ref r) |\n+            Implicit(ty::MutBorrow, ref r) => {\n+                format!(\"&{} mut\", r.repr(tcx))\n+            }\n+            BorrowedPtr(ty::UniqueImmBorrow, ref r) |\n+            Implicit(ty::UniqueImmBorrow, ref r) => {\n+                format!(\"&{} uniq\", r.repr(tcx))\n+            }\n+            UnsafePtr(_) => {\n+                format!(\"*\")\n+            }\n+        }\n     }\n }\n \n@@ -1531,3 +1565,27 @@ fn element_kind(t: Ty) -> ElementKind {\n         _ => OtherElement\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for ty::UnboxedClosureKind {\n+    fn repr(&self, _: &ty::ctxt) -> String {\n+        format!(\"Upvar({:?})\", self)\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for Upvar {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"Upvar({})\", self.kind.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for Upvar {\n+    fn user_string(&self, _: &ty::ctxt) -> String {\n+        let kind = match self.kind {\n+            ty::FnUnboxedClosureKind => \"Fn\",\n+            ty::FnMutUnboxedClosureKind => \"FnMut\",\n+            ty::FnOnceUnboxedClosureKind => \"FnOnce\",\n+        };\n+        format!(\"captured outer variable in an `{}` closure\", kind)\n+    }\n+}\n+"}, {"sha": "9ac6b8a86b68b10585fb191f64ca5552f3cb181a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -313,6 +313,17 @@ impl<T> VecPerParamSpace<T> {\n         self.content.insert(limit, value);\n     }\n \n+    /// Appends `values` to the vector associated with `space`.\n+    ///\n+    /// Unlike the `extend` method in `Vec`, this should not be assumed\n+    /// to be a cheap operation (even when amortized over many calls).\n+    pub fn extend<I:Iterator<Item=T>>(&mut self, space: ParamSpace, mut values: I) {\n+        // This could be made more efficient, obviously.\n+        for item in values {\n+            self.push(space, item);\n+        }\n+    }\n+\n     pub fn pop(&mut self, space: ParamSpace) -> Option<T> {\n         let (start, limit) = self.limits(space);\n         if start == limit {"}, {"sha": "b6d45ab89e70aa1b1b164357acc0ba98e84cd9f5", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,6 +12,7 @@\n \n use super::SelectionContext;\n use super::{Obligation, ObligationCause};\n+use super::project;\n use super::util;\n \n use middle::subst::{Subst};\n@@ -34,22 +35,28 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n            impl1_def_id.repr(infcx.tcx),\n            impl2_def_id.repr(infcx.tcx));\n \n+    let param_env = ty::empty_parameter_environment(infcx.tcx);\n+    let mut selcx = SelectionContext::intercrate(infcx, &param_env);\n+    let cause = ObligationCause::dummy();\n+\n     // `impl1` provides an implementation of `Foo<X,Y> for Z`.\n     let impl1_substs =\n         util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n     let impl1_trait_ref =\n         (*ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()).subst(infcx.tcx, &impl1_substs);\n+    let impl1_trait_ref =\n+        project::normalize(&mut selcx, cause.clone(), &impl1_trait_ref);\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n-    let param_env = ty::empty_parameter_environment(infcx.tcx);\n-    let mut selcx = SelectionContext::intercrate(infcx, &param_env);\n-    let obligation = Obligation::new(ObligationCause::dummy(),\n+    let obligation = Obligation::new(cause,\n                                      ty::Binder(ty::TraitPredicate {\n-                                         trait_ref: Rc::new(impl1_trait_ref),\n+                                         trait_ref: Rc::new(impl1_trait_ref.value),\n                                      }));\n     debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n-    selcx.evaluate_impl(impl2_def_id, &obligation)\n+    selcx.evaluate_impl(impl2_def_id, &obligation) &&\n+        impl1_trait_ref.obligations.iter().all(\n+            |o| selcx.evaluate_obligation(o))\n }\n \n #[allow(missing_copy_implementations)]"}, {"sha": "95a938328cf452650c64bc305ab57b90989eb285", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -206,6 +206,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n         // normalize it when we instantiate those bound regions (which\n         // should occur eventually).\n \n+        let ty = ty_fold::super_fold_ty(self, ty);\n         match ty.sty {\n             ty::ty_projection(ref data) if !data.has_escaping_regions() => { // (*)\n \n@@ -229,8 +230,9 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n                 self.obligations.extend(obligations.into_iter());\n                 ty\n             }\n+\n             _ => {\n-                ty_fold::super_fold_ty(self, ty)\n+                ty\n             }\n         }\n     }\n@@ -243,6 +245,12 @@ pub struct Normalized<'tcx,T> {\n \n pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n \n+impl<'tcx,T> Normalized<'tcx,T> {\n+    pub fn with<U>(self, value: U) -> Normalized<'tcx,U> {\n+        Normalized { value: value, obligations: self.obligations }\n+    }\n+}\n+\n pub fn normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,"}, {"sha": "d6302976b9f111d21864e84eef0cf1c7ccffedb4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -19,6 +19,7 @@ use self::EvaluationResult::*;\n \n use super::{DerivedObligationCause};\n use super::{project};\n+use super::project::Normalized;\n use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n@@ -713,12 +714,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 debug!(\"obligation self ty is {}\",\n                        obligation.predicate.0.self_ty().repr(self.tcx()));\n \n-                // If the user has asked for the older, compatibility\n-                // behavior, ignore user-defined impls here. This will\n-                // go away by the time 1.0 is released.\n-                if !self.tcx().sess.features.borrow().opt_out_copy {\n-                    try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n-                }\n+                try!(self.assemble_candidates_from_impls(obligation, &mut candidates.vec));\n \n                 try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n                                                             stack,\n@@ -1160,7 +1156,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let impl_trait_ref =\n                         ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n                     let impl_trait_ref =\n-                        impl_trait_ref.subst(self.tcx(), &impl_substs);\n+                        impl_trait_ref.subst(self.tcx(), &impl_substs.value);\n                     let poly_impl_trait_ref =\n                         ty::Binder(impl_trait_ref);\n                     let origin =\n@@ -1505,21 +1501,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::BoundCopy => {\n-                    // This is an Opt-In Built-In Trait. So, unless\n-                    // the user is asking for the old behavior, we\n-                    // don't supply any form of builtin impl.\n-                    if !this.tcx().sess.features.borrow().opt_out_copy {\n-                        return Ok(ParameterBuiltin)\n-                    } else {\n-                        // Older, backwards compatibility behavior:\n-                        if\n-                            Some(def_id) == tcx.lang_items.no_copy_bound() ||\n-                            Some(def_id) == tcx.lang_items.managed_bound() ||\n-                            ty::has_dtor(tcx, def_id)\n-                        {\n-                            return Err(Unimplemented);\n-                        }\n-                    }\n+                    return Ok(ParameterBuiltin)\n                 }\n \n                 ty::BoundSync => {\n@@ -1731,15 +1713,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let substs =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot, &skol_map, skol_obligation_trait_ref.trait_ref);\n-            debug!(\"confirm_impl_candidate substs={:?}\", substs);\n+            debug!(\"confirm_impl_candidate substs={}\", substs.repr(self.tcx()));\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n         })\n     }\n \n     fn vtable_impl(&mut self,\n                    impl_def_id: ast::DefId,\n-                   substs: Substs<'tcx>,\n+                   substs: Normalized<'tcx, Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: uint,\n                    skol_map: infer::SkolemizationMap,\n@@ -1752,21 +1734,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                recursion_depth,\n                skol_map.repr(self.tcx()));\n \n-        let impl_predicates =\n-            self.impl_predicates(cause,\n+        let mut impl_obligations =\n+            self.impl_obligations(cause,\n                                  recursion_depth,\n                                  impl_def_id,\n-                                 &substs,\n+                                 &substs.value,\n                                  skol_map,\n                                  snapshot);\n \n-        debug!(\"vtable_impl: impl_def_id={} impl_predicates={}\",\n+        debug!(\"vtable_impl: impl_def_id={} impl_obligations={}\",\n                impl_def_id.repr(self.tcx()),\n-               impl_predicates.repr(self.tcx()));\n+               impl_obligations.repr(self.tcx()));\n+\n+        impl_obligations.extend(TypeSpace, substs.obligations.into_iter());\n \n         VtableImplData { impl_def_id: impl_def_id,\n-                         substs: substs,\n-                         nested: impl_predicates }\n+                         substs: substs.value,\n+                         nested: impl_obligations }\n     }\n \n     fn confirm_object_candidate(&mut self,\n@@ -1950,7 +1934,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     snapshot: &infer::CombinedSnapshot,\n                     skol_map: &infer::SkolemizationMap,\n                     skol_obligation_trait_ref: Rc<ty::TraitRef<'tcx>>)\n-                    -> Substs<'tcx>\n+                    -> Normalized<'tcx, Substs<'tcx>>\n     {\n         match self.match_impl(impl_def_id, obligation, snapshot,\n                               skol_map, skol_obligation_trait_ref) {\n@@ -1972,7 +1956,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                   snapshot: &infer::CombinedSnapshot,\n                   skol_map: &infer::SkolemizationMap,\n                   skol_obligation_trait_ref: Rc<ty::TraitRef<'tcx>>)\n-                  -> Result<Substs<'tcx>, ()>\n+                  -> Result<Normalized<'tcx, Substs<'tcx>>, ()>\n     {\n         let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n \n@@ -1990,6 +1974,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   &impl_substs);\n \n+        let impl_trait_ref =\n+            project::normalize_with_depth(self,\n+                                          obligation.cause.clone(),\n+                                          obligation.recursion_depth + 1,\n+                                          &impl_trait_ref);\n+\n         debug!(\"match_impl(impl_def_id={}, obligation={}, \\\n                impl_trait_ref={}, skol_obligation_trait_ref={})\",\n                impl_def_id.repr(self.tcx()),\n@@ -2000,7 +1990,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_trait_refs(false,\n                                         origin,\n-                                        impl_trait_ref,\n+                                        impl_trait_ref.value.clone(),\n                                         skol_obligation_trait_ref) {\n             Ok(()) => { }\n             Err(e) => {\n@@ -2020,7 +2010,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         debug!(\"match_impl: success impl_substs={}\", impl_substs.repr(self.tcx()));\n-        Ok(impl_substs)\n+        Ok(Normalized { value: impl_substs,\n+                        obligations: impl_trait_ref.obligations })\n     }\n \n     fn fast_reject_trait_refs(&mut self,\n@@ -2161,14 +2152,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn impl_predicates(&mut self,\n-                       cause: ObligationCause<'tcx>,\n-                       recursion_depth: uint,\n-                       impl_def_id: ast::DefId,\n-                       impl_substs: &Substs<'tcx>,\n-                       skol_map: infer::SkolemizationMap,\n-                       snapshot: &infer::CombinedSnapshot)\n-                       -> VecPerParamSpace<PredicateObligation<'tcx>>\n+    fn impl_obligations(&mut self,\n+                        cause: ObligationCause<'tcx>,\n+                        recursion_depth: uint,\n+                        impl_def_id: ast::DefId,\n+                        impl_substs: &Substs<'tcx>,\n+                        skol_map: infer::SkolemizationMap,\n+                        snapshot: &infer::CombinedSnapshot)\n+                        -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n@@ -2181,9 +2172,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           cause,\n                                           recursion_depth,\n                                           &normalized_bounds.value);\n-        for obligation in normalized_bounds.obligations.into_iter() {\n-            impl_obligations.push(TypeSpace, obligation);\n-        }\n+        impl_obligations.extend(TypeSpace, normalized_bounds.obligations.into_iter());\n         impl_obligations\n     }\n "}, {"sha": "ef86e67de1606af77d7c0e3397fb7309412f1f0f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -2341,12 +2341,12 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: intern_ty(arena, interner, ty_bool),\n             char: intern_ty(arena, interner, ty_char),\n             err: intern_ty(arena, interner, ty_err),\n-            int: intern_ty(arena, interner, ty_int(ast::TyIs)),\n+            int: intern_ty(arena, interner, ty_int(ast::TyIs(false))),\n             i8: intern_ty(arena, interner, ty_int(ast::TyI8)),\n             i16: intern_ty(arena, interner, ty_int(ast::TyI16)),\n             i32: intern_ty(arena, interner, ty_int(ast::TyI32)),\n             i64: intern_ty(arena, interner, ty_int(ast::TyI64)),\n-            uint: intern_ty(arena, interner, ty_uint(ast::TyUs)),\n+            uint: intern_ty(arena, interner, ty_uint(ast::TyUs(false))),\n             u8: intern_ty(arena, interner, ty_uint(ast::TyU8)),\n             u16: intern_ty(arena, interner, ty_uint(ast::TyU16)),\n             u32: intern_ty(arena, interner, ty_uint(ast::TyU32)),\n@@ -2692,7 +2692,7 @@ impl FlagComputation {\n \n pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyIs   => tcx.types.int,\n+        ast::TyIs(_)   => tcx.types.int,\n         ast::TyI8   => tcx.types.i8,\n         ast::TyI16  => tcx.types.i16,\n         ast::TyI32  => tcx.types.i32,\n@@ -2702,7 +2702,7 @@ pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n \n pub fn mk_mach_uint<'tcx>(tcx: &ctxt<'tcx>, tm: ast::UintTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyUs   => tcx.types.uint,\n+        ast::TyUs(_)   => tcx.types.uint,\n         ast::TyU8   => tcx.types.u8,\n         ast::TyU16  => tcx.types.u16,\n         ast::TyU32  => tcx.types.u32,\n@@ -3363,7 +3363,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n         let result = match ty.sty {\n             // uint and int are ffi-unsafe\n-            ty_uint(ast::TyUs) | ty_int(ast::TyIs) => {\n+            ty_uint(ast::TyUs(_)) | ty_int(ast::TyIs(_)) => {\n                 TC::ReachesFfiUnsafe\n             }\n \n@@ -3937,7 +3937,7 @@ pub fn type_is_fresh(ty: Ty) -> bool {\n \n pub fn type_is_uint(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(IntVar(_)) | ty_uint(ast::TyUs) => true,\n+      ty_infer(IntVar(_)) | ty_uint(ast::TyUs(_)) => true,\n       _ => false\n     }\n }\n@@ -3983,7 +3983,7 @@ pub fn type_is_signed(ty: Ty) -> bool {\n \n pub fn type_is_machine(ty: Ty) -> bool {\n     match ty.sty {\n-        ty_int(ast::TyIs) | ty_uint(ast::TyUs) => false,\n+        ty_int(ast::TyIs(_)) | ty_uint(ast::TyUs(_)) => false,\n         ty_int(..) | ty_uint(..) | ty_float(..) => true,\n         _ => false\n     }"}, {"sha": "d29a47b65b0a3d51df8b147f812e48be4390c037", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -22,7 +22,7 @@\n //! build speedups.\n \n #![crate_name = \"rustc_back\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -31,6 +31,7 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![allow(unknown_features)]\n #![feature(slicing_syntax, box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "28d02161eebd7e470ef93c3e76679e9d7a4bd2d0", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -115,29 +115,31 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     match move_from.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n-        mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n         mc::cat_static_item => {\n-            bccx.span_err(\n-                move_from.span,\n-                &format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from))[]);\n+            bccx.span_err(move_from.span,\n+                          &format!(\"cannot move out of {}\",\n+                                  move_from.descriptive_string(bccx.tcx))[]);\n         }\n \n         mc::cat_downcast(ref b, _) |\n         mc::cat_interior(ref b, _) => {\n             match b.ty.sty {\n-                ty::ty_struct(did, _)\n-                | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n+                ty::ty_struct(did, _) |\n+                ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n                                 b.ty.user_string(bccx.tcx))[]);\n                 },\n-                _ => panic!(\"this path should not cause illegal move\")\n+                _ => {\n+                    bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n+                }\n             }\n         }\n-        _ => panic!(\"this path should not cause illegal move\")\n+        _ => {\n+            bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n+        }\n     }\n }\n "}, {"sha": "b87fed1601c51a3db3a33906464774547cec731d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -681,6 +681,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(s, m);\n     }\n \n+    pub fn span_bug(&self, s: Span, m: &str) {\n+        self.tcx.sess.span_bug(s, m);\n+    }\n+\n     pub fn span_note(&self, s: Span, m: &str) {\n         self.tcx.sess.span_note(s, m);\n     }"}, {"sha": "eedad75c89fe276ab284cf2e1da1ffdce3deb345", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_borrowck\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -21,6 +21,7 @@\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n \n #[macro_use] extern crate log;"}, {"sha": "9122a34a79362db703a50e00742593d09d37f6e5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_driver\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -28,6 +28,7 @@\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "a4f9b1f98d4c969cbc1bec5cae04130ad0e5a89c", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,7 +14,7 @@\n #![allow(dead_code)]\n \n #![crate_name = \"rustc_llvm\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -25,6 +25,7 @@\n #![allow(unknown_features)]\n #![feature(link_args)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate libc;\n "}, {"sha": "ea6ecfbb92b4f2f3a90b685eaf48a0b56406a23f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_resolve\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -19,6 +19,7 @@\n \n #![feature(slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -819,15 +820,15 @@ impl PrimitiveTypeTable {\n         table.intern(\"char\",    TyChar);\n         table.intern(\"f32\",     TyFloat(TyF32));\n         table.intern(\"f64\",     TyFloat(TyF64));\n-        table.intern(\"int\",     TyInt(TyIs));\n-        table.intern(\"isize\",   TyInt(TyIs));\n+        table.intern(\"int\",     TyInt(TyIs(true)));\n+        table.intern(\"isize\",   TyInt(TyIs(false)));\n         table.intern(\"i8\",      TyInt(TyI8));\n         table.intern(\"i16\",     TyInt(TyI16));\n         table.intern(\"i32\",     TyInt(TyI32));\n         table.intern(\"i64\",     TyInt(TyI64));\n         table.intern(\"str\",     TyStr);\n-        table.intern(\"uint\",    TyUint(TyUs));\n-        table.intern(\"usize\",   TyUint(TyUs));\n+        table.intern(\"uint\",    TyUint(TyUs(true)));\n+        table.intern(\"usize\",   TyUint(TyUs(false)));\n         table.intern(\"u8\",      TyUint(TyU8));\n         table.intern(\"u16\",     TyUint(TyU16));\n         table.intern(\"u32\",     TyUint(TyU32));"}, {"sha": "b6a6b526faccd5662c67e25225f84863673c5853", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -142,7 +142,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     let cstrs: Vec<CString> = reachable.iter().map(|s| {\n         CString::from_slice(s.as_bytes())\n     }).collect();\n-    let arr: Vec<*const i8> = cstrs.iter().map(|c| c.as_ptr()).collect();\n+    let arr: Vec<*const libc::c_char> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod,"}, {"sha": "4859598e63c7abcc6230998ec263f94f3ff345f9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_trans\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -28,6 +28,7 @@\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "88ce36a710a0c606ff06c32ce1c6f1f769f84a9d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -917,8 +917,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             ty::ty_int(t) => {\n                 let llty = Type::int_from_ty(cx.ccx(), t);\n                 let min = match t {\n-                    ast::TyIs if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n-                    ast::TyIs => i64::MIN as u64,\n+                    ast::TyIs(_) if llty == Type::i32(cx.ccx()) => i32::MIN as u64,\n+                    ast::TyIs(_) => i64::MIN as u64,\n                     ast::TyI8 => i8::MIN as u64,\n                     ast::TyI16 => i16::MIN as u64,\n                     ast::TyI32 => i32::MIN as u64,"}, {"sha": "3afd33d324dd1867417772cadaf49d83931a9b29", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 674, "deletions": 674, "changes": 1348, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -124,170 +124,170 @@ pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-match ty.sty {\n-    ty::ty_open(_) => true,\n-    _ => type_is_sized(cx, ty),\n-}\n+    match ty.sty {\n+        ty::ty_open(_) => true,\n+        _ => type_is_sized(cx, ty),\n+    }\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-match ty.sty {\n-    ty::ty_ptr(ty::mt{ty, ..}) |\n-    ty::ty_rptr(_, ty::mt{ty, ..}) |\n-    ty::ty_uniq(ty) => {\n-        !type_is_sized(cx, ty)\n-    }\n-    _ => {\n-        false\n+    match ty.sty {\n+        ty::ty_ptr(ty::mt{ty, ..}) |\n+        ty::ty_rptr(_, ty::mt{ty, ..}) |\n+        ty::ty_uniq(ty) => {\n+            !type_is_sized(cx, ty)\n+        }\n+        _ => {\n+            false\n+        }\n     }\n }\n-}\n \n // Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n // 'Smallest' here means component of the static representation of the type; not\n // the size of an object at runtime.\n pub fn unsized_part_of_type<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-match ty.sty {\n-    ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n-    ty::ty_struct(def_id, substs) => {\n-        let unsized_fields: Vec<_> =\n-            ty::struct_fields(cx, def_id, substs)\n-            .iter()\n-            .map(|f| f.mt.ty)\n-            .filter(|ty| !type_is_sized(cx, *ty))\n-            .collect();\n-\n-        // Exactly one of the fields must be unsized.\n-        assert!(unsized_fields.len() == 1);\n-\n-        unsized_part_of_type(cx, unsized_fields[0])\n-    }\n-    _ => {\n-        assert!(type_is_sized(cx, ty),\n-                \"unsized_part_of_type failed even though ty is unsized\");\n-        panic!(\"called unsized_part_of_type with sized ty\");\n+    match ty.sty {\n+        ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n+        ty::ty_struct(def_id, substs) => {\n+            let unsized_fields: Vec<_> =\n+                ty::struct_fields(cx, def_id, substs)\n+                .iter()\n+                .map(|f| f.mt.ty)\n+                .filter(|ty| !type_is_sized(cx, *ty))\n+                .collect();\n+\n+            // Exactly one of the fields must be unsized.\n+            assert!(unsized_fields.len() == 1);\n+\n+            unsized_part_of_type(cx, unsized_fields[0])\n+        }\n+        _ => {\n+            assert!(type_is_sized(cx, ty),\n+                    \"unsized_part_of_type failed even though ty is unsized\");\n+            panic!(\"called unsized_part_of_type with sized ty\");\n+        }\n     }\n }\n-}\n \n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n-    type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n-});\n-\n-fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                    ty: Ty<'tcx>,\n-                                    tycache: &mut FnvHashSet<Ty<'tcx>>)\n-                                    -> bool\n-{\n-    // Prevent infinite recursion\n-    if !tycache.insert(ty) {\n-        return false;\n-    }\n-\n-    let mut needs_unwind_cleanup = false;\n-    ty::maybe_walk_ty(ty, |ty| {\n-        needs_unwind_cleanup |= match ty.sty {\n-            ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n-            ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n+    return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n+        type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n+    });\n \n-            ty::ty_enum(did, substs) =>\n-                ty::enum_variants(tcx, did).iter().any(|v|\n-                    v.args.iter().any(|&aty| {\n-                        let t = aty.subst(tcx, substs);\n-                        type_needs_unwind_cleanup_(tcx, t, tycache)\n-                    })\n-                ),\n+    fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        tycache: &mut FnvHashSet<Ty<'tcx>>)\n+                                        -> bool\n+    {\n+        // Prevent infinite recursion\n+        if !tycache.insert(ty) {\n+            return false;\n+        }\n \n-            _ => true\n-        };\n-        !needs_unwind_cleanup\n-    });\n-    needs_unwind_cleanup\n-}\n+        let mut needs_unwind_cleanup = false;\n+        ty::maybe_walk_ty(ty, |ty| {\n+            needs_unwind_cleanup |= match ty.sty {\n+                ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n+                ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n+\n+                ty::ty_enum(did, substs) =>\n+                    ty::enum_variants(tcx, did).iter().any(|v|\n+                        v.args.iter().any(|&aty| {\n+                            let t = aty.subst(tcx, substs);\n+                            type_needs_unwind_cleanup_(tcx, t, tycache)\n+                        })\n+                    ),\n+\n+                _ => true\n+            };\n+            !needs_unwind_cleanup\n+        });\n+        needs_unwind_cleanup\n+    }\n }\n \n pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>,\n                          ty: Ty<'tcx>)\n                          -> bool {\n-ty::type_contents(cx, ty).needs_drop(cx)\n+    ty::type_contents(cx, ty).needs_drop(cx)\n }\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    ty: Ty<'tcx>) -> bool {\n-match ty.sty {\n-    ty::ty_struct(def_id, substs) => {\n-        let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n-        fields.len() == 1 &&\n-            fields[0].name ==\n-                token::special_idents::unnamed_field.name &&\n-            type_is_immediate(ccx, fields[0].mt.ty)\n+    match ty.sty {\n+        ty::ty_struct(def_id, substs) => {\n+            let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n+            fields.len() == 1 &&\n+                fields[0].name ==\n+                    token::special_idents::unnamed_field.name &&\n+                type_is_immediate(ccx, fields[0].mt.ty)\n+        }\n+        _ => false\n     }\n-    _ => false\n-}\n }\n \n pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-use trans::machine::llsize_of_alloc;\n-use trans::type_of::sizing_type_of;\n-\n-let tcx = ccx.tcx();\n-let simple = ty::type_is_scalar(ty) ||\n-    ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n-    type_is_newtype_immediate(ccx, ty) ||\n-    ty::type_is_simd(tcx, ty);\n-if simple && !type_is_fat_ptr(tcx, ty) {\n-    return true;\n-}\n-if !type_is_sized(tcx, ty) {\n-    return false;\n-}\n-match ty.sty {\n-    ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n-    ty::ty_unboxed_closure(..) => {\n-        let llty = sizing_type_of(ccx, ty);\n-        llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n+    use trans::machine::llsize_of_alloc;\n+    use trans::type_of::sizing_type_of;\n+\n+    let tcx = ccx.tcx();\n+    let simple = ty::type_is_scalar(ty) ||\n+        ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n+        type_is_newtype_immediate(ccx, ty) ||\n+        ty::type_is_simd(tcx, ty);\n+    if simple && !type_is_fat_ptr(tcx, ty) {\n+        return true;\n+    }\n+    if !type_is_sized(tcx, ty) {\n+        return false;\n+    }\n+    match ty.sty {\n+        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) |\n+        ty::ty_unboxed_closure(..) => {\n+            let llty = sizing_type_of(ccx, ty);\n+            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n+        }\n+        _ => type_is_zero_size(ccx, ty)\n     }\n-    _ => type_is_zero_size(ccx, ty)\n-}\n }\n \n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-use trans::machine::llsize_of_alloc;\n-use trans::type_of::sizing_type_of;\n-let llty = sizing_type_of(ccx, ty);\n-llsize_of_alloc(ccx, llty) == 0\n+    use trans::machine::llsize_of_alloc;\n+    use trans::type_of::sizing_type_of;\n+    let llty = sizing_type_of(ccx, ty);\n+    llsize_of_alloc(ccx, llty) == 0\n }\n \n /// Identifies types which we declare to be equivalent to `void` in C for the purpose of function\n /// return types. These are `()`, bot, and uninhabited enums. Note that all such types are also\n /// zero-size, but not all zero-size types use a `void` return type (in order to aid with C ABI\n /// compatibility).\n pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n-ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n+    ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> PathElem {\n-let num = token::gensym(name).uint();\n-// use one colon which will get translated to a period by the mangler, and\n-// we're guaranteed that `num` is globally unique for this crate.\n-PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n+    let num = token::gensym(name).uint();\n+    // use one colon which will get translated to a period by the mangler, and\n+    // we're guaranteed that `num` is globally unique for this crate.\n+    PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n }\n \n #[derive(Copy)]\n pub struct tydesc_info<'tcx> {\n-pub ty: Ty<'tcx>,\n-pub tydesc: ValueRef,\n-pub size: ValueRef,\n-pub align: ValueRef,\n-pub name: ValueRef,\n+    pub ty: Ty<'tcx>,\n+    pub tydesc: ValueRef,\n+    pub size: ValueRef,\n+    pub align: ValueRef,\n+    pub name: ValueRef,\n }\n \n /*\n@@ -318,36 +318,36 @@ pub name: ValueRef,\n \n #[derive(Copy)]\n pub struct NodeInfo {\n-pub id: ast::NodeId,\n-pub span: Span,\n+    pub id: ast::NodeId,\n+    pub span: Span,\n }\n \n pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n-NodeInfo { id: expr.id, span: expr.span }\n+    NodeInfo { id: expr.id, span: expr.span }\n }\n \n pub struct BuilderRef_res {\n-pub b: BuilderRef,\n+    pub b: BuilderRef,\n }\n \n impl Drop for BuilderRef_res {\n-fn drop(&mut self) {\n-    unsafe {\n-        llvm::LLVMDisposeBuilder(self.b);\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMDisposeBuilder(self.b);\n+        }\n     }\n }\n-}\n \n pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n-BuilderRef_res {\n-    b: b\n-}\n+    BuilderRef_res {\n+        b: b\n+    }\n }\n \n pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n pub fn validate_substs(substs: &Substs) {\n-assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n }\n \n // work around bizarre resolve errors\n@@ -357,183 +357,183 @@ type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n-// The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-// address of the first instruction in the sequence of\n-// instructions for this function that will go in the .text\n-// section of the executable we're generating.\n-pub llfn: ValueRef,\n+    // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n+    // address of the first instruction in the sequence of\n+    // instructions for this function that will go in the .text\n+    // section of the executable we're generating.\n+    pub llfn: ValueRef,\n \n-// always an empty parameter-environment\n-pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+    // always an empty parameter-environment\n+    pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n-// The environment argument in a closure.\n-pub llenv: Option<ValueRef>,\n+    // The environment argument in a closure.\n+    pub llenv: Option<ValueRef>,\n \n-// A pointer to where to store the return value. If the return type is\n-// immediate, this points to an alloca in the function. Otherwise, it's a\n-// pointer to the hidden first parameter of the function. After function\n-// construction, this should always be Some.\n-pub llretslotptr: Cell<Option<ValueRef>>,\n+    // A pointer to where to store the return value. If the return type is\n+    // immediate, this points to an alloca in the function. Otherwise, it's a\n+    // pointer to the hidden first parameter of the function. After function\n+    // construction, this should always be Some.\n+    pub llretslotptr: Cell<Option<ValueRef>>,\n \n-// These pub elements: \"hoisted basic blocks\" containing\n-// administrative activities that have to happen in only one place in\n-// the function, due to LLVM's quirks.\n-// A marker for the place where we want to insert the function's static\n-// allocas, so that LLVM will coalesce them into a single alloca call.\n-pub alloca_insert_pt: Cell<Option<ValueRef>>,\n-pub llreturn: Cell<Option<BasicBlockRef>>,\n+    // These pub elements: \"hoisted basic blocks\" containing\n+    // administrative activities that have to happen in only one place in\n+    // the function, due to LLVM's quirks.\n+    // A marker for the place where we want to insert the function's static\n+    // allocas, so that LLVM will coalesce them into a single alloca call.\n+    pub alloca_insert_pt: Cell<Option<ValueRef>>,\n+    pub llreturn: Cell<Option<BasicBlockRef>>,\n \n-// If the function has any nested return's, including something like:\n-// fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n-// we use a separate alloca for each return\n-pub needs_ret_allocas: bool,\n+    // If the function has any nested return's, including something like:\n+    // fn foo() -> Option<Foo> { Some(Foo { x: return None }) }, then\n+    // we use a separate alloca for each return\n+    pub needs_ret_allocas: bool,\n \n-// The a value alloca'd for calls to upcalls.rust_personality. Used when\n-// outputting the resume instruction.\n-pub personality: Cell<Option<ValueRef>>,\n+    // The a value alloca'd for calls to upcalls.rust_personality. Used when\n+    // outputting the resume instruction.\n+    pub personality: Cell<Option<ValueRef>>,\n \n-// True if the caller expects this fn to use the out pointer to\n-// return. Either way, your code should write into the slot llretslotptr\n-// points to, but if this value is false, that slot will be a local alloca.\n-pub caller_expects_out_pointer: bool,\n+    // True if the caller expects this fn to use the out pointer to\n+    // return. Either way, your code should write into the slot llretslotptr\n+    // points to, but if this value is false, that slot will be a local alloca.\n+    pub caller_expects_out_pointer: bool,\n \n-// Maps the DefId's for local variables to the allocas created for\n-// them in llallocas.\n-pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n+    // Maps the DefId's for local variables to the allocas created for\n+    // them in llallocas.\n+    pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n \n-// Same as above, but for closure upvars\n-pub llupvars: RefCell<NodeMap<ValueRef>>,\n+    // Same as above, but for closure upvars\n+    pub llupvars: RefCell<NodeMap<ValueRef>>,\n \n-// The NodeId of the function, or -1 if it doesn't correspond to\n-// a user-defined function.\n-pub id: ast::NodeId,\n+    // The NodeId of the function, or -1 if it doesn't correspond to\n+    // a user-defined function.\n+    pub id: ast::NodeId,\n \n-// If this function is being monomorphized, this contains the type\n-// substitutions used.\n-pub param_substs: &'a Substs<'tcx>,\n+    // If this function is being monomorphized, this contains the type\n+    // substitutions used.\n+    pub param_substs: &'a Substs<'tcx>,\n \n-// The source span and nesting context where this function comes from, for\n-// error reporting and symbol generation.\n-pub span: Option<Span>,\n+    // The source span and nesting context where this function comes from, for\n+    // error reporting and symbol generation.\n+    pub span: Option<Span>,\n \n-// The arena that blocks are allocated from.\n-pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n+    // The arena that blocks are allocated from.\n+    pub block_arena: &'a TypedArena<BlockS<'a, 'tcx>>,\n \n-// This function's enclosing crate context.\n-pub ccx: &'a CrateContext<'a, 'tcx>,\n+    // This function's enclosing crate context.\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n \n-// Used and maintained by the debuginfo module.\n-pub debug_context: debuginfo::FunctionDebugContext,\n+    // Used and maintained by the debuginfo module.\n+    pub debug_context: debuginfo::FunctionDebugContext,\n \n-// Cleanup scopes.\n-pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n+    // Cleanup scopes.\n+    pub scopes: RefCell<Vec<cleanup::CleanupScope<'a, 'tcx>>>,\n \n-pub cfg: Option<cfg::CFG>,\n+    pub cfg: Option<cfg::CFG>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-pub fn arg_pos(&self, arg: uint) -> uint {\n-    let arg = self.env_arg_pos() + arg;\n-    if self.llenv.is_some() {\n-        arg + 1\n-    } else {\n-        arg\n+    pub fn arg_pos(&self, arg: uint) -> uint {\n+        let arg = self.env_arg_pos() + arg;\n+        if self.llenv.is_some() {\n+            arg + 1\n+        } else {\n+            arg\n+        }\n     }\n-}\n \n-pub fn env_arg_pos(&self) -> uint {\n-    if self.caller_expects_out_pointer {\n-        1u\n-    } else {\n-        0u\n+    pub fn env_arg_pos(&self) -> uint {\n+        if self.caller_expects_out_pointer {\n+            1u\n+        } else {\n+            0u\n+        }\n     }\n-}\n \n-pub fn cleanup(&self) {\n-    unsafe {\n-        llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n-                                                 .get()\n-                                                 .unwrap());\n+    pub fn cleanup(&self) {\n+        unsafe {\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n+                                                     .get()\n+                                                     .unwrap());\n+        }\n     }\n-}\n \n-pub fn get_llreturn(&self) -> BasicBlockRef {\n-    if self.llreturn.get().is_none() {\n+    pub fn get_llreturn(&self) -> BasicBlockRef {\n+        if self.llreturn.get().is_none() {\n \n-        self.llreturn.set(Some(unsafe {\n-            llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n-                                                \"return\\0\".as_ptr() as *const _)\n-        }))\n-    }\n+            self.llreturn.set(Some(unsafe {\n+                llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(), self.llfn,\n+                                                    \"return\\0\".as_ptr() as *const _)\n+            }))\n+        }\n \n-    self.llreturn.get().unwrap()\n-}\n+        self.llreturn.get().unwrap()\n+    }\n \n-pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n-                    output: ty::FnOutput<'tcx>,\n-                    name: &str) -> ValueRef {\n-    if self.needs_ret_allocas {\n-        base::alloca_no_lifetime(bcx, match output {\n-            ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n-            ty::FnDiverging => Type::void(bcx.ccx())\n-        }, name)\n-    } else {\n-        self.llretslotptr.get().unwrap()\n+    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n+                        output: ty::FnOutput<'tcx>,\n+                        name: &str) -> ValueRef {\n+        if self.needs_ret_allocas {\n+            base::alloca_no_lifetime(bcx, match output {\n+                ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n+                ty::FnDiverging => Type::void(bcx.ccx())\n+            }, name)\n+        } else {\n+            self.llretslotptr.get().unwrap()\n+        }\n     }\n-}\n \n-pub fn new_block(&'a self,\n-                 is_lpad: bool,\n-                 name: &str,\n-                 opt_node_id: Option<ast::NodeId>)\n-                 -> Block<'a, 'tcx> {\n-    unsafe {\n-        let name = CString::from_slice(name.as_bytes());\n-        let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n-                                                       self.llfn,\n-                                                       name.as_ptr());\n-        BlockS::new(llbb, is_lpad, opt_node_id, self)\n+    pub fn new_block(&'a self,\n+                     is_lpad: bool,\n+                     name: &str,\n+                     opt_node_id: Option<ast::NodeId>)\n+                     -> Block<'a, 'tcx> {\n+        unsafe {\n+            let name = CString::from_slice(name.as_bytes());\n+            let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n+                                                           self.llfn,\n+                                                           name.as_ptr());\n+            BlockS::new(llbb, is_lpad, opt_node_id, self)\n+        }\n     }\n-}\n \n-pub fn new_id_block(&'a self,\n-                    name: &str,\n-                    node_id: ast::NodeId)\n-                    -> Block<'a, 'tcx> {\n-    self.new_block(false, name, Some(node_id))\n-}\n+    pub fn new_id_block(&'a self,\n+                        name: &str,\n+                        node_id: ast::NodeId)\n+                        -> Block<'a, 'tcx> {\n+        self.new_block(false, name, Some(node_id))\n+    }\n \n-pub fn new_temp_block(&'a self,\n-                      name: &str)\n-                      -> Block<'a, 'tcx> {\n-    self.new_block(false, name, None)\n-}\n+    pub fn new_temp_block(&'a self,\n+                          name: &str)\n+                          -> Block<'a, 'tcx> {\n+        self.new_block(false, name, None)\n+    }\n \n-pub fn join_blocks(&'a self,\n-                   id: ast::NodeId,\n-                   in_cxs: &[Block<'a, 'tcx>])\n-                   -> Block<'a, 'tcx> {\n-    let out = self.new_id_block(\"join\", id);\n-    let mut reachable = false;\n-    for bcx in in_cxs.iter() {\n-        if !bcx.unreachable.get() {\n-            build::Br(*bcx, out.llbb);\n-            reachable = true;\n+    pub fn join_blocks(&'a self,\n+                       id: ast::NodeId,\n+                       in_cxs: &[Block<'a, 'tcx>])\n+                       -> Block<'a, 'tcx> {\n+        let out = self.new_id_block(\"join\", id);\n+        let mut reachable = false;\n+        for bcx in in_cxs.iter() {\n+            if !bcx.unreachable.get() {\n+                build::Br(*bcx, out.llbb);\n+                reachable = true;\n+            }\n         }\n+        if !reachable {\n+            build::Unreachable(out);\n+        }\n+        return out;\n     }\n-    if !reachable {\n-        build::Unreachable(out);\n-    }\n-    return out;\n-}\n \n-pub fn monomorphize<T>(&self, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n-{\n-    monomorphize::apply_param_substs(self.ccx.tcx(),\n-                                     self.param_substs,\n-                                     value)\n-}\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                         self.param_substs,\n+                                         value)\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block\n@@ -542,277 +542,277 @@ pub fn monomorphize<T>(&self, value: &T) -> T\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n pub struct BlockS<'blk, 'tcx: 'blk> {\n-// The BasicBlockRef returned from a call to\n-// llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n-// block to the function pointed to by llfn.  We insert\n-// instructions into that block by way of this block context.\n-// The block pointing to this one in the function's digraph.\n-pub llbb: BasicBlockRef,\n-pub terminated: Cell<bool>,\n-pub unreachable: Cell<bool>,\n+    // The BasicBlockRef returned from a call to\n+    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n+    // block to the function pointed to by llfn.  We insert\n+    // instructions into that block by way of this block context.\n+    // The block pointing to this one in the function's digraph.\n+    pub llbb: BasicBlockRef,\n+    pub terminated: Cell<bool>,\n+    pub unreachable: Cell<bool>,\n \n-// Is this block part of a landing pad?\n-pub is_lpad: bool,\n+    // Is this block part of a landing pad?\n+    pub is_lpad: bool,\n \n-// AST node-id associated with this block, if any. Used for\n-// debugging purposes only.\n-pub opt_node_id: Option<ast::NodeId>,\n+    // AST node-id associated with this block, if any. Used for\n+    // debugging purposes only.\n+    pub opt_node_id: Option<ast::NodeId>,\n \n-// The function context for the function to which this block is\n-// attached.\n-pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n+    // The function context for the function to which this block is\n+    // attached.\n+    pub fcx: &'blk FunctionContext<'blk, 'tcx>,\n }\n \n pub type Block<'blk, 'tcx> = &'blk BlockS<'blk, 'tcx>;\n \n impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n-pub fn new(llbb: BasicBlockRef,\n-           is_lpad: bool,\n-           opt_node_id: Option<ast::NodeId>,\n-           fcx: &'blk FunctionContext<'blk, 'tcx>)\n-           -> Block<'blk, 'tcx> {\n-    fcx.block_arena.alloc(BlockS {\n-        llbb: llbb,\n-        terminated: Cell::new(false),\n-        unreachable: Cell::new(false),\n-        is_lpad: is_lpad,\n-        opt_node_id: opt_node_id,\n-        fcx: fcx\n-    })\n-}\n+    pub fn new(llbb: BasicBlockRef,\n+               is_lpad: bool,\n+               opt_node_id: Option<ast::NodeId>,\n+               fcx: &'blk FunctionContext<'blk, 'tcx>)\n+               -> Block<'blk, 'tcx> {\n+        fcx.block_arena.alloc(BlockS {\n+            llbb: llbb,\n+            terminated: Cell::new(false),\n+            unreachable: Cell::new(false),\n+            is_lpad: is_lpad,\n+            opt_node_id: opt_node_id,\n+            fcx: fcx\n+        })\n+    }\n \n-pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n-    self.fcx.ccx\n-}\n-pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n-    self.fcx.ccx.tcx()\n-}\n-pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n+    pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n+        self.fcx.ccx\n+    }\n+    pub fn tcx(&self) -> &'blk ty::ctxt<'tcx> {\n+        self.fcx.ccx.tcx()\n+    }\n+    pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n-pub fn ident(&self, ident: Ident) -> String {\n-    token::get_ident(ident).get().to_string()\n-}\n+    pub fn ident(&self, ident: Ident) -> String {\n+        token::get_ident(ident).get().to_string()\n+    }\n \n-pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n-    self.tcx().map.node_to_string(id).to_string()\n-}\n+    pub fn node_id_to_string(&self, id: ast::NodeId) -> String {\n+        self.tcx().map.node_to_string(id).to_string()\n+    }\n \n-pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n-    e.repr(self.tcx())\n-}\n+    pub fn expr_to_string(&self, e: &ast::Expr) -> String {\n+        e.repr(self.tcx())\n+    }\n \n-pub fn def(&self, nid: ast::NodeId) -> def::Def {\n-    match self.tcx().def_map.borrow().get(&nid) {\n-        Some(v) => v.clone(),\n-        None => {\n-            self.tcx().sess.bug(&format!(\n-                \"no def associated with node id {}\", nid)[]);\n+    pub fn def(&self, nid: ast::NodeId) -> def::Def {\n+        match self.tcx().def_map.borrow().get(&nid) {\n+            Some(v) => v.clone(),\n+            None => {\n+                self.tcx().sess.bug(&format!(\n+                    \"no def associated with node id {}\", nid)[]);\n+            }\n         }\n     }\n-}\n \n-pub fn val_to_string(&self, val: ValueRef) -> String {\n-    self.ccx().tn().val_to_string(val)\n-}\n+    pub fn val_to_string(&self, val: ValueRef) -> String {\n+        self.ccx().tn().val_to_string(val)\n+    }\n \n-pub fn llty_str(&self, ty: Type) -> String {\n-    self.ccx().tn().type_to_string(ty)\n-}\n+    pub fn llty_str(&self, ty: Type) -> String {\n+        self.ccx().tn().type_to_string(ty)\n+    }\n \n-pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-    t.repr(self.tcx())\n-}\n+    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n+        t.repr(self.tcx())\n+    }\n \n-pub fn to_str(&self) -> String {\n-    format!(\"[block {:p}]\", self)\n-}\n+    pub fn to_str(&self) -> String {\n+        format!(\"[block {:p}]\", self)\n+    }\n \n-pub fn monomorphize<T>(&self, value: &T) -> T\n-    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n-{\n-    monomorphize::apply_param_substs(self.tcx(),\n-                                     self.fcx.param_substs,\n-                                     value)\n-}\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.tcx(),\n+                                         self.fcx.param_substs,\n+                                         value)\n+    }\n }\n \n impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n-fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-    self.tcx()\n-}\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+        self.tcx()\n+    }\n \n-fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-    Ok(node_id_type(self, id))\n-}\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n+        Ok(node_id_type(self, id))\n+    }\n \n-fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n-    Ok(expr_ty_adjusted(self, expr))\n-}\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n+        Ok(expr_ty_adjusted(self, expr))\n+    }\n \n-fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n-    self.tcx()\n-        .method_map\n-        .borrow()\n-        .get(&method_call)\n-        .map(|method| monomorphize_type(self, method.ty))\n-}\n+    fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {\n+        self.tcx()\n+            .method_map\n+            .borrow()\n+            .get(&method_call)\n+            .map(|method| monomorphize_type(self, method.ty))\n+    }\n \n-fn node_method_origin(&self, method_call: ty::MethodCall)\n-                      -> Option<ty::MethodOrigin<'tcx>>\n-{\n-    self.tcx()\n-        .method_map\n-        .borrow()\n-        .get(&method_call)\n-        .map(|method| method.origin.clone())\n-}\n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.tcx()\n+            .method_map\n+            .borrow()\n+            .get(&method_call)\n+            .map(|method| method.origin.clone())\n+    }\n \n-fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-    &self.tcx().adjustments\n-}\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        &self.tcx().adjustments\n+    }\n \n-fn is_method_call(&self, id: ast::NodeId) -> bool {\n-    self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n-}\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tcx().method_map.borrow().contains_key(&ty::MethodCall::expr(id))\n+    }\n \n-fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n-    self.tcx().region_maps.temporary_scope(rvalue_id)\n-}\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent> {\n+        self.tcx().region_maps.temporary_scope(rvalue_id)\n+    }\n \n-fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-    Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n-}\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n+        Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n+    }\n \n-fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                -> ast::CaptureClause {\n-    self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n-}\n+    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n+                    -> ast::CaptureClause {\n+        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n+    }\n \n-fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n-    self.fcx.param_env.type_moves_by_default(span, ty)\n-}\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        self.fcx.param_env.type_moves_by_default(span, ty)\n+    }\n }\n \n impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {\n-fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n-    &self.fcx.param_env\n-}\n+    fn param_env<'a>(&'a self) -> &'a ty::ParameterEnvironment<'a, 'tcx> {\n+        &self.fcx.param_env\n+    }\n \n-fn unboxed_closure_kind(&self,\n-                        def_id: ast::DefId)\n-                        -> ty::UnboxedClosureKind\n-{\n-    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-    typer.unboxed_closure_kind(def_id)\n-}\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_kind(def_id)\n+    }\n \n-fn unboxed_closure_type(&self,\n-                        def_id: ast::DefId,\n-                        substs: &subst::Substs<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-{\n-    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-    typer.unboxed_closure_type(def_id, substs)\n-}\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_type(def_id, substs)\n+    }\n \n-fn unboxed_closure_upvars(&self,\n-                          def_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n-                          -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n-{\n-    let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n-    typer.unboxed_closure_upvars(def_id, substs)\n-}\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        let typer = NormalizingUnboxedClosureTyper::new(self.tcx());\n+        typer.unboxed_closure_upvars(def_id, substs)\n+    }\n }\n \n pub struct Result<'blk, 'tcx: 'blk> {\n-pub bcx: Block<'blk, 'tcx>,\n-pub val: ValueRef\n+    pub bcx: Block<'blk, 'tcx>,\n+    pub val: ValueRef\n }\n \n impl<'b, 'tcx> Result<'b, 'tcx> {\n-pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n-    Result {\n-        bcx: bcx,\n-        val: val,\n+    pub fn new(bcx: Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n+        Result {\n+            bcx: bcx,\n+            val: val,\n+        }\n     }\n }\n-}\n \n pub fn val_ty(v: ValueRef) -> Type {\n-unsafe {\n-    Type::from_ref(llvm::LLVMTypeOf(v))\n-}\n+    unsafe {\n+        Type::from_ref(llvm::LLVMTypeOf(v))\n+    }\n }\n \n // LLVM constant constructors.\n pub fn C_null(t: Type) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstNull(t.to_ref())\n-}\n+    unsafe {\n+        llvm::LLVMConstNull(t.to_ref())\n+    }\n }\n \n pub fn C_undef(t: Type) -> ValueRef {\n-unsafe {\n-    llvm::LLVMGetUndef(t.to_ref())\n-}\n+    unsafe {\n+        llvm::LLVMGetUndef(t.to_ref())\n+    }\n }\n \n pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n-}\n+    unsafe {\n+        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n+    }\n }\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n-unsafe {\n-    let s = CString::from_slice(s.as_bytes());\n-    llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n-}\n+    unsafe {\n+        let s = CString::from_slice(s.as_bytes());\n+        llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n+    }\n }\n \n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n-C_struct(ccx, &[], false)\n+    C_struct(ccx, &[], false)\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-C_integral(Type::i1(ccx), val as u64, false)\n+    C_integral(Type::i1(ccx), val as u64, false)\n }\n \n pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n-C_integral(Type::i32(ccx), i as u64, true)\n+    C_integral(Type::i32(ccx), i as u64, true)\n }\n \n pub fn C_i64(ccx: &CrateContext, i: i64) -> ValueRef {\n-C_integral(Type::i64(ccx), i as u64, true)\n+    C_integral(Type::i64(ccx), i as u64, true)\n }\n \n pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n-C_integral(Type::i64(ccx), i, false)\n+    C_integral(Type::i64(ccx), i, false)\n }\n \n pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n-let v = i.as_i64();\n+    let v = i.as_i64();\n \n-match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-    32 => assert!(v < (1<<31) && v >= -(1<<31)),\n-    64 => {},\n-    n => panic!(\"unsupported target size: {}\", n)\n-}\n+    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+        32 => assert!(v < (1<<31) && v >= -(1<<31)),\n+        64 => {},\n+        n => panic!(\"unsupported target size: {}\", n)\n+    }\n \n-C_integral(ccx.int_type(), v as u64, true)\n+    C_integral(ccx.int_type(), v as u64, true)\n }\n \n pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n-let v = i.as_u64();\n+    let v = i.as_u64();\n \n-match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-    32 => assert!(v < (1<<32)),\n-    64 => {},\n-    n => panic!(\"unsupported target size: {}\", n)\n-}\n+    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n+        32 => assert!(v < (1<<32)),\n+        64 => {},\n+        n => panic!(\"unsupported target size: {}\", n)\n+    }\n \n-C_integral(ccx.int_type(), v, false)\n+    C_integral(ccx.int_type(), v, false)\n }\n \n pub trait AsI64 { fn as_i64(self) -> i64; }\n@@ -829,157 +829,157 @@ impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n impl AsU64 for uint { fn as_u64(self) -> u64 { self as u64 }}\n \n pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n-C_integral(Type::i8(ccx), i as u64, false)\n+    C_integral(Type::i8(ccx), i as u64, false)\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n-unsafe {\n-    match cx.const_cstr_cache().borrow().get(&s) {\n-        Some(&llval) => return llval,\n-        None => ()\n-    }\n+    unsafe {\n+        match cx.const_cstr_cache().borrow().get(&s) {\n+            Some(&llval) => return llval,\n+            None => ()\n+        }\n \n-    let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n-                                            s.get().as_ptr() as *const c_char,\n-                                            s.get().len() as c_uint,\n-                                            !null_terminated as Bool);\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n+                                                s.get().as_ptr() as *const c_char,\n+                                                s.get().len() as c_uint,\n+                                                !null_terminated as Bool);\n \n-    let gsym = token::gensym(\"str\");\n-    let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n-    let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n-    llvm::LLVMSetInitializer(g, sc);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-    llvm::SetLinkage(g, llvm::InternalLinkage);\n+        let gsym = token::gensym(\"str\");\n+        let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n+        llvm::LLVMSetInitializer(g, sc);\n+        llvm::LLVMSetGlobalConstant(g, True);\n+        llvm::SetLinkage(g, llvm::InternalLinkage);\n \n-    cx.const_cstr_cache().borrow_mut().insert(s, g);\n-    g\n-}\n+        cx.const_cstr_cache().borrow_mut().insert(s, g);\n+        g\n+    }\n }\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n-let len = s.get().len();\n-let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n+    let len = s.get().len();\n+    let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n+    C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }\n \n pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n-unsafe {\n-    let len = data.len();\n-    let lldata = C_bytes(cx, data);\n-\n-    let gsym = token::gensym(\"binary\");\n-    let name = format!(\"binary{}\", gsym.uint());\n-    let name = CString::from_vec(name.into_bytes());\n-    let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n-                                name.as_ptr());\n-    llvm::LLVMSetInitializer(g, lldata);\n-    llvm::LLVMSetGlobalConstant(g, True);\n-    llvm::SetLinkage(g, llvm::InternalLinkage);\n-\n-    let cs = consts::ptrcast(g, Type::i8p(cx));\n-    C_struct(cx, &[cs, C_uint(cx, len)], false)\n-}\n+    unsafe {\n+        let len = data.len();\n+        let lldata = C_bytes(cx, data);\n+\n+        let gsym = token::gensym(\"binary\");\n+        let name = format!(\"binary{}\", gsym.uint());\n+        let name = CString::from_vec(name.into_bytes());\n+        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n+                                    name.as_ptr());\n+        llvm::LLVMSetInitializer(g, lldata);\n+        llvm::LLVMSetGlobalConstant(g, True);\n+        llvm::SetLinkage(g, llvm::InternalLinkage);\n+\n+        let cs = consts::ptrcast(g, Type::i8p(cx));\n+        C_struct(cx, &[cs, C_uint(cx, len)], false)\n+    }\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n-C_struct_in_context(cx.llcx(), elts, packed)\n+    C_struct_in_context(cx.llcx(), elts, packed)\n }\n \n pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstStructInContext(llcx,\n-                                   elts.as_ptr(), elts.len() as c_uint,\n-                                   packed as Bool)\n-}\n+    unsafe {\n+        llvm::LLVMConstStructInContext(llcx,\n+                                       elts.as_ptr(), elts.len() as c_uint,\n+                                       packed as Bool)\n+    }\n }\n \n pub fn C_named_struct(t: Type, elts: &[ValueRef]) -> ValueRef {\n-unsafe {\n-    llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n-}\n+    unsafe {\n+        llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n+    }\n }\n \n pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n-unsafe {\n-    return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n-}\n+    unsafe {\n+        return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n+    }\n }\n \n pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n-C_bytes_in_context(cx.llcx(), bytes)\n+    C_bytes_in_context(cx.llcx(), bytes)\n }\n \n pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n-unsafe {\n-    let ptr = bytes.as_ptr() as *const c_char;\n-    return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n-}\n+    unsafe {\n+        let ptr = bytes.as_ptr() as *const c_char;\n+        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+    }\n }\n \n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n               -> ValueRef {\n-unsafe {\n-    let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+    unsafe {\n+        let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-    debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n-           cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n+        debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n+               cx.tn().val_to_string(v), us, cx.tn().val_to_string(r));\n \n-    return r;\n-}\n+        return r;\n+    }\n }\n \n pub fn is_const(v: ValueRef) -> bool {\n-unsafe {\n-    llvm::LLVMIsConstant(v) == True\n-}\n+    unsafe {\n+        llvm::LLVMIsConstant(v) == True\n+    }\n }\n \n pub fn const_to_int(v: ValueRef) -> i64 {\n-unsafe {\n-    llvm::LLVMConstIntGetSExtValue(v)\n-}\n+    unsafe {\n+        llvm::LLVMConstIntGetSExtValue(v)\n+    }\n }\n \n pub fn const_to_uint(v: ValueRef) -> u64 {\n-unsafe {\n-    llvm::LLVMConstIntGetZExtValue(v)\n-}\n+    unsafe {\n+        llvm::LLVMConstIntGetZExtValue(v)\n+    }\n }\n \n pub fn is_undef(val: ValueRef) -> bool {\n-unsafe {\n-    llvm::LLVMIsUndef(val) != False\n-}\n+    unsafe {\n+        llvm::LLVMIsUndef(val) != False\n+    }\n }\n \n #[allow(dead_code)] // potentially useful\n pub fn is_null(val: ValueRef) -> bool {\n-unsafe {\n-    llvm::LLVMIsNull(val) != False\n-}\n+    unsafe {\n+        llvm::LLVMIsNull(val) != False\n+    }\n }\n \n pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-bcx.fcx.monomorphize(&t)\n+    bcx.fcx.monomorphize(&t)\n }\n \n pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n-let tcx = bcx.tcx();\n-let t = ty::node_id_to_type(tcx, id);\n-monomorphize_type(bcx, t)\n+    let tcx = bcx.tcx();\n+    let t = ty::node_id_to_type(tcx, id);\n+    monomorphize_type(bcx, t)\n }\n \n pub fn expr_ty<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-node_id_type(bcx, ex.id)\n+    node_id_type(bcx, ex.id)\n }\n \n pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n-monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n+    monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n@@ -990,191 +990,191 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 trait_ref: ty::PolyTraitRef<'tcx>)\n                                 -> traits::Vtable<'tcx, ()>\n {\n-let tcx = ccx.tcx();\n-\n-// Remove any references to regions; this helps improve caching.\n-let trait_ref = erase_regions(tcx, &trait_ref);\n-\n-// First check the cache.\n-match ccx.trait_cache().borrow().get(&trait_ref) {\n-    Some(vtable) => {\n-        info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n-        return (*vtable).clone();\n-    }\n-    None => { }\n-}\n-\n-debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n-\n-ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n-let infcx = infer::new_infer_ctxt(tcx);\n-\n-// Do the initial selection for the obligation. This yields the\n-// shallow result we are looking for -- that is, what specific impl.\n-let typer = NormalizingUnboxedClosureTyper::new(tcx);\n-let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                         trait_ref.to_poly_trait_predicate());\n-let selection = match selcx.select(&obligation) {\n-    Ok(Some(selection)) => selection,\n-    Ok(None) => {\n-        // Ambiguity can happen when monomorphizing during trans\n-        // expands to some humongo type that never occurred\n-        // statically -- this humongo type can then overflow,\n-        // leading to an ambiguous result. So report this as an\n-        // overflow bug, since I believe this is the only case\n-        // where ambiguity can result.\n-        debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n-                presuming due to overflow\",\n-               trait_ref.repr(tcx));\n-        ccx.sess().span_fatal(\n-            span,\n-            \"reached the recursion limit during monomorphization\");\n-    }\n-    Err(e) => {\n-        tcx.sess.span_bug(\n-            span,\n-            &format!(\"Encountered error `{}` selecting `{}` during trans\",\n-                    e.repr(tcx),\n-                    trait_ref.repr(tcx))[])\n-    }\n-};\n-\n-// Currently, we use a fulfillment context to completely resolve\n-// all nested obligations. This is because they can inform the\n-// inference of the impl's type parameters.\n-let mut fulfill_cx = traits::FulfillmentContext::new();\n-let vtable = selection.map_move_nested(|predicate| {\n-    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-});\n-let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n-\n-info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n-ccx.trait_cache().borrow_mut().insert(trait_ref,\n-                                      vtable.clone());\n-\n-vtable\n+    let tcx = ccx.tcx();\n+\n+    // Remove any references to regions; this helps improve caching.\n+    let trait_ref = erase_regions(tcx, &trait_ref);\n+\n+    // First check the cache.\n+    match ccx.trait_cache().borrow().get(&trait_ref) {\n+        Some(vtable) => {\n+            info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n+            return (*vtable).clone();\n+        }\n+        None => { }\n+    }\n+\n+    debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n+\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    // Do the initial selection for the obligation. This yields the\n+    // shallow result we are looking for -- that is, what specific impl.\n+    let typer = NormalizingUnboxedClosureTyper::new(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n+    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                             trait_ref.to_poly_trait_predicate());\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(selection)) => selection,\n+        Ok(None) => {\n+            // Ambiguity can happen when monomorphizing during trans\n+            // expands to some humongo type that never occurred\n+            // statically -- this humongo type can then overflow,\n+            // leading to an ambiguous result. So report this as an\n+            // overflow bug, since I believe this is the only case\n+            // where ambiguity can result.\n+            debug!(\"Encountered ambiguity selecting `{}` during trans, \\\n+                    presuming due to overflow\",\n+                   trait_ref.repr(tcx));\n+            ccx.sess().span_fatal(\n+                span,\n+                \"reached the recursion limit during monomorphization\");\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(\n+                span,\n+                &format!(\"Encountered error `{}` selecting `{}` during trans\",\n+                        e.repr(tcx),\n+                        trait_ref.repr(tcx))[])\n+        }\n+    };\n+\n+    // Currently, we use a fulfillment context to completely resolve\n+    // all nested obligations. This is because they can inform the\n+    // inference of the impl's type parameters.\n+    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let vtable = selection.map_move_nested(|predicate| {\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+    });\n+    let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n+\n+    info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n+    ccx.trait_cache().borrow_mut().insert(trait_ref,\n+                                          vtable.clone());\n+\n+    vtable\n }\n \n pub struct NormalizingUnboxedClosureTyper<'a,'tcx:'a> {\n-param_env: ty::ParameterEnvironment<'a, 'tcx>\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n \n impl<'a,'tcx> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n-    // Parameter environment is used to give details about type parameters,\n-    // but since we are in trans, everything is fully monomorphized.\n-    NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n-}\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> NormalizingUnboxedClosureTyper<'a,'tcx> {\n+        // Parameter environment is used to give details about type parameters,\n+        // but since we are in trans, everything is fully monomorphized.\n+        NormalizingUnboxedClosureTyper { param_env: ty::empty_parameter_environment(tcx) }\n+    }\n }\n \n impl<'a,'tcx> ty::UnboxedClosureTyper<'tcx> for NormalizingUnboxedClosureTyper<'a,'tcx> {\n-fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-    &self.param_env\n-}\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.param_env\n+    }\n \n-fn unboxed_closure_kind(&self,\n-                        def_id: ast::DefId)\n-                        -> ty::UnboxedClosureKind\n-{\n-    self.param_env.tcx.unboxed_closure_kind(def_id)\n-}\n+    fn unboxed_closure_kind(&self,\n+                            def_id: ast::DefId)\n+                            -> ty::UnboxedClosureKind\n+    {\n+        self.param_env.tcx.unboxed_closure_kind(def_id)\n+    }\n \n-fn unboxed_closure_type(&self,\n-                        def_id: ast::DefId,\n-                        substs: &subst::Substs<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-{\n-    // the substitutions in `substs` are already monomorphized,\n-    // but we still must normalize associated types\n-    let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n-    monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n-}\n+    fn unboxed_closure_type(&self,\n+                            def_id: ast::DefId,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> ty::ClosureTy<'tcx>\n+    {\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let closure_ty = self.param_env.tcx.unboxed_closure_type(def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &closure_ty)\n+    }\n \n-fn unboxed_closure_upvars(&self,\n-                          def_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n-                          -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n-{\n-    // the substitutions in `substs` are already monomorphized,\n-    // but we still must normalize associated types\n-    let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n-    monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n-}\n+    fn unboxed_closure_upvars(&self,\n+                              def_id: ast::DefId,\n+                              substs: &Substs<'tcx>)\n+                              -> Option<Vec<ty::UnboxedClosureUpvar<'tcx>>>\n+    {\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let result = ty::unboxed_closure_upvars(&self.param_env, def_id, substs);\n+        monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n+    }\n }\n \n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                                    infcx: &infer::InferCtxt<'a,'tcx>,\n                                    fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                    result: &T)\n                                    -> T\n-where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-debug!(\"drain_fulfillment_cx(result={})\",\n-       result.repr(infcx.tcx));\n-\n-// In principle, we only need to do this so long as `result`\n-// contains unbound type parameters. It could be a slight\n-// optimization to stop iterating early.\n-let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n-match fulfill_cx.select_all_or_error(infcx, &typer) {\n-    Ok(()) => { }\n-    Err(errors) => {\n-        if errors.iter().all(|e| e.is_overflow()) {\n-            // See Ok(None) case above.\n-            infcx.tcx.sess.span_fatal(\n-                span,\n-                \"reached the recursion limit during monomorphization\");\n-        } else {\n-            infcx.tcx.sess.span_bug(\n-                span,\n-                &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                        errors.repr(infcx.tcx))[]);\n+    debug!(\"drain_fulfillment_cx(result={})\",\n+           result.repr(infcx.tcx));\n+\n+    // In principle, we only need to do this so long as `result`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    let typer = NormalizingUnboxedClosureTyper::new(infcx.tcx);\n+    match fulfill_cx.select_all_or_error(infcx, &typer) {\n+        Ok(()) => { }\n+        Err(errors) => {\n+            if errors.iter().all(|e| e.is_overflow()) {\n+                // See Ok(None) case above.\n+                infcx.tcx.sess.span_fatal(\n+                    span,\n+                    \"reached the recursion limit during monomorphization\");\n+            } else {\n+                infcx.tcx.sess.span_bug(\n+                    span,\n+                    &format!(\"Encountered errors `{}` fulfilling during trans\",\n+                            errors.repr(infcx.tcx))[]);\n+            }\n         }\n     }\n-}\n \n-// Use freshen to simultaneously replace all type variables with\n-// their bindings and replace all regions with 'static.  This is\n-// sort of overkill because we do not expect there to be any\n-// unbound type variables, hence no `TyFresh` types should ever be\n-// inserted.\n-result.fold_with(&mut infcx.freshener())\n+    // Use freshen to simultaneously replace all type variables with\n+    // their bindings and replace all regions with 'static.  This is\n+    // sort of overkill because we do not expect there to be any\n+    // unbound type variables, hence no `TyFresh` types should ever be\n+    // inserted.\n+    result.fold_with(&mut infcx.freshener())\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n #[derive(Copy, PartialEq, Show)]\n pub enum ExprOrMethodCall {\n-// Type parameters for a path like `None::<int>`\n-ExprId(ast::NodeId),\n+    // Type parameters for a path like `None::<int>`\n+    ExprId(ast::NodeId),\n \n-// Type parameters for a method call like `a.foo::<int>()`\n-MethodCallKey(ty::MethodCall)\n+    // Type parameters for a method call like `a.foo::<int>()`\n+    MethodCallKey(ty::MethodCall)\n }\n \n pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             node: ExprOrMethodCall,\n                             param_substs: &subst::Substs<'tcx>)\n                             -> subst::Substs<'tcx> {\n-let tcx = ccx.tcx();\n+    let tcx = ccx.tcx();\n \n-let substs = match node {\n-    ExprId(id) => {\n-        ty::node_id_item_substs(tcx, id).substs\n-    }\n-    MethodCallKey(method_call) => {\n-        (*tcx.method_map.borrow())[method_call].substs.clone()\n-    }\n-};\n+    let substs = match node {\n+        ExprId(id) => {\n+            ty::node_id_item_substs(tcx, id).substs\n+        }\n+        MethodCallKey(method_call) => {\n+            (*tcx.method_map.borrow())[method_call].substs.clone()\n+        }\n+    };\n \n-if substs.types.any(|t| ty::type_needs_infer(*t)) {\n-        tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                             node, substs.repr(tcx))[]);\n-    }\n+    if substs.types.any(|t| ty::type_needs_infer(*t)) {\n+            tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n+                                 node, substs.repr(tcx))[]);\n+        }\n \n-    monomorphize::apply_param_substs(tcx,\n-                                     param_substs,\n-                                     &substs.erase_regions())\n+        monomorphize::apply_param_substs(tcx,\n+                                         param_substs,\n+                                         &substs.erase_regions())\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "2f58baab7fca944327b5e073538c0e9150431f62", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -1804,14 +1804,14 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n         ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n-            ast::TyIs => (\"isize\".to_string(), DW_ATE_signed),\n+            ast::TyIs(_) => (\"isize\".to_string(), DW_ATE_signed),\n             ast::TyI8 => (\"i8\".to_string(), DW_ATE_signed),\n             ast::TyI16 => (\"i16\".to_string(), DW_ATE_signed),\n             ast::TyI32 => (\"i32\".to_string(), DW_ATE_signed),\n             ast::TyI64 => (\"i64\".to_string(), DW_ATE_signed)\n         },\n         ty::ty_uint(uint_ty) => match uint_ty {\n-            ast::TyUs => (\"usize\".to_string(), DW_ATE_unsigned),\n+            ast::TyUs(_) => (\"usize\".to_string(), DW_ATE_unsigned),\n             ast::TyU8 => (\"u8\".to_string(), DW_ATE_unsigned),\n             ast::TyU16 => (\"u16\".to_string(), DW_ATE_unsigned),\n             ast::TyU32 => (\"u32\".to_string(), DW_ATE_unsigned),\n@@ -3739,12 +3739,12 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n         ty::ty_str               => output.push_str(\"str\"),\n-        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n+        ty::ty_int(ast::TyIs(_))     => output.push_str(\"isize\"),\n         ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n         ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n         ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n         ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n-        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n+        ty::ty_uint(ast::TyUs(_))    => output.push_str(\"usize\"),\n         ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n         ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n         ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),"}, {"sha": "71a7789eb393277ec4a7372554d44a399001d6a1", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -112,7 +112,7 @@ impl Type {\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::TyIs => ccx.int_type(),\n+            ast::TyIs(_) => ccx.int_type(),\n             ast::TyI8 => Type::i8(ccx),\n             ast::TyI16 => Type::i16(ccx),\n             ast::TyI32 => Type::i32(ccx),\n@@ -122,7 +122,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::TyUs => ccx.int_type(),\n+            ast::TyUs(_) => ccx.int_type(),\n             ast::TyU8 => Type::i8(ccx),\n             ast::TyU16 => Type::i16(ccx),\n             ast::TyU32 => Type::i32(ccx),"}, {"sha": "99330797422299b817bbdc9521f663151ce13e88", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -263,7 +263,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         }\n \n         match unsized_part_of_type(cx.tcx(), t).sty {\n-            ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyUs),\n+            ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyUs(false)),\n             ty::ty_trait(_) => Type::vtable_ptr(cx),\n             _ => panic!(\"Unexpected type returned from unsized_part_of_type : {}\",\n                        t.repr(cx.tcx()))"}, {"sha": "19a88dfc553b68159675280fc4f9195c8e54f5a7", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -73,7 +73,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         autoderef(fcx,\n                   callee_expr.span,\n                   original_callee_ty,\n-                  Some(callee_expr.id),\n+                  Some(callee_expr),\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {\n                       let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };"}, {"sha": "7946077485976e4cd3bbfa8128f4f7b97865f8b0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -143,7 +143,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // time writing the results into the various tables.\n         let (autoderefd_ty, n, result) =\n             check::autoderef(\n-                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr.id), NoPreference,\n+                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr), NoPreference,\n                 |_, n| if n == auto_deref_ref.autoderefs { Some(()) } else { None });\n         assert_eq!(n, auto_deref_ref.autoderefs);\n         assert_eq!(result, Some(()));\n@@ -492,7 +492,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                exprs.repr(self.tcx()));\n \n         // Fix up autoderefs and derefs.\n-        for (i, expr) in exprs.iter().rev().enumerate() {\n+        for (i, &expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n             let autoderef_count = match self.fcx\n                                             .inh\n@@ -512,8 +512,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n                                  expr.span,\n-                                 self.fcx.expr_ty(*expr),\n-                                 Some(expr.id),\n+                                 self.fcx.expr_ty(expr),\n+                                 Some(expr),\n                                  PreferMutLvalue,\n                                  |_, autoderefs| {\n                                      if autoderefs == autoderef_count + 1 {\n@@ -567,7 +567,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         let result = check::try_index_step(\n                             self.fcx,\n                             MethodCall::expr(expr.id),\n-                            *expr,\n+                            expr,\n                             &**base_expr,\n                             adjusted_base_ty,\n                             base_adjustment,\n@@ -577,7 +577,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         if let Some((input_ty, return_ty)) = result {\n                             demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n \n-                            let expr_ty = self.fcx.expr_ty(&**expr);\n+                            let expr_ty = self.fcx.expr_ty(&*expr);\n                             demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n                         }\n                     }"}, {"sha": "0c53a16a8118b2a76d746d6f0e749b2aa02c311d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -102,9 +102,9 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n-pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  span: Span,\n-                                 self_expr: Option<&'a ast::Expr>,\n+                                 self_expr: Option<&ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n                                  self_ty: Ty<'tcx>,\n@@ -125,9 +125,9 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n /// method-lookup code. In particular, autoderef on index is basically identical to autoderef with\n /// normal probes, except that the test also looks for built-in indexing. Also, the second half of\n /// this method is basically the same as confirmation.\n-pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           span: Span,\n-                                          self_expr: Option<&'a ast::Expr>,\n+                                          self_expr: Option<&ast::Expr>,\n                                           m_name: ast::Name,\n                                           trait_def_id: DefId,\n                                           autoderefref: ty::AutoDerefRef<'tcx>,"}, {"sha": "1d184131dede3c017b35d279018f1a922db35200", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -2268,12 +2268,17 @@ pub enum LvaluePreference {\n pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  sp: Span,\n                                  base_ty: Ty<'tcx>,\n-                                 expr_id: Option<ast::NodeId>,\n+                                 opt_expr: Option<&ast::Expr>,\n                                  mut lvalue_pref: LvaluePreference,\n                                  mut should_stop: F)\n-                                 -> (Ty<'tcx>, uint, Option<T>) where\n-    F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n+                                 -> (Ty<'tcx>, uint, Option<T>)\n+    where F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n {\n+    debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={:?})\",\n+           base_ty.repr(fcx.tcx()),\n+           opt_expr.repr(fcx.tcx()),\n+           lvalue_pref);\n+\n     let mut t = base_ty;\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n@@ -2291,7 +2296,19 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mt = match ty::deref(resolved_t, false) {\n             Some(mt) => Some(mt),\n             None => {\n-                let method_call = expr_id.map(|id| MethodCall::autoderef(id, autoderefs));\n+                let method_call = opt_expr.map(|expr| MethodCall::autoderef(expr.id, autoderefs));\n+\n+                // Super subtle: it might seem as though we should\n+                // pass `opt_expr` to `try_overloaded_deref`, so that\n+                // the (implicit) autoref of using an overloaded deref\n+                // would get added to the adjustment table. However we\n+                // do not do that, because it's kind of a\n+                // \"meta-adjustment\" -- instead, we just leave it\n+                // unrecorded and know that there \"will be\" an\n+                // autoref. regionck and other bits of the code base,\n+                // when they encounter an overloaded autoderef, have\n+                // to do some reconstructive surgery. This is a pretty\n+                // complex mess that is begging for a proper MIR.\n                 try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n             }\n         };\n@@ -2324,7 +2341,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+            method::lookup_in_trait(fcx, span, base_expr,\n                                     token::intern(\"deref_mut\"), trait_did,\n                                     base_ty, None)\n         }\n@@ -2334,7 +2351,7 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Otherwise, fall back to Deref.\n     let method = match (method, fcx.tcx().lang_items.deref_trait()) {\n         (None, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n+            method::lookup_in_trait(fcx, span, base_expr,\n                                     token::intern(\"deref\"), trait_did,\n                                     base_ty, None)\n         }\n@@ -2390,7 +2407,7 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // consolidated.\n \n     let (ty, autoderefs, final_mt) =\n-        autoderef(fcx, base_expr.span, base_ty, Some(base_expr.id), lvalue_pref, |adj_ty, idx| {\n+        autoderef(fcx, base_expr.span, base_ty, Some(base_expr), lvalue_pref, |adj_ty, idx| {\n             let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n             step(adj_ty, autoderefref)\n         });\n@@ -2442,7 +2459,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // First, try built-in indexing.\n     match (ty::index(adjusted_ty), &index_ty.sty) {\n-        (Some(ty), &ty::ty_uint(ast::TyUs)) | (Some(ty), &ty::ty_infer(ty::IntVar(_))) => {\n+        (Some(ty), &ty::ty_uint(ast::TyUs(_))) | (Some(ty), &ty::ty_infer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n             return Some((tcx.types.uint, ty));\n@@ -3208,8 +3225,24 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n-            check_expr_has_type(fcx, &**rhs, fcx.tcx().types.uint);\n-            fcx.write_ty(expr.id, lhs_t);\n+            check_expr(fcx, &**rhs);\n+            let rhs_ty = fcx.expr_ty(&**rhs);\n+            let rhs_ty = fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+            if ty::type_is_integral(rhs_ty) {\n+                fcx.write_ty(expr.id, lhs_t);\n+            } else {\n+                fcx.type_error_message(\n+                    expr.span,\n+                    |actual| {\n+                        format!(\n+                            \"right-hand-side of a shift operation must have integral type, \\\n+                             not `{}`\",\n+                            actual)\n+                    },\n+                    rhs_ty,\n+                    None);\n+                fcx.write_ty(expr.id, fcx.tcx().types.err);\n+            }\n             return;\n         }\n \n@@ -3360,7 +3393,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 fcx.expr_ty(base));\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n@@ -3421,7 +3454,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut tuple_like = false;\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base.id), lvalue_pref, |base_t, _| {\n+            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);\n@@ -4770,7 +4803,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 ast::TyU16 => disr as u16 as Disr == disr,\n                 ast::TyU32 => disr as u32 as Disr == disr,\n                 ast::TyU64 => disr as u64 as Disr == disr,\n-                ast::TyUs => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n+                ast::TyUs(_) => uint_in_range(ccx, ccx.tcx.sess.target.uint_type, disr)\n             }\n         }\n         fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n@@ -4779,7 +4812,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 ast::TyI16 => disr as i16 as Disr == disr,\n                 ast::TyI32 => disr as i32 as Disr == disr,\n                 ast::TyI64 => disr as i64 as Disr == disr,\n-                ast::TyIs => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n+                ast::TyIs(_) => int_in_range(ccx, ccx.tcx.sess.target.int_type, disr)\n             }\n         }\n         match ty {"}, {"sha": "3b5027dbb9e69c22a0eedc4a26e9354386ba0928", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -936,37 +936,55 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   deref_expr: &ast::Expr,\n                                   derefs: uint,\n-                                  mut derefd_ty: Ty<'tcx>) {\n+                                  mut derefd_ty: Ty<'tcx>)\n+{\n+    debug!(\"constrain_autoderefs(deref_expr={}, derefs={}, derefd_ty={})\",\n+           deref_expr.repr(rcx.tcx()),\n+           derefs,\n+           derefd_ty.repr(rcx.tcx()));\n+\n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n     for i in range(0u, derefs) {\n-        debug!(\"constrain_autoderefs(deref_expr=?, derefd_ty={}, derefs={}/{}\",\n-               rcx.fcx.infcx().ty_to_string(derefd_ty),\n-               i, derefs);\n-\n         let method_call = MethodCall::autoderef(deref_expr.id, i);\n+        debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n+\n         derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n             Some(method) => {\n+                debug!(\"constrain_autoderefs: #{} is overloaded, method={}\",\n+                       i, method.repr(rcx.tcx()));\n+\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n-                let self_ty = fn_sig.0.inputs[0];\n+                let fn_sig = // late-bound regions should have been instantiated\n+                    ty::assert_no_late_bound_regions(rcx.tcx(), fn_sig);\n+                let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n-                    _ => rcx.tcx().sess.span_bug(deref_expr.span,\n+                    _ => {\n+                        rcx.tcx().sess.span_bug(\n+                            deref_expr.span,\n                             &format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(rcx.tcx()))[])\n+                                     method.ty.repr(rcx.tcx()))[])\n+                    }\n                 };\n+\n+                debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n+                       r.repr(rcx.tcx()), m);\n+\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n+                    debug!(\"constrain_autoderefs: self_cmt={:?}\",\n+                           self_cmt.repr(rcx.tcx()));\n                     link_region(rcx, deref_expr.span, *r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n                 // Specialized version of constrain_call.\n                 type_must_outlive(rcx, infer::CallRcvr(deref_expr.span),\n                                   self_ty, r_deref_expr);\n-                match fn_sig.0.output {\n+                match fn_sig.output {\n                     ty::FnConverging(return_type) => {\n                         type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n                                           return_type, r_deref_expr);\n@@ -1049,13 +1067,16 @@ fn type_of_node_must_outlive<'a, 'tcx>(\n /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n /// resulting pointer is linked to the lifetime of its guarantor (if any).\n fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n-               mutability: ast::Mutability, base: &ast::Expr) {\n-    debug!(\"link_addr_of(base=?)\");\n+                mutability: ast::Mutability, base: &ast::Expr) {\n+    debug!(\"link_addr_of(expr={}, base={})\", expr.repr(rcx.tcx()), base.repr(rcx.tcx()));\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n         ignore_err!(mc.cat_expr(base))\n     };\n+\n+    debug!(\"link_addr_of: cmt={}\", cmt.repr(rcx.tcx()));\n+\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n \n@@ -1182,6 +1203,9 @@ fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                         id: ast::NodeId,\n                                         mutbl: ast::Mutability,\n                                         cmt_borrowed: mc::cmt<'tcx>) {\n+    debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={})\",\n+           id, mutbl, cmt_borrowed.repr(rcx.tcx()));\n+\n     let rptr_ty = rcx.resolve_node_type(id);\n     if !ty::type_is_error(rptr_ty) {\n         let tcx = rcx.fcx.ccx.tcx;"}, {"sha": "89de1ea80fcf42fd2328c9e19f92b9b409a99791", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -235,9 +235,16 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // Find the supertrait bounds. This will add `int:Bar`.\n             let poly_trait_ref = ty::Binder(trait_ref);\n             let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &poly_trait_ref);\n-            for predicate in predicates.into_iter() {\n+            let predicates = {\n+                let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n+                traits::normalize(selcx, cause.clone(), &predicates)\n+            };\n+            for predicate in predicates.value.into_iter() {\n                 fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n             }\n+            for obligation in predicates.obligations.into_iter() {\n+                fcx.register_predicate(obligation);\n+            }\n         });\n     }\n }"}, {"sha": "f15d53290e761de75895711b9640575c564f29bc", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -64,7 +64,7 @@ This API is completely unstable and subject to change.\n */\n \n #![crate_name = \"rustc_typeck\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -77,6 +77,7 @@ This API is completely unstable and subject to change.\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n \n #[macro_use] extern crate log;"}, {"sha": "a44c73e8c4120f91d9b986673e6a68273003faf8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -1389,12 +1389,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n         match self.sty {\n             ty::ty_bool => Primitive(Bool),\n             ty::ty_char => Primitive(Char),\n-            ty::ty_int(ast::TyIs) => Primitive(Isize),\n+            ty::ty_int(ast::TyIs(_)) => Primitive(Isize),\n             ty::ty_int(ast::TyI8) => Primitive(I8),\n             ty::ty_int(ast::TyI16) => Primitive(I16),\n             ty::ty_int(ast::TyI32) => Primitive(I32),\n             ty::ty_int(ast::TyI64) => Primitive(I64),\n-            ty::ty_uint(ast::TyUs) => Primitive(Usize),\n+            ty::ty_uint(ast::TyUs(_)) => Primitive(Usize),\n             ty::ty_uint(ast::TyU8) => Primitive(U8),\n             ty::ty_uint(ast::TyU16) => Primitive(U16),\n             ty::ty_uint(ast::TyU32) => Primitive(U32),\n@@ -2269,12 +2269,12 @@ fn resolve_type(cx: &DocContext,\n             ast::TyStr => return Primitive(Str),\n             ast::TyBool => return Primitive(Bool),\n             ast::TyChar => return Primitive(Char),\n-            ast::TyInt(ast::TyIs) => return Primitive(Isize),\n+            ast::TyInt(ast::TyIs(_)) => return Primitive(Isize),\n             ast::TyInt(ast::TyI8) => return Primitive(I8),\n             ast::TyInt(ast::TyI16) => return Primitive(I16),\n             ast::TyInt(ast::TyI32) => return Primitive(I32),\n             ast::TyInt(ast::TyI64) => return Primitive(I64),\n-            ast::TyUint(ast::TyUs) => return Primitive(Usize),\n+            ast::TyUint(ast::TyUs(_)) => return Primitive(Usize),\n             ast::TyUint(ast::TyU8) => return Primitive(U8),\n             ast::TyUint(ast::TyU16) => return Primitive(U16),\n             ast::TyUint(ast::TyU32) => return Primitive(U32),"}, {"sha": "6d5df3d777d8677f125c09cadb994a0537496003", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustdoc\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -19,6 +19,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "942a8cfa2c5b931b4c17e633915555c7cf31062d", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -28,6 +28,7 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(old_impl_check)]\n #![feature(slicing_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "77c2315194bb4e26aeb8fc78f208317992c5e757", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -22,7 +22,7 @@ use string::String;\n use vec::Vec;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n pub trait OwnedAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -36,7 +36,7 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n pub trait AsciiExt<T = Self> {\n     /// Check if within the ASCII range.\n     fn is_ascii(&self) -> bool;\n@@ -57,7 +57,7 @@ pub trait AsciiExt<T = Self> {\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n impl AsciiExt<String> for str {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -82,7 +82,7 @@ impl AsciiExt<String> for str {\n     }\n }\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_uppercase(self) -> String {\n@@ -97,7 +97,7 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -123,7 +123,7 @@ impl AsciiExt<Vec<u8>> for [u8] {\n     }\n }\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_uppercase(mut self) -> Vec<u8> {\n@@ -142,7 +142,7 @@ impl OwnedAsciiExt for Vec<u8> {\n     }\n }\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n impl AsciiExt for u8 {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -165,7 +165,7 @@ impl AsciiExt for u8 {\n     }\n }\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n+#[unstable = \"would prefer to do this in a more general way\"]\n impl AsciiExt for char {\n     #[inline]\n     fn is_ascii(&self) -> bool {"}, {"sha": "3a059766fef8e24f95f8bf6a8dced8714320ab0c", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![experimental]\n+#![unstable]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "456f3763b39162d523fe1ab646715fa6c1a2ded7", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -632,7 +632,7 @@ impl<K, V> RawTable<K, V> {\n \n     /// Creates a new raw table from a given capacity. All buckets are\n     /// initially empty.\n-    #[allow(experimental)]\n+    #[allow(unstable)]\n     pub fn new(capacity: uint) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);"}, {"sha": "3eeb09b79dab23904539f68eec00317e540a303a", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-#![experimental]\n+#![unstable]\n #![allow(missing_docs)]\n \n use prelude::v1::*;"}, {"sha": "54191cf24040e743eff746b2b3e4d1d07cf66203", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![experimental]\n+#![unstable]\n \n use prelude::v1::*;\n "}, {"sha": "907925e93d3999145b8a3aa470c9e3e75ad64c61", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -410,7 +410,7 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n \n-#![experimental]\n+#![unstable]\n \n use string;\n \n@@ -439,7 +439,7 @@ pub use core::fmt::{argument, argumentuint};\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-#[experimental = \"this is an implementation detail of format! and should not \\\n+#[unstable = \"this is an implementation detail of format! and should not \\\n                   be called directly\"]\n pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();"}, {"sha": "3968dda2a82026051a4687abf6a487314a63fa1b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -219,7 +219,7 @@\n //! concerned with error handling; instead its caller is responsible for\n //! responding to errors that may occur while attempting to read the numbers.\n \n-#![experimental]\n+#![unstable]\n #![deny(unused_must_use)]\n \n pub use self::SeekStyle::*;"}, {"sha": "42d9fff6d151da84989f9626880067cf7a5e54c4", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -68,7 +68,7 @@ impl UnixStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[experimental = \"the timeout argument is likely to change types\"]\n+    #[unstable = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P>(path: P, timeout: Duration)\n                               -> IoResult<UnixStream>\n                               where P: BytesContainer {\n@@ -107,23 +107,23 @@ impl UnixStream {\n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -219,7 +219,7 @@ impl UnixAcceptor {\n     /// When using this method, it is likely necessary to reset the timeout as\n     /// appropriate, the timeout specified is specific to this object, not\n     /// specific to the next request.\n-    #[experimental = \"the name and arguments to this function are likely \\\n+    #[unstable = \"the name and arguments to this function are likely \\\n                       to change\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n@@ -229,7 +229,7 @@ impl UnixAcceptor {\n     ///\n     /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n     /// more information can be found in that documentation.\n-    #[experimental]\n+    #[unstable]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }"}, {"sha": "6a3f5fcb2c69902d43b01c0afa8d23796c9c1307", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -85,7 +85,7 @@ impl TcpStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[experimental = \"the timeout argument may eventually change types\"]\n+    #[unstable = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n                                             timeout: Duration) -> IoResult<TcpStream> {\n         if timeout <= Duration::milliseconds(0) {\n@@ -109,7 +109,7 @@ impl TcpStream {\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n-    #[experimental]\n+    #[unstable]\n     pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n         self.inner.set_nodelay(nodelay)\n     }\n@@ -119,7 +119,7 @@ impl TcpStream {\n     /// If the value specified is `None`, then the keepalive flag is cleared on\n     /// this connection. Otherwise, the keepalive timeout will be set to the\n     /// specified time, in seconds.\n-    #[experimental]\n+    #[unstable]\n     pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n         self.inner.set_keepalive(delay_in_seconds)\n     }\n@@ -187,7 +187,7 @@ impl TcpStream {\n     ///\n     /// For clarification on the semantics of interrupting a read and a write,\n     /// take a look at `set_read_timeout` and `set_write_timeout`.\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n@@ -204,7 +204,7 @@ impl TcpStream {\n     /// action is taken. Otherwise, the read operation will be scheduled to\n     /// promptly return. If a timeout error is returned, then no data was read\n     /// during the timeout period.\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n@@ -231,7 +231,7 @@ impl TcpStream {\n     /// does not know how many bytes were written as part of the timeout\n     /// operation. It may be the case that bytes continue to be written in an\n     /// asynchronous fashion after the call to write returns.\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -374,7 +374,7 @@ impl TcpAcceptor {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// # #![allow(experimental)]\n+    /// # #![allow(unstable)]\n     /// use std::io::TcpListener;\n     /// use std::io::{Listener, Acceptor, TimedOut};\n     ///\n@@ -397,7 +397,7 @@ impl TcpAcceptor {\n     /// a.set_timeout(None);\n     /// let socket = a.accept();\n     /// ```\n-    #[experimental = \"the type of the argument and name of this function are \\\n+    #[unstable = \"the type of the argument and name of this function are \\\n                       subject to change\"]\n     pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n \n@@ -418,7 +418,7 @@ impl TcpAcceptor {\n     /// # Example\n     ///\n     /// ```\n-    /// # #![allow(experimental)]\n+    /// # #![allow(unstable)]\n     /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n     /// use std::thread::Thread;\n     ///\n@@ -444,7 +444,7 @@ impl TcpAcceptor {\n     /// // Signal our accept loop to exit\n     /// assert!(a.close_accept().is_ok());\n     /// ```\n-    #[experimental]\n+    #[unstable]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }\n@@ -482,7 +482,7 @@ impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n }\n \n #[cfg(test)]\n-#[allow(experimental)]\n+#[allow(unstable)]\n mod test {\n     use prelude::v1::*;\n "}, {"sha": "8cdad3f528a4856fcfa8b760a7010d2e17e9c62e", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -92,63 +92,63 @@ impl UdpSocket {\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n-    #[experimental]\n+    #[unstable]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.join_multicast(multi)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n-    #[experimental]\n+    #[unstable]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.leave_multicast(multi)\n     }\n \n     /// Set the multicast loop flag to the specified value\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n-    #[experimental]\n+    #[unstable]\n     pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n         self.inner.set_multicast_loop(on)\n     }\n \n     /// Sets the multicast TTL\n-    #[experimental]\n+    #[unstable]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n-    #[experimental]\n+    #[unstable]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.time_to_live(ttl)\n     }\n \n     /// Sets the broadcast flag on or off\n-    #[experimental]\n+    #[unstable]\n     pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n         self.inner.set_broadcast(broadcast)\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[experimental = \"the timeout argument may change in type and value\"]\n+    #[unstable = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n     }\n@@ -176,7 +176,7 @@ impl sys_common::AsInner<UdpSocketImp> for UdpSocket {\n }\n \n #[cfg(test)]\n-#[allow(experimental)]\n+#[allow(unstable)]\n mod test {\n     use prelude::v1::*;\n "}, {"sha": "a093e748d573653a80f5cd01ff392fef1289c72a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n //! Bindings for executing child processes\n \n-#![allow(experimental)]\n+#![allow(unstable)]\n #![allow(non_upper_case_globals)]\n \n pub use self::StdioContainer::*;\n@@ -661,7 +661,7 @@ impl Process {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// # #![allow(experimental)]\n+    /// # #![allow(unstable)]\n     /// use std::io::{Command, IoResult};\n     /// use std::io::process::ProcessExit;\n     ///\n@@ -689,7 +689,7 @@ impl Process {\n     ///     p.wait()\n     /// }\n     /// ```\n-    #[experimental = \"the type of the timeout is likely to change\"]\n+    #[unstable = \"the type of the timeout is likely to change\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);\n     }"}, {"sha": "dc157c7d67660ef6d5a4a0888267cfe06f69db40", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -110,6 +110,7 @@\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n #![feature(old_impl_check)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "626372db23b5f23a2b760441adc4f688f62ff3b4", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,7 +14,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-#![experimental]\n+#![unstable]\n \n /// The entry point for panic of Rust tasks.\n ///\n@@ -44,7 +44,7 @@ macro_rules! panic {\n     ($msg:expr) => ({\n         $crate::rt::begin_unwind($msg, {\n             // static requires less code at runtime, more constant data\n-            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+            static _FILE_LINE: (&'static str, usize) = (file!(), line!());\n             &_FILE_LINE\n         })\n     });\n@@ -54,7 +54,7 @@ macro_rules! panic {\n             // used inside a dead function. Just `#[allow(dead_code)]` is\n             // insufficient, since the user may have\n             // `#[forbid(dead_code)]` and which cannot be overridden.\n-            static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+            static _FILE_LINE: (&'static str, usize) = (file!(), line!());\n             &_FILE_LINE\n         })\n     });\n@@ -324,7 +324,7 @@ macro_rules! try {\n ///\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n-#[experimental]\n+#[unstable]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n@@ -466,7 +466,7 @@ pub mod builtin {\n \n     /// A macro which expands to the line number on which it was invoked.\n     ///\n-    /// The expanded expression has type `uint`, and the returned line is not\n+    /// The expanded expression has type `usize`, and the returned line is not\n     /// the invocation of the `line!()` macro itself, but rather the first macro\n     /// invocation leading up to the invocation of the `line!()` macro.\n     ///\n@@ -481,7 +481,7 @@ pub mod builtin {\n \n     /// A macro which expands to the column number on which it was invoked.\n     ///\n-    /// The expanded expression has type `uint`, and the returned column is not\n+    /// The expanded expression has type `usize`, and the returned column is not\n     /// the invocation of the `column!()` macro itself, but rather the first macro\n     /// invocation leading up to the invocation of the `column!()` macro.\n     ///"}, {"sha": "adbce893887709912904e4cca5d9879c55d00031", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -366,7 +366,7 @@ impl Float for f32 {\n ///\n /// * num - The float value\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -379,7 +379,7 @@ pub fn to_string(num: f32) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -394,7 +394,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -407,7 +407,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -422,7 +422,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -438,7 +438,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -454,7 +454,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "baff14125ee17120c9e778cf5e2e17d4a4e13a6e", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -375,7 +375,7 @@ impl Float for f64 {\n ///\n /// * num - The float value\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -388,7 +388,7 @@ pub fn to_string(num: f64) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -403,7 +403,7 @@ pub fn to_str_hex(num: f64) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -416,7 +416,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -431,7 +431,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -447,7 +447,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -463,7 +463,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "ec168eaaa9de65952be8f390c22dcce43ed18391", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![experimental]\n+#![unstable]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "5bc5415287497b99905a1eac21a0ee482fe1aa15", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![experimental]\n+#![unstable]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty) => ("}, {"sha": "e804408b4d0e258ca2acd7cf22f808e95a3cc0b3", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -33,7 +33,7 @@ pub use core::num::{FpCategory};\n \n use option::Option;\n \n-#[experimental = \"may be removed or relocated\"]\n+#[unstable = \"may be removed or relocated\"]\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers."}, {"sha": "f480a3b420f54a1dae7cbb523cbad186ea531dce", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![experimental]\n+#![unstable]\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n "}, {"sha": "6e3949b9e22d0efe26678e21fd01935bcc920214", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -22,7 +22,7 @@\n //! so we will not _hide_ the facts of which OS the user is on -- they should be given the\n //! opportunity to write OS-ignorant code by default.\n \n-#![experimental]\n+#![unstable]\n \n #![allow(missing_docs)]\n #![allow(non_snake_case)]"}, {"sha": "1ec7b6b3edcbbd4c351c0d4b4eb1870246314ef2", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -59,7 +59,7 @@\n //! println!(\"path exists: {}\", path.exists());\n //! ```\n \n-#![experimental]\n+#![unstable]\n \n use core::marker::Sized;\n use ffi::CString;"}, {"sha": "60d490982db7ea284bb0c250c3a14baddff309c4", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -219,7 +219,7 @@\n //! }\n //! ```\n \n-#![experimental]\n+#![unstable]\n \n use cell::RefCell;\n use clone::Clone;"}, {"sha": "e3e4e132b8172925c265ed8a44263beea85fc608", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,7 +16,7 @@\n //! and should be considered as private implementation details for the\n //! time being.\n \n-#![experimental]\n+#![unstable]\n \n // FIXME: this should not be here.\n #![allow(missing_docs)]"}, {"sha": "4cd0b29688a708c1af3f67689a992b39c4f3e995", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -582,7 +582,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n /// Only a limited number of callbacks can be registered, and this function\n /// returns whether the callback was successfully registered or not. It is not\n /// currently possible to unregister a callback once it has been registered.\n-#[experimental]\n+#[unstable]\n pub unsafe fn register(f: Callback) -> bool {\n     match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n         // The invocation code has knowledge of this window where the count has"}, {"sha": "f4fbd378899e093035001f6b64949433a946d0ad", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n-#![experimental]\n+#![unstable]\n \n // All platforms need to link to rustrt\n #[cfg(not(test))]"}, {"sha": "83de98fdbffee87b396f0d2e12230c1e0ec83734", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -35,7 +35,7 @@\n //! method, and see the method for more information about it. Due to this\n //! caveat, this queue may not be appropriate for all use-cases.\n \n-#![experimental]\n+#![unstable]\n \n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue"}, {"sha": "0da458a51f10848b9988bf1b202c9d4569e08496", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -46,7 +46,7 @@\n //! ```\n \n #![allow(dead_code)]\n-#![experimental = \"This implementation, while likely sufficient, is unsafe and \\\n+#![unstable = \"This implementation, while likely sufficient, is unsafe and \\\n                    likely to be error prone. At some point in the future this \\\n                    module will likely be replaced, and it is currently \\\n                    unknown how much API breakage that will cause. The ability \\"}, {"sha": "46c69f6f5478927b2713374b10d4a1e276af509e", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -33,7 +33,7 @@\n //! concurrently between two tasks. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n-#![experimental]\n+#![unstable]\n \n use core::prelude::*;\n "}, {"sha": "0e4a9d1b307f7636e26e722c13d91f7c113b7993", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -29,7 +29,7 @@\n //! }\n //! ```\n \n-#![experimental]\n+#![unstable]\n \n use sys_common::AsInner;\n use libc;"}, {"sha": "87ff31ab73cda64236b8f4262506a2797f6bac5d", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,7 +14,7 @@\n //! descriptors, and sockets, but its functionality will grow over\n //! time.\n \n-#![experimental]\n+#![unstable]\n \n use sys_common::AsInner;\n use libc;"}, {"sha": "932556fe1a65d39c15a45d0b3c12a33d73ae622b", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -207,14 +207,14 @@ impl Builder {\n     }\n \n     /// Redirect thread-local stdout.\n-    #[experimental = \"Will likely go away after proc removal\"]\n+    #[unstable = \"Will likely go away after proc removal\"]\n     pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect thread-local stderr.\n-    #[experimental = \"Will likely go away after proc removal\"]\n+    #[unstable = \"Will likely go away after proc removal\"]\n     pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder {\n         self.stderr = Some(stderr);\n         self\n@@ -483,7 +483,7 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n \n impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n-    #[experimental = \"unsure whether this API imposes limitations elsewhere\"]\n+    #[unstable = \"unsure whether this API imposes limitations elsewhere\"]\n     pub fn detach(mut self) {\n         unsafe { imp::detach(self.native) };\n         self.joined = true; // avoid joining in the destructor"}, {"sha": "162c3677168f806ff12dbb97444a7fe751fdb5c8", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n //! Temporal quantification\n \n-#![experimental]\n+#![unstable]\n \n use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg, FnOnce};"}, {"sha": "630f7768885de6ec6097834c0b90a2a312398f6f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -1075,15 +1075,29 @@ pub struct Typedef {\n     pub typ: P<Ty>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum IntTy {\n-    TyIs,\n+    TyIs(bool /* is this deprecated `int`? */),\n     TyI8,\n     TyI16,\n     TyI32,\n     TyI64,\n }\n \n+impl PartialEq for IntTy {\n+    fn eq(&self, other: &IntTy) -> bool {\n+        match (*self, *other) {\n+            // true/false need to compare the same, so this can't be derived\n+            (TyIs(_), TyIs(_)) |\n+            (TyI8, TyI8) |\n+            (TyI16, TyI16) |\n+            (TyI32, TyI32) |\n+            (TyI64, TyI64) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n impl fmt::Show for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(self, f)\n@@ -1099,27 +1113,41 @@ impl fmt::String for IntTy {\n impl IntTy {\n     pub fn suffix_len(&self) -> uint {\n         match *self {\n-            TyIs => 1,\n-            TyI8 => 2,\n+            TyIs(true) /* i */ => 1,\n+            TyIs(false) /* is */ | TyI8 => 2,\n             TyI16 | TyI32 | TyI64  => 3,\n         }\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum UintTy {\n-    TyUs,\n+    TyUs(bool /* is this deprecated uint? */),\n     TyU8,\n     TyU16,\n     TyU32,\n     TyU64,\n }\n \n+impl PartialEq for UintTy {\n+    fn eq(&self, other: &UintTy) -> bool {\n+        match (*self, *other) {\n+            // true/false need to compare the same, so this can't be derived\n+            (TyUs(_), TyUs(_)) |\n+            (TyU8, TyU8) |\n+            (TyU16, TyU16) |\n+            (TyU32, TyU32) |\n+            (TyU64, TyU64) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n impl UintTy {\n     pub fn suffix_len(&self) -> uint {\n         match *self {\n-            TyUs => 1,\n-            TyU8 => 2,\n+            TyUs(true) /* u */ => 1,\n+            TyUs(false) /* us */ | TyU8 => 2,\n             TyU16 | TyU32 | TyU64  => 3,\n         }\n     }"}, {"sha": "bc7fbd46fd8bac52f795026e8f48854f315ffa3f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -127,8 +127,10 @@ pub fn is_path(e: P<Expr>) -> bool {\n /// We want to avoid \"45int\" and \"-3int\" in favor of \"45\" and \"-3\"\n pub fn int_ty_to_string(t: IntTy, val: Option<i64>) -> String {\n     let s = match t {\n-        TyIs if val.is_some() => \"is\",\n-        TyIs => \"isize\",\n+        TyIs(true) if val.is_some() => \"i\",\n+        TyIs(true) => \"int\",\n+        TyIs(false) if val.is_some() => \"is\",\n+        TyIs(false) => \"isize\",\n         TyI8 => \"i8\",\n         TyI16 => \"i16\",\n         TyI32 => \"i32\",\n@@ -148,7 +150,7 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n     match t {\n         TyI8 => 0x80u64,\n         TyI16 => 0x8000u64,\n-        TyIs | TyI32 => 0x80000000u64, // actually ni about TyIs\n+        TyIs(_) | TyI32 => 0x80000000u64, // actually ni about TyIs\n         TyI64 => 0x8000000000000000u64\n     }\n }\n@@ -157,8 +159,10 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n /// We want to avoid \"42uint\" in favor of \"42u\"\n pub fn uint_ty_to_string(t: UintTy, val: Option<u64>) -> String {\n     let s = match t {\n-        TyUs if val.is_some() => \"us\",\n-        TyUs => \"usize\",\n+        TyUs(true) if val.is_some() => \"u\",\n+        TyUs(true) => \"uint\",\n+        TyUs(false) if val.is_some() => \"us\",\n+        TyUs(false) => \"usize\",\n         TyU8 => \"u8\",\n         TyU16 => \"u16\",\n         TyU32 => \"u32\",\n@@ -175,7 +179,7 @@ pub fn uint_ty_max(t: UintTy) -> u64 {\n     match t {\n         TyU8 => 0xffu64,\n         TyU16 => 0xffffu64,\n-        TyUs | TyU32 => 0xffffffffu64, // actually ni about TyUs\n+        TyUs(_) | TyU32 => 0xffffffffu64, // actually ni about TyUs\n         TyU64 => 0xffffffffffffffffu64\n     }\n }"}, {"sha": "6f57c06d33e885d682d33f5d0c6856bec4429a3f", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -464,10 +464,10 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n         \"u32\" => Some(UnsignedInt(ast::TyU32)),\n         \"i64\" => Some(SignedInt(ast::TyI64)),\n         \"u64\" => Some(UnsignedInt(ast::TyU64)),\n-        \"int\" => Some(SignedInt(ast::TyIs)),\n-        \"uint\" => Some(UnsignedInt(ast::TyUs)),\n-        \"isize\" => Some(SignedInt(ast::TyIs)),\n-        \"usize\" => Some(UnsignedInt(ast::TyUs)),\n+        \"int\" => Some(SignedInt(ast::TyIs(true))),\n+        \"uint\" => Some(UnsignedInt(ast::TyUs(true))),\n+        \"isize\" => Some(SignedInt(ast::TyIs(false))),\n+        \"usize\" => Some(UnsignedInt(ast::TyUs(false))),\n         _ => None\n     }\n }\n@@ -511,7 +511,7 @@ impl IntType {\n             SignedInt(ast::TyI16) | UnsignedInt(ast::TyU16) |\n             SignedInt(ast::TyI32) | UnsignedInt(ast::TyU32) |\n             SignedInt(ast::TyI64) | UnsignedInt(ast::TyU64) => true,\n-            SignedInt(ast::TyIs) | UnsignedInt(ast::TyUs) => false\n+            SignedInt(ast::TyIs(_)) | UnsignedInt(ast::TyUs(_)) => false\n         }\n     }\n }"}, {"sha": "c34142aec39c8e7aa4158717613ceda9531ff8f0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -642,10 +642,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprLit(P(respan(sp, lit))))\n     }\n     fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr> {\n-        self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyUs)))\n+        self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyUs(false))))\n     }\n     fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs, ast::Sign::new(i))))\n+        self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs(false),\n+                                                                  ast::Sign::new(i))))\n     }\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))"}, {"sha": "e6b6f7bbd49c3d0f09d99bd7fcfd5d7fad69cce2", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -1031,7 +1031,7 @@ impl<'a> MethodDef<'a> {\n             let arms: Vec<ast::Arm> = variants.iter().enumerate()\n                 .map(|(index, variant)| {\n                     let pat = variant_to_pat(cx, sp, type_ident, &**variant);\n-                    let lit = ast::LitInt(index as u64, ast::UnsignedIntLit(ast::TyUs));\n+                    let lit = ast::LitInt(index as u64, ast::UnsignedIntLit(ast::TyUs(false)));\n                     cx.arm(sp, vec![pat], cx.expr_lit(sp, lit))\n                 }).collect();\n "}, {"sha": "1359cada67396fa1c57059051996216e41559017", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -98,13 +98,13 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                                        rand_name,\n                                        vec!(rng.clone()));\n \n-            // need to specify the uint-ness of the random number\n-            let uint_ty = cx.ty_ident(trait_span, cx.ident_of(\"uint\"));\n+            // need to specify the usize-ness of the random number\n+            let usize_ty = cx.ty_ident(trait_span, cx.ident_of(\"usize\"));\n             let value_ident = cx.ident_of(\"__value\");\n             let let_statement = cx.stmt_let_typed(trait_span,\n                                                   false,\n                                                   value_ident,\n-                                                  uint_ty,\n+                                                  usize_ty,\n                                                   rv_call);\n \n             // rand() % variants.len()"}, {"sha": "c42b188302cc3ab25c1001c80b183535604622e9", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -244,10 +244,10 @@ pub mod rt {\n     }\n \n     macro_rules! impl_to_source_int {\n-        (signed, $t:ty, $tag:ident) => (\n+        (signed, $t:ty, $tag:expr) => (\n             impl ToSource for $t {\n                 fn to_source(&self) -> String {\n-                    let lit = ast::LitInt(*self as u64, ast::SignedIntLit(ast::$tag,\n+                    let lit = ast::LitInt(*self as u64, ast::SignedIntLit($tag,\n                                                                           ast::Sign::new(*self)));\n                     pprust::lit_to_string(&dummy_spanned(lit))\n                 }\n@@ -258,10 +258,10 @@ pub mod rt {\n                 }\n             }\n         );\n-        (unsigned, $t:ty, $tag:ident) => (\n+        (unsigned, $t:ty, $tag:expr) => (\n             impl ToSource for $t {\n                 fn to_source(&self) -> String {\n-                    let lit = ast::LitInt(*self as u64, ast::UnsignedIntLit(ast::$tag));\n+                    let lit = ast::LitInt(*self as u64, ast::UnsignedIntLit($tag));\n                     pprust::lit_to_string(&dummy_spanned(lit))\n                 }\n             }\n@@ -273,17 +273,17 @@ pub mod rt {\n         );\n     }\n \n-    impl_to_source_int! { signed, int, TyIs }\n-    impl_to_source_int! { signed, i8,  TyI8 }\n-    impl_to_source_int! { signed, i16, TyI16 }\n-    impl_to_source_int! { signed, i32, TyI32 }\n-    impl_to_source_int! { signed, i64, TyI64 }\n+    impl_to_source_int! { signed, int, ast::TyIs(false) }\n+    impl_to_source_int! { signed, i8,  ast::TyI8 }\n+    impl_to_source_int! { signed, i16, ast::TyI16 }\n+    impl_to_source_int! { signed, i32, ast::TyI32 }\n+    impl_to_source_int! { signed, i64, ast::TyI64 }\n \n-    impl_to_source_int! { unsigned, uint, TyUs }\n-    impl_to_source_int! { unsigned, u8,   TyU8 }\n-    impl_to_source_int! { unsigned, u16,  TyU16 }\n-    impl_to_source_int! { unsigned, u32,  TyU32 }\n-    impl_to_source_int! { unsigned, u64,  TyU64 }\n+    impl_to_source_int! { unsigned, uint, ast::TyUs(false) }\n+    impl_to_source_int! { unsigned, u8,   ast::TyU8 }\n+    impl_to_source_int! { unsigned, u16,  ast::TyU16 }\n+    impl_to_source_int! { unsigned, u32,  ast::TyU32 }\n+    impl_to_source_int! { unsigned, u64,  ast::TyU64 }\n \n     // Alas ... we write these out instead. All redundant.\n "}, {"sha": "8175c0a9eecf4805d88fd571467b3c241a4a359f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -82,7 +82,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"issue_5723_bootstrap\", Accepted),\n \n     // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n-    (\"opt_out_copy\", Deprecated),\n+    (\"opt_out_copy\", Removed),\n \n     // A way to temporarily opt out of the new orphan rules. This will *never* be accepted.\n     (\"old_orphan_check\", Deprecated),\n@@ -93,6 +93,9 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     // OIBIT specific features\n     (\"optin_builtin_traits\", Active),\n \n+    // int and uint are now deprecated\n+    (\"int_uint\", Active),\n+\n     // These are used to test this portion of the compiler, they don't actually\n     // mean anything\n     (\"test_accepted_feature\", Accepted),\n@@ -123,7 +126,6 @@ pub struct Features {\n     pub import_shadowing: bool,\n     pub visible_private_types: bool,\n     pub quote: bool,\n-    pub opt_out_copy: bool,\n     pub old_orphan_check: bool,\n }\n \n@@ -135,7 +137,6 @@ impl Features {\n             import_shadowing: false,\n             visible_private_types: false,\n             quote: false,\n-            opt_out_copy: false,\n             old_orphan_check: false,\n         }\n     }\n@@ -157,6 +158,14 @@ impl<'a> Context<'a> {\n         }\n     }\n \n+    fn warn_feature(&self, feature: &str, span: Span, explain: &str) {\n+        if !self.has_feature(feature) {\n+            self.span_handler.span_warn(span, explain);\n+            self.span_handler.span_help(span, &format!(\"add #![feature({})] to the \\\n+                                                       crate attributes to silence this warning\",\n+                                                      feature)[]);\n+        }\n+    }\n     fn has_feature(&self, feature: &str) -> bool {\n         self.features.iter().any(|&n| n == feature)\n     }\n@@ -334,6 +343,31 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n+        match t.node {\n+            ast::TyPath(ref p, _) => {\n+                match &*p.segments {\n+\n+                    [ast::PathSegment { identifier, .. }] => {\n+                        let name = token::get_ident(identifier);\n+                        let msg = if name == \"int\" {\n+                            Some(\"the `int` type is deprecated; \\\n+                                  use `isize` or a fixed-sized integer\")\n+                        } else if name == \"uint\" {\n+                            Some(\"the `uint` type is deprecated; \\\n+                                  use `usize` or a fixed-sized integer\")\n+                        } else {\n+                            None\n+                        };\n+\n+                        if let Some(msg) = msg {\n+                            self.context.warn_feature(\"int_uint\", t.span, msg)\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n         visit::walk_ty(self, t);\n     }\n \n@@ -345,6 +379,25 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   \"box expression syntax is experimental in alpha release; \\\n                                    you can call `Box::new` instead.\");\n             }\n+            ast::ExprLit(ref lit) => {\n+                match lit.node {\n+                    ast::LitInt(_, ty) => {\n+                        let msg = if let ast::SignedIntLit(ast::TyIs(true), _) = ty {\n+                            Some(\"the `i` suffix on integers is deprecated; use `is` \\\n+                                  or one of the fixed-sized suffixes\")\n+                        } else if let ast::UnsignedIntLit(ast::TyUs(true)) = ty {\n+                            Some(\"the `u` suffix on integers is deprecated; use `us` \\\n+                                 or one of the fixed-sized suffixes\")\n+                        } else {\n+                            None\n+                        };\n+                        if let Some(msg) = msg {\n+                            self.context.warn_feature(\"int_uint\", e.span, msg);\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);\n@@ -465,7 +518,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n         import_shadowing: cx.has_feature(\"import_shadowing\"),\n         visible_private_types: cx.has_feature(\"visible_private_types\"),\n         quote: cx.has_feature(\"quote\"),\n-        opt_out_copy: cx.has_feature(\"opt_out_copy\"),\n         old_orphan_check: cx.has_feature(\"old_orphan_check\"),\n     },\n     unknown_features)"}, {"sha": "9c947f422e9a99247610fc92dabfff90b75a0711", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"syntax\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n@@ -27,6 +27,7 @@\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n #![feature(quote, unsafe_destructor)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "f1f547ba0c7dd52e24855c6f32f558ecb390e743", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -702,14 +702,14 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     if let Some(suf) = suffix {\n         if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n         ty = match suf {\n-            \"i\"   => ast::SignedIntLit(ast::TyIs, ast::Plus),\n-            \"is\"   => ast::SignedIntLit(ast::TyIs, ast::Plus),\n+            \"i\"   => ast::SignedIntLit(ast::TyIs(true), ast::Plus),\n+            \"is\"   => ast::SignedIntLit(ast::TyIs(false), ast::Plus),\n             \"i8\"  => ast::SignedIntLit(ast::TyI8, ast::Plus),\n             \"i16\" => ast::SignedIntLit(ast::TyI16, ast::Plus),\n             \"i32\" => ast::SignedIntLit(ast::TyI32, ast::Plus),\n             \"i64\" => ast::SignedIntLit(ast::TyI64, ast::Plus),\n-            \"u\"   => ast::UnsignedIntLit(ast::TyUs),\n-            \"us\"   => ast::UnsignedIntLit(ast::TyUs),\n+            \"u\"   => ast::UnsignedIntLit(ast::TyUs(true)),\n+            \"us\"   => ast::UnsignedIntLit(ast::TyUs(false)),\n             \"u8\"  => ast::UnsignedIntLit(ast::TyU8),\n             \"u16\" => ast::UnsignedIntLit(ast::TyU16),\n             \"u32\" => ast::UnsignedIntLit(ast::TyU32),"}, {"sha": "2117b68c08e5974a59ed34af9bc4628ad93a487f", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -39,7 +39,7 @@\n //! [ti]: https://en.wikipedia.org/wiki/Terminfo\n \n #![crate_name = \"term\"]\n-#![experimental = \"use the crates.io `term` library instead\"]\n+#![unstable = \"use the crates.io `term` library instead\"]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -51,6 +51,7 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n \n #[macro_use] extern crate log;"}, {"sha": "c4cb53d6cb7b6e19cf557c613cc756d794ba0ac3", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -24,7 +24,7 @@\n // build off of.\n \n #![crate_name = \"test\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -34,6 +34,7 @@\n #![allow(unknown_features)]\n #![feature(asm, slicing_syntax)]\n #![feature(box_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate getopts;\n extern crate regex;"}, {"sha": "17607383beed1435bdf6cb71a92e822f41e45b6b", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -21,7 +21,7 @@\n //! (yet) aim to provide a full set of Unicode tables.\n \n #![crate_name = \"unicode\"]\n-#![experimental]\n+#![unstable]\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -30,6 +30,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n #![feature(slicing_syntax)]\n+#![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate core;\n "}, {"sha": "4142a62ba66644bc52acfdc42a9834dd49eeb132", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -112,7 +112,7 @@ pub trait CharExt {\n     /// 'XID_Start' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n-    #[experimental = \"mainly needed for compiler internals\"]\n+    #[unstable = \"mainly needed for compiler internals\"]\n     fn is_xid_start(self) -> bool;\n \n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n@@ -121,7 +121,7 @@ pub trait CharExt {\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-    #[experimental = \"mainly needed for compiler internals\"]\n+    #[unstable = \"mainly needed for compiler internals\"]\n     fn is_xid_continue(self) -> bool;\n \n     /// Indicates whether a character is in lowercase.\n@@ -171,7 +171,7 @@ pub trait CharExt {\n     ///\n     /// Returns the lowercase equivalent of the character, or the character\n     /// itself if no conversion is possible.\n-    #[experimental = \"pending case transformation decisions\"]\n+    #[unstable = \"pending case transformation decisions\"]\n     fn to_lowercase(self) -> char;\n \n     /// Converts a character to its uppercase equivalent.\n@@ -194,7 +194,7 @@ pub trait CharExt {\n     /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    #[experimental = \"pending case transformation decisions\"]\n+    #[unstable = \"pending case transformation decisions\"]\n     fn to_uppercase(self) -> char;\n \n     /// Returns this character's displayed width in columns, or `None` if it is a\n@@ -206,7 +206,7 @@ pub trait CharExt {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    #[unstable = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n     fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n@@ -238,10 +238,10 @@ impl CharExt for char {\n         }\n     }\n \n-    #[experimental = \"mainly needed for compiler internals\"]\n+    #[unstable = \"mainly needed for compiler internals\"]\n     fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    #[experimental = \"mainly needed for compiler internals\"]\n+    #[unstable = \"mainly needed for compiler internals\"]\n     fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n     #[stable]\n@@ -288,12 +288,12 @@ impl CharExt for char {\n         }\n     }\n \n-    #[experimental = \"pending case transformation decisions\"]\n+    #[unstable = \"pending case transformation decisions\"]\n     fn to_lowercase(self) -> char { conversions::to_lower(self) }\n \n-    #[experimental = \"pending case transformation decisions\"]\n+    #[unstable = \"pending case transformation decisions\"]\n     fn to_uppercase(self) -> char { conversions::to_upper(self) }\n \n-    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    #[unstable = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n     fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "1d16de2a2febc629a76ee428e3ecd1ed6a7d418e", "filename": "src/rustbook/book.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,166 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Basic data structures for representing a book.\n+\n+use std::io::BufferedReader;\n+use std::iter;\n+use std::iter::AdditiveIterator;\n+use regex::Regex;\n+\n+pub struct BookItem {\n+    pub title: String,\n+    pub path: Path,\n+    pub path_to_root: Path,\n+    pub children: Vec<BookItem>,\n+}\n+\n+pub struct Book {\n+    pub chapters: Vec<BookItem>,\n+}\n+\n+/// A depth-first iterator over a book.\n+pub struct BookItems<'a> {\n+    cur_items: &'a [BookItem],\n+    cur_idx: usize,\n+    stack: Vec<(&'a [BookItem], usize)>,\n+}\n+\n+impl<'a> Iterator for BookItems<'a> {\n+    type Item = (String, &'a BookItem);\n+\n+    fn next(&mut self) -> Option<(String, &'a BookItem)> {\n+        loop {\n+            if self.cur_idx >= self.cur_items.len() {\n+                match self.stack.pop() {\n+                    None => return None,\n+                    Some((parent_items, parent_idx)) => {\n+                        self.cur_items = parent_items;\n+                        self.cur_idx = parent_idx + 1;\n+                    }\n+                }\n+            } else {\n+                let cur = self.cur_items.get(self.cur_idx).unwrap();\n+\n+                let mut section = \"\".to_string();\n+                for &(_, idx) in self.stack.iter() {\n+                    section.push_str(&(idx + 1).to_string()[]);\n+                    section.push('.');\n+                }\n+                section.push_str(&(self.cur_idx + 1).to_string()[]);\n+                section.push('.');\n+\n+                self.stack.push((self.cur_items, self.cur_idx));\n+                self.cur_items = &cur.children[];\n+                self.cur_idx = 0;\n+                return Some((section, cur))\n+            }\n+        }\n+    }\n+}\n+\n+impl Book {\n+    pub fn iter(&self) -> BookItems {\n+        BookItems {\n+            cur_items: &self.chapters[],\n+            cur_idx: 0,\n+            stack: Vec::new(),\n+        }\n+    }\n+}\n+\n+/// Construct a book by parsing a summary (markdown table of contents).\n+pub fn parse_summary<R: Reader>(input: R, src: &Path) -> Result<Book, Vec<String>> {\n+    fn collapse(stack: &mut Vec<BookItem>,\n+                top_items: &mut Vec<BookItem>,\n+                to_level: usize) {\n+        loop {\n+            if stack.len() < to_level { return }\n+            if stack.len() == 1 {\n+                top_items.push(stack.pop().unwrap());\n+                return;\n+            }\n+\n+            let tip = stack.pop().unwrap();\n+            let last = stack.len() - 1;\n+            stack[last].children.push(tip);\n+        }\n+    }\n+\n+    let regex = r\"(?P<indent>[\\t ]*)\\*[:space:]*\\[(?P<title>.*)\\]\\((?P<path>.*)\\)\";\n+    let item_re = Regex::new(regex).unwrap();\n+    let mut top_items = vec!();\n+    let mut stack = vec!();\n+    let mut errors = vec!();\n+\n+    // always include the introduction\n+    top_items.push(BookItem {\n+        title: \"Introduction\".to_string(),\n+        path: Path::new(\"README.md\"),\n+        path_to_root: Path::new(\".\"),\n+        children: vec!(),\n+    });\n+\n+    for line_result in BufferedReader::new(input).lines() {\n+        let line = match line_result {\n+            Ok(line) => line,\n+            Err(err) => {\n+                errors.push(err.desc.to_string()); // FIXME: include detail\n+                return Err(errors);\n+            }\n+        };\n+\n+        item_re.captures(&line[]).map(|cap| {\n+            let given_path = cap.name(\"path\");\n+            let title = cap.name(\"title\").unwrap().to_string();\n+\n+            let path_from_root = match src.join(given_path.unwrap()).path_relative_from(src) {\n+                Some(p) => p,\n+                None => {\n+                    errors.push(format!(\"Paths in SUMMARY.md must be relative, \\\n+                                         but path '{}' for section '{}' is not.\",\n+                                         given_path.unwrap(), title));\n+                    Path::new(\"\")\n+                }\n+            };\n+            let path_to_root = Path::new(iter::repeat(\"../\")\n+                                             .take(path_from_root.components().count() - 1)\n+                                             .collect::<String>());\n+            let item = BookItem {\n+                title: title,\n+                path: path_from_root,\n+                path_to_root: path_to_root,\n+                children: vec!(),\n+            };\n+            let level = cap.name(\"indent\").unwrap().chars().map(|c| {\n+                match c {\n+                    ' ' => 1us,\n+                    '\\t' => 4,\n+                    _ => unreachable!()\n+                }\n+            }).sum() / 4 + 1;\n+\n+            if level > stack.len() + 1 {\n+                // FIXME: better error message\n+                errors.push(format!(\"Section '{}' is indented too many levels.\", item.title));\n+            } else if level <= stack.len() {\n+                collapse(&mut stack, &mut top_items, level);\n+            }\n+            stack.push(item)\n+        });\n+    }\n+\n+    if errors.is_empty() {\n+        collapse(&mut stack, &mut top_items, 1);\n+        Ok(Book { chapters: top_items })\n+    } else {\n+        Err(errors)\n+    }\n+}"}, {"sha": "1cb5e38e19076da4158e1eeb31ec9c72e3cebac8", "filename": "src/rustbook/build.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the `build` subcommand, used to compile a book.\n+\n+use std::os;\n+use std::io;\n+use std::io::{fs, File, BufferedWriter, TempDir, IoResult};\n+\n+use subcommand::Subcommand;\n+use term::Term;\n+use error::{Error, CliResult, CommandResult};\n+use book;\n+use book::{Book, BookItem};\n+use css;\n+\n+use regex::Regex;\n+\n+use rustdoc;\n+\n+struct Build;\n+\n+pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n+    if name == \"build\" {\n+        Some(box Build as Box<Subcommand>)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()> {\n+    fn walk_items(items: &[BookItem],\n+                  section: &str,\n+                  path_to_root: &Path,\n+                  out: &mut Writer) -> IoResult<()> {\n+        for (i, item) in items.iter().enumerate() {\n+            try!(walk_item(item, &format!(\"{}{}.\", section, i + 1)[], path_to_root, out));\n+        }\n+        Ok(())\n+    }\n+    fn walk_item(item: &BookItem,\n+                 section: &str,\n+                 path_to_root: &Path,\n+                 out: &mut Writer) -> IoResult<()> {\n+        try!(writeln!(out, \"<li><a href='{}'><b>{}</b> {}</a>\",\n+                 path_to_root.join(item.path.with_extension(\"html\")).display(),\n+                 section,\n+                 item.title));\n+        if !item.children.is_empty() {\n+            try!(writeln!(out, \"<ul class='section'>\"));\n+            let _ = walk_items(&item.children[], section, path_to_root, out);\n+            try!(writeln!(out, \"</ul>\"));\n+        }\n+        try!(writeln!(out, \"</li>\"));\n+\n+        Ok(())\n+    }\n+\n+    try!(writeln!(out, \"<div id='toc'>\"));\n+    try!(writeln!(out, \"<ul class='chapter'>\"));\n+    try!(walk_items(&book.chapters[], \"\", path_to_root, out));\n+    try!(writeln!(out, \"</ul>\"));\n+    try!(writeln!(out, \"</div>\"));\n+\n+    Ok(())\n+}\n+\n+fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n+    let tmp = TempDir::new(\"rust-book\")\n+                      .ok()\n+                      // FIXME: lift to Result instead\n+                      .expect(\"could not create temporary directory\");\n+\n+    for (section, item) in book.iter() {\n+        println!(\"{} {}\", section, item.title);\n+\n+        let out_path = tgt.join(item.path.dirname());\n+\n+        let regex = r\"\\[(?P<title>[^]]*)\\]\\((?P<url_stem>[^)]*)\\.(?P<ext>md|markdown)\\)\";\n+        let md_urls = Regex::new(regex).unwrap();\n+\n+        let src;\n+        if os::args().len() < 3 {\n+            src = os::getcwd().unwrap().clone();\n+        } else {\n+            src = Path::new(os::args()[2].clone());\n+        }\n+        // preprocess the markdown, rerouting markdown references to html references\n+        let markdown_data = try!(File::open(&src.join(&item.path)).read_to_string());\n+        let preprocessed_path = tmp.path().join(item.path.filename().unwrap());\n+        {\n+            let urls = md_urls.replace_all(&markdown_data[], \"[$title]($url_stem.html)\");\n+            try!(File::create(&preprocessed_path)\n+                      .write_str(&urls[]));\n+        }\n+\n+        // write the prelude to a temporary HTML file for rustdoc inclusion\n+        let prelude = tmp.path().join(\"prelude.html\");\n+        {\n+            let mut toc = BufferedWriter::new(try!(File::create(&prelude)));\n+            let _ = write_toc(book, &item.path_to_root, &mut toc);\n+            try!(writeln!(&mut toc, \"<div id='page-wrapper'>\"));\n+            try!(writeln!(&mut toc, \"<div id='page'>\"));\n+        }\n+\n+        // write the postlude to a temporary HTML file for rustdoc inclusion\n+        let postlude = tmp.path().join(\"postlude.html\");\n+        {\n+            let mut toc = BufferedWriter::new(try!(File::create(&postlude)));\n+            try!(writeln!(&mut toc, \"</div></div>\"));\n+        }\n+\n+        try!(fs::mkdir_recursive(&out_path, io::USER_DIR));\n+\n+        let rustdoc_args: &[String] = &[\n+            \"\".to_string(),\n+            preprocessed_path.display().to_string(),\n+            format!(\"-o{}\", out_path.display()),\n+            format!(\"--html-before-content={}\", prelude.display()),\n+            format!(\"--html-after-content={}\", postlude.display()),\n+            format!(\"--markdown-css={}\", item.path_to_root.join(\"rust-book.css\").display()),\n+            \"--markdown-no-toc\".to_string(),\n+        ];\n+        let output_result = rustdoc::main_args(rustdoc_args);\n+        if output_result != 0 {\n+            let message = format!(\"Could not execute `rustdoc` with {:?}: {}\",\n+                                  rustdoc_args, output_result);\n+            return Err(box message as Box<Error>);\n+        }\n+    }\n+\n+    // create index.html from the root README\n+    try!(fs::copy(&tgt.join(\"README.html\"), &tgt.join(\"index.html\")));\n+    Ok(())\n+}\n+\n+impl Subcommand for Build {\n+    fn parse_args(&mut self, _: &[String]) -> CliResult<()> {\n+        Ok(())\n+    }\n+    fn usage(&self) {}\n+    fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n+        let cwd = os::getcwd().unwrap();\n+        let src;\n+        let tgt;\n+\n+        if os::args().len() < 3 {\n+            src = cwd.clone();\n+        } else {\n+            src = Path::new(os::args()[2].clone());\n+        }\n+\n+        if os::args().len() < 4 {\n+            tgt = cwd.join(\"_book\");\n+        } else {\n+            tgt = Path::new(os::args()[3].clone());\n+        }\n+\n+        let _ = fs::mkdir(&tgt, io::USER_DIR); // FIXME: handle errors\n+\n+        // FIXME: handle errors\n+        let _ = File::create(&tgt.join(\"rust-book.css\")).write_str(css::STYLE);\n+\n+        let summary = File::open(&src.join(\"SUMMARY.md\"));\n+        match book::parse_summary(summary, &src) {\n+            Ok(book) => {\n+                // execute rustdoc on the whole book\n+                try!(render(&book, &tgt).map_err(|err| {\n+                    term.err(&format!(\"error: {}\", err.description())[]);\n+                    err.detail().map(|detail| {\n+                        term.err(&format!(\"detail: {}\", detail)[]);\n+                    });\n+                    err\n+                }))\n+            }\n+            Err(errors) => {\n+                for err in errors.into_iter() {\n+                    term.err(&err[]);\n+                }\n+            }\n+        }\n+\n+        Ok(()) // lol\n+    }\n+}"}, {"sha": "8eb66e71d3ad22271fb8e12975fafac439e9ad9c", "filename": "src/rustbook/css.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fcss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fcss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fcss.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The rust-book CSS in string form.\n+\n+pub static STYLE: &'static str = r#\"\n+@import url(\"//static.rust-lang.org/doc/master/rust.css\");\n+\n+body {\n+    max-width:none;\n+}\n+\n+#toc {\n+    position: absolute;\n+    left: 0px;\n+    top: 0px;\n+    bottom: 0px;\n+    width: 250px;\n+    overflow-y: auto;\n+    border-right: 1px solid rgba(0, 0, 0, 0.07);\n+    padding: 10px 10px;\n+    font-size: 16px;\n+    background: none repeat scroll 0% 0% #FFF;\n+    box-sizing: border-box;\n+}\n+\n+#page-wrapper {\n+    position: absolute;\n+    overflow-y: auto;\n+    left: 260px;\n+    right: 0px;\n+    top: 0px;\n+    bottom: 0px;\n+    box-sizing: border-box;\n+    background: none repeat scroll 0% 0% #FFF;\n+}\n+\n+#page {\n+    margin-left: auto;\n+    margin-right:auto;\n+    width: 750px;\n+}\n+\n+.chapter {\n+    list-style: none outside none;\n+    padding-left: 0px;\n+    line-height: 30px;\n+}\n+\n+.section {\n+    list-style: none outside none;\n+    padding-left: 20px;\n+    line-height: 30px;\n+}\n+\n+.section li {\n+    text-overflow: ellipsis;\n+    overflow: hidden;\n+    white-space: nowrap;\n+}\n+\n+.chapter li a {\n+    color: #000000;\n+}\n+\"#;"}, {"sha": "a5915ed4d7370d23473ed526de7953c7bc0fc991", "filename": "src/rustbook/error.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error handling utilities. WIP.\n+\n+use std::fmt;\n+use std::fmt::{Show, Formatter};\n+\n+use std::io::IoError;\n+\n+pub type CliError = Box<Error + 'static>;\n+pub type CliResult<T> = Result<T, CliError>;\n+\n+pub type CommandError = Box<Error + 'static>;\n+pub type CommandResult<T> = Result<T, CommandError>;\n+\n+pub trait Error {\n+    fn description(&self) -> &str;\n+\n+    fn detail(&self) -> Option<&str> { None }\n+    fn cause(&self) -> Option<&Error> { None }\n+}\n+\n+pub trait FromError<E> {\n+    fn from_err(err: E) -> Self;\n+}\n+\n+impl Show for Box<Error + 'static> {\n+    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.description())\n+    }\n+}\n+\n+impl<E: Error + 'static> FromError<E> for Box<Error + 'static> {\n+    fn from_err(err: E) -> Box<Error + 'static> {\n+        box err as Box<Error>\n+    }\n+}\n+\n+impl<'a> Error for &'a str {\n+    fn description<'b>(&'b self) -> &'b str {\n+        *self\n+    }\n+}\n+\n+impl Error for String {\n+    fn description<'a>(&'a self) -> &'a str {\n+        &self[]\n+    }\n+}\n+\n+impl<'a> Error for Box<Error + 'a> {\n+    fn description(&self) -> &str { (**self).description() }\n+    fn detail(&self) -> Option<&str> { (**self).detail() }\n+    fn cause(&self) -> Option<&Error> { (**self).cause() }\n+}\n+\n+impl FromError<()> for () {\n+    fn from_err(_: ()) -> () { () }\n+}\n+\n+impl FromError<IoError> for IoError {\n+    fn from_err(error: IoError) -> IoError { error }\n+}\n+\n+impl Error for IoError {\n+    fn description(&self) -> &str {\n+        self.desc\n+    }\n+    fn detail(&self) -> Option<&str> {\n+        self.detail.as_ref().map(|s| &s[])\n+    }\n+}\n+\n+//fn iter_map_err<T, U, E, I: Iterator<Result<T,E>>>(iter: I,"}, {"sha": "7fd8214f7311af078614aaf7ebcb4eebaa8f3569", "filename": "src/rustbook/help.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fhelp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fhelp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fhelp.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the `help` subcommand. Currently just prints basic usage info.\n+\n+use subcommand::Subcommand;\n+use error::CliResult;\n+use error::CommandResult;\n+use term::Term;\n+\n+struct Help;\n+\n+pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n+    match name {\n+        \"help\" | \"--help\" | \"-h\" | \"-?\" => Some(box Help as Box<Subcommand>),\n+        _ => None\n+    }\n+}\n+\n+impl Subcommand for Help {\n+    fn parse_args(&mut self, _: &[String]) -> CliResult<()> {\n+        Ok(())\n+    }\n+    fn usage(&self) {}\n+    fn execute(&mut self, _: &mut Term) -> CommandResult<()> {\n+        usage();\n+        Ok(())\n+    }\n+}\n+\n+pub fn usage() {\n+    println!(\"Usage: rust-book <command> [<args>]\");\n+    println!(\"\");\n+    println!(\"The <command> must be one of:\");\n+    println!(\"  help    Print this message.\");\n+    println!(\"  build   Build the book in subdirectory _book\");\n+    println!(\"  serve   --NOT YET IMPLEMENTED--\");\n+    println!(\"  test    --NOT YET IMPLEMENTED--\");\n+}"}, {"sha": "acb4edb7a4594ec38671a290e64e5ecc9333f383", "filename": "src/rustbook/main.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slicing_syntax, box_syntax)]\n+\n+extern crate regex;\n+\n+extern crate rustdoc;\n+\n+use std::os;\n+use subcommand::Subcommand;\n+use term::Term;\n+\n+macro_rules! try (\n+    ($expr:expr) => ({\n+        use error;\n+        match $expr {\n+            Ok(val) => val,\n+            Err(err) => return Err(error::FromError::from_err(err))\n+        }\n+    })\n+);\n+\n+mod term;\n+mod error;\n+mod book;\n+\n+mod subcommand;\n+mod help;\n+mod build;\n+mod serve;\n+mod test;\n+\n+mod css;\n+\n+#[cfg(not(test))] // thanks #12327\n+fn main() {\n+    let mut term = Term::new();\n+    let cmd = os::args();\n+\n+    if cmd.len() < 1 {\n+        help::usage()\n+    } else {\n+        match subcommand::parse_name(&cmd[1][]) {\n+            Some(mut subcmd) => {\n+                match subcmd.parse_args(cmd.tail()) {\n+                    Ok(_) => {\n+                        match subcmd.execute(&mut term) {\n+                            Ok(_) => (),\n+                            Err(_) => os::set_exit_status(-1),\n+                        }\n+                    }\n+                    Err(err) => {\n+                        println!(\"{}\", err.description());\n+                        println!(\"\");\n+                        subcmd.usage();\n+                    }\n+                }\n+            }\n+            None => {\n+                println!(\"Unrecognized command '{}'.\", cmd[1]);\n+                println!(\"\");\n+                help::usage();\n+            }\n+        }\n+    }\n+}"}, {"sha": "808527dcef95eeeaa2b2b96f3dbfe37abc24e4aa", "filename": "src/rustbook/serve.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fserve.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the `serve` subcommand. Just a stub for now.\n+\n+use subcommand::Subcommand;\n+use error::CliResult;\n+use error::CommandResult;\n+use term::Term;\n+\n+struct Serve;\n+\n+pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n+    if name == \"serve\" {\n+        Some(box Serve as Box<Subcommand>)\n+    } else {\n+        None\n+    }\n+}\n+\n+impl Subcommand for Serve {\n+    fn parse_args(&mut self, _: &[String]) -> CliResult<()> {\n+        Ok(())\n+    }\n+    fn usage(&self) {}\n+    fn execute(&mut self, _: &mut Term) -> CommandResult<()> {\n+        Ok(())\n+    }\n+}"}, {"sha": "473739c919d64ee27fc4e3e3e40a85e3b0e29426", "filename": "src/rustbook/subcommand.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fsubcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fsubcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fsubcommand.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Common API for all rust-book subcommands.\n+\n+use error::CliResult;\n+use error::CommandResult;\n+use term::Term;\n+\n+use help;\n+use build;\n+use serve;\n+use test;\n+\n+pub trait Subcommand {\n+    /// Mutate the subcommand by parsing its arguments.\n+    ///\n+    /// Returns `Err` on a parsing error.\n+    fn parse_args(&mut self, args: &[String]) -> CliResult<()>;\n+    /// Print the CLI usage information.\n+    fn usage(&self);\n+    /// Actually execute the subcommand.\n+    fn execute(&mut self, term: &mut Term) -> CommandResult<()>;\n+}\n+\n+/// Create a Subcommand object based on its name.\n+pub fn parse_name(name: &str) -> Option<Box<Subcommand>> {\n+    for parser in [\n+        help::parse_cmd as fn(&str) -> Option<Box<Subcommand>>,\n+        build::parse_cmd as fn(&str) -> Option<Box<Subcommand>>,\n+        serve::parse_cmd as fn(&str) -> Option<Box<Subcommand>>,\n+        test::parse_cmd as fn(&str) -> Option<Box<Subcommand>>].iter() {\n+        let parsed = (*parser)(name);\n+        if parsed.is_some() { return parsed }\n+    }\n+    None\n+}"}, {"sha": "471e22ce7c1f1df06716d906b4921e2c6db8b9b2", "filename": "src/rustbook/term.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fterm.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An abstraction of the terminal. Eventually, provide color and\n+//! verbosity support. For now, just a wrapper around stdout/stderr.\n+\n+use std::os;\n+use std::io::stdio;\n+\n+pub struct Term {\n+    err: Box<Writer + 'static>\n+}\n+\n+impl Term {\n+    pub fn new() -> Term {\n+        Term {\n+            err: box stdio::stderr() as Box<Writer>,\n+        }\n+    }\n+\n+    pub fn err(&mut self, msg: &str) {\n+        // swallow any errors\n+        let _ = self.err.write_line(msg);\n+        os::set_exit_status(101);\n+    }\n+}"}, {"sha": "f2bf92585f7ead27acf635c1cd373ad03010eb75", "filename": "src/rustbook/test.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the `test` subcommand. Just a stub for now.\n+\n+use subcommand::Subcommand;\n+use error::CliResult;\n+use error::CommandResult;\n+use error::Error;\n+use term::Term;\n+use book;\n+use std::io::{Command, File};\n+use std::os;\n+\n+struct Test;\n+\n+pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n+    if name == \"test\" {\n+        Some(box Test as Box<Subcommand>)\n+    } else {\n+        None\n+    }\n+}\n+\n+impl Subcommand for Test {\n+    fn parse_args(&mut self, _: &[String]) -> CliResult<()> {\n+        Ok(())\n+    }\n+    fn usage(&self) {}\n+    fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n+        let cwd = os::getcwd().unwrap();\n+        let src = cwd.clone();\n+\n+        let summary = File::open(&src.join(\"SUMMARY.md\"));\n+        match book::parse_summary(summary, &src) {\n+            Ok(book) => {\n+                for (_, item) in book.iter() {\n+                    let output_result = Command::new(\"rustdoc\")\n+                        .arg(&item.path)\n+                        .arg(\"--test\")\n+                        .output();\n+                    match output_result {\n+                        Ok(output) => {\n+                            if !output.status.success() {\n+                                term.err(&format!(\"{}\\n{}\",\n+                                         String::from_utf8_lossy(&output.output[]),\n+                                         String::from_utf8_lossy(&output.error[]))[]);\n+                                return Err(box \"Some tests failed.\" as Box<Error>);\n+                            }\n+\n+                        }\n+                        Err(e) => {\n+                            let message = format!(\"Could not execute `rustdoc`: {}\", e);\n+                            return Err(box message as Box<Error>);\n+                        }\n+                    }\n+                }\n+            }\n+            Err(errors) => {\n+                for err in errors.into_iter() {\n+                    term.err(&err[]);\n+                }\n+                return Err(box \"There was an error.\" as Box<Error>);\n+            }\n+        }\n+        Ok(()) // lol\n+    }\n+}"}, {"sha": "7a01ce3de0bcfea37dd1615d2f1ec54fdb72779f", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n #![crate_name=\"inherited_stability\"]\n #![crate_type = \"lib\"]\n-#![experimental]\n+#![unstable]\n+#![staged_api]\n \n pub fn experimental() {}\n \n@@ -26,7 +27,7 @@ pub mod stable_mod {\n \n #[unstable]\n pub mod unstable_mod {\n-    #[experimental]\n+    #[unstable]\n     pub fn experimental() {}\n \n     pub fn unstable() {}"}, {"sha": "adbb90fe6c8246a58e9e47f01849b643e8bbb525", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,13 +10,14 @@\n \n #![crate_name=\"lint_output_format\"]\n #![crate_type = \"lib\"]\n+#![staged_api]\n \n #[deprecated]\n pub fn foo() -> uint {\n     20\n }\n \n-#[experimental]\n+#[unstable]\n pub fn bar() -> uint {\n     40\n }"}, {"sha": "73724713b21c4f41d15968ae86f19dba230f407c", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,15 +9,16 @@\n // except according to those terms.\n #![crate_name=\"lint_stability\"]\n #![crate_type = \"lib\"]\n+#![staged_api]\n \n #[deprecated]\n pub fn deprecated() {}\n #[deprecated=\"text\"]\n pub fn deprecated_text() {}\n \n-#[experimental]\n+#[unstable]\n pub fn experimental() {}\n-#[experimental=\"text\"]\n+#[unstable=\"text\"]\n pub fn experimental_text() {}\n \n #[unstable]\n@@ -51,9 +52,9 @@ impl MethodTester {\n     #[deprecated=\"text\"]\n     pub fn method_deprecated_text(&self) {}\n \n-    #[experimental]\n+    #[unstable]\n     pub fn method_experimental(&self) {}\n-    #[experimental=\"text\"]\n+    #[unstable=\"text\"]\n     pub fn method_experimental_text(&self) {}\n \n     #[unstable]\n@@ -85,9 +86,9 @@ pub trait Trait {\n     #[deprecated=\"text\"]\n     fn trait_deprecated_text(&self) {}\n \n-    #[experimental]\n+    #[unstable]\n     fn trait_experimental(&self) {}\n-    #[experimental=\"text\"]\n+    #[unstable=\"text\"]\n     fn trait_experimental_text(&self) {}\n \n     #[unstable]\n@@ -115,12 +116,12 @@ pub trait Trait {\n \n impl Trait for MethodTester {}\n \n-#[experimental]\n+#[unstable]\n pub trait ExperimentalTrait {}\n \n #[deprecated]\n pub struct DeprecatedStruct { pub i: int }\n-#[experimental]\n+#[unstable]\n pub struct ExperimentalStruct { pub i: int }\n #[unstable]\n pub struct UnstableStruct { pub i: int }\n@@ -134,7 +135,7 @@ pub struct LockedStruct { pub i: int }\n \n #[deprecated]\n pub struct DeprecatedUnitStruct;\n-#[experimental]\n+#[unstable]\n pub struct ExperimentalUnitStruct;\n #[unstable]\n pub struct UnstableUnitStruct;\n@@ -149,7 +150,7 @@ pub struct LockedUnitStruct;\n pub enum Enum {\n     #[deprecated]\n     DeprecatedVariant,\n-    #[experimental]\n+    #[unstable]\n     ExperimentalVariant,\n     #[unstable]\n     UnstableVariant,\n@@ -165,7 +166,7 @@ pub enum Enum {\n \n #[deprecated]\n pub struct DeprecatedTupleStruct(pub int);\n-#[experimental]\n+#[unstable]\n pub struct ExperimentalTupleStruct(pub int);\n #[unstable]\n pub struct UnstableTupleStruct(pub int);"}, {"sha": "de806c65bebc293761cff832bae724acaabd0012", "filename": "src/test/auxiliary/stability_cfg1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,3 +10,4 @@\n \n #![cfg_attr(foo, experimental)]\n #![cfg_attr(not(foo), stable)]\n+#![staged_api]"}, {"sha": "842f35b08aec3a04cc460a0fd491baf777c297f1", "filename": "src/test/auxiliary/stability_cfg2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,6 +10,6 @@\n \n // compile-flags:--cfg foo\n \n-#![cfg_attr(foo, experimental)]\n+#![cfg_attr(foo, unstable)]\n #![cfg_attr(not(foo), stable)]\n-\n+#![staged_api]"}, {"sha": "cf1264ff5d675e54d4b393169fb3e121dcd88a10", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -39,7 +39,7 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n #![feature(simd)]\n-#![allow(experimental)]\n+#![allow(unstable)]\n \n // ignore-pretty very bad with line comments\n "}, {"sha": "6845116e4a4cefdfc81de8f20375d75f8b61e6a1", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,6 +15,6 @@ pub use use_from_trait_xc::Trait;\n \n fn main() {\n     match () {\n-        Trait { x: 42u } => () //~ ERROR use of trait `Trait` in a struct pattern\n+        Trait { x: 42us } => () //~ ERROR use of trait `Trait` in a struct pattern\n     }\n }"}, {"sha": "bad192fc2cfea95bbb149a26748cde2747ef57ed", "filename": "src/test/compile-fail/access-mode-in-closures.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n \n-struct sty(Vec<int> );\n+struct sty(Vec<isize> );\n \n-fn unpack<F>(_unpack: F) where F: FnOnce(&sty) -> Vec<int> {}\n+fn unpack<F>(_unpack: F) where F: FnOnce(&sty) -> Vec<isize> {}\n \n fn main() {\n     let _foo = unpack(|s| {"}, {"sha": "673314ec4c9978bf98327b22ff2b8c5ea7e6b73b", "filename": "src/test/compile-fail/arg-count-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,6 +10,6 @@\n \n // error-pattern: parameters were supplied\n \n-fn f(x: int) { }\n+fn f(x: isize) { }\n \n fn main() { let i: (); i = f(); }"}, {"sha": "1f657ca58326eb4bafbd3db64a52d82807add1b9", "filename": "src/test/compile-fail/arg-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,6 +11,6 @@\n \n // error-pattern: mismatched types\n \n-fn f(x: int) { }\n+fn f(x: isize) { }\n \n fn main() { let i: (); i = f(()); }"}, {"sha": "3b4810a86abd559597a7e61c13065638a6f3bc3d", "filename": "src/test/compile-fail/array-old-syntax-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farray-old-syntax-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farray-old-syntax-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray-old-syntax-1.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,5 +11,5 @@\n // Test that the old fixed length array syntax is a parsing error.\n \n fn main() {\n-    let _x: [int, ..3] = [0i, 1, 2]; //~ ERROR\n+    let _x: [isize, ..3] = [0is, 1, 2]; //~ ERROR\n }"}, {"sha": "c1b88290bc39cc80737d50af8062ef70555494aa", "filename": "src/test/compile-fail/array-old-syntax-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farray-old-syntax-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Farray-old-syntax-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray-old-syntax-2.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,5 +11,5 @@\n // Test that the old repeating array syntax gives an error.\n \n fn main() {\n-    let _ = [0i, ..3]; //~ ERROR\n+    let _ = [0is, ..3]; //~ ERROR\n }"}, {"sha": "ffbb25e266ac644c6bb46943b3f462ff9bb92b51", "filename": "src/test/compile-fail/asm-in-bad-modifier.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,18 +10,18 @@\n \n #![feature(asm)]\n \n-fn foo(x: int) { println!(\"{}\", x); }\n+fn foo(x: isize) { println!(\"{}\", x); }\n \n #[cfg(any(target_arch = \"x86\",\n           target_arch = \"x86_64\",\n           target_arch = \"arm\",\n           target_arch = \"aarch64\"))]\n pub fn main() {\n-    let x: int;\n-    let y: int;\n+    let x: isize;\n+    let y: isize;\n     unsafe {\n-        asm!(\"mov $1, $0\" : \"=r\"(x) : \"=r\"(5u)); //~ ERROR input operand constraint contains '='\n-        asm!(\"mov $1, $0\" : \"=r\"(y) : \"+r\"(5u)); //~ ERROR input operand constraint contains '+'\n+        asm!(\"mov $1, $0\" : \"=r\"(x) : \"=r\"(5us)); //~ ERROR input operand constraint contains '='\n+        asm!(\"mov $1, $0\" : \"=r\"(y) : \"+r\"(5us)); //~ ERROR input operand constraint contains '+'\n     }\n     foo(x);\n     foo(y);"}, {"sha": "8bc6f206dec02c7118c09a82ab3a621922fbfe47", "filename": "src/test/compile-fail/asm-misplaced-option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -18,17 +18,17 @@\n           target_arch = \"x86_64\"))]\n pub fn main() {\n     // assignment not dead\n-    let mut x: int = 0;\n+    let mut x: isize = 0;\n     unsafe {\n         // extra colon\n-        asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(5u), \"0\"(x) : : \"cc\");\n+        asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(5us), \"0\"(x) : : \"cc\");\n         //~^ WARNING unrecognized option\n     }\n     assert_eq!(x, 5);\n \n     unsafe {\n         // comma in place of a colon\n-        asm!(\"add $2, $1; mov $1, $0\" : \"=r\"(x) : \"r\"(x), \"r\"(8u) : \"cc\", \"volatile\");\n+        asm!(\"add $2, $1; mov $1, $0\" : \"=r\"(x) : \"r\"(x), \"r\"(8us) : \"cc\", \"volatile\");\n         //~^ WARNING expected a clobber, found an option\n     }\n     assert_eq!(x, 13);"}, {"sha": "9ad5d7e9f09eefbf021648eae0ff8cf739e7115c", "filename": "src/test/compile-fail/asm-out-assign-imm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,18 +10,18 @@\n \n #![feature(asm)]\n \n-fn foo(x: int) { println!(\"{}\", x); }\n+fn foo(x: isize) { println!(\"{}\", x); }\n \n #[cfg(any(target_arch = \"x86\",\n           target_arch = \"x86_64\",\n           target_arch = \"arm\",\n           target_arch = \"aarch64\"))]\n pub fn main() {\n-    let x: int;\n+    let x: isize;\n     x = 1; //~ NOTE prior assignment occurs here\n     foo(x);\n     unsafe {\n-        asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(5u)); //~ ERROR re-assignment of immutable variable `x`\n+        asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(5us)); //~ ERROR re-assignment of immutable variable `x`\n     }\n     foo(x);\n }"}, {"sha": "b58d41e1d825c163ca84fe737b25dba72debf493", "filename": "src/test/compile-fail/asm-out-no-modifier.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,16 +10,16 @@\n \n #![feature(asm)]\n \n-fn foo(x: int) { println!(\"{}\", x); }\n+fn foo(x: isize) { println!(\"{}\", x); }\n \n #[cfg(any(target_arch = \"x86\",\n           target_arch = \"x86_64\",\n           target_arch = \"arm\",\n           target_arch = \"aarch64\"))]\n pub fn main() {\n-    let x: int;\n+    let x: isize;\n     unsafe {\n-        asm!(\"mov $1, $0\" : \"r\"(x) : \"r\"(5u)); //~ ERROR output operand constraint lacks '='\n+        asm!(\"mov $1, $0\" : \"r\"(x) : \"r\"(5us)); //~ ERROR output operand constraint lacks '='\n     }\n     foo(x);\n }"}, {"sha": "5e71a2c731dd275e2db7fde4ff78c407d206eeb0", "filename": "src/test/compile-fail/asm-out-read-uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,14 +10,14 @@\n \n #![feature(asm)]\n \n-fn foo(x: int) { println!(\"{}\", x); }\n+fn foo(x: isize) { println!(\"{}\", x); }\n \n #[cfg(any(target_arch = \"x86\",\n           target_arch = \"x86_64\",\n           target_arch = \"arm\",\n           target_arch = \"aarch64\"))]\n pub fn main() {\n-    let x: int;\n+    let x: isize;\n     unsafe {\n         asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(x)); //~ ERROR use of possibly uninitialized variable: `x`\n     }"}, {"sha": "540272a8e2c58b511542504a666fdf20fb4be2c1", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn test() {\n-    let v: int;\n+    let v: isize;\n     v = 1; //~ NOTE prior assignment occurs here\n     println!(\"v={}\", v);\n     v = 2; //~ ERROR re-assignment of immutable variable"}, {"sha": "0694420e7666fed35f4935e80f659ba03b7b5cb5", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,23 +9,23 @@\n // except according to those terms.\n \n struct cat {\n-  meows : uint,\n+  meows : usize,\n \n-  how_hungry : int,\n+  how_hungry : isize,\n }\n \n impl cat {\n-    pub fn speak(&self) { self.meows += 1u; }\n+    pub fn speak(&self) { self.meows += 1us; }\n }\n \n-fn cat(in_x : uint, in_y : int) -> cat {\n+fn cat(in_x : usize, in_y : isize) -> cat {\n     cat {\n         meows: in_x,\n         how_hungry: in_y\n     }\n }\n \n fn main() {\n-  let nyan : cat = cat(52u, 99);\n+  let nyan : cat = cat(52us, 99);\n   nyan.speak = |&:| println!(\"meow\"); //~ ERROR attempted to take value of method\n }"}, {"sha": "ba8e4a652d337397609eb7c254de9b938e6f96a8", "filename": "src/test/compile-fail/assoc-inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassoc-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassoc-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-inherent.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,7 +13,7 @@\n struct Foo;\n \n impl Foo {\n-    type Bar = int; //~ERROR associated items are not allowed in inherent impls\n+    type Bar = isize; //~ERROR associated items are not allowed in inherent impls\n }\n \n fn main() {}"}, {"sha": "adccd73beae2dc97651f38cdc1f844e6611cd74e", "filename": "src/test/compile-fail/associated-types-bound-failure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-bound-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-bound-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-bound-failure.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,7 +11,7 @@\n // Test equality constraints on associated types in a where clause.\n \n pub trait ToInt {\n-    fn to_int(&self) -> int;\n+    fn to_int(&self) -> isize;\n }\n \n pub trait GetToInt\n@@ -21,13 +21,13 @@ pub trait GetToInt\n     fn get(&self) -> <Self as GetToInt>::R;\n }\n \n-fn foo<G>(g: G) -> int\n+fn foo<G>(g: G) -> isize\n     where G : GetToInt\n {\n     ToInt::to_int(&g.get()) //~ ERROR not implemented\n }\n \n-fn bar<G : GetToInt>(g: G) -> int\n+fn bar<G : GetToInt>(g: G) -> isize\n     where G::R : ToInt\n {\n     ToInt::to_int(&g.get()) // OK"}, {"sha": "95a68dd66983672dfe537bf4f1bfc8bcee5c8d2d", "filename": "src/test/compile-fail/associated-types-coherence-failure.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that coherence detects overlap when some of the types in the\n+// impls are projections of associated type. Issue #20624.\n+\n+use std::ops::Deref;\n+\n+pub struct Cow<'a, B: ?Sized>;\n+\n+/// Trait for moving into a `Cow`\n+pub trait IntoCow<'a, B: ?Sized> {\n+    /// Moves `self` into `Cow`\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n+//~^ ERROR E0119\n+    fn into_cow(self) -> Cow<'a, B> {\n+        self\n+    }\n+}\n+\n+impl<'a, B: ?Sized> IntoCow<'a, B> for <B as ToOwned>::Owned where B: ToOwned {\n+//~^ ERROR E0119\n+    fn into_cow(self) -> Cow<'a, B> {\n+        Cow\n+    }\n+}\n+\n+impl<'a, B: ?Sized> IntoCow<'a, B> for &'a B where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B> {\n+        Cow\n+    }\n+}\n+\n+impl ToOwned for u8 {\n+    type Owned = &'static u8;\n+    fn to_owned(&self) -> &'static u8 { panic!() }\n+}\n+\n+/// A generalization of Clone to borrowed data.\n+pub trait ToOwned {\n+    type Owned;\n+\n+    /// Create owned data from borrowed data, usually by copying.\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+\n+\n+fn main() {}\n+"}, {"sha": "755a9f2d73f6271f22dbb263c9bcc40aeeeedeba", "filename": "src/test/compile-fail/associated-types-eq-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -18,9 +18,9 @@ pub trait Foo {\n \n struct Bar;\n \n-impl Foo for int {\n-    type A = uint;\n-    fn boo(&self) -> uint { 42 }\n+impl Foo for isize {\n+    type A = usize;\n+    fn boo(&self) -> usize { 42 }\n }\n \n fn baz<I: Foo>(x: &<I as Foo<A=Bar>>::A) {}"}, {"sha": "ed81c0fccbc854687bde295941db5657b497988c", "filename": "src/test/compile-fail/associated-types-eq-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -18,9 +18,9 @@ pub trait Foo {\n \n struct Bar;\n \n-impl Foo for int {\n-    type A = uint;\n-    fn boo(&self) -> uint {\n+impl Foo for isize {\n+    type A = usize;\n+    fn boo(&self) -> usize {\n         42\n     }\n }\n@@ -40,7 +40,7 @@ pub fn baz(x: &Foo<A=Bar>) {\n \n \n pub fn main() {\n-    let a = 42i;\n+    let a = 42is;\n     foo1(a); //~ERROR expected usize, found struct Bar\n     baz(&a); //~ERROR expected usize, found struct Bar\n }"}, {"sha": "9baa7f1ad5a6901237f64cb4f1777590e47d638d", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,15 +12,15 @@\n \n trait Foo {\n     type A;\n-    fn bar() -> int;\n+    fn bar() -> isize;\n }\n \n-impl Foo for int {\n-    type A = uint;\n-    fn bar() -> int { 42 }\n+impl Foo for isize {\n+    type A = usize;\n+    fn bar() -> isize { 42 }\n }\n \n pub fn main() {\n-    let x: int = Foo::<A=uint>::bar();\n+    let x: isize = Foo::<A=usize>::bar();\n     //~^ERROR unexpected binding of associated item in expression path\n }"}, {"sha": "d5678c155fd2db44dd4f6a94e354ff6a3ee7b196", "filename": "src/test/compile-fail/associated-types-eq-hr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,43 +17,43 @@ pub trait TheTrait<T> {\n }\n \n struct IntStruct {\n-    x: int\n+    x: isize\n }\n \n-impl<'a> TheTrait<&'a int> for IntStruct {\n-    type A = &'a int;\n+impl<'a> TheTrait<&'a isize> for IntStruct {\n+    type A = &'a isize;\n \n-    fn get(&self, t: &'a int) -> &'a int {\n+    fn get(&self, t: &'a isize) -> &'a isize {\n         t\n     }\n }\n \n struct UintStruct {\n-    x: int\n+    x: isize\n }\n \n-impl<'a> TheTrait<&'a int> for UintStruct {\n-    type A = &'a uint;\n+impl<'a> TheTrait<&'a isize> for UintStruct {\n+    type A = &'a usize;\n \n-    fn get(&self, t: &'a int) -> &'a uint {\n+    fn get(&self, t: &'a isize) -> &'a usize {\n         panic!()\n     }\n }\n \n fn foo<T>()\n-    where T : for<'x> TheTrait<&'x int, A = &'x int>\n+    where T : for<'x> TheTrait<&'x isize, A = &'x isize>\n {\n     // ok for IntStruct, but not UintStruct\n }\n \n fn bar<T>()\n-    where T : for<'x> TheTrait<&'x int, A = &'x uint>\n+    where T : for<'x> TheTrait<&'x isize, A = &'x usize>\n {\n     // ok for UintStruct, but not IntStruct\n }\n \n fn baz<T>()\n-    where T : for<'x,'y> TheTrait<&'x int, A = &'y int>\n+    where T : for<'x,'y> TheTrait<&'x isize, A = &'y isize>\n {\n     // not ok for either struct, due to the use of two lifetimes\n }"}, {"sha": "31492406fedd35fd6350e65b660ef44fa24c6c28", "filename": "src/test/compile-fail/associated-types-incomplete-object.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -19,24 +19,24 @@ pub trait Foo {\n \n struct Bar;\n \n-impl Foo for int {\n-    type A = uint;\n+impl Foo for isize {\n+    type A = usize;\n     type B = char;\n-    fn boo(&self) -> uint {\n+    fn boo(&self) -> usize {\n         42\n     }\n }\n \n pub fn main() {\n-    let a = &42i as &Foo<A=uint, B=char>;\n+    let a = &42is as &Foo<A=usize, B=char>;\n \n-    let b = &42i as &Foo<A=uint>;\n+    let b = &42is as &Foo<A=usize>;\n     //~^ ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n \n-    let c = &42i as &Foo<B=char>;\n+    let c = &42is as &Foo<B=char>;\n     //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n \n-    let d = &42i as &Foo;\n+    let d = &42is as &Foo;\n     //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n     //~| ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n }"}, {"sha": "b6c4d59c8488299d859beb46d72f50da458e35f4", "filename": "src/test/compile-fail/associated-types-invalid-trait-ref-issue-18865.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-invalid-trait-ref-issue-18865.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-invalid-trait-ref-issue-18865.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-invalid-trait-ref-issue-18865.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,7 +16,7 @@ trait Foo<T> {\n     fn get_bar(&self) -> Self::Bar;\n }\n \n-fn f<T:Foo<int>>(t: &T) {\n+fn f<T:Foo<isize>>(t: &T) {\n     let u: <T as Foo<usize>>::Bar = t.get_bar();\n     //~^ ERROR the trait `Foo<usize>` is not implemented for the type `T`\n }"}, {"sha": "fa09ae793bf632c75198a0fad1b8d7056838040c", "filename": "src/test/compile-fail/associated-types-issue-17359.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,7 +15,7 @@ trait Trait {\n     type Type;\n }\n \n-impl Trait for int {}  //~ ERROR missing: `Type`\n+impl Trait for isize {}  //~ ERROR missing: `Type`\n \n fn main() {}\n "}, {"sha": "fd60896c29885b262a657fec9efa2de3a2716162", "filename": "src/test/compile-fail/associated-types-no-suitable-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-bound.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,7 +14,7 @@ trait Get {\n }\n \n struct Struct {\n-    x: int,\n+    x: isize,\n }\n \n impl Struct {"}, {"sha": "74c8dffced5cf9e0d06f2847c0fab8e00dc14d78", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,8 +14,8 @@ pub trait Foo {\n     type A;\n }\n \n-impl Foo for int {\n-    type A = uint;\n+impl Foo for isize {\n+    type A = usize;\n }\n \n pub fn f1<T: Foo>(a: T, x: T::A) {}\n@@ -45,7 +45,7 @@ pub fn f1_uint_int() {\n }\n \n pub fn f2_int() {\n-    let _: int = f2(2is);\n+    let _: isize = f2(2is);\n     //~^ ERROR expected `isize`, found `usize`\n }\n "}, {"sha": "917c03fbf4b1c427097d4de2ac42960912bc4475", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-explicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-explicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-explicit.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,7 +17,7 @@ pub trait Foo<T> {\n     fn get(&self, t: T) -> Self::A;\n }\n \n-fn foo2<I>(x: <I as for<'x> Foo<&'x int>>::A)\n+fn foo2<I>(x: <I as for<'x> Foo<&'x isize>>::A)\n     //~^ ERROR expected identifier, found keyword `for`\n     //~| ERROR expected one of `::` or `>`\n {"}, {"sha": "285a77d6b657ae8bd35d012f2b320cab4441b2c2", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-fn-body.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,15 +17,15 @@ pub trait Foo<T> {\n     fn get(&self, t: T) -> Self::A;\n }\n \n-fn foo<'a, I : for<'x> Foo<&'x int>>(\n-    x: <I as Foo<&'a int>>::A)\n+fn foo<'a, I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&'a isize>>::A)\n {\n     let y: I::A = x;\n }\n \n-fn bar<'a, 'b, I : for<'x> Foo<&'x int>>(\n-    x: <I as Foo<&'a int>>::A,\n-    y: <I as Foo<&'b int>>::A,\n+fn bar<'a, 'b, I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&'a isize>>::A,\n+    y: <I as Foo<&'b isize>>::A,\n     cond: bool)\n {\n     // x and y here have two distinct lifetimes:"}, {"sha": "a79d5c4649a49e2e82fa7b71850b3ccc1f144db4", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-fn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,7 +17,7 @@ pub trait Foo<T> {\n     fn get(&self, t: T) -> Self::A;\n }\n \n-fn foo2<I : for<'x> Foo<&'x int>>(\n+fn foo2<I : for<'x> Foo<&'x isize>>(\n     x: I::A)\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n {\n@@ -28,15 +28,15 @@ fn foo2<I : for<'x> Foo<&'x int>>(\n     // specifically for fn signatures.\n }\n \n-fn foo3<I : for<'x> Foo<&'x int>>(\n-    x: <I as Foo<&int>>::A)\n+fn foo3<I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&isize>>::A)\n {\n     // OK, in this case we spelled out the precise regions involved, though we left one of\n     // them anonymous.\n }\n \n-fn foo4<'a, I : for<'x> Foo<&'x int>>(\n-    x: <I as Foo<&'a int>>::A)\n+fn foo4<'a, I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&'a isize>>::A)\n {\n     // OK, in this case we spelled out the precise regions involved.\n }"}, {"sha": "44ad0bb01138fe2d085d315f974abd11ec940281", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,18 +17,18 @@ pub trait Foo<T> {\n     fn get(&self, t: T) -> Self::A;\n }\n \n-struct SomeStruct<I : for<'x> Foo<&'x int>> {\n+struct SomeStruct<I : for<'x> Foo<&'x isize>> {\n     field: I::A\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n-struct AnotherStruct<I : for<'x> Foo<&'x int>> {\n-    field: <I as Foo<&int>>::A\n+struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n+    field: <I as Foo<&isize>>::A\n     //~^ ERROR missing lifetime specifier\n }\n \n-struct YetAnotherStruct<'a, I : for<'x> Foo<&'x int>> {\n-    field: <I as Foo<&'a int>>::A\n+struct YetAnotherStruct<'a, I : for<'x> Foo<&'x isize>> {\n+    field: <I as Foo<&'a isize>>::A\n }\n \n pub fn main() {}"}, {"sha": "af46a1b42d07855ff2f122ea4edbd8e2eafb7df4", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-trait-method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-trait-method.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,17 +17,17 @@ pub trait Foo<T> {\n     fn get(&self, t: T) -> Self::A;\n }\n \n-trait SomeTrait<I : for<'x> Foo<&'x int>> {\n+trait SomeTrait<I : for<'x> Foo<&'x isize>> {\n     fn some_method(&self, arg: I::A);\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n-trait AnotherTrait<I : for<'x> Foo<&'x int>> {\n-    fn some_method(&self, arg: <I as Foo<&int>>::A);\n+trait AnotherTrait<I : for<'x> Foo<&'x isize>> {\n+    fn some_method(&self, arg: <I as Foo<&isize>>::A);\n }\n \n-trait YetAnotherTrait<I : for<'x> Foo<&'x int>> {\n-    fn some_method<'a>(&self, arg: <I as Foo<&'a int>>::A);\n+trait YetAnotherTrait<I : for<'x> Foo<&'x isize>> {\n+    fn some_method<'a>(&self, arg: <I as Foo<&'a isize>>::A);\n }\n \n pub fn main() {}"}, {"sha": "aecbf217a5b25e916155829b81188bf7401049ac", "filename": "src/test/compile-fail/associated-types-unconstrained.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,15 +12,15 @@\n \n trait Foo {\n     type A;\n-    fn bar() -> int;\n+    fn bar() -> isize;\n }\n \n-impl Foo for int {\n-    type A = uint;\n-    fn bar() -> int { 42 }\n+impl Foo for isize {\n+    type A = usize;\n+    fn bar() -> isize { 42 }\n }\n \n pub fn main() {\n-    let x: int = Foo::bar();\n+    let x: isize = Foo::bar();\n     //~^ ERROR type annotations required\n }"}, {"sha": "ad3f467a454713e2fb8c6a0cfe58d8d93f6335ea", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -27,7 +27,7 @@ trait MyIter {\n     fn test(&self);\n }\n \n-impl<'a> MyIter for &'a [int] {\n+impl<'a> MyIter for &'a [isize] {\n     fn test_mut(&mut self) { }\n     fn test(&self) { }\n }"}, {"sha": "2c5749e0d5d39ae81127625caa1a3a79b4e7cddf", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -28,7 +28,7 @@ fn main() {\n     assert_eq!(z, 21);\n     let forty: fish = fish{a: box 40};\n     let two: fish = fish{a: box 2};\n-    let answer: int = forty.a + two.a;\n+    let answer: isize = forty.a + two.a;\n     //~^ ERROR binary operation `+` cannot be applied to type `Box<isize>`\n     println!(\"{}\", answer);\n     assert_eq!(answer, 42);"}, {"sha": "e5dbdbd237db87a2daac4d4df70f743a611d629b", "filename": "src/test/compile-fail/bad-bang-ann-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann-3.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,8 +10,8 @@\n \n // Tests that a function with a ! annotation always actually fails\n \n-fn bad_bang(i: uint) -> ! {\n-    return 7u; //~ ERROR `return` in a function declared as diverging [E0166]\n+fn bad_bang(i: usize) -> ! {\n+    return 7us; //~ ERROR `return` in a function declared as diverging [E0166]\n }\n \n-fn main() { bad_bang(5u); }\n+fn main() { bad_bang(5us); }"}, {"sha": "414421c8b77ce2bd4dc20818187c9fc037ced096", "filename": "src/test/compile-fail/bad-bang-ann.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,8 +10,8 @@\n \n // Tests that a function with a ! annotation always actually fails\n \n-fn bad_bang(i: uint) -> ! { //~ ERROR computation may converge in a function marked as diverging\n-    if i < 0u { } else { panic!(); }\n+fn bad_bang(i: usize) -> ! { //~ ERROR computation may converge in a function marked as diverging\n+    if i < 0us { } else { panic!(); }\n }\n \n-fn main() { bad_bang(5u); }\n+fn main() { bad_bang(5us); }"}, {"sha": "938664887327be367b34840c8a240f1b2903a115", "filename": "src/test/compile-fail/bad-env-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern: can't capture dynamic environment in a fn item;\n fn foo() {\n-    let x: int;\n+    let x: isize;\n     fn bar() { log(debug, x); }\n }\n fn main() { foo(); }"}, {"sha": "39a6922cfd0b653ec2ba3520ff6a8362525f4ae4", "filename": "src/test/compile-fail/bad-env-capture2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture2.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // error-pattern: can't capture dynamic environment in a fn item;\n-fn foo(x: int) {\n+fn foo(x: isize) {\n     fn bar() { log(debug, x); }\n }\n fn main() { foo(2); }"}, {"sha": "8857b94ddce0c7bf0c678788600e9335b646dbad", "filename": "src/test/compile-fail/bad-env-capture3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture3.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // error-pattern: can't capture dynamic environment in a fn item;\n-fn foo(x: int) {\n+fn foo(x: isize) {\n     fn mth() {\n         fn bar() { log(debug, x); }\n     }"}, {"sha": "321dca8989134f92391abda79aa2b74fc11c4f14", "filename": "src/test/compile-fail/bad-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-main.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main(x: int) { } //~ ERROR: main function expects type\n+fn main(x: isize) { } //~ ERROR: main function expects type"}, {"sha": "33043ff5524a45753ad6826c9661f4025ec4ef5d", "filename": "src/test/compile-fail/bad-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-match.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,7 +11,7 @@\n // error-pattern: expected\n \n fn main() {\n-  let int x = 5;\n+  let isize x = 5;\n   match x;\n }\n "}, {"sha": "8e5a6054b89280593ad0d587251b5d2e43466262", "filename": "src/test/compile-fail/bad-method-typaram-kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-method-typaram-kind.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n fn foo<T:'static>() {\n-    1u.bar::<T>(); //~ ERROR `core::marker::Send` is not implemented\n+    1us.bar::<T>(); //~ ERROR `core::marker::Send` is not implemented\n }\n \n trait bar {\n     fn bar<T:Send>(&self);\n }\n \n-impl bar for uint {\n+impl bar for usize {\n     fn bar<T:Send>(&self) {\n     }\n }"}, {"sha": "79fe4e7165ec378d133e49be0faa3846781e4b9a", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -33,28 +33,28 @@ trait Trait<T> {\n }\n \n struct S2 {\n-    contents: int,\n+    contents: isize,\n }\n \n-impl Trait<int> for S2 {\n-    fn new<U>(x: int, _: U) -> S2 {\n+impl Trait<isize> for S2 {\n+    fn new<U>(x: isize, _: U) -> S2 {\n         S2 {\n             contents: x,\n         }\n     }\n }\n \n fn foo<'a>() {\n-    let _ = S::new::<int,f64>(1, 1.0);\n+    let _ = S::new::<isize,f64>(1, 1.0);\n     //~^ ERROR too many type parameters provided\n \n-    let _ = S::<'a,int>::new::<f64>(1, 1.0);\n+    let _ = S::<'a,isize>::new::<f64>(1, 1.0);\n     //~^ ERROR too many lifetime parameters provided\n \n-    let _: S2 = Trait::new::<int,f64>(1, 1.0);\n+    let _: S2 = Trait::new::<isize,f64>(1, 1.0);\n     //~^ ERROR too many type parameters provided\n \n-    let _: S2 = Trait::<'a,int>::new::<f64>(1, 1.0);\n+    let _: S2 = Trait::<'a,isize>::new::<f64>(1, 1.0);\n     //~^ ERROR too many lifetime parameters provided\n }\n "}, {"sha": "b208c6f4244efc15399e48ed35144882db82e119", "filename": "src/test/compile-fail/bad-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-name.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,5 +11,5 @@\n // error-pattern: expected\n \n fn main() {\n-  let x.y::<int>.z foo;\n+  let x.y::<isize>.z foo;\n }"}, {"sha": "d17fa68b47cbe21f2d5d654894f0e8968fc98e48", "filename": "src/test/compile-fail/bang-tailexpr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbang-tailexpr.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn f() -> ! { //~ ERROR computation may converge in a function marked as diverging\n-    3i\n+    3is\n }\n fn main() { }"}, {"sha": "0d84a5e7d0280bffdde45f64d69385013857fb2a", "filename": "src/test/compile-fail/better-expected.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbetter-expected.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let x: [int 3]; //~ ERROR expected one of `(`, `+`, `::`, `;`, or `]`, found `3`\n+    let x: [isize 3]; //~ ERROR expected one of `(`, `+`, `::`, `;`, or `]`, found `3`\n }"}, {"sha": "375f6c5d0475ecfc507f1286c49daee538739f5f", "filename": "src/test/compile-fail/bind-struct-early-modifiers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbind-struct-early-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbind-struct-early-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-struct-early-modifiers.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    struct Foo { x: int }\n+    struct Foo { x: isize }\n     match (Foo { x: 10 }) {\n         Foo { ref x: ref x } => {}, //~ ERROR unexpected `:`\n         _ => {}"}, {"sha": "cff0064497aff34ac814b8be55d4a1b9c4e64b9d", "filename": "src/test/compile-fail/binop-move-semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -37,9 +37,9 @@ fn illegal_dereference<T: Add<Output=()>>(mut x: T, y: T) {\n     let m = &mut x;\n     let n = &y;\n \n-    *m  //~ ERROR: cannot move out of dereference of `&mut`-pointer\n+    *m  //~ ERROR: cannot move out of borrowed content\n     +\n-    *n;  //~ ERROR: cannot move out of dereference of `&`-pointer\n+    *n;  //~ ERROR: cannot move out of borrowed content\n }\n \n struct Foo;"}, {"sha": "704d856f106b280468522ff0377c02c0882c77a3", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,7 +11,7 @@\n \n // error-pattern: unresolved\n \n-enum color { rgb(int, int, int), rgba(int, int, int, int), }\n+enum color { rgb(isize, isize, isize), rgba(isize, isize, isize, isize), }\n \n fn main() {\n     let red: color = rgb(255, 0, 0);"}, {"sha": "12555c550729ca13c405ccd11cd14e5c8572c169", "filename": "src/test/compile-fail/borrow-immutable-upvar-mutation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,29 +13,29 @@\n // Tests that we can't assign to or mutably borrow upvars from `Fn`\n // closures (issue #17780)\n \n-fn set(x: &mut uint) { *x = 5; }\n+fn set(x: &mut usize) { *x = 5; }\n \n fn main() {\n     // By-ref captures\n     {\n-        let mut x = 0u;\n+        let mut x = 0us;\n         let _f = |&:| x = 42; //~ ERROR cannot assign\n \n-        let mut y = 0u;\n+        let mut y = 0us;\n         let _g = |&:| set(&mut y); //~ ERROR cannot borrow\n \n-        let mut z = 0u;\n+        let mut z = 0us;\n         let _h = |&mut:| { set(&mut z); |&:| z = 42; }; //~ ERROR cannot assign\n     }\n     // By-value captures\n     {\n-        let mut x = 0u;\n+        let mut x = 0us;\n         let _f = move |&:| x = 42; //~ ERROR cannot assign\n \n-        let mut y = 0u;\n+        let mut y = 0us;\n         let _g = move |&:| set(&mut y); //~ ERROR cannot borrow\n \n-        let mut z = 0u;\n+        let mut z = 0us;\n         let _h = move |&mut:| { set(&mut z); move |&:| z = 42; }; //~ ERROR cannot assign\n     }\n }"}, {"sha": "e6fe60a9004b6b1f00bfccc6062b84dfc4af32a3", "filename": "src/test/compile-fail/borrow-tuple-fields.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrow-tuple-fields.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,33 +11,33 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-struct Foo(Box<int>, int);\n+struct Foo(Box<isize>, isize);\n \n-struct Bar(int, int);\n+struct Bar(isize, isize);\n \n fn main() {\n-    let x = (box 1i, 2i);\n+    let x = (box 1is, 2is);\n     let r = &x.0;\n     let y = x; //~ ERROR cannot move out of `x` because it is borrowed\n \n-    let mut x = (1i, 2i);\n+    let mut x = (1is, 2is);\n     let a = &x.0;\n     let b = &mut x.0; //~ ERROR cannot borrow `x.0` as mutable because it is also borrowed as\n \n-    let mut x = (1i, 2i);\n+    let mut x = (1is, 2is);\n     let a = &mut x.0;\n     let b = &mut x.0; //~ ERROR cannot borrow `x.0` as mutable more than once at a time\n \n \n-    let x = Foo(box 1i, 2i);\n+    let x = Foo(box 1is, 2is);\n     let r = &x.0;\n     let y = x; //~ ERROR cannot move out of `x` because it is borrowed\n \n-    let mut x = Bar(1i, 2i);\n+    let mut x = Bar(1is, 2is);\n     let a = &x.0;\n     let b = &mut x.0; //~ ERROR cannot borrow `x.0` as mutable because it is also borrowed as\n \n-    let mut x = Bar(1i, 2i);\n+    let mut x = Bar(1is, 2is);\n     let a = &mut x.0;\n     let b = &mut x.0; //~ ERROR cannot borrow `x.0` as mutable more than once at a time\n }"}, {"sha": "92f16d8ffcedb8351c2835ead67828a7f602929b", "filename": "src/test/compile-fail/borrowck-and-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-and-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-and-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-and-init.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let i: int;\n+    let i: isize;\n \n     println!(\"{}\", false && { i = 5; true });\n     println!(\"{}\", i); //~ ERROR use of possibly uninitialized variable: `i`"}, {"sha": "5ee2b89dd9839d4e9d510dfb457a9312ea9d055f", "filename": "src/test/compile-fail/borrowck-anon-fields-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,7 +11,7 @@\n // Tests that we are able to distinguish when loans borrow different\n // anonymous fields of a tuple vs the same anonymous field.\n \n-struct Y(uint, uint);\n+struct Y(usize, usize);\n \n fn distinct_variant() {\n     let mut y = Y(1, 2);"}, {"sha": "88486756b66598dff4d8ce3f6dbdc33d66b6d675", "filename": "src/test/compile-fail/borrowck-anon-fields-tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@\n // anonymous fields of a tuple vs the same anonymous field.\n \n fn distinct_variant() {\n-    let mut y = (1i, 2i);\n+    let mut y = (1is, 2is);\n \n     let a = match y {\n         (ref mut a, _) => a\n@@ -27,7 +27,7 @@ fn distinct_variant() {\n }\n \n fn same_variant() {\n-    let mut y = (1i, 2i);\n+    let mut y = (1is, 2is);\n \n     let a = match y {\n         (ref mut a, _) => a"}, {"sha": "4e1b85283a6b1d3a0e72c0ae9d3c5c68291b9b57", "filename": "src/test/compile-fail/borrowck-anon-fields-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@\n // anonymous fields of an enum variant vs the same anonymous field.\n \n enum Foo {\n-    X, Y(uint, uint)\n+    X, Y(usize, usize)\n }\n \n fn distinct_variant() {"}, {"sha": "ac9ddc2ce6503d492ad3bbd4504e4fd8fd728ef7", "filename": "src/test/compile-fail/borrowck-array-double-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,9 +12,9 @@\n #![feature(box_syntax)]\n \n fn f() {\n-    let mut a = [box 0i, box 1i];\n+    let mut a = [box 0is, box 1is];\n     drop(a[0]);\n-    a[1] = box 2i;\n+    a[1] = box 2is;\n     drop(a[0]); //~ ERROR use of moved value: `a[..]`\n }\n "}, {"sha": "3a2c6f038510721794edb2b4a60884df0767cdd5", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,22 +9,22 @@\n // except according to those terms.\n \n struct Point {\n-    x: int,\n-    y: int,\n+    x: isize,\n+    y: isize,\n }\n \n fn a() {\n     let mut p = vec!(1);\n \n     // Create an immutable pointer into p's contents:\n-    let q: &int = &p[0];\n+    let q: &isize = &p[0];\n \n     p[0] = 5; //~ ERROR cannot borrow\n \n     println!(\"{}\", *q);\n }\n \n-fn borrow<F>(_x: &[int], _f: F) where F: FnOnce() {}\n+fn borrow<F>(_x: &[isize], _f: F) where F: FnOnce() {}\n \n fn b() {\n     // here we alias the mutable vector into an imm slice and try to"}, {"sha": "802b83119b7c31ce633d72363368b9990fae38b6", "filename": "src/test/compile-fail/borrowck-assign-comp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct point { x: int, y: int }\n+struct point { x: isize, y: isize }\n \n fn a() {\n     let mut p = point {x: 3, y: 4};\n     let q = &p;\n \n     // This assignment is illegal because the field x is not\n     // inherently mutable; since `p` was made immutable, `p.x` is now\n-    // immutable.  Otherwise the type of &_q.x (&int) would be wrong.\n+    // immutable.  Otherwise the type of &_q.x (&isize) would be wrong.\n     p.x = 5; //~ ERROR cannot assign to `p.x`\n     q.x;\n }"}, {"sha": "d66cdb99a74636b6d09f26a3d39d37bc65897b89", "filename": "src/test/compile-fail/borrowck-assign-to-andmut-in-aliasable-loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n struct S<'a> {\n-    pointer: &'a mut int\n+    pointer: &'a mut isize\n }\n \n fn a(s: &S) {"}, {"sha": "77aa57ef1b5ba6f8bf78ffe5e01aba097447a83c", "filename": "src/test/compile-fail/borrowck-assign-to-andmut-in-borrowed-loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,7 +12,7 @@\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n struct S<'a> {\n-    pointer: &'a mut int\n+    pointer: &'a mut isize\n }\n \n fn copy_borrowed_ptr<'a>(p: &'a mut S<'a>) -> S<'a> {"}, {"sha": "1b5b1899e0d9d34d0272c77172381b228f2c5cae", "filename": "src/test/compile-fail/borrowck-assign-to-constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-constants.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static foo: int = 5;\n+static foo: isize = 5;\n \n fn main() {\n     // assigning to various global constants"}, {"sha": "ea020dc0685218085da8d1e20fa4fea524245b11", "filename": "src/test/compile-fail/borrowck-auto-mut-ref-to-immut-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,7 +11,7 @@\n // Tests that auto-ref can't create mutable aliases to immutable memory.\n \n struct Foo {\n-    x: int\n+    x: isize\n }\n \n impl Foo {"}, {"sha": "d5f09305808f0bc3e54454cf0d8ca6f97e3bfb3e", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,10 +10,10 @@\n \n enum Either<T, U> { Left(T), Right(U) }\n \n-struct X(Either<(uint,uint), fn()>);\n+struct X(Either<(usize,usize), fn()>);\n \n impl X {\n-    pub fn with<F>(&self, blk: F) where F: FnOnce(&Either<(uint, uint), fn()>) {\n+    pub fn with<F>(&self, blk: F) where F: FnOnce(&Either<(usize, usize), fn()>) {\n         let X(ref e) = *self;\n         blk(e)\n     }"}, {"sha": "4d1939be5b9f7350eeeb6772b458d21badf7227d", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-free.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,12 +13,12 @@\n \n #![feature(box_syntax)]\n \n-fn rewrite(v: &mut Box<uint>) -> uint {\n+fn rewrite(v: &mut Box<usize>) -> usize {\n     *v = box 22;\n     **v\n }\n \n-fn add(v: &uint, w: uint) -> uint {\n+fn add(v: &usize, w: usize) -> usize {\n     *v + w\n }\n "}, {"sha": "9eda3689334c19f4176be63c228ea93157ac9e62", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,12 +13,12 @@\n \n #![feature(box_syntax)]\n \n-fn rewrite(v: &mut Box<uint>) -> uint {\n+fn rewrite(v: &mut Box<usize>) -> usize {\n     *v = box 22;\n     **v\n }\n \n-fn add(v: &uint, w: Box<uint>) -> uint {\n+fn add(v: &usize, w: Box<usize>) -> usize {\n     *v + *w\n }\n "}, {"sha": "a09ee439245434dfc57eca2f51de09ce7713a35a", "filename": "src/test/compile-fail/borrowck-block-unint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-block-unint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-block-unint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-block-unint.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n fn force<F>(f: F) where F: FnOnce() { f(); }\n fn main() {\n-    let x: int;\n+    let x: isize;\n     force(|| {  //~ ERROR capture of possibly uninitialized variable: `x`\n         println!(\"{}\", x);\n     });"}, {"sha": "397c55a502afd6df79bc38cd10f8efd9dac70046", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -17,8 +17,8 @@ struct Foo {\n impl Copy for Foo {}\n \n struct Bar {\n-  int1: int,\n-  int2: int,\n+  int1: isize,\n+  int2: isize,\n }\n \n impl Copy for Bar {}"}, {"sha": "ae4c09c59d720c2d3a004b981994d6786da59db5", "filename": "src/test/compile-fail/borrowck-borrow-from-stack-variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,8 +16,8 @@ struct Foo {\n impl Copy for Foo {}\n \n struct Bar {\n-  int1: int,\n-  int2: int,\n+  int1: isize,\n+  int2: isize,\n }\n \n impl Copy for Bar {}"}, {"sha": "fbb3824cd4060089081cc91475581b5229c84658", "filename": "src/test/compile-fail/borrowck-borrow-from-temporary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-temporary.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,9 +11,9 @@\n // Test lifetimes are linked properly when we take reference\n // to interior.\n \n-struct Foo(int);\n+struct Foo(isize);\n \n-fn foo<'a>() -> &'a int {\n+fn foo<'a>() -> &'a isize {\n     let &Foo(ref x) = &Foo(3); //~ ERROR borrowed value does not live long enough\n     x\n }"}, {"sha": "794e0fc6e3aba95ab10168acd24d51a96b0d0ffd", "filename": "src/test/compile-fail/borrowck-borrow-immut-deref-of-box-as-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-immut-deref-of-box-as-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-immut-deref-of-box-as-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-immut-deref-of-box-as-mut.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -20,5 +20,5 @@ impl A {\n pub fn main() {\n     let a = box A;\n     a.foo();\n-    //~^ ERROR cannot borrow immutable dereference of `Box` `*a` as mutable\n+    //~^ ERROR cannot borrow immutable `Box` content `*a` as mutable\n }"}, {"sha": "9126058a4e6f41cacf0ecc08f0d87948b9dc1de1", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,20 +13,20 @@\n //\n // Example from src/middle/borrowck/doc.rs\n \n-fn foo(t0: & &mut int) {\n+fn foo(t0: & &mut isize) {\n     let t1 = t0;\n-    let p: &int = &**t0;\n+    let p: &isize = &**t0;\n     **t1 = 22; //~ ERROR cannot assign\n }\n \n-fn foo3(t0: &mut &mut int) {\n+fn foo3(t0: &mut &mut isize) {\n     let t1 = &mut *t0;\n-    let p: &int = &**t0; //~ ERROR cannot borrow\n+    let p: &isize = &**t0; //~ ERROR cannot borrow\n     **t1 = 22;\n }\n \n-fn foo4(t0: & &mut int) {\n-    let x:  &mut int = &mut **t0; //~ ERROR cannot borrow\n+fn foo4(t0: & &mut isize) {\n+    let x:  &mut isize = &mut **t0; //~ ERROR cannot borrow\n     *x += 1;\n }\n "}, {"sha": "5db9ad2e3a4a9608bc93424a8bdc64a72e152bfb", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref-mut.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref-mut.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -32,25 +32,25 @@ impl<T> DerefMut for Own<T> {\n }\n \n struct Point {\n-    x: int,\n-    y: int\n+    x: isize,\n+    y: isize\n }\n \n impl Point {\n-    fn get(&self) -> (int, int) {\n+    fn get(&self) -> (isize, isize) {\n         (self.x, self.y)\n     }\n \n-    fn set(&mut self, x: int, y: int) {\n+    fn set(&mut self, x: isize, y: isize) {\n         self.x = x;\n         self.y = y;\n     }\n \n-    fn x_ref(&self) -> &int {\n+    fn x_ref(&self) -> &isize {\n         &self.x\n     }\n \n-    fn y_mut(&mut self) -> &mut int {\n+    fn y_mut(&mut self) -> &mut isize {\n         &mut self.y\n     }\n }\n@@ -67,15 +67,15 @@ fn deref_mut_field2(mut x: Own<Point>) {\n     let _i = &mut x.y;\n }\n \n-fn deref_extend_field(x: &Own<Point>) -> &int {\n+fn deref_extend_field(x: &Own<Point>) -> &isize {\n     &x.y\n }\n \n-fn deref_extend_mut_field1(x: &Own<Point>) -> &mut int {\n+fn deref_extend_mut_field1(x: &Own<Point>) -> &mut isize {\n     &mut x.y //~ ERROR cannot borrow\n }\n \n-fn deref_extend_mut_field2(x: &mut Own<Point>) -> &mut int {\n+fn deref_extend_mut_field2(x: &mut Own<Point>) -> &mut isize {\n     &mut x.y\n }\n \n@@ -126,15 +126,15 @@ fn deref_mut_method2(mut x: Own<Point>) {\n     x.set(0, 0);\n }\n \n-fn deref_extend_method(x: &Own<Point>) -> &int {\n+fn deref_extend_method(x: &Own<Point>) -> &isize {\n     x.x_ref()\n }\n \n-fn deref_extend_mut_method1(x: &Own<Point>) -> &mut int {\n+fn deref_extend_mut_method1(x: &Own<Point>) -> &mut isize {\n     x.y_mut() //~ ERROR cannot borrow\n }\n \n-fn deref_extend_mut_method2(x: &mut Own<Point>) -> &mut int {\n+fn deref_extend_mut_method2(x: &mut Own<Point>) -> &mut isize {\n     x.y_mut()\n }\n "}, {"sha": "75680de9c9effb5b433cdf51762a35207cb8999d", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -26,25 +26,25 @@ impl<T> Deref for Rc<T> {\n }\n \n struct Point {\n-    x: int,\n-    y: int\n+    x: isize,\n+    y: isize\n }\n \n impl Point {\n-    fn get(&self) -> (int, int) {\n+    fn get(&self) -> (isize, isize) {\n         (self.x, self.y)\n     }\n \n-    fn set(&mut self, x: int, y: int) {\n+    fn set(&mut self, x: isize, y: isize) {\n         self.x = x;\n         self.y = y;\n     }\n \n-    fn x_ref(&self) -> &int {\n+    fn x_ref(&self) -> &isize {\n         &self.x\n     }\n \n-    fn y_mut(&mut self) -> &mut int {\n+    fn y_mut(&mut self) -> &mut isize {\n         &mut self.y\n     }\n }\n@@ -61,15 +61,15 @@ fn deref_mut_field2(mut x: Rc<Point>) {\n     let _i = &mut x.y; //~ ERROR cannot borrow\n }\n \n-fn deref_extend_field(x: &Rc<Point>) -> &int {\n+fn deref_extend_field(x: &Rc<Point>) -> &isize {\n     &x.y\n }\n \n-fn deref_extend_mut_field1(x: &Rc<Point>) -> &mut int {\n+fn deref_extend_mut_field1(x: &Rc<Point>) -> &mut isize {\n     &mut x.y //~ ERROR cannot borrow\n }\n \n-fn deref_extend_mut_field2(x: &mut Rc<Point>) -> &mut int {\n+fn deref_extend_mut_field2(x: &mut Rc<Point>) -> &mut isize {\n     &mut x.y //~ ERROR cannot borrow\n }\n \n@@ -97,15 +97,15 @@ fn deref_mut_method2(mut x: Rc<Point>) {\n     x.set(0, 0); //~ ERROR cannot borrow\n }\n \n-fn deref_extend_method(x: &Rc<Point>) -> &int {\n+fn deref_extend_method(x: &Rc<Point>) -> &isize {\n     x.x_ref()\n }\n \n-fn deref_extend_mut_method1(x: &Rc<Point>) -> &mut int {\n+fn deref_extend_mut_method1(x: &Rc<Point>) -> &mut isize {\n     x.y_mut() //~ ERROR cannot borrow\n }\n \n-fn deref_extend_mut_method2(x: &mut Rc<Point>) -> &mut int {\n+fn deref_extend_mut_method2(x: &mut Rc<Point>) -> &mut isize {\n     x.y_mut() //~ ERROR cannot borrow\n }\n "}, {"sha": "bfe53b739f4a8811b9373d0f2713f9d8fa9593d7", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref-mut.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -31,39 +31,39 @@ impl<T> DerefMut for Own<T> {\n     }\n }\n \n-fn deref_imm(x: Own<int>) {\n+fn deref_imm(x: Own<isize>) {\n     let _i = &*x;\n }\n \n-fn deref_mut1(x: Own<int>) {\n+fn deref_mut1(x: Own<isize>) {\n     let _i = &mut *x; //~ ERROR cannot borrow\n }\n \n-fn deref_mut2(mut x: Own<int>) {\n+fn deref_mut2(mut x: Own<isize>) {\n     let _i = &mut *x;\n }\n \n-fn deref_extend<'a>(x: &'a Own<int>) -> &'a int {\n+fn deref_extend<'a>(x: &'a Own<isize>) -> &'a isize {\n     &**x\n }\n \n-fn deref_extend_mut1<'a>(x: &'a Own<int>) -> &'a mut int {\n+fn deref_extend_mut1<'a>(x: &'a Own<isize>) -> &'a mut isize {\n     &mut **x //~ ERROR cannot borrow\n }\n \n-fn deref_extend_mut2<'a>(x: &'a mut Own<int>) -> &'a mut int {\n+fn deref_extend_mut2<'a>(x: &'a mut Own<isize>) -> &'a mut isize {\n     &mut **x\n }\n \n-fn assign1<'a>(x: Own<int>) {\n+fn assign1<'a>(x: Own<isize>) {\n     *x = 3; //~ ERROR cannot borrow\n }\n \n-fn assign2<'a>(x: &'a Own<int>) {\n+fn assign2<'a>(x: &'a Own<isize>) {\n     **x = 3; //~ ERROR cannot borrow\n }\n \n-fn assign3<'a>(x: &'a mut Own<int>) {\n+fn assign3<'a>(x: &'a mut Own<isize>) {\n     **x = 3;\n }\n "}, {"sha": "153368f4894a45da50bafd2fe2daffc5c7ce679f", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -25,39 +25,39 @@ impl<T> Deref for Rc<T> {\n     }\n }\n \n-fn deref_imm(x: Rc<int>) {\n+fn deref_imm(x: Rc<isize>) {\n     let _i = &*x;\n }\n \n-fn deref_mut1(x: Rc<int>) {\n+fn deref_mut1(x: Rc<isize>) {\n     let _i = &mut *x; //~ ERROR cannot borrow\n }\n \n-fn deref_mut2(mut x: Rc<int>) {\n+fn deref_mut2(mut x: Rc<isize>) {\n     let _i = &mut *x; //~ ERROR cannot borrow\n }\n \n-fn deref_extend<'a>(x: &'a Rc<int>) -> &'a int {\n+fn deref_extend<'a>(x: &'a Rc<isize>) -> &'a isize {\n     &**x\n }\n \n-fn deref_extend_mut1<'a>(x: &'a Rc<int>) -> &'a mut int {\n+fn deref_extend_mut1<'a>(x: &'a Rc<isize>) -> &'a mut isize {\n     &mut **x //~ ERROR cannot borrow\n }\n \n-fn deref_extend_mut2<'a>(x: &'a mut Rc<int>) -> &'a mut int {\n+fn deref_extend_mut2<'a>(x: &'a mut Rc<isize>) -> &'a mut isize {\n     &mut **x //~ ERROR cannot borrow\n }\n \n-fn assign1<'a>(x: Rc<int>) {\n+fn assign1<'a>(x: Rc<isize>) {\n     *x = 3; //~ ERROR cannot assign\n }\n \n-fn assign2<'a>(x: &'a Rc<int>) {\n+fn assign2<'a>(x: &'a Rc<isize>) {\n     **x = 3; //~ ERROR cannot assign\n }\n \n-fn assign3<'a>(x: &'a mut Rc<int>) {\n+fn assign3<'a>(x: &'a mut Rc<isize>) {\n     **x = 3; //~ ERROR cannot assign\n }\n "}, {"sha": "98d1905ed9068155797f616b3f75a29db5ab128f", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,7 +16,7 @@ extern crate collections;\n use std::collections::HashMap;\n \n fn main() {\n-    let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n+    let mut buggy_map: HashMap<usize, &usize> = HashMap::new();\n     buggy_map.insert(42, &*box 1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary"}, {"sha": "648d0d81ffbc0ef28fd99d0da26338f68e6cb177", "filename": "src/test/compile-fail/borrowck-box-insensitivity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,23 +11,23 @@\n #![feature(box_syntax)]\n \n struct A {\n-    x: Box<int>,\n-    y: int,\n+    x: Box<isize>,\n+    y: isize,\n }\n \n struct B {\n-    x: Box<int>,\n-    y: Box<int>,\n+    x: Box<isize>,\n+    y: Box<isize>,\n }\n \n struct C {\n     x: Box<A>,\n-    y: int,\n+    y: isize,\n }\n \n struct D {\n     x: Box<A>,\n-    y: Box<int>,\n+    y: Box<isize>,\n }\n \n fn copy_after_move() {"}, {"sha": "a52eaeeb9c3e303d89566aca0a5f2c4c13fe6f76", "filename": "src/test/compile-fail/borrowck-break-uninit-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-break-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-break-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-break-uninit-2.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo() -> int {\n-    let x: int;\n+fn foo() -> isize {\n+    let x: isize;\n \n-    while 1i != 2  {\n+    while 1is != 2  {\n         break;\n         x = 0;\n     }\n \n     println!(\"{}\", x); //~ ERROR use of possibly uninitialized variable: `x`\n \n-    return 17i;\n+    return 17is;\n }\n \n fn main() { println!(\"{}\", foo()); }"}, {"sha": "8a6a036945b78e60994964d9cde1d1c53cf65b3d", "filename": "src/test/compile-fail/borrowck-break-uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-break-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-break-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-break-uninit.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo() -> int {\n-    let x: int;\n+fn foo() -> isize {\n+    let x: isize;\n \n     loop {\n         break;"}, {"sha": "010ddb792ccc6f18fc954cdc737c339a52590b64", "filename": "src/test/compile-fail/borrowck-call-is-borrow-issue-12224.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -33,15 +33,15 @@ fn test1() {\n }\n \n fn test2<F>(f: &F) where F: FnMut() {\n-    (*f)(); //~ ERROR: cannot borrow immutable dereference of `&`-pointer `*f` as mutable\n+    (*f)(); //~ ERROR: cannot borrow immutable borrowed content `*f` as mutable\n }\n \n fn test3<F>(f: &mut F) where F: FnMut() {\n     (*f)();\n }\n \n fn test4(f: &Test) {\n-    f.f.call_mut(()) //~ ERROR: cannot borrow immutable dereference of `Box` `*f.f` as mutable\n+    f.f.call_mut(()) //~ ERROR: cannot borrow immutable `Box` content `*f.f` as mutable\n }\n \n fn test5(f: &mut Test) {\n@@ -56,8 +56,8 @@ fn test6() {\n }\n \n fn test7() {\n-    fn foo<F>(_: F) where F: FnMut(Box<FnMut(int)>, int) {}\n-    let mut f = |&mut: g: Box<FnMut(int)>, b: int| {};\n+    fn foo<F>(_: F) where F: FnMut(Box<FnMut(isize)>, isize) {}\n+    let mut f = |&mut: g: Box<FnMut(isize)>, b: isize| {};\n     f(box |a| { //~ ERROR: cannot borrow `f` as immutable because it is also borrowed as mutable\n         foo(f); //~ ERROR: cannot move out of captured outer variable\n     }, 3);"}, {"sha": "bc0b667e895d003928fa38c2693ec266f606d606", "filename": "src/test/compile-fail/borrowck-call-method-from-mut-aliasable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-method-from-mut-aliasable.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo {\n-    x: int,\n+    x: isize,\n }\n \n impl Foo {"}, {"sha": "29c7d6920bd95c6426d86f28b2201a104c66d4ca", "filename": "src/test/compile-fail/borrowck-closures-mut-and-imm.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,53 +13,53 @@\n \n #![feature(box_syntax)]\n \n-fn get(x: &int) -> int {\n+fn get(x: &isize) -> isize {\n     *x\n }\n \n-fn set(x: &mut int) {\n+fn set(x: &mut isize) {\n     *x = 4;\n }\n \n fn a() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| x = 4;\n     let c2 = |&mut:| x * 5; //~ ERROR cannot borrow `x`\n }\n \n fn b() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| set(&mut x);\n     let c2 = |&mut:| get(&x); //~ ERROR cannot borrow `x`\n }\n \n fn c() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| set(&mut x);\n     let c2 = |&mut:| x * 5; //~ ERROR cannot borrow `x`\n }\n \n fn d() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c2 = |&mut:| x * 5;\n     x = 5; //~ ERROR cannot assign\n }\n \n fn e() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| get(&x);\n     x = 5; //~ ERROR cannot assign\n }\n \n fn f() {\n-    let mut x = box 3i;\n+    let mut x = box 3is;\n     let c1 = |&mut:| get(&*x);\n     *x = 5; //~ ERROR cannot assign\n }\n \n fn g() {\n     struct Foo {\n-        f: Box<int>\n+        f: Box<isize>\n     }\n \n     let mut x = box Foo { f: box 3 };\n@@ -69,7 +69,7 @@ fn g() {\n \n fn h() {\n     struct Foo {\n-        f: Box<int>\n+        f: Box<isize>\n     }\n \n     let mut x = box Foo { f: box 3 };"}, {"sha": "8260774190967b417962d319ce0ce46cc0bfd1a4", "filename": "src/test/compile-fail/borrowck-closures-mut-of-imm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,15 +11,15 @@\n // Tests that two closures cannot simultaneously have mutable\n // and immutable access to the variable. Issue #6801.\n \n-fn get(x: &int) -> int {\n+fn get(x: &isize) -> isize {\n     *x\n }\n \n-fn set(x: &mut int) {\n+fn set(x: &mut isize) {\n     *x = 4;\n }\n \n-fn a(x: &int) {\n+fn a(x: &isize) {\n     let c1 = |&mut:| set(&mut *x);\n     //~^ ERROR cannot borrow\n     let c2 = |&mut:| set(&mut *x);"}, {"sha": "5cb49ab77114bda503a5126d16635e26b7359f09", "filename": "src/test/compile-fail/borrowck-closures-two-mut.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,37 +15,37 @@\n #![feature(box_syntax)]\n \n fn a() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| x = 4;\n     let c2 = |&mut:| x = 5; //~ ERROR cannot borrow `x` as mutable more than once\n }\n \n-fn set(x: &mut int) {\n+fn set(x: &mut isize) {\n     *x = 4;\n }\n \n fn b() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| set(&mut x);\n     let c2 = |&mut:| set(&mut x); //~ ERROR cannot borrow `x` as mutable more than once\n }\n \n fn c() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| x = 5;\n     let c2 = |&mut:| set(&mut x); //~ ERROR cannot borrow `x` as mutable more than once\n }\n \n fn d() {\n-    let mut x = 3i;\n+    let mut x = 3is;\n     let c1 = |&mut:| x = 5;\n     let c2 = |&mut:| { let _y = |&mut:| set(&mut x); }; // (nested closure)\n     //~^ ERROR cannot borrow `x` as mutable more than once\n }\n \n fn g() {\n     struct Foo {\n-        f: Box<int>\n+        f: Box<isize>\n     }\n \n     let mut x = box Foo { f: box 3 };"}, {"sha": "cf86602af0be22106ddb8ff056b512b37c81098d", "filename": "src/test/compile-fail/borrowck-closures-unique-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique-imm.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo {\n-    x: int,\n+    x: isize,\n }\n \n pub fn main() {"}, {"sha": "f9a6d5ac84575617db471360a6fead5f28f34f4f", "filename": "src/test/compile-fail/borrowck-closures-unique.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -14,35 +14,35 @@\n //  may be *immutable*, but we cannot allow\n // multiple borrows.\n \n-fn get(x: &int) -> int {\n+fn get(x: &isize) -> isize {\n     *x\n }\n \n-fn set(x: &mut int) -> int {\n+fn set(x: &mut isize) -> isize {\n     *x\n }\n \n-fn a(x: &mut int) {\n+fn a(x: &mut isize) {\n     let c1 = |&mut:| get(x);\n     let c2 = |&mut:| get(x);\n }\n \n-fn b(x: &mut int) {\n+fn b(x: &mut isize) {\n     let c1 = |&mut:| get(x);\n     let c2 = |&mut:| set(x); //~ ERROR closure requires unique access to `x`\n }\n \n-fn c(x: &mut int) {\n+fn c(x: &mut isize) {\n     let c1 = |&mut:| get(x);\n     let c2 = |&mut:| { get(x); set(x); }; //~ ERROR closure requires unique access to `x`\n }\n \n-fn d(x: &mut int) {\n+fn d(x: &mut isize) {\n     let c1 = |&mut:| set(x);\n     let c2 = |&mut:| set(x); //~ ERROR closure requires unique access to `x`\n }\n \n-fn e(x: &mut int) {\n+fn e(x: &mut isize) {\n     let c1 = |&mut:| x = panic!(); //~ ERROR closure cannot assign to immutable local variable\n }\n "}, {"sha": "b6529da18838b96c5f38694f699885b195eb1f11", "filename": "src/test/compile-fail/borrowck-closures-use-after-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -15,7 +15,7 @@\n #![feature(box_syntax)]\n \n struct Foo {\n-  x: int\n+  x: isize\n }\n \n impl Drop for Foo {"}, {"sha": "fe5142a77341fe6152c7caea3666f12620f2da1c", "filename": "src/test/compile-fail/borrowck-field-sensitivity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-struct A { a: int, b: Box<int> }\n+struct A { a: isize, b: Box<isize> }\n \n fn deref_after_move() {\n     let x = A { a: 1, b: box 2 };"}, {"sha": "6884ac153a16ba83c6a584ce0f8d7898ef5f03de", "filename": "src/test/compile-fail/borrowck-for-loop-correct-cmt-for-pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,11 +13,11 @@\n #![feature(box_syntax)]\n \n struct Foo {\n-    a: [Box<int>; 3],\n+    a: [Box<isize>; 3],\n }\n \n fn main() {\n-    let mut y = 1i;\n+    let mut y = 1is;\n     let x = Some(&mut y);\n     for &a in x.iter() {    //~ ERROR cannot move out\n     }\n@@ -28,7 +28,7 @@ fn main() {\n     for &a in f.a.iter() {  //~ ERROR cannot move out\n     }\n \n-    let x = Some(box 1i);\n+    let x = Some(box 1is);\n     for &a in x.iter() {    //~ ERROR cannot move out\n     }\n }"}, {"sha": "d2f99ea696af2bddc9502e36bb3a0491ceac4bc7", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,11 +11,11 @@\n use std::iter::repeat;\n \n fn main() {\n-    let mut vector = vec![1u, 2];\n+    let mut vector = vec![1us, 2];\n     for &x in vector.iter() {\n         let cap = vector.capacity();\n         vector.extend(repeat(0));      //~ ERROR cannot borrow\n-        vector[1u] = 5u;   //~ ERROR cannot borrow\n+        vector[1us] = 5us;   //~ ERROR cannot borrow\n     }\n }\n "}, {"sha": "b98833776fbaf80166847e848664aff5b9e438da", "filename": "src/test/compile-fail/borrowck-if-no-else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-if-no-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-if-no-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-if-no-else.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x: int) { println!(\"{}\", x); }\n+fn foo(x: isize) { println!(\"{}\", x); }\n \n fn main() {\n-    let x: int; if 1i > 2 { x = 10; }\n+    let x: isize; if 1is > 2 { x = 10; }\n     foo(x); //~ ERROR use of possibly uninitialized variable: `x`\n }"}, {"sha": "c74edfd8d070c21411f343f8dd7b253fd29a06f4", "filename": "src/test/compile-fail/borrowck-if-with-else.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-if-with-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-if-with-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-if-with-else.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(x: int) { println!(\"{}\", x); }\n+fn foo(x: isize) { println!(\"{}\", x); }\n \n fn main() {\n-    let x: int;\n-    if 1i > 2 {\n+    let x: isize;\n+    if 1is > 2 {\n         println!(\"whoops\");\n     } else {\n         x = 10;"}, {"sha": "fabfce6ffb3886ac059a2bfb4839bb4e308e6a7e", "filename": "src/test/compile-fail/borrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let mut _a = 3i;\n+    let mut _a = 3is;\n     let _b = &mut _a;\n     {\n         let _c = &*_b;"}, {"sha": "3c20abab8bdeffac38047bab550ff1647a130cc5", "filename": "src/test/compile-fail/borrowck-init-in-called-fn-expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-called-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-called-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-called-fn-expr.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    let j = |&:| -> int {\n-        let i: int;\n+    let j = |&:| -> isize {\n+        let i: isize;\n         i //~ ERROR use of possibly uninitialized variable: `i`\n     };\n     j();"}, {"sha": "31ca39c3f9b36772a15acd3d81c7908625c55c66", "filename": "src/test/compile-fail/borrowck-init-in-fn-expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fn-expr.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    let f  = |&:| -> int {\n-        let i: int;\n+    let f  = |&:| -> isize {\n+        let i: isize;\n         i //~ ERROR use of possibly uninitialized variable: `i`\n     };\n     println!(\"{}\", f());"}, {"sha": "569ddb80c2fe20dc47dec55c7263e884d5423477", "filename": "src/test/compile-fail/borrowck-init-in-fru.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-in-fru.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,8 +10,8 @@\n \n #[derive(Clone)]\n struct point {\n-    x: int,\n-    y: int,\n+    x: isize,\n+    y: isize,\n }\n \n fn main() {"}, {"sha": "e0d93fd1d475bc4622a9185cf1ef76d843cdab63", "filename": "src/test/compile-fail/borrowck-init-op-equal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-op-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-op-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-op-equal.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n \n fn test() {\n-    let v: int;\n+    let v: isize;\n     v += 1; //~ ERROR use of possibly uninitialized variable: `v`\n     v.clone();\n }"}, {"sha": "a036286f3634a0ca8470638a0ea68e47bd514141", "filename": "src/test/compile-fail/borrowck-init-plus-equal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-plus-equal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-init-plus-equal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-init-plus-equal.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn test() {\n-    let mut v: int;\n+    let mut v: isize;\n     v = v + 1; //~ ERROR use of possibly uninitialized variable: `v`\n     v.clone();\n }"}, {"sha": "d729af844cb39dd0d465e6577146fc1f768ede7d", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,11 +12,11 @@ extern crate collections;\n use std::collections::HashSet;\n \n struct Foo {\n-  n: HashSet<int>,\n+  n: HashSet<isize>,\n }\n \n impl Foo {\n-    pub fn foo<F>(&mut self, mut fun: F) where F: FnMut(&int) {\n+    pub fn foo<F>(&mut self, mut fun: F) where F: FnMut(&isize) {\n         for f in self.n.iter() {\n             fun(f);\n         }"}, {"sha": "cc562afa9f818ecbe89946d1c0d64378020f1a69", "filename": "src/test/compile-fail/borrowck-issue-14498.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -13,11 +13,11 @@\n \n #![feature(box_syntax)]\n \n-struct A { a: int }\n-struct B<'a> { a: Box<&'a mut int> }\n+struct A { a: isize }\n+struct B<'a> { a: Box<&'a mut isize> }\n \n fn borrow_in_var_from_var() {\n-    let mut x: int = 1;\n+    let mut x: isize = 1;\n     let y = box &mut x;\n     let p = &y;\n     let q = &***p;\n@@ -37,7 +37,7 @@ fn borrow_in_var_from_field() {\n }\n \n fn borrow_in_field_from_var() {\n-    let mut x: int = 1;\n+    let mut x: isize = 1;\n     let y = B { a: box &mut x };\n     let p = &y.a;\n     let q = &***p;"}, {"sha": "dc1c73efc409ebcb9c1d301bccddc0bbebed3715", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n \n fn main() {\n-    let x = Some(box 1i);\n+    let x = Some(box 1is);\n     match x {\n       Some(ref _y) => {\n         let _a = x; //~ ERROR cannot move"}, {"sha": "0b76044f8d61bc875d464ddd44e67c8ad4b2dd03", "filename": "src/test/compile-fail/borrowck-issue-2657-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-2.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n \n fn main() {\n-    let x = Some(box 1i);\n+    let x = Some(box 1is);\n     match x {\n       Some(ref y) => {\n         let _b = *y; //~ ERROR cannot move out"}, {"sha": "ca8efb5dc967d7f5286982ec741c73a7b20e62c3", "filename": "src/test/compile-fail/borrowck-lend-flow-if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,13 +16,13 @@\n \n #![feature(box_syntax)]\n \n-fn borrow(_v: &int) {}\n-fn borrow_mut(_v: &mut int) {}\n+fn borrow(_v: &isize) {}\n+fn borrow_mut(_v: &mut isize) {}\n fn cond() -> bool { panic!() }\n fn for_func<F>(_f: F) where F: FnOnce() -> bool { panic!() }\n fn produce<T>() -> T { panic!(); }\n \n-fn inc(v: &mut Box<int>) {\n+fn inc(v: &mut Box<isize>) {\n     *v = box() (**v + 1);\n }\n "}, {"sha": "491a0d40bec427a2088104768023c663c5c95fa1", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,12 +16,12 @@\n \n #![feature(box_syntax)]\n \n-fn borrow(_v: &int) {}\n-fn borrow_mut(_v: &mut int) {}\n+fn borrow(_v: &isize) {}\n+fn borrow_mut(_v: &mut isize) {}\n fn cond() -> bool { panic!() }\n fn produce<T>() -> T { panic!(); }\n \n-fn inc(v: &mut Box<int>) {\n+fn inc(v: &mut Box<isize>) {\n     *v = box() (**v + 1);\n }\n \n@@ -41,7 +41,7 @@ fn block_overarching_alias_mut() {\n \n     let mut v = box 3;\n     let mut x = &mut v;\n-    for _ in range(0i, 3) {\n+    for _ in range(0is, 3) {\n         borrow(&*v); //~ ERROR cannot borrow\n     }\n     *x = box 5;\n@@ -113,8 +113,8 @@ fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n     }\n }\n \n-fn loop_break_pops_scopes<'r, F>(_v: &'r mut [uint], mut f: F) where\n-    F: FnMut(&'r mut uint) -> bool,\n+fn loop_break_pops_scopes<'r, F>(_v: &'r mut [usize], mut f: F) where\n+    F: FnMut(&'r mut usize) -> bool,\n {\n     // Here we check that when you break out of an inner loop, the\n     // borrows that go out of scope as you exit the inner loop are\n@@ -123,21 +123,23 @@ fn loop_break_pops_scopes<'r, F>(_v: &'r mut [uint], mut f: F) where\n     while cond() {\n         while cond() {\n             // this borrow is limited to the scope of `r`...\n-            let r: &'r mut uint = produce();\n+            let r: &'r mut usize = produce();\n             if !f(&mut *r) {\n                 break; // ...so it is not live as exit the `while` loop here\n             }\n         }\n     }\n }\n \n-fn loop_loop_pops_scopes<'r, F>(_v: &'r mut [uint], mut f: F) where F: FnMut(&'r mut uint) -> bool {\n+fn loop_loop_pops_scopes<'r, F>(_v: &'r mut [usize], mut f: F)\n+    where F: FnMut(&'r mut usize) -> bool\n+{\n     // Similar to `loop_break_pops_scopes` but for the `loop` keyword\n \n     while cond() {\n         while cond() {\n             // this borrow is limited to the scope of `r`...\n-            let r: &'r mut uint = produce();\n+            let r: &'r mut usize = produce();\n             if !f(&mut *r) {\n                 continue; // ...so it is not live as exit (and re-enter) the `while` loop here\n             }"}, {"sha": "f501682847f5fc7c3c8e9fc29acd2bea49f0d9ff", "filename": "src/test/compile-fail/borrowck-lend-flow-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-match.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -19,10 +19,10 @@ fn separate_arms() {\n         None => {\n             // It is ok to reassign x here, because there is in\n             // fact no outstanding loan of x!\n-            x = Some(0i);\n+            x = Some(0is);\n         }\n         Some(ref _i) => {\n-            x = Some(1i); //~ ERROR cannot assign\n+            x = Some(1is); //~ ERROR cannot assign\n         }\n     }\n     x.clone(); // just to prevent liveness warnings"}, {"sha": "177976c15f0f46831762f717273b6f699c3227fd", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -16,13 +16,13 @@\n \n #![feature(box_syntax)]\n \n-fn borrow(_v: &int) {}\n-fn borrow_mut(_v: &mut int) {}\n+fn borrow(_v: &isize) {}\n+fn borrow_mut(_v: &mut isize) {}\n fn cond() -> bool { panic!() }\n fn for_func<F>(_f: F) where F: FnOnce() -> bool { panic!() }\n fn produce<T>() -> T { panic!(); }\n \n-fn inc(v: &mut Box<int>) {\n+fn inc(v: &mut Box<isize>) {\n     *v = box() (**v + 1);\n }\n "}, {"sha": "5f5ff4014e109cfcbbd84e7f7f2edfdb9b79afa9", "filename": "src/test/compile-fail/borrowck-let-suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn f() {\n-    let x = [1i].iter(); //~ ERROR borrowed value does not live long enough\n+    let x = [1is].iter(); //~ ERROR borrowed value does not live long enough\n                          //~^^ NOTE reference must be valid for the block\n                          //~^^ HELP consider using a `let` binding to increase its lifetime\n }"}, {"sha": "bff22257760ebb8989f948a87d7c6bfa04e94830", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -12,12 +12,12 @@\n \n use std::thread::Thread;\n \n-fn borrow<F>(v: &int, f: F) where F: FnOnce(&int) {\n+fn borrow<F>(v: &isize, f: F) where F: FnOnce(&isize) {\n     f(v);\n }\n \n fn box_imm() {\n-    let v = box 3i;\n+    let v = box 3is;\n     let _w = &v;\n     Thread::spawn(move|| {\n         println!(\"v={}\", *v);\n@@ -26,7 +26,7 @@ fn box_imm() {\n }\n \n fn box_imm_explicit() {\n-    let v = box 3i;\n+    let v = box 3is;\n     let _w = &v;\n     Thread::spawn(move|| {\n         println!(\"v={}\", *v);"}, {"sha": "f3f18807314f9638a77502d488bb48d0702e6f40", "filename": "src/test/compile-fail/borrowck-loan-blocks-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-fn take(_v: Box<int>) {\n+fn take(_v: Box<isize>) {\n }\n \n fn box_imm() {"}, {"sha": "a52a4484b20d123440a7c602d20c1c8d9ed6eee9", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b112c45a604fa6f4b59af2a40c9deeadfdb7c6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=00b112c45a604fa6f4b59af2a40c9deeadfdb7c6", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-fn borrow<F>(v: &int, f: F) where F: FnOnce(&int) {\n+fn borrow<F>(v: &isize, f: F) where F: FnOnce(&isize) {\n     f(v);\n }\n "}]}