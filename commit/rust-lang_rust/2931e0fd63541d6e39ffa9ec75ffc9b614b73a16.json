{"sha": "2931e0fd63541d6e39ffa9ec75ffc9b614b73a16", "node_id": "C_kwDOAAsO6NoAKDI5MzFlMGZkNjM1NDFkNmUzOWZmYTllYzc1ZmZjOWI2MTRiNzNhMTY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-04T03:18:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-05T12:34:41Z"}, "message": "handle Box with allocators", "tree": {"sha": "aed41e50e0220fee223f9ef69738f6ce23052926", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed41e50e0220fee223f9ef69738f6ce23052926"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16", "html_url": "https://github.com/rust-lang/rust/commit/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "178e7f3f332bac8be6bc9c33ad1f811ddc5c4e39", "url": "https://api.github.com/repos/rust-lang/rust/commits/178e7f3f332bac8be6bc9c33ad1f811ddc5c4e39", "html_url": "https://github.com/rust-lang/rust/commit/178e7f3f332bac8be6bc9c33ad1f811ddc5c4e39"}], "stats": {"total": 119, "additions": 110, "deletions": 9}, "files": [{"sha": "9969fbdbcd3433171c58a51d4b5c5ccef5d16dbd", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=2931e0fd63541d6e39ffa9ec75ffc9b614b73a16", "patch": "@@ -976,27 +976,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Raw pointers need to be enabled.\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == Mutability::Mut }, false)),\n-                // Boxes do not get a protector: protectors reflect that references outlive the call\n-                // they were passed in to; that's just not the case for boxes.\n-                ty::Adt(..) if ty.is_box() => Some((RefKind::Unique { two_phase: false }, false)),\n+                // Boxes are handled separately due to that allocator situation.\n                 _ => None,\n             }\n         }\n \n         // We need a visitor to visit all references. However, that requires\n-        // a `MPlaceTy` (or `OpTy), so we have a fast path for reference types that\n+        // a `MPlaceTy` (or `OpTy`), so we have a fast path for reference types that\n         // avoids allocating.\n \n-        if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n+        if let Some((ref_kind, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(&this.place_to_op(place)?)?;\n-            let val = this.retag_reference(&val, mutbl, protector)?;\n+            let val = this.retag_reference(&val, ref_kind, protector)?;\n             this.write_immediate(*val, place)?;\n             return Ok(());\n         }\n \n         // If we don't want to recurse, we are already done.\n-        if !this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields {\n+        // EXCEPT if this is a `Box`, then we have to recurse because allocators.\n+        // (Yes this means we technically also recursively retag the allocator itself even if field\n+        // retagging is not enabled. *shrug*)\n+        if !this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields\n+            && !place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box())\n+        {\n             return Ok(());\n         }\n \n@@ -1034,10 +1037,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 self.ecx\n             }\n \n+            fn visit_box(&mut self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+                // Boxes do not get a protector: protectors reflect that references outlive the call\n+                // they were passed in to; that's just not the case for boxes.\n+                let (ref_kind, protector) = (RefKind::Unique { two_phase: false }, false);\n+\n+                let val = self.ecx.read_immediate(&place.into())?;\n+                let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n+                self.ecx.write_immediate(*val, &place.into())?;\n+                Ok(())\n+            }\n+\n             fn visit_value(&mut self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n-                if let Some((mutbl, protector)) = qualify(place.layout.ty, self.kind) {\n+                if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n                     let val = self.ecx.read_immediate(&place.into())?;\n-                    let val = self.ecx.retag_reference(&val, mutbl, protector)?;\n+                    let val = self.ecx.retag_reference(&val, ref_kind, protector)?;\n                     self.ecx.write_immediate(*val, &place.into())?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {\n                     // Wide raw pointers *do* have fields and their types are strange."}, {"sha": "ef432a86d460a86fc7f62d3ddd1d99b6903f13bf", "filename": "tests/pass/box-custom-alloc.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16/tests%2Fpass%2Fbox-custom-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2931e0fd63541d6e39ffa9ec75ffc9b614b73a16/tests%2Fpass%2Fbox-custom-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fbox-custom-alloc.rs?ref=2931e0fd63541d6e39ffa9ec75ffc9b614b73a16", "patch": "@@ -0,0 +1,87 @@\n+#![allow(incomplete_features)] // for trait upcasting\n+#![feature(allocator_api, trait_upcasting)]\n+\n+use std::alloc::Layout;\n+use std::alloc::{AllocError, Allocator};\n+use std::cell::Cell;\n+use std::mem::MaybeUninit;\n+use std::ptr::{self, NonNull};\n+\n+struct OnceAlloc<'a> {\n+    space: Cell<&'a mut [MaybeUninit<u8>]>,\n+}\n+\n+unsafe impl<'shared, 'a: 'shared> Allocator for &'shared OnceAlloc<'a> {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        let space = self.space.replace(&mut []);\n+\n+        let (ptr, len) = (space.as_mut_ptr(), space.len());\n+\n+        if ptr.align_offset(layout.align()) != 0 || len < layout.size() {\n+            return Err(AllocError);\n+        }\n+\n+        let slice_ptr = ptr::slice_from_raw_parts_mut(ptr as *mut u8, len);\n+        unsafe { Ok(NonNull::new_unchecked(slice_ptr)) }\n+    }\n+\n+    unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {}\n+}\n+\n+trait MyTrait {\n+    fn hello(&self) -> u8;\n+}\n+\n+impl MyTrait for [u8; 1] {\n+    fn hello(&self) -> u8 {\n+        self[0]\n+    }\n+}\n+\n+trait TheTrait: MyTrait {}\n+\n+impl TheTrait for [u8; 1] {}\n+\n+/// `Box<T, G>` is a `ScalarPair` where the 2nd component is the allocator.\n+fn test1() {\n+    let mut space = vec![MaybeUninit::new(0); 1];\n+    let once_alloc = OnceAlloc { space: Cell::new(&mut space[..]) };\n+\n+    let boxed = Box::new_in([42u8; 1], &once_alloc);\n+    let _val = *boxed;\n+    let with_dyn: Box<dyn TheTrait, &OnceAlloc> = boxed;\n+    assert_eq!(42, with_dyn.hello());\n+    let with_dyn: Box<dyn MyTrait, &OnceAlloc> = with_dyn; // upcast\n+    assert_eq!(42, with_dyn.hello());\n+}\n+\n+// Make the allocator itself so big that the Box is not even a ScalarPair any more.\n+struct OnceAllocRef<'s, 'a>(&'s OnceAlloc<'a>, u64);\n+\n+unsafe impl<'shared, 'a: 'shared> Allocator for OnceAllocRef<'shared, 'a> {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        self.0.allocate(layout)\n+    }\n+\n+    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {\n+        self.0.deallocate(ptr, layout)\n+    }\n+}\n+\n+/// `Box<T, G>` is an `Aggregate`.\n+fn test2() {\n+    let mut space = vec![MaybeUninit::new(0); 1];\n+    let once_alloc = OnceAlloc { space: Cell::new(&mut space[..]) };\n+\n+    let boxed = Box::new_in([42u8; 1], OnceAllocRef(&once_alloc, 0));\n+    let _val = *boxed;\n+    let with_dyn: Box<dyn TheTrait, OnceAllocRef> = boxed;\n+    assert_eq!(42, with_dyn.hello());\n+    let with_dyn: Box<dyn MyTrait, OnceAllocRef> = with_dyn; // upcast\n+    assert_eq!(42, with_dyn.hello());\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+}"}]}