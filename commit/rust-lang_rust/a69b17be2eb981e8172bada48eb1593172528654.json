{"sha": "a69b17be2eb981e8172bada48eb1593172528654", "node_id": "C_kwDOAAsO6NoAKGE2OWIxN2JlMmViOTgxZTgxNzJiYWRhNDhlYjE1OTMxNzI1Mjg2NTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T13:19:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T13:19:45Z"}, "message": "Auto merge of #12562 - Veykril:completion, r=Veykril\n\nSplit completion context module into definitions and analysis parts", "tree": {"sha": "ee63d29e22b44f4d0a525a050c6859ae1278771b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee63d29e22b44f4d0a525a050c6859ae1278771b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a69b17be2eb981e8172bada48eb1593172528654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a69b17be2eb981e8172bada48eb1593172528654", "html_url": "https://github.com/rust-lang/rust/commit/a69b17be2eb981e8172bada48eb1593172528654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a69b17be2eb981e8172bada48eb1593172528654/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6269137760988863cb7438c2bb4e5cf69a263e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6269137760988863cb7438c2bb4e5cf69a263e9d", "html_url": "https://github.com/rust-lang/rust/commit/6269137760988863cb7438c2bb4e5cf69a263e9d"}, {"sha": "f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "url": "https://api.github.com/repos/rust-lang/rust/commits/f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "html_url": "https://github.com/rust-lang/rust/commit/f35a9a1dccc9a7a86820cbb688cebaba23f2da85"}], "stats": {"total": 3027, "additions": 1513, "deletions": 1514}, "files": [{"sha": "d5f754d66581cd0cd2cc34f1193500a1f973c48f", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 7, "deletions": 1420, "changes": 1427, "blob_url": "https://github.com/rust-lang/rust/blob/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=a69b17be2eb981e8172bada48eb1593172528654", "patch": "@@ -1,30 +1,27 @@\n //! See `CompletionContext` structure.\n \n-use std::iter;\n+mod analysis;\n+#[cfg(test)]\n+mod tests;\n \n use base_db::SourceDatabaseExt;\n use hir::{\n     HasAttrs, Local, Name, PathResolution, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo,\n };\n use ide_db::{\n-    active_parameter::ActiveParameter,\n     base_db::{FilePosition, SourceDatabase},\n     famous_defs::FamousDefs,\n     FxHashMap, FxHashSet, RootDatabase,\n };\n use syntax::{\n-    algo::{find_node_at_offset, non_trivia_sibling},\n-    ast::{self, AttrKind, HasArgList, HasName, NameOrNameRef},\n-    match_ast, AstNode, AstToken, Direction, NodeOrToken,\n+    ast::{self, AttrKind, NameOrNameRef},\n+    AstNode,\n     SyntaxKind::{self, *},\n-    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n+    SyntaxToken, TextRange, TextSize,\n };\n use text_edit::Indel;\n \n-use crate::{\n-    patterns::{is_in_loop_body, is_in_token_of_for_loop, previous_token},\n-    CompletionConfig,\n-};\n+use crate::CompletionConfig;\n \n const COMPLETION_MARKER: &str = \"intellijRulezz\";\n \n@@ -558,1019 +555,6 @@ impl<'a> CompletionContext<'a> {\n         )?;\n         Some(ctx)\n     }\n-\n-    /// Expand attributes and macro calls at the current cursor position for both the original file\n-    /// and fake file repeatedly. As soon as one of the two expansions fail we stop so the original\n-    /// and speculative states stay in sync.\n-    fn expand_and_fill(\n-        &mut self,\n-        mut original_file: SyntaxNode,\n-        mut speculative_file: SyntaxNode,\n-        mut offset: TextSize,\n-        mut fake_ident_token: SyntaxToken,\n-    ) -> Option<()> {\n-        let _p = profile::span(\"CompletionContext::expand_and_fill\");\n-        let mut derive_ctx = None;\n-\n-        'expansion: loop {\n-            let parent_item =\n-                |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n-            let ancestor_items = iter::successors(\n-                Option::zip(\n-                    find_node_at_offset::<ast::Item>(&original_file, offset),\n-                    find_node_at_offset::<ast::Item>(&speculative_file, offset),\n-                ),\n-                |(a, b)| parent_item(a).zip(parent_item(b)),\n-            );\n-\n-            // first try to expand attributes as these are always the outermost macro calls\n-            'ancestors: for (actual_item, item_with_fake_ident) in ancestor_items {\n-                match (\n-                    self.sema.expand_attr_macro(&actual_item),\n-                    self.sema.speculative_expand_attr_macro(\n-                        &actual_item,\n-                        &item_with_fake_ident,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    // maybe parent items have attributes, so continue walking the ancestors\n-                    (None, None) => continue 'ancestors,\n-                    // successful expansions\n-                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n-                        let new_offset = fake_mapped_token.text_range().start();\n-                        if new_offset > actual_expansion.text_range().end() {\n-                            // offset outside of bounds from the original expansion,\n-                            // stop here to prevent problems from happening\n-                            break 'expansion;\n-                        }\n-                        original_file = actual_expansion;\n-                        speculative_file = fake_expansion;\n-                        fake_ident_token = fake_mapped_token;\n-                        offset = new_offset;\n-                        continue 'expansion;\n-                    }\n-                    // exactly one expansion failed, inconsistent state so stop expanding completely\n-                    _ => break 'expansion,\n-                }\n-            }\n-\n-            // No attributes have been expanded, so look for macro_call! token trees or derive token trees\n-            let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n-                Some(it) => it,\n-                None => break 'expansion,\n-            };\n-            let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n-                Some(it) => it,\n-                None => break 'expansion,\n-            };\n-\n-            // Expand pseudo-derive expansion\n-            if let (Some(orig_attr), Some(spec_attr)) = (\n-                orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n-                spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n-            ) {\n-                if let (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) = (\n-                    self.sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n-                    self.sema.speculative_expand_derive_as_pseudo_attr_macro(\n-                        &orig_attr,\n-                        &spec_attr,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    derive_ctx = Some((\n-                        actual_expansion,\n-                        fake_expansion,\n-                        fake_mapped_token.text_range().start(),\n-                        orig_attr,\n-                    ));\n-                }\n-                // at this point we won't have any more successful expansions, so stop\n-                break 'expansion;\n-            }\n-\n-            // Expand fn-like macro calls\n-            if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n-                orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n-                spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n-            ) {\n-                let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n-                let mac_call_path1 =\n-                    macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n-\n-                // inconsistent state, stop expanding\n-                if mac_call_path0 != mac_call_path1 {\n-                    break 'expansion;\n-                }\n-                let speculative_args = match macro_call_with_fake_ident.token_tree() {\n-                    Some(tt) => tt,\n-                    None => break 'expansion,\n-                };\n-\n-                match (\n-                    self.sema.expand(&actual_macro_call),\n-                    self.sema.speculative_expand(\n-                        &actual_macro_call,\n-                        &speculative_args,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    // successful expansions\n-                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n-                        let new_offset = fake_mapped_token.text_range().start();\n-                        if new_offset > actual_expansion.text_range().end() {\n-                            // offset outside of bounds from the original expansion,\n-                            // stop here to prevent problems from happening\n-                            break 'expansion;\n-                        }\n-                        original_file = actual_expansion;\n-                        speculative_file = fake_expansion;\n-                        fake_ident_token = fake_mapped_token;\n-                        offset = new_offset;\n-                        continue 'expansion;\n-                    }\n-                    // at least on expansion failed, we won't have anything to expand from this point\n-                    // onwards so break out\n-                    _ => break 'expansion,\n-                }\n-            }\n-\n-            // none of our states have changed so stop the loop\n-            break 'expansion;\n-        }\n-\n-        self.fill(&original_file, speculative_file, offset, derive_ctx)\n-    }\n-\n-    /// Calculate the expected type and name of the cursor position.\n-    fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n-        let mut node = match self.token.parent() {\n-            Some(it) => it,\n-            None => return (None, None),\n-        };\n-        loop {\n-            break match_ast! {\n-                match node {\n-                    ast::LetStmt(it) => {\n-                        cov_mark::hit!(expected_type_let_with_leading_char);\n-                        cov_mark::hit!(expected_type_let_without_leading_char);\n-                        let ty = it.pat()\n-                            .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)))\n-                            .map(TypeInfo::original);\n-                        let name = match it.pat() {\n-                            Some(ast::Pat::IdentPat(ident)) => ident.name().map(NameOrNameRef::Name),\n-                            Some(_) | None => None,\n-                        };\n-\n-                        (ty, name)\n-                    },\n-                    ast::LetExpr(it) => {\n-                        cov_mark::hit!(expected_type_if_let_without_leading_char);\n-                        let ty = it.pat()\n-                            .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.expr().and_then(|it| self.sema.type_of_expr(&it)))\n-                            .map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::ArgList(_) => {\n-                        cov_mark::hit!(expected_type_fn_param);\n-                        ActiveParameter::at_token(\n-                            &self.sema,\n-                            self.token.clone(),\n-                        ).map(|ap| {\n-                            let name = ap.ident().map(NameOrNameRef::Name);\n-                            let ty = if has_ref(&self.token) {\n-                                cov_mark::hit!(expected_type_fn_param_ref);\n-                                ap.ty.remove_ref()\n-                            } else {\n-                                Some(ap.ty)\n-                            };\n-                            (ty, name)\n-                        })\n-                        .unwrap_or((None, None))\n-                    },\n-                    ast::RecordExprFieldList(it) => {\n-                        // wouldn't try {} be nice...\n-                        (|| {\n-                            if self.token.kind() == T![..]\n-                                || self.token.prev_token().map(|t| t.kind()) == Some(T![..])\n-                            {\n-                                cov_mark::hit!(expected_type_struct_func_update);\n-                                let record_expr = it.syntax().parent().and_then(ast::RecordExpr::cast)?;\n-                                let ty = self.sema.type_of_expr(&record_expr.into())?;\n-                                Some((\n-                                    Some(ty.original),\n-                                    None\n-                                ))\n-                            } else {\n-                                cov_mark::hit!(expected_type_struct_field_without_leading_char);\n-                                let expr_field = self.token.prev_sibling_or_token()?\n-                                    .into_node()\n-                                    .and_then(ast::RecordExprField::cast)?;\n-                                let (_, _, ty) = self.sema.resolve_record_field(&expr_field)?;\n-                                Some((\n-                                    Some(ty),\n-                                    expr_field.field_name().map(NameOrNameRef::NameRef),\n-                                ))\n-                            }\n-                        })().unwrap_or((None, None))\n-                    },\n-                    ast::RecordExprField(it) => {\n-                        if let Some(expr) = it.expr() {\n-                            cov_mark::hit!(expected_type_struct_field_with_leading_char);\n-                            (\n-                                self.sema.type_of_expr(&expr).map(TypeInfo::original),\n-                                it.field_name().map(NameOrNameRef::NameRef),\n-                            )\n-                        } else {\n-                            cov_mark::hit!(expected_type_struct_field_followed_by_comma);\n-                            let ty = self.sema.resolve_record_field(&it)\n-                                .map(|(_, _, ty)| ty);\n-                            (\n-                                ty,\n-                                it.field_name().map(NameOrNameRef::NameRef),\n-                            )\n-                        }\n-                    },\n-                    // match foo { $0 }\n-                    // match foo { ..., pat => $0 }\n-                    ast::MatchExpr(it) => {\n-                        let ty = if self.previous_token_is(T![=>]) {\n-                            // match foo { ..., pat => $0 }\n-                            cov_mark::hit!(expected_type_match_arm_body_without_leading_char);\n-                            cov_mark::hit!(expected_type_match_arm_body_with_leading_char);\n-                            self.sema.type_of_expr(&it.into())\n-                        } else {\n-                            // match foo { $0 }\n-                            cov_mark::hit!(expected_type_match_arm_without_leading_char);\n-                            it.expr().and_then(|e| self.sema.type_of_expr(&e))\n-                        }.map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::IfExpr(it) => {\n-                        let ty = it.condition()\n-                            .and_then(|e| self.sema.type_of_expr(&e))\n-                            .map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::IdentPat(it) => {\n-                        cov_mark::hit!(expected_type_if_let_with_leading_char);\n-                        cov_mark::hit!(expected_type_match_arm_with_leading_char);\n-                        let ty = self.sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::Fn(it) => {\n-                        cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n-                        cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n-                        let def = self.sema.to_def(&it);\n-                        (def.map(|def| def.ret_type(self.db)), None)\n-                    },\n-                    ast::ClosureExpr(it) => {\n-                        let ty = self.sema.type_of_expr(&it.into());\n-                        ty.and_then(|ty| ty.original.as_callable(self.db))\n-                            .map(|c| (Some(c.return_type()), None))\n-                            .unwrap_or((None, None))\n-                    },\n-                    ast::ParamList(_) => (None, None),\n-                    ast::Stmt(_) => (None, None),\n-                    ast::Item(_) => (None, None),\n-                    _ => {\n-                        match node.parent() {\n-                            Some(n) => {\n-                                node = n;\n-                                continue;\n-                            },\n-                            None => (None, None),\n-                        }\n-                    },\n-                }\n-            };\n-        }\n-    }\n-\n-    /// Fill the completion context, this is what does semantic reasoning about the surrounding context\n-    /// of the completion location.\n-    fn fill(\n-        &mut self,\n-        original_file: &SyntaxNode,\n-        file_with_fake_ident: SyntaxNode,\n-        offset: TextSize,\n-        derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n-    ) -> Option<()> {\n-        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased()?;\n-        let syntax_element = NodeOrToken::Token(fake_ident_token);\n-        if is_in_token_of_for_loop(syntax_element.clone()) {\n-            // for pat $0\n-            // there is nothing to complete here except `in` keyword\n-            // don't bother populating the context\n-            // FIXME: the completion calculations should end up good enough\n-            // such that this special case becomes unnecessary\n-            return None;\n-        }\n-\n-        self.previous_token = previous_token(syntax_element.clone());\n-\n-        self.incomplete_let =\n-            syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n-                it.syntax().text_range().end() == syntax_element.text_range().end()\n-            });\n-\n-        (self.expected_type, self.expected_name) = self.expected_type_and_name();\n-\n-        // Overwrite the path kind for derives\n-        if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n-            self.existing_derives = self\n-                .sema\n-                .resolve_derive_macro(&origin_attr)\n-                .into_iter()\n-                .flatten()\n-                .flatten()\n-                .collect();\n-\n-            if let Some(ast::NameLike::NameRef(name_ref)) =\n-                find_node_at_offset(&file_with_fake_ident, offset)\n-            {\n-                let parent = name_ref.syntax().parent()?;\n-                let (mut nameref_ctx, _, _) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n-                if let Some(NameRefKind::Path(path_ctx)) = &mut nameref_ctx.kind {\n-                    path_ctx.kind = PathKind::Derive;\n-                }\n-                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n-                return Some(());\n-            }\n-            return None;\n-        }\n-\n-        let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n-            Some(it) => it,\n-            None => {\n-                if let Some(original) = ast::String::cast(self.original_token.clone()) {\n-                    self.ident_ctx = IdentContext::String {\n-                        original,\n-                        expanded: ast::String::cast(self.token.clone()),\n-                    };\n-                } else {\n-                    // Fix up trailing whitespace problem\n-                    // #[attr(foo = $0\n-                    let token = if self.token.kind() == SyntaxKind::WHITESPACE {\n-                        self.previous_token.as_ref()?\n-                    } else {\n-                        &self.token\n-                    };\n-                    let p = token.parent()?;\n-                    if p.kind() == SyntaxKind::TOKEN_TREE\n-                        && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n-                    {\n-                        self.ident_ctx = IdentContext::UnexpandedAttrTT {\n-                            fake_attribute_under_caret: syntax_element\n-                                .ancestors()\n-                                .find_map(ast::Attr::cast),\n-                        };\n-                    } else {\n-                        return None;\n-                    }\n-                }\n-                return Some(());\n-            }\n-        };\n-        self.impl_def = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SOURCE_FILE)\n-            .filter_map(ast::Item::cast)\n-            .take(2)\n-            .find_map(|it| match it {\n-                ast::Item::Impl(impl_) => Some(impl_),\n-                _ => None,\n-            });\n-        self.function_def = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .filter_map(ast::Item::cast)\n-            .take(2)\n-            .find_map(|it| match it {\n-                ast::Item::Fn(fn_) => Some(fn_),\n-                _ => None,\n-            });\n-\n-        match name_like {\n-            ast::NameLike::Lifetime(lifetime) => {\n-                self.ident_ctx = IdentContext::Lifetime(Self::classify_lifetime(\n-                    &self.sema,\n-                    original_file,\n-                    lifetime,\n-                )?);\n-            }\n-            ast::NameLike::NameRef(name_ref) => {\n-                let parent = name_ref.syntax().parent()?;\n-                let (nameref_ctx, pat_ctx, qualifier_ctx) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone());\n-\n-                self.qualifier_ctx = qualifier_ctx;\n-                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n-                self.pattern_ctx = pat_ctx;\n-            }\n-            ast::NameLike::Name(name) => {\n-                let (name_ctx, pat_ctx) = Self::classify_name(&self.sema, original_file, name)?;\n-                self.pattern_ctx = pat_ctx;\n-                self.ident_ctx = IdentContext::Name(name_ctx);\n-            }\n-        }\n-        Some(())\n-    }\n-\n-    fn classify_lifetime(\n-        _sema: &Semantics<RootDatabase>,\n-        original_file: &SyntaxNode,\n-        lifetime: ast::Lifetime,\n-    ) -> Option<LifetimeContext> {\n-        let parent = lifetime.syntax().parent()?;\n-        if parent.kind() == ERROR {\n-            return None;\n-        }\n-\n-        let kind = match_ast! {\n-            match parent {\n-                ast::LifetimeParam(param) => LifetimeKind::LifetimeParam {\n-                    is_decl: param.lifetime().as_ref() == Some(&lifetime),\n-                    param\n-                },\n-                ast::BreakExpr(_) => LifetimeKind::LabelRef,\n-                ast::ContinueExpr(_) => LifetimeKind::LabelRef,\n-                ast::Label(_) => LifetimeKind::LabelDef,\n-                _ => LifetimeKind::Lifetime,\n-            }\n-        };\n-        let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n-\n-        Some(LifetimeContext { lifetime, kind })\n-    }\n-\n-    fn classify_name(\n-        _sema: &Semantics<RootDatabase>,\n-        original_file: &SyntaxNode,\n-        name: ast::Name,\n-    ) -> Option<(NameContext, Option<PatternContext>)> {\n-        let parent = name.syntax().parent()?;\n-        let mut pat_ctx = None;\n-        let kind = match_ast! {\n-            match parent {\n-                ast::Const(_) => NameKind::Const,\n-                ast::ConstParam(_) => NameKind::ConstParam,\n-                ast::Enum(_) => NameKind::Enum,\n-                ast::Fn(_) => NameKind::Function,\n-                ast::IdentPat(bind_pat) => {\n-                    pat_ctx = Some({\n-                        let mut pat_ctx = pattern_context_for(original_file, bind_pat.into());\n-                        if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n-                            pat_ctx.record_pat = find_node_in_file_compensated(original_file, &record_field.parent_record_pat());\n-                        }\n-                        pat_ctx\n-                    });\n-\n-                    NameKind::IdentPat\n-                },\n-                ast::MacroDef(_) => NameKind::MacroDef,\n-                ast::MacroRules(_) => NameKind::MacroRules,\n-                ast::Module(module) => NameKind::Module(module),\n-                ast::RecordField(_) => NameKind::RecordField,\n-                ast::Rename(_) => NameKind::Rename,\n-                ast::SelfParam(_) => NameKind::SelfParam,\n-                ast::Static(_) => NameKind::Static,\n-                ast::Struct(_) => NameKind::Struct,\n-                ast::Trait(_) => NameKind::Trait,\n-                ast::TypeAlias(_) => NameKind::TypeAlias,\n-                ast::TypeParam(_) => NameKind::TypeParam,\n-                ast::Union(_) => NameKind::Union,\n-                ast::Variant(_) => NameKind::Variant,\n-                _ => return None,\n-            }\n-        };\n-        let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n-        Some((NameContext { name, kind }, pat_ctx))\n-    }\n-\n-    fn classify_name_ref(\n-        sema: &Semantics<RootDatabase>,\n-        original_file: &SyntaxNode,\n-        name_ref: ast::NameRef,\n-        parent: SyntaxNode,\n-    ) -> (NameRefContext, Option<PatternContext>, QualifierCtx) {\n-        let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n-\n-        let mut res = (NameRefContext { nameref, kind: None }, None, QualifierCtx::default());\n-        let (nameref_ctx, pattern_ctx, qualifier_ctx) = &mut res;\n-\n-        if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n-            nameref_ctx.kind =\n-                find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n-                    .map(NameRefKind::RecordExpr);\n-            return res;\n-        }\n-        if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n-            *pattern_ctx = Some(PatternContext {\n-                param_ctx: None,\n-                has_type_ascription: false,\n-                ref_token: None,\n-                mut_token: None,\n-                record_pat: find_node_in_file_compensated(\n-                    original_file,\n-                    &record_field.parent_record_pat(),\n-                ),\n-                ..pattern_context_for(\n-                    original_file,\n-                    record_field.parent_record_pat().clone().into(),\n-                )\n-            });\n-            return res;\n-        }\n-\n-        let segment = match_ast! {\n-            match parent {\n-                ast::PathSegment(segment) => segment,\n-                ast::FieldExpr(field) => {\n-                    let receiver = find_opt_node_in_file(original_file, field.expr());\n-                    let receiver_is_ambiguous_float_literal = match &receiver {\n-                        Some(ast::Expr::Literal(l)) => matches! {\n-                            l.kind(),\n-                            ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.text().ends_with('.'))\n-                        },\n-                        _ => false,\n-                    };\n-                    nameref_ctx.kind = Some(NameRefKind::DotAccess(DotAccess {\n-                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n-                        kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n-                        receiver\n-                    }));\n-                    return res;\n-                },\n-                ast::MethodCallExpr(method) => {\n-                    let receiver = find_opt_node_in_file(original_file, method.receiver());\n-                    nameref_ctx.kind = Some(NameRefKind::DotAccess(DotAccess {\n-                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n-                        kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n-                        receiver\n-                    }));\n-                    return res;\n-                },\n-                _ => return res,\n-            }\n-        };\n-\n-        let path = segment.parent_path();\n-        let mut path_ctx = PathCompletionCtx {\n-            has_call_parens: false,\n-            has_macro_bang: false,\n-            is_absolute_path: false,\n-            qualifier: None,\n-            parent: path.parent_path(),\n-            kind: PathKind::Item { kind: ItemListKind::SourceFile },\n-            has_type_args: false,\n-        };\n-\n-        let is_in_block = |it: &SyntaxNode| {\n-            it.parent()\n-                .map(|node| {\n-                    ast::ExprStmt::can_cast(node.kind()) || ast::StmtList::can_cast(node.kind())\n-                })\n-                .unwrap_or(false)\n-        };\n-        let func_update_record = |syn: &SyntaxNode| {\n-            if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n-                find_node_in_file_compensated(original_file, &record_expr)\n-            } else {\n-                None\n-            }\n-        };\n-        let after_if_expr = |node: SyntaxNode| {\n-            let prev_expr = (|| {\n-                let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-                ast::ExprStmt::cast(prev_sibling)?.expr()\n-            })();\n-            matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n-        };\n-\n-        // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n-        // ex. trait Foo $0 {}\n-        // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n-        // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n-        // expression or an item list.\n-        // The following code checks if the body is missing, if it is we either cut off the body\n-        // from the item or it was missing in the first place\n-        let inbetween_body_and_decl_check = |node: SyntaxNode| {\n-            if let Some(NodeOrToken::Node(n)) =\n-                syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n-            {\n-                if let Some(item) = ast::Item::cast(n) {\n-                    let is_inbetween = match &item {\n-                        ast::Item::Const(it) => it.body().is_none(),\n-                        ast::Item::Enum(it) => it.variant_list().is_none(),\n-                        ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n-                        ast::Item::Fn(it) => it.body().is_none(),\n-                        ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n-                        ast::Item::Module(it) => it.item_list().is_none(),\n-                        ast::Item::Static(it) => it.body().is_none(),\n-                        ast::Item::Struct(it) => it.field_list().is_none(),\n-                        ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n-                        ast::Item::TypeAlias(it) => it.ty().is_none(),\n-                        ast::Item::Union(it) => it.record_field_list().is_none(),\n-                        _ => false,\n-                    };\n-                    if is_inbetween {\n-                        return Some(item);\n-                    }\n-                }\n-            }\n-            None\n-        };\n-\n-        let type_location = |it: Option<SyntaxNode>| {\n-            let parent = it?;\n-            let res = match_ast! {\n-                match parent {\n-                    ast::Const(it) => {\n-                        let name = find_opt_node_in_file(original_file, it.name())?;\n-                        let original = ast::Const::cast(name.syntax().parent()?)?;\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n-                    },\n-                    ast::RetType(it) => {\n-                        if it.thin_arrow_token().is_none() {\n-                            return None;\n-                        }\n-                        let parent = match ast::Fn::cast(parent.parent()?) {\n-                            Some(x) => x.param_list(),\n-                            None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n-                        };\n-\n-                        let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n-                            match parent {\n-                                ast::ClosureExpr(it) => {\n-                                    it.body()\n-                                },\n-                                ast::Fn(it) => {\n-                                    it.body().map(ast::Expr::BlockExpr)\n-                                },\n-                                _ => return None,\n-                            }\n-                        }))\n-                    },\n-                    ast::Param(it) => {\n-                        if it.colon_token().is_none() {\n-                            return None;\n-                        }\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n-                    },\n-                    ast::LetStmt(it) => {\n-                        if it.colon_token().is_none() {\n-                            return None;\n-                        }\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n-                    },\n-                    ast::TypeBound(_) => TypeLocation::TypeBound,\n-                    // is this case needed?\n-                    ast::TypeBoundList(_) => TypeLocation::TypeBound,\n-                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n-                    // is this case needed?\n-                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, Some(it))),\n-                    ast::TupleField(_) => TypeLocation::TupleField,\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        };\n-\n-        // Infer the path kind\n-        let kind = path.syntax().parent().and_then(|it| {\n-            match_ast! {\n-                match it {\n-                    ast::PathType(it) => {\n-                        let location = type_location(it.syntax().parent());\n-                        Some(PathKind::Type {\n-                            location: location.unwrap_or(TypeLocation::Other),\n-                        })\n-                    },\n-                    ast::PathExpr(it) => {\n-                        if let Some(p) = it.syntax().parent() {\n-                            if ast::ExprStmt::can_cast(p.kind()) {\n-                                if let Some(kind) = inbetween_body_and_decl_check(p) {\n-                                    nameref_ctx.kind = Some(NameRefKind::Keyword(kind));\n-                                    return None;\n-                                }\n-                            }\n-                        }\n-\n-                        path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n-                        let in_block_expr = is_in_block(it.syntax());\n-                        let in_loop_body = is_in_loop_body(it.syntax());\n-                        let after_if_expr = after_if_expr(it.syntax().clone());\n-                        let ref_expr_parent = path.as_single_name_ref()\n-                            .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n-                        let is_func_update = func_update_record(it.syntax());\n-\n-                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update })\n-                    },\n-                    ast::TupleStructPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n-                        Some(PathKind::Pat)\n-                    },\n-                    ast::RecordPat(it) => {\n-                        path_ctx.has_call_parens = true;\n-                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n-                        Some(PathKind::Pat)\n-                    },\n-                    ast::PathPat(it) => {\n-                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n-                        Some(PathKind::Pat)\n-                    },\n-                    ast::MacroCall(it) => {\n-                        if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n-                            nameref_ctx.kind = Some(NameRefKind::Keyword(kind));\n-                            return None;\n-                        }\n-\n-                        path_ctx.has_macro_bang = it.excl_token().is_some();\n-                        let parent = it.syntax().parent();\n-                        match parent.as_ref().map(|it| it.kind()) {\n-                            Some(SyntaxKind::MACRO_PAT) => Some(PathKind::Pat),\n-                            Some(SyntaxKind::MACRO_TYPE) => {\n-                                let location = type_location(parent.unwrap().parent());\n-                                Some(PathKind::Type {\n-                                    location: location.unwrap_or(TypeLocation::Other),\n-                                })\n-                            },\n-                            Some(SyntaxKind::ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::Module }),\n-                            Some(SyntaxKind::ASSOC_ITEM_LIST) => Some(PathKind::Item { kind: match parent.and_then(|it| it.parent()) {\n-                                Some(it) => match_ast! {\n-                                    match it {\n-                                        ast::Trait(_) => ItemListKind::Trait,\n-                                        ast::Impl(it) => if it.trait_().is_some() {\n-                                            ItemListKind::TraitImpl\n-                                        } else {\n-                                            ItemListKind::Impl\n-                                        },\n-                                        _ => return None\n-                                    }\n-                                },\n-                                None => return None,\n-                            } }),\n-                            Some(SyntaxKind::EXTERN_ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::ExternBlock }),\n-                            Some(SyntaxKind::SOURCE_FILE) => Some(PathKind::Item { kind: ItemListKind::SourceFile }),\n-                            _ => {\n-                               return parent.and_then(ast::MacroExpr::cast).map(|it| {\n-                                    let in_loop_body = is_in_loop_body(it.syntax());\n-                                    let in_block_expr = is_in_block(it.syntax());\n-                                    let after_if_expr = after_if_expr(it.syntax().clone());\n-                                    let ref_expr_parent = path.as_single_name_ref()\n-                                        .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n-                                    let is_func_update = func_update_record(it.syntax());\n-                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update }\n-                                });\n-                            },\n-                        }\n-                    },\n-                    ast::Meta(meta) => (|| {\n-                        let attr = meta.parent_attr()?;\n-                        let kind = attr.kind();\n-                        let attached = attr.syntax().parent()?;\n-                        let is_trailing_outer_attr = kind != AttrKind::Inner\n-                            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n-                        let annotated_item_kind = if is_trailing_outer_attr {\n-                            None\n-                        } else {\n-                            Some(attached.kind())\n-                        };\n-                        Some(PathKind::Attr {\n-                            kind,\n-                            annotated_item_kind,\n-                        })\n-                    })(),\n-                    ast::Visibility(it) => Some(PathKind::Vis { has_in_token: it.in_token().is_some() }),\n-                    ast::UseTree(_) => Some(PathKind::Use),\n-                    _ => return None,\n-                }\n-            }\n-        });\n-\n-        match kind {\n-            Some(kind) => path_ctx.kind = kind,\n-            None => return res,\n-        }\n-        path_ctx.has_type_args = segment.generic_arg_list().is_some();\n-\n-        if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n-            if !use_tree_parent {\n-                path_ctx.is_absolute_path =\n-                    path.top_path().segment().map_or(false, |it| it.coloncolon_token().is_some());\n-            }\n-\n-            let path = path\n-                .segment()\n-                .and_then(|it| find_node_in_file(original_file, &it))\n-                .map(|it| it.parent_path());\n-            path_ctx.qualifier = path.map(|path| {\n-                let res = sema.resolve_path(&path);\n-                let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                    .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n-\n-                // `<_>::$0`\n-                let is_infer_qualifier = path.qualifier().is_none()\n-                    && matches!(\n-                        path.segment().and_then(|it| it.kind()),\n-                        Some(ast::PathSegmentKind::Type {\n-                            type_ref: Some(ast::Type::InferType(_)),\n-                            trait_ref: None,\n-                        })\n-                    );\n-\n-                PathQualifierCtx {\n-                    path,\n-                    resolution: res,\n-                    is_super_chain,\n-                    use_tree_parent,\n-                    is_infer_qualifier,\n-                }\n-            });\n-        } else if let Some(segment) = path.segment() {\n-            if segment.coloncolon_token().is_some() {\n-                path_ctx.is_absolute_path = true;\n-            }\n-        }\n-\n-        if path_ctx.is_trivial_path() {\n-            // fetch the full expression that may have qualifiers attached to it\n-            let top_node = match path_ctx.kind {\n-                PathKind::Expr { in_block_expr: true, .. } => {\n-                    parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n-                        let parent = p.parent()?;\n-                        if ast::StmtList::can_cast(parent.kind()) {\n-                            Some(p)\n-                        } else if ast::ExprStmt::can_cast(parent.kind()) {\n-                            Some(parent)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                PathKind::Item { .. } => {\n-                    parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n-                }\n-                _ => None,\n-            };\n-            if let Some(top) = top_node {\n-                if let Some(NodeOrToken::Node(error_node)) =\n-                    syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n-                {\n-                    if error_node.kind() == SyntaxKind::ERROR {\n-                        qualifier_ctx.unsafe_tok = error_node\n-                            .children_with_tokens()\n-                            .filter_map(NodeOrToken::into_token)\n-                            .find(|it| it.kind() == T![unsafe]);\n-                        qualifier_ctx.vis_node =\n-                            error_node.children().find_map(ast::Visibility::cast);\n-                    }\n-                }\n-\n-                if let PathKind::Item { .. } = path_ctx.kind {\n-                    if qualifier_ctx.none() {\n-                        if let Some(t) = top.first_token() {\n-                            if let Some(prev) = t\n-                                .prev_token()\n-                                .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n-                            {\n-                                if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n-                                    // This was inferred to be an item position path, but it seems\n-                                    // to be part of some other broken node which leaked into an item\n-                                    // list, so return without setting the path context\n-                                    return res;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        nameref_ctx.kind = Some(NameRefKind::Path(path_ctx));\n-        res\n-    }\n-}\n-\n-fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternContext {\n-    let mut is_param = None;\n-    let (refutability, has_type_ascription) =\n-    pat\n-        .syntax()\n-        .ancestors()\n-        .skip_while(|it| ast::Pat::can_cast(it.kind()))\n-        .next()\n-        .map_or((PatternRefutability::Irrefutable, false), |node| {\n-            let refutability = match_ast! {\n-                match node {\n-                    ast::LetStmt(let_) => return (PatternRefutability::Irrefutable, let_.ty().is_some()),\n-                    ast::Param(param) => {\n-                        let has_type_ascription = param.ty().is_some();\n-                        is_param = (|| {\n-                            let fake_param_list = param.syntax().parent().and_then(ast::ParamList::cast)?;\n-                            let param_list = find_node_in_file_compensated(original_file, &fake_param_list)?;\n-                            let param_list_owner = param_list.syntax().parent()?;\n-                            let kind = match_ast! {\n-                                match param_list_owner {\n-                                    ast::ClosureExpr(closure) => ParamKind::Closure(closure),\n-                                    ast::Fn(fn_) => ParamKind::Function(fn_),\n-                                    _ => return None,\n-                                }\n-                            };\n-                            Some((param_list, param, kind))\n-                        })();\n-                        return (PatternRefutability::Irrefutable, has_type_ascription)\n-                    },\n-                    ast::MatchArm(_) => PatternRefutability::Refutable,\n-                    ast::LetExpr(_) => PatternRefutability::Refutable,\n-                    ast::ForExpr(_) => PatternRefutability::Irrefutable,\n-                    _ => PatternRefutability::Irrefutable,\n-                }\n-            };\n-            (refutability, false)\n-        });\n-    let (ref_token, mut_token) = match &pat {\n-        ast::Pat::IdentPat(it) => (it.ref_token(), it.mut_token()),\n-        _ => (None, None),\n-    };\n-    PatternContext {\n-        refutability,\n-        param_ctx: is_param,\n-        has_type_ascription,\n-        parent_pat: pat.syntax().parent().and_then(ast::Pat::cast),\n-        mut_token,\n-        ref_token,\n-        record_pat: None,\n-    }\n-}\n-\n-/// Attempts to find `node` inside `syntax` via `node`'s text range.\n-/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n-fn find_opt_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: Option<N>) -> Option<N> {\n-    find_node_in_file(syntax, &node?)\n-}\n-\n-/// Attempts to find `node` inside `syntax` via `node`'s text range.\n-/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n-fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n-    let syntax_range = syntax.text_range();\n-    let range = node.syntax().text_range();\n-    let intersection = range.intersect(syntax_range)?;\n-    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n-}\n-\n-/// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n-/// for the offset introduced by the fake ident.\n-/// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n-fn find_node_in_file_compensated<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n-    let syntax_range = syntax.text_range();\n-    let range = node.syntax().text_range();\n-    let end = range.end().checked_sub(TextSize::try_from(COMPLETION_MARKER.len()).ok()?)?;\n-    if end < range.start() {\n-        return None;\n-    }\n-    let range = TextRange::new(range.start(), end);\n-    // our inserted ident could cause `range` to go outside of the original syntax, so cap it\n-    let intersection = range.intersect(syntax_range)?;\n-    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n-}\n-\n-/// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n-/// for the offset introduced by the fake ident..\n-/// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n-fn find_opt_node_in_file_compensated<N: AstNode>(\n-    syntax: &SyntaxNode,\n-    node: Option<N>,\n-) -> Option<N> {\n-    find_node_in_file_compensated(syntax, &node?)\n-}\n-\n-fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n-    if let Some(qual) = path.qualifier() {\n-        return Some((qual, false));\n-    }\n-    let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n-    let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n-    Some((use_tree.path()?, true))\n-}\n-\n-fn has_ref(token: &SyntaxToken) -> bool {\n-    let mut token = token.clone();\n-    for skip in [IDENT, WHITESPACE, T![mut]] {\n-        if token.kind() == skip {\n-            token = match token.prev_token() {\n-                Some(it) => it,\n-                None => return false,\n-            }\n-        }\n-    }\n-    token.kind() == T![&]\n }\n \n const OP_TRAIT_LANG_NAMES: &[&str] = &[\n@@ -1605,400 +589,3 @@ const OP_TRAIT_LANG_NAMES: &[&str] = &[\n     \"shr\",\n     \"sub\",\n ];\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-    use hir::HirDisplay;\n-\n-    use crate::tests::{position, TEST_CONFIG};\n-\n-    use super::CompletionContext;\n-\n-    fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n-        let (db, pos) = position(ra_fixture);\n-        let config = TEST_CONFIG;\n-        let completion_context = CompletionContext::new(&db, pos, &config).unwrap();\n-\n-        let ty = completion_context\n-            .expected_type\n-            .map(|t| t.display_test(&db).to_string())\n-            .unwrap_or(\"?\".to_owned());\n-\n-        let name = completion_context\n-            .expected_name\n-            .map_or_else(|| \"?\".to_owned(), |name| name.to_string());\n-\n-        expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n-    }\n-\n-    #[test]\n-    fn expected_type_let_without_leading_char() {\n-        cov_mark::check!(expected_type_let_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let x: u32 = $0;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_let_with_leading_char() {\n-        cov_mark::check!(expected_type_let_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let x: u32 = c$0;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_let_pat() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let x$0 = 0u32;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let $0 = 0u32;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_param() {\n-        cov_mark::check!(expected_type_fn_param);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar($0); }\n-fn bar(x: u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(c$0); }\n-fn bar(x: u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_param_ref() {\n-        cov_mark::check!(expected_type_fn_param_ref);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&$0); }\n-fn bar(x: &u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&mut $0); }\n-fn bar(x: &mut u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(& c$0); }\n-fn bar(x: &u32) {}\n-        \"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&mut c$0); }\n-fn bar(x: &mut u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&c$0); }\n-fn bar(x: &u32) {}\n-        \"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_struct_field_without_leading_char() {\n-        cov_mark::check!(expected_type_struct_field_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { a: u32 }\n-fn foo() {\n-    Foo { a: $0 };\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_struct_field_followed_by_comma() {\n-        cov_mark::check!(expected_type_struct_field_followed_by_comma);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { a: u32 }\n-fn foo() {\n-    Foo { a: $0, };\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_generic_struct_field() {\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo<T> { a: T }\n-fn foo() -> Foo<u32> {\n-    Foo { a: $0 }\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_struct_field_with_leading_char() {\n-        cov_mark::check!(expected_type_struct_field_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { a: u32 }\n-fn foo() {\n-    Foo { a: c$0 };\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_arm_without_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum E { X }\n-fn foo() {\n-   match E::X { $0 }\n-}\n-\"#,\n-            expect![[r#\"ty: E, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_arm_with_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum E { X }\n-fn foo() {\n-   match E::X { c$0 }\n-}\n-\"#,\n-            expect![[r#\"ty: E, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_arm_body_without_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_body_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo;\n-enum E { X }\n-fn foo() -> Foo {\n-   match E::X { E::X => $0 }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_body_arm_with_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_body_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo;\n-enum E { X }\n-fn foo() -> Foo {\n-   match E::X { E::X => c$0 }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_if_let_without_leading_char() {\n-        cov_mark::check!(expected_type_if_let_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn foo() {\n-    let f = Foo::Quux;\n-    if let $0 = f { }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_if_let_with_leading_char() {\n-        cov_mark::check!(expected_type_if_let_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn foo() {\n-    let f = Foo::Quux;\n-    if let c$0 = f { }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_ret_without_leading_char() {\n-        cov_mark::check!(expected_type_fn_ret_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() -> u32 {\n-    $0\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_ret_with_leading_char() {\n-        cov_mark::check!(expected_type_fn_ret_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() -> u32 {\n-    c$0\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_ret_fn_ref_fully_typed() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() -> u32 {\n-    foo$0\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_closure_param_return() {\n-        // FIXME: make this work with `|| $0`\n-        check_expected_type_and_name(\n-            r#\"\n-//- minicore: fn\n-fn foo() {\n-    bar(|| a$0);\n-}\n-\n-fn bar(f: impl FnOnce() -> u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_generic_function() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    bar::<u32>($0);\n-}\n-\n-fn bar<T>(t: T) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: t\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_generic_method() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    S(1u32).bar($0);\n-}\n-\n-struct S<T>(T);\n-impl<T> S<T> {\n-    fn bar(self, t: T) {}\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: t\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_functional_update() {\n-        cov_mark::check!(expected_type_struct_func_update);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { field: u32 }\n-fn foo() {\n-    Foo {\n-        ..$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_param_pat() {\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { field: u32 }\n-fn foo(a$0: Foo) {}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { field: u32 }\n-fn foo($0: Foo) {}\n-\"#,\n-            // FIXME make this work, currently fails due to pattern recovery eating the `:`\n-            expect![[r#\"ty: ?, name: ?\"#]],\n-        );\n-    }\n-}"}, {"sha": "dc50d82f1998c1ed88972c7de440e9273780de43", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "added", "additions": 1113, "deletions": 0, "changes": 1113, "blob_url": "https://github.com/rust-lang/rust/blob/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=a69b17be2eb981e8172bada48eb1593172528654", "patch": "@@ -0,0 +1,1113 @@\n+//! Module responsible for analyzing the code surrounding the cursor for completion.\n+use std::iter;\n+\n+use hir::{Semantics, Type, TypeInfo};\n+use ide_db::{active_parameter::ActiveParameter, RootDatabase};\n+use syntax::{\n+    algo::{find_node_at_offset, non_trivia_sibling},\n+    ast::{self, AttrKind, HasArgList, HasLoopBody, HasName, NameOrNameRef},\n+    match_ast, AstNode, AstToken, Direction, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode,\n+    SyntaxToken, TextRange, TextSize, T,\n+};\n+\n+use crate::context::{\n+    CompletionContext, DotAccess, DotAccessKind, IdentContext, ItemListKind, LifetimeContext,\n+    LifetimeKind, NameContext, NameKind, NameRefContext, NameRefKind, ParamKind, PathCompletionCtx,\n+    PathKind, PathQualifierCtx, PatternContext, PatternRefutability, QualifierCtx,\n+    TypeAscriptionTarget, TypeLocation, COMPLETION_MARKER,\n+};\n+\n+impl<'a> CompletionContext<'a> {\n+    /// Expand attributes and macro calls at the current cursor position for both the original file\n+    /// and fake file repeatedly. As soon as one of the two expansions fail we stop so the original\n+    /// and speculative states stay in sync.\n+    pub(super) fn expand_and_fill(\n+        &mut self,\n+        mut original_file: SyntaxNode,\n+        mut speculative_file: SyntaxNode,\n+        mut offset: TextSize,\n+        mut fake_ident_token: SyntaxToken,\n+    ) -> Option<()> {\n+        let _p = profile::span(\"CompletionContext::expand_and_fill\");\n+        let mut derive_ctx = None;\n+\n+        'expansion: loop {\n+            let parent_item =\n+                |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n+            let ancestor_items = iter::successors(\n+                Option::zip(\n+                    find_node_at_offset::<ast::Item>(&original_file, offset),\n+                    find_node_at_offset::<ast::Item>(&speculative_file, offset),\n+                ),\n+                |(a, b)| parent_item(a).zip(parent_item(b)),\n+            );\n+\n+            // first try to expand attributes as these are always the outermost macro calls\n+            'ancestors: for (actual_item, item_with_fake_ident) in ancestor_items {\n+                match (\n+                    self.sema.expand_attr_macro(&actual_item),\n+                    self.sema.speculative_expand_attr_macro(\n+                        &actual_item,\n+                        &item_with_fake_ident,\n+                        fake_ident_token.clone(),\n+                    ),\n+                ) {\n+                    // maybe parent items have attributes, so continue walking the ancestors\n+                    (None, None) => continue 'ancestors,\n+                    // successful expansions\n+                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                        let new_offset = fake_mapped_token.text_range().start();\n+                        if new_offset > actual_expansion.text_range().end() {\n+                            // offset outside of bounds from the original expansion,\n+                            // stop here to prevent problems from happening\n+                            break 'expansion;\n+                        }\n+                        original_file = actual_expansion;\n+                        speculative_file = fake_expansion;\n+                        fake_ident_token = fake_mapped_token;\n+                        offset = new_offset;\n+                        continue 'expansion;\n+                    }\n+                    // exactly one expansion failed, inconsistent state so stop expanding completely\n+                    _ => break 'expansion,\n+                }\n+            }\n+\n+            // No attributes have been expanded, so look for macro_call! token trees or derive token trees\n+            let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n+                Some(it) => it,\n+                None => break 'expansion,\n+            };\n+            let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n+                Some(it) => it,\n+                None => break 'expansion,\n+            };\n+\n+            // Expand pseudo-derive expansion\n+            if let (Some(orig_attr), Some(spec_attr)) = (\n+                orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+                spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+            ) {\n+                if let (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) = (\n+                    self.sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n+                    self.sema.speculative_expand_derive_as_pseudo_attr_macro(\n+                        &orig_attr,\n+                        &spec_attr,\n+                        fake_ident_token.clone(),\n+                    ),\n+                ) {\n+                    derive_ctx = Some((\n+                        actual_expansion,\n+                        fake_expansion,\n+                        fake_mapped_token.text_range().start(),\n+                        orig_attr,\n+                    ));\n+                }\n+                // at this point we won't have any more successful expansions, so stop\n+                break 'expansion;\n+            }\n+\n+            // Expand fn-like macro calls\n+            if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n+                orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+                spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+            ) {\n+                let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n+                let mac_call_path1 =\n+                    macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n+\n+                // inconsistent state, stop expanding\n+                if mac_call_path0 != mac_call_path1 {\n+                    break 'expansion;\n+                }\n+                let speculative_args = match macro_call_with_fake_ident.token_tree() {\n+                    Some(tt) => tt,\n+                    None => break 'expansion,\n+                };\n+\n+                match (\n+                    self.sema.expand(&actual_macro_call),\n+                    self.sema.speculative_expand(\n+                        &actual_macro_call,\n+                        &speculative_args,\n+                        fake_ident_token.clone(),\n+                    ),\n+                ) {\n+                    // successful expansions\n+                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                        let new_offset = fake_mapped_token.text_range().start();\n+                        if new_offset > actual_expansion.text_range().end() {\n+                            // offset outside of bounds from the original expansion,\n+                            // stop here to prevent problems from happening\n+                            break 'expansion;\n+                        }\n+                        original_file = actual_expansion;\n+                        speculative_file = fake_expansion;\n+                        fake_ident_token = fake_mapped_token;\n+                        offset = new_offset;\n+                        continue 'expansion;\n+                    }\n+                    // at least on expansion failed, we won't have anything to expand from this point\n+                    // onwards so break out\n+                    _ => break 'expansion,\n+                }\n+            }\n+\n+            // none of our states have changed so stop the loop\n+            break 'expansion;\n+        }\n+\n+        self.fill(&original_file, speculative_file, offset, derive_ctx)\n+    }\n+\n+    /// Calculate the expected type and name of the cursor position.\n+    fn expected_type_and_name(&self) -> (Option<Type>, Option<NameOrNameRef>) {\n+        let mut node = match self.token.parent() {\n+            Some(it) => it,\n+            None => return (None, None),\n+        };\n+        loop {\n+            break match_ast! {\n+                match node {\n+                    ast::LetStmt(it) => {\n+                        cov_mark::hit!(expected_type_let_with_leading_char);\n+                        cov_mark::hit!(expected_type_let_without_leading_char);\n+                        let ty = it.pat()\n+                            .and_then(|pat| self.sema.type_of_pat(&pat))\n+                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)))\n+                            .map(TypeInfo::original);\n+                        let name = match it.pat() {\n+                            Some(ast::Pat::IdentPat(ident)) => ident.name().map(NameOrNameRef::Name),\n+                            Some(_) | None => None,\n+                        };\n+\n+                        (ty, name)\n+                    },\n+                    ast::LetExpr(it) => {\n+                        cov_mark::hit!(expected_type_if_let_without_leading_char);\n+                        let ty = it.pat()\n+                            .and_then(|pat| self.sema.type_of_pat(&pat))\n+                            .or_else(|| it.expr().and_then(|it| self.sema.type_of_expr(&it)))\n+                            .map(TypeInfo::original);\n+                        (ty, None)\n+                    },\n+                    ast::ArgList(_) => {\n+                        cov_mark::hit!(expected_type_fn_param);\n+                        ActiveParameter::at_token(\n+                            &self.sema,\n+                            self.token.clone(),\n+                        ).map(|ap| {\n+                            let name = ap.ident().map(NameOrNameRef::Name);\n+                            let ty = if has_ref(&self.token) {\n+                                cov_mark::hit!(expected_type_fn_param_ref);\n+                                ap.ty.remove_ref()\n+                            } else {\n+                                Some(ap.ty)\n+                            };\n+                            (ty, name)\n+                        })\n+                        .unwrap_or((None, None))\n+                    },\n+                    ast::RecordExprFieldList(it) => {\n+                        // wouldn't try {} be nice...\n+                        (|| {\n+                            if self.token.kind() == T![..]\n+                                || self.token.prev_token().map(|t| t.kind()) == Some(T![..])\n+                            {\n+                                cov_mark::hit!(expected_type_struct_func_update);\n+                                let record_expr = it.syntax().parent().and_then(ast::RecordExpr::cast)?;\n+                                let ty = self.sema.type_of_expr(&record_expr.into())?;\n+                                Some((\n+                                    Some(ty.original),\n+                                    None\n+                                ))\n+                            } else {\n+                                cov_mark::hit!(expected_type_struct_field_without_leading_char);\n+                                let expr_field = self.token.prev_sibling_or_token()?\n+                                    .into_node()\n+                                    .and_then(ast::RecordExprField::cast)?;\n+                                let (_, _, ty) = self.sema.resolve_record_field(&expr_field)?;\n+                                Some((\n+                                    Some(ty),\n+                                    expr_field.field_name().map(NameOrNameRef::NameRef),\n+                                ))\n+                            }\n+                        })().unwrap_or((None, None))\n+                    },\n+                    ast::RecordExprField(it) => {\n+                        if let Some(expr) = it.expr() {\n+                            cov_mark::hit!(expected_type_struct_field_with_leading_char);\n+                            (\n+                                self.sema.type_of_expr(&expr).map(TypeInfo::original),\n+                                it.field_name().map(NameOrNameRef::NameRef),\n+                            )\n+                        } else {\n+                            cov_mark::hit!(expected_type_struct_field_followed_by_comma);\n+                            let ty = self.sema.resolve_record_field(&it)\n+                                .map(|(_, _, ty)| ty);\n+                            (\n+                                ty,\n+                                it.field_name().map(NameOrNameRef::NameRef),\n+                            )\n+                        }\n+                    },\n+                    // match foo { $0 }\n+                    // match foo { ..., pat => $0 }\n+                    ast::MatchExpr(it) => {\n+                        let ty = if self.previous_token_is(T![=>]) {\n+                            // match foo { ..., pat => $0 }\n+                            cov_mark::hit!(expected_type_match_arm_body_without_leading_char);\n+                            cov_mark::hit!(expected_type_match_arm_body_with_leading_char);\n+                            self.sema.type_of_expr(&it.into())\n+                        } else {\n+                            // match foo { $0 }\n+                            cov_mark::hit!(expected_type_match_arm_without_leading_char);\n+                            it.expr().and_then(|e| self.sema.type_of_expr(&e))\n+                        }.map(TypeInfo::original);\n+                        (ty, None)\n+                    },\n+                    ast::IfExpr(it) => {\n+                        let ty = it.condition()\n+                            .and_then(|e| self.sema.type_of_expr(&e))\n+                            .map(TypeInfo::original);\n+                        (ty, None)\n+                    },\n+                    ast::IdentPat(it) => {\n+                        cov_mark::hit!(expected_type_if_let_with_leading_char);\n+                        cov_mark::hit!(expected_type_match_arm_with_leading_char);\n+                        let ty = self.sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::original);\n+                        (ty, None)\n+                    },\n+                    ast::Fn(it) => {\n+                        cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n+                        cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n+                        let def = self.sema.to_def(&it);\n+                        (def.map(|def| def.ret_type(self.db)), None)\n+                    },\n+                    ast::ClosureExpr(it) => {\n+                        let ty = self.sema.type_of_expr(&it.into());\n+                        ty.and_then(|ty| ty.original.as_callable(self.db))\n+                            .map(|c| (Some(c.return_type()), None))\n+                            .unwrap_or((None, None))\n+                    },\n+                    ast::ParamList(_) => (None, None),\n+                    ast::Stmt(_) => (None, None),\n+                    ast::Item(_) => (None, None),\n+                    _ => {\n+                        match node.parent() {\n+                            Some(n) => {\n+                                node = n;\n+                                continue;\n+                            },\n+                            None => (None, None),\n+                        }\n+                    },\n+                }\n+            };\n+        }\n+    }\n+\n+    /// Fill the completion context, this is what does semantic reasoning about the surrounding context\n+    /// of the completion location.\n+    fn fill(\n+        &mut self,\n+        original_file: &SyntaxNode,\n+        file_with_fake_ident: SyntaxNode,\n+        offset: TextSize,\n+        derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n+    ) -> Option<()> {\n+        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased()?;\n+        let syntax_element = NodeOrToken::Token(fake_ident_token);\n+        if is_in_token_of_for_loop(syntax_element.clone()) {\n+            // for pat $0\n+            // there is nothing to complete here except `in` keyword\n+            // don't bother populating the context\n+            // FIXME: the completion calculations should end up good enough\n+            // such that this special case becomes unnecessary\n+            return None;\n+        }\n+\n+        self.previous_token = previous_token(syntax_element.clone());\n+\n+        self.incomplete_let =\n+            syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n+                it.syntax().text_range().end() == syntax_element.text_range().end()\n+            });\n+\n+        (self.expected_type, self.expected_name) = self.expected_type_and_name();\n+\n+        // Overwrite the path kind for derives\n+        if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n+            self.existing_derives = self\n+                .sema\n+                .resolve_derive_macro(&origin_attr)\n+                .into_iter()\n+                .flatten()\n+                .flatten()\n+                .collect();\n+\n+            if let Some(ast::NameLike::NameRef(name_ref)) =\n+                find_node_at_offset(&file_with_fake_ident, offset)\n+            {\n+                let parent = name_ref.syntax().parent()?;\n+                let (mut nameref_ctx, _, _) =\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n+                if let Some(NameRefKind::Path(path_ctx)) = &mut nameref_ctx.kind {\n+                    path_ctx.kind = PathKind::Derive;\n+                }\n+                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n+                return Some(());\n+            }\n+            return None;\n+        }\n+\n+        let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n+            Some(it) => it,\n+            None => {\n+                if let Some(original) = ast::String::cast(self.original_token.clone()) {\n+                    self.ident_ctx = IdentContext::String {\n+                        original,\n+                        expanded: ast::String::cast(self.token.clone()),\n+                    };\n+                } else {\n+                    // Fix up trailing whitespace problem\n+                    // #[attr(foo = $0\n+                    let token = if self.token.kind() == SyntaxKind::WHITESPACE {\n+                        self.previous_token.as_ref()?\n+                    } else {\n+                        &self.token\n+                    };\n+                    let p = token.parent()?;\n+                    if p.kind() == SyntaxKind::TOKEN_TREE\n+                        && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+                    {\n+                        self.ident_ctx = IdentContext::UnexpandedAttrTT {\n+                            fake_attribute_under_caret: syntax_element\n+                                .ancestors()\n+                                .find_map(ast::Attr::cast),\n+                        };\n+                    } else {\n+                        return None;\n+                    }\n+                }\n+                return Some(());\n+            }\n+        };\n+        self.impl_def = self\n+            .sema\n+            .token_ancestors_with_macros(self.token.clone())\n+            .take_while(|it| it.kind() != SyntaxKind::SOURCE_FILE)\n+            .filter_map(ast::Item::cast)\n+            .take(2)\n+            .find_map(|it| match it {\n+                ast::Item::Impl(impl_) => Some(impl_),\n+                _ => None,\n+            });\n+        self.function_def = self\n+            .sema\n+            .token_ancestors_with_macros(self.token.clone())\n+            .take_while(|it| {\n+                it.kind() != SyntaxKind::SOURCE_FILE && it.kind() != SyntaxKind::MODULE\n+            })\n+            .filter_map(ast::Item::cast)\n+            .take(2)\n+            .find_map(|it| match it {\n+                ast::Item::Fn(fn_) => Some(fn_),\n+                _ => None,\n+            });\n+\n+        match name_like {\n+            ast::NameLike::Lifetime(lifetime) => {\n+                self.ident_ctx = IdentContext::Lifetime(Self::classify_lifetime(\n+                    &self.sema,\n+                    original_file,\n+                    lifetime,\n+                )?);\n+            }\n+            ast::NameLike::NameRef(name_ref) => {\n+                let parent = name_ref.syntax().parent()?;\n+                let (nameref_ctx, pat_ctx, qualifier_ctx) =\n+                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone());\n+\n+                self.qualifier_ctx = qualifier_ctx;\n+                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n+                self.pattern_ctx = pat_ctx;\n+            }\n+            ast::NameLike::Name(name) => {\n+                let (name_ctx, pat_ctx) = Self::classify_name(&self.sema, original_file, name)?;\n+                self.pattern_ctx = pat_ctx;\n+                self.ident_ctx = IdentContext::Name(name_ctx);\n+            }\n+        }\n+        Some(())\n+    }\n+\n+    fn classify_lifetime(\n+        _sema: &Semantics<RootDatabase>,\n+        original_file: &SyntaxNode,\n+        lifetime: ast::Lifetime,\n+    ) -> Option<LifetimeContext> {\n+        let parent = lifetime.syntax().parent()?;\n+        if parent.kind() == SyntaxKind::ERROR {\n+            return None;\n+        }\n+\n+        let kind = match_ast! {\n+            match parent {\n+                ast::LifetimeParam(param) => LifetimeKind::LifetimeParam {\n+                    is_decl: param.lifetime().as_ref() == Some(&lifetime),\n+                    param\n+                },\n+                ast::BreakExpr(_) => LifetimeKind::LabelRef,\n+                ast::ContinueExpr(_) => LifetimeKind::LabelRef,\n+                ast::Label(_) => LifetimeKind::LabelDef,\n+                _ => LifetimeKind::Lifetime,\n+            }\n+        };\n+        let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n+\n+        Some(LifetimeContext { lifetime, kind })\n+    }\n+\n+    fn classify_name(\n+        _sema: &Semantics<RootDatabase>,\n+        original_file: &SyntaxNode,\n+        name: ast::Name,\n+    ) -> Option<(NameContext, Option<PatternContext>)> {\n+        let parent = name.syntax().parent()?;\n+        let mut pat_ctx = None;\n+        let kind = match_ast! {\n+            match parent {\n+                ast::Const(_) => NameKind::Const,\n+                ast::ConstParam(_) => NameKind::ConstParam,\n+                ast::Enum(_) => NameKind::Enum,\n+                ast::Fn(_) => NameKind::Function,\n+                ast::IdentPat(bind_pat) => {\n+                    pat_ctx = Some({\n+                        let mut pat_ctx = pattern_context_for(original_file, bind_pat.into());\n+                        if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n+                            pat_ctx.record_pat = find_node_in_file_compensated(original_file, &record_field.parent_record_pat());\n+                        }\n+                        pat_ctx\n+                    });\n+\n+                    NameKind::IdentPat\n+                },\n+                ast::MacroDef(_) => NameKind::MacroDef,\n+                ast::MacroRules(_) => NameKind::MacroRules,\n+                ast::Module(module) => NameKind::Module(module),\n+                ast::RecordField(_) => NameKind::RecordField,\n+                ast::Rename(_) => NameKind::Rename,\n+                ast::SelfParam(_) => NameKind::SelfParam,\n+                ast::Static(_) => NameKind::Static,\n+                ast::Struct(_) => NameKind::Struct,\n+                ast::Trait(_) => NameKind::Trait,\n+                ast::TypeAlias(_) => NameKind::TypeAlias,\n+                ast::TypeParam(_) => NameKind::TypeParam,\n+                ast::Union(_) => NameKind::Union,\n+                ast::Variant(_) => NameKind::Variant,\n+                _ => return None,\n+            }\n+        };\n+        let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n+        Some((NameContext { name, kind }, pat_ctx))\n+    }\n+\n+    fn classify_name_ref(\n+        sema: &Semantics<RootDatabase>,\n+        original_file: &SyntaxNode,\n+        name_ref: ast::NameRef,\n+        parent: SyntaxNode,\n+    ) -> (NameRefContext, Option<PatternContext>, QualifierCtx) {\n+        let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n+\n+        let mut res = (NameRefContext { nameref, kind: None }, None, QualifierCtx::default());\n+        let (nameref_ctx, pattern_ctx, qualifier_ctx) = &mut res;\n+\n+        if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n+            nameref_ctx.kind =\n+                find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n+                    .map(NameRefKind::RecordExpr);\n+            return res;\n+        }\n+        if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n+            *pattern_ctx = Some(PatternContext {\n+                param_ctx: None,\n+                has_type_ascription: false,\n+                ref_token: None,\n+                mut_token: None,\n+                record_pat: find_node_in_file_compensated(\n+                    original_file,\n+                    &record_field.parent_record_pat(),\n+                ),\n+                ..pattern_context_for(\n+                    original_file,\n+                    record_field.parent_record_pat().clone().into(),\n+                )\n+            });\n+            return res;\n+        }\n+\n+        let segment = match_ast! {\n+            match parent {\n+                ast::PathSegment(segment) => segment,\n+                ast::FieldExpr(field) => {\n+                    let receiver = find_opt_node_in_file(original_file, field.expr());\n+                    let receiver_is_ambiguous_float_literal = match &receiver {\n+                        Some(ast::Expr::Literal(l)) => matches! {\n+                            l.kind(),\n+                            ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.text().ends_with('.'))\n+                        },\n+                        _ => false,\n+                    };\n+                    nameref_ctx.kind = Some(NameRefKind::DotAccess(DotAccess {\n+                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n+                        kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n+                        receiver\n+                    }));\n+                    return res;\n+                },\n+                ast::MethodCallExpr(method) => {\n+                    let receiver = find_opt_node_in_file(original_file, method.receiver());\n+                    nameref_ctx.kind = Some(NameRefKind::DotAccess(DotAccess {\n+                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n+                        kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n+                        receiver\n+                    }));\n+                    return res;\n+                },\n+                _ => return res,\n+            }\n+        };\n+\n+        let path = segment.parent_path();\n+        let mut path_ctx = PathCompletionCtx {\n+            has_call_parens: false,\n+            has_macro_bang: false,\n+            is_absolute_path: false,\n+            qualifier: None,\n+            parent: path.parent_path(),\n+            kind: PathKind::Item { kind: ItemListKind::SourceFile },\n+            has_type_args: false,\n+        };\n+\n+        let is_in_block = |it: &SyntaxNode| {\n+            it.parent()\n+                .map(|node| {\n+                    ast::ExprStmt::can_cast(node.kind()) || ast::StmtList::can_cast(node.kind())\n+                })\n+                .unwrap_or(false)\n+        };\n+        let func_update_record = |syn: &SyntaxNode| {\n+            if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n+                find_node_in_file_compensated(original_file, &record_expr)\n+            } else {\n+                None\n+            }\n+        };\n+        let after_if_expr = |node: SyntaxNode| {\n+            let prev_expr = (|| {\n+                let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n+                ast::ExprStmt::cast(prev_sibling)?.expr()\n+            })();\n+            matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n+        };\n+\n+        // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n+        // ex. trait Foo $0 {}\n+        // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n+        // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n+        // expression or an item list.\n+        // The following code checks if the body is missing, if it is we either cut off the body\n+        // from the item or it was missing in the first place\n+        let inbetween_body_and_decl_check = |node: SyntaxNode| {\n+            if let Some(NodeOrToken::Node(n)) =\n+                syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n+            {\n+                if let Some(item) = ast::Item::cast(n) {\n+                    let is_inbetween = match &item {\n+                        ast::Item::Const(it) => it.body().is_none(),\n+                        ast::Item::Enum(it) => it.variant_list().is_none(),\n+                        ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n+                        ast::Item::Fn(it) => it.body().is_none(),\n+                        ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n+                        ast::Item::Module(it) => it.item_list().is_none(),\n+                        ast::Item::Static(it) => it.body().is_none(),\n+                        ast::Item::Struct(it) => it.field_list().is_none(),\n+                        ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n+                        ast::Item::TypeAlias(it) => it.ty().is_none(),\n+                        ast::Item::Union(it) => it.record_field_list().is_none(),\n+                        _ => false,\n+                    };\n+                    if is_inbetween {\n+                        return Some(item);\n+                    }\n+                }\n+            }\n+            None\n+        };\n+\n+        let type_location = |it: Option<SyntaxNode>| {\n+            let parent = it?;\n+            let res = match_ast! {\n+                match parent {\n+                    ast::Const(it) => {\n+                        let name = find_opt_node_in_file(original_file, it.name())?;\n+                        let original = ast::Const::cast(name.syntax().parent()?)?;\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n+                    },\n+                    ast::RetType(it) => {\n+                        if it.thin_arrow_token().is_none() {\n+                            return None;\n+                        }\n+                        let parent = match ast::Fn::cast(parent.parent()?) {\n+                            Some(x) => x.param_list(),\n+                            None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n+                        };\n+\n+                        let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n+                            match parent {\n+                                ast::ClosureExpr(it) => {\n+                                    it.body()\n+                                },\n+                                ast::Fn(it) => {\n+                                    it.body().map(ast::Expr::BlockExpr)\n+                                },\n+                                _ => return None,\n+                            }\n+                        }))\n+                    },\n+                    ast::Param(it) => {\n+                        if it.colon_token().is_none() {\n+                            return None;\n+                        }\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n+                    },\n+                    ast::LetStmt(it) => {\n+                        if it.colon_token().is_none() {\n+                            return None;\n+                        }\n+                        TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n+                    },\n+                    ast::TypeBound(_) => TypeLocation::TypeBound,\n+                    // is this case needed?\n+                    ast::TypeBoundList(_) => TypeLocation::TypeBound,\n+                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n+                    // is this case needed?\n+                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, Some(it))),\n+                    ast::TupleField(_) => TypeLocation::TupleField,\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        };\n+\n+        // Infer the path kind\n+        let kind = path.syntax().parent().and_then(|it| {\n+            match_ast! {\n+                match it {\n+                    ast::PathType(it) => {\n+                        let location = type_location(it.syntax().parent());\n+                        Some(PathKind::Type {\n+                            location: location.unwrap_or(TypeLocation::Other),\n+                        })\n+                    },\n+                    ast::PathExpr(it) => {\n+                        if let Some(p) = it.syntax().parent() {\n+                            if ast::ExprStmt::can_cast(p.kind()) {\n+                                if let Some(kind) = inbetween_body_and_decl_check(p) {\n+                                    nameref_ctx.kind = Some(NameRefKind::Keyword(kind));\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+\n+                        path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+                        let in_block_expr = is_in_block(it.syntax());\n+                        let in_loop_body = is_in_loop_body(it.syntax());\n+                        let after_if_expr = after_if_expr(it.syntax().clone());\n+                        let ref_expr_parent = path.as_single_name_ref()\n+                            .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n+                        let is_func_update = func_update_record(it.syntax());\n+\n+                        Some(PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update })\n+                    },\n+                    ast::TupleStructPat(it) => {\n+                        path_ctx.has_call_parens = true;\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        Some(PathKind::Pat)\n+                    },\n+                    ast::RecordPat(it) => {\n+                        path_ctx.has_call_parens = true;\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        Some(PathKind::Pat)\n+                    },\n+                    ast::PathPat(it) => {\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        Some(PathKind::Pat)\n+                    },\n+                    ast::MacroCall(it) => {\n+                        if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n+                            nameref_ctx.kind = Some(NameRefKind::Keyword(kind));\n+                            return None;\n+                        }\n+\n+                        path_ctx.has_macro_bang = it.excl_token().is_some();\n+                        let parent = it.syntax().parent();\n+                        match parent.as_ref().map(|it| it.kind()) {\n+                            Some(SyntaxKind::MACRO_PAT) => Some(PathKind::Pat),\n+                            Some(SyntaxKind::MACRO_TYPE) => {\n+                                let location = type_location(parent.unwrap().parent());\n+                                Some(PathKind::Type {\n+                                    location: location.unwrap_or(TypeLocation::Other),\n+                                })\n+                            },\n+                            Some(SyntaxKind::ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::Module }),\n+                            Some(SyntaxKind::ASSOC_ITEM_LIST) => Some(PathKind::Item { kind: match parent.and_then(|it| it.parent()) {\n+                                Some(it) => match_ast! {\n+                                    match it {\n+                                        ast::Trait(_) => ItemListKind::Trait,\n+                                        ast::Impl(it) => if it.trait_().is_some() {\n+                                            ItemListKind::TraitImpl\n+                                        } else {\n+                                            ItemListKind::Impl\n+                                        },\n+                                        _ => return None\n+                                    }\n+                                },\n+                                None => return None,\n+                            } }),\n+                            Some(SyntaxKind::EXTERN_ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::ExternBlock }),\n+                            Some(SyntaxKind::SOURCE_FILE) => Some(PathKind::Item { kind: ItemListKind::SourceFile }),\n+                            _ => {\n+                               return parent.and_then(ast::MacroExpr::cast).map(|it| {\n+                                    let in_loop_body = is_in_loop_body(it.syntax());\n+                                    let in_block_expr = is_in_block(it.syntax());\n+                                    let after_if_expr = after_if_expr(it.syntax().clone());\n+                                    let ref_expr_parent = path.as_single_name_ref()\n+                                        .and_then(|_| it.syntax().parent()).and_then(ast::RefExpr::cast);\n+                                    let is_func_update = func_update_record(it.syntax());\n+                                    PathKind::Expr { in_block_expr, in_loop_body, after_if_expr, ref_expr_parent, is_func_update }\n+                                });\n+                            },\n+                        }\n+                    },\n+                    ast::Meta(meta) => (|| {\n+                        let attr = meta.parent_attr()?;\n+                        let kind = attr.kind();\n+                        let attached = attr.syntax().parent()?;\n+                        let is_trailing_outer_attr = kind != AttrKind::Inner\n+                            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n+                        let annotated_item_kind = if is_trailing_outer_attr {\n+                            None\n+                        } else {\n+                            Some(attached.kind())\n+                        };\n+                        Some(PathKind::Attr {\n+                            kind,\n+                            annotated_item_kind,\n+                        })\n+                    })(),\n+                    ast::Visibility(it) => Some(PathKind::Vis { has_in_token: it.in_token().is_some() }),\n+                    ast::UseTree(_) => Some(PathKind::Use),\n+                    _ => return None,\n+                }\n+            }\n+        });\n+\n+        match kind {\n+            Some(kind) => path_ctx.kind = kind,\n+            None => return res,\n+        }\n+        path_ctx.has_type_args = segment.generic_arg_list().is_some();\n+\n+        if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n+            if !use_tree_parent {\n+                path_ctx.is_absolute_path =\n+                    path.top_path().segment().map_or(false, |it| it.coloncolon_token().is_some());\n+            }\n+\n+            let path = path\n+                .segment()\n+                .and_then(|it| find_node_in_file(original_file, &it))\n+                .map(|it| it.parent_path());\n+            path_ctx.qualifier = path.map(|path| {\n+                let res = sema.resolve_path(&path);\n+                let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n+                    .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n+\n+                // `<_>::$0`\n+                let is_infer_qualifier = path.qualifier().is_none()\n+                    && matches!(\n+                        path.segment().and_then(|it| it.kind()),\n+                        Some(ast::PathSegmentKind::Type {\n+                            type_ref: Some(ast::Type::InferType(_)),\n+                            trait_ref: None,\n+                        })\n+                    );\n+\n+                PathQualifierCtx {\n+                    path,\n+                    resolution: res,\n+                    is_super_chain,\n+                    use_tree_parent,\n+                    is_infer_qualifier,\n+                }\n+            });\n+        } else if let Some(segment) = path.segment() {\n+            if segment.coloncolon_token().is_some() {\n+                path_ctx.is_absolute_path = true;\n+            }\n+        }\n+\n+        if path_ctx.is_trivial_path() {\n+            // fetch the full expression that may have qualifiers attached to it\n+            let top_node = match path_ctx.kind {\n+                PathKind::Expr { in_block_expr: true, .. } => {\n+                    parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n+                        let parent = p.parent()?;\n+                        if ast::StmtList::can_cast(parent.kind()) {\n+                            Some(p)\n+                        } else if ast::ExprStmt::can_cast(parent.kind()) {\n+                            Some(parent)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                PathKind::Item { .. } => {\n+                    parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+                }\n+                _ => None,\n+            };\n+            if let Some(top) = top_node {\n+                if let Some(NodeOrToken::Node(error_node)) =\n+                    syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n+                {\n+                    if error_node.kind() == SyntaxKind::ERROR {\n+                        qualifier_ctx.unsafe_tok = error_node\n+                            .children_with_tokens()\n+                            .filter_map(NodeOrToken::into_token)\n+                            .find(|it| it.kind() == T![unsafe]);\n+                        qualifier_ctx.vis_node =\n+                            error_node.children().find_map(ast::Visibility::cast);\n+                    }\n+                }\n+\n+                if let PathKind::Item { .. } = path_ctx.kind {\n+                    if qualifier_ctx.none() {\n+                        if let Some(t) = top.first_token() {\n+                            if let Some(prev) = t\n+                                .prev_token()\n+                                .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n+                            {\n+                                if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n+                                    // This was inferred to be an item position path, but it seems\n+                                    // to be part of some other broken node which leaked into an item\n+                                    // list, so return without setting the path context\n+                                    return res;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        nameref_ctx.kind = Some(NameRefKind::Path(path_ctx));\n+        res\n+    }\n+}\n+\n+fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternContext {\n+    let mut is_param = None;\n+    let (refutability, has_type_ascription) =\n+    pat\n+        .syntax()\n+        .ancestors()\n+        .skip_while(|it| ast::Pat::can_cast(it.kind()))\n+        .next()\n+        .map_or((PatternRefutability::Irrefutable, false), |node| {\n+            let refutability = match_ast! {\n+                match node {\n+                    ast::LetStmt(let_) => return (PatternRefutability::Irrefutable, let_.ty().is_some()),\n+                    ast::Param(param) => {\n+                        let has_type_ascription = param.ty().is_some();\n+                        is_param = (|| {\n+                            let fake_param_list = param.syntax().parent().and_then(ast::ParamList::cast)?;\n+                            let param_list = find_node_in_file_compensated(original_file, &fake_param_list)?;\n+                            let param_list_owner = param_list.syntax().parent()?;\n+                            let kind = match_ast! {\n+                                match param_list_owner {\n+                                    ast::ClosureExpr(closure) => ParamKind::Closure(closure),\n+                                    ast::Fn(fn_) => ParamKind::Function(fn_),\n+                                    _ => return None,\n+                                }\n+                            };\n+                            Some((param_list, param, kind))\n+                        })();\n+                        return (PatternRefutability::Irrefutable, has_type_ascription)\n+                    },\n+                    ast::MatchArm(_) => PatternRefutability::Refutable,\n+                    ast::LetExpr(_) => PatternRefutability::Refutable,\n+                    ast::ForExpr(_) => PatternRefutability::Irrefutable,\n+                    _ => PatternRefutability::Irrefutable,\n+                }\n+            };\n+            (refutability, false)\n+        });\n+    let (ref_token, mut_token) = match &pat {\n+        ast::Pat::IdentPat(it) => (it.ref_token(), it.mut_token()),\n+        _ => (None, None),\n+    };\n+    PatternContext {\n+        refutability,\n+        param_ctx: is_param,\n+        has_type_ascription,\n+        parent_pat: pat.syntax().parent().and_then(ast::Pat::cast),\n+        mut_token,\n+        ref_token,\n+        record_pat: None,\n+    }\n+}\n+\n+/// Attempts to find `node` inside `syntax` via `node`'s text range.\n+/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n+fn find_opt_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: Option<N>) -> Option<N> {\n+    find_node_in_file(syntax, &node?)\n+}\n+\n+/// Attempts to find `node` inside `syntax` via `node`'s text range.\n+/// If the fake identifier has been inserted after this node or inside of this node use the `_compensated` version instead.\n+fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n+    let syntax_range = syntax.text_range();\n+    let range = node.syntax().text_range();\n+    let intersection = range.intersect(syntax_range)?;\n+    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n+}\n+\n+/// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n+/// for the offset introduced by the fake ident.\n+/// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n+fn find_node_in_file_compensated<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n+    let syntax_range = syntax.text_range();\n+    let range = node.syntax().text_range();\n+    let end = range.end().checked_sub(TextSize::try_from(COMPLETION_MARKER.len()).ok()?)?;\n+    if end < range.start() {\n+        return None;\n+    }\n+    let range = TextRange::new(range.start(), end);\n+    // our inserted ident could cause `range` to go outside of the original syntax, so cap it\n+    let intersection = range.intersect(syntax_range)?;\n+    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n+}\n+\n+/// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n+/// for the offset introduced by the fake ident..\n+/// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n+fn find_opt_node_in_file_compensated<N: AstNode>(\n+    syntax: &SyntaxNode,\n+    node: Option<N>,\n+) -> Option<N> {\n+    find_node_in_file_compensated(syntax, &node?)\n+}\n+\n+fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n+    if let Some(qual) = path.qualifier() {\n+        return Some((qual, false));\n+    }\n+    let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+    let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n+    Some((use_tree.path()?, true))\n+}\n+\n+fn has_ref(token: &SyntaxToken) -> bool {\n+    let mut token = token.clone();\n+    for skip in [SyntaxKind::IDENT, SyntaxKind::WHITESPACE, T![mut]] {\n+        if token.kind() == skip {\n+            token = match token.prev_token() {\n+                Some(it) => it,\n+                None => return false,\n+            }\n+        }\n+    }\n+    token.kind() == T![&]\n+}\n+\n+pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n+    element.into_token().and_then(previous_non_trivia_token)\n+}\n+\n+pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n+    // oh my ...\n+    (|| {\n+        let syntax_token = element.into_token()?;\n+        let range = syntax_token.text_range();\n+        let for_expr = syntax_token.parent_ancestors().find_map(ast::ForExpr::cast)?;\n+\n+        // check if the current token is the `in` token of a for loop\n+        if let Some(token) = for_expr.in_token() {\n+            return Some(syntax_token == token);\n+        }\n+        let pat = for_expr.pat()?;\n+        if range.end() < pat.syntax().text_range().end() {\n+            // if we are inside or before the pattern we can't be at the `in` token position\n+            return None;\n+        }\n+        let next_sibl = next_non_trivia_sibling(pat.syntax().clone().into())?;\n+        Some(match next_sibl {\n+            // the loop body is some node, if our token is at the start we are at the `in` position,\n+            // otherwise we could be in a recovered expression, we don't wanna ruin completions there\n+            syntax::NodeOrToken::Node(n) => n.text_range().start() == range.start(),\n+            // the loop body consists of a single token, if we are this we are certainly at the `in` token position\n+            syntax::NodeOrToken::Token(t) => t == syntax_token,\n+        })\n+    })()\n+    .unwrap_or(false)\n+}\n+\n+#[test]\n+fn test_for_is_prev2() {\n+    crate::tests::check_pattern_is_applicable(r\"fn __() { for i i$0 }\", is_in_token_of_for_loop);\n+}\n+\n+pub(crate) fn is_in_loop_body(node: &SyntaxNode) -> bool {\n+    node.ancestors()\n+        .take_while(|it| it.kind() != SyntaxKind::FN && it.kind() != SyntaxKind::CLOSURE_EXPR)\n+        .find_map(|it| {\n+            let loop_body = match_ast! {\n+                match it {\n+                    ast::ForExpr(it) => it.loop_body(),\n+                    ast::WhileExpr(it) => it.loop_body(),\n+                    ast::LoopExpr(it) => it.loop_body(),\n+                    _ => None,\n+                }\n+            };\n+            loop_body.filter(|it| it.syntax().text_range().contains_range(node.text_range()))\n+        })\n+        .is_some()\n+}\n+\n+fn previous_non_trivia_token(token: SyntaxToken) -> Option<SyntaxToken> {\n+    let mut token = token.prev_token();\n+    while let Some(inner) = token {\n+        if !inner.kind().is_trivia() {\n+            return Some(inner);\n+        } else {\n+            token = inner.prev_token();\n+        }\n+    }\n+    None\n+}\n+\n+fn next_non_trivia_sibling(ele: SyntaxElement) -> Option<SyntaxElement> {\n+    let mut e = ele.next_sibling_or_token();\n+    while let Some(inner) = e {\n+        if !inner.kind().is_trivia() {\n+            return Some(inner);\n+        } else {\n+            e = inner.next_sibling_or_token();\n+        }\n+    }\n+    None\n+}"}, {"sha": "ce9357270b126986bd807adf25e3768fbb974e9b", "filename": "crates/ide-completion/src/context/tests.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=a69b17be2eb981e8172bada48eb1593172528654", "patch": "@@ -0,0 +1,393 @@\n+use expect_test::{expect, Expect};\n+use hir::HirDisplay;\n+\n+use crate::{\n+    context::CompletionContext,\n+    tests::{position, TEST_CONFIG},\n+};\n+\n+fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n+    let (db, pos) = position(ra_fixture);\n+    let config = TEST_CONFIG;\n+    let completion_context = CompletionContext::new(&db, pos, &config).unwrap();\n+\n+    let ty = completion_context\n+        .expected_type\n+        .map(|t| t.display_test(&db).to_string())\n+        .unwrap_or(\"?\".to_owned());\n+\n+    let name =\n+        completion_context.expected_name.map_or_else(|| \"?\".to_owned(), |name| name.to_string());\n+\n+    expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n+}\n+\n+#[test]\n+fn expected_type_let_without_leading_char() {\n+    cov_mark::check!(expected_type_let_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let x: u32 = $0;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_let_with_leading_char() {\n+    cov_mark::check!(expected_type_let_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let x: u32 = c$0;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_let_pat() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let x$0 = 0u32;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let $0 = 0u32;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_fn_param() {\n+    cov_mark::check!(expected_type_fn_param);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar($0); }\n+fn bar(x: u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(c$0); }\n+fn bar(x: u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_fn_param_ref() {\n+    cov_mark::check!(expected_type_fn_param_ref);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&$0); }\n+fn bar(x: &u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&mut $0); }\n+fn bar(x: &mut u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(& c$0); }\n+fn bar(x: &u32) {}\n+        \"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&mut c$0); }\n+fn bar(x: &mut u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&c$0); }\n+fn bar(x: &u32) {}\n+        \"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_struct_field_without_leading_char() {\n+    cov_mark::check!(expected_type_struct_field_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: $0 };\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_struct_field_followed_by_comma() {\n+    cov_mark::check!(expected_type_struct_field_followed_by_comma);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: $0, };\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_generic_struct_field() {\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo<T> { a: T }\n+fn foo() -> Foo<u32> {\n+    Foo { a: $0 }\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_struct_field_with_leading_char() {\n+    cov_mark::check!(expected_type_struct_field_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: c$0 };\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_arm_without_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { $0 }\n+}\n+\"#,\n+        expect![[r#\"ty: E, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_arm_with_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { c$0 }\n+}\n+\"#,\n+        expect![[r#\"ty: E, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_arm_body_without_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_body_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo;\n+enum E { X }\n+fn foo() -> Foo {\n+   match E::X { E::X => $0 }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_body_arm_with_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_body_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo;\n+enum E { X }\n+fn foo() -> Foo {\n+   match E::X { E::X => c$0 }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_if_let_without_leading_char() {\n+    cov_mark::check!(expected_type_if_let_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let $0 = f { }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_if_let_with_leading_char() {\n+    cov_mark::check!(expected_type_if_let_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let c$0 = f { }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_fn_ret_without_leading_char() {\n+    cov_mark::check!(expected_type_fn_ret_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() -> u32 {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_fn_ret_with_leading_char() {\n+    cov_mark::check!(expected_type_fn_ret_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() -> u32 {\n+    c$0\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_fn_ret_fn_ref_fully_typed() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() -> u32 {\n+    foo$0\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_closure_param_return() {\n+    // FIXME: make this work with `|| $0`\n+    check_expected_type_and_name(\n+        r#\"\n+//- minicore: fn\n+fn foo() {\n+    bar(|| a$0);\n+}\n+\n+fn bar(f: impl FnOnce() -> u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_generic_function() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    bar::<u32>($0);\n+}\n+\n+fn bar<T>(t: T) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: t\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_generic_method() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    S(1u32).bar($0);\n+}\n+\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn bar(self, t: T) {}\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: t\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_functional_update() {\n+    cov_mark::check!(expected_type_struct_func_update);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { field: u32 }\n+fn foo() {\n+    Foo {\n+        ..$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_param_pat() {\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { field: u32 }\n+fn foo(a$0: Foo) {}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { field: u32 }\n+fn foo($0: Foo) {}\n+\"#,\n+        // FIXME make this work, currently fails due to pattern recovery eating the `:`\n+        expect![[r#\"ty: ?, name: ?\"#]],\n+    );\n+}"}, {"sha": "f53c5f6747ae28e91c59543166a50b848f122f4f", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a69b17be2eb981e8172bada48eb1593172528654/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=a69b17be2eb981e8172bada48eb1593172528654", "patch": "@@ -4,7 +4,6 @@ mod completions;\n mod config;\n mod context;\n mod item;\n-mod patterns;\n mod render;\n \n #[cfg(test)]"}, {"sha": "9efb42c4de75813836f739612513d53a09343118", "filename": "crates/ide-completion/src/patterns.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6269137760988863cb7438c2bb4e5cf69a263e9d/crates%2Fide-completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fpatterns.rs?ref=6269137760988863cb7438c2bb4e5cf69a263e9d", "patch": "@@ -1,93 +0,0 @@\n-//! Patterns telling us certain facts about current syntax element, they are used in completion context\n-//!\n-//! Most logic in this module first expands the token below the cursor to a maximum node that acts similar to the token itself.\n-//! This means we for example expand a NameRef token to its outermost Path node, as semantically these act in the same location\n-//! and the completions usually query for path specific things on the Path context instead. This simplifies some location handling.\n-\n-use syntax::{\n-    ast::{self, HasLoopBody},\n-    match_ast, AstNode, SyntaxElement,\n-    SyntaxKind::*,\n-    SyntaxNode, SyntaxToken,\n-};\n-\n-#[cfg(test)]\n-use crate::tests::check_pattern_is_applicable;\n-\n-pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n-    element.into_token().and_then(previous_non_trivia_token)\n-}\n-\n-pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n-    // oh my ...\n-    (|| {\n-        let syntax_token = element.into_token()?;\n-        let range = syntax_token.text_range();\n-        let for_expr = syntax_token.parent_ancestors().find_map(ast::ForExpr::cast)?;\n-\n-        // check if the current token is the `in` token of a for loop\n-        if let Some(token) = for_expr.in_token() {\n-            return Some(syntax_token == token);\n-        }\n-        let pat = for_expr.pat()?;\n-        if range.end() < pat.syntax().text_range().end() {\n-            // if we are inside or before the pattern we can't be at the `in` token position\n-            return None;\n-        }\n-        let next_sibl = next_non_trivia_sibling(pat.syntax().clone().into())?;\n-        Some(match next_sibl {\n-            // the loop body is some node, if our token is at the start we are at the `in` position,\n-            // otherwise we could be in a recovered expression, we don't wanna ruin completions there\n-            syntax::NodeOrToken::Node(n) => n.text_range().start() == range.start(),\n-            // the loop body consists of a single token, if we are this we are certainly at the `in` token position\n-            syntax::NodeOrToken::Token(t) => t == syntax_token,\n-        })\n-    })()\n-    .unwrap_or(false)\n-}\n-\n-#[test]\n-fn test_for_is_prev2() {\n-    check_pattern_is_applicable(r\"fn __() { for i i$0 }\", is_in_token_of_for_loop);\n-}\n-\n-pub(crate) fn is_in_loop_body(node: &SyntaxNode) -> bool {\n-    node.ancestors()\n-        .take_while(|it| it.kind() != FN && it.kind() != CLOSURE_EXPR)\n-        .find_map(|it| {\n-            let loop_body = match_ast! {\n-                match it {\n-                    ast::ForExpr(it) => it.loop_body(),\n-                    ast::WhileExpr(it) => it.loop_body(),\n-                    ast::LoopExpr(it) => it.loop_body(),\n-                    _ => None,\n-                }\n-            };\n-            loop_body.filter(|it| it.syntax().text_range().contains_range(node.text_range()))\n-        })\n-        .is_some()\n-}\n-\n-fn previous_non_trivia_token(token: SyntaxToken) -> Option<SyntaxToken> {\n-    let mut token = token.prev_token();\n-    while let Some(inner) = token {\n-        if !inner.kind().is_trivia() {\n-            return Some(inner);\n-        } else {\n-            token = inner.prev_token();\n-        }\n-    }\n-    None\n-}\n-\n-fn next_non_trivia_sibling(ele: SyntaxElement) -> Option<SyntaxElement> {\n-    let mut e = ele.next_sibling_or_token();\n-    while let Some(inner) = e {\n-        if !inner.kind().is_trivia() {\n-            return Some(inner);\n-        } else {\n-            e = inner.next_sibling_or_token();\n-        }\n-    }\n-    None\n-}"}]}