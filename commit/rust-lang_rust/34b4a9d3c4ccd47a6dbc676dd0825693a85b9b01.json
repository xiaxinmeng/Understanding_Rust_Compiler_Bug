{"sha": "34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YjRhOWQzYzRjY2Q0N2E2ZGJjNjc2ZGQwODI1NjkzYTg1YjliMDE=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-03T09:54:41Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-03T09:54:41Z"}, "message": "Add struct_field_align_threshold for vertical alignment", "tree": {"sha": "0fc7c979ffadddb29a473248c6439fa680bde187", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fc7c979ffadddb29a473248c6439fa680bde187"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "html_url": "https://github.com/rust-lang/rust/commit/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd991851c86c2475d703b08bed6742253d4bb8d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd991851c86c2475d703b08bed6742253d4bb8d9", "html_url": "https://github.com/rust-lang/rust/commit/bd991851c86c2475d703b08bed6742253d4bb8d9"}], "stats": {"total": 683, "additions": 512, "deletions": 171}, "files": [{"sha": "5de757a91685998ab6d0fff1c6ee1311308cdb8f", "filename": "Configurations.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "patch": "@@ -1209,6 +1209,33 @@ fn lorem<T: Eq>(t: T) {\n \n See also: [`space_before_bound`](#space_before_bound).\n \n+## `struct_field_align_threshold`\n+\n+The maximum diff of width between struct fields to be aligned with each other.\n+\n+- **Default value** : 0\n+- **Possible values**: any positive integer\n+\n+#### `0`:\n+\n+```rust\n+struct Foo {\n+    x: u32,\n+    yy: u32,\n+    zzz: u32,\n+}\n+```\n+\n+#### `20`:\n+\n+```rust\n+struct Foo {\n+    x:   u32,\n+    yy:  u32,\n+    zzz: u32,\n+}\n+```\n+\n ## `space_after_struct_lit_field_colon`\n \n Leave a space after the colon in a struct literal field"}, {"sha": "bc00fd176cf0a97f0f34a48b042f1587e518f9b4", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "patch": "@@ -598,7 +598,9 @@ create_config! {\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n     condense_wildcard_suffixes: bool, false, \"Replace strings of _ wildcards by a single .. in \\\n                                               tuple patterns\";\n-    combine_control_expr: bool, true, \"Combine control expressions with funciton calls.\"\n+    combine_control_expr: bool, true, \"Combine control expressions with funciton calls.\";\n+    struct_field_align_threshold: usize, 0, \"Align struct fields if their diffs fits within \\\n+                                             threshold.\"\n }\n \n #[cfg(test)]"}, {"sha": "d9d20b1092cbdcc80db6005084a36c9e515fc6a7", "filename": "src/expr.rs", "status": "modified", "additions": 88, "deletions": 44, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "patch": "@@ -30,6 +30,7 @@ use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n use macros::{rewrite_macro, MacroPosition};\n use patterns::{TuplePatField, can_be_overflowed_pat};\n+use vertical::rewrite_with_alignment;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos};\n@@ -2528,6 +2529,14 @@ fn rewrite_index(\n     ))\n }\n \n+fn struct_lit_can_be_aligned(fields: &[ast::Field], base: &Option<&ast::Expr>) -> bool {\n+    if base.is_some() {\n+        return false;\n+    }\n+\n+    fields.iter().all(|field| !field.is_shorthand)\n+}\n+\n fn rewrite_struct_lit<'a>(\n     context: &RewriteContext,\n     path: &ast::Path,\n@@ -2557,50 +2566,71 @@ fn rewrite_struct_lit<'a>(\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n-    let field_iter = fields\n-        .into_iter()\n-        .map(StructLitField::Regular)\n-        .chain(base.into_iter().map(StructLitField::Base));\n-\n     // Foo { a: Foo } - indent is +3, width is -5.\n     let (h_shape, v_shape) = try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, 2));\n \n-    let span_lo = |item: &StructLitField| match *item {\n-        StructLitField::Regular(field) => field.span.lo,\n-        StructLitField::Base(expr) => {\n-            let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n-            let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n-            let pos = snippet.find_uncommented(\"..\").unwrap();\n-            last_field_hi + BytePos(pos as u32)\n-        }\n-    };\n-    let span_hi = |item: &StructLitField| match *item {\n-        StructLitField::Regular(field) => field.span.hi,\n-        StructLitField::Base(expr) => expr.span.hi,\n-    };\n-    let rewrite = |item: &StructLitField| match *item {\n-        StructLitField::Regular(field) => {\n-            // The 1 taken from the v_budget is for the comma.\n-            rewrite_field(context, field, try_opt!(v_shape.sub_width(1)))\n-        }\n-        StructLitField::Base(expr) => {\n-            // 2 = ..\n-            expr.rewrite(context, try_opt!(v_shape.shrink_left(2)))\n-                .map(|s| format!(\"..{}\", s))\n-        }\n+    let one_line_width = h_shape.map_or(0, |shape| shape.width);\n+    let body_lo = context.codemap.span_after(span, \"{\");\n+    let fields_str = if struct_lit_can_be_aligned(fields, &base) &&\n+        context.config.struct_field_align_threshold() > 0\n+    {\n+        try_opt!(rewrite_with_alignment(\n+            fields,\n+            context,\n+            shape,\n+            mk_sp(body_lo, span.hi),\n+            one_line_width,\n+        ))\n+    } else {\n+        let field_iter = fields\n+            .into_iter()\n+            .map(StructLitField::Regular)\n+            .chain(base.into_iter().map(StructLitField::Base));\n+\n+        let span_lo = |item: &StructLitField| match *item {\n+            StructLitField::Regular(field) => field.span().lo,\n+            StructLitField::Base(expr) => {\n+                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let pos = snippet.find_uncommented(\"..\").unwrap();\n+                last_field_hi + BytePos(pos as u32)\n+            }\n+        };\n+        let span_hi = |item: &StructLitField| match *item {\n+            StructLitField::Regular(field) => field.span().hi,\n+            StructLitField::Base(expr) => expr.span.hi,\n+        };\n+        let rewrite = |item: &StructLitField| match *item {\n+            StructLitField::Regular(field) => {\n+                // The 1 taken from the v_budget is for the comma.\n+                rewrite_field(context, field, try_opt!(v_shape.sub_width(1)), 0)\n+            }\n+            StructLitField::Base(expr) => {\n+                // 2 = ..\n+                expr.rewrite(context, try_opt!(v_shape.shrink_left(2)))\n+                    .map(|s| format!(\"..{}\", s))\n+            }\n+        };\n+\n+        let items = itemize_list(\n+            context.codemap,\n+            field_iter,\n+            \"}\",\n+            span_lo,\n+            span_hi,\n+            rewrite,\n+            body_lo,\n+            span.hi,\n+        );\n+        let item_vec = items.collect::<Vec<_>>();\n+\n+        let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n+        let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n+        let fmt = struct_lit_formatting(nested_shape, tactic, context, base.is_some());\n+\n+        try_opt!(write_list(&item_vec, &fmt))\n     };\n \n-    let items = itemize_list(\n-        context.codemap,\n-        field_iter,\n-        \"}\",\n-        span_lo,\n-        span_hi,\n-        rewrite,\n-        context.codemap.span_after(span, \"{\"),\n-        span.hi,\n-    );\n-    let item_vec = items.collect::<Vec<_>>();\n     let fields_str = wrap_struct_field(context, &fields_str, shape, v_shape, one_line_width);\n     Some(format!(\"{} {{{}}}\", path_str, fields_str))\n \n@@ -2639,18 +2669,32 @@ pub fn struct_lit_field_separator(config: &Config) -> &str {\n     )\n }\n \n-fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) -> Option<String> {\n+pub fn rewrite_field(\n+    context: &RewriteContext,\n+    field: &ast::Field,\n+    shape: Shape,\n+    prefix_max_width: usize,\n+) -> Option<String> {\n+    if contains_skip(&field.attrs) {\n+        return wrap_str(\n+            context.snippet(field.span()),\n+            context.config.max_width(),\n+            shape,\n+        );\n+    }\n     let name = &field.ident.node.to_string();\n     if field.is_shorthand {\n         Some(name.to_string())\n     } else {\n-        let separator = struct_lit_field_separator(context.config);\n+        let mut separator = String::from(struct_lit_field_separator(context.config));\n+        for _ in 0..prefix_max_width.checked_sub(name.len()).unwrap_or(0) {\n+            separator.push(' ');\n+        }\n         let overhead = name.len() + separator.len();\n-        let mut expr_shape = try_opt!(shape.sub_width(overhead));\n-        expr_shape.offset += overhead;\n+        let expr_shape = try_opt!(shape.offset_left(overhead));\n         let expr = field.expr.rewrite(context, expr_shape);\n \n-        let mut attrs_str = try_opt!((*field.attrs).rewrite(context, shape));\n+        let mut attrs_str = try_opt!(field.attrs.rewrite(context, shape));\n         if !attrs_str.is_empty() {\n             attrs_str.push_str(&format!(\"\\n{}\", shape.indent.to_string(context.config)));\n         };"}, {"sha": "0e8c10ea1815cefbfa08bd0c584c4544dfdb7292", "filename": "src/items.rs", "status": "modified", "additions": 122, "deletions": 126, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "patch": "@@ -23,6 +23,7 @@ use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n use config::{Config, IndentStyle, Density, ReturnIndent, BraceStyle, Style};\n use types::join_bounds;\n+use vertical::rewrite_with_alignment;\n \n use syntax::{ast, abi, ptr, symbol};\n use syntax::codemap::{Span, BytePos};\n@@ -1100,49 +1101,14 @@ fn format_struct_struct(\n         return Some(result);\n     }\n \n-    let item_indent = offset.block_indent(context.config);\n-    // 1 = \",\"\n-    let item_budget = try_opt!(\n-        context\n-            .config\n-            .max_width()\n-            .checked_sub(item_indent.width() + 1)\n-    );\n-\n-    let items = itemize_list(\n-        context.codemap,\n-        fields.iter(),\n-        \"}\",\n-        |field| {\n-            // Include attributes and doc comments, if present\n-            if !field.attrs.is_empty() {\n-                field.attrs[0].span.lo\n-            } else {\n-                field.span.lo\n-            }\n-        },\n-        |field| field.ty.span.hi,\n-        |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n-        context.codemap.span_after(span, \"{\"),\n-        span.hi,\n-    ).collect::<Vec<_>>();\n-    // 1 = ,\n-    let budget = context.config.max_width() - offset.width() + context.config.tab_spaces() - 1;\n-\n-    let tactic = match one_line_width {\n-        Some(w) => definitive_tactic(&items, ListTactic::LimitedHorizontalVertical(w), budget),\n-        None => DefinitiveListTactic::Vertical,\n-    };\n+    let items_str = try_opt!(rewrite_with_alignment(\n+        fields,\n+        context,\n+        Shape::indented(offset, context.config),\n+        mk_sp(body_lo, span.hi),\n+        one_line_width.unwrap_or(0),\n+    ));\n \n-    let fmt = ListFormatting {\n-        tactic: tactic,\n-        separator: \",\",\n-        trailing_separator: context.config.trailing_comma(),\n-        shape: Shape::legacy(budget, item_indent),\n-        ends_with_newline: true,\n-        config: context.config,\n-    };\n-    let items_str = try_opt!(write_list(&items, &fmt));\n     if one_line_width.is_some() && !items_str.contains('\\n') {\n         Some(format!(\"{} {} }}\", result, items_str))\n     } else {\n@@ -1257,7 +1223,9 @@ fn format_tuple_struct(\n                 }\n             },\n             |field| field.ty.span.hi,\n-            |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n+            |field| {\n+                rewrite_struct_field(context, field, Shape::legacy(item_budget, item_indent), 0)\n+            },\n             context.codemap.span_after(span, \"(\"),\n             span.hi,\n         );\n@@ -1430,97 +1398,125 @@ fn rewrite_missing_comment_on_field(\n     }\n }\n \n-impl Rewrite for ast::StructField {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        if contains_skip(&self.attrs) {\n-            let span = context.snippet(mk_sp(self.attrs[0].span.lo, self.span.hi));\n-            return wrap_str(span, context.config.max_width(), shape);\n+pub fn rewrite_struct_field_prefix(\n+    context: &RewriteContext,\n+    field: &ast::StructField,\n+    shape: Shape,\n+) -> Option<String> {\n+    let vis = format_visibility(&field.vis);\n+    let mut attr_str = try_opt!(\n+        field\n+            .attrs\n+            .rewrite(context, Shape::indented(shape.indent, context.config))\n+    );\n+    // Try format missing comments after attributes\n+    let missing_comment = if !field.attrs.is_empty() {\n+        rewrite_missing_comment_on_field(\n+            context,\n+            shape,\n+            field.attrs[field.attrs.len() - 1].span.hi,\n+            field.span.lo,\n+            &mut attr_str,\n+        ).unwrap_or(String::new())\n+    } else {\n+        String::new()\n+    };\n+\n+    let type_annotation_spacing = type_annotation_spacing(context.config);\n+    Some(match field.ident {\n+        Some(name) => {\n+            format!(\n+                \"{}{}{}{}{}:\",\n+                attr_str,\n+                missing_comment,\n+                vis,\n+                name,\n+                type_annotation_spacing.0\n+            )\n         }\n+        None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n+    })\n+}\n \n-        let name = self.ident;\n-        let vis = format_visibility(&self.vis);\n-        let mut attr_str = try_opt!(\n-            self.attrs\n-                .rewrite(context, Shape::indented(shape.indent, context.config))\n-        );\n-        // Try format missing comments after attributes\n-        let missing_comment = if !self.attrs.is_empty() {\n-            rewrite_missing_comment_on_field(\n-                context,\n-                shape,\n-                self.attrs[self.attrs.len() - 1].span.hi,\n-                self.span.lo,\n-                &mut attr_str,\n-            ).unwrap_or(String::new())\n-        } else {\n-            String::new()\n-        };\n+fn rewrite_struct_field_type(\n+    context: &RewriteContext,\n+    last_line_width: usize,\n+    field: &ast::StructField,\n+    spacing: &str,\n+    shape: Shape,\n+) -> Option<String> {\n+    let ty_shape = try_opt!(shape.offset_left(last_line_width + spacing.len()));\n+    field\n+        .ty\n+        .rewrite(context, ty_shape)\n+        .map(|ty| format!(\"{}{}\", spacing, ty))\n+}\n \n-        let type_annotation_spacing = type_annotation_spacing(context.config);\n-        let mut result = match name {\n-            Some(name) => {\n-                format!(\n-                    \"{}{}{}{}{}:\",\n-                    attr_str,\n-                    missing_comment,\n-                    vis,\n-                    name,\n-                    type_annotation_spacing.0\n-                )\n-            }\n-            None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n-        };\n \n-        let type_offset = shape.indent.block_indent(context.config);\n-        let rewrite_type_in_next_line = || {\n-            self.ty\n-                .rewrite(context, Shape::indented(type_offset, context.config))\n-        };\n+pub fn rewrite_struct_field(\n+    context: &RewriteContext,\n+    field: &ast::StructField,\n+    shape: Shape,\n+    lhs_max_width: usize,\n+) -> Option<String> {\n+    if contains_skip(&field.attrs) {\n+        let span = context.snippet(mk_sp(field.attrs[0].span.lo, field.span.hi));\n+        return wrap_str(span, context.config.max_width(), shape);\n+    }\n \n-        let last_line_width = last_line_width(&result) + type_annotation_spacing.1.len();\n-        let budget = try_opt!(shape.width.checked_sub(last_line_width));\n-        let ty_rewritten = self.ty.rewrite(\n-            context,\n-            Shape::legacy(budget, shape.indent + last_line_width),\n-        );\n-        match ty_rewritten {\n-            Some(ref ty) if ty.contains('\\n') => {\n-                let new_ty = rewrite_type_in_next_line();\n-                match new_ty {\n-                    Some(ref new_ty)\n-                        if !new_ty.contains('\\n') &&\n-                               new_ty.len() + type_offset.width() <= context.config.max_width() => {\n-                        Some(format!(\n-                            \"{}\\n{}{}\",\n-                            result,\n-                            type_offset.to_string(&context.config),\n-                            &new_ty\n-                        ))\n-                    }\n-                    _ => {\n-                        if name.is_some() {\n-                            result.push_str(type_annotation_spacing.1);\n-                        }\n-                        Some(result + &ty)\n-                    }\n-                }\n-            }\n-            Some(ty) => {\n-                if name.is_some() {\n-                    result.push_str(type_annotation_spacing.1);\n+    let type_annotation_spacing = type_annotation_spacing(context.config);\n+    let prefix = try_opt!(rewrite_struct_field_prefix(context, field, shape));\n+\n+    // Try to put everything on a single line.\n+    let last_line_width = last_line_width(&prefix);\n+    let mut spacing = String::from(if field.ident.is_some() {\n+        type_annotation_spacing.1\n+    } else {\n+        \"\"\n+    });\n+    let lhs_offset = lhs_max_width.checked_sub(last_line_width).unwrap_or(0);\n+    for _ in 0..lhs_offset {\n+        spacing.push(' ');\n+    }\n+    let ty_rewritten = rewrite_struct_field_type(context, last_line_width, field, &spacing, shape);\n+    if let Some(ref ty) = ty_rewritten {\n+        if !ty.contains('\\n') {\n+            return Some(prefix + &ty);\n+        }\n+    }\n+\n+    // We must use multiline.\n+    let type_offset = shape.indent.block_indent(context.config);\n+    let rewrite_type_in_next_line = || {\n+        field\n+            .ty\n+            .rewrite(context, Shape::indented(type_offset, context.config))\n+    };\n+\n+    match ty_rewritten {\n+        // If we start from the next line and type fits in a single line, then do so.\n+        Some(ref ty) => {\n+            match rewrite_type_in_next_line() {\n+                Some(ref new_ty) if !new_ty.contains('\\n') => {\n+                    Some(format!(\n+                        \"{}\\n{}{}\",\n+                        prefix,\n+                        type_offset.to_string(&context.config),\n+                        &new_ty\n+                    ))\n                 }\n-                Some(result + &ty)\n-            }\n-            None => {\n-                let ty = try_opt!(rewrite_type_in_next_line());\n-                Some(format!(\n-                    \"{}\\n{}{}\",\n-                    result,\n-                    type_offset.to_string(&context.config),\n-                    &ty\n-                ))\n+                _ => Some(prefix + &ty),\n             }\n         }\n+        _ => {\n+            let ty = try_opt!(rewrite_type_in_next_line());\n+            Some(format!(\n+                \"{}\\n{}{}\",\n+                prefix,\n+                type_offset.to_string(&context.config),\n+                &ty\n+            ))\n+        }\n     }\n }\n "}, {"sha": "f0c3ebf49a1d0248b9d3b1cd17ec75efc3fa0acd", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "patch": "@@ -76,6 +76,7 @@ mod chains;\n mod macros;\n mod patterns;\n mod summary;\n+mod vertical;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip."}, {"sha": "d6b344435186fc2f8f924126ebb65ec8eab79743", "filename": "src/vertical.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=34b4a9d3c4ccd47a6dbc676dd0825693a85b9b01", "patch": "@@ -0,0 +1,271 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Format with vertical alignment.\n+\n+use std::cmp;\n+\n+use {Indent, Shape, Spanned};\n+use codemap::SpanUtils;\n+use comment::contains_comment;\n+use expr::rewrite_field;\n+use items::{rewrite_struct_field, rewrite_struct_field_prefix};\n+use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic};\n+use rewrite::{Rewrite, RewriteContext};\n+use utils::{contains_skip, mk_sp};\n+\n+use syntax::ast;\n+use syntax::codemap::{Span, BytePos};\n+\n+pub trait AlignedItem {\n+    fn skip(&self) -> bool;\n+    fn get_span(&self) -> Span;\n+    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n+    fn rewrite_aligned_item(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        prefix_max_width: usize,\n+    ) -> Option<String>;\n+}\n+\n+impl AlignedItem for ast::StructField {\n+    fn skip(&self) -> bool {\n+        contains_skip(&self.attrs)\n+    }\n+\n+    fn get_span(&self) -> Span {\n+        self.span()\n+    }\n+\n+    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        rewrite_struct_field_prefix(context, self, shape)\n+    }\n+\n+    fn rewrite_aligned_item(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        prefix_max_width: usize,\n+    ) -> Option<String> {\n+        rewrite_struct_field(context, self, shape, prefix_max_width)\n+    }\n+}\n+\n+impl AlignedItem for ast::Field {\n+    fn skip(&self) -> bool {\n+        contains_skip(&self.attrs)\n+    }\n+\n+    fn get_span(&self) -> Span {\n+        self.span()\n+    }\n+\n+    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let mut attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n+        if !attrs_str.is_empty() {\n+            attrs_str.push_str(&format!(\"\\n{}\", shape.indent.to_string(context.config)));\n+        };\n+        let name = &self.ident.node.to_string();\n+        Some(format!(\"{}{}\", attrs_str, name))\n+    }\n+\n+    fn rewrite_aligned_item(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        prefix_max_width: usize,\n+    ) -> Option<String> {\n+        rewrite_field(context, self, shape, prefix_max_width)\n+    }\n+}\n+\n+pub fn rewrite_with_alignment<T: AlignedItem>(\n+    fields: &[T],\n+    context: &RewriteContext,\n+    shape: Shape,\n+    span: Span,\n+    one_line_width: usize,\n+) -> Option<String> {\n+    let (spaces, group_index) = if context.config.struct_field_align_threshold() > 0 {\n+        group_aligned_items(context, fields)\n+    } else {\n+        (\"\", fields.len() - 1)\n+    };\n+    let init = &fields[0..group_index + 1];\n+    let rest = &fields[group_index + 1..];\n+    let init_last_pos = if rest.is_empty() {\n+        span.hi\n+    } else {\n+        // Decide whether the missing comments should stick to init or rest.\n+        let init_hi = init[init.len() - 1].get_span().hi;\n+        let rest_lo = rest[0].get_span().lo;\n+        let missing_span = mk_sp(init_hi, rest_lo);\n+        let missing_span = mk_sp(\n+            context.codemap.span_after(missing_span, \",\"),\n+            missing_span.hi,\n+        );\n+\n+        let snippet = context.snippet(missing_span);\n+        if snippet.trim_left().starts_with(\"//\") {\n+            let offset = snippet.lines().next().map_or(0, |l| l.len());\n+            // 2 = \",\" + \"\\n\"\n+            init_hi + BytePos(offset as u32 + 2)\n+        } else if snippet.trim_left().starts_with(\"/*\") {\n+            let comment_lines = snippet\n+                .lines()\n+                .position(|line| line.trim_right().ends_with(\"*/\"))\n+                .unwrap_or(0);\n+\n+            let offset = snippet\n+                .lines()\n+                .take(comment_lines + 1)\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+                .len();\n+\n+            init_hi + BytePos(offset as u32 + 2)\n+        } else {\n+            missing_span.lo\n+        }\n+    };\n+    let init_span = mk_sp(span.lo, init_last_pos);\n+    let one_line_width = if rest.is_empty() { one_line_width } else { 0 };\n+    let result = try_opt!(rewrite_aligned_items_inner(\n+        context,\n+        init,\n+        init_span,\n+        shape.indent,\n+        one_line_width,\n+    ));\n+    if rest.is_empty() {\n+        Some(result + spaces)\n+    } else {\n+        let rest_span = mk_sp(init_last_pos, span.hi);\n+        let rest_str = try_opt!(rewrite_with_alignment(\n+            rest,\n+            context,\n+            shape,\n+            rest_span,\n+            one_line_width,\n+        ));\n+        Some(\n+            result + spaces + \"\\n\" +\n+                &shape\n+                    .indent\n+                    .block_indent(context.config)\n+                    .to_string(context.config) + &rest_str,\n+        )\n+    }\n+}\n+\n+fn struct_field_preix_max_min_width<T: AlignedItem>(\n+    context: &RewriteContext,\n+    fields: &[T],\n+    shape: Shape,\n+) -> (usize, usize) {\n+    fields\n+        .iter()\n+        .map(|field| {\n+            field.rewrite_prefix(context, shape).and_then(\n+                |field_str| if field_str.contains('\\n') {\n+                    None\n+                } else {\n+                    Some(field_str.len())\n+                },\n+            )\n+        })\n+        .fold(Some((0, ::std::usize::MAX)), |acc, len| match (acc, len) {\n+            (Some((max_len, min_len)), Some(len)) => {\n+                Some((cmp::max(max_len, len), cmp::min(min_len, len)))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or((0, 0))\n+}\n+\n+fn rewrite_aligned_items_inner<T: AlignedItem>(\n+    context: &RewriteContext,\n+    fields: &[T],\n+    span: Span,\n+    offset: Indent,\n+    one_line_width: usize,\n+) -> Option<String> {\n+    let item_indent = offset.block_indent(context.config);\n+    // 1 = \",\"\n+    let item_shape = try_opt!(Shape::indented(item_indent, context.config).sub_width(1));\n+    let (mut field_prefix_max_width, field_prefix_min_width) =\n+        struct_field_preix_max_min_width(context, fields, item_shape);\n+    let max_diff = field_prefix_max_width\n+        .checked_sub(field_prefix_min_width)\n+        .unwrap_or(0);\n+    if max_diff > context.config.struct_field_align_threshold() {\n+        field_prefix_max_width = 0;\n+    }\n+\n+    let items = itemize_list(\n+        context.codemap,\n+        fields.iter(),\n+        \"}\",\n+        |field| field.get_span().lo,\n+        |field| field.get_span().hi,\n+        |field| field.rewrite_aligned_item(context, item_shape, field_prefix_max_width),\n+        span.lo,\n+        span.hi,\n+    ).collect::<Vec<_>>();\n+\n+    let tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, one_line_width);\n+\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: context.config.trailing_comma(),\n+        shape: item_shape,\n+        ends_with_newline: true,\n+        config: context.config,\n+    };\n+    write_list(&items, &fmt)\n+}\n+\n+fn group_aligned_items<T: AlignedItem>(\n+    context: &RewriteContext,\n+    fields: &[T],\n+) -> (&'static str, usize) {\n+    let mut index = 0;\n+    for i in 0..fields.len() - 1 {\n+        if fields[i].skip() {\n+            return (\"\", index);\n+        }\n+        // See if there are comments or empty lines between fields.\n+        let span = mk_sp(fields[i].get_span().hi, fields[i + 1].get_span().lo);\n+        let snippet = context\n+            .snippet(span)\n+            .lines()\n+            .skip(1)\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let spacings = if snippet\n+            .lines()\n+            .rev()\n+            .skip(1)\n+            .find(|l| l.trim().is_empty())\n+            .is_some()\n+        {\n+            \"\\n\"\n+        } else {\n+            \"\"\n+        };\n+        if contains_comment(&snippet) || snippet.lines().count() > 1 {\n+            return (spacings, index);\n+        }\n+        index += 1;\n+    }\n+    (\"\", index)\n+}"}]}