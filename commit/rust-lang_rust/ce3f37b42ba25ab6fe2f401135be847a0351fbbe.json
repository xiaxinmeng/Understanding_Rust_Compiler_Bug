{"sha": "ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlM2YzN2I0MmJhMjVhYjZmZTJmNDAxMTM1YmU4NDdhMDM1MWZiYmU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-20T23:14:24Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-10T21:03:08Z"}, "message": "Use new dataflow interface for initialization/borrows analyses", "tree": {"sha": "42772fa33fb47325f0d20feb7d11d29499b2c608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42772fa33fb47325f0d20feb7d11d29499b2c608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "html_url": "https://github.com/rust-lang/rust/commit/ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce3f37b42ba25ab6fe2f401135be847a0351fbbe/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702096da17254239d09e1095b060c083322b8ac2", "url": "https://api.github.com/repos/rust-lang/rust/commits/702096da17254239d09e1095b060c083322b8ac2", "html_url": "https://github.com/rust-lang/rust/commit/702096da17254239d09e1095b060c083322b8ac2"}], "stats": {"total": 303, "additions": 195, "deletions": 108}, "files": [{"sha": "151ae28bae255688888e27c61ab0412719a7b108", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 55, "deletions": 33, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f37b42ba25ab6fe2f401135be847a0351fbbe/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f37b42ba25ab6fe2f401135be847a0351fbbe/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "patch": "@@ -10,7 +10,8 @@ use crate::borrow_check::{\n     places_conflict, BorrowData, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext,\n     ToRegionVid,\n };\n-use crate::dataflow::{BitDenotation, BottomValue, GenKillSet};\n+use crate::dataflow::generic::{self, GenKill};\n+use crate::dataflow::BottomValue;\n \n use std::rc::Rc;\n \n@@ -172,7 +173,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     /// That means they went out of a nonlexical scope\n     fn kill_loans_out_of_scope_at_location(\n         &self,\n-        trans: &mut GenKillSet<BorrowIndex>,\n+        trans: &mut impl GenKill<BorrowIndex>,\n         location: Location,\n     ) {\n         // NOTE: The state associated with a given `location`\n@@ -187,16 +188,21 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         // region, then setting that gen-bit will override any\n         // potential kill introduced here.\n         if let Some(indices) = self.borrows_out_of_scope_at_location.get(&location) {\n-            trans.kill_all(indices);\n+            trans.kill_all(indices.iter().copied());\n         }\n     }\n \n     /// Kill any borrows that conflict with `place`.\n-    fn kill_borrows_on_place(&self, trans: &mut GenKillSet<BorrowIndex>, place: &Place<'tcx>) {\n+    fn kill_borrows_on_place(&self, trans: &mut impl GenKill<BorrowIndex>, place: &Place<'tcx>) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n-        let other_borrows_of_local =\n-            self.borrow_set.local_map.get(&place.local).into_iter().flat_map(|bs| bs.into_iter());\n+        let other_borrows_of_local = self\n+            .borrow_set\n+            .local_map\n+            .get(&place.local)\n+            .into_iter()\n+            .flat_map(|bs| bs.into_iter())\n+            .copied();\n \n         // If the borrowed place is a local with no projections, all other borrows of this\n         // local must conflict. This is purely an optimization so we don't have to call\n@@ -212,7 +218,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         // pair of array indices are unequal, so that when `places_conflict` returns true, we\n         // will be assured that two places being compared definitely denotes the same sets of\n         // locations.\n-        let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n+        let definitely_conflicting_borrows = other_borrows_of_local.filter(|&i| {\n             places_conflict(\n                 self.tcx,\n                 self.body,\n@@ -226,36 +232,41 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n+impl<'tcx> generic::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     type Idx = BorrowIndex;\n-    fn name() -> &'static str {\n-        \"borrows\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"borrows\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.borrow_set.borrows.len() * 2\n     }\n \n-    fn start_block_effect(&self, _entry_set: &mut BitSet<Self::Idx>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n         // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect.\n     }\n \n-    fn before_statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        debug!(\"Borrows::before_statement_effect trans: {:?} location: {:?}\", trans, location);\n-        self.kill_loans_out_of_scope_at_location(trans, location);\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, idx: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{:?}\", self.location(idx))\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        debug!(\"Borrows::statement_effect: trans={:?} location={:?}\", trans, location);\n-\n-        let block = &self.body.basic_blocks().get(location.block).unwrap_or_else(|| {\n-            panic!(\"could not find block at location {:?}\", location);\n-        });\n-        let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n-            panic!(\"could not find statement at location {:?}\");\n-        });\n+impl<'tcx> generic::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n+    fn before_statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.kill_loans_out_of_scope_at_location(trans, location);\n+    }\n \n-        debug!(\"Borrows::statement_effect: stmt={:?}\", stmt);\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         match stmt.kind {\n             mir::StatementKind::Assign(box (ref lhs, ref rhs)) => {\n                 if let mir::Rvalue::Ref(_, _, ref place) = *rhs {\n@@ -301,18 +312,29 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n         }\n     }\n \n-    fn before_terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        debug!(\"Borrows::before_terminator_effect: trans={:?} location={:?}\", trans, location);\n+    fn before_terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         self.kill_loans_out_of_scope_at_location(trans, location);\n     }\n \n-    fn terminator_effect(&self, _: &mut GenKillSet<Self::Idx>, _: Location) {}\n+    fn terminator_effect(\n+        &self,\n+        _: &mut impl GenKill<Self::Idx>,\n+        _: &mir::Terminator<'tcx>,\n+        _: Location,\n+    ) {\n+    }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        _in_out: &mut BitSet<BorrowIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         _dest_place: &mir::Place<'tcx>,\n     ) {\n     }"}, {"sha": "5b2264c2a65266b6a85c6537b48117b1b16858a8", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 140, "deletions": 75, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/ce3f37b42ba25ab6fe2f401135be847a0351fbbe/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce3f37b42ba25ab6fe2f401135be847a0351fbbe/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=ce3f37b42ba25ab6fe2f401135be847a0351fbbe", "patch": "@@ -11,8 +11,9 @@ use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n+use super::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use super::move_paths::{HasMoveData, InitIndex, InitKind, MoveData, MovePathIndex};\n-use super::{BitDenotation, BottomValue, GenKillSet};\n+use super::{BottomValue, GenKillSet};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n@@ -216,6 +217,7 @@ impl<'a, 'tcx> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n /// }\n /// ```\n pub struct EverInitializedPlaces<'a, 'tcx> {\n+    #[allow(dead_code)]\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'tcx>,\n@@ -235,7 +237,7 @@ impl<'a, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n     fn update_bits(\n-        trans: &mut GenKillSet<MovePathIndex>,\n+        trans: &mut impl GenKill<MovePathIndex>,\n         path: MovePathIndex,\n         state: DropFlagState,\n     ) {\n@@ -248,7 +250,7 @@ impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n     fn update_bits(\n-        trans: &mut GenKillSet<MovePathIndex>,\n+        trans: &mut impl GenKill<MovePathIndex>,\n         path: MovePathIndex,\n         state: DropFlagState,\n     ) {\n@@ -261,7 +263,7 @@ impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     fn update_bits(\n-        trans: &mut GenKillSet<MovePathIndex>,\n+        trans: &mut impl GenKill<MovePathIndex>,\n         path: MovePathIndex,\n         state: DropFlagState,\n     ) {\n@@ -272,39 +274,56 @@ impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n     type Idx = MovePathIndex;\n-    fn name() -> &'static str {\n-        \"maybe_init\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"maybe_init\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().move_paths.len()\n     }\n \n-    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n-            entry_set.insert(path);\n+            state.insert(path);\n         });\n     }\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{}\", self.move_data().move_paths[mpi])\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<MovePathIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         dest_place: &mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n@@ -315,50 +334,67 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'tcx> {\n             self.move_data(),\n             self.move_data().rev_lookup.find(dest_place.as_ref()),\n             |mpi| {\n-                in_out.insert(mpi);\n+                trans.gen(mpi);\n             },\n         );\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n     type Idx = MovePathIndex;\n-    fn name() -> &'static str {\n-        \"maybe_uninit\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"maybe_uninit\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().move_paths.len()\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n-        assert!(self.bits_per_block() == entry_set.domain_size());\n-        entry_set.insert_all();\n+        assert!(self.bits_per_block(body) == state.domain_size());\n+        state.insert_all();\n \n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n-            entry_set.remove(path);\n+            state.remove(path);\n         });\n     }\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{}\", self.move_data().move_paths[mpi])\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<MovePathIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         dest_place: &mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n@@ -369,48 +405,65 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'tcx> {\n             self.move_data(),\n             self.move_data().rev_lookup.find(dest_place.as_ref()),\n             |mpi| {\n-                in_out.remove(mpi);\n+                trans.kill(mpi);\n             },\n         );\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n+impl<'a, 'tcx> AnalysisDomain<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n     type Idx = MovePathIndex;\n-    fn name() -> &'static str {\n-        \"definite_init\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"definite_init\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().move_paths.len()\n     }\n \n     // sets on_entry bits for Arg places\n-    fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n-        entry_set.clear();\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        state.clear();\n \n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {\n             assert!(s == DropFlagState::Present);\n-            entry_set.insert(path);\n+            state.insert(path);\n         });\n     }\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn pretty_print_idx(&self, w: &mut impl std::io::Write, mpi: Self::Idx) -> std::io::Result<()> {\n+        write!(w, \"{}\", self.move_data().move_paths[mpi])\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for DefinitelyInitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         drop_flag_effects_for_location(self.tcx, self.body, self.mdpe, location, |path, s| {\n             Self::update_bits(trans, path, s)\n         })\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<MovePathIndex>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         dest_place: &mir::Place<'tcx>,\n     ) {\n         // when a call returns successfully, that means we need to set\n@@ -421,30 +474,36 @@ impl<'a, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n             self.move_data(),\n             self.move_data().rev_lookup.find(dest_place.as_ref()),\n             |mpi| {\n-                in_out.insert(mpi);\n+                trans.gen(mpi);\n             },\n         );\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n     type Idx = InitIndex;\n-    fn name() -> &'static str {\n-        \"ever_init\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n+\n+    const NAME: &'static str = \"ever_init\";\n+\n+    fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n         self.move_data().inits.len()\n     }\n \n-    fn start_block_effect(&self, entry_set: &mut BitSet<InitIndex>) {\n-        for arg_init in 0..self.body.arg_count {\n-            entry_set.insert(InitIndex::new(arg_init));\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        for arg_init in 0..body.arg_count {\n+            state.insert(InitIndex::new(arg_init));\n         }\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n-        let (_, body, move_data) = (self.tcx, self.body, self.move_data());\n-        let stmt = &body[location.block].statements[location.statement_index];\n+impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        let move_data = self.move_data();\n         let init_path_map = &move_data.init_path_map;\n         let init_loc_map = &move_data.init_loc_map;\n         let rev_lookup = &move_data.rev_lookup;\n@@ -453,7 +512,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n             \"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n             stmt, location, &init_loc_map[location]\n         );\n-        trans.gen_all(&init_loc_map[location]);\n+        trans.gen_all(init_loc_map[location].iter().copied());\n \n         match stmt.kind {\n             mir::StatementKind::StorageDead(local) => {\n@@ -464,13 +523,18 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n                     \"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n                     stmt, location, &init_path_map[move_path_index]\n                 );\n-                trans.kill_all(&init_path_map[move_path_index]);\n+                trans.kill_all(init_path_map[move_path_index].iter().copied());\n             }\n             _ => {}\n         }\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location) {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n         let (body, move_data) = (self.body, self.move_data());\n         let term = body[location.block].terminator();\n         let init_loc_map = &move_data.init_loc_map;\n@@ -479,28 +543,29 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n             term, location, &init_loc_map[location]\n         );\n         trans.gen_all(\n-            init_loc_map[location].iter().filter(|init_index| {\n-                move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n-            }),\n+            init_loc_map[location]\n+                .iter()\n+                .filter(|init_index| {\n+                    move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n+                })\n+                .copied(),\n         );\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<InitIndex>,\n-        call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         _dest_place: &mir::Place<'tcx>,\n     ) {\n         let move_data = self.move_data();\n-        let bits_per_block = self.bits_per_block();\n         let init_loc_map = &move_data.init_loc_map;\n \n-        let call_loc =\n-            Location { block: call_bb, statement_index: self.body[call_bb].statements.len() };\n+        let call_loc = self.body.terminator_loc(block);\n         for init_index in &init_loc_map[call_loc] {\n-            assert!(init_index.index() < bits_per_block);\n-            in_out.insert(*init_index);\n+            trans.gen(*init_index);\n         }\n     }\n }"}]}