{"sha": "3c32cd1be27f321658382e39d34f5d993d99ae8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMzJjZDFiZTI3ZjMyMTY1ODM4MmUzOWQzNGY1ZDk5M2Q5OWFlOGI=", "commit": {"author": {"name": "Paul Collier", "email": "paul@paulcollier.ca", "date": "2015-01-18T00:41:56Z"}, "committer": {"name": "Paul Collier", "email": "paul@paulcollier.ca", "date": "2015-01-19T03:43:44Z"}, "message": "libsyntax: 0u -> 0us, 0i -> 0is", "tree": {"sha": "a82c1d5da8abe7c5fae2fe1f60c3bae2c3eee0e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a82c1d5da8abe7c5fae2fe1f60c3bae2c3eee0e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c32cd1be27f321658382e39d34f5d993d99ae8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c32cd1be27f321658382e39d34f5d993d99ae8b", "html_url": "https://github.com/rust-lang/rust/commit/3c32cd1be27f321658382e39d34f5d993d99ae8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c32cd1be27f321658382e39d34f5d993d99ae8b/comments", "author": {"login": "pshc", "id": 6398, "node_id": "MDQ6VXNlcjYzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pshc", "html_url": "https://github.com/pshc", "followers_url": "https://api.github.com/users/pshc/followers", "following_url": "https://api.github.com/users/pshc/following{/other_user}", "gists_url": "https://api.github.com/users/pshc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pshc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pshc/subscriptions", "organizations_url": "https://api.github.com/users/pshc/orgs", "repos_url": "https://api.github.com/users/pshc/repos", "events_url": "https://api.github.com/users/pshc/events{/privacy}", "received_events_url": "https://api.github.com/users/pshc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pshc", "id": 6398, "node_id": "MDQ6VXNlcjYzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pshc", "html_url": "https://github.com/pshc", "followers_url": "https://api.github.com/users/pshc/followers", "following_url": "https://api.github.com/users/pshc/following{/other_user}", "gists_url": "https://api.github.com/users/pshc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pshc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pshc/subscriptions", "organizations_url": "https://api.github.com/users/pshc/orgs", "repos_url": "https://api.github.com/users/pshc/repos", "events_url": "https://api.github.com/users/pshc/events{/privacy}", "received_events_url": "https://api.github.com/users/pshc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "591337431df612dd4e0df8d46b6291358085ac7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/591337431df612dd4e0df8d46b6291358085ac7c", "html_url": "https://github.com/rust-lang/rust/commit/591337431df612dd4e0df8d46b6291358085ac7c"}], "stats": {"total": 312, "additions": 156, "deletions": 156}, "files": [{"sha": "34fd498322c0f86ddcbef527f571c617413d307e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -322,15 +322,15 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n pub fn operator_prec(op: ast::BinOp) -> usize {\n   match op {\n       // 'as' sits here with 12\n-      BiMul | BiDiv | BiRem     => 11u,\n-      BiAdd | BiSub             => 10u,\n-      BiShl | BiShr             =>  9u,\n-      BiBitAnd                  =>  8u,\n-      BiBitXor                  =>  7u,\n-      BiBitOr                   =>  6u,\n-      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3u,\n-      BiAnd                     =>  2u,\n-      BiOr                      =>  1u\n+      BiMul | BiDiv | BiRem     => 11us,\n+      BiAdd | BiSub             => 10us,\n+      BiShl | BiShr             =>  9us,\n+      BiBitAnd                  =>  8us,\n+      BiBitXor                  =>  7us,\n+      BiBitOr                   =>  6us,\n+      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3us,\n+      BiAnd                     =>  2us,\n+      BiOr                      =>  1us\n   }\n }\n "}, {"sha": "a5e10f42750b8be8966895a409774ba9ec98de13", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -430,7 +430,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n-        for i in range(lo.line - 1u, hi.line as usize) {\n+        for i in range(lo.line - 1us, hi.line as usize) {\n             lines.push(i);\n         };\n         FileLines {file: lo.file, lines: lines}\n@@ -498,10 +498,10 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let files = &*files;\n         let len = files.len();\n-        let mut a = 0u;\n+        let mut a = 0us;\n         let mut b = len;\n-        while b - a > 1u {\n-            let m = (a + b) / 2u;\n+        while b - a > 1us {\n+            let m = (a + b) / 2us;\n             if files[m].start_pos > pos {\n                 b = m;\n             } else {\n@@ -537,12 +537,12 @@ impl CodeMap {\n \n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n-        let mut a = 0u;\n+        let mut a = 0us;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n-            while b - a > 1u {\n-                let m = (a + b) / 2u;\n+            while b - a > 1us {\n+                let m = (a + b) / 2us;\n                 if (*lines)[m] > pos { b = m; } else { a = m; }\n             }\n         }\n@@ -551,7 +551,7 @@ impl CodeMap {\n \n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n-        let line = a + 1u; // Line numbers start at 1\n+        let line = a + 1us; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n         let linebpos = (*f.lines.borrow())[a];\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n@@ -762,7 +762,7 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0], 1u);\n+        assert_eq!(file_lines.lines[0], 1us);\n     }\n \n     #[test]"}, {"sha": "6de466ea9bd3ad2a2d082be8b5a706a99b104b6f", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -26,7 +26,7 @@ use term::WriterWrapper;\n use term;\n \n /// maximum number of lines we will print for each error; arbitrary.\n-static MAX_LINES: usize = 6u;\n+static MAX_LINES: usize = 6us;\n \n #[derive(Clone, Copy)]\n pub enum RenderSpan {\n@@ -151,20 +151,20 @@ impl Handler {\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n-        self.err_count.set(self.err_count.get() + 1u);\n+        self.err_count.set(self.err_count.get() + 1us);\n     }\n     pub fn err_count(&self) -> usize {\n         self.err_count.get()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.err_count.get()> 0u\n+        self.err_count.get() > 0us\n     }\n     pub fn abort_if_errors(&self) {\n         let s;\n         match self.err_count.get() {\n-          0u => return,\n-          1u => s = \"aborting due to previous error\".to_string(),\n-          _  => {\n+          0us => return,\n+          1us => s = \"aborting due to previous error\".to_string(),\n+          _   => {\n             s = format!(\"aborting due to {} previous errors\",\n                         self.err_count.get());\n           }\n@@ -448,7 +448,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = &lines.lines[];\n     if display_lines.len() > MAX_LINES {\n-        display_lines = &display_lines[0u..MAX_LINES];\n+        display_lines = &display_lines[0us..MAX_LINES];\n         elided = true;\n     }\n     // Print the offending lines\n@@ -459,32 +459,32 @@ fn highlight_lines(err: &mut EmitterWriter,\n         }\n     }\n     if elided {\n-        let last_line = display_lines[display_lines.len() - 1u];\n-        let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n+        let last_line = display_lines[display_lines.len() - 1us];\n+        let s = format!(\"{}:{} \", fm.name, last_line + 1us);\n         try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n     // If there's one line at fault we can easily point to the problem\n-    if lines.lines.len() == 1u {\n+    if lines.lines.len() == 1us {\n         let lo = cm.lookup_char_pos(sp.lo);\n-        let mut digits = 0u;\n-        let mut num = (lines.lines[0] + 1u) / 10u;\n+        let mut digits = 0us;\n+        let mut num = (lines.lines[0] + 1us) / 10us;\n \n         // how many digits must be indent past?\n-        while num > 0u { num /= 10u; digits += 1u; }\n+        while num > 0us { num /= 10us; digits += 1us; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = fm.name.len() + digits + lo.col.to_usize() + 3u;\n+        let left = fm.name.len() + digits + lo.col.to_usize() + 3us;\n         let mut s = String::new();\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n-        let skip = fm.name.len() + digits + 3u;\n+        let skip = fm.name.len() + digits + 3us;\n         for _ in range(0, skip) {\n             s.push(' ');\n         }\n         if let Some(orig) = fm.get_line(lines.lines[0]) {\n-            for pos in range(0u, left - skip) {\n+            for pos in range(0us, left - skip) {\n                 let cur_char = orig.as_bytes()[pos] as char;\n                 // Whenever a tab occurs on the previous line, we insert one on\n                 // the error-point-squiggly-line as well (instead of a space)."}, {"sha": "b77c203acfbc4ba943bb89464043d3f1586de1ad", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -748,7 +748,7 @@ impl<'a> MethodDef<'a> {\n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = Vec::new();\n-        for i in range(0u, self_args.len()) {\n+        for i in range(0us, self_args.len()) {\n             let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));\n             let (pat, ident_expr) =\n                 trait_.create_struct_pattern(cx,\n@@ -837,8 +837,8 @@ impl<'a> MethodDef<'a> {\n     ///             (&A2(ref __self_0),\n     ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n     ///             _ => {\n-    ///                 let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n-    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n+    ///                 let __self_vi = match *self { A1(..) => 0us, A2(..) => 1us };\n+    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0us, A2(..) => 1us };\n     ///                 false\n     ///             }\n     ///         }\n@@ -882,8 +882,8 @@ impl<'a> MethodDef<'a> {\n     ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n     ///   ...\n     ///   _ => {\n-    ///     let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n-    ///     let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n+    ///     let __this_vi = match this { Variant1 => 0us, Variant2 => 1us, ... };\n+    ///     let __that_vi = match that { Variant1 => 0us, Variant2 => 1us, ... };\n     ///     ... // catch-all remainder can inspect above variant index values.\n     ///   }\n     /// }\n@@ -1045,13 +1045,13 @@ impl<'a> MethodDef<'a> {\n             //\n             // ```\n             // let __self0_vi = match   self {\n-            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            //     A => 0us, B(..) => 1us, C(..) => 2us\n             // };\n             // let __self1_vi = match __arg1 {\n-            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            //     A => 0us, B(..) => 1us, C(..) => 2us\n             // };\n             // let __self2_vi = match __arg2 {\n-            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            //     A => 0us, B(..) => 1us, C(..) => 2us\n             // };\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();"}, {"sha": "9aa602b39b4f6ec463908a923e6b4e1c2ee18777", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -273,7 +273,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n         // in this file.\n         // Token-tree macros:\n         MacInvocTT(pth, tts, _) => {\n-            if pth.segments.len() > 1u {\n+            if pth.segments.len() > 1us {\n                 fld.cx.span_err(pth.span,\n                                 \"expected macro name without module \\\n                                 separators\");\n@@ -844,7 +844,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             },\n             _ => unreachable!()\n         };\n-        if pth.segments.len() > 1u {\n+        if pth.segments.len() > 1us {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n         }"}, {"sha": "5339c3d77c656e4d3dc3022cb7723c8e6c78f74f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -716,7 +716,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // try removing it when enough of them are gone.\n \n     let mut p = cx.new_parser_from_tts(tts);\n-    p.quote_depth += 1u;\n+    p.quote_depth += 1us;\n \n     let cx_expr = p.parse_expr();\n     if !p.eat(&token::Comma) {"}, {"sha": "d115f2ed6208265b7b69646471585caffe173f9d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -171,11 +171,11 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n         stack: vec![],\n         top_elts: TtSeq(ms),\n         sep: sep,\n-        idx: 0u,\n+        idx: 0us,\n         up: None,\n         matches: matches,\n-        match_lo: 0u,\n-        match_cur: 0u,\n+        match_lo: 0us,\n+        match_cur: 0us,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n     }\n@@ -238,7 +238,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    let mut idx = 0u;\n+    let mut idx = 0us;\n     for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n     ret_val\n }\n@@ -383,7 +383,7 @@ pub fn parse(sess: &ParseSess,\n                         if seq.op == ast::ZeroOrMore {\n                             let mut new_ei = ei.clone();\n                             new_ei.match_cur += seq.num_captures;\n-                            new_ei.idx += 1u;\n+                            new_ei.idx += 1us;\n                             //we specifically matched zero repeats.\n                             for idx in range(ei.match_cur, ei.match_cur + seq.num_captures) {\n                                 (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(vec![], sp)));\n@@ -398,7 +398,7 @@ pub fn parse(sess: &ParseSess,\n                         cur_eis.push(box MatcherPos {\n                             stack: vec![],\n                             sep: seq.separator.clone(),\n-                            idx: 0u,\n+                            idx: 0us,\n                             matches: matches,\n                             match_lo: ei_t.match_cur,\n                             match_cur: ei_t.match_cur,\n@@ -442,20 +442,20 @@ pub fn parse(sess: &ParseSess,\n \n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&tok, &token::Eof) {\n-            if eof_eis.len() == 1u {\n+            if eof_eis.len() == 1us {\n                 let mut v = Vec::new();\n                 for dv in (&mut eof_eis[0]).matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, &v[]));\n-            } else if eof_eis.len() > 1u {\n+            } else if eof_eis.len() > 1us {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n                 return Failure(sp, \"unexpected end of macro invocation\".to_string());\n             }\n         } else {\n-            if (bb_eis.len() > 0u && next_eis.len() > 0u)\n-                || bb_eis.len() > 1u {\n+            if (bb_eis.len() > 0us && next_eis.len() > 0us)\n+                || bb_eis.len() > 1us {\n                 let nts = bb_eis.iter().map(|ei| {\n                     match ei.top_elts.get_tt(ei.idx) {\n                       TtToken(_, MatchNt(bind, name, _, _)) => {\n@@ -469,12 +469,12 @@ pub fn parse(sess: &ParseSess,\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()).to_string());\n-            } else if bb_eis.len() == 0u && next_eis.len() == 0u {\n+            } else if bb_eis.len() == 0us && next_eis.len() == 0us {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n                             pprust::token_to_string(&tok)).to_string());\n-            } else if next_eis.len() > 0u {\n+            } else if next_eis.len() > 0us {\n                 /* Now process the next token */\n-                while next_eis.len() > 0u {\n+                while next_eis.len() > 0us {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n@@ -488,7 +488,7 @@ pub fn parse(sess: &ParseSess,\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get()))));\n-                    ei.idx += 1u;\n+                    ei.idx += 1us;\n                     ei.match_cur += 1;\n                   }\n                   _ => panic!()\n@@ -501,16 +501,16 @@ pub fn parse(sess: &ParseSess,\n             }\n         }\n \n-        assert!(cur_eis.len() > 0u);\n+        assert!(cur_eis.len() > 0us);\n     }\n }\n \n pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n-            p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n+            p.quote_depth += 1us; //but in theory, non-quoted tts might be useful\n             let res = token::NtTT(P(p.parse_token_tree()));\n-            p.quote_depth -= 1u;\n+            p.quote_depth -= 1us;\n             return res;\n         }\n         _ => {}"}, {"sha": "0bf20b8f3e1514c829ede4aa92a71b27e1349970", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -223,7 +223,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.repeat_len.pop();\n             }\n         } else { /* repeat */\n-            *r.repeat_idx.last_mut().unwrap() += 1u;\n+            *r.repeat_idx.last_mut().unwrap() += 1us;\n             r.stack.last_mut().unwrap().idx = 0;\n             match r.stack.last().unwrap().sep.clone() {\n                 Some(tk) => {"}, {"sha": "2799696e8eb2f4eca364c4336511c46b455d0524", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -62,7 +62,7 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: Vec<String> ) -> Vec<String> {\n-        let mut i = 0u;\n+        let mut i = 0us;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n@@ -132,7 +132,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let lines = comment[3u..(comment.len() - 2u)]\n+        let lines = comment[3us..(comment.len() - 2us)]\n             .lines_any()\n             .map(|s| s.to_string())\n             .collect::<Vec<String> >();\n@@ -158,7 +158,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader,\n                                            comments: &mut Vec<Comment>) {\n     while is_whitespace(rdr.curr) && !rdr.is_eof() {\n-        if rdr.col == CharPos(0u) && rdr.curr_is('\\n') {\n+        if rdr.col == CharPos(0us) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         rdr.bump();\n@@ -305,7 +305,7 @@ fn read_block_comment(rdr: &mut StringReader,\n \n     let mut style = if code_to_the_left { Trailing } else { Isolated };\n     rdr.consume_non_eol_whitespace();\n-    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1u {\n+    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1us {\n         style = Mixed;\n     }\n     debug!(\"<<< block comment\");"}, {"sha": "d18bf5549750eefcf7fc2a67eb942234515570da", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -279,7 +279,7 @@ impl<'a> StringReader<'a> {\n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n     fn translate_crlf<'b>(&self, start: BytePos,\n                           s: &'b str, errmsg: &'b str) -> CowString<'b> {\n-        let mut i = 0u;\n+        let mut i = 0us;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);\n             if ch == '\\r' {\n@@ -331,10 +331,10 @@ impl<'a> StringReader<'a> {\n             let byte_offset_diff = next.next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n             self.curr = Some(next.ch);\n-            self.col = self.col + CharPos(1u);\n+            self.col = self.col + CharPos(1us);\n             if last_char == '\\n' {\n                 self.filemap.next_line(self.last_pos);\n-                self.col = CharPos(0u);\n+                self.col = CharPos(0us);\n             }\n \n             if byte_offset_diff > 1 {\n@@ -472,7 +472,7 @@ impl<'a> StringReader<'a> {\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.last_pos);\n                 debug!(\"Skipping a shebang\");\n-                if loc.line == 1u && loc.col == CharPos(0u) {\n+                if loc.line == 1us && loc.col == CharPos(0us) {\n                     // FIXME: Add shebang \"token\", return it\n                     let start = self.last_pos;\n                     while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n@@ -646,7 +646,7 @@ impl<'a> StringReader<'a> {\n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n     fn scan_digits(&mut self, radix: usize) -> usize {\n-        let mut len = 0u;\n+        let mut len = 0us;\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n@@ -799,14 +799,14 @@ impl<'a> StringReader<'a> {\n                                 if self.curr == Some('{') {\n                                     self.scan_unicode_escape(delim)\n                                 } else {\n-                                    let res = self.scan_hex_digits(4u, delim, false);\n+                                    let res = self.scan_hex_digits(4us, delim, false);\n                                     let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                     self.old_escape_warning(sp);\n                                     res\n                                 }\n                             }\n                             'U' if !ascii_only => {\n-                                let res = self.scan_hex_digits(8u, delim, false);\n+                                let res = self.scan_hex_digits(8us, delim, false);\n                                 let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                 self.old_escape_warning(sp);\n                                 res\n@@ -937,11 +937,11 @@ impl<'a> StringReader<'a> {\n     /// error if it isn't.\n     fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: usize) {\n         match base {\n-            16u => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n-                                 supported\"),\n-            8u => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n-            2u => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n-            _ => ()\n+            16us => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n+                                   supported\"),\n+            8us => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n+            2us => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n+            _   => ()\n         }\n     }\n \n@@ -1189,7 +1189,7 @@ impl<'a> StringReader<'a> {\n           'r' => {\n             let start_bpos = self.last_pos;\n             self.bump();\n-            let mut hash_count = 0u;\n+            let mut hash_count = 0us;\n             while self.curr_is('#') {\n                 self.bump();\n                 hash_count += 1;\n@@ -1374,7 +1374,7 @@ impl<'a> StringReader<'a> {\n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n         let start_bpos = self.last_pos;\n         self.bump();\n-        let mut hash_count = 0u;\n+        let mut hash_count = 0us;\n         while self.curr_is('#') {\n             self.bump();\n             hash_count += 1;\n@@ -1616,9 +1616,9 @@ mod test {\n         test!(\"1.0\", Float, \"1.0\");\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n-        assert_eq!(setup(&mk_sh(), \"2u\".to_string()).next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"2us\".to_string()).next_token().tok,\n                    token::Literal(token::Integer(token::intern(\"2\")),\n-                                  Some(token::intern(\"u\"))));\n+                                  Some(token::intern(\"us\"))));\n         assert_eq!(setup(&mk_sh(), \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));"}, {"sha": "29414ef94b5cc423b36ae409eb69880978d77c11", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -181,7 +181,7 @@ pub fn parse_tts_from_source_str(name: String,\n         name,\n         source\n     );\n-    p.quote_depth += 1u;\n+    p.quote_depth += 1us;\n     // right now this is re-creating the token trees from ... token trees.\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n@@ -325,7 +325,7 @@ pub mod with_hygiene {\n             name,\n             source\n         );\n-        p.quote_depth += 1u;\n+        p.quote_depth += 1us;\n         // right now this is re-creating the token trees from ... token trees.\n         maybe_aborted(p.parse_all_token_trees(),p)\n     }\n@@ -574,7 +574,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n     if lit.len() == 1 {\n         (lit.as_bytes()[0], 1)\n     } else {\n-        assert!(lit.as_bytes()[0] == b'\\\\', err(0i));\n+        assert!(lit.as_bytes()[0] == b'\\\\', err(0is));\n         let b = match lit.as_bytes()[1] {\n             b'\"' => b'\"',\n             b'n' => b'\\n',\n@@ -684,9 +684,9 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     match suffix {\n         Some(suf) if looks_like_width_suffix(&['f'], suf) => {\n             match base {\n-                16u => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n-                8u => sd.span_err(sp, \"octal float literal is not supported\"),\n-                2u => sd.span_err(sp, \"binary float literal is not supported\"),\n+                16us => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n+                8us => sd.span_err(sp, \"octal float literal is not supported\"),\n+                2us => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n             let ident = token::intern_and_get_ident(&*s);"}, {"sha": "ea7c80d3fc49dbaafdeb7f4f857e5753a4d190ac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -767,7 +767,7 @@ impl<'a> Parser<'a> {\n         // would encounter a `>` and stop. This lets the parser handle trailing\n         // commas in generic parameters, because it can stop either after\n         // parsing a type or after parsing a comma.\n-        for i in iter::count(0u, 1) {\n+        for i in iter::count(0us, 1) {\n             if self.check(&token::Gt)\n                 || self.token == token::BinOp(token::Shr)\n                 || self.token == token::Ge\n@@ -944,7 +944,7 @@ impl<'a> Parser<'a> {\n         };\n         self.span = next.sp;\n         self.token = next.tok;\n-        self.tokens_consumed += 1u;\n+        self.tokens_consumed += 1us;\n         self.expected_tokens.clear();\n         // check after each token\n         self.check_unknown_macro_variable();\n@@ -2638,7 +2638,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn check_unknown_macro_variable(&mut self) {\n-        if self.quote_depth == 0u {\n+        if self.quote_depth == 0us {\n             match self.token {\n                 token::SubstNt(name, _) =>\n                     self.fatal(&format!(\"unknown macro variable `{}`\",\n@@ -2707,7 +2707,7 @@ impl<'a> Parser<'a> {\n                                     token_str)[])\n                 },\n                 /* we ought to allow different depths of unquotation */\n-                token::Dollar | token::SubstNt(..) if p.quote_depth > 0u => {\n+                token::Dollar | token::SubstNt(..) if p.quote_depth > 0us => {\n                     p.parse_unquoted()\n                 }\n                 _ => {\n@@ -5079,7 +5079,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        if first && attrs_remaining_len > 0u {\n+        if first && attrs_remaining_len > 0us {\n             // We parsed attributes for the first item but didn't find it\n             let last_span = self.last_span;\n             self.span_err(last_span,\n@@ -5683,7 +5683,7 @@ impl<'a> Parser<'a> {\n             return IoviItem(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe) &&\n-            self.look_ahead(1u, |t| t.is_keyword(keywords::Trait))\n+            self.look_ahead(1us, |t| t.is_keyword(keywords::Trait))\n         {\n             // UNSAFE TRAIT ITEM\n             self.expect_keyword(keywords::Unsafe);\n@@ -5700,7 +5700,7 @@ impl<'a> Parser<'a> {\n             return IoviItem(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe) &&\n-            self.look_ahead(1u, |t| t.is_keyword(keywords::Impl))\n+            self.look_ahead(1us, |t| t.is_keyword(keywords::Impl))\n         {\n             // IMPL ITEM\n             self.expect_keyword(keywords::Unsafe);\n@@ -5731,7 +5731,7 @@ impl<'a> Parser<'a> {\n             return IoviItem(item);\n         }\n         if self.token.is_keyword(keywords::Unsafe)\n-            && self.look_ahead(1u, |t| *t != token::OpenDelim(token::Brace)) {\n+            && self.look_ahead(1us, |t| *t != token::OpenDelim(token::Brace)) {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n             let abi = if self.eat_keyword(keywords::Extern) {\n@@ -6035,7 +6035,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         }\n-        let mut rename_to = path[path.len() - 1u];\n+        let mut rename_to = path[path.len() - 1us];\n         let path = ast::Path {\n             span: mk_sp(lo, self.last_span.hi),\n             global: false,"}, {"sha": "0b1bd282941084fa59c3d5a3c923ea130c2c8e7a", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -132,15 +132,15 @@ pub fn buf_str(toks: &[Token],\n     let mut i = left;\n     let mut l = lim;\n     let mut s = string::String::from_str(\"[\");\n-    while i != right && l != 0u {\n-        l -= 1u;\n+    while i != right && l != 0us {\n+        l -= 1us;\n         if i != left {\n             s.push_str(\", \");\n         }\n         s.push_str(&format!(\"{}={}\",\n                            szs[i],\n                            tok_str(&toks[i]))[]);\n-        i += 1u;\n+        i += 1us;\n         i %= n;\n     }\n     s.push(']');\n@@ -167,7 +167,7 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: usize) -> Printer {\n     let n: usize = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n     let token: Vec<Token> = repeat(Token::Eof).take(n).collect();\n-    let size: Vec<isize> = repeat(0i).take(n).collect();\n+    let size: Vec<isize> = repeat(0is).take(n).collect();\n     let scan_stack: Vec<usize> = repeat(0us).take(n).collect();\n     Printer {\n         out: out,\n@@ -326,8 +326,8 @@ impl Printer {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n-                self.left = 0u;\n-                self.right = 0u;\n+                self.left = 0us;\n+                self.right = 0us;\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n@@ -355,8 +355,8 @@ impl Printer {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n-                self.left = 0u;\n-                self.right = 0u;\n+                self.left = 0us;\n+                self.right = 0us;\n             } else { self.advance_right(); }\n             debug!(\"pp Break({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n@@ -410,7 +410,7 @@ impl Printer {\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n         } else {\n-            self.top += 1u;\n+            self.top += 1us;\n             self.top %= self.buf_len;\n             assert!((self.top != self.bottom));\n         }\n@@ -422,7 +422,7 @@ impl Printer {\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n-            self.top += self.buf_len - 1u; self.top %= self.buf_len;\n+            self.top += self.buf_len - 1us; self.top %= self.buf_len;\n         }\n         return x;\n     }\n@@ -436,12 +436,12 @@ impl Printer {\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n-            self.bottom += 1u; self.bottom %= self.buf_len;\n+            self.bottom += 1us; self.bottom %= self.buf_len;\n         }\n         return x;\n     }\n     pub fn advance_right(&mut self) {\n-        self.right += 1u;\n+        self.right += 1us;\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n@@ -471,7 +471,7 @@ impl Printer {\n                 break;\n             }\n \n-            self.left += 1u;\n+            self.left += 1us;\n             self.left %= self.buf_len;\n \n             left_size = self.size[self.left];\n@@ -520,7 +520,7 @@ impl Printer {\n     pub fn get_top(&mut self) -> PrintStackElem {\n         let print_stack = &mut self.print_stack;\n         let n = print_stack.len();\n-        if n != 0u {\n+        if n != 0us {\n             (*print_stack)[n - 1]\n         } else {\n             PrintStackElem {\n@@ -565,7 +565,7 @@ impl Printer {\n           Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n-            assert!((print_stack.len() != 0u));\n+            assert!((print_stack.len() != 0us));\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n@@ -667,11 +667,11 @@ pub fn spaces(p: &mut Printer, n: usize) -> io::IoResult<()> {\n }\n \n pub fn zerobreak(p: &mut Printer) -> io::IoResult<()> {\n-    spaces(p, 0u)\n+    spaces(p, 0us)\n }\n \n pub fn space(p: &mut Printer) -> io::IoResult<()> {\n-    spaces(p, 1u)\n+    spaces(p, 1us)\n }\n \n pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {"}, {"sha": "78a97f310d252cf82eb4819f9b0db88623a74678", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -381,7 +381,7 @@ pub fn block_to_string(blk: &ast::Block) -> String {\n         // containing cbox, will be closed by print-block at }\n         try!(s.cbox(indent_unit));\n         // head-ibox, will be closed by print-block after {\n-        try!(s.ibox(0u));\n+        try!(s.ibox(0us));\n         s.print_block(blk)\n     })\n }\n@@ -520,7 +520,7 @@ impl<'a> State<'a> {\n     pub fn bclose_maybe_open (&mut self, span: codemap::Span,\n                               indented: usize, close_box: bool) -> IoResult<()> {\n         try!(self.maybe_print_comment(span.hi));\n-        try!(self.break_offset_if_not_bol(1u, -(indented as isize)));\n+        try!(self.break_offset_if_not_bol(1us, -(indented as isize)));\n         try!(word(&mut self.s, \"}\"));\n         if close_box {\n             try!(self.end()); // close the outer-box\n@@ -595,7 +595,7 @@ impl<'a> State<'a> {\n     pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> IoResult<()> where\n         F: FnMut(&mut State, &T) -> IoResult<()>,\n     {\n-        try!(self.rbox(0u, b));\n+        try!(self.rbox(0us, b));\n         let mut first = true;\n         for elt in elts.iter() {\n             if first { first = false; } else { try!(self.word_space(\",\")); }\n@@ -613,13 +613,13 @@ impl<'a> State<'a> {\n         F: FnMut(&mut State, &T) -> IoResult<()>,\n         G: FnMut(&T) -> codemap::Span,\n     {\n-        try!(self.rbox(0u, b));\n+        try!(self.rbox(0us, b));\n         let len = elts.len();\n-        let mut i = 0u;\n+        let mut i = 0us;\n         for elt in elts.iter() {\n             try!(self.maybe_print_comment(get_span(elt).hi));\n             try!(op(self, elt));\n-            i += 1u;\n+            i += 1us;\n             if i < len {\n                 try!(word(&mut self.s, \",\"));\n                 try!(self.maybe_print_trailing_comment(get_span(elt),\n@@ -670,7 +670,7 @@ impl<'a> State<'a> {\n \n     pub fn print_type(&mut self, ty: &ast::Ty) -> IoResult<()> {\n         try!(self.maybe_print_comment(ty.span.lo));\n-        try!(self.ibox(0u));\n+        try!(self.ibox(0us));\n         match ty.node {\n             ast::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n@@ -871,7 +871,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n-                try!(self.ibox(0u));\n+                try!(self.ibox(0us));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(params));\n@@ -1262,7 +1262,7 @@ impl<'a> State<'a> {\n \n     pub fn print_outer_attributes(&mut self,\n                                   attrs: &[ast::Attribute]) -> IoResult<()> {\n-        let mut count = 0u;\n+        let mut count = 0us;\n         for attr in attrs.iter() {\n             match attr.node.style {\n                 ast::AttrOuter => {\n@@ -1280,7 +1280,7 @@ impl<'a> State<'a> {\n \n     pub fn print_inner_attributes(&mut self,\n                                   attrs: &[ast::Attribute]) -> IoResult<()> {\n-        let mut count = 0u;\n+        let mut count = 0us;\n         for attr in attrs.iter() {\n             match attr.node.style {\n                 ast::AttrInner => {\n@@ -1404,8 +1404,8 @@ impl<'a> State<'a> {\n                 match _else.node {\n                     // \"another else-if\"\n                     ast::ExprIf(ref i, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1u));\n-                        try!(self.ibox(0u));\n+                        try!(self.cbox(indent_unit - 1us));\n+                        try!(self.ibox(0us));\n                         try!(word(&mut self.s, \" else if \"));\n                         try!(self.print_expr(&**i));\n                         try!(space(&mut self.s));\n@@ -1414,8 +1414,8 @@ impl<'a> State<'a> {\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1u));\n-                        try!(self.ibox(0u));\n+                        try!(self.cbox(indent_unit - 1us));\n+                        try!(self.ibox(0us));\n                         try!(word(&mut self.s, \" else if let \"));\n                         try!(self.print_pat(&**pat));\n                         try!(space(&mut self.s));\n@@ -1427,8 +1427,8 @@ impl<'a> State<'a> {\n                     }\n                     // \"final else\"\n                     ast::ExprBlock(ref b) => {\n-                        try!(self.cbox(indent_unit - 1u));\n-                        try!(self.ibox(0u));\n+                        try!(self.cbox(indent_unit - 1us));\n+                        try!(self.ibox(0us));\n                         try!(word(&mut self.s, \" else \"));\n                         self.print_block(&**b)\n                     }\n@@ -1594,7 +1594,7 @@ impl<'a> State<'a> {\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_ident(ident.node));\n-        if tys.len() > 0u {\n+        if tys.len() > 0us {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n                                |s, ty| s.print_type(&**ty)));\n@@ -1765,7 +1765,7 @@ impl<'a> State<'a> {\n                 // containing cbox, will be closed by print-block at }\n                 try!(self.cbox(indent_unit));\n                 // head-box, will be closed by print-block after {\n-                try!(self.ibox(0u));\n+                try!(self.ibox(0us));\n                 try!(self.print_block(&**blk));\n             }\n             ast::ExprAssign(ref lhs, ref rhs) => {\n@@ -2142,7 +2142,7 @@ impl<'a> State<'a> {\n                     },\n                     |f| f.node.pat.span));\n                 if etc {\n-                    if fields.len() != 0u { try!(self.word_space(\",\")); }\n+                    if fields.len() != 0us { try!(self.word_space(\",\")); }\n                     try!(word(&mut self.s, \"..\"));\n                 }\n                 try!(space(&mut self.s));\n@@ -2209,7 +2209,7 @@ impl<'a> State<'a> {\n             try!(space(&mut self.s));\n         }\n         try!(self.cbox(indent_unit));\n-        try!(self.ibox(0u));\n+        try!(self.ibox(0us));\n         try!(self.print_outer_attributes(&arm.attrs[]));\n         let mut first = true;\n         for p in arm.pats.iter() {\n@@ -2295,7 +2295,7 @@ impl<'a> State<'a> {\n         -> IoResult<()> {\n         // It is unfortunate to duplicate the commasep logic, but we want the\n         // self type and the args all in the same box.\n-        try!(self.rbox(0u, Inconsistent));\n+        try!(self.rbox(0us, Inconsistent));\n         let mut first = true;\n         for &explicit_self in opt_explicit_self.iter() {\n             let m = match explicit_self {\n@@ -2472,7 +2472,7 @@ impl<'a> State<'a> {\n         try!(word(&mut self.s, \"<\"));\n \n         let mut ints = Vec::new();\n-        for i in range(0u, total) {\n+        for i in range(0us, total) {\n             ints.push(i);\n         }\n \n@@ -2794,7 +2794,7 @@ impl<'a> State<'a> {\n                 if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                     span_line.line == comment_line.line {\n                         try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit.cur_cmnt += 1u;\n+                        self.cur_cmnt_and_lit.cur_cmnt += 1us;\n                     }\n             }\n             _ => ()\n@@ -2812,7 +2812,7 @@ impl<'a> State<'a> {\n             match self.next_comment() {\n                 Some(ref cmnt) => {\n                     try!(self.print_comment(cmnt));\n-                    self.cur_cmnt_and_lit.cur_cmnt += 1u;\n+                    self.cur_cmnt_and_lit.cur_cmnt += 1us;\n                 }\n                 _ => break\n             }\n@@ -2894,7 +2894,7 @@ impl<'a> State<'a> {\n                 while self.cur_cmnt_and_lit.cur_lit < lits.len() {\n                     let ltrl = (*lits)[self.cur_cmnt_and_lit.cur_lit].clone();\n                     if ltrl.pos > pos { return None; }\n-                    self.cur_cmnt_and_lit.cur_lit += 1u;\n+                    self.cur_cmnt_and_lit.cur_lit += 1us;\n                     if ltrl.pos == pos { return Some(ltrl); }\n                 }\n                 None\n@@ -2909,7 +2909,7 @@ impl<'a> State<'a> {\n                 Some(ref cmnt) => {\n                     if (*cmnt).pos < pos {\n                         try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit.cur_cmnt += 1u;\n+                        self.cur_cmnt_and_lit.cur_cmnt += 1us;\n                     } else { break; }\n                 }\n                 _ => break\n@@ -2922,7 +2922,7 @@ impl<'a> State<'a> {\n                          cmnt: &comments::Comment) -> IoResult<()> {\n         match cmnt.style {\n             comments::Mixed => {\n-                assert_eq!(cmnt.lines.len(), 1u);\n+                assert_eq!(cmnt.lines.len(), 1us);\n                 try!(zerobreak(&mut self.s));\n                 try!(word(&mut self.s, &cmnt.lines[0][]));\n                 zerobreak(&mut self.s)\n@@ -2941,11 +2941,11 @@ impl<'a> State<'a> {\n             }\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n-                if cmnt.lines.len() == 1u {\n+                if cmnt.lines.len() == 1us {\n                     try!(word(&mut self.s, &cmnt.lines[0][]));\n                     hardbreak(&mut self.s)\n                 } else {\n-                    try!(self.ibox(0u));\n+                    try!(self.ibox(0us));\n                     for line in cmnt.lines.iter() {\n                         if !line.is_empty() {\n                             try!(word(&mut self.s, &line[]));"}, {"sha": "ee8742825f46bb981aad4bc089bdef942f6cd68e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -345,8 +345,8 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n                 let tparm_cnt = generics.ty_params.len();\n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n-                input_cnt == 1u\n-                    && no_output && tparm_cnt == 0u\n+                input_cnt == 1us\n+                    && no_output && tparm_cnt == 0us\n             }\n           _ => false\n         }"}, {"sha": "d8bac19805b27eb5000e74292a159a7443b0ab98", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c32cd1be27f321658382e39d34f5d993d99ae8b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=3c32cd1be27f321658382e39d34f5d993d99ae8b", "patch": "@@ -194,14 +194,14 @@ mod test {\n         let v: SmallVector<isize> = SmallVector::zero();\n         assert_eq!(0, v.len());\n \n-        assert_eq!(1, SmallVector::one(1i).len());\n-        assert_eq!(5, SmallVector::many(vec!(1i, 2, 3, 4, 5)).len());\n+        assert_eq!(1, SmallVector::one(1is).len());\n+        assert_eq!(5, SmallVector::many(vec!(1is, 2, 3, 4, 5)).len());\n     }\n \n     #[test]\n     fn test_push_get() {\n         let mut v = SmallVector::zero();\n-        v.push(1i);\n+        v.push(1is);\n         assert_eq!(1, v.len());\n         assert_eq!(&1, v.get(0));\n         v.push(2);\n@@ -227,11 +227,11 @@ mod test {\n         let v: Vec<isize> = v.into_iter().collect();\n         assert_eq!(Vec::new(), v);\n \n-        let v = SmallVector::one(1i);\n-        assert_eq!(vec!(1i), v.into_iter().collect::<Vec<_>>());\n+        let v = SmallVector::one(1is);\n+        assert_eq!(vec!(1is), v.into_iter().collect::<Vec<_>>());\n \n-        let v = SmallVector::many(vec!(1i, 2i, 3i));\n-        assert_eq!(vec!(1i, 2i, 3i), v.into_iter().collect::<Vec<_>>());\n+        let v = SmallVector::many(vec!(1is, 2is, 3is));\n+        assert_eq!(vec!(1is, 2is, 3is), v.into_iter().collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -243,12 +243,12 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_expect_one_many() {\n-        SmallVector::many(vec!(1i, 2)).expect_one(\"\");\n+        SmallVector::many(vec!(1is, 2)).expect_one(\"\");\n     }\n \n     #[test]\n     fn test_expect_one_one() {\n-        assert_eq!(1i, SmallVector::one(1i).expect_one(\"\"));\n-        assert_eq!(1i, SmallVector::many(vec!(1i)).expect_one(\"\"));\n+        assert_eq!(1is, SmallVector::one(1is).expect_one(\"\"));\n+        assert_eq!(1is, SmallVector::many(vec!(1is)).expect_one(\"\"));\n     }\n }"}]}