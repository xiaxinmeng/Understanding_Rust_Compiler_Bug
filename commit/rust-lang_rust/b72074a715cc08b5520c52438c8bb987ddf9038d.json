{"sha": "b72074a715cc08b5520c52438c8bb987ddf9038d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MjA3NGE3MTVjYzA4YjU1MjBjNTI0MzhjOGJiOTg3ZGRmOTAzOGQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-26T12:10:56Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-26T12:10:56Z"}, "message": "Use ItemOrMacro in item resolution", "tree": {"sha": "ac1e51b23bbe2c1f4fd6ebddba394531758563ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac1e51b23bbe2c1f4fd6ebddba394531758563ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b72074a715cc08b5520c52438c8bb987ddf9038d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b72074a715cc08b5520c52438c8bb987ddf9038d", "html_url": "https://github.com/rust-lang/rust/commit/b72074a715cc08b5520c52438c8bb987ddf9038d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b72074a715cc08b5520c52438c8bb987ddf9038d/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0dc14ba5a0ad9f92d1c9795e252eeed45a912e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0dc14ba5a0ad9f92d1c9795e252eeed45a912e2", "html_url": "https://github.com/rust-lang/rust/commit/c0dc14ba5a0ad9f92d1c9795e252eeed45a912e2"}], "stats": {"total": 308, "additions": 214, "deletions": 94}, "files": [{"sha": "4735256b4b7ffa3008ed010b943eb99e1c5f526f", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=b72074a715cc08b5520c52438c8bb987ddf9038d", "patch": "@@ -13,7 +13,7 @@ use crate::{\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::HasGenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n-    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId},\n+    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId, MacroDefId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n     diagnostics::{DiagnosticSink},\n@@ -937,6 +937,11 @@ impl Docs for TypeAlias {\n         docs_from_ast(&*self.source(db).1)\n     }\n }\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroDef {\n+    pub(crate) id: MacroDefId,\n+}\n+\n \n pub enum Container {\n     Trait(Trait),"}, {"sha": "cb09c60f8abc910f429d11468ad9bbf57fe1102d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=b72074a715cc08b5520c52438c8bb987ddf9038d", "patch": "@@ -80,5 +80,5 @@ pub use self::code_model::{\n     Function, FnSignature,\n     StructField, FieldSource,\n     Static, Const, ConstSignature,\n-    Trait, TypeAlias, Container\n+    Trait, TypeAlias, MacroDef, Container\n };"}, {"sha": "9b9212bfcb787cb83681cb6895780c91a72021b0", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 81, "deletions": 34, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=b72074a715cc08b5520c52438c8bb987ddf9038d", "patch": "@@ -56,14 +56,15 @@ mod tests;\n use std::sync::Arc;\n \n use rustc_hash::{FxHashMap, FxHashSet};\n+use either::Either;\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n use ra_syntax::ast;\n use ra_prof::profile;\n \n use crate::{\n-    ModuleDef, Name, Crate, Module,\n+    ModuleDef, Name, Crate, Module, MacroDef,\n     DefDatabase, Path, PathKind, HirFileId, Trait,\n     ids::MacroDefId,\n     diagnostics::DiagnosticSink,\n@@ -136,6 +137,7 @@ pub(crate) struct ModuleData {\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n+    macros: FxHashMap<Name, MacroDef>,\n }\n \n impl ModuleScope {\n@@ -151,8 +153,17 @@ impl ModuleScope {\n             _ => None,\n         })\n     }\n+    fn get_item_or_macro(&self, name: &Name) -> Option<ItemOrMacro> {\n+        match (self.items.get(name), self.macros.get(name)) {\n+            (Some(item), _) if !item.def.is_none() => Some(Either::Left(item.def)),\n+            (_, Some(macro_)) => Some(Either::Right(*macro_)),\n+            _ => None,\n+        }\n+    }\n }\n \n+type ItemOrMacro = Either<PerNs<ModuleDef>, MacroDef>;\n+\n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct Resolution {\n     /// None for unresolved\n@@ -163,18 +174,18 @@ pub struct Resolution {\n \n #[derive(Debug, Clone)]\n struct ResolvePathResult {\n-    resolved_def: PerNs<ModuleDef>,\n+    resolved_def: ItemOrMacro,\n     segment_index: Option<usize>,\n     reached_fixedpoint: ReachedFixedPoint,\n }\n \n impl ResolvePathResult {\n     fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+        ResolvePathResult::with(Either::Left(PerNs::none()), reached_fixedpoint, None)\n     }\n \n     fn with(\n-        resolved_def: PerNs<ModuleDef>,\n+        resolved_def: ItemOrMacro,\n         reached_fixedpoint: ReachedFixedPoint,\n         segment_index: Option<usize>,\n     ) -> ResolvePathResult {\n@@ -194,6 +205,21 @@ enum ReachedFixedPoint {\n     No,\n }\n \n+/// helper function for select item or macro to use\n+fn or(left: ItemOrMacro, right: ItemOrMacro) -> ItemOrMacro {\n+    match (left, right) {\n+        (Either::Left(s), Either::Left(o)) => Either::Left(s.or(o)),\n+        (Either::Right(s), _) => Either::Right(s),\n+        (Either::Left(s), Either::Right(o)) => {\n+            if !s.is_none() {\n+                Either::Left(s)\n+            } else {\n+                Either::Right(o)\n+            }\n+        }\n+    }\n+}\n+\n impl CrateDefMap {\n     pub(crate) fn crate_def_map_query(db: &impl DefDatabase, krate: Crate) -> Arc<CrateDefMap> {\n         let _p = profile(\"crate_def_map_query\");\n@@ -268,7 +294,17 @@ impl CrateDefMap {\n         original_module: CrateModuleId,\n         path: &Path,\n     ) -> (PerNs<ModuleDef>, Option<usize>) {\n-        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n+        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n+        (res.resolved_def.left().unwrap_or_else(PerNs::none), res.segment_index)\n+    }\n+\n+    fn resolve_path_with_macro(\n+        &self,\n+        db: &impl DefDatabase,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> (ItemOrMacro, Option<usize>) {\n+        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n \n@@ -278,21 +314,21 @@ impl CrateDefMap {\n \n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n-    fn resolve_path_fp(\n+    fn resolve_path_fp_with_macro(\n         &self,\n         db: &impl DefDatabase,\n         mode: ResolveMode,\n         original_module: CrateModuleId,\n         path: &Path,\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n-            PathKind::Crate => {\n-                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n-            }\n-            PathKind::Self_ => {\n-                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n-            }\n+        let mut curr_per_ns: ItemOrMacro = match path.kind {\n+            PathKind::Crate => Either::Left(PerNs::types(\n+                Module { krate: self.krate, module_id: self.root }.into(),\n+            )),\n+            PathKind::Self_ => Either::Left(PerNs::types(\n+                Module { krate: self.krate, module_id: original_module }.into(),\n+            )),\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -314,11 +350,11 @@ impl CrateDefMap {\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n+                self.resolve_name_in_module_with_macro(db, original_module, &segment.name)\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n+                    Either::Left(PerNs::types(Module { krate: self.krate, module_id: p }.into()))\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -332,15 +368,15 @@ impl CrateDefMap {\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment.name) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n+                    Either::Left(PerNs::types(*def))\n                 } else {\n                     return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n         };\n \n         for (i, segment) in segments {\n-            let curr = match curr_per_ns.as_ref().take_types() {\n+            let curr = match curr_per_ns.as_ref().left().map_or(None, |m| m.as_ref().take_types()) {\n                 Some(r) => r,\n                 None => {\n                     // we still have path segments left, but the path so far\n@@ -362,16 +398,17 @@ impl CrateDefMap {\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        let (def, s) =\n+                            defp_map.resolve_path_with_macro(db, module.module_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n                             s.map(|s| s + i),\n                         );\n                     }\n \n-                    match self[module.module_id].scope.items.get(&segment.name) {\n-                        Some(res) if !res.def.is_none() => res.def,\n+                    match self[module.module_id].scope.get_item_or_macro(&segment.name) {\n+                        Some(res) => res,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n                             return ResolvePathResult::empty(ReachedFixedPoint::No);\n@@ -382,10 +419,10 @@ impl CrateDefMap {\n                     // enum variant\n                     tested_by!(can_import_enum_variant);\n                     match e.variant(db, &segment.name) {\n-                        Some(variant) => PerNs::both(variant.into(), variant.into()),\n+                        Some(variant) => Either::Left(PerNs::both(variant.into(), variant.into())),\n                         None => {\n                             return ResolvePathResult::with(\n-                                PerNs::types((*e).into()),\n+                                Either::Left(PerNs::types((*e).into())),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n                             );\n@@ -402,7 +439,7 @@ impl CrateDefMap {\n                     );\n \n                     return ResolvePathResult::with(\n-                        PerNs::types((*s).into()),\n+                        Either::Left(PerNs::types((*s).into())),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n                     );\n@@ -412,12 +449,12 @@ impl CrateDefMap {\n         ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n \n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> ItemOrMacro {\n         let from_crate_root =\n-            self[self.root].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n+            self[self.root].scope.get_item_or_macro(name).unwrap_or(Either::Left(PerNs::none()));\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n-        from_crate_root.or(from_extern_prelude)\n+        or(from_crate_root, Either::Left(from_extern_prelude))\n     }\n \n     pub(crate) fn resolve_name_in_module(\n@@ -426,32 +463,42 @@ impl CrateDefMap {\n         module: CrateModuleId,\n         name: &Name,\n     ) -> PerNs<ModuleDef> {\n+        self.resolve_name_in_module_with_macro(db, module, name).left().unwrap_or_else(PerNs::none)\n+    }\n+\n+    fn resolve_name_in_module_with_macro(\n+        &self,\n+        db: &impl DefDatabase,\n+        module: CrateModuleId,\n+        name: &Name,\n+    ) -> ItemOrMacro {\n         // Resolve in:\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n-        let from_scope = self[module].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_scope =\n+            self[module].scope.get_item_or_macro(name).unwrap_or(Either::Left(PerNs::none()));;\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name);\n \n-        from_scope.or(from_extern_prelude).or(from_prelude)\n+        or(from_scope, or(Either::Left(from_extern_prelude), from_prelude))\n     }\n \n     fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n         self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n     }\n \n-    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs<ModuleDef> {\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> ItemOrMacro {\n         if let Some(prelude) = self.prelude {\n             let resolution = if prelude.krate == self.krate {\n-                self[prelude.module_id].scope.items.get(name).cloned()\n+                self[prelude.module_id].scope.get_item_or_macro(name)\n             } else {\n-                db.crate_def_map(prelude.krate)[prelude.module_id].scope.items.get(name).cloned()\n+                db.crate_def_map(prelude.krate)[prelude.module_id].scope.get_item_or_macro(name)\n             };\n-            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n+            resolution.unwrap_or(Either::Left(PerNs::none()))\n         } else {\n-            PerNs::none()\n+            Either::Left(PerNs::none())\n         }\n     }\n }\n@@ -463,7 +510,7 @@ mod diagnostics {\n     use crate::{\n         AstId, DefDatabase,\n         nameres::CrateModuleId,\n-        diagnostics::{DiagnosticSink, UnresolvedModule},\n+        diagnostics::{DiagnosticSink, UnresolvedModule}\n };\n \n     #[derive(Debug, PartialEq, Eq)]"}, {"sha": "ba7ea001748554df60bb36bf0bea9751f38d555c", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 126, "deletions": 58, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b72074a715cc08b5520c52438c8bb987ddf9038d/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=b72074a715cc08b5520c52438c8bb987ddf9038d", "patch": "@@ -1,17 +1,18 @@\n use arrayvec::ArrayVec;\n use rustc_hash::FxHashMap;\n+use either::Either;\n use relative_path::RelativePathBuf;\n use test_utils::tested_by;\n use ra_db::FileId;\n use ra_syntax::ast;\n \n use crate::{\n-    Function, Module, Struct, Union, Enum, Const, Static, Trait, TypeAlias,\n+    Function, Module, Struct, Union, Enum, Const, Static, Trait, TypeAlias, MacroDef,\n     DefDatabase, HirFileId, Name, Path,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n-        CrateDefMap, CrateModuleId, ModuleData,\n+        CrateDefMap, CrateModuleId, ModuleData, ItemOrMacro,\n         diagnostics::DefDiagnostic,\n         raw,\n     },\n@@ -124,13 +125,21 @@ where\n         let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         // show unresolved imports in completion, etc\n         for (module_id, import, import_data) in unresolved_imports {\n-            self.record_resolved_import(module_id, PerNs::none(), import, &import_data)\n+            self.record_resolved_import(\n+                module_id,\n+                Either::Left(PerNs::none()),\n+                import,\n+                &import_data,\n+            )\n         }\n     }\n \n     fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n         if export {\n             self.def_map.public_macros.insert(name.clone(), macro_id);\n+\n+            let def = Either::Right(MacroDef { id: macro_id });\n+            self.update(self.def_map.root, None, &[(name.clone(), def)]);\n         } else {\n             self.def_map.local_macros.insert(name.clone(), macro_id);\n         }\n@@ -161,7 +170,7 @@ where\n         &self,\n         module_id: CrateModuleId,\n         import: &raw::ImportData,\n-    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n+    ) -> (ItemOrMacro, ReachedFixedPoint) {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n         if import.is_extern_crate {\n             let res = self.def_map.resolve_name_in_extern_prelude(\n@@ -170,10 +179,14 @@ where\n                     .as_ident()\n                     .expect(\"extern crate should have been desugared to one-element path\"),\n             );\n-            (res, ReachedFixedPoint::Yes)\n+            (Either::Left(res), ReachedFixedPoint::Yes)\n         } else {\n-            let res =\n-                self.def_map.resolve_path_fp(self.db, ResolveMode::Import, module_id, &import.path);\n+            let res = self.def_map.resolve_path_fp_with_macro(\n+                self.db,\n+                ResolveMode::Import,\n+                module_id,\n+                &import.path,\n+            );\n \n             (res.resolved_def, res.reached_fixedpoint)\n         }\n@@ -182,13 +195,13 @@ where\n     fn record_resolved_import(\n         &mut self,\n         module_id: CrateModuleId,\n-        def: PerNs<ModuleDef>,\n+        def: ItemOrMacro,\n         import_id: raw::ImportId,\n         import: &raw::ImportData,\n     ) {\n         if import.is_glob {\n             log::debug!(\"glob import: {:?}\", import);\n-            match def.take_types() {\n+            match def.left().and_then(|item| item.take_types()) {\n                 Some(ModuleDef::Module(m)) => {\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n@@ -201,9 +214,14 @@ where\n                         let items = scope\n                             .items\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n-                        self.update(module_id, Some(import_id), &items);\n+                            .map(|(name, res)| (name.clone(), Either::Left(res.clone())));\n+                        let macros = scope\n+                            .macros\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), Either::Right(res.clone())));\n+\n+                        let all = items.chain(macros).collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &all);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -212,9 +230,15 @@ where\n                         let items = scope\n                             .items\n                             .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n-                        self.update(module_id, Some(import_id), &items);\n+                            .map(|(name, res)| (name.clone(), Either::Left(res.clone())));\n+                        let macros = scope\n+                            .macros\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), Either::Right(res.clone())));\n+\n+                        let all = items.chain(macros).collect::<Vec<_>>();\n+\n+                        self.update(module_id, Some(import_id), &all);\n                         // record the glob import in case we add further items\n                         self.glob_imports\n                             .entry(m.module_id)\n@@ -234,7 +258,7 @@ where\n                                 import: Some(import_id),\n                             };\n                             let name = variant.name(self.db)?;\n-                            Some((name, res))\n+                            Some((name, Either::Left(res)))\n                         })\n                         .collect::<Vec<_>>();\n                     self.update(module_id, Some(import_id), &resolutions);\n@@ -254,11 +278,18 @@ where\n \n                     // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                     if import.is_extern_crate && module_id == self.def_map.root {\n-                        if let Some(def) = def.take_types() {\n+                        if let Some(def) = def.left().and_then(|item| item.take_types()) {\n                             self.def_map.extern_prelude.insert(name.clone(), def);\n                         }\n                     }\n-                    let resolution = Resolution { def, import: Some(import_id) };\n+\n+                    let resolution = match def {\n+                        Either::Left(item) => {\n+                            Either::Left(Resolution { def: item, import: Some(import_id) })\n+                        }\n+                        Either::Right(macro_) => Either::Right(macro_),\n+                    };\n+\n                     self.update(module_id, Some(import_id), &[(name, resolution)]);\n                 }\n                 None => tested_by!(bogus_paths),\n@@ -270,7 +301,7 @@ where\n         &mut self,\n         module_id: CrateModuleId,\n         import: Option<raw::ImportId>,\n-        resolutions: &[(Name, Resolution)],\n+        resolutions: &[(Name, Either<Resolution, MacroDef>)],\n     ) {\n         self.update_recursive(module_id, import, resolutions, 0)\n     }\n@@ -279,7 +310,7 @@ where\n         &mut self,\n         module_id: CrateModuleId,\n         import: Option<raw::ImportId>,\n-        resolutions: &[(Name, Resolution)],\n+        resolutions: &[(Name, Either<Resolution, MacroDef>)],\n         depth: usize,\n     ) {\n         if depth > 100 {\n@@ -289,25 +320,38 @@ where\n         let module_items = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            let existing = module_items.items.entry(name.clone()).or_default();\n-            if existing.def.types.is_none() && res.def.types.is_some() {\n-                existing.def.types = res.def.types;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.values.is_none() && res.def.values.is_some() {\n-                existing.def.values = res.def.values;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.is_none()\n-                && res.def.is_none()\n-                && existing.import.is_none()\n-                && res.import.is_some()\n-            {\n-                existing.import = res.import;\n+            match res {\n+                // item\n+                Either::Left(res) => {\n+                    let existing = module_items.items.entry(name.clone()).or_default();\n+\n+                    if existing.def.types.is_none() && res.def.types.is_some() {\n+                        existing.def.types = res.def.types;\n+                        existing.import = import.or(res.import);\n+                        changed = true;\n+                    }\n+                    if existing.def.values.is_none() && res.def.values.is_some() {\n+                        existing.def.values = res.def.values;\n+                        existing.import = import.or(res.import);\n+                        changed = true;\n+                    }\n+\n+                    if existing.def.is_none()\n+                        && res.def.is_none()\n+                        && existing.import.is_none()\n+                        && res.import.is_some()\n+                    {\n+                        existing.import = res.import;\n+                    }\n+                }\n+                // macro\n+                Either::Right(res) => {\n+                    // Always shadowing\n+                    module_items.macros.insert(name.clone(), *res);\n+                }\n             }\n         }\n+\n         if !changed {\n             return;\n         }\n@@ -324,32 +368,56 @@ where\n         }\n     }\n \n-    // XXX: this is just a pile of hacks now, because `PerNs` does not handle\n-    // macro namespace.\n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|(module_id, ast_id, path)| {\n-            if path.segments.len() != 2 {\n-                return true;\n+            let resolved_res = self.def_map.resolve_path_fp_with_macro(\n+                self.db,\n+                ResolveMode::Other,\n+                *module_id,\n+                path,\n+            );\n+\n+            if let Some(def) = resolved_res.resolved_def.right() {\n+                let call_id = MacroCallLoc { def: def.id, ast_id: *ast_id }.id(self.db);\n+                resolved.push((*module_id, call_id, def.id));\n+                res = ReachedFixedPoint::No;\n+                return false;\n             }\n-            let crate_name = &path.segments[0].name;\n-            let krate = match self.def_map.resolve_name_in_extern_prelude(crate_name).take_types() {\n-                Some(ModuleDef::Module(m)) => m.krate(self.db),\n-                _ => return true,\n-            };\n-            let krate = match krate {\n-                Some(it) => it,\n-                _ => return true,\n-            };\n-            res = ReachedFixedPoint::No;\n-            let def_map = self.db.crate_def_map(krate);\n-            if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n-                let call_id = MacroCallLoc { def: macro_id, ast_id: *ast_id }.id(self.db);\n-                resolved.push((*module_id, call_id, macro_id));\n+\n+            if resolved_res.reached_fixedpoint != ReachedFixedPoint::Yes {\n+                let crate_name = &path.segments[0].name;\n+\n+                // FIXME:\n+                // $crate are not handled in resolver right now\n+                if crate_name.to_string() == \"$crate\" {\n+                    return true;\n+                }\n+\n+                // FIXME:\n+                // Currently `#[cfg(test)]` are ignored and cargo-metadata do not insert\n+                // dev-dependencies of dependencies. For example,\n+                // if we depend on parking lot, and parking lot has a dev-dependency on lazy_static.\n+                // Then `lazy_static` wil not included in `CrateGraph`\n+                // We can fix that by proper handling `cfg(test)`.\n+                //\n+                // So right now we set the fixpoint to No only if its crate is in CrateGraph\n+                // See issue #1282 for details\n+                let krate =\n+                    match self.def_map.resolve_name_in_extern_prelude(crate_name).take_types() {\n+                        Some(ModuleDef::Module(m)) => m.krate(self.db),\n+                        _ => return true,\n+                    };\n+                if krate.is_none() {\n+                    return true;\n+                }\n+\n+                res = resolved_res.reached_fixedpoint;\n             }\n-            false\n+\n+            true\n         });\n \n         self.unexpanded_macros = macros;\n@@ -478,7 +546,7 @@ where\n             ),\n             import: None,\n         };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n+        self.def_collector.update(self.module_id, None, &[(name, Either::Left(resolution))]);\n         res\n     }\n \n@@ -509,7 +577,7 @@ where\n             raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n         };\n         let resolution = Resolution { def, import: None };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n+        self.def_collector.update(self.module_id, None, &[(name, Either::Left(resolution))])\n     }\n \n     fn collect_macro(&mut self, mac: &raw::MacroData) {"}]}