{"sha": "92613a25fc2c3a8f563025050c082f49b8a38019", "node_id": "C_kwDOAAsO6NoAKDkyNjEzYTI1ZmMyYzNhOGY1NjMwMjUwNTBjMDgyZjQ5YjhhMzgwMTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-13T05:44:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-13T05:44:12Z"}, "message": "Rollup merge of #89926 - the8472:saturate-instant, r=Mark-Simulacrum\n\nmake `Instant::{duration_since, elapsed, sub}` saturating and remove workarounds\n\nThis removes all mutex/atomic-based workarounds for non-monotonic clocks and makes the previously panicking methods saturating instead. Additionally `saturating_duration_since` becomes deprecated since `duration_since` now fills that role.\n\nEffectively this moves the fixup from `Instant` construction to the comparisons.\n\nThis has some observable effects, especially on platforms without monotonic clocks:\n\n* Incorrectly ordered Instant comparisons no longer panic in release mode. This could hide some programming errors, but since debug mode still panics tests can still catch them.\n* `checked_duration_since` will now return `None` in more cases. Previously it only happened when one compared instants obtained in the wrong order or manually created ones. Now it also does on backslides.\n* non-monotonic intervals will not be transitive, i.e. `b.duration_since(a) + c.duration_since(b) != c.duration_since(a)`\n\nThe upsides are reduced complexity and lower overhead of `Instant::now`.\n\n## Motivation\n\nCurrently we must choose between two poisons. One is high worst-case latency and jitter of `Instant::now()` due to explicit synchronization; see #83093 for benchmarks, the worst-case overhead is > 100x. The other is sporadic panics on specific, rare combinations of CPU/hypervisor/operating system due to platform bugs.\n\nUse-cases where low-overhead, fine-grained timestamps are needed - such as syscall tracing, performance profiles or sensor data acquisition (drone flight controllers were mentioned in a libs meeting) in multi-threaded programs - are negatively impacted by the synchronization.\n\nThe panics are user-visible (program crashes), hard to reproduce and can be triggered by any dependency that might be using Instants for any reason.\n\nA solution that is fast _and_ doesn't panic is desirable.\n\n----\n\ncloses #84448\ncloses #86470", "tree": {"sha": "9b8b24663eb72011d38964745866c24d3cd3e9c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b8b24663eb72011d38964745866c24d3cd3e9c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92613a25fc2c3a8f563025050c082f49b8a38019", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiCJqsCRBK7hj4Ov3rIwAAvlIIADQjQ7q7Lw2iZhAjiCBatqco\nGTAyRLCbsU4GYfjD4FfqoQmu3mVndabetX2umlUg17kDA2D8a2GbYdaE2toU9xtz\nzw75S928fNsNV7O5qhFjAvXDDRzajdj+Bzp3PZuIJAMtBPot0ftnwOTwxqDIRmNb\na1vNgNFR1fpyZn9Pyfxkqv/MB0DxeTv6cr5GwTGEC1hdKOPpVXrZrbjvdI818i2A\nDFM/IIKuw9xTq7hqIM9KXvyqAXB/HvmeMhJ88DCscUIY6el4rCfQphrpuSVuCEEg\nQegJTvEGQpXJbg0IE587fP6USj7wUdJWhca34Oqdy0/UTLnGp2ZfG46DxkKt09o=\n=dEY2\n-----END PGP SIGNATURE-----\n", "payload": "tree 9b8b24663eb72011d38964745866c24d3cd3e9c5\nparent 01c4c413012466214456767e6b013d036bbfeaea\nparent 37a1fc542fbf8c11356d4395f28d4ab7f936945d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644731052 +0100\ncommitter GitHub <noreply@github.com> 1644731052 +0100\n\nRollup merge of #89926 - the8472:saturate-instant, r=Mark-Simulacrum\n\nmake `Instant::{duration_since, elapsed, sub}` saturating and remove workarounds\n\nThis removes all mutex/atomic-based workarounds for non-monotonic clocks and makes the previously panicking methods saturating instead. Additionally `saturating_duration_since` becomes deprecated since `duration_since` now fills that role.\n\nEffectively this moves the fixup from `Instant` construction to the comparisons.\n\nThis has some observable effects, especially on platforms without monotonic clocks:\n\n* Incorrectly ordered Instant comparisons no longer panic in release mode. This could hide some programming errors, but since debug mode still panics tests can still catch them.\n* `checked_duration_since` will now return `None` in more cases. Previously it only happened when one compared instants obtained in the wrong order or manually created ones. Now it also does on backslides.\n* non-monotonic intervals will not be transitive, i.e. `b.duration_since(a) + c.duration_since(b) != c.duration_since(a)`\n\nThe upsides are reduced complexity and lower overhead of `Instant::now`.\n\n## Motivation\n\nCurrently we must choose between two poisons. One is high worst-case latency and jitter of `Instant::now()` due to explicit synchronization; see #83093 for benchmarks, the worst-case overhead is > 100x. The other is sporadic panics on specific, rare combinations of CPU/hypervisor/operating system due to platform bugs.\n\nUse-cases where low-overhead, fine-grained timestamps are needed - such as syscall tracing, performance profiles or sensor data acquisition (drone flight controllers were mentioned in a libs meeting) in multi-threaded programs - are negatively impacted by the synchronization.\n\nThe panics are user-visible (program crashes), hard to reproduce and can be triggered by any dependency that might be using Instants for any reason.\n\nA solution that is fast _and_ doesn't panic is desirable.\n\n----\n\ncloses #84448\ncloses #86470\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92613a25fc2c3a8f563025050c082f49b8a38019", "html_url": "https://github.com/rust-lang/rust/commit/92613a25fc2c3a8f563025050c082f49b8a38019", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92613a25fc2c3a8f563025050c082f49b8a38019/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01c4c413012466214456767e6b013d036bbfeaea", "url": "https://api.github.com/repos/rust-lang/rust/commits/01c4c413012466214456767e6b013d036bbfeaea", "html_url": "https://github.com/rust-lang/rust/commit/01c4c413012466214456767e6b013d036bbfeaea"}, {"sha": "37a1fc542fbf8c11356d4395f28d4ab7f936945d", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a1fc542fbf8c11356d4395f28d4ab7f936945d", "html_url": "https://github.com/rust-lang/rust/commit/37a1fc542fbf8c11356d4395f28d4ab7f936945d"}], "stats": {"total": 324, "additions": 57, "deletions": 267}, "files": [{"sha": "27173de6307290c6c2edc0d6d45551f0e152b74b", "filename": "library/std/src/sys/hermit/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -115,14 +115,6 @@ impl Instant {\n         Instant { t: time }\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant { t: Timespec::zero() }\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        true\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.t.sub_timespec(&other.t).ok()\n     }"}, {"sha": "25f13ee441aca60095c9e93ada5808aef5c33952", "filename": "library/std/src/sys/itron/time.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -14,15 +14,6 @@ impl Instant {\n         }\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant(0)\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        // There are ways to change the system time\n-        false\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.0.checked_sub(other.0).map(|ticks| {\n             // `SYSTIM` is measured in microseconds"}, {"sha": "db4cf2804bf13b111f9eff5bbce46d721bc337f4", "filename": "library/std/src/sys/sgx/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -25,14 +25,6 @@ impl Instant {\n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n         Some(Instant(self.0.checked_sub(*other)?))\n     }\n-\n-    pub fn actually_monotonic() -> bool {\n-        false\n-    }\n-\n-    pub const fn zero() -> Instant {\n-        Instant(Duration::from_secs(0))\n-    }\n }\n \n impl SystemTime {"}, {"sha": "59ddd1aa92f813d91151254fba2d5734ec887b45", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -154,14 +154,6 @@ mod inner {\n             Instant { t: unsafe { mach_absolute_time() } }\n         }\n \n-        pub const fn zero() -> Instant {\n-            Instant { t: 0 }\n-        }\n-\n-        pub fn actually_monotonic() -> bool {\n-            true\n-        }\n-\n         pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n             let diff = self.t.checked_sub(other.t)?;\n             let info = info();\n@@ -296,17 +288,6 @@ mod inner {\n             Instant { t: now(libc::CLOCK_MONOTONIC) }\n         }\n \n-        pub const fn zero() -> Instant {\n-            Instant { t: Timespec::zero() }\n-        }\n-\n-        pub fn actually_monotonic() -> bool {\n-            (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86_64\"))\n-                || (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86\"))\n-                || (cfg!(target_os = \"linux\") && cfg!(target_arch = \"aarch64\"))\n-                || cfg!(target_os = \"fuchsia\")\n-        }\n-\n         pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n             self.t.sub_timespec(&other.t).ok()\n         }"}, {"sha": "6d67b538a96bf5dfa47f86da629cf3f1736c9e34", "filename": "library/std/src/sys/unsupported/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -13,14 +13,6 @@ impl Instant {\n         panic!(\"time not implemented on this platform\")\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant(Duration::from_secs(0))\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        false\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.0.checked_sub(other.0)\n     }"}, {"sha": "088585654b948fa2f92a2acefc7e120c3ded648e", "filename": "library/std/src/sys/wasi/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -25,14 +25,6 @@ impl Instant {\n         Instant(current_time(wasi::CLOCKID_MONOTONIC))\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant(Duration::from_secs(0))\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        true\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.0.checked_sub(other.0)\n     }"}, {"sha": "a04908b541cdb58a859eba464d989be62c8ad2df", "filename": "library/std/src/sys/windows/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -41,14 +41,6 @@ impl Instant {\n         perf_counter::PerformanceCounterInstant::now().into()\n     }\n \n-    pub fn actually_monotonic() -> bool {\n-        false\n-    }\n-\n-    pub const fn zero() -> Instant {\n-        Instant { t: Duration::from_secs(0) }\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         // On windows there's a threshold below which we consider two timestamps\n         // equivalent due to measurement error. For more details + doc link,"}, {"sha": "df8a726e64ecb380f13bea12112dc0f03a564336", "filename": "library/std/src/time.rs", "status": "modified", "additions": 54, "deletions": 55, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -31,7 +31,6 @@\n \n #![stable(feature = \"time\", since = \"1.3.0\")]\n \n-mod monotonic;\n #[cfg(test)]\n mod tests;\n \n@@ -50,8 +49,8 @@ pub use core::time::FromFloatSecsError;\n /// A measurement of a monotonically nondecreasing clock.\n /// Opaque and useful only with [`Duration`].\n ///\n-/// Instants are always guaranteed to be no less than any previously measured\n-/// instant when created, and are often useful for tasks such as measuring\n+/// Instants are always guaranteed, barring [platform bugs], to be no less than any previously\n+/// measured instant when created, and are often useful for tasks such as measuring\n /// benchmarks or timing how long an operation takes.\n ///\n /// Note, however, that instants are **not** guaranteed to be **steady**. In other\n@@ -84,6 +83,8 @@ pub use core::time::FromFloatSecsError;\n /// }\n /// ```\n ///\n+/// [platform bugs]: Instant#monotonicity\n+///\n /// # OS-specific behaviors\n ///\n /// An `Instant` is a wrapper around system-specific types and it may behave\n@@ -125,6 +126,26 @@ pub use core::time::FromFloatSecsError;\n /// > structure cannot represent the new point in time.\n ///\n /// [`add`]: Instant::add\n+///\n+/// ## Monotonicity\n+///\n+/// On all platforms `Instant` will try to use an OS API that guarantees monotonic behavior\n+/// if available, which is the case for all [tier 1] platforms.\n+/// In practice such guarantees are \u2013 under rare circumstances \u2013 broken by hardware, virtualization\n+/// or operating system bugs. To work around these bugs and platforms not offering monotonic clocks\n+/// [`duration_since`], [`elapsed`] and [`sub`] saturate to zero. In older Rust versions this\n+/// lead to a panic instead. [`checked_duration_since`] can be used to detect and handle situations\n+/// where monotonicity is violated, or `Instant`s are subtracted in the wrong order.\n+///\n+/// This workaround obscures programming errors where earlier and later instants are accidentally\n+/// swapped. For this reason future rust versions may reintroduce panics.\n+///\n+/// [tier 1]: https://doc.rust-lang.org/rustc/platform-support.html\n+/// [`duration_since`]: Instant::duration_since\n+/// [`elapsed`]: Instant::elapsed\n+/// [`sub`]: Instant::sub\n+/// [`checked_duration_since`]: Instant::checked_duration_since\n+///\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct Instant(time::Instant);\n@@ -247,59 +268,19 @@ impl Instant {\n     #[must_use]\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn now() -> Instant {\n-        let os_now = time::Instant::now();\n-\n-        // And here we come upon a sad state of affairs. The whole point of\n-        // `Instant` is that it's monotonically increasing. We've found in the\n-        // wild, however, that it's not actually monotonically increasing for\n-        // one reason or another. These appear to be OS and hardware level bugs,\n-        // and there's not really a whole lot we can do about them. Here's a\n-        // taste of what we've found:\n-        //\n-        // * #48514 - OpenBSD, x86_64\n-        // * #49281 - linux arm64 and s390x\n-        // * #51648 - windows, x86\n-        // * #56560 - windows, x86_64, AWS\n-        // * #56612 - windows, x86, vm (?)\n-        // * #56940 - linux, arm64\n-        // * https://bugzilla.mozilla.org/show_bug.cgi?id=1487778 - a similar\n-        //   Firefox bug\n-        //\n-        // It seems that this just happens a lot in the wild.\n-        // We're seeing panics across various platforms where consecutive calls\n-        // to `Instant::now`, such as via the `elapsed` function, are panicking\n-        // as they're going backwards. Placed here is a last-ditch effort to try\n-        // to fix things up. We keep a global \"latest now\" instance which is\n-        // returned instead of what the OS says if the OS goes backwards.\n-        //\n-        // To hopefully mitigate the impact of this, a few platforms are\n-        // excluded as \"these at least haven't gone backwards yet\".\n-        //\n-        // While issues have been seen on arm64 platforms the Arm architecture\n-        // requires that the counter monotonically increases and that it must\n-        // provide a uniform view of system time (e.g. it must not be possible\n-        // for a core to receive a message from another core with a time stamp\n-        // and observe time going backwards (ARM DDI 0487G.b D11.1.2). While\n-        // there have been a few 64bit SoCs that have bugs which cause time to\n-        // not monoticially increase, these have been fixed in the Linux kernel\n-        // and we shouldn't penalize all Arm SoCs for those who refuse to\n-        // update their kernels:\n-        // SUN50I_ERRATUM_UNKNOWN1 - Allwinner A64 / Pine A64 - fixed in 5.1\n-        // FSL_ERRATUM_A008585 - Freescale LS2080A/LS1043A - fixed in 4.10\n-        // HISILICON_ERRATUM_161010101 - Hisilicon 1610 - fixed in 4.11\n-        // ARM64_ERRATUM_858921 - Cortex A73 - fixed in 4.12\n-        if time::Instant::actually_monotonic() {\n-            return Instant(os_now);\n-        }\n-\n-        Instant(monotonic::monotonize(os_now))\n+        Instant(time::Instant::now())\n     }\n \n-    /// Returns the amount of time elapsed from another instant to this one.\n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or zero duration if that instant is later than this one.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `earlier` is later than `self`.\n+    /// Previous rust versions panicked when `earlier` was later than `self`. Currently this\n+    /// method saturates. Future versions may reintroduce the panic in some circumstances.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n     ///\n     /// # Examples\n     ///\n@@ -311,16 +292,22 @@ impl Instant {\n     /// sleep(Duration::new(1, 0));\n     /// let new_now = Instant::now();\n     /// println!(\"{:?}\", new_now.duration_since(now));\n+    /// println!(\"{:?}\", now.duration_since(new_now)); // 0ns\n     /// ```\n     #[must_use]\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn duration_since(&self, earlier: Instant) -> Duration {\n-        self.0.checked_sub_instant(&earlier.0).expect(\"supplied instant is later than self\")\n+        self.checked_duration_since(earlier).unwrap_or_default()\n     }\n \n     /// Returns the amount of time elapsed from another instant to this one,\n     /// or None if that instant is later than this one.\n     ///\n+    /// Due to [monotonicity bugs], even under correct logical ordering of the passed `Instant`s,\n+    /// this method can return `None`.\n+    ///\n+    /// [monotonicity bugs]: Instant#monotonicity\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -364,9 +351,11 @@ impl Instant {\n     ///\n     /// # Panics\n     ///\n-    /// This function may panic if the current time is earlier than this\n-    /// instant, which is something that can happen if an `Instant` is\n-    /// produced synthetically.\n+    /// Previous rust versions panicked when self was earlier than the current time. Currently this\n+    /// method returns a Duration of zero in that case. Future versions may reintroduce the panic.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n     ///\n     /// # Examples\n     ///\n@@ -442,6 +431,16 @@ impl SubAssign<Duration> for Instant {\n impl Sub<Instant> for Instant {\n     type Output = Duration;\n \n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or zero duration if that instant is later than this one.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Previous rust versions panicked when `other` was later than `self`. Currently this\n+    /// method saturates. Future versions may reintroduce the panic in some circumstances.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n     fn sub(self, other: Instant) -> Duration {\n         self.duration_since(other)\n     }"}, {"sha": "64f16245c2b1643f902afe8b0b3e67dc1402a5b9", "filename": "library/std/src/time/monotonic.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/01c4c413012466214456767e6b013d036bbfeaea/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c4c413012466214456767e6b013d036bbfeaea/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs?ref=01c4c413012466214456767e6b013d036bbfeaea", "patch": "@@ -1,116 +0,0 @@\n-use crate::sys::time;\n-\n-#[inline]\n-pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n-    inner::monotonize(raw)\n-}\n-\n-#[cfg(any(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")), target_arch = \"aarch64\"))]\n-pub mod inner {\n-    use crate::sync::atomic::AtomicU64;\n-    use crate::sync::atomic::Ordering::*;\n-    use crate::sys::time;\n-    use crate::time::Duration;\n-\n-    pub(in crate::time) const ZERO: time::Instant = time::Instant::zero();\n-\n-    // bits 30 and 31 are never used since the nanoseconds part never exceeds 10^9\n-    const UNINITIALIZED: u64 = 0b11 << 30;\n-    static MONO: AtomicU64 = AtomicU64::new(UNINITIALIZED);\n-\n-    #[inline]\n-    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n-        monotonize_impl(&MONO, raw)\n-    }\n-\n-    #[inline]\n-    pub(in crate::time) fn monotonize_impl(mono: &AtomicU64, raw: time::Instant) -> time::Instant {\n-        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n-        let secs = delta.as_secs();\n-        // occupies no more than 30 bits (10^9 seconds)\n-        let nanos = delta.subsec_nanos() as u64;\n-\n-        // This wraps around every 136 years (2^32 seconds).\n-        // To detect backsliding we use wrapping arithmetic and declare forward steps smaller\n-        // than 2^31 seconds as expected and everything else as a backslide which will be\n-        // monotonized.\n-        // This could be a problem for programs that call instants at intervals greater\n-        // than 68 years. Interstellar probes may want to ensure that actually_monotonic() is true.\n-        let packed = (secs << 32) | nanos;\n-        let updated = mono.fetch_update(Relaxed, Relaxed, |old| {\n-            (old == UNINITIALIZED || packed.wrapping_sub(old) < u64::MAX / 2).then_some(packed)\n-        });\n-        match updated {\n-            Ok(_) => raw,\n-            Err(newer) => {\n-                // Backslide occurred. We reconstruct monotonized time from the upper 32 bit of the\n-                // passed in value and the 64bits loaded from the atomic\n-                let seconds_lower = newer >> 32;\n-                let mut seconds_upper = secs & 0xffff_ffff_0000_0000;\n-                if secs & 0xffff_ffff > seconds_lower {\n-                    // Backslide caused the lower 32bit of the seconds part to wrap.\n-                    // This must be the case because the seconds part is larger even though\n-                    // we are in the backslide branch, i.e. the seconds count should be smaller or equal.\n-                    //\n-                    // We assume that backslides are smaller than 2^32 seconds\n-                    // which means we need to add 1 to the upper half to restore it.\n-                    //\n-                    // Example:\n-                    // most recent observed time: 0xA1_0000_0000_0000_0000u128\n-                    // bits stored in AtomicU64:     0x0000_0000_0000_0000u64\n-                    // backslide by 1s\n-                    // caller time is             0xA0_ffff_ffff_0000_0000u128\n-                    // -> we can fix up the upper half time by adding 1 << 32\n-                    seconds_upper = seconds_upper.wrapping_add(0x1_0000_0000);\n-                }\n-                let secs = seconds_upper | seconds_lower;\n-                let nanos = newer as u32;\n-                ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(all(target_has_atomic = \"128\", not(target_arch = \"aarch64\")))]\n-pub mod inner {\n-    use crate::sync::atomic::AtomicU128;\n-    use crate::sync::atomic::Ordering::*;\n-    use crate::sys::time;\n-    use crate::time::Duration;\n-\n-    const ZERO: time::Instant = time::Instant::zero();\n-    static MONO: AtomicU128 = AtomicU128::new(0);\n-\n-    #[inline]\n-    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n-        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n-        // Split into seconds and nanos since Duration doesn't have a\n-        // constructor that takes a u128\n-        let secs = delta.as_secs() as u128;\n-        let nanos = delta.subsec_nanos() as u128;\n-        let timestamp: u128 = secs << 64 | nanos;\n-        let timestamp = MONO.fetch_max(timestamp, Relaxed).max(timestamp);\n-        let secs = (timestamp >> 64) as u64;\n-        let nanos = timestamp as u32;\n-        ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n-    }\n-}\n-\n-#[cfg(not(any(target_has_atomic = \"64\", target_has_atomic = \"128\")))]\n-pub mod inner {\n-    use crate::cmp;\n-    use crate::sys::time;\n-    use crate::sys_common::mutex::StaticMutex;\n-\n-    #[inline]\n-    pub(super) fn monotonize(os_now: time::Instant) -> time::Instant {\n-        static LOCK: StaticMutex = StaticMutex::new();\n-        static mut LAST_NOW: time::Instant = time::Instant::zero();\n-        unsafe {\n-            let _lock = LOCK.lock();\n-            let now = cmp::max(LAST_NOW, os_now);\n-            LAST_NOW = now;\n-            now\n-        }\n-    }\n-}"}, {"sha": "d1a69ff8697c654422b31191a0b5e878fcc828fb", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92613a25fc2c3a8f563025050c082f49b8a38019/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=92613a25fc2c3a8f563025050c082f49b8a38019", "patch": "@@ -90,10 +90,9 @@ fn instant_math_is_associative() {\n }\n \n #[test]\n-#[should_panic]\n-fn instant_duration_since_panic() {\n+fn instant_duration_since_saturates() {\n     let a = Instant::now();\n-    let _ = (a - Duration::SECOND).duration_since(a);\n+    assert_eq!((a - Duration::SECOND).duration_since(a), Duration::ZERO);\n }\n \n #[test]\n@@ -109,6 +108,7 @@ fn instant_checked_duration_since_nopanic() {\n #[test]\n fn instant_saturating_duration_since_nopanic() {\n     let a = Instant::now();\n+    #[allow(deprecated, deprecated_in_future)]\n     let ret = (a - Duration::SECOND).saturating_duration_since(a);\n     assert_eq!(ret, Duration::ZERO);\n }\n@@ -192,31 +192,6 @@ fn since_epoch() {\n     assert!(a < hundred_twenty_years);\n }\n \n-#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n-#[test]\n-fn monotonizer_wrapping_backslide() {\n-    use super::monotonic::inner::{monotonize_impl, ZERO};\n-    use core::sync::atomic::AtomicU64;\n-\n-    let reference = AtomicU64::new(0);\n-\n-    let time = match ZERO.checked_add_duration(&Duration::from_secs(0xffff_ffff)) {\n-        Some(time) => time,\n-        None => {\n-            // platform cannot represent u32::MAX seconds so it won't have to deal with this kind\n-            // of overflow either\n-            return;\n-        }\n-    };\n-\n-    let monotonized = monotonize_impl(&reference, time);\n-    let expected = ZERO.checked_add_duration(&Duration::from_secs(1 << 32)).unwrap();\n-    assert_eq!(\n-        monotonized, expected,\n-        \"64bit monotonizer should handle overflows in the seconds part\"\n-    );\n-}\n-\n macro_rules! bench_instant_threaded {\n     ($bench_name:ident, $thread_count:expr) => {\n         #[bench]"}]}