{"sha": "2584216364a9b17364c21b521bcb3d04f7da0e00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ODQyMTYzNjRhOWIxNzM2NGMyMWI1MjFiY2IzZDA0ZjdkYTBlMDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-23T19:28:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:22Z"}, "message": "represent `LivenessValues` with a specialized type", "tree": {"sha": "83a392876a636389ba938dbcc5fb515a1b714f2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83a392876a636389ba938dbcc5fb515a1b714f2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2584216364a9b17364c21b521bcb3d04f7da0e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2584216364a9b17364c21b521bcb3d04f7da0e00", "html_url": "https://github.com/rust-lang/rust/commit/2584216364a9b17364c21b521bcb3d04f7da0e00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2584216364a9b17364c21b521bcb3d04f7da0e00/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fda456ddfdfe164ab8521e722c21e6035f02722", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fda456ddfdfe164ab8521e722c21e6035f02722", "html_url": "https://github.com/rust-lang/rust/commit/2fda456ddfdfe164ab8521e722c21e6035f02722"}], "stats": {"total": 118, "additions": 76, "deletions": 42}, "files": [{"sha": "457499ded565713dfea9bf9a08efed09b935f6bc", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=2584216364a9b17364c21b521bcb3d04f7da0e00", "patch": "@@ -12,7 +12,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::values::RegionValues;\n+use borrow_check::nll::region_infer::values::LivenessValues;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n@@ -24,7 +24,7 @@ use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, RegionVid};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n-    liveness_constraints: &mut RegionValues<RegionVid>,\n+    liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n@@ -48,7 +48,7 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n-    liveness_constraints: &'cg mut RegionValues<RegionVid>,\n+    liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n }\n "}, {"sha": "4853db50a6c96b4ec66693ea2db1ca5af12d3960", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=2584216364a9b17364c21b521bcb3d04f7da0e00", "patch": "@@ -37,7 +37,7 @@ mod dump_mir;\n mod error_reporting;\n mod graphviz;\n pub mod values;\n-use self::values::{RegionValueElements, RegionValues};\n+use self::values::{RegionValueElements, RegionValues, LivenessValues};\n \n use super::ToRegionVid;\n \n@@ -52,7 +52,7 @@ pub struct RegionInferenceContext<'tcx> {\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    liveness_constraints: RegionValues<RegionVid>,\n+    liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n     constraints: Rc<ConstraintSet>,\n@@ -199,7 +199,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         _mir: &Mir<'tcx>,\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n-        liveness_constraints: RegionValues<RegionVid>,\n+        liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n     ) -> Self {\n         let universal_regions = Rc::new(universal_regions);\n@@ -216,9 +216,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut scc_values = RegionValues::new(elements);\n \n-        for region in liveness_constraints.regions_with_points() {\n+        for region in liveness_constraints.rows() {\n             let scc = constraint_sccs.scc(region);\n-            scc_values.merge_row(scc, region, &liveness_constraints);\n+            scc_values.merge_liveness(scc, region, &liveness_constraints);\n         }\n \n         let mut result = Self {\n@@ -283,7 +283,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.scc_values.add_all_points(variable_scc);\n \n             // Add `end(X)` into the set for X.\n-            self.add_live_element(variable, variable);\n+            self.add_element_to_scc_of(variable, variable);\n         }\n     }\n \n@@ -314,27 +314,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.region_value_str(scc)\n     }\n \n-    /// Indicates that the region variable `v` is live at the point `point`.\n-    ///\n-    /// Returns `true` if this constraint is new and `false` is the\n-    /// constraint was already present.\n-    pub(super) fn add_live_element(\n-        &mut self,\n-        v: RegionVid,\n-        elem: impl ToElementIndex,\n-    ) -> bool {\n+    /// Adds `elem` to the value of the SCC in which `v` appears.\n+    fn add_element_to_scc_of(&mut self, v: RegionVid, elem: impl ToElementIndex) {\n         debug!(\"add_live_element({:?}, {:?})\", v, elem);\n-\n-        // Add to the liveness values for `v`...\n-        if self.liveness_constraints.add_element(v, elem) {\n-            // ...but also add to the SCC in which `v` appears.\n-            let scc = self.constraint_sccs.scc(v);\n-            self.scc_values.add_element(scc, elem);\n-\n-            true\n-        } else {\n-            false\n-        }\n+        let scc = self.constraint_sccs.scc(v);\n+        self.scc_values.add_element(scc, elem);\n     }\n \n     /// Perform region inference and report errors if we see any"}, {"sha": "c31698720d5a2b1f4c7a48803e74bf280d851f6a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=2584216364a9b17364c21b521bcb3d04f7da0e00", "patch": "@@ -117,6 +117,65 @@ crate enum RegionElement {\n     RootUniversalRegion(RegionVid),\n }\n \n+/// When we initially compute liveness, we use a bit matrix storing\n+/// points for each region-vid.\n+crate struct LivenessValues<N: Idx> {\n+    elements: Rc<RegionValueElements>,\n+    points: SparseBitMatrix<N, PointIndex>,\n+}\n+\n+impl<N: Idx> LivenessValues<N> {\n+    /// Creates a new set of \"region values\" that tracks causal information.\n+    /// Each of the regions in num_region_variables will be initialized with an\n+    /// empty set of points and no causal information.\n+    crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n+        Self {\n+            elements: elements.clone(),\n+            points: SparseBitMatrix::new(elements.num_points),\n+        }\n+    }\n+\n+    /// Iterate through each region that has a value in this set.\n+    crate fn rows<'a>(&'a self) -> impl Iterator<Item = N> {\n+        self.points.rows()\n+    }\n+\n+    /// Adds the given element to the value for the given region. Returns true if\n+    /// the element is newly added (i.e., was not already present).\n+    crate fn add_element(\n+        &mut self,\n+        row: N,\n+        location: Location,\n+    ) -> bool {\n+        debug!(\"LivenessValues::add(r={:?}, location={:?})\", row, location);\n+        let index = self.elements.point_from_location(location);\n+        self.points.add(row, index)\n+    }\n+\n+    /// Adds all the control-flow points to the values for `r`.\n+    crate fn add_all_points(&mut self, row: N) {\n+        self.points.add_all(row);\n+    }\n+\n+    /// True if the region `r` contains the given element.\n+    crate fn contains(&self, row: N, location: Location) -> bool {\n+        let index = self.elements.point_from_location(location);\n+        self.points.contains(row, index)\n+    }\n+\n+    /// Returns a \"pretty\" string value of the region. Meant for debugging.\n+    crate fn region_value_str(&self, r: N) -> String {\n+        region_value_str(\n+            self.points\n+                .row(r)\n+                .into_iter()\n+                .flat_map(|set| set.iter())\n+                .map(|p| self.elements.to_location(p))\n+                .map(RegionElement::Location)\n+        )\n+    }\n+}\n+\n /// Stores the values for a set of regions. These are stored in a\n /// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n@@ -172,22 +231,13 @@ impl<N: Idx> RegionValues<N> {\n         elem.contained_in_row(self, r)\n     }\n \n-    /// Iterate through each region that has a value in this set.\n-    crate fn regions_with_points<'a>(&'a self) -> impl Iterator<Item = N> {\n-        self.points.rows()\n-    }\n-\n     /// `self[to] |= values[from]`, essentially: that is, take all the\n     /// elements for the region `from` from `values` and add them to\n     /// the region `to` in `self`.\n-    crate fn merge_row<M: Idx>(&mut self, to: N, from: M, values: &RegionValues<M>) {\n+    crate fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n         if let Some(set) = values.points.row(from) {\n             self.points.merge_into(to, set);\n         }\n-\n-        if let Some(set) = values.free_regions.row(from) {\n-            self.free_regions.merge_into(to, set);\n-        }\n     }\n \n     /// True if `sup_region` contains all the CFG points that"}, {"sha": "e990a99f2b416de523661a1f819bff6492ece5fb", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584216364a9b17364c21b521bcb3d04f7da0e00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=2584216364a9b17364c21b521bcb3d04f7da0e00", "patch": "@@ -15,8 +15,8 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use borrow_check::nll::region_infer::values::{RegionValues, RegionValueElements};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::LocalWithRegion;\n@@ -121,7 +121,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n-        liveness_constraints: RegionValues::new(elements),\n+        liveness_constraints: LivenessValues::new(elements),\n         outlives_constraints: ConstraintSet::default(),\n         type_tests: Vec::default(),\n     };\n@@ -638,7 +638,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    crate liveness_constraints: RegionValues<RegionVid>,\n+    crate liveness_constraints: LivenessValues<RegionVid>,\n \n     crate outlives_constraints: ConstraintSet,\n "}]}