{"sha": "9ba4d33e4345b14c78fcbdf72959d4a0232e46f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYTRkMzNlNDM0NWIxNGM3OGZjYmRmNzI5NTlkNGEwMjMyZTQ2ZjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-23T18:06:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:21Z"}, "message": "rewrite the \"constraint graph search\" to use a BFS instead of a DFS\n\nThis way we find the shortest path without having to sort etc", "tree": {"sha": "687407d3e4e543f104fa4a71738872d5ea11d907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/687407d3e4e543f104fa4a71738872d5ea11d907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4", "html_url": "https://github.com/rust-lang/rust/commit/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fce59f0fda5db8c2ef3b58ddce8e1ed670d813d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fce59f0fda5db8c2ef3b58ddce8e1ed670d813d", "html_url": "https://github.com/rust-lang/rust/commit/4fce59f0fda5db8c2ef3b58ddce8e1ed670d813d"}], "stats": {"total": 103, "additions": 51, "deletions": 52}, "files": [{"sha": "a48ffe7a799ea83c4619954fc11455fe50c4a94f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba4d33e4345b14c78fcbdf72959d4a0232e46f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=9ba4d33e4345b14c78fcbdf72959d4a0232e46f4", "patch": "@@ -16,9 +16,9 @@ use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n+use std::collections::VecDeque;\n use std::fmt;\n use syntax_pos::Span;\n \n@@ -54,6 +54,13 @@ impl fmt::Display for ConstraintCategory {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum Trace {\n+    StartRegion,\n+    FromConstraint(ConstraintIndex),\n+    NotVisited,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Walks the graph of constraints (where `'a: 'b` is considered\n     /// an edge `'a -> 'b`) to find all paths from `from_region` to\n@@ -64,56 +71,52 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Vec<Vec<ConstraintIndex>> {\n-        let mut results = vec![];\n-        self.find_constraint_paths_between_regions_helper(\n-            from_region,\n-            from_region,\n-            &target_test,\n-            &mut FxHashSet::default(),\n-            &mut vec![],\n-            &mut results,\n-        );\n-        results\n-    }\n+    ) -> Option<Vec<ConstraintIndex>> {\n+        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n+        context[from_region] = Trace::StartRegion;\n+\n+        // Use a deque so that we do a breadth-first search. We will\n+        // stop at the first match, which ought to be the shortest\n+        // path (fewest constraints).\n+        let mut deque = VecDeque::new();\n+        deque.push_back(from_region);\n+\n+        while let Some(r) = deque.pop_front() {\n+            // Check if we reached the region we were looking for. If so,\n+            // we can reconstruct the path that led to it and return it.\n+            if target_test(r) {\n+                let mut result = vec![];\n+                let mut p = r;\n+                loop {\n+                    match context[p] {\n+                        Trace::NotVisited => bug!(\"found unvisited region {:?} on path to {:?}\", p, r),\n+                        Trace::FromConstraint(c) => {\n+                            result.push(c);\n+                            p = self.constraints[c].sup;\n+                        }\n \n-    /// Helper for `find_constraint_paths_between_regions`.\n-    fn find_constraint_paths_between_regions_helper(\n-        &self,\n-        from_region: RegionVid,\n-        current_region: RegionVid,\n-        target_test: &impl Fn(RegionVid) -> bool,\n-        visited: &mut FxHashSet<RegionVid>,\n-        stack: &mut Vec<ConstraintIndex>,\n-        results: &mut Vec<Vec<ConstraintIndex>>,\n-    ) {\n-        // Check if we already visited this region.\n-        if !visited.insert(current_region) {\n-            return;\n-        }\n+                        Trace::StartRegion => {\n+                            result.reverse();\n+                            return Some(result);\n+                        }\n+                    }\n+                }\n+            }\n \n-        // Check if we reached the region we were looking for.\n-        if target_test(current_region) {\n-            if !stack.is_empty() {\n-                assert_eq!(self.constraints[stack[0]].sup, from_region);\n-                results.push(stack.clone());\n+            // Otherwise, walk over the outgoing constraints and\n+            // enqueue any regions we find, keeping track of how we\n+            // reached them.\n+            for constraint in self.constraint_graph.outgoing_edges(r) {\n+                assert_eq!(self.constraints[constraint].sup, r);\n+                let sub_region = self.constraints[constraint].sub;\n+                if let Trace::NotVisited = context[sub_region] {\n+                    context[sub_region] = Trace::FromConstraint(constraint);\n+                    deque.push_back(sub_region);\n+                }\n             }\n-            return;\n         }\n \n-        for constraint in self.constraint_graph.outgoing_edges(current_region) {\n-            assert_eq!(self.constraints[constraint].sup, current_region);\n-            stack.push(constraint);\n-            self.find_constraint_paths_between_regions_helper(\n-                from_region,\n-                self.constraints[constraint].sub,\n-                target_test,\n-                visited,\n-                stack,\n-                results,\n-            );\n-            stack.pop();\n-        }\n+        None\n     }\n \n     /// This function will return true if a constraint is interesting and false if a constraint\n@@ -204,12 +207,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n         // Find all paths\n-        let constraint_paths = self.find_constraint_paths_between_regions(fr, |r| r == outlived_fr);\n-        debug!(\"report_error: constraint_paths={:#?}\", constraint_paths);\n-\n-        // Find the shortest such path.\n-        let path = constraint_paths.iter().min_by_key(|p| p.len()).unwrap();\n-        debug!(\"report_error: shortest_path={:?}\", path);\n+        let path = self.find_constraint_paths_between_regions(fr, |r| r == outlived_fr).unwrap();\n+        debug!(\"report_error: path={:#?}\", path);\n \n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<(ConstraintCategory, Span)> = path.iter()"}]}