{"sha": "98c0578f157fbd04af6106c658886bbeb1091f1c", "node_id": "C_kwDOAAsO6NoAKDk4YzA1NzhmMTU3ZmJkMDRhZjYxMDZjNjU4ODg2YmJlYjEwOTFmMWM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-03T17:48:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-03T17:49:02Z"}, "message": "Move trait_impl completion analysis into CompletionContext", "tree": {"sha": "a1900ebc0ca312bd970e4de153bf3844cf2a4ba7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1900ebc0ca312bd970e4de153bf3844cf2a4ba7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c0578f157fbd04af6106c658886bbeb1091f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c0578f157fbd04af6106c658886bbeb1091f1c", "html_url": "https://github.com/rust-lang/rust/commit/98c0578f157fbd04af6106c658886bbeb1091f1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c0578f157fbd04af6106c658886bbeb1091f1c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a60b8452e469f8002834a7ac14a29434d92f12b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a60b8452e469f8002834a7ac14a29434d92f12b", "html_url": "https://github.com/rust-lang/rust/commit/2a60b8452e469f8002834a7ac14a29434d92f12b"}], "stats": {"total": 369, "additions": 186, "deletions": 183}, "files": [{"sha": "b0763584432b9bd60f7a9963e177c8999f13d0ba", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=98c0578f157fbd04af6106c658886bbeb1091f1c", "patch": "@@ -16,7 +16,6 @@ pub(crate) mod pattern;\n pub(crate) mod postfix;\n pub(crate) mod record;\n pub(crate) mod snippet;\n-pub(crate) mod trait_impl;\n pub(crate) mod r#type;\n pub(crate) mod use_;\n pub(crate) mod vis;"}, {"sha": "9b03d8bc5ff7c575be1c6a38f894da46c87b4d05", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=98c0578f157fbd04af6106c658886bbeb1091f1c", "patch": "@@ -6,9 +6,16 @@ use crate::{\n     CompletionContext, Completions,\n };\n \n+mod trait_impl;\n+\n pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext) {\n     let _p = profile::span(\"complete_item_list\");\n \n+    if let Some(_) = ctx.name_ctx() {\n+        trait_impl::complete_trait_impl(acc, ctx);\n+        return;\n+    }\n+\n     let (&is_absolute_path, path_qualifier, kind) = match ctx.path_context() {\n         Some(PathCompletionCtx {\n             kind: PathKind::Item { kind },\n@@ -24,7 +31,6 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n         }) => (is_absolute_path, qualifier, None),\n         _ => return,\n     };\n-    let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n \n     let in_item_list = matches!(kind, Some(ItemListKind::SourceFile | ItemListKind::Module) | None);\n     let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));\n@@ -35,6 +41,11 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n     let no_qualifiers = ctx.qualifier_ctx.vis_node.is_none();\n     let in_block = matches!(kind, None);\n \n+    if in_trait_impl {\n+        trait_impl::complete_trait_impl(acc, ctx);\n+    }\n+    let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n+\n     'block: loop {\n         if ctx.is_non_trivial_path() {\n             break 'block;"}, {"sha": "627752b1cdc62d094582feb07787256b9354e507", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "renamed", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=98c0578f157fbd04af6106c658886bbeb1091f1c", "patch": "@@ -43,6 +43,7 @@ use syntax::{\n use text_edit::TextEdit;\n \n use crate::{\n+    context::{ItemListKind, NameContext, NameKind, NameRefContext, PathCompletionCtx, PathKind},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n@@ -54,7 +55,6 @@ enum ImplCompletionKind {\n     Const,\n }\n \n-// FIXME: Make this a submodule of [`item_list`]\n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n     if let Some((kind, replacement_range, impl_def)) = completion_match(ctx) {\n         if let Some(hir_impl) = ctx.sema.to_def(&impl_def) {\n@@ -77,74 +77,48 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n     }\n }\n \n-// FIXME: This should be lifted out so that we can do proper smart item keyword completions\n fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, TextRange, ast::Impl)> {\n     let token = ctx.token.clone();\n \n-    // For keyword without name like `impl .. { fn $0 }`, the current position is inside\n-    // the whitespace token, which is outside `FN` syntax node.\n-    // We need to follow the previous token in this case.\n-    let mut token_before_ws = token.clone();\n-    if token.kind() == SyntaxKind::WHITESPACE {\n-        token_before_ws = token.prev_token()?;\n-    }\n-\n-    let parent_kind = token_before_ws.parent().map_or(SyntaxKind::EOF, |it| it.kind());\n-    if token.parent().map(|n| n.kind()) == Some(SyntaxKind::ASSOC_ITEM_LIST)\n-        && matches!(\n-            token_before_ws.kind(),\n-            SyntaxKind::SEMICOLON | SyntaxKind::R_CURLY | SyntaxKind::L_CURLY\n-        )\n-    {\n-        let impl_def = ast::Impl::cast(token.parent()?.parent()?)?;\n-        let kind = ImplCompletionKind::All;\n-        let replacement_range = TextRange::empty(ctx.position.offset);\n-        Some((kind, replacement_range, impl_def))\n-    } else {\n-        let impl_item_offset = match token_before_ws.kind() {\n-            // `impl .. { const $0 }`\n-            // ERROR      0\n-            //   CONST_KW <- *\n-            T![const] => 0,\n-            // `impl .. { fn/type $0 }`\n-            // FN/TYPE_ALIAS  0\n-            //   FN_KW        <- *\n-            T![fn] | T![type] => 0,\n-            // `impl .. { fn/type/const foo$0 }`\n-            // FN/TYPE_ALIAS/CONST  1\n-            //  NAME                0\n-            //    IDENT             <- *\n-            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME => 1,\n-            // `impl .. { foo$0 }`\n-            // MACRO_CALL       3\n-            //  PATH            2\n-            //    PATH_SEGMENT  1\n-            //      NAME_REF    0\n-            //        IDENT     <- *\n-            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME_REF => 3,\n+    if let Some(NameContext { name, kind, .. }) = ctx.name_ctx() {\n+        let kind = match kind {\n+            NameKind::Const => ImplCompletionKind::Const,\n+            NameKind::Function => ImplCompletionKind::Fn,\n+            NameKind::TypeAlias => ImplCompletionKind::TypeAlias,\n             _ => return None,\n         };\n-\n-        let impl_item = token_before_ws.ancestors().nth(impl_item_offset)?;\n-        // Must directly belong to an impl block.\n-        // IMPL\n-        //   ASSOC_ITEM_LIST\n-        //     <item>\n-        let impl_def = ast::Impl::cast(impl_item.parent()?.parent()?)?;\n-        let kind = match impl_item.kind() {\n-            // `impl ... { const $0 fn/type/const }`\n-            _ if token_before_ws.kind() == T![const] => ImplCompletionKind::Const,\n-            SyntaxKind::CONST | SyntaxKind::ERROR => ImplCompletionKind::Const,\n-            SyntaxKind::TYPE_ALIAS => ImplCompletionKind::TypeAlias,\n-            SyntaxKind::FN => ImplCompletionKind::Fn,\n-            SyntaxKind::MACRO_CALL => ImplCompletionKind::All,\n-            _ => return None,\n-        };\n-\n-        let replacement_range = replacement_range(ctx, &impl_item);\n-\n-        Some((kind, replacement_range, impl_def))\n+        let item = match name {\n+            Some(name) => name.syntax().parent(),\n+            None => {\n+                if token.kind() == SyntaxKind::WHITESPACE { token.prev_token()? } else { token }\n+                    .parent()\n+            }\n+        }?;\n+        return Some((\n+            kind,\n+            replacement_range(ctx, &item),\n+            // item -> ASSOC_ITEM_LIST -> IMPL\n+            ast::Impl::cast(item.parent()?.parent()?)?,\n+        ));\n+    } else if let Some(NameRefContext {\n+        nameref,\n+        path_ctx:\n+            Some(PathCompletionCtx { kind: PathKind::Item { kind: ItemListKind::TraitImpl }, .. }),\n+        ..\n+    }) = ctx.nameref_ctx()\n+    {\n+        if !ctx.is_non_trivial_path() {\n+            return Some((\n+                ImplCompletionKind::All,\n+                match nameref {\n+                    Some(name) => name.syntax().text_range(),\n+                    None => TextRange::empty(ctx.position.offset),\n+                },\n+                ctx.impl_def.clone()?,\n+            ));\n+        }\n     }\n+    None\n }\n \n fn add_function_impl(", "previous_filename": "crates/ide-completion/src/completions/trait_impl.rs"}, {"sha": "83815f6d5dc8d35f3c7de8c1a5825834dcef81cd", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 137, "deletions": 117, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=98c0578f157fbd04af6106c658886bbeb1091f1c", "patch": "@@ -101,15 +101,30 @@ pub(crate) struct PathCompletionCtx {\n     pub(super) is_absolute_path: bool,\n     /// The qualifier of the current path if it exists.\n     pub(super) qualifier: Option<PathQualifierCtx>,\n-    #[allow(dead_code)]\n-    // FIXME: use this\n     /// The parent of the path we are completing.\n     pub(super) parent: Option<ast::Path>,\n     pub(super) kind: PathKind,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,\n }\n \n+impl PathCompletionCtx {\n+    fn is_trivial_path(&self) -> bool {\n+        matches!(\n+            self,\n+            PathCompletionCtx {\n+                has_call_parens: false,\n+                has_macro_bang: false,\n+                is_absolute_path: false,\n+                qualifier: None,\n+                parent: None,\n+                has_type_args: false,\n+                ..\n+            }\n+        )\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct PathQualifierCtx {\n     pub(crate) path: ast::Path,\n@@ -365,13 +380,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn is_non_trivial_path(&self) -> bool {\n-        matches!(\n-            self.path_context(),\n-            Some(\n-                PathCompletionCtx { is_absolute_path: true, .. }\n-                    | PathCompletionCtx { qualifier: Some(_), .. }\n-            )\n-        )\n+        self.path_context().as_ref().map_or(false, |it| !it.is_trivial_path())\n     }\n \n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n@@ -872,7 +881,7 @@ impl<'a> CompletionContext<'a> {\n                 find_node_at_offset(&file_with_fake_ident, offset)\n             {\n                 let parent = name_ref.syntax().parent()?;\n-                let (mut nameref_ctx, _) =\n+                let (mut nameref_ctx, _, _) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n                 if let Some(path_ctx) = &mut nameref_ctx.path_ctx {\n                     path_ctx.kind = PathKind::Derive;\n@@ -920,13 +929,23 @@ impl<'a> CompletionContext<'a> {\n         self.impl_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::Impl::cast);\n+            .take_while(|it| it.kind() != SOURCE_FILE)\n+            .filter_map(ast::Item::cast)\n+            .take(2)\n+            .find_map(|it| match it {\n+                ast::Item::Impl(impl_) => Some(impl_),\n+                _ => None,\n+            });\n         self.function_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::Fn::cast);\n+            .filter_map(ast::Item::cast)\n+            .take(2)\n+            .find_map(|it| match it {\n+                ast::Item::Fn(fn_) => Some(fn_),\n+                _ => None,\n+            });\n \n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n@@ -938,50 +957,10 @@ impl<'a> CompletionContext<'a> {\n             }\n             ast::NameLike::NameRef(name_ref) => {\n                 let parent = name_ref.syntax().parent()?;\n-                let (nameref_ctx, pat_ctx) =\n+                let (nameref_ctx, pat_ctx, qualifier_ctx) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone());\n \n-                // Extract qualifiers\n-                if let Some(path_ctx) = &nameref_ctx.path_ctx {\n-                    if path_ctx.qualifier.is_none() {\n-                        let top = match path_ctx.kind {\n-                            PathKind::Expr { in_block_expr: true, .. } => parent\n-                                .ancestors()\n-                                .find(|it| ast::PathExpr::can_cast(it.kind()))\n-                                .and_then(|p| {\n-                                    let parent = p.parent()?;\n-                                    if ast::StmtList::can_cast(parent.kind()) {\n-                                        Some(p)\n-                                    } else if ast::ExprStmt::can_cast(parent.kind()) {\n-                                        Some(parent)\n-                                    } else {\n-                                        None\n-                                    }\n-                                }),\n-                            PathKind::Item { .. } => {\n-                                parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n-                            }\n-                            _ => None,\n-                        };\n-                        if let Some(top) = top {\n-                            if let Some(NodeOrToken::Node(error_node)) =\n-                                syntax::algo::non_trivia_sibling(\n-                                    top.into(),\n-                                    syntax::Direction::Prev,\n-                                )\n-                            {\n-                                if error_node.kind() == SyntaxKind::ERROR {\n-                                    self.qualifier_ctx.unsafe_tok = error_node\n-                                        .children_with_tokens()\n-                                        .filter_map(NodeOrToken::into_token)\n-                                        .find(|it| it.kind() == T![unsafe]);\n-                                    self.qualifier_ctx.vis_node =\n-                                        error_node.children().find_map(ast::Visibility::cast);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+                self.qualifier_ctx = qualifier_ctx;\n                 self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n                 self.pattern_ctx = pat_ctx;\n             }\n@@ -1070,40 +1049,44 @@ impl<'a> CompletionContext<'a> {\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n         parent: SyntaxNode,\n-    ) -> (NameRefContext, Option<PatternContext>) {\n+    ) -> (NameRefContext, Option<PatternContext>, QualifierCtx) {\n         let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n \n-        let mut nameref_ctx = NameRefContext {\n-            dot_access: None,\n-            path_ctx: None,\n-            nameref,\n-            record_expr: None,\n-            keyword: None,\n-        };\n+        let mut res = (\n+            NameRefContext {\n+                dot_access: None,\n+                path_ctx: None,\n+                nameref,\n+                record_expr: None,\n+                keyword: None,\n+            },\n+            None,\n+            QualifierCtx::default(),\n+        );\n+        let (nameref_ctx, pattern_ctx, qualifier_ctx) = &mut res;\n \n         if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n             nameref_ctx.record_expr =\n                 find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n                     .zip(Some(false));\n-            return (nameref_ctx, None);\n+            return res;\n         }\n         if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n-            let pat_ctx =\n-                pattern_context_for(original_file, record_field.parent_record_pat().clone().into());\n-            return (\n-                nameref_ctx,\n-                Some(PatternContext {\n-                    param_ctx: None,\n-                    has_type_ascription: false,\n-                    ref_token: None,\n-                    mut_token: None,\n-                    record_pat: find_node_in_file_compensated(\n-                        original_file,\n-                        &record_field.parent_record_pat(),\n-                    ),\n-                    ..pat_ctx\n-                }),\n-            );\n+            *pattern_ctx = Some(PatternContext {\n+                param_ctx: None,\n+                has_type_ascription: false,\n+                ref_token: None,\n+                mut_token: None,\n+                record_pat: find_node_in_file_compensated(\n+                    original_file,\n+                    &record_field.parent_record_pat(),\n+                ),\n+                ..pattern_context_for(\n+                    original_file,\n+                    record_field.parent_record_pat().clone().into(),\n+                )\n+            });\n+            return res;\n         }\n \n         let segment = match_ast! {\n@@ -1123,7 +1106,7 @@ impl<'a> CompletionContext<'a> {\n                         kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n                         receiver\n                     });\n-                    return (nameref_ctx, None);\n+                    return res;\n                 },\n                 ast::MethodCallExpr(method) => {\n                     let receiver = find_in_original_file(method.receiver(), original_file);\n@@ -1132,9 +1115,9 @@ impl<'a> CompletionContext<'a> {\n                         kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n                         receiver\n                     });\n-                    return (nameref_ctx, None);\n+                    return res;\n                 },\n-                _ => return (nameref_ctx, None),\n+                _ => return res,\n             }\n         };\n \n@@ -1148,7 +1131,6 @@ impl<'a> CompletionContext<'a> {\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n         };\n-        let mut pat_ctx = None;\n \n         let is_in_block = |it: &SyntaxNode| {\n             it.parent()\n@@ -1205,9 +1187,9 @@ impl<'a> CompletionContext<'a> {\n             None\n         };\n \n-        let kind = path.syntax().ancestors().find_map(|it| {\n-            // using Option<Option<PathKind>> as extra controlflow\n-            let kind = match_ast! {\n+        // Infer the path kind\n+        let kind = path.syntax().parent().and_then(|it| {\n+            match_ast! {\n                 match it {\n                     ast::PathType(it) => Some(PathKind::Type {\n                         in_tuple_struct: it.syntax().parent().map_or(false, |it| ast::TupleField::can_cast(it.kind()))\n@@ -1217,7 +1199,7 @@ impl<'a> CompletionContext<'a> {\n                             if ast::ExprStmt::can_cast(p.kind()) {\n                                 if let Some(kind) = inbetween_body_and_decl_check(p) {\n                                     nameref_ctx.keyword = Some(kind);\n-                                    return Some(None);\n+                                    return None;\n                                 }\n                             }\n                         }\n@@ -1233,22 +1215,22 @@ impl<'a> CompletionContext<'a> {\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::RecordPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::PathPat(it) => {\n-                        pat_ctx = Some(pattern_context_for(original_file, it.into()));\n+                        *pattern_ctx = Some(pattern_context_for(original_file, it.into()));\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => {\n                         if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n                             nameref_ctx.keyword = Some(kind);\n-                            return Some(None);\n+                            return None;\n                         }\n \n                         path_ctx.has_macro_bang = it.excl_token().is_some();\n@@ -1266,21 +1248,21 @@ impl<'a> CompletionContext<'a> {\n                                         } else {\n                                             ItemListKind::Impl\n                                         },\n-                                        _ => return Some(None)\n+                                        _ => return None\n                                     }\n                                 },\n-                                None => return Some(None),\n+                                None => return None,\n                             } }),\n                             Some(SyntaxKind::EXTERN_ITEM_LIST) => Some(PathKind::Item { kind: ItemListKind::ExternBlock }),\n                             Some(SyntaxKind::SOURCE_FILE) => Some(PathKind::Item { kind: ItemListKind::SourceFile }),\n                             _ => {\n-                               return Some(parent.and_then(ast::MacroExpr::cast).map(|it| {\n+                               return parent.and_then(ast::MacroExpr::cast).map(|it| {\n                                     let in_loop_body = is_in_loop_body(it.syntax());\n                                     let in_block_expr = is_in_block(it.syntax());\n                                     let after_if_expr = after_if_expr(it.syntax().clone());\n                                     fill_record_expr(it.syntax());\n                                     PathKind::Expr { in_block_expr, in_loop_body, after_if_expr }\n-                                }));\n+                                });\n                             },\n                         }\n                     },\n@@ -1302,30 +1284,14 @@ impl<'a> CompletionContext<'a> {\n                     })(),\n                     ast::Visibility(it) => Some(PathKind::Vis { has_in_token: it.in_token().is_some() }),\n                     ast::UseTree(_) => Some(PathKind::Use),\n-                    ast::ItemList(_) => Some(PathKind::Item { kind: ItemListKind::Module }),\n-                    ast::AssocItemList(it) => Some(PathKind::Item { kind: {\n-                        match_ast! {\n-                            match (it.syntax().parent()?) {\n-                                ast::Trait(_) => ItemListKind::Trait,\n-                                ast::Impl(it) => if it.trait_().is_some() {\n-                                    ItemListKind::TraitImpl\n-                                } else {\n-                                    ItemListKind::Impl\n-                                },\n-                                _ => return None\n-                            }\n-                        }\n-                    }}),\n-                    ast::ExternItemList(_) => Some(PathKind::Item { kind: ItemListKind::ExternBlock }),\n-                    ast::SourceFile(_) => Some(PathKind::Item { kind: ItemListKind::SourceFile }),\n                     _ => return None,\n                 }\n-            };\n-            Some(kind)\n-        }).flatten();\n+            }\n+        });\n+\n         match kind {\n             Some(kind) => path_ctx.kind = kind,\n-            None => return (nameref_ctx, pat_ctx),\n+            None => return res,\n         }\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n@@ -1367,8 +1333,62 @@ impl<'a> CompletionContext<'a> {\n                 path_ctx.is_absolute_path = true;\n             }\n         }\n+\n+        if path_ctx.is_trivial_path() {\n+            // fetch the full expression that may have qualifiers attached to it\n+            let top_node = match path_ctx.kind {\n+                PathKind::Expr { in_block_expr: true, .. } => {\n+                    parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n+                        let parent = p.parent()?;\n+                        if ast::StmtList::can_cast(parent.kind()) {\n+                            Some(p)\n+                        } else if ast::ExprStmt::can_cast(parent.kind()) {\n+                            Some(parent)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                PathKind::Item { .. } => {\n+                    parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+                }\n+                _ => None,\n+            };\n+            if let Some(top) = top_node {\n+                if let Some(NodeOrToken::Node(error_node)) =\n+                    syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n+                {\n+                    if error_node.kind() == SyntaxKind::ERROR {\n+                        qualifier_ctx.unsafe_tok = error_node\n+                            .children_with_tokens()\n+                            .filter_map(NodeOrToken::into_token)\n+                            .find(|it| it.kind() == T![unsafe]);\n+                        qualifier_ctx.vis_node =\n+                            error_node.children().find_map(ast::Visibility::cast);\n+                    }\n+                }\n+\n+                if let Some(PathKind::Item { .. }) = kind {\n+                    if qualifier_ctx.none() {\n+                        if let Some(t) = top.first_token() {\n+                            if let Some(prev) = t\n+                                .prev_token()\n+                                .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n+                            {\n+                                if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n+                                    // This was inferred to be an item position path, but it seems\n+                                    // to be part of some other broken node which leaked into an item\n+                                    // list, so return without setting the path context\n+                                    return res;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         nameref_ctx.path_ctx = Some(path_ctx);\n-        (nameref_ctx, pat_ctx)\n+        res\n     }\n }\n "}, {"sha": "3269e4926a7d7b946ce8d4ef7fd864025bd9d598", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c0578f157fbd04af6106c658886bbeb1091f1c/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=98c0578f157fbd04af6106c658886bbeb1091f1c", "patch": "@@ -173,7 +173,6 @@ pub fn completions(\n             completions::record::complete_record(acc, ctx);\n             completions::snippet::complete_expr_snippet(acc, ctx);\n             completions::snippet::complete_item_snippet(acc, ctx);\n-            completions::trait_impl::complete_trait_impl(acc, ctx);\n             completions::r#type::complete_type_path(acc, ctx);\n             completions::r#type::complete_inferred_type(acc, ctx);\n             completions::use_::complete_use_tree(acc, ctx);"}]}