{"sha": "fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTNjM2Q0N2VkMGNkZjBhMGNiYWM2NmE5ZjM1ZGRiNGM2NzgzYTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-20T00:32:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-20T00:32:04Z"}, "message": "std: Rebuild spsc with Unsafe/&self\n\nThis removes the incorrect usage of `&mut self` in a concurrent setting.", "tree": {"sha": "2402913e159bf6cbe21cbc3815b40b7e3b410a78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2402913e159bf6cbe21cbc3815b40b7e3b410a78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2", "html_url": "https://github.com/rust-lang/rust/commit/fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2966e970cabdf7103ad61c840c72bf58352150e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2966e970cabdf7103ad61c840c72bf58352150e0", "html_url": "https://github.com/rust-lang/rust/commit/2966e970cabdf7103ad61c840c72bf58352150e0"}], "stats": {"total": 51, "additions": 26, "deletions": 25}, "files": [{"sha": "b9827ee6b2a53620a111ab305961e77c33ca1997", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=fe93c3d47ed0cdf0a0cbac66a9f35ddb4c6783a2", "patch": "@@ -40,6 +40,7 @@ use option::{Some, None, Option};\n use owned::Box;\n use ptr::RawPtr;\n use sync::atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n+use ty::Unsafe;\n \n // Node within the linked list queue of messages to send\n struct Node<T> {\n@@ -56,13 +57,13 @@ struct Node<T> {\n /// time.\n pub struct Queue<T> {\n     // consumer fields\n-    tail: *mut Node<T>, // where to pop from\n+    tail: Unsafe<*mut Node<T>>, // where to pop from\n     tail_prev: AtomicPtr<Node<T>>, // where to pop from\n \n     // producer fields\n-    head: *mut Node<T>,      // where to push to\n-    first: *mut Node<T>,     // where to get new nodes from\n-    tail_copy: *mut Node<T>, // between first/tail\n+    head: Unsafe<*mut Node<T>>,      // where to push to\n+    first: Unsafe<*mut Node<T>>,     // where to get new nodes from\n+    tail_copy: Unsafe<*mut Node<T>>, // between first/tail\n \n     // Cache maintenance fields. Additions and subtractions are stored\n     // separately in order to allow them to use nonatomic addition/subtraction.\n@@ -101,11 +102,11 @@ impl<T: Send> Queue<T> {\n         let n2 = Node::new();\n         unsafe { (*n1).next.store(n2, Relaxed) }\n         Queue {\n-            tail: n2,\n+            tail: Unsafe::new(n2),\n             tail_prev: AtomicPtr::new(n1),\n-            head: n2,\n-            first: n1,\n-            tail_copy: n1,\n+            head: Unsafe::new(n2),\n+            first: Unsafe::new(n1),\n+            tail_copy: Unsafe::new(n1),\n             cache_bound: bound,\n             cache_additions: AtomicUint::new(0),\n             cache_subtractions: AtomicUint::new(0),\n@@ -114,43 +115,43 @@ impl<T: Send> Queue<T> {\n \n     /// Pushes a new value onto this queue. Note that to use this function\n     /// safely, it must be externally guaranteed that there is only one pusher.\n-    pub fn push(&mut self, t: T) {\n+    pub fn push(&self, t: T) {\n         unsafe {\n             // Acquire a node (which either uses a cached one or allocates a new\n             // one), and then append this to the 'head' node.\n             let n = self.alloc();\n             assert!((*n).value.is_none());\n             (*n).value = Some(t);\n             (*n).next.store(0 as *mut Node<T>, Relaxed);\n-            (*self.head).next.store(n, Release);\n-            self.head = n;\n+            (**self.head.get()).next.store(n, Release);\n+            *self.head.get() = n;\n         }\n     }\n \n-    unsafe fn alloc(&mut self) -> *mut Node<T> {\n+    unsafe fn alloc(&self) -> *mut Node<T> {\n         // First try to see if we can consume the 'first' node for our uses.\n         // We try to avoid as many atomic instructions as possible here, so\n         // the addition to cache_subtractions is not atomic (plus we're the\n         // only one subtracting from the cache).\n-        if self.first != self.tail_copy {\n+        if *self.first.get() != *self.tail_copy.get() {\n             if self.cache_bound > 0 {\n                 let b = self.cache_subtractions.load(Relaxed);\n                 self.cache_subtractions.store(b + 1, Relaxed);\n             }\n-            let ret = self.first;\n-            self.first = (*ret).next.load(Relaxed);\n+            let ret = *self.first.get();\n+            *self.first.get() = (*ret).next.load(Relaxed);\n             return ret;\n         }\n         // If the above fails, then update our copy of the tail and try\n         // again.\n-        self.tail_copy = self.tail_prev.load(Acquire);\n-        if self.first != self.tail_copy {\n+        *self.tail_copy.get() = self.tail_prev.load(Acquire);\n+        if *self.first.get() != *self.tail_copy.get() {\n             if self.cache_bound > 0 {\n                 let b = self.cache_subtractions.load(Relaxed);\n                 self.cache_subtractions.store(b + 1, Relaxed);\n             }\n-            let ret = self.first;\n-            self.first = (*ret).next.load(Relaxed);\n+            let ret = *self.first.get();\n+            *self.first.get() = (*ret).next.load(Relaxed);\n             return ret;\n         }\n         // If all of that fails, then we have to allocate a new node\n@@ -160,19 +161,19 @@ impl<T: Send> Queue<T> {\n \n     /// Attempts to pop a value from this queue. Remember that to use this type\n     /// safely you must ensure that there is only one popper at a time.\n-    pub fn pop(&mut self) -> Option<T> {\n+    pub fn pop(&self) -> Option<T> {\n         unsafe {\n             // The `tail` node is not actually a used node, but rather a\n             // sentinel from where we should start popping from. Hence, look at\n             // tail's next field and see if we can use it. If we do a pop, then\n             // the current tail node is a candidate for going into the cache.\n-            let tail = self.tail;\n+            let tail = *self.tail.get();\n             let next = (*tail).next.load(Acquire);\n             if next.is_null() { return None }\n             assert!((*next).value.is_some());\n             let ret = (*next).value.take();\n \n-            self.tail = next;\n+            *self.tail.get() = next;\n             if self.cache_bound == 0 {\n                 self.tail_prev.store(tail, Release);\n             } else {\n@@ -197,11 +198,11 @@ impl<T: Send> Queue<T> {\n \n     /// Attempts to peek at the head of the queue, returning `None` if the queue\n     /// has no data currently\n-    pub fn peek<'a>(&'a mut self) -> Option<&'a mut T> {\n+    pub fn peek<'a>(&'a self) -> Option<&'a mut T> {\n         // This is essentially the same as above with all the popping bits\n         // stripped out.\n         unsafe {\n-            let tail = self.tail;\n+            let tail = *self.tail.get();\n             let next = (*tail).next.load(Acquire);\n             if next.is_null() { return None }\n             return (*next).value.as_mut();\n@@ -213,7 +214,7 @@ impl<T: Send> Queue<T> {\n impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            let mut cur = self.first;\n+            let mut cur = *self.first.get();\n             while !cur.is_null() {\n                 let next = (*cur).next.load(Relaxed);\n                 let _n: Box<Node<T>> = mem::transmute(cur);"}]}