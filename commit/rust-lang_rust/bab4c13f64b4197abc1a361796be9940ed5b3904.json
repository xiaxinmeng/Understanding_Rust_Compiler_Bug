{"sha": "bab4c13f64b4197abc1a361796be9940ed5b3904", "node_id": "C_kwDOAAsO6NoAKGJhYjRjMTNmNjRiNDE5N2FiYzFhMzYxNzk2YmU5OTQwZWQ1YjM5MDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-27T11:45:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-27T11:45:55Z"}, "message": "Auto merge of #94400 - c410-f3r:more-let-chains, r=Dylan-DPC\n\n2 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667", "tree": {"sha": "497b37d12e909295659bb14bfd8603b523893ec4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/497b37d12e909295659bb14bfd8603b523893ec4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bab4c13f64b4197abc1a361796be9940ed5b3904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bab4c13f64b4197abc1a361796be9940ed5b3904", "html_url": "https://github.com/rust-lang/rust/commit/bab4c13f64b4197abc1a361796be9940ed5b3904", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bab4c13f64b4197abc1a361796be9940ed5b3904/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd9656c80ff06412c833bd9a6e7118a81bb95fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd9656c80ff06412c833bd9a6e7118a81bb95fc", "html_url": "https://github.com/rust-lang/rust/commit/2bd9656c80ff06412c833bd9a6e7118a81bb95fc"}, {"sha": "ef5601b321660f53bc93d30477308074174521c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5601b321660f53bc93d30477308074174521c2", "html_url": "https://github.com/rust-lang/rust/commit/ef5601b321660f53bc93d30477308074174521c2"}], "stats": {"total": 112, "additions": 53, "deletions": 59}, "files": [{"sha": "550c66e3d3b20d6d5f1289dfeb7e699da2f0a5f5", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=bab4c13f64b4197abc1a361796be9940ed5b3904", "patch": "@@ -75,12 +75,11 @@ impl NestedMetaItem {\n     pub fn name_value_literal(&self) -> Option<(Symbol, &Lit)> {\n         self.meta_item().and_then(|meta_item| {\n             meta_item.meta_item_list().and_then(|meta_item_list| {\n-                if meta_item_list.len() == 1 {\n-                    if let Some(ident) = meta_item.ident() {\n-                        if let Some(lit) = meta_item_list[0].literal() {\n-                            return Some((ident.name, lit));\n-                        }\n-                    }\n+                if meta_item_list.len() == 1\n+                    && let Some(ident) = meta_item.ident()\n+                    && let Some(lit) = meta_item_list[0].literal()\n+                {\n+                    return Some((ident.name, lit));\n                 }\n                 None\n             })"}, {"sha": "538bfc212901739e3c0d7002e5d8e5d9ba25747d", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=bab4c13f64b4197abc1a361796be9940ed5b3904", "patch": "@@ -12,11 +12,12 @@\n #![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(label_break_value)]\n-#![feature(nll)]\n+#![feature(let_chains)]\n #![feature(min_specialization)]\n-#![recursion_limit = \"256\"]\n+#![feature(nll)]\n #![feature(slice_internals)]\n #![feature(stmt_expr_attributes)]\n+#![recursion_limit = \"256\"]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "c367573de8a9445dee9d74ac6aa93d716f5ab91b", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=bab4c13f64b4197abc1a361796be9940ed5b3904", "patch": "@@ -504,10 +504,8 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind {\n-            if let NtPath(..) = **nt {\n-                return true;\n-            }\n+        if let Interpolated(ref nt) = self.kind && let NtPath(..) = **nt {\n+            return true;\n         }\n         false\n     }\n@@ -516,21 +514,19 @@ impl Token {\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind {\n-            if let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtIdent(..) | NtBlock(_) = **nt {\n-                return true;\n-            }\n+        if let Interpolated(ref nt) = self.kind\n+            && let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtIdent(..) | NtBlock(_) = **nt\n+        {\n+            return true;\n         }\n \n         false\n     }\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt) = self.kind {\n-            if let NtBlock(..) = **nt {\n-                return true;\n-            }\n+        if let Interpolated(ref nt) = self.kind && let NtBlock(..) = **nt {\n+            return true;\n         }\n         false\n     }"}, {"sha": "a67e7b1215b28c4ccce422707546d815b992cce6", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=bab4c13f64b4197abc1a361796be9940ed5b3904", "patch": "@@ -497,42 +497,40 @@ impl TokenStreamBuilder {\n \n         // If `self` is not empty and the last tree within the last stream is a\n         // token tree marked with `Joint`...\n-        if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut() {\n-            if let Some((TokenTree::Token(last_token), Spacing::Joint)) = last_stream_lrc.last() {\n-                // ...and `stream` is not empty and the first tree within it is\n-                // a token tree...\n-                let TokenStream(ref mut stream_lrc) = stream;\n-                if let Some((TokenTree::Token(token), spacing)) = stream_lrc.first() {\n-                    // ...and the two tokens can be glued together...\n-                    if let Some(glued_tok) = last_token.glue(&token) {\n-                        // ...then do so, by overwriting the last token\n-                        // tree in `self` and removing the first token tree\n-                        // from `stream`. This requires using `make_mut()`\n-                        // on the last stream in `self` and on `stream`,\n-                        // and in practice this doesn't cause cloning 99.9%\n-                        // of the time.\n-\n-                        // Overwrite the last token tree with the merged\n-                        // token.\n-                        let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n-                        *last_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n-\n-                        // Remove the first token tree from `stream`. (This\n-                        // is almost always the only tree in `stream`.)\n-                        let stream_vec_mut = Lrc::make_mut(stream_lrc);\n-                        stream_vec_mut.remove(0);\n-\n-                        // Don't push `stream` if it's empty -- that could\n-                        // block subsequent token gluing, by getting\n-                        // between two token trees that should be glued\n-                        // together.\n-                        if !stream.is_empty() {\n-                            self.0.push(stream);\n-                        }\n-                        return;\n-                    }\n-                }\n+        if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut()\n+            && let Some((TokenTree::Token(last_token), Spacing::Joint)) = last_stream_lrc.last()\n+            // ...and `stream` is not empty and the first tree within it is\n+            // a token tree...\n+            && let TokenStream(ref mut stream_lrc) = stream\n+            && let Some((TokenTree::Token(token), spacing)) = stream_lrc.first()\n+            // ...and the two tokens can be glued together...\n+            && let Some(glued_tok) = last_token.glue(&token)\n+        {\n+            // ...then do so, by overwriting the last token\n+            // tree in `self` and removing the first token tree\n+            // from `stream`. This requires using `make_mut()`\n+            // on the last stream in `self` and on `stream`,\n+            // and in practice this doesn't cause cloning 99.9%\n+            // of the time.\n+\n+            // Overwrite the last token tree with the merged\n+            // token.\n+            let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n+            *last_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n+\n+            // Remove the first token tree from `stream`. (This\n+            // is almost always the only tree in `stream`.)\n+            let stream_vec_mut = Lrc::make_mut(stream_lrc);\n+            stream_vec_mut.remove(0);\n+\n+            // Don't push `stream` if it's empty -- that could\n+            // block subsequent token gluing, by getting\n+            // between two token trees that should be glued\n+            // together.\n+            if !stream.is_empty() {\n+                self.0.push(stream);\n             }\n+            return;\n         }\n         self.0.push(stream);\n     }"}, {"sha": "231dd72af2c7d9100b6f50515823ffa3cdddf57f", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab4c13f64b4197abc1a361796be9940ed5b3904/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=bab4c13f64b4197abc1a361796be9940ed5b3904", "patch": "@@ -222,10 +222,10 @@ impl Lit {\n             }\n             token::Literal(lit) => lit,\n             token::Interpolated(ref nt) => {\n-                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n-                    if let ast::ExprKind::Lit(lit) = &expr.kind {\n-                        return Ok(lit.clone());\n-                    }\n+                if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt\n+                    && let ast::ExprKind::Lit(lit) = &expr.kind\n+                {\n+                    return Ok(lit.clone());\n                 }\n                 return Err(LitError::NotLiteral);\n             }"}]}