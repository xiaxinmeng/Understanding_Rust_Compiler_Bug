{"sha": "c89c5d21c17f2070c03779bfc58254a98eafe0f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4OWM1ZDIxYzE3ZjIwNzBjMDM3NzliZmM1ODI1NGE5OGVhZmUwZjg=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-19T13:38:38Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-19T13:38:38Z"}, "message": "Merge remote-tracking branch 'origin/master' into examples", "tree": {"sha": "15d4ab04e78974909281e8ce260f981d45de5d6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15d4ab04e78974909281e8ce260f981d45de5d6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c89c5d21c17f2070c03779bfc58254a98eafe0f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX3+pgAAoJEFbW7qD8Z6xGZV0P/32VIa59aafYqxFPP+5mD7Jv\n2bD6Sn5jyJM2ijko+at86ybqj82iV/u2APX4xJNoHYlOUwXEyQqegmZk7zMvXmui\nuF4L34glHnfRWbrCYaeoFGVcFdpwoQdqdnDrL0ldRNCU8SalABfSulfVuJgEY/p/\n1qHUdv6wK4MmvYUNxf2XLmHeA0qvEZESq6qvnCpS0X+Z0WkPWor7QTvc/Nr7VOCv\ntDHB2o2P5f5yyHnqbjmWZZesV8wFswPHxSOG3ueB4gFaWvaO5Vwnt463D5dyO2Rk\n0bm7KdNkRlrT9MwzD/3TuHA0Sss+AbABN/ugl0BKY26PIQW4MB4KvR+bxfcUO1O/\neGMd6UBfnqxanE/3ISgW3oHFlPTOz6ZAol2viK2jn5z3iPL4KJtCXVbOP5H/fK3Y\nq5HpUFrtZYqLBbyTbKePOcF6CLgaywLL+u49ApxvHiEVwfctRRIyPPPDoV1C8tNN\n353MnC8ixIg8SoWNRxWafbW6wTMBS8r+FWszxFoQZd3ZldiNuU6chlNUPCzIeP7F\niuJdriNAlmI6/P0o+t89ujYgJImx+r/2orC+Gqm0Qf74MdUrnY4ep1Rm3RT6uCJ9\ngcVCzHvrw+/iwfZHh5byMxLKaKDh+rGBGKnieDBTbORZDLZla3+qWjHEvMiDWnW7\n0rDH++bvfq3IeQnEucch\n=IfB2\n-----END PGP SIGNATURE-----", "payload": "tree 15d4ab04e78974909281e8ce260f981d45de5d6e\nparent 7b717d3152e9ad1b3e874d9b5dd957521640f40b\nparent 5f1120b3460eff614bb08623cb0be2365a07f8c5\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474292318 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474292318 +0200\n\nMerge remote-tracking branch 'origin/master' into examples\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c89c5d21c17f2070c03779bfc58254a98eafe0f8", "html_url": "https://github.com/rust-lang/rust/commit/c89c5d21c17f2070c03779bfc58254a98eafe0f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c89c5d21c17f2070c03779bfc58254a98eafe0f8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b717d3152e9ad1b3e874d9b5dd957521640f40b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b717d3152e9ad1b3e874d9b5dd957521640f40b", "html_url": "https://github.com/rust-lang/rust/commit/7b717d3152e9ad1b3e874d9b5dd957521640f40b"}, {"sha": "5f1120b3460eff614bb08623cb0be2365a07f8c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1120b3460eff614bb08623cb0be2365a07f8c5", "html_url": "https://github.com/rust-lang/rust/commit/5f1120b3460eff614bb08623cb0be2365a07f8c5"}], "stats": {"total": 2384, "additions": 1721, "deletions": 663}, "files": [{"sha": "84bbf87d29c24907dd2a046bcca97fa58d802ba8", "filename": "CHANGELOG.md", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,7 +1,35 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n-## 0.0.84 \u2014 TBD\n+## 0.0.90 \u2014 2016-09-09\n+* Rustup to *rustc 1.13.0-nightly (f1f40f850 2016-09-09)*\n+\n+## 0.0.89 \u2014 2016-09-06\n+* Rustup to *rustc 1.13.0-nightly (cbe4de78e 2016-09-05)*\n+\n+## 0.0.88 \u2014 2016-09-04\n+* Rustup to *rustc 1.13.0-nightly (70598e04f 2016-09-03)*\n+* The following lints are not new but were only usable through the `clippy`\n+  lint groups: [`filter_next`], [`for_loop_over_option`],\n+  [`for_loop_over_result`] and [`match_overlapping_arm`]. You should now be\n+  able to `#[allow/deny]` them individually and they are available directly\n+  through [`cargo clippy`].\n+\n+## 0.0.87 \u2014 2016-08-31\n+* Rustup to *rustc 1.13.0-nightly (eac41469d 2016-08-30)*\n+* New lints: [`builtin_type_shadow`]\n+* Fix FP in [`zero_prefixed_literal`] and `0b`/`0o`\n+\n+## 0.0.86 \u2014 2016-08-28\n+* Rustup to *rustc 1.13.0-nightly (a23064af5 2016-08-27)*\n+* New lints: [`missing_docs_in_private_items`], [`zero_prefixed_literal`]\n+\n+## 0.0.85 \u2014 2016-08-19\n+* Fix ICE with [`useless_attribute`]\n+* [`useless_attribute`] ignores [`unused_imports`] on `use` statements\n+\n+## 0.0.84 \u2014 2016-08-18\n+* Rustup to *rustc 1.13.0-nightly (aef6971ca 2016-08-17)*\n \n ## 0.0.83 \u2014 2016-08-17\n * Rustup to *rustc 1.12.0-nightly (1bf5fa326 2016-08-16)*\n@@ -166,6 +194,7 @@ All notable changes to this project will be documented in this file.\n [`bool_comparison`]: https://github.com/Manishearth/rust-clippy/wiki#bool_comparison\n [`box_vec`]: https://github.com/Manishearth/rust-clippy/wiki#box_vec\n [`boxed_local`]: https://github.com/Manishearth/rust-clippy/wiki#boxed_local\n+[`builtin_type_shadow`]: https://github.com/Manishearth/rust-clippy/wiki#builtin_type_shadow\n [`cast_possible_truncation`]: https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation\n [`cast_possible_wrap`]: https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap\n [`cast_precision_loss`]: https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss\n@@ -175,12 +204,14 @@ All notable changes to this project will be documented in this file.\n [`clone_double_ref`]: https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref\n [`clone_on_copy`]: https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy\n [`cmp_nan`]: https://github.com/Manishearth/rust-clippy/wiki#cmp_nan\n+[`cmp_null`]: https://github.com/Manishearth/rust-clippy/wiki#cmp_null\n [`cmp_owned`]: https://github.com/Manishearth/rust-clippy/wiki#cmp_owned\n [`collapsible_if`]: https://github.com/Manishearth/rust-clippy/wiki#collapsible_if\n [`crosspointer_transmute`]: https://github.com/Manishearth/rust-clippy/wiki#crosspointer_transmute\n [`cyclomatic_complexity`]: https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity\n [`deprecated_semver`]: https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver\n [`derive_hash_xor_eq`]: https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq\n+[`diverging_sub_expression`]: https://github.com/Manishearth/rust-clippy/wiki#diverging_sub_expression\n [`doc_markdown`]: https://github.com/Manishearth/rust-clippy/wiki#doc_markdown\n [`double_neg`]: https://github.com/Manishearth/rust-clippy/wiki#double_neg\n [`drop_ref`]: https://github.com/Manishearth/rust-clippy/wiki#drop_ref\n@@ -232,6 +263,7 @@ All notable changes to this project will be documented in this file.\n [`mem_forget`]: https://github.com/Manishearth/rust-clippy/wiki#mem_forget\n [`min_max`]: https://github.com/Manishearth/rust-clippy/wiki#min_max\n [`misrefactored_assign_op`]: https://github.com/Manishearth/rust-clippy/wiki#misrefactored_assign_op\n+[`missing_docs_in_private_items`]: https://github.com/Manishearth/rust-clippy/wiki#missing_docs_in_private_items\n [`mixed_case_hex_literals`]: https://github.com/Manishearth/rust-clippy/wiki#mixed_case_hex_literals\n [`module_inception`]: https://github.com/Manishearth/rust-clippy/wiki#module_inception\n [`modulo_one`]: https://github.com/Manishearth/rust-clippy/wiki#modulo_one\n@@ -323,5 +355,6 @@ All notable changes to this project will be documented in this file.\n [`wrong_self_convention`]: https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention\n [`wrong_transmute`]: https://github.com/Manishearth/rust-clippy/wiki#wrong_transmute\n [`zero_divided_by_zero`]: https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero\n+[`zero_prefixed_literal`]: https://github.com/Manishearth/rust-clippy/wiki#zero_prefixed_literal\n [`zero_width_space`]: https://github.com/Manishearth/rust-clippy/wiki#zero_width_space\n <!-- end autogenerated links to wiki -->"}, {"sha": "80f821a1b41c6dce1abee8389c6aeda517c0eef5", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.83\"\n+version = \"0.0.90\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,7 +25,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.83\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.90\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]"}, {"sha": "7aec86c2f39e64221b06d264345c33b8b10e6874", "filename": "README.md", "status": "modified", "additions": 165, "deletions": 160, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -15,9 +15,166 @@ Table of contents:\n *   [*clippy-service*](#link-with-clippy-service)\n *   [License](#license)\n \n+## Usage\n+\n+As a general rule clippy will only work with the *latest* Rust nightly for now.\n+\n+### As a Compiler Plugin\n+\n+Since stable Rust is backwards compatible, you should be able to\n+compile your stable programs with nightly Rust with clippy plugged in to\n+circumvent this.\n+\n+Add in your `Cargo.toml`:\n+\n+```toml\n+[dependencies]\n+clippy = \"*\"\n+```\n+\n+You then need to add `#![feature(plugin)]` and `#![plugin(clippy)]` to the top\n+of your crate entry point (`main.rs` or `lib.rs`).\n+\n+Sample `main.rs`:\n+\n+```rust\n+#![feature(plugin)]\n+\n+#![plugin(clippy)]\n+\n+\n+fn main(){\n+    let x = Some(1u8);\n+    match x {\n+        Some(y) => println!(\"{:?}\", y),\n+        _ => ()\n+    }\n+}\n+```\n+\n+Produces this warning:\n+\n+```terminal\n+src/main.rs:8:5: 11:6 warning: you seem to be trying to use match for destructuring a single type. Consider using `if let`, #[warn(single_match)] on by default\n+src/main.rs:8     match x {\n+src/main.rs:9         Some(y) => println!(\"{:?}\", y),\n+src/main.rs:10         _ => ()\n+src/main.rs:11     }\n+src/main.rs:8:5: 11:6 help: Try\n+if let Some(y) = x { println!(\"{:?}\", y) }\n+```\n+\n+### As a cargo subcommand (`cargo clippy`)\n+\n+An alternate way to use clippy is by installing clippy through cargo as a cargo\n+subcommand.\n+\n+```terminal\n+cargo install clippy\n+```\n+\n+Now you can run clippy by invoking `cargo clippy`, or\n+`rustup run nightly cargo clippy` directly from a directory that is usually\n+compiled with stable.\n+\n+In case you are not using rustup, you need to set the environment flag\n+`SYSROOT` during installation so clippy knows where to find `librustc` and\n+similar crates.\n+\n+```terminal\n+SYSROOT=/path/to/rustc/sysroot cargo install clippy\n+```\n+\n+### Running clippy from the command line without installing\n+\n+To have cargo compile your crate with clippy without needing `#![plugin(clippy)]`\n+in your code, you can use:\n+\n+```terminal\n+cargo rustc -- -L /path/to/clippy_so -Z extra-plugins=clippy\n+```\n+\n+*[Note](https://github.com/Manishearth/rust-clippy/wiki#a-word-of-warning):*\n+Be sure that clippy was compiled with the same version of rustc that cargo invokes here!\n+\n+### Optional dependency\n+\n+If you want to make clippy an optional dependency, you can do the following:\n+\n+In your `Cargo.toml`:\n+\n+```toml\n+[dependencies]\n+clippy = {version = \"*\", optional = true}\n+\n+[features]\n+default = []\n+```\n+\n+And, in your `main.rs` or `lib.rs`:\n+\n+```rust\n+#![cfg_attr(feature=\"clippy\", feature(plugin))]\n+\n+#![cfg_attr(feature=\"clippy\", plugin(clippy))]\n+```\n+\n+Then build by enabling the feature: `cargo build --features \"clippy\"`\n+\n+Instead of adding the `cfg_attr` attributes you can also run clippy on demand:\n+`cargo rustc --features clippy -- -Z no-trans -Z extra-plugins=clippy`\n+(the `-Z no trans`, while not neccessary, will stop the compilation process after\n+typechecking (and lints) have completed, which can significantly reduce the runtime).\n+\n+## Configuration\n+\n+Some lints can be configured in a `clippy.toml` file. It contains basic `variable = value` mapping eg.\n+\n+```toml\n+blacklisted-names = [\"toto\", \"tata\", \"titi\"]\n+cyclomatic-complexity-threshold = 30\n+```\n+\n+See the wiki for more information about which lints can be configured and the\n+meaning of the variables.\n+\n+You can also specify the path to the configuration file with:\n+\n+```rust\n+#![plugin(clippy(conf_file=\"path/to/clippy's/configuration\"))]\n+```\n+\n+To deactivate the \u201cfor further information visit *wiki-link*\u201d message you can\n+define the `CLIPPY_DISABLE_WIKI_LINKS` environment variable.\n+\n+### Allowing/denying lints\n+\n+You can add options  to `allow`/`warn`/`deny`:\n+\n+*   the whole set of `Warn` lints using the `clippy` lint group (`#![deny(clippy)]`)\n+\n+*   all lints using both the `clippy` and `clippy_pedantic` lint groups (`#![deny(clippy)]`,\n+    `#![deny(clippy_pedantic)]`). Note that `clippy_pedantic` contains some very aggressive\n+    lints prone to false positives.\n+\n+*   only some lints (`#![deny(single_match, box_vec)]`, etc)\n+\n+*   `allow`/`warn`/`deny` can be limited to a single function or module using `#[allow(...)]`, etc\n+\n+Note: `deny` produces errors instead of warnings.\n+\n+## Link with clippy service\n+\n+`clippy-service` is a rust web initiative providing `rust-clippy` as a web service.\n+\n+Both projects are independent and maintained by different people\n+(even if some `clippy-service`'s contributions are authored by some `rust-clippy` members).\n+\n+You can check out this great service at [clippy.bashy.io](https://clippy.bashy.io/).\n+\n ## Lints\n \n-There are 166 lints included in this crate:\n+There are 171 lints included in this crate:\n \n name                                                                                                                 | default | triggers on\n ---------------------------------------------------------------------------------------------------------------------|---------|----------------------------------------------------------------------------------------------------------------------------------\n@@ -33,6 +190,7 @@ name\n [bool_comparison](https://github.com/Manishearth/rust-clippy/wiki#bool_comparison)                                   | warn    | comparing a variable to a boolean, e.g. `if x == true`\n [box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                                   | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n [boxed_local](https://github.com/Manishearth/rust-clippy/wiki#boxed_local)                                           | warn    | using `Box<T>` where unnecessary\n+[builtin_type_shadow](https://github.com/Manishearth/rust-clippy/wiki#builtin_type_shadow)                           | warn    | shadowing a builtin type\n [cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)                 | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n [cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                             | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n [cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                           | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n@@ -42,12 +200,14 @@ name\n [clone_double_ref](https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref)                                 | warn    | using `clone` on `&&T`\n [clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy)                                       | warn    | using `clone` on a `Copy` type\n [cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                                   | deny    | comparisons to NAN, which will always return false, probably not intended\n+[cmp_null](https://github.com/Manishearth/rust-clippy/wiki#cmp_null)                                                 | warn    | comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                               | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                                     | warn    | `if`s that can be collapsed (e.g. `if x { if y { ... } }` and `else { if x { ... } }`)\n [crosspointer_transmute](https://github.com/Manishearth/rust-clippy/wiki#crosspointer_transmute)                     | warn    | transmutes that have to or from types that are a pointer to the other\n [cyclomatic_complexity](https://github.com/Manishearth/rust-clippy/wiki#cyclomatic_complexity)                       | warn    | functions that should be split up into multiple functions\n [deprecated_semver](https://github.com/Manishearth/rust-clippy/wiki#deprecated_semver)                               | warn    | use of `#[deprecated(since = \"x\")]` where x is not semver\n [derive_hash_xor_eq](https://github.com/Manishearth/rust-clippy/wiki#derive_hash_xor_eq)                             | warn    | deriving `Hash` but implementing `PartialEq` explicitly\n+[diverging_sub_expression](https://github.com/Manishearth/rust-clippy/wiki#diverging_sub_expression)                 | warn    | whether an expression contains a diverging sub expression\n [doc_markdown](https://github.com/Manishearth/rust-clippy/wiki#doc_markdown)                                         | warn    | presence of `_`, `::` or camel-case outside backticks in documentation\n [double_neg](https://github.com/Manishearth/rust-clippy/wiki#double_neg)                                             | warn    | `--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\n [drop_ref](https://github.com/Manishearth/rust-clippy/wiki#drop_ref)                                                 | warn    | calls to `std::mem::drop` with a reference instead of an owned value\n@@ -82,7 +242,7 @@ name\n [items_after_statements](https://github.com/Manishearth/rust-clippy/wiki#items_after_statements)                     | allow   | blocks where an item comes after a statement\n [iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                                     | warn    | for-looping over `_.next()` which is probably not intended\n [iter_nth](https://github.com/Manishearth/rust-clippy/wiki#iter_nth)                                                 | warn    | using `.iter().nth()` on a standard library type with O(1) element access\n-[len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                         | warn    | traits and impls that have `.len()` but not `.is_empty()`\n+[len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                         | warn    | traits or impls with a public `len` method but no corresponding `is_empty` method\n [len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                                 | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                                     | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                                     | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n@@ -99,6 +259,7 @@ name\n [mem_forget](https://github.com/Manishearth/rust-clippy/wiki#mem_forget)                                             | allow   | `mem::forget` usage on `Drop` types, likely to cause memory leaks\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                                   | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [misrefactored_assign_op](https://github.com/Manishearth/rust-clippy/wiki#misrefactored_assign_op)                   | warn    | having a variable on both sides of an assign op\n+[missing_docs_in_private_items](https://github.com/Manishearth/rust-clippy/wiki#missing_docs_in_private_items)       | allow   | detects missing documentation for public and private members\n [mixed_case_hex_literals](https://github.com/Manishearth/rust-clippy/wiki#mixed_case_hex_literals)                   | warn    | hex literals whose letter digits are not consistently upper- or lowercased\n [module_inception](https://github.com/Manishearth/rust-clippy/wiki#module_inception)                                 | warn    | modules that have the same name as their parent module\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                             | warn    | taking a number modulo 1, which always returns 0\n@@ -131,7 +292,7 @@ name\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                             | warn    | operations where precedence may be unclear\n [print_stdout](https://github.com/Manishearth/rust-clippy/wiki#print_stdout)                                         | allow   | printing on stdout\n [print_with_newline](https://github.com/Manishearth/rust-clippy/wiki#print_with_newline)                             | warn    | using `print!()` with a format string that ends in a newline\n-[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                                   | warn    | arguments of the type `&Vec<...>` (instead of `&[...]`) or `&String` (instead of `&str`)\n+[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                                   | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n [range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                             | warn    | using `Range::step_by(0)`, which produces an infinite iterator\n [range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                             | warn    | zipping iterator with a range when `enumerate()` would do\n [redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                               | warn    | redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n@@ -186,167 +347,11 @@ name\n [wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)                       | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n [wrong_transmute](https://github.com/Manishearth/rust-clippy/wiki#wrong_transmute)                                   | warn    | transmutes that are confusing at best, undefined behaviour at worst and always useless\n [zero_divided_by_zero](https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero)                         | warn    | usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\n+[zero_prefixed_literal](https://github.com/Manishearth/rust-clippy/wiki#zero_prefixed_literal)                       | warn    | integer literals starting with `0`\n [zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                                 | deny    | using a zero-width space in a string literal, which is confusing\n \n More to come, please [file an issue](https://github.com/Manishearth/rust-clippy/issues) if you have ideas!\n \n-## Usage\n-\n-As a general rule clippy will only work with the *latest* Rust nightly for now.\n-\n-### As a Compiler Plugin\n-\n-Since stable Rust is backwards compatible, you should be able to\n-compile your stable programs with nightly Rust with clippy plugged in to\n-circumvent this.\n-\n-Add in your `Cargo.toml`:\n-\n-```toml\n-[dependencies]\n-clippy = \"*\"\n-```\n-\n-You then need to add `#![feature(plugin)]` and `#![plugin(clippy)]` to the top\n-of your crate entry point (`main.rs` or `lib.rs`).\n-\n-Sample `main.rs`:\n-\n-```rust\n-#![feature(plugin)]\n-\n-#![plugin(clippy)]\n-\n-\n-fn main(){\n-    let x = Some(1u8);\n-    match x {\n-        Some(y) => println!(\"{:?}\", y),\n-        _ => ()\n-    }\n-}\n-```\n-\n-Produces this warning:\n-\n-```terminal\n-src/main.rs:8:5: 11:6 warning: you seem to be trying to use match for destructuring a single type. Consider using `if let`, #[warn(single_match)] on by default\n-src/main.rs:8     match x {\n-src/main.rs:9         Some(y) => println!(\"{:?}\", y),\n-src/main.rs:10         _ => ()\n-src/main.rs:11     }\n-src/main.rs:8:5: 11:6 help: Try\n-if let Some(y) = x { println!(\"{:?}\", y) }\n-```\n-\n-### As a cargo subcommand (`cargo clippy`)\n-\n-An alternate way to use clippy is by installing clippy through cargo as a cargo\n-subcommand.\n-\n-```terminal\n-cargo install clippy\n-```\n-\n-Now you can run clippy by invoking `cargo clippy`, or\n-`rustup run nightly cargo clippy` directly from a directory that is usually\n-compiled with stable.\n-\n-In case you are not using rustup, you need to set the environment flag\n-`SYSROOT` during installation so clippy knows where to find `librustc` and\n-similar crates.\n-\n-```terminal\n-SYSROOT=/path/to/rustc/sysroot cargo install clippy\n-```\n-\n-### Running clippy from the command line without installing\n-\n-To have cargo compile your crate with clippy without needing `#![plugin(clippy)]`\n-in your code, you can use:\n-\n-```terminal\n-cargo rustc -- -L /path/to/clippy_so -Z extra-plugins=clippy\n-```\n-\n-*[Note](https://github.com/Manishearth/rust-clippy/wiki#a-word-of-warning):*\n-Be sure that clippy was compiled with the same version of rustc that cargo invokes here!\n-\n-### Optional dependency\n-\n-If you want to make clippy an optional dependency, you can do the following:\n-\n-In your `Cargo.toml`:\n-\n-```toml\n-[dependencies]\n-clippy = {version = \"*\", optional = true}\n-\n-[features]\n-default = []\n-```\n-\n-And, in your `main.rs` or `lib.rs`:\n-\n-```rust\n-#![cfg_attr(feature=\"clippy\", feature(plugin))]\n-\n-#![cfg_attr(feature=\"clippy\", plugin(clippy))]\n-```\n-\n-Then build by enabling the feature: `cargo build --features \"clippy\"`\n-\n-Instead of adding the `cfg_attr` attributes you can also run clippy on demand:\n-`cargo rustc --features clippy -- -Z no-trans -Z extra-plugins=clippy`\n-(the `-Z no trans`, while not neccessary, will stop the compilation process after\n-typechecking (and lints) have completed, which can significantly reduce the runtime).\n-\n-## Configuration\n-\n-Some lints can be configured in a `clippy.toml` file. It contains basic `variable = value` mapping eg.\n-\n-```toml\n-blacklisted-names = [\"toto\", \"tata\", \"titi\"]\n-cyclomatic-complexity-threshold = 30\n-```\n-\n-See the wiki for more information about which lints can be configured and the\n-meaning of the variables.\n-\n-You can also specify the path to the configuration file with:\n-\n-```rust\n-#![plugin(clippy(conf_file=\"path/to/clippy's/configuration\"))]\n-```\n-\n-To deactivate the \u201cfor further information visit *wiki-link*\u201d message you can\n-define the `CLIPPY_DISABLE_WIKI_LINKS` environment variable.\n-\n-### Allowing/denying lints\n-\n-You can add options  to `allow`/`warn`/`deny`:\n-\n-*   the whole set of `Warn` lints using the `clippy` lint group (`#![deny(clippy)]`)\n-\n-*   all lints using both the `clippy` and `clippy_pedantic` lint groups (`#![deny(clippy)]`,\n-    `#![deny(clippy_pedantic)]`). Note that `clippy_pedantic` contains some very aggressive\n-    lints prone to false positives.\n-\n-*   only some lints (`#![deny(single_match, box_vec)]`, etc)\n-\n-*   `allow`/`warn`/`deny` can be limited to a single function or module using `#[allow(...)]`, etc\n-\n-Note: `deny` produces errors instead of warnings.\n-\n-## Link with clippy service\n-\n-`clippy-service` is a rust web initiative providing `rust-clippy` as a web service.\n-\n-Both projects are independent and maintained by different people\n-(even if some `clippy-service`'s contributions are authored by some `rust-clippy` members).\n-\n-You can check out this great service at [clippy.bashy.io](https://clippy.bashy.io/).\n-\n ## License\n \n Licensed under [MPL](https://www.mozilla.org/MPL/2.0/)."}, {"sha": "a7e863c29688c96294cb12f9f822c48b1c14641c", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.83\"\n+version = \"0.0.90\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "7a36049178b006381a47f4d33bea18ce4eef3fbb", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -4,7 +4,7 @@ use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n use semver::Version;\n-use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind};\n+use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n use utils::{in_macro, match_path, span_lint, span_lint_and_then, snippet_opt};\n use utils::paths;\n@@ -89,11 +89,13 @@ impl LateLintPass for AttrPass {\n                 return;\n             }\n             for item in items {\n-                if let MetaItemKind::NameValue(ref name, ref lit) = item.node {\n-                    if name == &\"since\" {\n-                        check_semver(cx, item.span, lit);\n-                    }\n-                }\n+                if_let_chain! {[\n+                    let NestedMetaItemKind::MetaItem(ref mi) = item.node,\n+                    let MetaItemKind::NameValue(ref name, ref lit) = mi.node,\n+                    name == &\"since\",\n+                ], {\n+                    check_semver(cx, item.span, lit);\n+                }}\n             }\n         }\n     }\n@@ -106,17 +108,27 @@ impl LateLintPass for AttrPass {\n             ItemExternCrate(_) |\n             ItemUse(_) => {\n                 for attr in &item.attrs {\n-                    if let MetaItemKind::List(ref name, _) = attr.node.value.node {\n+                    if let MetaItemKind::List(ref name, ref lint_list) = attr.node.value.node {\n                         match &**name {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                span_lint_and_then(cx, USELESS_ATTRIBUTE, attr.span,\n-                                                   \"useless lint attribute\",\n-                                                   |db| {\n-                                    if let Some(mut sugg) = snippet_opt(cx, attr.span) {\n-                                        sugg.insert(1, '!');\n-                                        db.span_suggestion(attr.span, \"if you just forgot a `!`, use\", sugg);\n+                                // whitelist `unused_imports`\n+                                for lint in lint_list {\n+                                    if is_word(lint, \"unused_imports\") {\n+                                        if let ItemUse(_) = item.node {\n+                                            return;\n+                                        }\n+                                    }\n+                                }\n+                                if let Some(mut sugg) = snippet_opt(cx, attr.span) {\n+                                    if sugg.len() > 1 {\n+                                        span_lint_and_then(cx, USELESS_ATTRIBUTE, attr.span,\n+                                                           \"useless lint attribute\",\n+                                                           |db| {\n+                                            sugg.insert(1, '!');\n+                                            db.span_suggestion(attr.span, \"if you just forgot a `!`, use\", sugg);\n+                                        });\n                                     }\n-                                });\n+                                }\n                             },\n                             _ => {},\n                         }\n@@ -202,10 +214,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n             if values.len() != 1 || inline != &\"inline\" {\n                 continue;\n             }\n-            if let MetaItemKind::Word(ref always) = values[0].node {\n-                if always != &\"always\" {\n-                    continue;\n-                }\n+            if is_word(&values[0], \"always\") {\n                 span_lint(cx,\n                           INLINE_ALWAYS,\n                           attr.span,\n@@ -227,3 +236,13 @@ fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n               span,\n               \"the since field must contain a semver-compliant version\");\n }\n+\n+fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n+    if let NestedMetaItemKind::MetaItem(ref mi) = nmi.node {\n+        if let MetaItemKind::Word(ref word) = mi.node {\n+            return word == expected;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "89e90bff625f311ee65f5d50eff095f25a717add", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -106,7 +106,8 @@ fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_re\n             let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n \n             // Only care about `impl PartialEq<Foo> for Foo`\n-            if trait_ref.input_types()[0] == ty {\n+            // For `impl PartialEq<B> for A, input_types is [A, B]\n+            if trait_ref.substs.type_at(1) == ty {\n                 let mess = if peq_is_automatically_derived {\n                     \"you are implementing `Hash` explicitly but have derived `PartialEq`\"\n                 } else {\n@@ -139,10 +140,11 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n             return; // ty is not Copy\n         }\n \n-        // Some types are not Clone by default but could be cloned `by hand` if necessary\n         match ty.sty {\n-            TypeVariants::TyEnum(def, substs) |\n-            TypeVariants::TyStruct(def, substs) => {\n+            TypeVariants::TyAdt(def, _) if def.is_union() => return,\n+\n+            // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n+            TypeVariants::TyAdt(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n                         match field.ty(cx.tcx, substs).sty {"}, {"sha": "69ec9911d99a20fccb5cd899ffaad829c9456ba8", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -47,8 +47,32 @@ declare_lint! {\n     \"type names prefixed/postfixed with their containing module's name\"\n }\n \n+/// **What it does:** Checks for modules that have the same name as their parent module\n+///\n+/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and again `mod foo { .. }` in `foo.rs`.\n+///                      The expectation is that items inside the inner `mod foo { .. }` are then available\n+///                      through `foo::x`, but they are only available through `foo::foo::x`.\n+///                      If this is done on purpose, it would be better to choose a more representative module name.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// // lib.rs\n+/// mod foo;\n+/// // foo.rs\n+/// mod foo {\n+///     ...\n+/// }\n+/// ```\n+declare_lint! {\n+    pub MODULE_INCEPTION,\n+    Warn,\n+    \"modules that have the same name as their parent module\"\n+}\n+\n pub struct EnumVariantNames {\n-    modules: Vec<String>,\n+    modules: Vec<(InternedString, String)>,\n     threshold: u64,\n }\n \n@@ -60,7 +84,7 @@ impl EnumVariantNames {\n \n impl LintPass for EnumVariantNames {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(ENUM_VARIANT_NAMES, STUTTER)\n+        lint_array!(ENUM_VARIANT_NAMES, STUTTER, MODULE_INCEPTION)\n     }\n }\n \n@@ -170,25 +194,32 @@ impl EarlyLintPass for EnumVariantNames {\n         let item_name = item.ident.name.as_str();\n         let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);\n-        if item.vis == Visibility::Public && !in_macro(cx, item.span) {\n-            if let Some(mod_camel) = self.modules.last() {\n+        if !in_macro(cx, item.span) {\n+            if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n                 // constants don't have surrounding modules\n                 if !mod_camel.is_empty() {\n-                    let matching = partial_match(mod_camel, &item_camel);\n-                    let rmatching = partial_rmatch(mod_camel, &item_camel);\n-                    let nchars = mod_camel.chars().count();\n-                    if matching == nchars {\n-                        span_lint(cx, STUTTER, item.span, &format!(\"Item name ({}) starts with its containing module's name ({})\", item_camel, mod_camel));\n+                    if mod_name == &item_name {\n+                        if let ItemKind::Mod(..) = item.node {\n+                            span_lint(cx, MODULE_INCEPTION, item.span, \"module has the same name as its containing module\");\n+                        }\n                     }\n-                    if rmatching == nchars {\n-                        span_lint(cx, STUTTER, item.span, &format!(\"Item name ({}) ends with its containing module's name ({})\", item_camel, mod_camel));\n+                    if item.vis == Visibility::Public {\n+                        let matching = partial_match(mod_camel, &item_camel);\n+                        let rmatching = partial_rmatch(mod_camel, &item_camel);\n+                        let nchars = mod_camel.chars().count();\n+                        if matching == nchars {\n+                            span_lint(cx, STUTTER, item.span, \"item name starts with its containing module's name\");\n+                        }\n+                        if rmatching == nchars {\n+                            span_lint(cx, STUTTER, item.span, \"item name ends with its containing module's name\");\n+                        }\n                     }\n                 }\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.node {\n             check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span);\n         }\n-        self.modules.push(item_camel);\n+        self.modules.push((item_name, item_camel));\n     }\n }"}, {"sha": "30c7e067d289bc72959d0a42a9b8a240595565bb", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx, 'g\n         }\n \n     }\n-    fn borrow(&mut self, borrow_id: NodeId, _: Span, cmt: cmt<'tcx>, _: ty::Region, _: ty::BorrowKind,\n+    fn borrow(&mut self, borrow_id: NodeId, _: Span, cmt: cmt<'tcx>, _: &ty::Region, _: ty::BorrowKind,\n               loan_cause: LoanCause) {\n \n         if let Categorization::Local(lid) = cmt.cat {"}, {"sha": "e53c830e11dec860bf8bde8758c0762261ae69fa", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 97, "deletions": 2, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,8 +1,9 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{Visitor, walk_expr};\n use rustc::hir::*;\n+use rustc::ty;\n use rustc::lint::*;\n-use utils::{get_parent_expr, span_note_and_lint};\n+use utils::{get_parent_expr, span_note_and_lint, span_lint};\n \n /// **What it does:** Checks for a read and a write to the same variable where\n /// whether the read occurs before or after the write depends on the evaluation\n@@ -26,12 +27,32 @@ declare_lint! {\n     \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n }\n \n+/// **What it does:** Checks for diverging calls that are not match arms or statements.\n+///\n+/// **Why is this bad?** It is often confusing to read. In addition, the\n+/// sub-expression evaluation order for Rust is not well documented.\n+///\n+/// **Known problems:** Someone might want to use `some_bool || panic!()` as a shorthand.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let a = b() || panic!() || c();\n+/// // `c()` is dead, `panic!()` is only called if `b()` returns `false`\n+/// let x = (a, b, c, panic!());\n+/// // can simply be replaced by `panic!()`\n+/// ```\n+declare_lint! {\n+    pub DIVERGING_SUB_EXPRESSION,\n+    Warn,\n+    \"whether an expression contains a diverging sub expression\"\n+}\n+\n #[derive(Copy,Clone)]\n pub struct EvalOrderDependence;\n \n impl LintPass for EvalOrderDependence {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(EVAL_ORDER_DEPENDENCE)\n+        lint_array!(EVAL_ORDER_DEPENDENCE, DIVERGING_SUB_EXPRESSION)\n     }\n }\n \n@@ -56,6 +77,80 @@ impl LateLintPass for EvalOrderDependence {\n             _ => {}\n         }\n     }\n+    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+        match stmt.node {\n+            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor(cx).maybe_walk_expr(e),\n+            StmtDecl(ref d, _) => {\n+                if let DeclLocal(ref local) = d.node {\n+                    if let Local { init: Some(ref e), .. } = **local {\n+                        DivergenceVisitor(cx).visit_expr(e);\n+                    }\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+struct DivergenceVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+\n+impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n+    fn maybe_walk_expr(&mut self, e: &Expr) {\n+        match e.node {\n+            ExprClosure(..) => {},\n+            ExprMatch(ref e, ref arms, _) => {\n+                self.visit_expr(e);\n+                for arm in arms {\n+                    if let Some(ref guard) = arm.guard {\n+                        self.visit_expr(guard);\n+                    }\n+                    // make sure top level arm expressions aren't linted\n+                    walk_expr(self, &*arm.body);\n+                }\n+            }\n+            _ => walk_expr(self, e),\n+        }\n+    }\n+    fn report_diverging_sub_expr(&mut self, e: &Expr) {\n+        span_lint(\n+            self.0,\n+            DIVERGING_SUB_EXPRESSION,\n+            e.span,\n+            \"sub-expression diverges\",\n+        );\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for DivergenceVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'v Expr) {\n+        match e.node {\n+            ExprAgain(_) |\n+            ExprBreak(_) |\n+            ExprRet(_) => self.report_diverging_sub_expr(e),\n+            ExprCall(ref func, _) => match self.0.tcx.expr_ty(func).sty {\n+                ty::TyFnDef(_, _, fn_ty) |\n+                ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&fn_ty.sig).output.sty {\n+                    self.report_diverging_sub_expr(e);\n+                },\n+                _ => {},\n+            },\n+            ExprMethodCall(..) => {\n+                let method_call = ty::MethodCall::expr(e.id);\n+                let borrowed_table = self.0.tcx.tables.borrow();\n+                let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n+                let result_ty = method_type.ty.fn_ret();\n+                if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&result_ty).sty {\n+                    self.report_diverging_sub_expr(e);\n+                }\n+            },\n+            _ => {\n+                // do not lint expressions referencing objects of type `!`, as that required a diverging expression to begin with\n+            },\n+        }\n+        self.maybe_walk_expr(e);\n+    }\n+    fn visit_block(&mut self, _: &'v Block) {\n+        // don't continue over blocks, LateLintPass already does that\n+    }\n }\n \n /// Walks up the AST from the the given write expression (`vis.write_expr`)"}, {"sha": "1d81b6dba22f42f7ddf6d876417ab8adca719d86", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -42,13 +42,13 @@ declare_lint! {\n /// **Example:**\n /// ```rust\n /// impl X {\n-///     fn len(&self) -> usize { .. }\n+///     pub fn len(&self) -> usize { .. }\n /// }\n /// ```\n declare_lint! {\n     pub LEN_WITHOUT_IS_EMPTY,\n     Warn,\n-    \"traits and impls that have `.len()` but not `.is_empty()`\"\n+    \"traits or impls with a public `len` method but no corresponding `is_empty` method\"\n }\n \n #[derive(Copy,Clone)]\n@@ -99,13 +99,12 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n     }\n \n     if !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n-        for i in trait_items {\n-            if is_named_self(i, \"len\") {\n+        if let Some(i) = trait_items.iter().find(|i| is_named_self(i, \"len\")) {\n+            if cx.access_levels.is_exported(i.id) {\n                 span_lint(cx,\n                           LEN_WITHOUT_IS_EMPTY,\n                           i.span,\n-                          &format!(\"trait `{}` has a `.len(_: &Self)` method, but no `.is_empty(_: &Self)` method. \\\n-                                    Consider adding one\",\n+                          &format!(\"trait `{}` has a `len` method but no `is_empty` method\",\n                                    item.name));\n             }\n         }\n@@ -122,19 +121,26 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItem]) {\n         }\n     }\n \n-    if !impl_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n-        for i in impl_items {\n-            if is_named_self(i, \"len\") {\n-                let ty = cx.tcx.node_id_to_type(item.id);\n-\n-                span_lint(cx,\n-                          LEN_WITHOUT_IS_EMPTY,\n-                          i.span,\n-                          &format!(\"item `{}` has a `.len(_: &Self)` method, but no `.is_empty(_: &Self)` method. \\\n-                                    Consider adding one\",\n-                                   ty));\n-                return;\n-            }\n+    let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(i, \"is_empty\")) {\n+        if cx.access_levels.is_exported(is_empty.id) {\n+            return;\n+        } else {\n+            \"a private\"\n+        }\n+    } else {\n+        \"no corresponding\"\n+    };\n+\n+    if let Some(i) = impl_items.iter().find(|i| is_named_self(i, \"len\")) {\n+        if cx.access_levels.is_exported(i.id) {\n+            let ty = cx.tcx.node_id_to_type(item.id);\n+\n+            span_lint(cx,\n+                      LEN_WITHOUT_IS_EMPTY,\n+                      i.span,\n+                      &format!(\"item `{}` has a public `len` method but {} `is_empty` method\",\n+                               ty,\n+                               is_empty));\n         }\n     }\n }\n@@ -208,8 +214,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n               .map_or(false, |ids| ids.iter().any(|i| is_is_empty(cx, i)))\n         }\n         ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, &id)),\n-        ty::TyEnum(id, _) |\n-        ty::TyStruct(id, _) => has_is_empty_impl(cx, &id.did),\n+        ty::TyAdt(id, _) => has_is_empty_impl(cx, &id.did),\n         ty::TyArray(..) | ty::TyStr => true,\n         _ => false,\n     }"}, {"sha": "67108eb5688c0adab080286e58584feae62745d9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -8,9 +8,8 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n-#![feature(type_macros)]\n \n-#![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n+#![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n \n #[macro_use]\n extern crate syntax;\n@@ -96,7 +95,7 @@ pub mod methods;\n pub mod minmax;\n pub mod misc;\n pub mod misc_early;\n-pub mod module_inception;\n+pub mod missing_doc;\n pub mod mut_mut;\n pub mod mut_reference;\n pub mod mutex_atomic;\n@@ -112,7 +111,7 @@ pub mod overflow_check_conditional;\n pub mod panic;\n pub mod precedence;\n pub mod print;\n-pub mod ptr_arg;\n+pub mod ptr;\n pub mod ranges;\n pub mod regex;\n pub mod returns;\n@@ -172,33 +171,29 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n \n     reg.register_late_lint_pass(box serde::Serde);\n     reg.register_early_lint_pass(box utils::internal_lints::Clippy);\n+    reg.register_late_lint_pass(box utils::internal_lints::LintWithoutLintPass::default());\n     reg.register_late_lint_pass(box types::TypePass);\n     reg.register_late_lint_pass(box booleans::NonminimalBool);\n-    reg.register_early_lint_pass(box module_inception::Pass);\n-    reg.register_late_lint_pass(box misc::TopLevelRefPass);\n-    reg.register_late_lint_pass(box misc::CmpNan);\n     reg.register_late_lint_pass(box eq_op::EqOp);\n     reg.register_early_lint_pass(box enum_variants::EnumVariantNames::new(conf.enum_variant_name_threshold));\n     reg.register_late_lint_pass(box enum_glob_use::EnumGlobUse);\n     reg.register_late_lint_pass(box enum_clike::UnportableVariant);\n     reg.register_late_lint_pass(box bit_mask::BitMask);\n-    reg.register_late_lint_pass(box ptr_arg::PtrArg);\n+    reg.register_late_lint_pass(box ptr::PointerPass);\n     reg.register_late_lint_pass(box needless_bool::NeedlessBool);\n     reg.register_late_lint_pass(box needless_bool::BoolComparison);\n     reg.register_late_lint_pass(box approx_const::Pass);\n-    reg.register_late_lint_pass(box misc::FloatCmp);\n+    reg.register_late_lint_pass(box misc::Pass);\n     reg.register_early_lint_pass(box precedence::Precedence);\n     reg.register_late_lint_pass(box eta_reduction::EtaPass);\n     reg.register_late_lint_pass(box identity_op::IdentityOp);\n     reg.register_early_lint_pass(box items_after_statements::ItemsAfterStatements);\n     reg.register_late_lint_pass(box mut_mut::MutMut);\n     reg.register_late_lint_pass(box mut_reference::UnnecessaryMutPassed);\n     reg.register_late_lint_pass(box len_zero::LenZero);\n-    reg.register_late_lint_pass(box misc::CmpOwned);\n     reg.register_late_lint_pass(box attrs::AttrPass);\n     reg.register_early_lint_pass(box collapsible_if::CollapsibleIf);\n     reg.register_late_lint_pass(box block_in_if_condition::BlockInIfCondition);\n-    reg.register_late_lint_pass(box misc::ModuloOne);\n     reg.register_late_lint_pass(box unicode::Unicode);\n     reg.register_late_lint_pass(box strings::StringAdd);\n     reg.register_early_lint_pass(box returns::ReturnPass);\n@@ -213,7 +208,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box types::CastPass);\n     reg.register_late_lint_pass(box types::TypeComplexityPass::new(conf.type_complexity_threshold));\n     reg.register_late_lint_pass(box matches::MatchPass);\n-    reg.register_late_lint_pass(box misc::PatternPass);\n     reg.register_late_lint_pass(box minmax::MinMaxPass);\n     reg.register_late_lint_pass(box open_options::NonSensical);\n     reg.register_late_lint_pass(box zero_div_zero::Pass);\n@@ -227,7 +221,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box cyclomatic_complexity::CyclomaticComplexity::new(conf.cyclomatic_complexity_threshold));\n     reg.register_late_lint_pass(box escape::Pass{too_large_for_stack: conf.too_large_for_stack});\n     reg.register_early_lint_pass(box misc_early::MiscEarly);\n-    reg.register_late_lint_pass(box misc::UsedUnderscoreBinding);\n     reg.register_late_lint_pass(box array_indexing::ArrayIndexing);\n     reg.register_late_lint_pass(box panic::Pass);\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n@@ -260,6 +253,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box assign_ops::AssignOps);\n     reg.register_late_lint_pass(box let_if_seq::LetIfSeq);\n     reg.register_late_lint_pass(box eval_order_dependence::EvalOrderDependence);\n+    reg.register_late_lint_pass(box missing_doc::MissingDoc::new());\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -282,6 +276,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         methods::WRONG_PUB_SELF_CONVENTION,\n         misc::USED_UNDERSCORE_BINDING,\n         misc_early::UNSEPARATED_LITERAL_SUFFIX,\n+        missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n         mut_mut::MUT_MUT,\n         mutex_atomic::MUTEX_INTEGER,\n         non_expressive_names::SIMILAR_NAMES,\n@@ -301,6 +296,11 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         unicode::UNICODE_NOT_NFC,\n     ]);\n \n+    reg.register_lint_group(\"clippy_internal\", vec![\n+        utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n+        utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+    ]);\n+\n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n         array_indexing::OUT_OF_BOUNDS_INDEXING,\n@@ -327,9 +327,11 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         entry::MAP_ENTRY,\n         enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT,\n         enum_variants::ENUM_VARIANT_NAMES,\n+        enum_variants::MODULE_INCEPTION,\n         eq_op::EQ_OP,\n         escape::BOXED_LOCAL,\n         eta_reduction::REDUNDANT_CLOSURE,\n+        eval_order_dependence::DIVERGING_SUB_EXPRESSION,\n         eval_order_dependence::EVAL_ORDER_DEPENDENCE,\n         format::USELESS_FORMAT,\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n@@ -382,12 +384,13 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         misc::MODULO_ONE,\n         misc::REDUNDANT_PATTERN,\n         misc::TOPLEVEL_REF_ARG,\n+        misc_early::BUILTIN_TYPE_SHADOW,\n         misc_early::DOUBLE_NEG,\n         misc_early::DUPLICATE_UNDERSCORE_ARGUMENT,\n         misc_early::MIXED_CASE_HEX_LITERALS,\n         misc_early::REDUNDANT_CLOSURE_CALL,\n         misc_early::UNNEEDED_FIELD_PATTERN,\n-        module_inception::MODULE_INCEPTION,\n+        misc_early::ZERO_PREFIXED_LITERAL,\n         mut_reference::UNNECESSARY_MUT_PASSED,\n         mutex_atomic::MUTEX_ATOMIC,\n         needless_bool::BOOL_COMPARISON,\n@@ -405,7 +408,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         panic::PANIC_PARAMS,\n         precedence::PRECEDENCE,\n         print::PRINT_WITH_NEWLINE,\n-        ptr_arg::PTR_ARG,\n+        ptr::CMP_NULL,\n+        ptr::PTR_ARG,\n         ranges::RANGE_STEP_BY_ZERO,\n         ranges::RANGE_ZIP_WITH_LEN,\n         regex::INVALID_REGEX,"}, {"sha": "66ae404221b55788f1ced9298adff58be507f1ea", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -14,9 +14,9 @@ use std::collections::HashMap;\n use syntax::ast;\n use utils::sugg;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, higher,\n-            walk_ptrs_ty};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg,\n+            in_external_macro, is_refutable, span_help_and_lint, is_integer_literal,\n+            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty};\n use utils::paths;\n \n /// **What it does:** Checks for looping over the range of `0..len` of some\n@@ -276,6 +276,8 @@ impl LintPass for Pass {\n         lint_array!(NEEDLESS_RANGE_LOOP,\n                     EXPLICIT_ITER_LOOP,\n                     ITER_NEXT_LOOP,\n+                    FOR_LOOP_OVER_RESULT,\n+                    FOR_LOOP_OVER_OPTION,\n                     WHILE_LET_LOOP,\n                     UNUSED_COLLECT,\n                     REVERSE_RANGE_LOOP,\n@@ -352,6 +354,7 @@ impl LateLintPass for Pass {\n                     if method_name.node.as_str() == \"next\" &&\n                        match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n                        lhs_constructor.name.as_str() == \"Some\" &&\n+                       !is_refutable(cx, &pat_args[0]) &&\n                        !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n                         let loop_var = snippet(cx, pat_args[0].span, \"_\");"}, {"sha": "a3a4b7155f5b191a7ac0d66e28b51d59a11f8809", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -22,7 +22,7 @@ use utils::sugg::Sugg;\n /// **Example:**\n /// ```rust\n /// match x {\n-///     Some(ref foo) -> bar(foo),\n+///     Some(ref foo) => bar(foo),\n ///     _ => ()\n /// }\n /// ```\n@@ -43,7 +43,7 @@ declare_lint! {\n /// **Example:**\n /// ```rust\n /// match x {\n-///     Some(ref foo) -> bar(foo),\n+///     Some(ref foo) => bar(foo),\n ///     _ => bar(other_ref),\n /// }\n /// ```\n@@ -125,7 +125,7 @@ pub struct MatchPass;\n \n impl LintPass for MatchPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(SINGLE_MATCH, MATCH_REF_PATS, MATCH_BOOL, SINGLE_MATCH_ELSE)\n+        lint_array!(SINGLE_MATCH, MATCH_REF_PATS, MATCH_BOOL, SINGLE_MATCH_ELSE, MATCH_OVERLAPPING_ARM)\n     }\n }\n "}, {"sha": "a0a1059ba4896d57ba0368b68f633294f2cf4d65", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -2,7 +2,6 @@ use rustc::hir;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::const_qualif::ConstQualif;\n-use rustc::ty::subst::TypeSpace;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n@@ -380,9 +379,7 @@ declare_lint! {\n /// **Known problems:** Does not catch multi-byte unicode characters.\n ///\n /// **Example:**\n-/// ```rust\n-/// _.split(\"x\")` could be `_.split('x')\n-/// ```\n+/// `_.split(\"x\")` could be `_.split('x')\n declare_lint! {\n     pub SINGLE_CHAR_PATTERN,\n     Warn,\n@@ -462,6 +459,7 @@ impl LintPass for Pass {\n                     SINGLE_CHAR_PATTERN,\n                     SEARCH_IS_SOME,\n                     TEMPORARY_CSTRING_AS_PTR,\n+                    FILTER_NEXT,\n                     FILTER_MAP,\n                     ITER_NTH)\n     }\n@@ -796,7 +794,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     fn may_slice(cx: &LateContext, ty: ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n-            ty::TyStruct(..) => match_type(cx, ty, &paths::VEC),\n+            ty::TyAdt(..) => match_type(cx, ty, &paths::VEC),\n             ty::TyArray(_, size) => size < 32,\n             ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) |\n             ty::TyBox(inner) => may_slice(cx, inner),\n@@ -1081,15 +1079,15 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr)\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n-    if !match_type(cx, ty, &paths::RESULT) {\n-        return None;\n-    }\n-    if let ty::TyEnum(_, substs) = ty.sty {\n-        if let Some(err_ty) = substs.types.opt_get(TypeSpace, 1) {\n-            return Some(err_ty);\n+    if let ty::TyAdt(_, substs) = ty.sty {\n+        if match_type(cx, ty, &paths::RESULT) {\n+            substs.types().nth(1)\n+        } else {\n+            None\n         }\n+    } else {\n+        None\n     }\n-    None\n }\n \n /// This checks whether a given type is known to implement Debug."}, {"sha": "5526c8660f47d8f8928bd5ae9c78669f1175bf29", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 201, "deletions": 290, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -40,16 +40,134 @@ declare_lint! {\n     \"an entire binding declared as `ref`, in a function argument or a `let` statement\"\n }\n \n-#[allow(missing_copy_implementations)]\n-pub struct TopLevelRefPass;\n+/// **What it does:** Checks for comparisons to NaN.\n+///\n+/// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n+/// even itself \u2013 so those comparisons are simply wrong.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// x == NAN\n+/// ```\n+declare_lint! {\n+    pub CMP_NAN,\n+    Deny,\n+    \"comparisons to NAN, which will always return false, probably not intended\"\n+}\n+\n+/// **What it does:** Checks for (in-)equality comparisons on floating-point\n+/// values (apart from zero), except in functions called `*eq*` (which probably\n+/// implement equality for a type involving floats).\n+///\n+/// **Why is this bad?** Floating point calculations are usually imprecise, so\n+/// asking if two values are *exactly* equal is asking for trouble. For a good\n+/// guide on what to do, see [the floating point\n+/// guide](http://www.floating-point-gui.de/errors/comparison).\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// y == 1.23f64\n+/// y != x  // where both are floats\n+/// ```\n+declare_lint! {\n+    pub FLOAT_CMP,\n+    Warn,\n+    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n+}\n+\n+/// **What it does:** Checks for conversions to owned values just for the sake\n+/// of a comparison.\n+///\n+/// **Why is this bad?** The comparison can operate on a reference, so creating\n+/// an owned value effectively throws it away directly afterwards, which is\n+/// needlessly consuming code and heap space.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// x.to_owned() == y\n+/// ```\n+declare_lint! {\n+    pub CMP_OWNED,\n+    Warn,\n+    \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n+}\n+\n+/// **What it does:** Checks for getting the remainder of a division by one.\n+///\n+/// **Why is this bad?** The result can only ever be zero. No one will write\n+/// such code deliberately, unless trying to win an Underhanded Rust\n+/// Contest. Even for that contest, it's probably a bad idea. Use something more\n+/// underhanded.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// x % 1\n+/// ```\n+declare_lint! {\n+    pub MODULO_ONE,\n+    Warn,\n+    \"taking a number modulo 1, which always returns 0\"\n+}\n+\n+/// **What it does:** Checks for patterns in the form `name @ _`.\n+///\n+/// **Why is this bad?** It's almost always more readable to just use direct bindings.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// match v {\n+///     Some(x) => (),\n+///     y @ _   => (), // easier written as `y`,\n+/// }\n+/// ```\n+declare_lint! {\n+    pub REDUNDANT_PATTERN,\n+    Warn,\n+    \"using `name @ _` in a pattern\"\n+}\n+\n+/// **What it does:** Checks for the use of bindings with a single leading underscore.\n+///\n+/// **Why is this bad?** A single leading underscore is usually used to indicate\n+/// that a binding will not be used. Using such a binding breaks this\n+/// expectation.\n+///\n+/// **Known problems:** The lint does not work properly with desugaring and\n+/// macro, it has been allowed in the mean time.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let _x = 0;\n+/// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n+///                 // We should rename `_x` to `x`\n+/// ```\n+declare_lint! {\n+    pub USED_UNDERSCORE_BINDING,\n+    Allow,\n+    \"using a binding which is prefixed with an underscore\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Pass;\n \n-impl LintPass for TopLevelRefPass {\n+impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(TOPLEVEL_REF_ARG)\n+        lint_array!(TOPLEVEL_REF_ARG, CMP_NAN, FLOAT_CMP, CMP_OWNED, MODULO_ONE, REDUNDANT_PATTERN,\n+                    USED_UNDERSCORE_BINDING)\n     }\n }\n \n-impl LateLintPass for TopLevelRefPass {\n+impl LateLintPass for Pass {\n     fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n@@ -64,6 +182,7 @@ impl LateLintPass for TopLevelRefPass {\n             }\n         }\n     }\n+\n     fn check_stmt(&mut self, cx: &LateContext, s: &Stmt) {\n         if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n@@ -97,103 +216,28 @@ impl LateLintPass for TopLevelRefPass {\n             );\n         }}\n     }\n-}\n \n-/// **What it does:** Checks for comparisons to NaN.\n-///\n-/// **Why is this bad?** NaN does not compare meaningfully to anything \u2013 not\n-/// even itself \u2013 so those comparisons are simply wrong.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x == NAN\n-/// ```\n-declare_lint! {\n-    pub CMP_NAN,\n-    Deny,\n-    \"comparisons to NAN, which will always return false, probably not intended\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct CmpNan;\n-\n-impl LintPass for CmpNan {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(CMP_NAN)\n-    }\n-}\n-\n-impl LateLintPass for CmpNan {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            if cmp.node.is_comparison() {\n+            let op = cmp.node;\n+            if op.is_comparison() {\n                 if let ExprPath(_, ref path) = left.node {\n                     check_nan(cx, path, expr.span);\n                 }\n                 if let ExprPath(_, ref path) = right.node {\n                     check_nan(cx, path, expr.span);\n                 }\n+                check_to_owned(cx, left, right, true, cmp.span);\n+                check_to_owned(cx, right, left, false, cmp.span)\n             }\n-        }\n-    }\n-}\n-\n-fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n-    path.segments.last().map(|seg| {\n-        if seg.name.as_str() == \"NAN\" {\n-            span_lint(cx,\n-                      CMP_NAN,\n-                      span,\n-                      \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n-        }\n-    });\n-}\n-\n-/// **What it does:** Checks for (in-)equality comparisons on floating-point\n-/// values (apart from zero), except in functions called `*eq*` (which probably\n-/// implement equality for a type involving floats).\n-///\n-/// **Why is this bad?** Floating point calculations are usually imprecise, so\n-/// asking if two values are *exactly* equal is asking for trouble. For a good\n-/// guide on what to do, see [the floating point\n-/// guide](http://www.floating-point-gui.de/errors/comparison).\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// y == 1.23f64\n-/// y != x  // where both are floats\n-/// ```\n-declare_lint! {\n-    pub FLOAT_CMP,\n-    Warn,\n-    \"using `==` or `!=` on float values instead of comparing difference with an epsilon\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct FloatCmp;\n-\n-impl LintPass for FloatCmp {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(FLOAT_CMP)\n-    }\n-}\n-\n-impl LateLintPass for FloatCmp {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            let op = cmp.node;\n             if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n                 if is_allowed(cx, left) || is_allowed(cx, right) {\n                     return;\n                 }\n                 if let Some(name) = get_item_name(cx, expr) {\n                     let name = name.as_str();\n                     if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                       name.ends_with(\"_eq\") {\n+                        name.ends_with(\"_eq\") {\n                         return;\n                     }\n                 }\n@@ -202,19 +246,84 @@ impl LateLintPass for FloatCmp {\n                                    expr.span,\n                                    \"strict comparison of f32 or f64\",\n                                    |db| {\n-                    let lhs = Sugg::hir(cx, left, \"..\");\n-                    let rhs = Sugg::hir(cx, right, \"..\");\n+                                       let lhs = Sugg::hir(cx, left, \"..\");\n+                                       let rhs = Sugg::hir(cx, right, \"..\");\n+\n+                                       db.span_suggestion(expr.span,\n+                                                          \"consider comparing them within some error\",\n+                                                          format!(\"({}).abs() < error\", lhs - rhs));\n+                                       db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n+                                   });\n+            } else if op == BiRem && is_integer_literal(right, 1) {\n+                span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n+            }\n+        }\n+        if in_attributes_expansion(cx, expr) {\n+            // Don't lint things expanded by #[derive(...)], etc\n+            return;\n+        }\n+        let binding = match expr.node {\n+            ExprPath(_, ref path) => {\n+                let binding = path.segments\n+                    .last()\n+                    .expect(\"path should always have at least one segment\")\n+                    .name\n+                    .as_str();\n+                if binding.starts_with('_') &&\n+                    !binding.starts_with(\"__\") &&\n+                    binding != \"_result\" && // FIXME: #944\n+                    is_used(cx, expr) &&\n+                    // don't lint if the declaration is in a macro\n+                    non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n+                    Some(binding)\n+                } else {\n+                    None\n+                }\n+            }\n+            ExprField(_, spanned) => {\n+                let name = spanned.node.as_str();\n+                if name.starts_with('_') && !name.starts_with(\"__\") {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        };\n+        if let Some(binding) = binding {\n+            span_lint(cx,\n+                      USED_UNDERSCORE_BINDING,\n+                      expr.span,\n+                      &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n+                                underscore signals that a binding will not be used.\", binding));\n+        }\n+    }\n \n-                    db.span_suggestion(expr.span,\n-                                       \"consider comparing them within some error\",\n-                                       format!(\"({}).abs() < error\", lhs - rhs));\n-                    db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n-                });\n+    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+        if let PatKind::Binding(_, ref ident, Some(ref right)) = pat.node {\n+            if right.node == PatKind::Wild {\n+                span_lint(cx,\n+                          REDUNDANT_PATTERN,\n+                          pat.span,\n+                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n+                                   ident.node,\n+                                   ident.node));\n             }\n         }\n     }\n }\n \n+fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n+    path.segments.last().map(|seg| {\n+        if seg.name.as_str() == \"NAN\" {\n+            span_lint(cx,\n+                      CMP_NAN,\n+                      span,\n+                      \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+        }\n+    });\n+}\n+\n fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n     let res = eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None);\n     if let Ok(ConstVal::Float(val)) = res {\n@@ -247,45 +356,6 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n     matches!(walk_ptrs_ty(cx.tcx.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n-/// **What it does:** Checks for conversions to owned values just for the sake\n-/// of a comparison.\n-///\n-/// **Why is this bad?** The comparison can operate on a reference, so creating\n-/// an owned value effectively throws it away directly afterwards, which is\n-/// needlessly consuming code and heap space.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.to_owned() == y\n-/// ```\n-declare_lint! {\n-    pub CMP_OWNED,\n-    Warn,\n-    \"creating owned instances for comparing with others, e.g. `x == \\\"foo\\\".to_string()`\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct CmpOwned;\n-\n-impl LintPass for CmpOwned {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(CMP_OWNED)\n-    }\n-}\n-\n-impl LateLintPass for CmpOwned {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            if cmp.node.is_comparison() {\n-                check_to_owned(cx, left, right, true, cmp.span);\n-                check_to_owned(cx, right, left, false, cmp.span)\n-            }\n-        }\n-    }\n-}\n-\n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n         ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n@@ -346,165 +416,6 @@ fn is_str_arg(cx: &LateContext, args: &[P<Expr>]) -> bool {\n         matches!(walk_ptrs_ty(cx.tcx.expr_ty(&args[0])).sty, ty::TyStr)\n }\n \n-/// **What it does:** Checks for getting the remainder of a division by one.\n-///\n-/// **Why is this bad?** The result can only ever be zero. No one will write\n-/// such code deliberately, unless trying to win an Underhanded Rust\n-/// Contest. Even for that contest, it's probably a bad idea. Use something more\n-/// underhanded.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// x % 1\n-/// ```\n-declare_lint! {\n-    pub MODULO_ONE,\n-    Warn,\n-    \"taking a number modulo 1, which always returns 0\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct ModuloOne;\n-\n-impl LintPass for ModuloOne {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MODULO_ONE)\n-    }\n-}\n-\n-impl LateLintPass for ModuloOne {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(ref cmp, _, ref right) = expr.node {\n-            if let Spanned { node: BinOp_::BiRem, .. } = *cmp {\n-                if is_integer_literal(right, 1) {\n-                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// **What it does:** Checks for patterns in the form `name @ _`.\n-///\n-/// **Why is this bad?** It's almost always more readable to just use direct bindings.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// match v {\n-///     Some(x) => (),\n-///     y @ _   => (), // easier written as `y`,\n-/// }\n-/// ```\n-declare_lint! {\n-    pub REDUNDANT_PATTERN,\n-    Warn,\n-    \"using `name @ _` in a pattern\"\n-}\n-\n-#[derive(Copy,Clone)]\n-pub struct PatternPass;\n-\n-impl LintPass for PatternPass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(REDUNDANT_PATTERN)\n-    }\n-}\n-\n-impl LateLintPass for PatternPass {\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, Some(ref right)) = pat.node {\n-            if right.node == PatKind::Wild {\n-                span_lint(cx,\n-                          REDUNDANT_PATTERN,\n-                          pat.span,\n-                          &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                   ident.node,\n-                                   ident.node));\n-            }\n-        }\n-    }\n-}\n-\n-\n-/// **What it does:** Checks for the use of bindings with a single leading underscore.\n-///\n-/// **Why is this bad?** A single leading underscore is usually used to indicate\n-/// that a binding will not be used. Using such a binding breaks this\n-/// expectation.\n-///\n-/// **Known problems:** The lint does not work properly with desugaring and\n-/// macro, it has been allowed in the mean time.\n-///\n-/// **Example:**\n-/// ```rust\n-/// let _x = 0;\n-/// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n-///                 // We should rename `_x` to `x`\n-/// ```\n-declare_lint! {\n-    pub USED_UNDERSCORE_BINDING,\n-    Allow,\n-    \"using a binding which is prefixed with an underscore\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UsedUnderscoreBinding;\n-\n-impl LintPass for UsedUnderscoreBinding {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(USED_UNDERSCORE_BINDING)\n-    }\n-}\n-\n-impl LateLintPass for UsedUnderscoreBinding {\n-    #[cfg_attr(rustfmt, rustfmt_skip)]\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if in_attributes_expansion(cx, expr) {\n-            // Don't lint things expanded by #[derive(...)], etc\n-            return;\n-        }\n-        let binding = match expr.node {\n-            ExprPath(_, ref path) => {\n-                let binding = path.segments\n-                                .last()\n-                                .expect(\"path should always have at least one segment\")\n-                                .name\n-                                .as_str();\n-                if binding.starts_with('_') &&\n-                   !binding.starts_with(\"__\") &&\n-                   binding != \"_result\" && // FIXME: #944\n-                   is_used(cx, expr) &&\n-                   // don't lint if the declaration is in a macro\n-                   non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n-                    Some(binding)\n-                } else {\n-                    None\n-                }\n-            }\n-            ExprField(_, spanned) => {\n-                let name = spanned.node.as_str();\n-                if name.starts_with('_') && !name.starts_with(\"__\") {\n-                    Some(name)\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        };\n-        if let Some(binding) = binding {\n-            span_lint(cx,\n-                      USED_UNDERSCORE_BINDING,\n-                      expr.span,\n-                      &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n-                                underscore signals that a binding will not be used.\", binding));\n-        }\n-    }\n-}\n-\n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {"}, {"sha": "61e4530a1df42e846cbaf9a61190c253899760f6", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -4,7 +4,7 @@ use std::char;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n-use utils::{span_lint, span_help_and_lint, snippet, snippet_opt, span_lint_and_then};\n+use utils::{constants, span_lint, span_help_and_lint, snippet, snippet_opt, span_lint_and_then};\n \n /// **What it does:** Checks for structure field patterns bound to wildcards.\n ///\n@@ -105,18 +105,88 @@ declare_lint! {\n     \"literals whose suffix is not separated by an underscore\"\n }\n \n+/// **What it does:** Warns if an integral constant literal starts with `0`.\n+///\n+/// **Why is this bad?** In some languages (including the infamous C language and most of its\n+/// familly), this marks an octal constant. In Rust however, this is a decimal constant. This could\n+/// be confusing for both the writer and a reader of the constant.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// In Rust:\n+/// ```rust\n+/// fn main() {\n+///     let a = 0123;\n+///     println!(\"{}\", a);\n+/// }\n+/// ```\n+///\n+/// prints `123`, while in C:\n+///\n+/// ```c\n+/// #include <stdio.h>\n+///\n+/// int main() {\n+///     int a = 0123;\n+///     printf(\"%d\\n\", a);\n+/// }\n+/// ```\n+///\n+/// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n+declare_lint! {\n+    pub ZERO_PREFIXED_LITERAL,\n+    Warn,\n+    \"integer literals starting with `0`\"\n+}\n+\n+/// **What it does:** Warns if a generic shadows a built-in type.\n+///\n+/// **Why is this bad?** This gives surprising type errors.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// impl<u32> Foo<u32> {\n+///     fn impl_func(&self) -> u32 {\n+///         42\n+///     }\n+/// }\n+/// ```\n+declare_lint! {\n+    pub BUILTIN_TYPE_SHADOW,\n+    Warn,\n+    \"shadowing a builtin type\"\n+}\n+\n \n #[derive(Copy, Clone)]\n pub struct MiscEarly;\n \n impl LintPass for MiscEarly {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNNEEDED_FIELD_PATTERN, DUPLICATE_UNDERSCORE_ARGUMENT, REDUNDANT_CLOSURE_CALL,\n-                    DOUBLE_NEG, MIXED_CASE_HEX_LITERALS, UNSEPARATED_LITERAL_SUFFIX)\n+                    DOUBLE_NEG, MIXED_CASE_HEX_LITERALS, UNSEPARATED_LITERAL_SUFFIX,\n+                    ZERO_PREFIXED_LITERAL, BUILTIN_TYPE_SHADOW)\n     }\n }\n \n impl EarlyLintPass for MiscEarly {\n+    fn check_generics(&mut self, cx: &EarlyContext, gen: &Generics) {\n+        for ty in &gen.ty_params {\n+            let name = ty.ident.name.as_str();\n+            if constants::BUILTIN_TYPES.contains(&&*name) {\n+                span_lint(cx,\n+                          BUILTIN_TYPE_SHADOW,\n+                          ty.span,\n+                          &format!(\"This generic shadows the built-in type `{}`\", name));\n+            }\n+        }\n+    }\n+\n     fn check_pat(&mut self, cx: &EarlyContext, pat: &Pat) {\n         if let PatKind::Struct(ref npat, ref pfields, _) = pat.node {\n             let mut wilds = 0;\n@@ -220,7 +290,7 @@ impl EarlyLintPass for MiscEarly {\n             }\n             ExprKind::Lit(ref lit) => {\n                 if_let_chain! {[\n-                    let LitKind::Int(..) = lit.node,\n+                    let LitKind::Int(value, ..) = lit.node,\n                     let Some(src) = snippet_opt(cx, lit.span),\n                     let Some(firstch) = src.chars().next(),\n                     char::to_digit(firstch, 10).is_some()\n@@ -250,6 +320,17 @@ impl EarlyLintPass for MiscEarly {\n                             span_lint(cx, MIXED_CASE_HEX_LITERALS, lit.span,\n                                       \"inconsistent casing in hexadecimal literal\");\n                         }\n+                    } else if src.starts_with(\"0b\") || src.starts_with(\"0o\") {\n+                        /* nothing to do */\n+                    } else if value != 0 && src.starts_with('0') {\n+                        span_lint_and_then(cx,\n+                                           ZERO_PREFIXED_LITERAL,\n+                                           lit.span,\n+                                           \"this is a decimal constant\",\n+                                           |db| {\n+                            db.span_suggestion(lit.span, \"if you mean to use a decimal constant, remove the `0` to remove confusion:\", src[1..].to_string());\n+                            db.span_suggestion(lit.span, \"if you mean to use an octal constant, use `0o`:\", format!(\"0o{}\", &src[1..]));\n+                        });\n                     }\n                 }}\n                 if_let_chain! {["}, {"sha": "454f591756bb5d878f171636f7c9e229d6f5b7a3", "filename": "clippy_lints/src/missing_doc.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,179 @@\n+/* This file incorporates work covered by the following copyright and\n+ * permission notice:\n+ *   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+ *   file at the top-level directory of this distribution and at\n+ *   http://rust-lang.org/COPYRIGHT.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+ *   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+ *   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+ *   option. This file may not be copied, modified, or distributed\n+ *   except according to those terms.\n+ */\n+\n+/* Note: More specifically this lint is largely inspired (aka copied) from *rustc*'s\n+ * [`missing_doc`].\n+ *\n+ * [`missing_doc`]: https://github.com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.rs#L246\n+ */\n+\n+use rustc::hir;\n+use rustc::lint::*;\n+use rustc::ty;\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::Span;\n+use utils::in_macro;\n+\n+/// **What it does:** Warns if there is missing doc for any documentable item (public or private).\n+///\n+/// **Why is this bad?** Doc is good. *rustc* has a `MISSING_DOCS` allowed-by-default lint for\n+/// public members, but has no way to enforce documentation of private items. This lint fixes that.\n+///\n+/// **Known problems:** None.\n+declare_lint! {\n+    pub MISSING_DOCS_IN_PRIVATE_ITEMS,\n+    Allow,\n+    \"detects missing documentation for public and private members\"\n+}\n+\n+pub struct MissingDoc {\n+    /// Stack of whether #[doc(hidden)] is set\n+    /// at each level which has lint attributes.\n+    doc_hidden_stack: Vec<bool>,\n+}\n+\n+impl ::std::default::Default for MissingDoc {\n+    fn default() -> MissingDoc {\n+        MissingDoc::new()\n+    }\n+}\n+\n+impl MissingDoc {\n+    pub fn new() -> MissingDoc {\n+        MissingDoc {\n+            doc_hidden_stack: vec![false],\n+        }\n+    }\n+\n+    fn doc_hidden(&self) -> bool {\n+        *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n+    }\n+\n+    fn check_missing_docs_attrs(&self,\n+                               cx: &LateContext,\n+                               attrs: &[ast::Attribute],\n+                               sp: Span,\n+                               desc: &'static str) {\n+        // If we're building a test harness, then warning about\n+        // documentation is probably not really relevant right now.\n+        if cx.sess().opts.test {\n+            return;\n+        }\n+\n+        // `#[doc(hidden)]` disables missing_docs check.\n+        if self.doc_hidden() {\n+            return;\n+        }\n+\n+        if in_macro(cx, sp) {\n+            return;\n+        }\n+\n+        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n+        if !has_doc {\n+            cx.span_lint(MISSING_DOCS_IN_PRIVATE_ITEMS, sp,\n+                         &format!(\"missing documentation for {}\", desc));\n+        }\n+    }\n+}\n+\n+impl LintPass for MissingDoc {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![MISSING_DOCS_IN_PRIVATE_ITEMS]\n+    }\n+}\n+\n+impl LateLintPass for MissingDoc {\n+    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n+        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+                None => false,\n+                Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n+            }\n+        });\n+        self.doc_hidden_stack.push(doc_hidden);\n+    }\n+\n+    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) {\n+        self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n+    }\n+\n+    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n+        self.check_missing_docs_attrs(cx, &krate.attrs, krate.span, \"crate\");\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        let desc = match it.node {\n+            hir::ItemConst(..) => \"a constant\",\n+            hir::ItemEnum(..) => \"an enum\",\n+            hir::ItemFn(..) => \"a function\",\n+            hir::ItemMod(..) => \"a module\",\n+            hir::ItemStatic(..) => \"a static\",\n+            hir::ItemStruct(..) => \"a struct\",\n+            hir::ItemTrait(..) => \"a trait\",\n+            hir::ItemTy(..) => \"a type alias\",\n+            hir::ItemUnion(..) => \"a union\",\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemExternCrate(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemImpl(..) |\n+            hir::ItemUse(..) => return,\n+        };\n+\n+        self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n+        let desc = match trait_item.node {\n+            hir::ConstTraitItem(..) => \"an associated constant\",\n+            hir::MethodTraitItem(..) => \"a trait method\",\n+            hir::TypeTraitItem(..) => \"an associated type\",\n+        };\n+\n+        self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n+        // If the method is an impl for a trait, don't doc.\n+        let def_id = cx.tcx.map.local_def_id(impl_item.id);\n+        match cx.tcx.impl_or_trait_items.borrow()\n+                                         .get(&def_id)\n+                                         .expect(\"missing method descriptor?!\")\n+                                         .container() {\n+            ty::TraitContainer(_) => return,\n+            ty::ImplContainer(cid) => {\n+                if cx.tcx.impl_trait_ref(cid).is_some() {\n+                    return\n+                }\n+            }\n+        }\n+\n+        let desc = match impl_item.node {\n+            hir::ImplItemKind::Const(..) => \"an associated constant\",\n+            hir::ImplItemKind::Method(..) => \"a method\",\n+            hir::ImplItemKind::Type(_) => \"an associated type\",\n+        };\n+        self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n+        if !sf.is_positional() {\n+            self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a struct field\");\n+        }\n+    }\n+\n+    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n+        self.check_missing_docs_attrs(cx, &v.node.attrs, v.span, \"a variant\");\n+    }\n+}"}, {"sha": "10c8154d100e777d232ccb7139b2695d6c9fd757", "filename": "clippy_lints/src/module_inception.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7b717d3152e9ad1b3e874d9b5dd957521640f40b/clippy_lints%2Fsrc%2Fmodule_inception.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b717d3152e9ad1b3e874d9b5dd957521640f40b/clippy_lints%2Fsrc%2Fmodule_inception.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodule_inception.rs?ref=7b717d3152e9ad1b3e874d9b5dd957521640f40b", "patch": "@@ -1,50 +0,0 @@\n-use rustc::lint::*;\n-use syntax::ast::*;\n-use utils::span_lint;\n-\n-/// **What it does:** Checks for modules that have the same name as their parent module\n-///\n-/// **Why is this bad?** A typical beginner mistake is to have `mod foo;` and again `mod foo { .. }` in `foo.rs`.\n-///                      The expectation is that items inside the inner `mod foo { .. }` are then available\n-///                      through `foo::x`, but they are only available through `foo::foo::x`.\n-///                      If this is done on purpose, it would be better to choose a more representative module name.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-/// ```rust\n-/// // lib.rs\n-/// mod foo;\n-/// // foo.rs\n-/// mod foo {\n-///     ...\n-/// }\n-/// ```\n-declare_lint! {\n-    pub MODULE_INCEPTION,\n-    Warn,\n-    \"modules that have the same name as their parent module\"\n-}\n-\n-pub struct Pass;\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array![MODULE_INCEPTION]\n-    }\n-}\n-\n-impl EarlyLintPass for Pass {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n-        if let ItemKind::Mod(ref module) = item.node {\n-            for sub_item in &module.items {\n-                if let ItemKind::Mod(_) = sub_item.node {\n-                    if item.ident == sub_item.ident {\n-                        span_lint(cx, MODULE_INCEPTION, sub_item.span,\n-                                  \"module has the same name as its containing module\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "a2117656f9d7851b5f0499e2046d4df65afae535", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -3,7 +3,6 @@\n //! This lint is **warn** by default\n \n use rustc::lint::{LintPass, LintArray, LateLintPass, LateContext};\n-use rustc::ty::subst::ParamSpace;\n use rustc::ty;\n use rustc::hir::Expr;\n use syntax::ast;\n@@ -58,9 +57,9 @@ pub struct MutexAtomic;\n impl LateLintPass for MutexAtomic {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         let ty = cx.tcx.expr_ty(expr);\n-        if let ty::TyStruct(_, subst) = ty.sty {\n+        if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {\n-                let mutex_param = &subst.types.get(ParamSpace::TypeSpace, 0).sty;\n+                let mutex_param = &subst.type_at(0).sty;\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\\n                                        behaviour and not the internal type, consider using Mutex<()>.\","}, {"sha": "9f607f4350d2a2259df65d8461e6d202b716b76a", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty::TyStruct;\n+use rustc::ty::TyAdt;\n use rustc::hir::{Expr, ExprStruct};\n use utils::span_lint;\n \n@@ -34,7 +34,7 @@ impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tcx.expr_ty(expr);\n-            if let TyStruct(def, _) = ty.sty {\n+            if let TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n                     span_lint(cx,\n                               NEEDLESS_UPDATE,"}, {"sha": "538d3abd5ea430fb204d299968862a33683bdff6", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -146,7 +146,7 @@ impl LateLintPass for NewWithoutDefault {\n \n fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> bool {\n     match ty.sty {\n-        ty::TyStruct(adt_def, substs) => {\n+        ty::TyAdt(adt_def, substs) if adt_def.is_struct() => {\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);\n                 if !implements_trait(cx, f_ty, default_trait_id, Vec::new()) {"}, {"sha": "dea950ac063ef8cf6e261337d510172aca84d662", "filename": "clippy_lints/src/ptr.rs", "status": "renamed", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -5,14 +5,14 @@ use rustc::hir::map::NodeItem;\n use rustc::lint::*;\n use rustc::ty;\n use syntax::ast::NodeId;\n-use utils::{match_type, paths, span_lint};\n+use utils::{match_path, match_type, paths, span_lint};\n \n-/// **What it does:** Checks for function arguments of type `&String` or `&Vec`\n-/// unless the references are mutable.\n+/// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless\n+/// the references are mutable.\n ///\n-/// **Why is this bad?** Requiring the argument to be of the specific size makes\n-/// the function less useful for no benefit; slices in the form of `&[T]` or\n-/// `&str` usually suffice and can be obtained from other types, too.\n+/// **Why is this bad?** Requiring the argument to be of the specific size makes the function less\n+/// useful for no benefit; slices in the form of `&[T]` or `&str` usually suffice and can be\n+/// obtained from other types, too.\n ///\n /// **Known problems:** None.\n ///\n@@ -23,19 +23,38 @@ use utils::{match_type, paths, span_lint};\n declare_lint! {\n     pub PTR_ARG,\n     Warn,\n-    \"arguments of the type `&Vec<...>` (instead of `&[...]`) or `&String` (instead of `&str`)\"\n+    \"fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` \\\n+     instead, respectively\"\n }\n \n+/// **What it does:** This lint checks for equality comparisons with `ptr::null`\n+///\n+/// **Why is this bad?** It's easier and more readable to use the inherent `.is_null()`\n+/// method instead\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// if x == ptr::null { .. }\n+/// ```\n+declare_lint! {\n+    pub CMP_NULL,\n+    Warn,\n+    \"comparing a pointer to a null pointer, suggesting to use `.is_null()` instead.\"\n+}\n+\n+\n #[derive(Copy,Clone)]\n-pub struct PtrArg;\n+pub struct PointerPass;\n \n-impl LintPass for PtrArg {\n+impl LintPass for PointerPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(PTR_ARG)\n+        lint_array!(PTR_ARG, CMP_NULL)\n     }\n }\n \n-impl LateLintPass for PtrArg {\n+impl LateLintPass for PointerPass {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n             check_fn(cx, decl, item.id);\n@@ -58,6 +77,17 @@ impl LateLintPass for PtrArg {\n             check_fn(cx, &sig.decl, item.id);\n         }\n     }\n+    \n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if let ExprBinary(ref op, ref l, ref r) = expr.node {\n+            if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n+                span_lint(cx,\n+                          CMP_NULL,\n+                          expr.span,\n+                          \"Comparing with null is better expressed by the .is_null() method\");\n+            }\n+        }\n+    }\n }\n \n fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n@@ -81,3 +111,14 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n         }\n     }\n }\n+\n+fn is_null_path(expr: &Expr) -> bool {\n+    if let ExprCall(ref pathexp, ref args) = expr.node {\n+        if args.is_empty() {\n+            if let ExprPath(_, ref path) = pathexp.node {\n+                return match_path(path, &paths::PTR_NULL) || match_path(path, &paths::PTR_NULL_MUT)\n+            }\n+        }\n+    }\n+    false\n+}", "previous_filename": "clippy_lints/src/ptr_arg.rs"}, {"sha": "488ca5c8a62bda88f9faff6c7d72face032b25d2", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -51,8 +51,8 @@ impl LateLintPass for UnsafeNameRemoval {\n                 ViewPath_::ViewPathList(_, ref path_list_items) => {\n                     for path_list_item in path_list_items.iter() {\n                         let plid = path_list_item.node;\n-                        if let (Some(name), Some(rename)) = (plid.name(), plid.rename()) {\n-                            unsafe_to_safe_check(name, rename, cx, &item.span);\n+                        if let Some(rename) = plid.rename {\n+                            unsafe_to_safe_check(plid.name, rename, cx, &item.span);\n                         };\n                     }\n                 }"}, {"sha": "a277226eb67c6844a8f0d13922f7c0f8d86d2870", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,14 +1,23 @@\n+//! Utility functions about comparison operators.\n+\n+#![deny(missing_docs_in_private_items)]\n+\n use rustc::hir::{BinOp_, Expr};\n \n #[derive(PartialEq, Eq, Debug, Copy, Clone)]\n+/// Represent a normalized comparison operator.\n pub enum Rel {\n+    /// `<`\n     Lt,\n+    /// `<=`\n     Le,\n+    /// `==`\n     Eq,\n+    /// `!=`\n     Ne,\n }\n \n-/// Put the expression in the form  `lhs < rhs` or `lhs <= rhs`.\n+/// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or `lhs != rhs`.\n pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n                                 -> Option<(Rel, &'a Expr, &'a Expr)> {\n     match op {"}, {"sha": "f9a93ed3f6ee1fef1c83b0a83f852c8b94f3c145", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,12 +1,16 @@\n+//! Read configurations files.\n+\n+#![deny(missing_docs_in_private_items)]\n+\n use std::{fmt, fs, io};\n use std::io::Read;\n-use syntax::{ast, codemap, ptr};\n+use syntax::{ast, codemap};\n use syntax::parse::token;\n use toml;\n \n /// Get the configuration file from arguments.\n-pub fn file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::InternedString>, (&'static str, codemap::Span)> {\n-    for arg in args {\n+pub fn file(args: &[codemap::Spanned<ast::NestedMetaItemKind>]) -> Result<Option<token::InternedString>, (&'static str, codemap::Span)> {\n+    for arg in args.iter().filter_map(|a| a.meta_item()) {\n         match arg.node {\n             ast::MetaItemKind::Word(ref name) |\n             ast::MetaItemKind::List(ref name, _) => {\n@@ -32,9 +36,20 @@ pub fn file(args: &[ptr::P<ast::MetaItem>]) -> Result<Option<token::InternedStri\n /// Error from reading a configuration file.\n #[derive(Debug)]\n pub enum Error {\n+    /// An I/O error.\n     Io(io::Error),\n+    /// The file is not valid TOML.\n     Toml(Vec<toml::ParserError>),\n-    Type(&'static str, &'static str, &'static str),\n+    /// Type error.\n+    Type(\n+        /// The name of the key.\n+        &'static str,\n+        /// The expected type.\n+        &'static str,\n+        /// The type we got instead.\n+        &'static str\n+    ),\n+    /// There is an unknown key is the file.\n     UnknownKey(String),\n }\n "}, {"sha": "179c251e3228caead11b694a35a2ab68d2077fa4", "filename": "clippy_lints/src/utils/constants.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconstants.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,21 @@\n+//! This module contains some useful constants.\n+\n+#![deny(missing_docs_in_private_items)]\n+\n+/// List of the built-in types names.\n+///\n+/// See also [the reference][reference-types] for a list of such types.\n+///\n+/// [reference-types]: https://doc.rust-lang.org/reference.html#types\n+pub const BUILTIN_TYPES: &'static [&'static str] = &[\n+    \"i8\", \"u8\",\n+    \"i16\", \"u16\",\n+    \"i32\", \"u32\",\n+    \"i64\", \"u64\",\n+    \"isize\", \"usize\",\n+    \"f32\",\n+    \"f64\",\n+    \"bool\",\n+    \"str\",\n+    \"char\",\n+];"}, {"sha": "aed07471a6564bb06178c05b5f948aaa798d1ab2", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,5 +1,7 @@\n //! This module contains functions for retrieve the original AST from lowered `hir`.\n \n+#![deny(missing_docs_in_private_items)]\n+\n use rustc::hir;\n use rustc::lint::LateContext;\n use syntax::ast;\n@@ -33,14 +35,17 @@ pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n /// Represent a range akin to `ast::ExprKind::Range`.\n #[derive(Debug, Copy, Clone)]\n pub struct Range<'a> {\n+    /// The lower bound of the range, or `None` for ranges such as `..X`.\n     pub start: Option<&'a hir::Expr>,\n+    /// The upper bound of the range, or `None` for ranges such as `X..`.\n     pub end: Option<&'a hir::Expr>,\n+    /// Whether the interval is open or closed.\n     pub limits: ast::RangeLimits,\n }\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n pub fn range(expr: &hir::Expr) -> Option<Range> {\n-    // To be removed when ranges get stable.\n+    /// Skip unstable blocks. To be removed when ranges get stable.\n     fn unwrap_unstable(expr: &hir::Expr) -> &hir::Expr {\n         if let hir::ExprBlock(ref block) = expr.node {\n             if block.rules == hir::BlockCheckMode::PushUnstableBlock || block.rules == hir::BlockCheckMode::PopUnstableBlock {\n@@ -53,6 +58,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n         expr\n     }\n \n+    /// Find the field named `name` in the field. Always return `Some` for convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter()\n                           .find(|field| field.name.node.as_str() == name)"}, {"sha": "964774562e2a204148df31214cb3a233e516480f", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 122, "deletions": 3, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,7 +1,12 @@\n use rustc::lint::*;\n-use utils::span_lint;\n+use rustc::hir::*;\n+use rustc::hir::intravisit::{Visitor, walk_expr};\n+use utils::{paths, match_path, span_lint};\n use syntax::parse::token::InternedString;\n-use syntax::ast::*;\n+use syntax::ast::{Name, NodeId, ItemKind, Crate as AstCrate};\n+use syntax::codemap::Span;\n+use std::collections::{HashSet, HashMap};\n+\n \n /// **What it does:** Checks for various things we like to keep tidy in clippy.\n ///\n@@ -17,6 +22,36 @@ declare_lint! {\n }\n \n \n+/// **What it does:** Ensures every lint is associated to a `LintPass`.\n+///\n+/// **Why is this bad?** The compiler only knows lints via a `LintPass`. Without\n+/// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n+/// know the name of the lint.\n+///\n+/// **Known problems:** Only checks for lints associated using the `lint_array!`\n+/// macro.\n+///\n+/// **Example:**\n+/// ```rust\n+/// declare_lint! { pub LINT_1, ... }\n+/// declare_lint! { pub LINT_2, ... }\n+/// declare_lint! { pub FORGOTTEN_LINT, ... }\n+/// // ...\n+/// pub struct Pass;\n+/// impl LintPass for Pass {\n+///     fn get_lints(&self) -> LintArray {\n+///         lint_array![LINT_1, LINT_2]\n+///         // missing FORGOTTEN_LINT\n+///     }\n+/// }\n+/// ```\n+declare_lint! {\n+    pub LINT_WITHOUT_LINT_PASS,\n+    Warn,\n+    \"declaring a lint without associating it in a LintPass\"\n+}\n+\n+\n #[derive(Copy, Clone)]\n pub struct Clippy;\n \n@@ -27,7 +62,7 @@ impl LintPass for Clippy {\n }\n \n impl EarlyLintPass for Clippy {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext, krate: &AstCrate) {\n         if let Some(utils) = krate.module.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n             if let ItemKind::Mod(ref utils_mod) = utils.node {\n                 if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n@@ -52,3 +87,87 @@ impl EarlyLintPass for Clippy {\n         }\n     }\n }\n+\n+\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct LintWithoutLintPass {\n+    declared_lints: HashMap<Name, Span>,\n+    registered_lints: HashSet<Name>,\n+}\n+\n+\n+impl LintPass for LintWithoutLintPass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(LINT_WITHOUT_LINT_PASS)\n+    }\n+}\n+\n+\n+impl LateLintPass for LintWithoutLintPass {\n+    fn check_item(&mut self, _: &LateContext, item: &Item) {\n+        if let ItemStatic(ref ty, MutImmutable, ref expr) = item.node {\n+            if is_lint_ref_type(ty) {\n+                self.declared_lints.insert(item.name, item.span);\n+            } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name.as_str() == \"ARRAY\" {\n+                let mut collector = LintCollector { output: &mut self.registered_lints };\n+                collector.visit_expr(expr);\n+            }\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext, _: &Crate) {\n+        for (lint_name, &lint_span) in &self.declared_lints {\n+            // When using the `declare_lint!` macro, the original `lint_span`'s\n+            // file points to \"<rustc macros>\".\n+            // `compiletest-rs` thinks that's an error in a different file and\n+            // just ignores it. This causes the test in compile-fail/lint_pass\n+            // not able to capture the error.\n+            // Therefore, we need to climb the macro expansion tree and find the\n+            // actual span that invoked `declare_lint!`:\n+            let lint_span = cx.sess().codemap().source_callsite(lint_span);\n+\n+            if !self.registered_lints.contains(lint_name) {\n+                span_lint(cx,\n+                          LINT_WITHOUT_LINT_PASS,\n+                          lint_span,\n+                          &format!(\"the lint `{}` is not added to any `LintPass`\", lint_name));\n+            }\n+        }\n+    }\n+}\n+\n+\n+fn is_lint_ref_type(ty: &Ty) -> bool {\n+    if let TyRptr(Some(_), MutTy { ty: ref inner, mutbl: MutImmutable }) = ty.node {\n+        if let TyPath(None, ref path) = inner.node {\n+            return match_path(path, &paths::LINT);\n+        }\n+    }\n+    false\n+}\n+\n+\n+fn is_lint_array_type(ty: &Ty) -> bool {\n+    if let TyPath(None, ref path) = ty.node {\n+        match_path(path, &paths::LINT_ARRAY)\n+    } else {\n+        false\n+    }\n+}\n+\n+struct LintCollector<'a> {\n+    output: &'a mut HashSet<Name>,\n+}\n+\n+impl<'v, 'a: 'v> Visitor<'v> for LintCollector<'a> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        walk_expr(self, expr);\n+    }\n+\n+    fn visit_path(&mut self, path: &'v Path, _: NodeId) {\n+        if path.segments.len() == 1 {\n+            self.output.insert(path.segments[0].name);\n+        }\n+    }\n+}"}, {"sha": "2a86d0af380883f6a60431b1c85a5c4f48fe6828", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -22,6 +22,7 @@ use syntax::ptr::P;\n pub mod cargo;\n pub mod comparisons;\n pub mod conf;\n+pub mod constants;\n mod hir;\n pub mod paths;\n pub mod sugg;\n@@ -151,11 +152,10 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n     apb.names == path\n }\n \n-/// Check if type is struct or enum type with given def path.\n+/// Check if type is struct, enum or union type with given def path.\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyEnum(adt, _) |\n-        ty::TyStruct(adt, _) => match_def_path(cx, adt.did, path),\n+        ty::TyAdt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n@@ -279,7 +279,7 @@ pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>,\n                                                         trait_id,\n                                                         0,\n                                                         ty,\n-                                                        ty_params);\n+                                                        &ty_params);\n \n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n     })\n@@ -721,7 +721,43 @@ pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n     }\n }\n \n-pub fn is_copy<'a, 'ctx>(cx: &LateContext<'a, 'ctx>, ty: ty::Ty<'ctx>, env: NodeId) -> bool {\n+pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: NodeId) -> bool {\n     let env = ty::ParameterEnvironment::for_item(cx.tcx, env);\n     !ty.subst(cx.tcx, env.free_substs).moves_by_default(cx.tcx.global_tcx(), &env, DUMMY_SP)\n }\n+\n+/// Return whether a pattern is refutable.\n+pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n+    fn is_enum_variant(cx: &LateContext, did: NodeId) -> bool {\n+        matches!(cx.tcx.def_map.borrow().get(&did).map(|d| d.full_def()), Some(def::Def::Variant(..)))\n+    }\n+\n+    fn are_refutable<'a, I: Iterator<Item=&'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n+        i.any(|pat| is_refutable(cx, pat))\n+    }\n+\n+    match pat.node {\n+        PatKind::Binding(..) | PatKind::Wild => false,\n+        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Lit(..) | PatKind::Range(..) => true,\n+        PatKind::Path(..) => is_enum_variant(cx, pat.id),\n+        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n+        PatKind::Struct(_, ref fields, _) => {\n+            if is_enum_variant(cx, pat.id) {\n+                true\n+            } else {\n+                are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n+            }\n+        }\n+        PatKind::TupleStruct(_, ref pats, _) => {\n+            if is_enum_variant(cx, pat.id) {\n+                true\n+            } else {\n+                are_refutable(cx, pats.iter().map(|pat| &**pat))\n+            }\n+        }\n+        PatKind::Vec(ref head, ref middle, ref tail) => {\n+            are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n+        }\n+    }\n+}"}, {"sha": "cd9b7c83eda6d76a30f4586cee5a6aad2578d713", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -26,11 +26,15 @@ pub const HASHSET: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"Ha\n pub const IO_PRINT: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n pub const ITERATOR: [&'static str; 4] = [\"core\", \"iter\", \"iterator\", \"Iterator\"];\n pub const LINKED_LIST: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const LINT: [&'static str; 3] = [\"rustc\", \"lint\", \"Lint\"];\n+pub const LINT_ARRAY: [&'static str; 3] = [\"rustc\", \"lint\", \"LintArray\"];\n pub const MEM_FORGET: [&'static str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MUTEX: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPS_MODULE: [&'static str; 2] = [\"core\", \"ops\"];\n pub const OPTION: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const PTR_NULL: [&'static str; 2] = [\"ptr\", \"null\"];\n+pub const PTR_NULL_MUT: [&'static str; 2] = [\"ptr\", \"null_mut\"];\n pub const RANGE: [&'static str; 3] = [\"core\", \"ops\", \"Range\"];\n pub const RANGE_FROM: [&'static str; 3] = [\"core\", \"ops\", \"RangeFrom\"];\n pub const RANGE_FROM_STD: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];"}, {"sha": "560ec491b455365d4f00569a91d88d07ddd33989", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,3 +1,6 @@\n+//! Contains utility functions to generate suggestions.\n+#![deny(missing_docs_in_private_items)]\n+\n use rustc::hir;\n use rustc::lint::{EarlyContext, LateContext, LintContext};\n use rustc_errors;\n@@ -35,6 +38,7 @@ impl<'a> Display for Sugg<'a> {\n \n #[allow(wrong_self_convention)] // ok, because of the function `as_ty` method\n impl<'a> Sugg<'a> {\n+    /// Prepare a suggestion from an expression.\n     pub fn hir_opt(cx: &LateContext, expr: &hir::Expr) -> Option<Sugg<'a>> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n@@ -72,10 +76,12 @@ impl<'a> Sugg<'a> {\n         })\n     }\n \n+    /// Convenience function around `hir_opt` for suggestions with a default text.\n     pub fn hir(cx: &LateContext, expr: &hir::Expr, default: &'a str) -> Sugg<'a> {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n+    /// Prepare a suggestion from an expression.\n     pub fn ast(cx: &EarlyContext, expr: &ast::Expr, default: &'a str) -> Sugg<'a> {\n         use syntax::ast::RangeLimits;\n \n@@ -193,12 +199,16 @@ impl<'a> std::ops::Not for Sugg<'a> {\n     }\n }\n \n+/// Helper type to display either `foo` or `(foo)`.\n struct ParenHelper<T> {\n+    /// Whether parenthesis are needed.\n     paren: bool,\n+    /// The main thing to display.\n     wrapped: T,\n }\n \n impl<T> ParenHelper<T> {\n+    /// Build a `ParenHelper`.\n     fn new(paren: bool, wrapped: T) -> Self {\n         ParenHelper {\n             paren: paren,\n@@ -230,14 +240,18 @@ pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n /// Precedence of shift operator relative to other arithmetic operation is often confusing so\n /// parenthesis will always be added for a mix of these.\n pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+    /// Whether the operator is a shift operator `<<` or `>>`.\n     fn is_shift(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n+    /// Whether the operator is a arithmetic operator (`+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n     }\n \n+    /// Whether the operator `op` needs parenthesis with the operator `other` in the direction\n+    /// `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence() ||\n             (other.precedence() == op.precedence() &&\n@@ -298,10 +312,15 @@ pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n }\n \n #[derive(PartialEq, Eq)]\n+/// Operator associativity.\n enum Associativity {\n+    /// The operator is both left-associative and right-associative.\n     Both,\n+    /// The operator is left-associative.\n     Left,\n+    /// The operator is not associative.\n     None,\n+    /// The operator is right-associative.\n     Right,\n }\n \n@@ -383,6 +402,7 @@ fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n     }\n }\n \n+/// Convenience extension trait for `DiagnosticBuilder`.\n pub trait DiagnosticBuilderExt<T: LintContext> {\n     /// Suggests to add an attribute to an item.\n     ///"}, {"sha": "06d3d040ccdc57237befdbe13d3f7cce04d9c61f", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -88,8 +88,8 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n fn vec_type(ty: ty::Ty) -> ty::Ty {\n-    if let ty::TyStruct(_, substs) = ty.sty {\n-        substs.types.get(ty::subst::ParamSpace::TypeSpace, 0)\n+    if let ty::TyAdt(_, substs) = ty.sty {\n+        substs.type_at(0)\n     } else {\n         panic!(\"The type of `vec!` is a not a struct?\");\n     }"}, {"sha": "1b9333d80b091d9c5cb0f8c92a8c6146da5367f5", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -3,6 +3,7 @@\n #![feature(rustc_private)]\n #![allow(unknown_lints)]\n #![feature(borrow_state)]\n+#![allow(missing_docs_in_private_items)]\n \n extern crate rustc_plugin;\n use rustc_plugin::Registry;"}, {"sha": "83c569ebb397ec7c34ad9f3bb170aaddb24085e2", "filename": "src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -2,6 +2,8 @@\n #![feature(box_syntax)]\n #![feature(rustc_private)]\n \n+#![allow(unknown_lints, missing_docs_in_private_items)]\n+\n extern crate clippy_lints;\n extern crate getopts;\n extern crate rustc;\n@@ -70,7 +72,7 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n             let old = std::mem::replace(&mut control.after_parse.callback, box |_| {});\n             control.after_parse.callback = Box::new(move |state| {\n                 {\n-                    let mut registry = rustc_plugin::registry::Registry::new(state.session, state.krate.as_ref().expect(\"at this compilation stage the krate must be parsed\"));\n+                    let mut registry = rustc_plugin::registry::Registry::new(state.session, state.krate.as_ref().expect(\"at this compilation stage the krate must be parsed\").span);\n                     registry.args_hidden = Some(Vec::new());\n                     clippy_lints::register_plugins(&mut registry);\n "}, {"sha": "172875a6b9aacfe1df7c96a98c7432cd845e1718", "filename": "tests/compile-fail/builtin-type-shadow.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fbuiltin-type-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fbuiltin-type-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbuiltin-type-shadow.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,11 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(builtin_type_shadow)]\n+\n+fn foo<u32>(a: u32) -> u32 { //~ERROR shadows the built-in type `u32`\n+    42  //~ERROR E0308\n+    // ^ rustc's type error\n+}\n+\n+fn main() {\n+}"}, {"sha": "a55ea6f5bca29fdc8294310a8c0fc67146280ad8", "filename": "tests/compile-fail/cmp_null.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fcmp_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fcmp_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcmp_null.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,19 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(cmp_null)]\n+#![allow(unused_mut)]\n+\n+use std::ptr;\n+\n+fn main() {\n+    let x = 0;\n+    let p : *const usize = &x;\n+    if p == ptr::null() { //~ERROR:  Comparing with null\n+        println!(\"This is surprising!\");\n+    }\n+    let mut y = 0;\n+    let mut m : *mut usize = &mut y;\n+    if m == ptr::null_mut() { //~ERROR:  Comparing with null\n+        println!(\"This is surprising, too!\");\n+    }\n+}"}, {"sha": "cf4467f30a59271abe40ea019cf4efdf1890db6f", "filename": "tests/compile-fail/derive.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fderive.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,9 +1,10 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n+#![feature(untagged_unions)]\n+\n #![deny(warnings)]\n #![allow(dead_code)]\n-#![allow(unused_variables)] // Temporary fix for rustc false positive. To be removed.\n \n use std::hash::{Hash, Hasher};\n \n@@ -46,6 +47,20 @@ impl Clone for Qux {\n     fn clone(&self) -> Self { Qux }\n }\n \n+// looks like unions don't support deriving Clone for now\n+#[derive(Copy)]\n+union Union {\n+    a: u8,\n+}\n+\n+impl Clone for Union {\n+    fn clone(&self) -> Self {\n+        Union {\n+            a: 42,\n+        }\n+    }\n+}\n+\n // See #666\n #[derive(Copy)]\n struct Lt<'a> {"}, {"sha": "782c406d74c881ff25d24a7b80cd8739e47a8fd7", "filename": "tests/compile-fail/diverging_sub_expression.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fdiverging_sub_expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fdiverging_sub_expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdiverging_sub_expression.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,37 @@\n+#![feature(plugin, never_type)]\n+#![plugin(clippy)]\n+#![deny(diverging_sub_expression)]\n+\n+#[allow(empty_loop)]\n+fn diverge() -> ! { loop {} }\n+\n+struct A;\n+\n+impl A {\n+    fn foo(&self) -> ! { diverge() }\n+}\n+\n+#[allow(unused_variables, unnecessary_operation)]\n+fn main() {\n+    let b = true;\n+    b || diverge(); //~ ERROR sub-expression diverges\n+    b || A.foo(); //~ ERROR sub-expression diverges\n+    let y = (5, diverge(), 6); //~ ERROR sub-expression diverges\n+    println!(\"{}\", y.1);\n+}\n+\n+#[allow(dead_code, unused_variables)]\n+fn foobar() {\n+    loop {\n+        let x = match 5 {\n+            4 => return,\n+            5 => continue,\n+            6 => (println!(\"foo\"), return), //~ ERROR sub-expression diverges\n+            7 => (println!(\"bar\"), continue), //~ ERROR sub-expression diverges\n+            8 => break,\n+            9 => diverge(),\n+            3 => (println!(\"moo\"), diverge()), //~ ERROR sub-expression diverges\n+            _ => (println!(\"boo\"), break), //~ ERROR sub-expression diverges\n+        };\n+    }\n+}"}, {"sha": "12fd104312a9f9bea3fa4c06f80e2b02432c5af6", "filename": "tests/compile-fail/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fenum_glob_use.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,7 +1,7 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n #![deny(clippy, clippy_pedantic)]\n-#![allow(unused_imports, dead_code)]\n+#![allow(unused_imports, dead_code, missing_docs_in_private_items)]\n \n use std::cmp::Ordering::*; //~ ERROR: don't use glob imports for enum variants\n "}, {"sha": "8e185f24b1f992ce39f56439f4b8df17033cca4a", "filename": "tests/compile-fail/escape_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fescape_analysis.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -31,7 +31,7 @@ fn ok_box_trait(boxed_trait: &Box<Z>) {\n \n fn warn_call() {\n     let x = box A; //~ ERROR local variable\n-    x.foo(); \n+    x.foo();\n }\n \n fn warn_arg(x: Box<A>) { //~ ERROR local variable"}, {"sha": "20803c8d0e858c01f068d5a6664c759e9bb28ff5", "filename": "tests/compile-fail/filter_methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Ffilter_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Ffilter_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffilter_methods.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -2,6 +2,8 @@\n #![plugin(clippy)]\n \n #![deny(clippy, clippy_pedantic)]\n+#![allow(missing_docs_in_private_items)]\n+\n fn main() {\n     let _: Vec<_> = vec![5; 6].into_iter() //~ERROR called `filter(p).map(q)` on an `Iterator`\n                               .filter(|&x| x == 0)"}, {"sha": "b640c6db3a3ceb4cdfece7f834d26308021b33fb", "filename": "tests/compile-fail/len_zero.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flen_zero.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,18 +1,45 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n+#![deny(len_without_is_empty, len_zero)]\n+#![allow(dead_code, unused)]\n+\n+pub struct PubOne;\n+\n+impl PubOne {\n+    pub fn len(self: &Self) -> isize { //~ERROR item `PubOne` has a public `len` method but no corresponding `is_empty`\n+        1\n+    }\n+}\n+\n+struct NotPubOne;\n+\n+impl NotPubOne {\n+    pub fn len(self: &Self) -> isize { // no error, len is pub but `NotPubOne` is not exported anyway\n+        1\n+    }\n+}\n+\n struct One;\n \n-#[deny(len_without_is_empty)]\n impl One {\n-    fn len(self: &Self) -> isize { //~ERROR item `One` has a `.len(_: &Self)`\n+    fn len(self: &Self) -> isize { // no error, len is private, see #1085\n         1\n     }\n }\n \n-#[deny(len_without_is_empty)]\n+pub trait PubTraitsToo {\n+    fn len(self: &Self) -> isize; //~ERROR trait `PubTraitsToo` has a `len` method but no `is_empty`\n+}\n+\n+impl PubTraitsToo for One {\n+    fn len(self: &Self) -> isize {\n+        0\n+    }\n+}\n+\n trait TraitsToo {\n-    fn len(self: &Self) -> isize; //~ERROR trait `TraitsToo` has a `.len(_:\n+    fn len(self: &Self) -> isize; // no error, len is private, see #1085\n }\n \n impl TraitsToo for One {\n@@ -21,11 +48,22 @@ impl TraitsToo for One {\n     }\n }\n \n-struct HasIsEmpty;\n+struct HasPrivateIsEmpty;\n+\n+impl HasPrivateIsEmpty {\n+    pub fn len(self: &Self) -> isize {\n+        1\n+    }\n+\n+    fn is_empty(self: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+pub struct HasIsEmpty;\n \n-#[deny(len_without_is_empty)]\n impl HasIsEmpty {\n-    fn len(self: &Self) -> isize {\n+    pub fn len(self: &Self) -> isize { //~ERROR item `HasIsEmpty` has a public `len` method but a private `is_empty`\n         1\n     }\n \n@@ -36,8 +74,7 @@ impl HasIsEmpty {\n \n struct Wither;\n \n-#[deny(len_without_is_empty)]\n-trait WithIsEmpty {\n+pub trait WithIsEmpty {\n     fn len(self: &Self) -> isize;\n     fn is_empty(self: &Self) -> bool;\n }\n@@ -52,21 +89,18 @@ impl WithIsEmpty for Wither {\n     }\n }\n \n-struct HasWrongIsEmpty;\n+pub struct HasWrongIsEmpty;\n \n-#[deny(len_without_is_empty)]\n impl HasWrongIsEmpty {\n-    fn len(self: &Self) -> isize { //~ERROR item `HasWrongIsEmpty` has a `.len(_: &Self)`\n+    pub fn len(self: &Self) -> isize { //~ERROR item `HasWrongIsEmpty` has a public `len` method but no corresponding `is_empty`\n         1\n     }\n \n-    #[allow(dead_code, unused)]\n-    fn is_empty(self: &Self, x : u32) -> bool {\n+    pub fn is_empty(self: &Self, x : u32) -> bool {\n         false\n     }\n }\n \n-#[deny(len_zero)]\n fn main() {\n     let x = [1, 2];\n     if x.len() == 0 {"}, {"sha": "980ae5cb7a11f0242411cc617da31b90ba47dcb2", "filename": "tests/compile-fail/lint_pass.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Flint_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Flint_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flint_pass.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,27 @@\n+#![feature(plugin)]\n+#![feature(rustc_private)]\n+#![plugin(clippy)]\n+\n+#![deny(lint_without_lint_pass)]\n+\n+#[macro_use] extern crate rustc;\n+\n+use rustc::lint::{LintPass, LintArray};\n+\n+declare_lint! { GOOD_LINT, Warn, \"good lint\" }\n+declare_lint! { MISSING_LINT, Warn, \"missing lint\" }\n+//~^ ERROR: the lint `MISSING_LINT` is not added to any `LintPass`\n+\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![GOOD_LINT]\n+    }\n+}\n+\n+fn main() {\n+    let _ = MISSING_LINT;\n+}\n+\n+"}, {"sha": "6c8a27c2ed4a2d85347479ae774dc9d9bcb43ba4", "filename": "tests/compile-fail/literals.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fliterals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fliterals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fliterals.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -2,6 +2,7 @@\n #![plugin(clippy)]\n #![deny(mixed_case_hex_literals)]\n #![deny(unseparated_literal_suffix)]\n+#![deny(zero_prefixed_literal)]\n #![allow(dead_code)]\n \n fn main() {\n@@ -22,4 +23,16 @@ fn main() {\n     let fail5 = 1234isize;    //~ERROR integer type suffix should be separated\n     let fail6 = 1234usize;    //~ERROR integer type suffix should be separated\n     let fail7 = 1.5f32;       //~ERROR float type suffix should be separated\n+\n+    let ok9 = 0;\n+    let ok10 = 0_i64;\n+    let fail8 = 0123;\n+    //~^ERROR decimal constant\n+    //~|HELP remove the `0`\n+    //~|SUGGESTION = 123;\n+    //~|HELP use `0o`\n+    //~|SUGGESTION = 0o123;\n+\n+    let ok11 = 0o123;\n+    let ok12 = 0b101010;\n }"}, {"sha": "0412dfecac11d2a23d9e2b38730061b80e8fe51a", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -3,7 +3,7 @@\n #![plugin(clippy)]\n \n #![deny(clippy, clippy_pedantic)]\n-#![allow(blacklisted_name, unused, print_stdout, non_ascii_literal, new_without_default, new_without_default_derive)]\n+#![allow(blacklisted_name, unused, print_stdout, non_ascii_literal, new_without_default, new_without_default_derive, missing_docs_in_private_items)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;"}, {"sha": "acd86f18ea3d5cb6b1b8213c6807485eda755655", "filename": "tests/compile-fail/missing-doc.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fmissing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fmissing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmissing-doc.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,202 @@\n+/* This file incorporates work covered by the following copyright and\n+ * permission notice:\n+ *   Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+ *   file at the top-level directory of this distribution and at\n+ *   http://rust-lang.org/COPYRIGHT.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+ *   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+ *   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+ *   option. This file may not be copied, modified, or distributed\n+ *   except according to those terms.\n+ */\n+\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(missing_docs_in_private_items)]\n+\n+// When denying at the crate level, be sure to not get random warnings from the\n+// injected intrinsics by the compiler.\n+#![allow(dead_code)]\n+#![feature(associated_type_defaults)]\n+\n+//! Some garbage docs for the crate here\n+#![doc=\"More garbage\"]\n+\n+type Typedef = String; //~ ERROR: missing documentation for a type alias\n+pub type PubTypedef = String; //~ ERROR: missing documentation for a type alias\n+\n+struct Foo { //~ ERROR: missing documentation for a struct\n+    a: isize, //~ ERROR: missing documentation for a struct field\n+    b: isize, //~ ERROR: missing documentation for a struct field\n+}\n+\n+pub struct PubFoo { //~ ERROR: missing documentation for a struct\n+    pub a: isize,      //~ ERROR: missing documentation for a struct field\n+    b: isize, //~ ERROR: missing documentation for a struct field\n+}\n+\n+#[allow(missing_docs_in_private_items)]\n+pub struct PubFoo2 {\n+    pub a: isize,\n+    pub c: isize,\n+}\n+\n+mod module_no_dox {} //~ ERROR: missing documentation for a module\n+pub mod pub_module_no_dox {} //~ ERROR: missing documentation for a module\n+\n+/// dox\n+pub fn foo() {}\n+pub fn foo2() {} //~ ERROR: missing documentation for a function\n+fn foo3() {} //~ ERROR: missing documentation for a function\n+#[allow(missing_docs_in_private_items)] pub fn foo4() {}\n+\n+/// dox\n+pub trait A {\n+    /// dox\n+    fn foo(&self);\n+    /// dox\n+    fn foo_with_impl(&self) {}\n+}\n+\n+#[allow(missing_docs_in_private_items)]\n+trait B {\n+    fn foo(&self);\n+    fn foo_with_impl(&self) {}\n+}\n+\n+pub trait C { //~ ERROR: missing documentation for a trait\n+    fn foo(&self); //~ ERROR: missing documentation for a trait method\n+    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a trait method\n+}\n+\n+#[allow(missing_docs_in_private_items)]\n+pub trait D {\n+    fn dummy(&self) { }\n+}\n+\n+/// dox\n+pub trait E {\n+    type AssociatedType; //~ ERROR: missing documentation for an associated type\n+    type AssociatedTypeDef = Self; //~ ERROR: missing documentation for an associated type\n+\n+    /// dox\n+    type DocumentedType;\n+    /// dox\n+    type DocumentedTypeDef = Self;\n+    /// dox\n+    fn dummy(&self) {}\n+}\n+\n+impl Foo {\n+    pub fn foo() {} //~ ERROR: missing documentation for a method\n+    fn bar() {} //~ ERROR: missing documentation for a method\n+}\n+\n+impl PubFoo {\n+    pub fn foo() {} //~ ERROR: missing documentation for a method\n+    /// dox\n+    pub fn foo1() {}\n+    fn foo2() {} //~ ERROR: missing documentation for a method\n+    #[allow(missing_docs_in_private_items)] pub fn foo3() {}\n+}\n+\n+#[allow(missing_docs_in_private_items)]\n+trait F {\n+    fn a();\n+    fn b(&self);\n+}\n+\n+// should need to redefine documentation for implementations of traits\n+impl F for Foo {\n+    fn a() {}\n+    fn b(&self) {}\n+}\n+\n+// It sure is nice if doc(hidden) implies allow(missing_docs), and that it\n+// applies recursively\n+#[doc(hidden)]\n+mod a {\n+    pub fn baz() {}\n+    pub mod b {\n+        pub fn baz() {}\n+    }\n+}\n+\n+enum Baz { //~ ERROR: missing documentation for an enum\n+    BazA { //~ ERROR: missing documentation for a variant\n+        a: isize, //~ ERROR: missing documentation for a struct field\n+        b: isize //~ ERROR: missing documentation for a struct field\n+    },\n+    BarB //~ ERROR: missing documentation for a variant\n+}\n+\n+pub enum PubBaz { //~ ERROR: missing documentation for an enum\n+    PubBazA { //~ ERROR: missing documentation for a variant\n+        a: isize, //~ ERROR: missing documentation for a struct field\n+    },\n+}\n+\n+/// dox\n+pub enum PubBaz2 {\n+    /// dox\n+    PubBaz2A {\n+        /// dox\n+        a: isize,\n+    },\n+}\n+\n+#[allow(missing_docs_in_private_items)]\n+pub enum PubBaz3 {\n+    PubBaz3A {\n+        b: isize\n+    },\n+}\n+\n+#[doc(hidden)]\n+pub fn baz() {}\n+\n+\n+const FOO: u32 = 0; //~ ERROR: missing documentation for a const\n+/// dox\n+pub const FOO1: u32 = 0;\n+#[allow(missing_docs_in_private_items)]\n+pub const FOO2: u32 = 0;\n+#[doc(hidden)]\n+pub const FOO3: u32 = 0;\n+pub const FOO4: u32 = 0; //~ ERROR: missing documentation for a const\n+\n+\n+static BAR: u32 = 0; //~ ERROR: missing documentation for a static\n+/// dox\n+pub static BAR1: u32 = 0;\n+#[allow(missing_docs_in_private_items)]\n+pub static BAR2: u32 = 0;\n+#[doc(hidden)]\n+pub static BAR3: u32 = 0;\n+pub static BAR4: u32 = 0; //~ ERROR: missing documentation for a static\n+\n+\n+mod internal_impl { //~ ERROR: missing documentation for a module\n+    /// dox\n+    pub fn documented() {}\n+    pub fn undocumented1() {} //~ ERROR: missing documentation for a function\n+    pub fn undocumented2() {} //~ ERROR: missing documentation for a function\n+    fn undocumented3() {} //~ ERROR: missing documentation for a function\n+    /// dox\n+    pub mod globbed {\n+        /// dox\n+        pub fn also_documented() {}\n+        pub fn also_undocumented1() {} //~ ERROR: missing documentation for a function\n+        fn also_undocumented2() {} //~ ERROR: missing documentation for a function\n+    }\n+}\n+/// dox\n+pub mod public_interface {\n+    pub use internal_impl::documented as foo;\n+    pub use internal_impl::undocumented1 as bar;\n+    pub use internal_impl::{documented, undocumented2};\n+    pub use internal_impl::globbed::*;\n+}\n+\n+fn main() {} //~ ERROR: missing documentation for a function"}, {"sha": "861ed504c86ead1d1e22ac6dcba43964df7154d0", "filename": "tests/compile-fail/module_inception.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fmodule_inception.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fmodule_inception.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodule_inception.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -14,4 +14,11 @@ mod foo {\n     }\n }\n \n+// No warning. See <https://github.com/Manishearth/rust-clippy/issues/1220>.\n+mod bar {\n+    #[allow(module_inception)]\n+    mod bar {\n+    }\n+}\n+\n fn main() {}"}, {"sha": "6616f7bdc86c03a4ee2a0f95fdc2521056768068", "filename": "tests/compile-fail/no_effect.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fno_effect.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -4,6 +4,7 @@\n #![deny(no_effect, unnecessary_operation)]\n #![allow(dead_code)]\n #![allow(path_statements)]\n+#![feature(untagged_unions)]\n \n struct Unit;\n struct Tuple(i32);\n@@ -15,6 +16,11 @@ enum Enum {\n     Struct { field: i32 },\n }\n \n+union Union {\n+    a: u8,\n+    b: f64,\n+}\n+\n fn get_number() -> i32 { 0 }\n fn get_struct() -> Struct { Struct { field: 0 } }\n \n@@ -30,6 +36,7 @@ fn main() {\n     Tuple(0); //~ERROR statement with no effect\n     Struct { field: 0 }; //~ERROR statement with no effect\n     Struct { ..s }; //~ERROR statement with no effect\n+    Union { a: 0 }; //~ERROR statement with no effect\n     Enum::Tuple(0); //~ERROR statement with no effect\n     Enum::Struct { field: 0 }; //~ERROR statement with no effect\n     5 + 6; //~ERROR statement with no effect"}, {"sha": "fae87cd97503aa6bc65034fe06fa812ddc8bccae", "filename": "tests/compile-fail/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fshadow.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -1,8 +1,8 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#![allow(unused_parens, unused_variables)]\n #![deny(clippy, clippy_pedantic)]\n+#![allow(unused_parens, unused_variables, missing_docs_in_private_items)]\n \n fn id<T>(x: T) -> T { x }\n "}, {"sha": "0c99859c10d8c972b96250612eec2ea7ca25b1ad", "filename": "tests/compile-fail/stutter.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fstutter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fstutter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstutter.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -0,0 +1,14 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(stutter)]\n+#![allow(dead_code)]\n+\n+mod foo {\n+    pub fn foo() {}\n+    pub fn foo_bar() {} //~ ERROR: item name starts with its containing module's name\n+    pub fn bar_foo() {} //~ ERROR: item name ends with its containing module's name\n+    pub struct FooCake {} //~ ERROR: item name starts with its containing module's name\n+    pub enum CakeFoo {} //~ ERROR: item name ends with its containing module's name\n+}\n+\n+fn main() {}"}, {"sha": "1826f3a20e9b1366a1385c3db27d1d36faa02cee", "filename": "tests/compile-fail/useless_attribute.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fuseless_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fuseless_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fuseless_attribute.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -7,4 +7,8 @@\n //~| SUGGESTION #![allow(dead_code)]\n extern crate clippy_lints;\n \n+// don't lint on unused_import for `use` items\n+#[allow(unused_imports)]\n+use std::collections;\n+\n fn main() {}"}, {"sha": "7b0fb43575eeadd097dbfefe5ae3b8ad6908032c", "filename": "tests/compile-fail/while_loop.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -165,3 +165,31 @@ fn issue1017() {\n         }\n     }\n }\n+\n+// Issue #1188\n+fn refutable() {\n+    let a = [42, 1337];\n+    let mut b = a.iter();\n+\n+    // consume all the 42s\n+    while let Some(&42) = b.next() {\n+    }\n+\n+    let a = [(1, 2, 3)];\n+    let mut b = a.iter();\n+\n+    while let Some(&(1, 2, 3)) = b.next() {\n+    }\n+\n+    let a = [Some(42)];\n+    let mut b = a.iter();\n+\n+    while let Some(&None) = b.next() {\n+    }\n+\n+    /* This gives \u201crefutable pattern in `for` loop binding: `&_` not covered\u201d\n+    for &42 in b {}\n+    for &(1, 2, 3) in b {}\n+    for &Option::None in b.next() {}\n+    // */\n+}"}, {"sha": "540040a5ed5a70bfcff3dfff8f2f92b4dcb360fd", "filename": "tests/dogfood.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -24,7 +24,7 @@ fn dogfood() {\n     let mut s = String::new();\n     s.push_str(\" -L target/debug/\");\n     s.push_str(\" -L target/debug/deps\");\n-    s.push_str(\" -Zextra-plugins=clippy -Ltarget_recur/debug -Dclippy_pedantic -Dclippy -Dclippy_lints_internal\");\n+    s.push_str(\" -Zextra-plugins=clippy -Ltarget_recur/debug -Dclippy_pedantic -Dclippy -Dclippy_internal\");\n     config.target_rustcflags = Some(s);\n     if let Ok(name) = var(\"TESTNAME\") {\n         config.filter = Some(name.to_owned())"}, {"sha": "04196eef396089d0453cb999a4f2682682efc673", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c89c5d21c17f2070c03779bfc58254a98eafe0f8/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/c89c5d21c17f2070c03779bfc58254a98eafe0f8/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=c89c5d21c17f2070c03779bfc58254a98eafe0f8", "patch": "@@ -62,7 +62,8 @@ <h1>ALL the Clippy Lints</h1>\n                 </div>\n             </div>\n \n-            <article class=\"panel panel-default\" id=\"{{lint.id}}\" ng-repeat=\"lint in data | filter:byLevels | filter:search | orderBy:'id' track by lint.id\">\n+            <article class=\"panel panel-default\" id=\"{{lint.id}}\"\n+                ng-repeat=\"lint in data | filter:byLevels | filter:search | orderBy:'id' track by lint.id\" on-finish-render=\"ngRepeatFinished\">\n                 <header class=\"panel-heading\" ng-click=\"open[lint.id] = !open[lint.id]\">\n                     <button class=\"btn btn-default btn-sm pull-right\" style=\"margin-top: -6px;\">\n                         <span ng-show=\"open[lint.id]\">&minus;</span>\n@@ -77,11 +78,11 @@ <h2 class=\"panel-title\">\n                         <span ng-if=\"lint.level == 'Deny'\" class=\"label label-danger\">Deny</span>\n                         <span ng-if=\"lint.level == 'Deprecated'\" class=\"label label-default\">Deprecated</span>\n \n-                        <a href=\"#{{lint.id}}\" class=\"anchor label label-default\">&para;</a>\n+                        <a href=\"#{{lint.id}}\" class=\"anchor label label-default\" ng-click=\"open[lint.id] = true; $event.stopPropagation()\">&para;</a>\n                     </h2>\n                 </header>\n \n-                <ul class=\"list-group\" ng-if=\"lint.docs\" ng-class=\"{collapse: true, in: open[lint.id]}\">\n+                <ul class=\"list-group lint-docs\" ng-if=\"lint.docs\" ng-class=\"{collapse: true, in: open[lint.id]}\">\n                     <li class=\"list-group-item\" ng-repeat=\"(title, text) in lint.docs\">\n                         <h4 class=\"list-group-item-heading\">\n                             {{title}}\n@@ -96,7 +97,7 @@ <h4 class=\"list-group-item-heading\">\n     <a href=\"https://github.com/Manishearth/rust-clippy\">\n         <img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\"/>\n     </a>\n-    \n+\n     <script src=\"https://cdnjs.cloudflare.com/ajax/libs/markdown-it/7.0.0/markdown-it.min.js\"></script>\n     <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js\"></script>\n     <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/languages/rust.min.js\"></script>\n@@ -120,6 +121,21 @@ <h4 class=\"list-group-item-heading\">\n             }\n         });\n \n+        function scrollToLint(lintId) {\n+            var target = document.getElementById(lintId);\n+            if (!target) {\n+                return;\n+            }\n+            target.scrollIntoView();\n+        }\n+\n+        function scrollToLintByURL($scope) {\n+            var removeListener = $scope.$on('ngRepeatFinished', function(ngRepeatFinishedEvent) {\n+                scrollToLint(window.location.hash.slice(1));\n+                removeListener();\n+            });\n+        }\n+\n         angular.module(\"clippy\", [])\n         .filter('markdown', function ($sce) {\n             return function (text) {\n@@ -130,9 +146,22 @@ <h4 class=\"list-group-item-heading\">\n                 );\n             };\n         })\n-        .controller(\"lintList\", function ($scope, $http) {\n+        .directive('onFinishRender', function ($timeout) {\n+            return {\n+                restrict: 'A',\n+                link: function (scope, element, attr) {\n+                    if (scope.$last === true) {\n+                        $timeout(function () {\n+                            scope.$emit(attr.onFinishRender);\n+                        });\n+                    }\n+                }\n+            };\n+        })\n+        .controller(\"lintList\", function ($scope, $http, $timeout) {\n             // Level filter\n-            $scope.levels = {Allow: true, Warn: true, Deny: true, Deprecated: true};\n+            var LEVEL_FILTERS_DEFAULT = {Allow: true, Warn: true, Deny: true, Deprecated: true};\n+            $scope.levels = LEVEL_FILTERS_DEFAULT;\n             $scope.byLevels = function (lint) {\n                 return $scope.levels[lint.level];\n             };\n@@ -141,17 +170,37 @@ <h4 class=\"list-group-item-heading\">\n             $scope.open = {};\n             $scope.loading = true;\n \n+            if (window.location.hash.length > 1) {\n+                $scope.search = window.location.hash.slice(1);\n+                $scope.open[window.location.hash.slice(1)] = true;\n+                scrollToLintByURL($scope);\n+            }\n+\n             $http.get('./lints.json')\n             .success(function (data) {\n                 $scope.data = data;\n                 $scope.loading = false;\n+\n+                scrollToLintByURL($scope);\n             })\n             .error(function (data) {\n                 $scope.error = data;\n                 $scope.loading = false;\n             });\n-        })\n+\n+            window.addEventListener('hashchange', function () {\n+                // trigger re-render\n+                $timeout(function () {\n+                    $scope.levels = LEVEL_FILTERS_DEFAULT;\n+                    $scope.search = window.location.hash.slice(1);\n+                    $scope.open[window.location.hash.slice(1)] = true;\n+\n+                    scrollToLintByURL($scope);\n+                });\n+                return true;\n+            }, false);\n+        });\n     })();\n     </script>\n </body>\n-</html>\n\\ No newline at end of file\n+</html>"}]}