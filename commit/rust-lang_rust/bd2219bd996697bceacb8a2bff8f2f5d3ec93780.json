{"sha": "bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMjIxOWJkOTk2Njk3YmNlYWNiOGEyYmZmOGYyZjVkM2VjOTM3ODA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-14T15:11:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-14T15:11:17Z"}, "message": "Merge #9890\n\n9890: internal: refactor binary operator handling r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ae3ca076246d65351b483deabcf0ba5c7bd10a54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae3ca076246d65351b483deabcf0ba5c7bd10a54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhF90VCRBK7hj4Ov3rIwAARnEIAHcujmpTvj3hwLAryYFQP6+i\nGea/Kcnpd8JpQG/0yT/HgqZCenM4YqyVQyWloB9jRwFRWM4f8222+ltgmhiVs0zw\nBx8AZlaPI+BPt2nX3U2aMPFHx9pEZvofQ8YNHY2zuVyhxklNGYfynWU++tPUOx42\nu8niMaEtdXD0hOqCF4GxpCs45dpVu5z/XJvEZdEOIhpkZCSsC8JYaPo9fWVOz8nY\nZEP0VDniVPJyS0rdM+qO008nu+NDMeuoZecSKrAKaykB+8OOtEmPUPdANamzgz1i\nvkFazbQobz5VpBnixEroHQX3cKZbHiAeUhdGDFG7zj5JjHx7+rb2OhAMhUu+d1c=\n=y/BW\n-----END PGP SIGNATURE-----\n", "payload": "tree ae3ca076246d65351b483deabcf0ba5c7bd10a54\nparent 01b589b0822c1cc11944975ce14db04a917424f4\nparent 90357a9090a88b2f7bc5db5d05cb576680ce2960\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628953877 +0000\ncommitter GitHub <noreply@github.com> 1628953877 +0000\n\nMerge #9890\n\n9890: internal: refactor binary operator handling r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "html_url": "https://github.com/rust-lang/rust/commit/bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01b589b0822c1cc11944975ce14db04a917424f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b589b0822c1cc11944975ce14db04a917424f4", "html_url": "https://github.com/rust-lang/rust/commit/01b589b0822c1cc11944975ce14db04a917424f4"}, {"sha": "90357a9090a88b2f7bc5db5d05cb576680ce2960", "url": "https://api.github.com/repos/rust-lang/rust/commits/90357a9090a88b2f7bc5db5d05cb576680ce2960", "html_url": "https://github.com/rust-lang/rust/commit/90357a9090a88b2f7bc5db5d05cb576680ce2960"}], "stats": {"total": 678, "additions": 265, "deletions": 413}, "files": [{"sha": "d8dac66556b0fb890054d0cfc9e0599ed624ccce", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -27,9 +27,8 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Label,\n-        LabelId, Literal, LogicOp, MatchArm, MatchGuard, Ordering, Pat, PatId, RecordFieldPat,\n-        RecordLitField, Statement,\n+        dummy_expr_id, Array, BindingAnnotation, Expr, ExprId, Label, LabelId, Literal, MatchArm,\n+        MatchGuard, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     intern::Interned,\n     item_scope::BuiltinShadowMode,\n@@ -509,7 +508,7 @@ impl ExprCollector<'_> {\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n-                let op = e.op_kind().map(BinaryOp::from);\n+                let op = e.op_kind();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n@@ -954,50 +953,6 @@ impl ExprCollector<'_> {\n     }\n }\n \n-impl From<ast::BinOp> for BinaryOp {\n-    fn from(ast_op: ast::BinOp) -> Self {\n-        match ast_op {\n-            ast::BinOp::BooleanOr => BinaryOp::LogicOp(LogicOp::Or),\n-            ast::BinOp::BooleanAnd => BinaryOp::LogicOp(LogicOp::And),\n-            ast::BinOp::EqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n-            ast::BinOp::NegatedEqualityTest => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n-            ast::BinOp::LesserEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: false })\n-            }\n-            ast::BinOp::GreaterEqualTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false })\n-            }\n-            ast::BinOp::LesserTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less, strict: true })\n-            }\n-            ast::BinOp::GreaterTest => {\n-                BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true })\n-            }\n-            ast::BinOp::Addition => BinaryOp::ArithOp(ArithOp::Add),\n-            ast::BinOp::Multiplication => BinaryOp::ArithOp(ArithOp::Mul),\n-            ast::BinOp::Subtraction => BinaryOp::ArithOp(ArithOp::Sub),\n-            ast::BinOp::Division => BinaryOp::ArithOp(ArithOp::Div),\n-            ast::BinOp::Remainder => BinaryOp::ArithOp(ArithOp::Rem),\n-            ast::BinOp::LeftShift => BinaryOp::ArithOp(ArithOp::Shl),\n-            ast::BinOp::RightShift => BinaryOp::ArithOp(ArithOp::Shr),\n-            ast::BinOp::BitwiseXor => BinaryOp::ArithOp(ArithOp::BitXor),\n-            ast::BinOp::BitwiseOr => BinaryOp::ArithOp(ArithOp::BitOr),\n-            ast::BinOp::BitwiseAnd => BinaryOp::ArithOp(ArithOp::BitAnd),\n-            ast::BinOp::Assignment => BinaryOp::Assignment { op: None },\n-            ast::BinOp::AddAssign => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n-            ast::BinOp::DivAssign => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n-            ast::BinOp::MulAssign => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n-            ast::BinOp::RemAssign => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n-            ast::BinOp::ShlAssign => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n-            ast::BinOp::ShrAssign => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n-            ast::BinOp::SubAssign => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n-            ast::BinOp::BitOrAssign => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n-            ast::BinOp::BitAndAssign => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n-            ast::BinOp::BitXorAssign => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n-        }\n-    }\n-}\n-\n impl From<ast::LiteralKind> for Literal {\n     fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n         match ast_lit_kind {"}, {"sha": "b508d875e819a2768ecbf09de97aa1b93b6acdee", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -14,7 +14,6 @@\n \n use hir_expand::name::Name;\n use la_arena::{Idx, RawIdx};\n-use syntax::ast::RangeOp;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n@@ -24,6 +23,8 @@ use crate::{\n     BlockId,\n };\n \n+pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp};\n+\n pub type ExprId = Idx<Expr>;\n pub(crate) fn dummy_expr_id() -> ExprId {\n     ExprId::from_raw(RawIdx::from(!0))\n@@ -179,47 +180,6 @@ pub enum Expr {\n     Literal(Literal),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum BinaryOp {\n-    LogicOp(LogicOp),\n-    ArithOp(ArithOp),\n-    CmpOp(CmpOp),\n-    Assignment { op: Option<ArithOp> },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum LogicOp {\n-    And,\n-    Or,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum CmpOp {\n-    Eq { negated: bool },\n-    Ord { ordering: Ordering, strict: bool },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum Ordering {\n-    Less,\n-    Greater,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ArithOp {\n-    Add,\n-    Mul,\n-    Sub,\n-    Div,\n-    Rem,\n-    Shl,\n-    Shr,\n-    BitXor,\n-    BitOr,\n-    BitAnd,\n-}\n-\n-pub use syntax::ast::PrefixOp as UnaryOp;\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n     ElementList(Vec<ExprId>),"}, {"sha": "f82566d978e5d4c0df74355de9168beba6fd1f43", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -126,7 +126,7 @@ pub(super) fn element(\n                 let ty = sema.type_of_expr(&expr)?.original;\n                 if ty.is_raw_ptr() {\n                     HlTag::Operator(HlOperator::Other) | HlMod::Unsafe\n-                } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n+                } else if let Some(ast::UnaryOp::Deref) = prefix_expr.op_kind() {\n                     HlOperator::Other.into()\n                 } else {\n                     HlPunct::Other.into()"}, {"sha": "9c888e2d4e31a11b7fac92d1626ba2997330e42e", "filename": "crates/ide_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 17, "deletions": 75, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -19,14 +19,20 @@ use crate::{utils::invert_boolean_expression, AssistContext, AssistId, AssistKin\n // ->\n // ```\n // fn main() {\n-//     if !(x == 4 && !(y < 3.14)) {}\n+//     if !(x == 4 && y >= 3.14) {}\n // }\n // ```\n pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n-    let opposite_op = opposite_logic_op(op)?;\n+\n+    let opposite_op = match op {\n+        ast::BinaryOp::LogicOp(ast::LogicOp::And) => \"||\",\n+        ast::BinaryOp::LogicOp(ast::LogicOp::Or) => \"&&\",\n+        _ => return None,\n+    };\n+\n     let cursor_in_range = op_range.contains_range(ctx.frange.range);\n     if !cursor_in_range {\n         return None;\n@@ -85,7 +91,7 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n                 .and_then(|paren_expr| paren_expr.syntax().parent())\n                 .and_then(ast::PrefixExpr::cast)\n                 .and_then(|prefix_expr| {\n-                    if prefix_expr.op_kind().unwrap() == ast::PrefixOp::Not {\n+                    if prefix_expr.op_kind().unwrap() == ast::UnaryOp::Not {\n                         Some(prefix_expr)\n                     } else {\n                         None\n@@ -99,7 +105,7 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n             if let Some(paren_expr) = paren_expr {\n                 for term in terms {\n                     let range = term.syntax().text_range();\n-                    let not_term = invert_boolean_expression(&ctx.sema, term);\n+                    let not_term = invert_boolean_expression(term);\n \n                     edit.replace(range, not_term.syntax().text());\n                 }\n@@ -114,37 +120,28 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n             } else {\n                 if let Some(lhs) = terms.pop_front() {\n                     let lhs_range = lhs.syntax().text_range();\n-                    let not_lhs = invert_boolean_expression(&ctx.sema, lhs);\n+                    let not_lhs = invert_boolean_expression(lhs);\n \n                     edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n                 }\n \n                 if let Some(rhs) = terms.pop_back() {\n                     let rhs_range = rhs.syntax().text_range();\n-                    let not_rhs = invert_boolean_expression(&ctx.sema, rhs);\n+                    let not_rhs = invert_boolean_expression(rhs);\n \n                     edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));\n                 }\n \n                 for term in terms {\n                     let term_range = term.syntax().text_range();\n-                    let not_term = invert_boolean_expression(&ctx.sema, term);\n+                    let not_term = invert_boolean_expression(term);\n                     edit.replace(term_range, not_term.syntax().text());\n                 }\n             }\n         },\n     )\n }\n \n-// Return the opposite text for a given logical operator, if it makes sense\n-fn opposite_logic_op(kind: ast::BinOp) -> Option<&'static str> {\n-    match kind {\n-        ast::BinOp::BooleanOr => Some(\"&&\"),\n-        ast::BinOp::BooleanAnd => Some(\"||\"),\n-        _ => None,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -156,40 +153,12 @@ mod tests {\n         check_assist(\n             apply_demorgan,\n             r#\"\n-//- minicore: ord, derive\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-struct S;\n-\n-fn f() {\n-    S < S &&$0 S <= S\n-}\n-\"#,\n-            r#\"\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-struct S;\n-\n-fn f() {\n-    !(S >= S || S > S)\n-}\n-\"#,\n-        );\n-\n-        check_assist(\n-            apply_demorgan,\n-            r#\"\n-//- minicore: ord, derive\n struct S;\n-\n-fn f() {\n-    S < S &&$0 S <= S\n-}\n+fn f() { S < S &&$0 S <= S }\n \"#,\n             r#\"\n struct S;\n-\n-fn f() {\n-    !(!(S < S) || !(S <= S))\n-}\n+fn f() { !(S >= S || S > S) }\n \"#,\n         );\n     }\n@@ -199,39 +168,12 @@ fn f() {\n         check_assist(\n             apply_demorgan,\n             r#\"\n-//- minicore: ord, derive\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-struct S;\n-\n-fn f() {\n-    S > S &&$0 S >= S\n-}\n-\"#,\n-            r#\"\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-struct S;\n-\n-fn f() {\n-    !(S <= S || S < S)\n-}\n-\"#,\n-        );\n-        check_assist(\n-            apply_demorgan,\n-            r#\"\n-//- minicore: ord, derive\n struct S;\n-\n-fn f() {\n-    S > S &&$0 S >= S\n-}\n+fn f() { S > S &&$0 S >= S }\n \"#,\n             r#\"\n struct S;\n-\n-fn f() {\n-    !(!(S > S) || !(S >= S))\n-}\n+fn f() { !(S <= S || S < S) }\n \"#,\n         );\n     }"}, {"sha": "5adb3f5a1b3cccf9eaf357d3e00dd4a768cf8cd7", "filename": "crates/ide_assists/src/handlers/convert_bool_then.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn convert_if_to_bool_then(acc: &mut Assists, ctx: &AssistContext) ->\n                 e => e,\n             };\n \n-            let cond = if invert_cond { invert_boolean_expression(&ctx.sema, cond) } else { cond };\n+            let cond = if invert_cond { invert_boolean_expression(cond) } else { cond };\n             let arg_list = make::arg_list(Some(make::expr_closure(None, closure_body)));\n             let mcall = make::expr_method_call(cond, make::name_ref(\"then\"), arg_list);\n             builder.replace(target, mcall.to_string());"}, {"sha": "1b3fa898bb71491abcf95baca074c67136a3b513", "filename": "crates/ide_assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -115,7 +115,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                     let new_expr = {\n                         let then_branch =\n                             make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n-                        let cond = invert_boolean_expression(&ctx.sema, cond_expr);\n+                        let cond = invert_boolean_expression(cond_expr);\n                         make::expr_if(make::condition(cond, None), then_branch, None)\n                             .indent(if_indent_level)\n                     };"}, {"sha": "5e96cec511ccc7a29f36d2065c3e9707bf55b11d", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -892,7 +892,7 @@ fn expr_require_exclusive_access(ctx: &AssistContext, expr: &ast::Expr) -> Optio\n     let parent = expr.syntax().parent()?;\n \n     if let Some(bin_expr) = ast::BinExpr::cast(parent.clone()) {\n-        if bin_expr.op_kind()?.is_assignment() {\n+        if matches!(bin_expr.op_kind()?, ast::BinaryOp::Assignment { .. }) {\n             return Some(bin_expr.lhs()?.syntax() == expr.syntax());\n         }\n         return Some(false);"}, {"sha": "0117b8a84b8744cf131b50aaa928774c2ed0488f", "filename": "crates/ide_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -1,4 +1,4 @@\n-use syntax::ast::{AstNode, BinExpr, BinOp};\n+use syntax::ast::{self, AstNode, BinExpr};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -56,14 +56,19 @@ enum FlipAction {\n     DontFlip,\n }\n \n-impl From<BinOp> for FlipAction {\n-    fn from(op_kind: BinOp) -> Self {\n+impl From<ast::BinaryOp> for FlipAction {\n+    fn from(op_kind: ast::BinaryOp) -> Self {\n         match op_kind {\n-            kind if kind.is_assignment() => FlipAction::DontFlip,\n-            BinOp::GreaterTest => FlipAction::FlipAndReplaceOp(\"<\"),\n-            BinOp::GreaterEqualTest => FlipAction::FlipAndReplaceOp(\"<=\"),\n-            BinOp::LesserTest => FlipAction::FlipAndReplaceOp(\">\"),\n-            BinOp::LesserEqualTest => FlipAction::FlipAndReplaceOp(\">=\"),\n+            ast::BinaryOp::Assignment { .. } => FlipAction::DontFlip,\n+            ast::BinaryOp::CmpOp(ast::CmpOp::Ord { ordering, strict }) => {\n+                let rev_op = match (ordering, strict) {\n+                    (ast::Ordering::Less, true) => \">\",\n+                    (ast::Ordering::Less, false) => \">=\",\n+                    (ast::Ordering::Greater, true) => \"<\",\n+                    (ast::Ordering::Greater, false) => \"<=\",\n+                };\n+                FlipAction::FlipAndReplaceOp(rev_op)\n+            }\n             _ => FlipAction::Flip,\n         }\n     }"}, {"sha": "50845cd9e03e2d8552a8d620b0ca839865e1560e", "filename": "crates/ide_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -47,7 +47,7 @@ pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     };\n \n     acc.add(AssistId(\"invert_if\", AssistKind::RefactorRewrite), \"Invert if\", if_range, |edit| {\n-        let flip_cond = invert_boolean_expression(&ctx.sema, cond.clone());\n+        let flip_cond = invert_boolean_expression(cond.clone());\n         edit.replace_ast(cond, flip_cond);\n \n         let else_node = else_block.syntax();"}, {"sha": "8946ecfac7c7f04eb165a4e1eed8a8ded2de0c03", "filename": "crates/ide_assists/src/handlers/pull_assignment_up.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -39,7 +39,7 @@ pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext) -> Opti\n     let assign_expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n \n     let op_kind = assign_expr.op_kind()?;\n-    if op_kind != ast::BinOp::Assignment {\n+    if op_kind != (ast::BinaryOp::Assignment { op: None }) {\n         cov_mark::hit!(test_cant_pull_non_assignments);\n         return None;\n     }\n@@ -143,7 +143,7 @@ impl<'a> AssignmentsCollector<'a> {\n     }\n \n     fn collect_expr(&mut self, expr: &ast::BinExpr) -> Option<()> {\n-        if expr.op_kind()? == ast::BinOp::Assignment\n+        if expr.op_kind()? == (ast::BinaryOp::Assignment { op: None })\n             && is_equivalent(self.sema, &expr.lhs()?, &self.common_lhs)\n         {\n             self.assignments.push((expr.clone(), expr.rhs()?));\n@@ -173,8 +173,8 @@ fn is_equivalent(\n             }\n         }\n         (ast::Expr::PrefixExpr(prefix0), ast::Expr::PrefixExpr(prefix1))\n-            if prefix0.op_kind() == Some(ast::PrefixOp::Deref)\n-                && prefix1.op_kind() == Some(ast::PrefixOp::Deref) =>\n+            if prefix0.op_kind() == Some(ast::UnaryOp::Deref)\n+                && prefix1.op_kind() == Some(ast::UnaryOp::Deref) =>\n         {\n             cov_mark::hit!(test_pull_assignment_up_deref);\n             if let (Some(prefix0), Some(prefix1)) = (prefix0.expr(), prefix1.expr()) {"}, {"sha": "853c41f78f439c13ef00bb72e3ec496f83918496", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -151,7 +151,7 @@ fn main() {\n \"#####,\n         r#####\"\n fn main() {\n-    if !(x == 4 && !(y < 3.14)) {}\n+    if !(x == 4 && y >= 3.14) {}\n }\n \"#####,\n     )"}, {"sha": "ee81e5048a3e880737b80ddd809247c94cc59e81", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 16, "deletions": 43, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -5,12 +5,8 @@ mod gen_trait_fn_body;\n \n use std::ops;\n \n-use hir::{Adt, HasSource, Semantics};\n-use ide_db::{\n-    helpers::{FamousDefs, SnippetCap},\n-    path_transform::PathTransform,\n-    RootDatabase,\n-};\n+use hir::{Adt, HasSource};\n+use ide_db::{helpers::SnippetCap, path_transform::PathTransform, RootDatabase};\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n@@ -207,30 +203,23 @@ pub(crate) fn vis_offset(node: &SyntaxNode) -> TextSize {\n         .unwrap_or_else(|| node.text_range().start())\n }\n \n-pub(crate) fn invert_boolean_expression(\n-    sema: &Semantics<RootDatabase>,\n-    expr: ast::Expr,\n-) -> ast::Expr {\n-    invert_special_case(sema, &expr).unwrap_or_else(|| make::expr_prefix(T![!], expr))\n+pub(crate) fn invert_boolean_expression(expr: ast::Expr) -> ast::Expr {\n+    invert_special_case(&expr).unwrap_or_else(|| make::expr_prefix(T![!], expr))\n }\n \n-fn invert_special_case(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<ast::Expr> {\n+fn invert_special_case(expr: &ast::Expr) -> Option<ast::Expr> {\n     match expr {\n         ast::Expr::BinExpr(bin) => match bin.op_kind()? {\n-            ast::BinOp::NegatedEqualityTest => bin.replace_op(T![==]).map(|it| it.into()),\n-            ast::BinOp::EqualityTest => bin.replace_op(T![!=]).map(|it| it.into()),\n-            // Swap `<` with `>=`, `<=` with `>`, ... if operands `impl Ord`\n-            ast::BinOp::LesserTest if bin_impls_ord(sema, bin) => {\n-                bin.replace_op(T![>=]).map(|it| it.into())\n-            }\n-            ast::BinOp::LesserEqualTest if bin_impls_ord(sema, bin) => {\n-                bin.replace_op(T![>]).map(|it| it.into())\n-            }\n-            ast::BinOp::GreaterTest if bin_impls_ord(sema, bin) => {\n-                bin.replace_op(T![<=]).map(|it| it.into())\n-            }\n-            ast::BinOp::GreaterEqualTest if bin_impls_ord(sema, bin) => {\n-                bin.replace_op(T![<]).map(|it| it.into())\n+            ast::BinaryOp::CmpOp(op) => {\n+                let rev_op = match op {\n+                    ast::CmpOp::Eq { negated: false } => T![!=],\n+                    ast::CmpOp::Eq { negated: true } => T![==],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Less, strict: true } => T![>=],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Less, strict: false } => T![>],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Greater, strict: true } => T![<=],\n+                    ast::CmpOp::Ord { ordering: ast::Ordering::Greater, strict: false } => T![<],\n+                };\n+                bin.replace_op(rev_op).map(ast::Expr::from)\n             }\n             // Parenthesize other expressions before prefixing `!`\n             _ => Some(make::expr_prefix(T![!], make::expr_paren(expr.clone()))),\n@@ -249,7 +238,7 @@ fn invert_special_case(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Opti\n             };\n             Some(make::expr_method_call(receiver, make::name_ref(method), arg_list))\n         }\n-        ast::Expr::PrefixExpr(pe) if pe.op_kind()? == ast::PrefixOp::Not => {\n+        ast::Expr::PrefixExpr(pe) if pe.op_kind()? == ast::UnaryOp::Not => {\n             if let ast::Expr::ParenExpr(parexpr) = pe.expr()? {\n                 parexpr.expr()\n             } else {\n@@ -267,22 +256,6 @@ fn invert_special_case(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Opti\n     }\n }\n \n-fn bin_impls_ord(sema: &Semantics<RootDatabase>, bin: &ast::BinExpr) -> bool {\n-    match (\n-        bin.lhs().and_then(|lhs| sema.type_of_expr(&lhs)).map(hir::TypeInfo::adjusted),\n-        bin.rhs().and_then(|rhs| sema.type_of_expr(&rhs)).map(hir::TypeInfo::adjusted),\n-    ) {\n-        (Some(lhs_ty), Some(rhs_ty)) if lhs_ty == rhs_ty => {\n-            let krate = sema.scope(bin.syntax()).module().map(|it| it.krate());\n-            let ord_trait = FamousDefs(sema, krate).core_cmp_Ord();\n-            ord_trait.map_or(false, |ord_trait| {\n-                lhs_ty.autoderef(sema.db).any(|ty| ty.impls_trait(sema.db, ord_trait, &[]))\n-            })\n-        }\n-        _ => false,\n-    }\n-}\n-\n pub(crate) fn next_prev() -> impl Iterator<Item = Direction> {\n     [Direction::Next, Direction::Prev].iter().copied()\n }"}, {"sha": "5a8914b3316ea454c2341bb3bdeefc9f9c0d4b2b", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -1,7 +1,7 @@\n //! This module contains functions to generate default trait impl function bodies where possible.\n \n use syntax::{\n-    ast::{self, edit::AstNodeEdit, make, AstNode, NameOwner},\n+    ast::{self, edit::AstNodeEdit, make, AstNode, BinaryOp, CmpOp, LogicOp, NameOwner},\n     ted,\n };\n \n@@ -325,7 +325,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n         match expr {\n-            Some(expr) => Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp)),\n+            Some(expr) => Some(make::expr_bin_op(expr, BinaryOp::LogicOp(LogicOp::And), cmp)),\n             None => Some(cmp),\n         }\n     }\n@@ -362,7 +362,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let lhs = make::expr_call(make_discriminant()?, make::arg_list(Some(lhs_name.clone())));\n             let rhs_name = make::expr_path(make::ext::ident_path(\"other\"));\n             let rhs = make::expr_call(make_discriminant()?, make::arg_list(Some(rhs_name.clone())));\n-            let eq_check = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+            let eq_check =\n+                make::expr_bin_op(lhs, BinaryOp::CmpOp(CmpOp::Eq { negated: false }), rhs);\n \n             let mut case_count = 0;\n             let mut arms = vec![];\n@@ -386,7 +387,11 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n                             let lhs = make::expr_path(make::ext::ident_path(l_name));\n                             let rhs = make::expr_path(make::ext::ident_path(r_name));\n-                            let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                            let cmp = make::expr_bin_op(\n+                                lhs,\n+                                BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+                                rhs,\n+                            );\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n@@ -415,7 +420,11 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n                             let lhs = make::expr_path(make::ext::ident_path(&l_name));\n                             let rhs = make::expr_path(make::ext::ident_path(&r_name));\n-                            let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                            let cmp = make::expr_bin_op(\n+                                lhs,\n+                                BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+                                rhs,\n+                            );\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n@@ -455,7 +464,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let lhs = make::expr_field(lhs, &field.name()?.to_string());\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n                     let rhs = make::expr_field(rhs, &field.name()?.to_string());\n-                    let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                    let cmp =\n+                        make::expr_bin_op(lhs, BinaryOp::CmpOp(CmpOp::Eq { negated: false }), rhs);\n                     expr = gen_eq_chain(expr, cmp);\n                 }\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n@@ -469,7 +479,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n                     let rhs = make::expr_field(rhs, &idx);\n-                    let cmp = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n+                    let cmp =\n+                        make::expr_bin_op(lhs, BinaryOp::CmpOp(CmpOp::Eq { negated: false }), rhs);\n                     expr = gen_eq_chain(expr, cmp);\n                 }\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))"}, {"sha": "17db6d3c19dedd1acd0531bfbcd9263f99ac0f05", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -110,7 +110,7 @@ pub(crate) fn for_variable(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>)\n             }\n             ast::Expr::ParenExpr(inner) => next_expr = inner.expr(),\n             ast::Expr::TryExpr(inner) => next_expr = inner.expr(),\n-            ast::Expr::PrefixExpr(prefix) if prefix.op_kind() == Some(ast::PrefixOp::Deref) => {\n+            ast::Expr::PrefixExpr(prefix) if prefix.op_kind() == Some(ast::UnaryOp::Deref) => {\n                 next_expr = prefix.expr()\n             }\n             _ => break,"}, {"sha": "627f5e97fa734a5292e74b6b89db26ac37b87293", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -655,7 +655,7 @@ fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<Referen\n         match_ast! {\n             match (node) {\n                 ast::BinExpr(expr) => {\n-                    if expr.op_kind()?.is_assignment() {\n+                    if matches!(expr.op_kind()?, ast::BinaryOp::Assignment { .. }) {\n                         // If the variable or field ends on the LHS's end then it's a Write (covers fields and locals).\n                         // FIXME: This is not terribly accurate.\n                         if let Some(lhs) = expr.lhs() {"}, {"sha": "e26c5b7ad90f8de78c9847528b3ebe8753db4319", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -5,6 +5,7 @@ mod traits;\n mod token_ext;\n mod node_ext;\n mod expr_ext;\n+mod operators;\n pub mod edit;\n pub mod edit_in_place;\n pub mod make;\n@@ -17,14 +18,21 @@ use crate::{\n };\n \n pub use self::{\n-    expr_ext::{ArrayExprKind, BinOp, Effect, ElseBranch, LiteralKind, PrefixOp, RangeOp},\n+    expr_ext::{ArrayExprKind, Effect, ElseBranch, LiteralKind},\n     generated::{nodes::*, tokens::*},\n     node_ext::{\n         AttrKind, AttrsOwnerNode, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind,\n         SelfParamKind, SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n     },\n-    token_ext::*,\n-    traits::*,\n+    operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n+    token_ext::{\n+        CommentKind, CommentPlacement, CommentShape, FormatSpecifier, HasFormatSpecifier, IsString,\n+        QuoteOffsets, Radix,\n+    },\n+    traits::{\n+        ArgListOwner, AttrsOwner, CommentIter, DocCommentsOwner, GenericParamsOwner, LoopBodyOwner,\n+        ModuleItemOwner, NameOwner, TypeBoundsOwner, VisibilityOwner,\n+    },\n };\n \n /// The main trait to go from untyped `SyntaxNode`  to a typed ast. The"}, {"sha": "4598066bc93a907fa9e41cf239de09dca874d026", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 49, "deletions": 174, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -3,7 +3,11 @@\n use rowan::WalkEvent;\n \n use crate::{\n-    ast::{self, support, AstChildren, AstNode},\n+    ast::{\n+        self,\n+        operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n+        support, AstChildren, AstNode,\n+    },\n     AstToken,\n     SyntaxKind::*,\n     SyntaxToken, T,\n@@ -193,152 +197,67 @@ impl ast::IfExpr {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum PrefixOp {\n-    /// The `*` operator for dereferencing\n-    Deref,\n-    /// The `!` operator for logical inversion\n-    Not,\n-    /// The `-` operator for negation\n-    Neg,\n-}\n-\n impl ast::PrefixExpr {\n-    pub fn op_kind(&self) -> Option<PrefixOp> {\n-        match self.op_token()?.kind() {\n-            T![*] => Some(PrefixOp::Deref),\n-            T![!] => Some(PrefixOp::Not),\n-            T![-] => Some(PrefixOp::Neg),\n-            _ => None,\n-        }\n+    pub fn op_kind(&self) -> Option<UnaryOp> {\n+        let res = match self.op_token()?.kind() {\n+            T![*] => UnaryOp::Deref,\n+            T![!] => UnaryOp::Not,\n+            T![-] => UnaryOp::Neg,\n+            _ => return None,\n+        };\n+        Some(res)\n     }\n \n     pub fn op_token(&self) -> Option<SyntaxToken> {\n         self.syntax().first_child_or_token()?.into_token()\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum BinOp {\n-    /// The `||` operator for boolean OR\n-    BooleanOr,\n-    /// The `&&` operator for boolean AND\n-    BooleanAnd,\n-    /// The `==` operator for equality testing\n-    EqualityTest,\n-    /// The `!=` operator for equality testing\n-    NegatedEqualityTest,\n-    /// The `<=` operator for lesser-equal testing\n-    LesserEqualTest,\n-    /// The `>=` operator for greater-equal testing\n-    GreaterEqualTest,\n-    /// The `<` operator for comparison\n-    LesserTest,\n-    /// The `>` operator for comparison\n-    GreaterTest,\n-    /// The `+` operator for addition\n-    Addition,\n-    /// The `*` operator for multiplication\n-    Multiplication,\n-    /// The `-` operator for subtraction\n-    Subtraction,\n-    /// The `/` operator for division\n-    Division,\n-    /// The `%` operator for remainder after division\n-    Remainder,\n-    /// The `<<` operator for left shift\n-    LeftShift,\n-    /// The `>>` operator for right shift\n-    RightShift,\n-    /// The `^` operator for bitwise XOR\n-    BitwiseXor,\n-    /// The `|` operator for bitwise OR\n-    BitwiseOr,\n-    /// The `&` operator for bitwise AND\n-    BitwiseAnd,\n-    /// The `=` operator for assignment\n-    Assignment,\n-    /// The `+=` operator for assignment after addition\n-    AddAssign,\n-    /// The `/=` operator for assignment after division\n-    DivAssign,\n-    /// The `*=` operator for assignment after multiplication\n-    MulAssign,\n-    /// The `%=` operator for assignment after remainders\n-    RemAssign,\n-    /// The `>>=` operator for assignment after shifting right\n-    ShrAssign,\n-    /// The `<<=` operator for assignment after shifting left\n-    ShlAssign,\n-    /// The `-=` operator for assignment after subtraction\n-    SubAssign,\n-    /// The `|=` operator for assignment after bitwise OR\n-    BitOrAssign,\n-    /// The `&=` operator for assignment after bitwise AND\n-    BitAndAssign,\n-    /// The `^=` operator for assignment after bitwise XOR\n-    BitXorAssign,\n-}\n-\n-impl BinOp {\n-    pub fn is_assignment(self) -> bool {\n-        matches!(\n-            self,\n-            BinOp::Assignment\n-                | BinOp::AddAssign\n-                | BinOp::DivAssign\n-                | BinOp::MulAssign\n-                | BinOp::RemAssign\n-                | BinOp::ShrAssign\n-                | BinOp::ShlAssign\n-                | BinOp::SubAssign\n-                | BinOp::BitOrAssign\n-                | BinOp::BitAndAssign\n-                | BinOp::BitXorAssign\n-        )\n-    }\n-}\n-\n impl ast::BinExpr {\n-    pub fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n+    pub fn op_details(&self) -> Option<(SyntaxToken, BinaryOp)> {\n         self.syntax().children_with_tokens().filter_map(|it| it.into_token()).find_map(|c| {\n+            #[rustfmt::skip]\n             let bin_op = match c.kind() {\n-                T![||] => BinOp::BooleanOr,\n-                T![&&] => BinOp::BooleanAnd,\n-                T![==] => BinOp::EqualityTest,\n-                T![!=] => BinOp::NegatedEqualityTest,\n-                T![<=] => BinOp::LesserEqualTest,\n-                T![>=] => BinOp::GreaterEqualTest,\n-                T![<] => BinOp::LesserTest,\n-                T![>] => BinOp::GreaterTest,\n-                T![+] => BinOp::Addition,\n-                T![*] => BinOp::Multiplication,\n-                T![-] => BinOp::Subtraction,\n-                T![/] => BinOp::Division,\n-                T![%] => BinOp::Remainder,\n-                T![<<] => BinOp::LeftShift,\n-                T![>>] => BinOp::RightShift,\n-                T![^] => BinOp::BitwiseXor,\n-                T![|] => BinOp::BitwiseOr,\n-                T![&] => BinOp::BitwiseAnd,\n-                T![=] => BinOp::Assignment,\n-                T![+=] => BinOp::AddAssign,\n-                T![/=] => BinOp::DivAssign,\n-                T![*=] => BinOp::MulAssign,\n-                T![%=] => BinOp::RemAssign,\n-                T![>>=] => BinOp::ShrAssign,\n-                T![<<=] => BinOp::ShlAssign,\n-                T![-=] => BinOp::SubAssign,\n-                T![|=] => BinOp::BitOrAssign,\n-                T![&=] => BinOp::BitAndAssign,\n-                T![^=] => BinOp::BitXorAssign,\n+                T![||] => BinaryOp::LogicOp(LogicOp::Or),\n+                T![&&] => BinaryOp::LogicOp(LogicOp::And),\n+\n+                T![==] => BinaryOp::CmpOp(CmpOp::Eq { negated: false }),\n+                T![!=] => BinaryOp::CmpOp(CmpOp::Eq { negated: true }),\n+                T![<=] => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less,    strict: false }),\n+                T![>=] => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: false }),\n+                T![<]  => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Less,    strict: true }),\n+                T![>]  => BinaryOp::CmpOp(CmpOp::Ord { ordering: Ordering::Greater, strict: true }),\n+\n+                T![+]  => BinaryOp::ArithOp(ArithOp::Add),\n+                T![*]  => BinaryOp::ArithOp(ArithOp::Mul),\n+                T![-]  => BinaryOp::ArithOp(ArithOp::Sub),\n+                T![/]  => BinaryOp::ArithOp(ArithOp::Div),\n+                T![%]  => BinaryOp::ArithOp(ArithOp::Rem),\n+                T![<<] => BinaryOp::ArithOp(ArithOp::Shl),\n+                T![>>] => BinaryOp::ArithOp(ArithOp::Shr),\n+                T![^]  => BinaryOp::ArithOp(ArithOp::BitXor),\n+                T![|]  => BinaryOp::ArithOp(ArithOp::BitOr),\n+                T![&]  => BinaryOp::ArithOp(ArithOp::BitAnd),\n+\n+                T![=]   => BinaryOp::Assignment { op: None },\n+                T![+=]  => BinaryOp::Assignment { op: Some(ArithOp::Add) },\n+                T![*=]  => BinaryOp::Assignment { op: Some(ArithOp::Mul) },\n+                T![-=]  => BinaryOp::Assignment { op: Some(ArithOp::Sub) },\n+                T![/=]  => BinaryOp::Assignment { op: Some(ArithOp::Div) },\n+                T![%=]  => BinaryOp::Assignment { op: Some(ArithOp::Rem) },\n+                T![<<=] => BinaryOp::Assignment { op: Some(ArithOp::Shl) },\n+                T![>>=] => BinaryOp::Assignment { op: Some(ArithOp::Shr) },\n+                T![^=]  => BinaryOp::Assignment { op: Some(ArithOp::BitXor) },\n+                T![|=]  => BinaryOp::Assignment { op: Some(ArithOp::BitOr) },\n+                T![&=]  => BinaryOp::Assignment { op: Some(ArithOp::BitAnd) },\n+\n                 _ => return None,\n             };\n             Some((c, bin_op))\n         })\n     }\n \n-    pub fn op_kind(&self) -> Option<BinOp> {\n+    pub fn op_kind(&self) -> Option<BinaryOp> {\n         self.op_details().map(|t| t.1)\n     }\n \n@@ -362,50 +281,6 @@ impl ast::BinExpr {\n     }\n }\n \n-impl std::fmt::Display for BinOp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            BinOp::BooleanOr => write!(f, \"||\"),\n-            BinOp::BooleanAnd => write!(f, \"&&\"),\n-            BinOp::EqualityTest => write!(f, \"==\"),\n-            BinOp::NegatedEqualityTest => write!(f, \"!=\"),\n-            BinOp::LesserEqualTest => write!(f, \"<=\"),\n-            BinOp::GreaterEqualTest => write!(f, \">=\"),\n-            BinOp::LesserTest => write!(f, \"<\"),\n-            BinOp::GreaterTest => write!(f, \">\"),\n-            BinOp::Addition => write!(f, \"+\"),\n-            BinOp::Multiplication => write!(f, \"*\"),\n-            BinOp::Subtraction => write!(f, \"-\"),\n-            BinOp::Division => write!(f, \"/\"),\n-            BinOp::Remainder => write!(f, \"%\"),\n-            BinOp::LeftShift => write!(f, \"<<\"),\n-            BinOp::RightShift => write!(f, \">>\"),\n-            BinOp::BitwiseXor => write!(f, \"^\"),\n-            BinOp::BitwiseOr => write!(f, \"|\"),\n-            BinOp::BitwiseAnd => write!(f, \"&\"),\n-            BinOp::Assignment => write!(f, \"=\"),\n-            BinOp::AddAssign => write!(f, \"+=\"),\n-            BinOp::DivAssign => write!(f, \"/=\"),\n-            BinOp::MulAssign => write!(f, \"*=\"),\n-            BinOp::RemAssign => write!(f, \"%=\"),\n-            BinOp::ShrAssign => write!(f, \">>=\"),\n-            BinOp::ShlAssign => write!(f, \"<<=\"),\n-            BinOp::SubAssign => write!(f, \"-\"),\n-            BinOp::BitOrAssign => write!(f, \"|=\"),\n-            BinOp::BitAndAssign => write!(f, \"&=\"),\n-            BinOp::BitXorAssign => write!(f, \"^=\"),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum RangeOp {\n-    /// `..`\n-    Exclusive,\n-    /// `..=`\n-    Inclusive,\n-}\n-\n impl ast::RangeExpr {\n     fn op_details(&self) -> Option<(usize, SyntaxToken, RangeOp)> {\n         self.syntax().children_with_tokens().enumerate().find_map(|(ix, child)| {"}, {"sha": "5494dd1d3e8685c50e85e31498534ffb2ad7cf3b", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -276,7 +276,8 @@ pub fn expr_path(path: ast::Path) -> ast::Expr {\n pub fn expr_continue() -> ast::Expr {\n     expr_from_text(\"continue\")\n }\n-pub fn expr_op(op: ast::BinOp, lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n+// Consider `op: SyntaxKind` instead for nicer syntax at the call-site?\n+pub fn expr_bin_op(lhs: ast::Expr, op: ast::BinaryOp, rhs: ast::Expr) -> ast::Expr {\n     expr_from_text(&format!(\"{} {} {}\", lhs, op, rhs))\n }\n pub fn expr_break(expr: Option<ast::Expr>) -> ast::Expr {"}, {"sha": "a687ba0b77a56760a6a9dcb4f51b102b9be75535", "filename": "crates/syntax/src/ast/operators.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2219bd996697bceacb8a2bff8f2f5d3ec93780/crates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs?ref=bd2219bd996697bceacb8a2bff8f2f5d3ec93780", "patch": "@@ -0,0 +1,122 @@\n+//! Defines a bunch of data-less enums for unary and binary operators.\n+//!\n+//! Types here don't know about AST, this allows re-using them for both AST and\n+//! HIR.\n+use std::fmt;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum RangeOp {\n+    /// `..`\n+    Exclusive,\n+    /// `..=`\n+    Inclusive,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum UnaryOp {\n+    /// `*`\n+    Deref,\n+    /// `!`\n+    Not,\n+    /// `-`\n+    Neg,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum BinaryOp {\n+    LogicOp(LogicOp),\n+    ArithOp(ArithOp),\n+    CmpOp(CmpOp),\n+    Assignment { op: Option<ArithOp> },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LogicOp {\n+    And,\n+    Or,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CmpOp {\n+    Eq { negated: bool },\n+    Ord { ordering: Ordering, strict: bool },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum Ordering {\n+    Less,\n+    Greater,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ArithOp {\n+    Add,\n+    Mul,\n+    Sub,\n+    Div,\n+    Rem,\n+    Shl,\n+    Shr,\n+    BitXor,\n+    BitOr,\n+    BitAnd,\n+}\n+\n+impl fmt::Display for LogicOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let res = match self {\n+            LogicOp::And => \"&&\",\n+            LogicOp::Or => \"||\",\n+        };\n+        f.write_str(res)\n+    }\n+}\n+\n+impl fmt::Display for ArithOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let res = match self {\n+            ArithOp::Add => \"+\",\n+            ArithOp::Mul => \"*\",\n+            ArithOp::Sub => \"-\",\n+            ArithOp::Div => \"/\",\n+            ArithOp::Rem => \"%\",\n+            ArithOp::Shl => \"<<\",\n+            ArithOp::Shr => \">>\",\n+            ArithOp::BitXor => \"^\",\n+            ArithOp::BitOr => \"|\",\n+            ArithOp::BitAnd => \"&\",\n+        };\n+        f.write_str(res)\n+    }\n+}\n+\n+impl fmt::Display for CmpOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let res = match self {\n+            CmpOp::Eq { negated: false } => \"==\",\n+            CmpOp::Eq { negated: true } => \"!=\",\n+            CmpOp::Ord { ordering: Ordering::Less, strict: false } => \"<=\",\n+            CmpOp::Ord { ordering: Ordering::Less, strict: true } => \"<\",\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: false } => \">=\",\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: true } => \">\",\n+        };\n+        f.write_str(res)\n+    }\n+}\n+\n+impl fmt::Display for BinaryOp {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            BinaryOp::LogicOp(op) => fmt::Display::fmt(op, f),\n+            BinaryOp::ArithOp(op) => fmt::Display::fmt(op, f),\n+            BinaryOp::CmpOp(op) => fmt::Display::fmt(op, f),\n+            BinaryOp::Assignment { op } => {\n+                f.write_str(\"=\")?;\n+                if let Some(op) = op {\n+                    fmt::Display::fmt(op, f)?;\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}"}]}