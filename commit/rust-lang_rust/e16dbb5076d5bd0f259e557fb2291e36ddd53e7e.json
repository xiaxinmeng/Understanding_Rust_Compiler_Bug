{"sha": "e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "node_id": "C_kwDOAAsO6NoAKGUxNmRiYjUwNzZkNWJkMGYyNTllNTU3ZmIyMjkxZTM2ZGRkNTNlN2U", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-06-26T15:08:58Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-06-28T04:17:40Z"}, "message": "Make empty bounds lower to WellFormed and make WellFormed coinductive", "tree": {"sha": "16dcaa176e95dbb2e0c372656e12796949ac09f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16dcaa176e95dbb2e0c372656e12796949ac09f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "html_url": "https://github.com/rust-lang/rust/commit/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e430bfa9a6a9d81b25bddf6325069d217dc6f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e430bfa9a6a9d81b25bddf6325069d217dc6f3f", "html_url": "https://github.com/rust-lang/rust/commit/8e430bfa9a6a9d81b25bddf6325069d217dc6f3f"}], "stats": {"total": 126, "additions": 100, "deletions": 26}, "files": [{"sha": "cd40f6a2cf0c35d45049179a85ee499e62ef046b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -145,6 +145,7 @@ where\n                 }\n                 ControlFlow::CONTINUE\n             }\n+            ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }"}, {"sha": "f33864024b0adab6f791752abe2093265fef18c9", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -488,20 +488,70 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n-                    self.infcx,\n-                    obligation.param_env,\n-                    obligation.cause.body_id,\n-                    obligation.recursion_depth + 1,\n-                    arg,\n-                    obligation.cause.span,\n-                ) {\n-                    Some(mut obligations) => {\n-                        self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                        self.evaluate_predicates_recursively(previous_stack, obligations)\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    // So, there is a bit going on here. First, `WellFormed` predicates\n+                    // are coinductive, like trait predicates with auto traits.\n+                    // This means that we need to detect if we have recursively\n+                    // evaluated `WellFormed(X)`. Otherwise, we would run into\n+                    // a \"natural\" overflow error.\n+                    //\n+                    // Now, the next question is whether we need to do anything\n+                    // special with caching. Considering the following tree:\n+                    // - `WF(Foo<T>)`\n+                    //   - `Bar<T>: Send`\n+                    //     - `WF(Foo<T>)`\n+                    //   - `Foo<T>: Trait`\n+                    // In this case, the innermost `WF(Foo<T>)` should return\n+                    // `EvaluatedToOk`, since it's coinductive. Then if\n+                    // `Bar<T>: Send` is resolved to `EvaluatedToOk`, it can be\n+                    // inserted into a cache (because without thinking about `WF`\n+                    // goals, it isn't in a cycle). If `Foo<T>: Trait` later doesn't\n+                    // hold, then `Bar<T>: Send` shouldn't hold. Therefore, we\n+                    // *do* need to keep track of coinductive cycles.\n+\n+                    let cache = previous_stack.cache;\n+                    let dfn = cache.next_dfn();\n+\n+                    for stack_arg in previous_stack.cache.wf_tys.borrow().iter().rev() {\n+                        if stack_arg.0 != arg {\n+                            continue;\n+                        }\n+                        debug!(\"WellFormed({:?}) on stack\", arg);\n+                        if let Some(stack) = previous_stack.head {\n+                            stack.update_reached_depth(stack_arg.1);\n+                        }\n+                        return Ok(EvaluatedToOk);\n+                    }\n+\n+                    match wf::obligations(\n+                        self.infcx,\n+                        obligation.param_env,\n+                        obligation.cause.body_id,\n+                        obligation.recursion_depth + 1,\n+                        arg,\n+                        obligation.cause.span,\n+                    ) {\n+                        Some(mut obligations) => {\n+                            self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+\n+                            cache.wf_tys.borrow_mut().push((arg, previous_stack.depth()));\n+                            let result =\n+                                self.evaluate_predicates_recursively(previous_stack, obligations);\n+                            cache.wf_tys.borrow_mut().pop();\n+\n+                            let result = result?;\n+\n+                            if !result.must_apply_modulo_regions() {\n+                                cache.on_failure(dfn);\n+                            }\n+\n+                            cache.on_completion(dfn);\n+\n+                            Ok(result)\n+                        }\n+                        None => Ok(EvaluatedToAmbig),\n                     }\n-                    None => Ok(EvaluatedToAmbig),\n-                },\n+                }\n \n                 ty::PredicateKind::TypeOutlives(pred) => {\n                     // A global type with no late-bound regions can only\n@@ -718,6 +768,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?fresh_trait_pred);\n \n+        // If a trait predicate is in the (local or global) evaluation cache,\n+        // then we know it holds without cycles.\n         if let Some(result) = self.check_evaluation_cache(param_env, fresh_trait_pred) {\n             debug!(?result, \"CACHE HIT\");\n             return Ok(result);\n@@ -921,7 +973,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// - it also appears in the backtrace at some position `X`,\n     /// - all the predicates at positions `X..` between `X` and the top are\n     ///   also defaulted traits.\n-    pub fn coinductive_match<I>(&mut self, mut cycle: I) -> bool\n+    pub(crate) fn coinductive_match<I>(&mut self, mut cycle: I) -> bool\n     where\n         I: Iterator<Item = ty::Predicate<'tcx>>,\n     {\n@@ -931,6 +983,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate.kind().skip_binder() {\n             ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_auto(data.def_id()),\n+            ty::PredicateKind::WellFormed(_) => true,\n             _ => false,\n         };\n         debug!(?predicate, ?result, \"coinductive_predicate\");\n@@ -2411,6 +2464,8 @@ struct ProvisionalEvaluationCache<'tcx> {\n     ///   all cache values whose DFN is >= 4 -- in this case, that\n     ///   means the cached value for `F`.\n     map: RefCell<FxHashMap<ty::PolyTraitPredicate<'tcx>, ProvisionalEvaluation>>,\n+\n+    wf_tys: RefCell<Vec<(ty::GenericArg<'tcx>, usize)>>,\n }\n \n /// A cache value for the provisional cache: contains the depth-first\n@@ -2424,7 +2479,7 @@ struct ProvisionalEvaluation {\n \n impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {\n     fn default() -> Self {\n-        Self { dfn: Cell::new(0), map: Default::default() }\n+        Self { dfn: Cell::new(0), map: Default::default(), wf_tys: Default::default() }\n     }\n }\n "}, {"sha": "2453d3a692aa16f69eb0617e5798604133e32a96", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -106,8 +106,16 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 ty::PredicateKind::Projection(predicate) => chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n                 ),\n-                ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n+                ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+                    ty::GenericArgKind::Type(ty) => chalk_ir::DomainGoal::WellFormed(\n+                        chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                    ),\n+                    // FIXME(chalk): we need to change `WellFormed` in Chalk to take a `GenericArg`\n+                    _ => chalk_ir::DomainGoal::WellFormed(chalk_ir::WellFormed::Ty(\n+                        interner.tcx.types.unit.lower_into(interner),\n+                    )),\n+                },\n+                ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)"}, {"sha": "ae48211d52ddba8587534fbf7992f24c4d552236", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -44,16 +44,21 @@ fn compute_implied_outlives_bounds<'tcx>(\n \n     // Sometimes when we ask what it takes for T: WF, we get back that\n     // U: WF is required; in that case, we push U onto this stack and\n-    // process it next. Currently (at least) these resulting\n-    // predicates are always guaranteed to be a subset of the original\n-    // type, so we need not fear non-termination.\n+    // process it next. Because the resulting predicates aren't always\n+    // guaranteed to be a subset of the original type, so we need to store the\n+    // WF args we've computed in a set.\n+    let mut checked_wf_args = rustc_data_structures::stable_set::FxHashSet::default();\n     let mut wf_args = vec![ty.into()];\n \n     let mut implied_bounds = vec![];\n \n     let mut fulfill_cx = FulfillmentContext::new();\n \n     while let Some(arg) = wf_args.pop() {\n+        if !checked_wf_args.insert(arg) {\n+            continue;\n+        }\n+\n         // Compute the obligations for `arg` to be well-formed. If `arg` is\n         // an unresolved inference variable, just substituted an empty set\n         // -- because the return type here is going to be things we *add*"}, {"sha": "ed3b9f2db1f8e88ac1972fd7b60027d87b462806", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -206,6 +206,9 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                     relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n                         && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()\n                 }\n+                (ty::PredicateKind::WellFormed(arg_a), ty::PredicateKind::WellFormed(arg_b)) => {\n+                    relator.relate(predicate.rebind(arg_a), p.rebind(arg_b)).is_ok()\n+                }\n                 _ => predicate == p,\n             }\n         };"}, {"sha": "9a43719cac539ec094537b8ecf2fcf491ccc952b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -1807,6 +1807,12 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, mut span: Span, id: hir::HirI\n     let implied_obligations = traits::elaborate_predicates_with_span(fcx.tcx, predicates_with_span);\n \n     for obligation in implied_obligations {\n+        // We lower empty bounds like `Vec<dyn Copy>:` as\n+        // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n+        // regular WF checking\n+        if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n+            continue;\n+        }\n         let pred = obligation.predicate;\n         // Match the existing behavior.\n         if pred.is_global() && !pred.has_late_bound_regions() {"}, {"sha": "696d8db4e2094211db3ba9d15c1db6008c353ea1", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -2264,12 +2264,8 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n-                        let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::Binder::bind_with_vars(\n-                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                ty,\n-                                re_root_empty,\n-                            )),\n+                            ty::PredicateKind::WellFormed(ty.into()),\n                             bound_vars,\n                         );\n                         predicates.insert((predicate.to_predicate(tcx), span));"}, {"sha": "15cb875c60c2d650021a910f911f559233879b63", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16dbb5076d5bd0f259e557fb2291e36ddd53e7e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e16dbb5076d5bd0f259e557fb2291e36ddd53e7e", "patch": "@@ -288,10 +288,10 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::Predicate<'tcx> {\n             ty::PredicateKind::TypeOutlives(pred) => pred.clean(cx),\n             ty::PredicateKind::Projection(pred) => Some(pred.clean(cx)),\n             ty::PredicateKind::ConstEvaluatable(..) => None,\n+            ty::PredicateKind::WellFormed(..) => None,\n \n             ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::ConstEquate(..)"}]}