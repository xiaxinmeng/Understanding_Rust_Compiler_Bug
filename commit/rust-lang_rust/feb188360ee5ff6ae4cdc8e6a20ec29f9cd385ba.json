{"sha": "feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYjE4ODM2MGVlNWZmNmFlNGNkYzhlNmEyMGVjMjlmOWNkMzg1YmE=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-24T22:16:24Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Unify TLS dtors; move stepping outside.", "tree": {"sha": "59fe2fff56112fbb86087f84ca5b0e1e6ff965c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59fe2fff56112fbb86087f84ca5b0e1e6ff965c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "html_url": "https://github.com/rust-lang/rust/commit/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/comments", "author": null, "committer": null, "parents": [{"sha": "8240ed26a97a6d1642546e56144870305ff4676c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8240ed26a97a6d1642546e56144870305ff4676c", "html_url": "https://github.com/rust-lang/rust/commit/8240ed26a97a6d1642546e56144870305ff4676c"}], "stats": {"total": 159, "additions": 110, "deletions": 49}, "files": [{"sha": "9131946f8dc16b579b3107f0fb49ff0b23f4cc76", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "patch": "@@ -211,20 +211,15 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n                 }\n                 SchedulingAction::ExecuteDtors => {\n-                    ecx.run_tls_dtors_for_active_thread()?;\n+                    ecx.schedule_tls_dtors_for_active_thread()?;\n                 }\n                 SchedulingAction::Stop => {\n                     break;\n                 }\n             }\n             ecx.process_diagnostics();\n         }\n-        // Read the return code pointer *before* we run TLS destructors, to assert\n-        // that it was written to by the time that `start` lang item returned.\n         let return_code = ecx.read_scalar(ret_place.into())?.not_undef()?.to_machine_isize(&ecx)?;\n-        // Run Windows destructors. (We do not support concurrency on Windows\n-        // yet, so we run the destructor of the main thread separately.)\n-        ecx.run_windows_tls_dtors()?;\n         Ok(return_code)\n     })();\n "}, {"sha": "615950621a2476709e9fa7dea702cd4bd721b922", "filename": "src/shims/tls.rs", "status": "modified", "additions": 69, "deletions": 43, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "patch": "@@ -38,6 +38,9 @@ pub struct TlsData<'tcx> {\n \n     /// Whether we are in the \"destruct\" phase, during which some operations are UB.\n     dtors_running: HashSet<ThreadId>,\n+\n+    /// The last TlsKey used to retrieve a TLS destructor.\n+    last_dtor_key: BTreeMap<ThreadId, TlsKey>,\n }\n \n impl<'tcx> Default for TlsData<'tcx> {\n@@ -47,6 +50,7 @@ impl<'tcx> Default for TlsData<'tcx> {\n             keys: Default::default(),\n             global_dtors: Default::default(),\n             dtors_running: Default::default(),\n+            last_dtor_key: Default::default(),\n         }\n     }\n }\n@@ -187,21 +191,15 @@ impl<'tcx> TlsData<'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-\n-    /// Run TLS destructors for the main thread on Windows. The implementation\n-    /// assumes that we do not support concurrency on Windows yet.\n-    ///\n-    /// Note: on non-Windows OS this function is a no-op.\n-    fn run_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Schedule TLS destructors for the main thread on Windows. The\n+    /// implementation assumes that we do not support concurrency on Windows\n+    /// yet.\n+    fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if this.tcx.sess.target.target.target_os != \"windows\" {\n-            return Ok(());\n-        }\n         let active_thread = this.get_active_thread()?;\n         assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n-        assert!(!this.machine.tls.dtors_running.contains(&active_thread), \"running TLS dtors twice\");\n         this.machine.tls.dtors_running.insert(active_thread);\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n@@ -221,30 +219,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n-        // step until out of stackframes\n-        this.run()?;\n-\n-        // Windows doesn't have other destructors.\n+        this.enable_thread(active_thread)?;\n         Ok(())\n     }\n \n-    /// Run TLS destructors for the active thread.\n+    /// Schedule the MacOS global dtor to be executed.\n     ///\n-    /// Note: on Windows OS this function is a no-op because we do not support\n-    /// concurrency on Windows yet.\n-    ///\n-    /// FIXME: we do not support yet deallocation of thread local statics.\n-    fn run_tls_dtors_for_active_thread(&mut self) -> InterpResult<'tcx> {\n+    /// Note: It is safe to call this function also on other Unixes.\n+    fn schedule_macos_global_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if this.tcx.sess.target.target.target_os == \"windows\" {\n-            return Ok(());\n-        }\n         let thread_id = this.get_active_thread()?;\n-        assert!(!this.machine.tls.dtors_running.contains(&thread_id), \"running TLS dtors twice\");\n-        this.machine.tls.dtors_running.insert(thread_id);\n-\n         // The macOS global dtor runs \"before any TLS slots get freed\", so do that first.\n-        if let Some(&(instance, data)) = this.machine.tls.global_dtors.get(&thread_id) {\n+        if let Some((instance, data)) = this.machine.tls.global_dtors.remove(&thread_id) {\n             trace!(\"Running global dtor {:?} on {:?} at {:?}\", instance, data, thread_id);\n \n             let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n@@ -255,14 +241,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n \n-            // step until out of stackframes\n-            this.run()?;\n+            // Enable the thread so that it steps through the destructor which\n+            // we just scheduled. Since we deleted the destructor, it is\n+            // guaranteed that we will schedule it again. The `dtors_running`\n+            // flag will prevent the code from adding the destructor again.\n+            this.enable_thread(thread_id)?;\n         }\n+        Ok(())\n+    }\n+\n+    /// Schedule a pthread TLS destructor.\n+    fn schedule_pthread_tls_dtors(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread()?;\n \n-        assert!(this.has_terminated(thread_id)?, \"running TLS dtors for non-terminated thread\");\n-        let mut dtor = this.machine.tls.fetch_tls_dtor(None, thread_id);\n-        while let Some((instance, ptr, key)) = dtor {\n-            trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, thread_id);\n+        assert!(this.has_terminated(active_thread)?, \"running TLS dtors for non-terminated thread\");\n+        // Fetch next dtor after `key`.\n+        let last_key = this.machine.tls.last_dtor_key.get(&active_thread).cloned();\n+        let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n+            dtor @ Some(_) => dtor,\n+            // We ran each dtor once, start over from the beginning.\n+            None => {\n+                this.machine.tls.fetch_tls_dtor(None, active_thread)\n+            }\n+        };\n+        if let Some((instance, ptr, key)) = dtor {\n+            this.machine.tls.last_dtor_key.insert(active_thread, key);\n+            trace!(\"Running TLS dtor {:?} on {:?} at {:?}\", instance, ptr, active_thread);\n             assert!(!this.is_null(ptr).unwrap(), \"Data can't be NULL when dtor is called!\");\n \n             let ret_place = MPlaceTy::dangling(this.machine.layouts.unit, this).into();\n@@ -273,15 +278,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n \n-            // step until out of stackframes\n-            this.run()?;\n+            this.enable_thread(active_thread)?;\n+            return Ok(());\n+        }\n+        this.machine.tls.last_dtor_key.remove(&active_thread);\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n \n-            // Fetch next dtor after `key`.\n-            dtor = match this.machine.tls.fetch_tls_dtor(Some(key), thread_id) {\n-                dtor @ Some(_) => dtor,\n-                // We ran each dtor once, start over from the beginning.\n-                None => this.machine.tls.fetch_tls_dtor(None, thread_id),\n-            };\n+    /// Schedule an active thread's TLS destructor to run on the active thread.\n+    /// Note that this function does not run the destructors itself, it just\n+    /// schedules them one by one each time it is called.\n+    ///\n+    /// FIXME: we do not support yet deallocation of thread local statics.\n+    fn schedule_tls_dtors_for_active_thread(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread()?;\n+\n+        if this.tcx.sess.target.target.target_os == \"windows\" {\n+            if !this.machine.tls.dtors_running.contains(&active_thread) {\n+                this.machine.tls.dtors_running.insert(active_thread);\n+                this.schedule_windows_tls_dtors()?;\n+            }\n+        } else {\n+            this.machine.tls.dtors_running.insert(active_thread);\n+            this.schedule_macos_global_tls_dtors()?;\n+            this.schedule_pthread_tls_dtors()?;\n         }\n \n         Ok(())"}, {"sha": "c4e0f9be1877bd11c4f505573184da4cb7322289", "filename": "src/thread.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "patch": "@@ -248,6 +248,12 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         self.threads[thread_id].state == ThreadState::Terminated\n     }\n \n+    /// Enable the thread for execution. The thread must be terminated.\n+    fn enable_thread(&mut self, thread_id: ThreadId) {\n+        assert!(self.has_terminated(thread_id));\n+        self.threads[thread_id].state = ThreadState::Enabled;\n+    }\n+\n     /// Get the borrow of the currently active thread.\n     fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n         &mut self.threads[self.active_thread]\n@@ -525,6 +531,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(this.machine.threads.has_terminated(thread_id))\n     }\n \n+    #[inline]\n+    fn enable_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.enable_thread(thread_id);\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n         let this = self.eval_context_ref();"}, {"sha": "f232cee5bdd103359d89261937cfe0d754a7227d", "filename": "tests/run-pass/concurrency/tls_lib_drop_single_thread.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop_single_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop_single_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop_single_thread.rs?ref=feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "patch": "@@ -0,0 +1,25 @@\n+//! Check that destructors of the thread locals are executed on all OSes.\n+\n+use std::cell::RefCell;\n+\n+struct TestCell {\n+    value: RefCell<u8>,\n+}\n+\n+impl Drop for TestCell {\n+    fn drop(&mut self) {\n+        eprintln!(\"Dropping: {}\", self.value.borrow())\n+    }\n+}\n+\n+thread_local! {\n+    static A: TestCell = TestCell { value: RefCell::new(0) };\n+}\n+\n+fn main() {\n+    A.with(|f| {\n+        assert_eq!(*f.value.borrow(), 0);\n+        *f.value.borrow_mut() = 5;\n+    });\n+    eprintln!(\"Continue main.\")\n+}"}, {"sha": "a9d705e5b9a2218a0787840b2332ba1c08f7432a", "filename": "tests/run-pass/concurrency/tls_lib_drop_single_thread.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop_single_thread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop_single_thread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop_single_thread.stderr?ref=feb188360ee5ff6ae4cdc8e6a20ec29f9cd385ba", "patch": "@@ -0,0 +1,2 @@\n+Continue main.\n+Dropping: 5"}]}