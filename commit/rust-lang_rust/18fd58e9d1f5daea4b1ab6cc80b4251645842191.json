{"sha": "18fd58e9d1f5daea4b1ab6cc80b4251645842191", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZmQ1OGU5ZDFmNWRhZWE0YjFhYjZjYzgwYjQyNTE2NDU4NDIxOTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-25T10:12:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-26T07:56:54Z"}, "message": "interning cleanup: we no longer need to distinguish Const and ConstInner; we no longer need the ignore_interior_mut_in_const hack", "tree": {"sha": "7409de253b136865d2545bbf4760f1b06d4a8bb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7409de253b136865d2545bbf4760f1b06d4a8bb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18fd58e9d1f5daea4b1ab6cc80b4251645842191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18fd58e9d1f5daea4b1ab6cc80b4251645842191", "html_url": "https://github.com/rust-lang/rust/commit/18fd58e9d1f5daea4b1ab6cc80b4251645842191", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18fd58e9d1f5daea4b1ab6cc80b4251645842191/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b501edf08e7088c4a9b8fe9b12523b9f421e588", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b501edf08e7088c4a9b8fe9b12523b9f421e588", "html_url": "https://github.com/rust-lang/rust/commit/9b501edf08e7088c4a9b8fe9b12523b9f421e588"}], "stats": {"total": 114, "additions": 33, "deletions": 81}, "files": [{"sha": "4ba36a376f8c9741d3d6f77e2055af01f2f52d41", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=18fd58e9d1f5daea4b1ab6cc80b4251645842191", "patch": "@@ -210,16 +210,6 @@ pub struct Body<'tcx> {\n     /// We hold in this field all the constants we are not able to evaluate yet.\n     pub required_consts: Vec<Constant<'tcx>>,\n \n-    /// The user may be writing e.g. `&[(SOME_CELL, 42)][i].1` and this would get promoted, because\n-    /// we'd statically know that no thing with interior mutability will ever be available to the\n-    /// user without some serious unsafe code.  Now this means that our promoted is actually\n-    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because\n-    /// the index may be a runtime value. Such a promoted value is illegal because it has reachable\n-    /// interior mutability. This flag just makes this situation very obvious where the previous\n-    /// implementation without the flag hid this situation silently.\n-    /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n-    pub ignore_interior_mut_in_const_validation: bool,\n-\n     /// Does this body use generic parameters. This is used for the `ConstEvaluatable` check.\n     ///\n     /// Note that this does not actually mean that this body is not computable right now.\n@@ -276,7 +266,6 @@ impl<'tcx> Body<'tcx> {\n             var_debug_info,\n             span,\n             required_consts: Vec::new(),\n-            ignore_interior_mut_in_const_validation: false,\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n         };\n@@ -306,7 +295,6 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n-            ignore_interior_mut_in_const_validation: false,\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n         };"}, {"sha": "7b9a4ec873d0a757d9794e2085717fd09978bd53", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=18fd58e9d1f5daea4b1ab6cc80b4251645842191", "patch": "@@ -67,12 +67,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n-    intern_const_alloc_recursive(\n-        ecx,\n-        intern_kind,\n-        ret,\n-        body.ignore_interior_mut_in_const_validation,\n-    );\n+    intern_const_alloc_recursive(ecx, intern_kind, ret);\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -373,7 +368,13 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n             // Since evaluation had no errors, valiate the resulting constant:\n             let validation = try {\n                 // FIXME do not validate promoteds until a decision on\n-                // https://github.com/rust-lang/rust/issues/67465 is made\n+                // https://github.com/rust-lang/rust/issues/67465 and\n+                // https://github.com/rust-lang/rust/issues/67534 is made.\n+                // Promoteds can contain unexpected `UnsafeCell` and reference `static`s, but their\n+                // otherwise restricted form ensures that this is still sound. We just lose the\n+                // extra safety net of some of the dynamic checks. They can also contain invalid\n+                // values, but since we do not usually check intermediate results of a computation\n+                // for validity, it might be surprising to do that here.\n                 if cid.promoted.is_none() {\n                     let mut ref_tracking = RefTracking::new(mplace);\n                     let mut inner = false;"}, {"sha": "11a211ef7b3518a39c558e8417b924c4f5672b45", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=18fd58e9d1f5daea4b1ab6cc80b4251645842191", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false);\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place);\n     ConstValue::Scalar(loc_place.ptr)\n }\n "}, {"sha": "c8b7da907539b2eece185db9499196935131ee1d", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 16, "deletions": 56, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=18fd58e9d1f5daea4b1ab6cc80b4251645842191", "patch": "@@ -7,7 +7,7 @@ use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n-use rustc_middle::ty::{self, layout::TyAndLayout, query::TyCtxtAt, Ty};\n+use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n use rustc_target::abi::Size;\n \n use rustc_ast::Mutability;\n@@ -40,11 +40,6 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n     /// the intern mode of references we encounter.\n     inside_unsafe_cell: bool,\n-\n-    /// This flag is to avoid triggering UnsafeCells are not allowed behind references in constants\n-    /// for promoteds.\n-    /// It's a copy of `mir::Body`'s ignore_interior_mut_in_const_validation field\n-    ignore_interior_mut_in_const: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n@@ -53,22 +48,14 @@ enum InternMode {\n     /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n     /// is *mutable*.\n     Static(hir::Mutability),\n-    /// The \"base value\" of a const, which can have `UnsafeCell` (as in `const FOO: Cell<i32>`),\n-    /// but that interior mutability is simply ignored.\n-    ConstBase,\n-    /// The \"inner values\" of a const with references, where `UnsafeCell` is an error.\n-    ConstInner,\n+    /// A `const`.\n+    Const,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n-fn mutable_memory_in_const(tcx: TyCtxtAt<'_>, kind: &str) {\n-    // FIXME: show this in validation instead so we can point at where in the value the error is?\n-    tcx.sess.span_err(tcx.span, &format!(\"mutable memory ({}) is not allowed in constant\", kind));\n-}\n-\n /// Intern an allocation without looking at its children.\n /// `mode` is the mode of the environment where we found this pointer.\n /// `mutablity` is the mutability of the place to be interned; even if that says\n@@ -165,17 +152,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n         mplace: MPlaceTy<'tcx>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n+        // ZSTs cannot contain pointers, so we can skip them.\n+        if mplace.layout.is_zst() {\n+            return Ok(());\n+        }\n+\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n-                if self.mode == InternMode::ConstInner && !self.ignore_interior_mut_in_const {\n-                    // We do not actually make this memory mutable.  But in case the user\n-                    // *expected* it to be mutable, make sure we error.  This is just a\n-                    // sanity check to prevent users from accidentally exploiting the UB\n-                    // they caused.  It also helps us to find cases where const-checking\n-                    // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n-                    // shows that part is not airtight).\n-                    //mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n-                }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n@@ -187,11 +170,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             }\n         }\n \n-        // ZSTs cannot contain pointers, so we can skip them.\n-        if mplace.layout.is_zst() {\n-            return Ok(());\n-        }\n-\n         self.walk_aggregate(mplace, fields)\n     }\n \n@@ -211,7 +189,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n+                    self.intern_shallow(vtable.alloc_id, InternMode::Const, None);\n                 } else {\n                     // Validation will error (with a better message) on an invalid vtable pointer.\n                     // Let validation show the error message, but make sure it *does* error.\n@@ -223,7 +201,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n                 // Compute the mode with which we intern this. Our goal here is to make as many\n-                // statics as we can immutable so they can be placed in const memory by LLVM.\n+                // statics as we can immutable so they can be placed in read-only memory by LLVM.\n                 let ref_mode = match self.mode {\n                     InternMode::Static(mutbl) => {\n                         // In statics, merge outer mutability with reference mutability and\n@@ -257,27 +235,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                             }\n                         }\n                     }\n-                    InternMode::ConstBase | InternMode::ConstInner => {\n-                        // Ignore `UnsafeCell`, everything is immutable.  Do some sanity checking\n-                        // for mutable references that we encounter -- they must all be ZST.\n-                        // This helps to prevent users from accidentally exploiting UB that they\n-                        // caused (by somehow getting a mutable reference in a `const`).\n-                        if ref_mutability == Mutability::Mut {\n-                            /*match referenced_ty.kind() {\n-                                ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n-                                ty::Slice(_)\n-                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n-                                        == 0 => {}\n-                                _ => mutable_memory_in_const(tcx, \"`&mut`\"),\n-                            }*/\n-                        } else {\n-                            // A shared reference. We cannot check `freeze` here due to references\n-                            // like `&dyn Trait` that are actually immutable.  We do check for\n-                            // concrete `UnsafeCell` when traversing the pointee though (if it is\n-                            // a new allocation, not yet interned).\n-                        }\n-                        // Go on with the \"inner\" rules.\n-                        InternMode::ConstInner\n+                    InternMode::Const => {\n+                        // Ignore `UnsafeCell`, everything is immutable.  Validity does some sanity\n+                        // checking for mutable references that we encounter -- they must all be\n+                        // ZST.\n+                        InternMode::Const\n                     }\n                 };\n                 match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty)) {\n@@ -316,7 +278,6 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n-    ignore_interior_mut_in_const: bool,\n ) where\n     'tcx: 'mir,\n {\n@@ -325,7 +286,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // `Constant` includes array lengths.\n         // `Promoted` includes non-`Copy` array initializers and `rustc_args_required_const` arguments.\n-        InternKind::Constant | InternKind::Promoted => InternMode::ConstBase,\n+        InternKind::Constant | InternKind::Promoted => InternMode::Const,\n     };\n \n     // Type based interning.\n@@ -355,7 +316,6 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             ecx,\n             mode,\n             leftover_allocations,\n-            ignore_interior_mut_in_const,\n             inside_unsafe_cell: false,\n         }\n         .visit_value(mplace);"}, {"sha": "a29ef117ace831c8696ce74a1e54d7e8c9210e17", "filename": "compiler/rustc_mir/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs?ref=18fd58e9d1f5daea4b1ab6cc80b4251645842191", "patch": "@@ -24,7 +24,7 @@ pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackP\n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n-pub use self::validity::{RefTracking, CtfeValidationMode};\n+pub use self::validity::{CtfeValidationMode, RefTracking};\n pub use self::visitor::{MutValueVisitor, ValueVisitor};\n \n crate use self::intrinsics::eval_nullary_intrinsic;"}, {"sha": "f657c6c4538328fef0399b73b3de74ff5623c4d7", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=18fd58e9d1f5daea4b1ab6cc80b4251645842191", "patch": "@@ -119,6 +119,8 @@ pub enum CtfeValidationMode {\n     Regular,\n     /// Validation of a `const`. `inner` says if this is an inner, indirect allocation (as opposed\n     /// to the top-level const allocation).\n+    /// Being an inner allocation makes a difference because the top-level allocation of a `const`\n+    /// is copied for each use, but the inner allocations are implicitly shared.\n     Const { inner: bool },\n }\n \n@@ -541,8 +543,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 Ok(true)\n             }\n             ty::Ref(_, ty, mutbl) => {\n-                if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. })) && *mutbl == hir::Mutability::Mut {\n-                    // A mutable reference inside a const? That does not seem right (except of it is\n+                if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. }))\n+                    && *mutbl == hir::Mutability::Mut\n+                {\n+                    // A mutable reference inside a const? That does not seem right (except if it is\n                     // a ZST).\n                     let layout = self.ecx.layout_of(ty)?;\n                     if !layout.is_zst() {"}, {"sha": "927aae82a36efab1c3cb9a66b4abd18548a453d0", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fd58e9d1f5daea4b1ab6cc80b4251645842191/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=18fd58e9d1f5daea4b1ab6cc80b4251645842191", "patch": "@@ -1170,7 +1170,7 @@ pub fn promote_candidates<'tcx>(\n         let mut scope = body.source_scopes[candidate.source_info(body).scope].clone();\n         scope.parent_scope = None;\n \n-        let mut promoted = Body::new(\n+        let promoted = Body::new(\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             IndexVec::from_elem_n(scope, 1),\n@@ -1181,7 +1181,6 @@ pub fn promote_candidates<'tcx>(\n             body.span,\n             body.generator_kind,\n         );\n-        promoted.ignore_interior_mut_in_const_validation = true;\n \n         let promoter = Promoter {\n             promoted,"}]}