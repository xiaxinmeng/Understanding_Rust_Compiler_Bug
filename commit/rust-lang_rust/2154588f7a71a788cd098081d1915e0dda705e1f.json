{"sha": "2154588f7a71a788cd098081d1915e0dda705e1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNTQ1ODhmN2E3MWE3ODhjZDA5ODA4MWQxOTE1ZTBkZGE3MDVlMWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-14T19:07:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-14T19:07:29Z"}, "message": "Auto merge of #37740 - bluss:corrected-vec-collect, r=alexcrichton\n\nRestore Vec::from_iter() specialization\n\nSince I said \"no intentional functional change\" in the previous commit,\nI guess it was inevitable there were unintentional changes. Not\nfunctional, but optimization-wise. This restores the extend\nspecialization's use in Vec::from_iter. (commit 1).\n\nAlso use specialization in from_iter to reduce allocation code duplication\nfor the TrustedLen case (commit 2).\n\nBug introduced in PR #37709", "tree": {"sha": "9e45f6fabb7da3575ccb7fb8acc72698581ef0c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e45f6fabb7da3575ccb7fb8acc72698581ef0c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2154588f7a71a788cd098081d1915e0dda705e1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2154588f7a71a788cd098081d1915e0dda705e1f", "html_url": "https://github.com/rust-lang/rust/commit/2154588f7a71a788cd098081d1915e0dda705e1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2154588f7a71a788cd098081d1915e0dda705e1f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766f6e4782994ff9f0b0cad9af9cd63b5a2d0f0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/766f6e4782994ff9f0b0cad9af9cd63b5a2d0f0d", "html_url": "https://github.com/rust-lang/rust/commit/766f6e4782994ff9f0b0cad9af9cd63b5a2d0f0d"}, {"sha": "c36edc726156c7868c6845c0e39b5231e35bc1ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c36edc726156c7868c6845c0e39b5231e35bc1ff", "html_url": "https://github.com/rust-lang/rust/commit/c36edc726156c7868c6845c0e39b5231e35bc1ff"}], "stats": {"total": 51, "additions": 31, "deletions": 20}, "files": [{"sha": "24f8e3a2d918144a8cbda94dccfb1545ef292a95", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2154588f7a71a788cd098081d1915e0dda705e1f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2154588f7a71a788cd098081d1915e0dda705e1f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2154588f7a71a788cd098081d1915e0dda705e1f", "patch": "@@ -1499,26 +1499,7 @@ impl<T> ops::DerefMut for Vec<T> {\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n-        // Unroll the first iteration, as the vector is going to be\n-        // expanded on this iteration in every case when the iterable is not\n-        // empty, but the loop in extend_desugared() is not going to see the\n-        // vector being full in the few subsequent loop iterations.\n-        // So we get better branch prediction.\n-        let mut iterator = iter.into_iter();\n-        let mut vector = match iterator.next() {\n-            None => return Vec::new(),\n-            Some(element) => {\n-                let (lower, _) = iterator.size_hint();\n-                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n-                unsafe {\n-                    ptr::write(vector.get_unchecked_mut(0), element);\n-                    vector.set_len(1);\n-                }\n-                vector\n-            }\n-        };\n-        vector.extend_desugared(iterator);\n-        vector\n+        <Self as SpecExtend<_>>::from_iter(iter.into_iter())\n     }\n }\n \n@@ -1590,13 +1571,37 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n+// Specialization trait used for Vec::from_iter and Vec::extend\n trait SpecExtend<I> {\n+    fn from_iter(iter: I) -> Self;\n     fn spec_extend(&mut self, iter: I);\n }\n \n impl<I, T> SpecExtend<I> for Vec<T>\n     where I: Iterator<Item=T>,\n {\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Unroll the first iteration, as the vector is going to be\n+        // expanded on this iteration in every case when the iterable is not\n+        // empty, but the loop in extend_desugared() is not going to see the\n+        // vector being full in the few subsequent loop iterations.\n+        // So we get better branch prediction.\n+        let mut vector = match iterator.next() {\n+            None => return Vec::new(),\n+            Some(element) => {\n+                let (lower, _) = iterator.size_hint();\n+                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n+                unsafe {\n+                    ptr::write(vector.get_unchecked_mut(0), element);\n+                    vector.set_len(1);\n+                }\n+                vector\n+            }\n+        };\n+        vector.spec_extend(iterator);\n+        vector\n+    }\n+\n     default fn spec_extend(&mut self, iter: I) {\n         self.extend_desugared(iter)\n     }\n@@ -1605,6 +1610,12 @@ impl<I, T> SpecExtend<I> for Vec<T>\n impl<I, T> SpecExtend<I> for Vec<T>\n     where I: TrustedLen<Item=T>,\n {\n+    fn from_iter(iterator: I) -> Self {\n+        let mut vector = Vec::new();\n+        vector.spec_extend(iterator);\n+        vector\n+    }\n+\n     fn spec_extend(&mut self, iterator: I) {\n         // This is the case for a TrustedLen iterator.\n         let (low, high) = iterator.size_hint();"}]}