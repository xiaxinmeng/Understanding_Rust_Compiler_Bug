{"sha": "39ba11036a55723fc31590ca6d4ac1845c941992", "node_id": "C_kwDOAAsO6NoAKDM5YmExMTAzNmE1NTcyM2ZjMzE1OTBjYTZkNGFjMTg0NWM5NDE5OTI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-02-09T17:48:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-09T17:48:35Z"}, "message": "Rollup merge of #107786 - compiler-errors:new-solver-some-tweaks, r=lcnr\n\nImplement some tweaks in the new solver\n\nI've been testing the new solver on some small codebases, and these are a few small changes I've needed to make.\n\nThe most \"controversial\" here is implementing `trait_candidate_should_be_dropped_in_favor_of`, which I just implemented to always return false. This surprisingly allows some code to compile, without us having to actually decide on any semantics yet.\n\nr? `@rust-lang/initiative-trait-system-refactor`", "tree": {"sha": "f4ad0a182992f9d05c4acbfe1dcf690e4cfaba07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4ad0a182992f9d05c4acbfe1dcf690e4cfaba07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ba11036a55723fc31590ca6d4ac1845c941992", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj5THzCRBK7hj4Ov3rIwAAmnIIAKJNsayuXLo62zfmo9Aur+B8\naLYUrgGKevYGCx72OwArHn6xYa16yQoMF8mIEOAml19H5+JzZLS2UcOrB+xD7Wdq\n/E9l7gBn2i75lEtdNwbBpPyuJFk1DMONATY/6qIgg/bsQAv/CprxQpqHX4FquXbF\nbwXudlMZZeLhSu1udsWJ4VSF/DnNueIoUsN8KI75BuJ4ZT49EKJBtz0oANS5ADH6\nGK8fl5BY0YSwofUcTI06DUrs9b7xVmGwU7J1elJgVmoS3FRRziuw2N4puwkyZq0d\nvrjidU8SzNGMSPChwCC3KMcZS12FgLy8CGQV9+aMPF937YFwgb2CeDAv9K5HOIo=\n=ew/V\n-----END PGP SIGNATURE-----\n", "payload": "tree f4ad0a182992f9d05c4acbfe1dcf690e4cfaba07\nparent 5aa062e249afb16f3fa3729a066534869df16826\nparent 654f43f34edded48a55fef2b515b4a7d0304c38e\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1675964915 +0530\ncommitter GitHub <noreply@github.com> 1675964915 +0530\n\nRollup merge of #107786 - compiler-errors:new-solver-some-tweaks, r=lcnr\n\nImplement some tweaks in the new solver\n\nI've been testing the new solver on some small codebases, and these are a few small changes I've needed to make.\n\nThe most \"controversial\" here is implementing `trait_candidate_should_be_dropped_in_favor_of`, which I just implemented to always return false. This surprisingly allows some code to compile, without us having to actually decide on any semantics yet.\n\nr? `@rust-lang/initiative-trait-system-refactor`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ba11036a55723fc31590ca6d4ac1845c941992", "html_url": "https://github.com/rust-lang/rust/commit/39ba11036a55723fc31590ca6d4ac1845c941992", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ba11036a55723fc31590ca6d4ac1845c941992/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aa062e249afb16f3fa3729a066534869df16826", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa062e249afb16f3fa3729a066534869df16826", "html_url": "https://github.com/rust-lang/rust/commit/5aa062e249afb16f3fa3729a066534869df16826"}, {"sha": "654f43f34edded48a55fef2b515b4a7d0304c38e", "url": "https://api.github.com/repos/rust-lang/rust/commits/654f43f34edded48a55fef2b515b4a7d0304c38e", "html_url": "https://github.com/rust-lang/rust/commit/654f43f34edded48a55fef2b515b4a7d0304c38e"}], "stats": {"total": 273, "additions": 129, "deletions": 144}, "files": [{"sha": "775974d8e9a608aaefbcc5cb6c0bee561a3b4dfe", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -3,7 +3,7 @@\n use super::infcx_ext::InferCtxtExt;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -399,10 +399,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ty::Alias(_, alias_ty) => alias_ty,\n         };\n \n-        for (assumption, _) in self\n-            .tcx()\n-            .bound_explicit_item_bounds(alias_ty.def_id)\n-            .subst_iter_copied(self.tcx(), alias_ty.substs)\n+        for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n             match G::consider_assumption(self, goal, assumption) {\n                 Ok(result) => {\n@@ -462,4 +459,78 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n         }\n     }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn merge_candidates_and_discard_reservation_impls(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.trait_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                i += 1;\n+            }\n+\n+            // If there are *STILL* multiple candidates, give up\n+            // and report ambiguity.\n+            if candidates.len() > 1 {\n+                let certainty = if candidates.iter().all(|x| {\n+                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n+                }) {\n+                    Certainty::Maybe(MaybeCause::Overflow)\n+                } else {\n+                    Certainty::AMBIGUOUS\n+                };\n+                return self.make_canonical_response(certainty);\n+            }\n+        }\n+\n+        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+    }\n+\n+    fn trait_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::AliasBound, _)\n+            | (CandidateSource::BuiltinImpl, _) => false,\n+        }\n+    }\n+\n+    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+        if let CandidateSource::Impl(def_id) = candidate.source {\n+            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n+                debug!(\"Selected reservation impl\");\n+                // We assemble all candidates inside of a probe so by\n+                // making a new canonical response here our result will\n+                // have no constraints.\n+                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n+            }\n+        }\n+\n+        candidate\n+    }\n }"}, {"sha": "4fea49893a6c6c2b86de4d31e832f5310253d453", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::{specialization_graph, translate_substs};\n \n-use super::assembly::{self, Candidate, CandidateSource};\n+use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n use super::trait_goals::structural_traits;\n use super::{Certainty, EvalCtxt, Goal, QueryResult};\n@@ -34,7 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // projection cache in the solver.\n         if self.term_is_fully_unconstrained(goal) {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_project_candidates(candidates)\n+            self.merge_candidates_and_discard_reservation_impls(candidates)\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = match predicate.term.unpack() {\n@@ -153,59 +153,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n     }\n-\n-    fn merge_project_candidates(\n-        &mut self,\n-        mut candidates: Vec<Candidate<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(candidates.pop().unwrap().result),\n-            _ => {}\n-        }\n-\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.project_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n-                    }\n-                }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                // If there are *STILL* multiple candidates, give up\n-                // and report ambiguity.\n-                i += 1;\n-                if i > 1 {\n-                    debug!(\"multiple matches, ambig\");\n-                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n-                    unimplemented!();\n-                }\n-            }\n-        }\n-\n-        Ok(candidates.pop().unwrap().result)\n-    }\n-\n-    fn project_candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::BuiltinImpl, _)\n-            | (CandidateSource::AliasBound, _) => unimplemented!(),\n-        }\n-    }\n }\n \n impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n@@ -452,7 +399,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let is_sized_certainty = ecx.evaluate_goal(goal.with(tcx, sized_predicate))?.1;\n+                    let (_, is_sized_certainty) =\n+                        ecx.evaluate_goal(goal.with(tcx, sized_predicate))?;\n                     return ecx.eq_term_and_make_canonical_response(\n                         goal,\n                         is_sized_certainty,"}, {"sha": "abb69476caefb537cd93d88394ffce389743335a", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 2, "deletions": 69, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use super::assembly::{self, Candidate, CandidateSource};\n+use super::assembly;\n use super::infcx_ext::InferCtxtExt;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n@@ -479,73 +479,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = self.assemble_and_evaluate_candidates(goal);\n-        self.merge_trait_candidates_discard_reservation_impls(candidates)\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn merge_trait_candidates_discard_reservation_impls(\n-        &mut self,\n-        mut candidates: Vec<Candidate<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n-            _ => {}\n-        }\n-\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.trait_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n-                    }\n-                }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                // If there are *STILL* multiple candidates, give up\n-                // and report ambiguity.\n-                i += 1;\n-                if i > 1 {\n-                    debug!(\"multiple matches, ambig\");\n-                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n-                    unimplemented!();\n-                }\n-            }\n-        }\n-\n-        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n-    }\n-\n-    fn trait_candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound, _)\n-            | (CandidateSource::BuiltinImpl, _) => unimplemented!(),\n-        }\n-    }\n-\n-    fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n-        if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n-                debug!(\"Selected reservation impl\");\n-                // FIXME: reduce candidate to ambiguous\n-                // FIXME: replace `var_values` with identity, yeet external constraints.\n-                unimplemented!()\n-            }\n-        }\n-\n-        candidate\n+        self.merge_candidates_and_discard_reservation_impls(candidates)\n     }\n }"}, {"sha": "bafa2981a87391f2558f1ec56333086b2afd5b8f", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -646,11 +646,9 @@ fn object_ty_for_trait<'tcx>(\n             debug!(?obligation);\n             let pred = obligation.predicate.to_opt_poly_projection_pred()?;\n             Some(pred.map_bound(|p| {\n-                ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n-                    def_id: p.projection_ty.def_id,\n-                    substs: p.projection_ty.substs,\n-                    term: p.term,\n-                })\n+                ty::ExistentialPredicate::Projection(ty::ExistentialProjection::erase_self_ty(\n+                    tcx, p,\n+                ))\n             }))\n         })\n         .collect();"}, {"sha": "076aefcf8fc60afedc88307195ffde433d5a5d42", "filename": "tests/ui/traits/new-solver/elaborate-item-bounds.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Felaborate-item-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Felaborate-item-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Felaborate-item-bounds.rs?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo {\n+    type Bar: Bar;\n+}\n+\n+trait Bar: Baz {}\n+\n+trait Baz {}\n+\n+fn main() {}"}, {"sha": "254ab356ad89c2f8610a1bf2fff75ec5bc135bdb", "filename": "tests/ui/traits/new-solver/provisional-result-done.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.rs?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -1,9 +1,5 @@\n // known-bug: unknown\n // compile-flags: -Ztrait-solver=next\n-// failure-status: 101\n-// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n-// rustc-env:RUST_BACKTRACE=0\n \n // This tests checks that we update results in the provisional cache when\n // we pop a goal from the stack."}, {"sha": "5bd0613d25911612d5757accb5200e92354002d7", "filename": "tests/ui/traits/new-solver/provisional-result-done.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprovisional-result-done.stderr?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -1,6 +1,11 @@\n-error: the compiler unexpectedly panicked. this is a bug.\n+error[E0283]: type annotations needed: cannot satisfy `Bar<T>: Coinductive`\n+  --> $DIR/provisional-result-done.rs:16:25\n+   |\n+LL | impl<T> Coinductive for Bar<T>\n+   |                         ^^^^^^\n+   |\n+   = note: cannot satisfy `Bar<T>: Coinductive`\n \n-query stack during panic:\n-#0 [check_well_formed] checking that `<impl at $DIR/provisional-result-done.rs:20:1: 20:31>` is well-formed\n-#1 [check_mod_type_wf] checking that types are well-formed in top-level module\n-end of query stack\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "18ee05457009b736a5ae53778972223f356d6bd7", "filename": "tests/ui/traits/new-solver/temporary-ambiguity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Ftemporary-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ba11036a55723fc31590ca6d4ac1845c941992/tests%2Fui%2Ftraits%2Fnew-solver%2Ftemporary-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ftemporary-ambiguity.rs?ref=39ba11036a55723fc31590ca6d4ac1845c941992", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Checks that we don't explode when we assemble >1 candidate for a goal.\n+\n+struct Wrapper<T>(T);\n+\n+trait Foo {}\n+\n+impl Foo for Wrapper<i32> {}\n+\n+impl Foo for Wrapper<()> {}\n+\n+fn needs_foo(_: impl Foo) {}\n+\n+fn main() {\n+    let mut x = Default::default();\n+    let w = Wrapper(x);\n+    needs_foo(w);\n+    x = 1;\n+    drop(x);\n+}"}]}