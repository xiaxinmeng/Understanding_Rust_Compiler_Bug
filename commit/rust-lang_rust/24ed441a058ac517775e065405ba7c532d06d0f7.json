{"sha": "24ed441a058ac517775e065405ba7c532d06d0f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZWQ0NDFhMDU4YWM1MTc3NzVlMDY1NDA1YmE3YzUzMmQwNmQwZjc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-12T15:31:22Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T14:08:31Z"}, "message": "Reuse monomorphized functions more aggressively\n\nAdds a trans::type_use pass that, given a function body, detects how\ndependant that function is on properties of its type parameters.", "tree": {"sha": "3412e0a58fa8a7ee87ae8e49d928572d3d0c51e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3412e0a58fa8a7ee87ae8e49d928572d3d0c51e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24ed441a058ac517775e065405ba7c532d06d0f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24ed441a058ac517775e065405ba7c532d06d0f7", "html_url": "https://github.com/rust-lang/rust/commit/24ed441a058ac517775e065405ba7c532d06d0f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24ed441a058ac517775e065405ba7c532d06d0f7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ab9978b9bc010641423cf3ff2990a5ef0a61142", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab9978b9bc010641423cf3ff2990a5ef0a61142", "html_url": "https://github.com/rust-lang/rust/commit/3ab9978b9bc010641423cf3ff2990a5ef0a61142"}], "stats": {"total": 415, "additions": 351, "deletions": 64}, "files": [{"sha": "1b73704c301c649a170fa4eb8403b2ac64e2fae9", "filename": "src/rustc/middle/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -24,7 +24,7 @@ type ctxt = {\n fn check_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     let t = ty::expr_ty(cx.tcx, expr);\n     if ty::type_has_rptrs(t) {\n-        ty::walk_ty(cx.tcx, t) { |t|\n+        ty::walk_ty(t) { |t|\n             alt ty::get(t).struct {\n                 ty::ty_rptr(region, _) {\n                     alt region {"}, {"sha": "c5a6769d30562a7d2b489546af3087ce1fa563c4", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 90, "deletions": 13, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -1784,22 +1784,98 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     ret get_extern_const(ccx.externs, ccx.llmod, name, llty);\n }\n \n-fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n+fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n+    // FIXME[mono] could do this recursively. is that worthwhile?\n+    alt ty::get(ty).struct {\n+      ty::ty_box(mt) { some(ty::mk_opaque_box(tcx)) }\n+      ty::ty_fn(fty) { some(ty::mk_fn(tcx, {proto: fty.proto,\n+                                            inputs: [],\n+                                            output: ty::mk_nil(tcx),\n+                                            ret_style: ast::return_val,\n+                                            constraints: []})) }\n+      ty::ty_iface(_, _) { some(ty::mk_fn(tcx, {proto: ast::proto_box,\n+                                                inputs: [],\n+                                                output: ty::mk_nil(tcx),\n+                                                ret_style: ast::return_val,\n+                                                constraints: []})) }\n+      ty::ty_ptr(_) { some(ty::mk_uint(tcx)) }\n+      _ { none }\n+    }\n+}\n+\n+fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n+                vtables: option<typeck::vtable_res>,\n+                param_uses: option<[type_use::type_uses]>) -> mono_id {\n+    let precise_param_ids = alt vtables {\n+      some(vts) {\n+        let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n+        let i = 0u;\n+        vec::map2(*bounds, substs, {|bounds, subst|\n+            let v = [];\n+            for bound in *bounds {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    v += [impl::vtable_id(ccx, vts[i])];\n+                    i += 1u;\n+                  }\n+                  _ {}\n+                }\n+            }\n+            mono_precise(subst, if v.len() > 0u { some(v) } else { none })\n+        })\n+      }\n+      none {\n+        vec::map(substs, {|subst| mono_precise(subst, none)})\n+      }\n+    };\n+    let param_ids = alt param_uses {\n+      some(uses) {\n+        vec::map2(precise_param_ids, uses, {|id, uses|\n+            alt check id {\n+              mono_precise(_, some(_)) { id }\n+              mono_precise(subst, none) {\n+                if uses == 0u { mono_any }\n+                else if uses == type_use::use_repr &&\n+                        !ty::type_needs_drop(ccx.tcx, subst) {\n+                    let llty = type_of(ccx, subst);\n+                    let size = shape::llsize_of_real(ccx, llty);\n+                    let align = shape::llalign_of_real(ccx, llty);\n+                    // Special value for nil to prevent problems with undef\n+                    // return pointers.\n+                    if size == 1u && ty::type_is_nil(subst) {\n+                        mono_repr(0u, 0u)\n+                    } else { mono_repr(size, align) }\n+                } else { id }\n+              }\n+            }\n+        })\n+      }\n+      none { precise_param_ids }\n+    };\n+    @{def: item, params: param_ids}\n+}\n+\n+fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n                   vtables: option<typeck::vtable_res>)\n     -> {val: ValueRef, must_cast: bool, intrinsic: bool} {\n     let mut must_cast = false;\n-    let substs = vec::map(substs, {|t|\n-        alt ty::get(t).struct {\n-          ty::ty_box(mt) { must_cast = true; ty::mk_opaque_box(ccx.tcx) }\n-          _ { t }\n+    let substs = vec::map(real_substs, {|t|\n+        alt normalize_for_monomorphization(ccx.tcx, t) {\n+          some(t) { must_cast = true; t }\n+          none { t }\n         }\n     });\n-    let hash_id = @{def: fn_id, substs: substs, vtables: alt vtables {\n-      some(os) { some_vts(vec::map(*os, impl::vtable_id)) }\n-      none { no_vts }\n-    }};\n+\n+    let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n+    let hash_id = make_mono_id(ccx, fn_id, substs, vtables, some(param_uses));\n+    if vec::any(hash_id.params,\n+                {|p| alt p { mono_precise(_, _) { false } _ { true } } }) {\n+        must_cast = true;\n+    }\n     alt ccx.monomorphized.find(hash_id) {\n-      some(val) { ret {val: val, must_cast: must_cast, intrinsic: false}; }\n+      some(val) {\n+        ret {val: val, must_cast: must_cast, intrinsic: false};\n+      }\n       none {}\n     }\n \n@@ -1867,12 +1943,12 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n                  impl_self(selfty), psubsts, fn_id.node, none);\n       }\n       ast_map::node_ctor(i) {\n-        alt check ccx.tcx.items.get(i.id) {\n-          ast_map::node_item(@{node: ast::item_res(decl, _, _, _, _), _}, _) {\n+        alt check i.node {\n+          ast::item_res(decl, _, _, _, _) {\n             set_inline_hint(lldecl);\n             trans_res_ctor(ccx, pt, decl, fn_id.node, psubsts, lldecl);\n           }\n-          ast_map::node_item(@{node: ast::item_class(_, _, ctor), _}, _) {\n+          ast::item_class(_, _, ctor) {\n             ccx.sess.unimpl(\"monomorphic class constructor\");\n           }\n         }\n@@ -4606,6 +4682,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           tydescs: ty::new_ty_hash(),\n           external: util::common::new_def_hash(),\n           monomorphized: map::hashmap(hash_mono_id, {|a, b| a == b}),\n+          type_use_cache: util::common::new_def_hash(),\n           vtables: map::hashmap(hash_mono_id, {|a, b| a == b}),\n           module_data: str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),"}, {"sha": "07a9e22952bbffbc0f82109483e59552fcebd5be", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -90,6 +90,8 @@ type crate_ctxt = {\n      external: hashmap<ast::def_id, option<ast::node_id>>,\n      // Cache instances of monomorphized functions\n      monomorphized: hashmap<mono_id, ValueRef>,\n+     // Cache computed type parameter uses (see type_use.rs)\n+     type_use_cache: hashmap<ast::def_id, [type_use::type_uses]>,\n      // Cache generated vtables\n      vtables: hashmap<mono_id, ValueRef>,\n      module_data: hashmap<str, ValueRef>,\n@@ -797,15 +799,27 @@ fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n     ret llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n }\n \n-// Used to identify cached monomorphized functions\n-enum mono_vtables { some_vts([mono_id]), no_vts }\n-type mono_id = @{def: ast::def_id, substs: [ty::t], vtables: mono_vtables};\n+// Used to identify cached monomorphized functions and vtables\n+enum mono_param_id {\n+    mono_precise(ty::t, option<[mono_id]>),\n+    mono_any,\n+    mono_repr(uint /* size */, uint /* align */),\n+}\n+type mono_id = @{def: ast::def_id, params: [mono_param_id]};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let h = syntax::ast_util::hash_def_id(mi.def);\n-    for ty in mi.substs { h = (h << 2u) + ty::type_id(ty); }\n-    alt mi.vtables {\n-      some_vts(ds) { for d in ds { h = (h << 2u) + hash_mono_id(d); } }\n-      no_vts {}\n+    for param in mi.params {\n+        h = h * alt param {\n+          mono_precise(ty, vts) {\n+            let h = ty::type_id(ty);\n+            option::may(vts) {|vts|\n+                for vt in vts { h += hash_mono_id(vt); }\n+            }\n+            h\n+          }\n+          mono_any { 1u }\n+          mono_repr(sz, align) { sz * (align + 2u) }\n+        }\n     }\n     h\n }"}, {"sha": "a228e499b6042d720d3f7582e2d871865620ce05", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -187,22 +187,23 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n     }\n }\n \n-fn vtable_id(origin: typeck::vtable_origin) -> mono_id {\n+fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n     alt check origin {\n       typeck::vtable_static(impl_id, substs, sub_vtables) {\n-        @{def: impl_id, substs: substs,\n-          vtables: if (*sub_vtables).len() == 0u { no_vts }\n-                 else { some_vts(vec::map(*sub_vtables, vtable_id)) } }\n+        make_mono_id(ccx, impl_id, substs,\n+                     if (*sub_vtables).len() == 0u { none }\n+                     else { some(sub_vtables) }, none)\n       }\n       typeck::vtable_iface(iface_id, substs) {\n-        @{def: iface_id, substs: substs, vtables: no_vts}\n+        @{def: iface_id,\n+          params: vec::map(substs, {|t| mono_precise(t, none)})}\n       }\n     }\n }\n \n fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n     -> ValueRef {\n-    let hash_id = vtable_id(origin);\n+    let hash_id = vtable_id(ccx, origin);\n     alt ccx.vtables.find(hash_id) {\n       some(val) { val }\n       none {"}, {"sha": "b481371a8cbbfe26610de7bdfe3f79f584d32ce9", "filename": "src/rustc/middle/trans/type_use.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -0,0 +1,204 @@\n+// Determines the ways in which a generic function body is dependant\n+// on its type parameters. Used to aggressively reuse compiled\n+// function bodies for different types.\n+\n+// This unfortunately depends on quite a bit of knowledge about the\n+// details of the language semantics, and is likely to accidentally go\n+// out of sync when something is changed. It could be made more\n+// powerful by distinguishing between functions that only need to know\n+// the size and alignment of a type, and those that also use its\n+// drop/take glue. But this would increase the fragility of the code\n+// to a ridiculous level, and probably not catch all that many extra\n+// opportunities for reuse.\n+\n+// (An other approach to doing what this code does is to instrument\n+// the translation code to set flags whenever it does something like\n+// alloca a type or get a tydesc. This would not duplicate quite as\n+// much information, but have the disadvantage of being very\n+// invasive.)\n+\n+import std::map::hashmap;\n+import driver::session::session;\n+import metadata::csearch;\n+import syntax::ast::*, syntax::ast_util, syntax::visit;\n+import common::*;\n+\n+// FIXME distinguish between size/alignment and take/drop dependencies\n+type type_uses = uint; // Bitmask\n+const use_repr: uint = 1u; // Dependency on size/alignment and take/drop glue\n+const use_tydesc: uint = 2u; // Takes the tydesc, or compares\n+\n+type ctx = {ccx: @crate_ctxt,\n+            uses: [mutable type_uses]};\n+\n+fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n+    -> [type_uses] {\n+    alt ccx.type_use_cache.find(fn_id) {\n+      some(uses) { ret uses; }\n+      none {}\n+    }\n+    let fn_id_loc = if fn_id.crate == local_crate { fn_id }\n+                    else { base::maybe_instantiate_inline(ccx, fn_id) };\n+    // Conservatively assume full use for recursive loops\n+    ccx.type_use_cache.insert(fn_id, vec::from_elem(n_tps, 3u));\n+\n+    let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n+    alt ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).struct {\n+      ty::ty_fn({inputs, _}) {\n+        for arg in inputs {\n+            if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n+        }\n+      }\n+      _ {}\n+    }\n+\n+    // FIXME handle external native functions in a more efficient way\n+    if fn_id_loc.crate != local_crate {\n+        if csearch::item_is_intrinsic(ccx.sess.cstore, fn_id) {\n+            uint::range(0u, n_tps) {|n| cx.uses[n] |= use_tydesc;}\n+        }\n+        let uses = vec::from_mut(cx.uses);\n+        ccx.type_use_cache.insert(fn_id, uses);\n+        ret uses;\n+    }\n+    alt check ccx.tcx.items.get(fn_id_loc.node) {\n+      ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |\n+      ast_map::node_item(@{node: item_res(_, _, body, _, _), _}, _) |\n+      ast_map::node_method(@{body, _}, _, _) {\n+        handle_body(cx, body);\n+      }\n+      ast_map::node_ctor(@{node: item_res(_, _, _, _, _), _}) |\n+      ast_map::node_variant(_, _, _) {\n+        uint::range(0u, n_tps) {|n| cx.uses[n] |= use_repr;}\n+      }\n+      ast_map::node_native_item(@{node: native_item_fn(_, _), _}, abi, _) {\n+        if abi == native_abi_rust_intrinsic {\n+            uint::range(0u, n_tps) {|n| cx.uses[n] |= use_tydesc;}\n+        }\n+      }\n+      ast_map::node_ctor(@{node: item_class(_, _, ctor), _}) {\n+        ccx.sess.unimpl(\"type uses in class constructor\");\n+      }\n+    }\n+    let uses = vec::from_mut(cx.uses);\n+    ccx.type_use_cache.insert(fn_id, uses);\n+    uses\n+}\n+\n+fn type_needs(cx: ctx, use: uint, ty: ty::t) {\n+    let done = true;\n+    // Optimization -- don't descend type if all params already have this use\n+    for u in cx.uses { if u & use != use { done = false } }\n+    if !done { type_needs_inner(cx, use, ty); }\n+}\n+\n+fn type_needs_inner(cx: ctx, use: uint, ty: ty::t) {\n+    ty::maybe_walk_ty(ty) {|ty|\n+        if !ty::type_has_params(ty) { ret false; }\n+        alt ty::get(ty).struct {\n+          ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _) |\n+          ty::ty_box(_) | ty::ty_iface(_, _) { ret false; }\n+          ty::ty_enum(did, tps) {\n+            for v in *ty::enum_variants(cx.ccx.tcx, did) {\n+                for aty in v.args {\n+                    let t = ty::substitute_type_params(cx.ccx.tcx, tps, aty);\n+                    type_needs_inner(cx, use, t);\n+                }\n+            }\n+            ret false;\n+          }\n+          ty::ty_param(n, _) {\n+            cx.uses[n] |= use;\n+          }\n+          _ {}\n+        }\n+        ret true;\n+    }\n+}\n+\n+fn node_type_needs(cx: ctx, use: uint, id: node_id) {\n+    type_needs(cx, use, ty::node_id_to_type(cx.ccx.tcx, id));\n+}\n+\n+fn mark_for_expr(cx: ctx, e: @expr) {\n+    alt e.node {\n+      expr_vec(_, _) | expr_rec(_, _) | expr_tup(_) |\n+      expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n+      expr_cast(_, _) | expr_binary(add, _, _) |\n+      expr_copy(_) | expr_move(_, _) {\n+        node_type_needs(cx, use_repr, e.id);\n+      }\n+      expr_binary(op, lhs, _) {\n+        alt op {\n+          eq | lt | le | ne | ge | gt {\n+            node_type_needs(cx, use_tydesc, lhs.id)\n+          }\n+          _ {}\n+        }\n+      }\n+      expr_path(_) {\n+        option::may(cx.ccx.tcx.node_type_substs.find(e.id)) {|ts|\n+            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(e.id));\n+            vec::iter2(type_uses_for(cx.ccx, id, ts.len()), ts) {|uses, subst|\n+                type_needs(cx, uses, subst)\n+            }\n+        }\n+      }\n+      expr_fn(_, _, _, _) | expr_fn_block(_, _) {\n+        alt ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n+          proto_bare | proto_any | proto_uniq {}\n+          proto_box | proto_block {\n+            for fv in *freevars::get_freevars(cx.ccx.tcx, e.id) {\n+                let node_id = ast_util::def_id_of_def(fv.def).node;\n+                node_type_needs(cx, use_repr, node_id);\n+            }\n+          }\n+        }\n+      }\n+      expr_assign(val, _) | expr_swap(val, _) | expr_assign_op(_, val, _) |\n+      expr_ret(some(val)) | expr_be(val) {\n+        node_type_needs(cx, use_repr, val.id);\n+      }\n+      expr_index(base, _) | expr_field(base, _, _) {\n+        // FIXME could be more careful and not count fields\n+        // after the chosen field\n+        let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n+        type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n+      }\n+      expr_log(_, _, val) {\n+        node_type_needs(cx, use_tydesc, val.id);\n+      }\n+      expr_for(_, _, _) | expr_do_while(_, _) | expr_alt(_, _, _) |\n+      expr_block(_) | expr_if(_, _, _) | expr_while(_, _) |\n+      expr_fail(_) | expr_break | expr_cont | expr_unary(_, _) |\n+      expr_lit(_) | expr_assert(_) | expr_check(_, _) |\n+      expr_if_check(_, _, _) | expr_mac(_) | expr_addr_of(_, _) |\n+      expr_ret(_) | expr_loop(_) | expr_call(_, _, _) | expr_bind(_, _) {}\n+    }\n+}\n+\n+fn handle_body(cx: ctx, body: blk) {\n+    let v = visit::mk_vt(@{\n+        visit_expr: {|e, cx, v|\n+            visit::visit_expr(e, cx, v);\n+            mark_for_expr(cx, e);\n+        },\n+        visit_local: {|l, cx, v|\n+            visit::visit_local(l, cx, v);\n+            node_type_needs(cx, use_repr, l.node.id);\n+        },\n+        visit_pat: {|p, cx, v|\n+            visit::visit_pat(p, cx, v);\n+            node_type_needs(cx, use_repr, p.id);\n+        },\n+        visit_block: {|b, cx, v|\n+            visit::visit_block(b, cx, v);\n+            option::may(b.node.expr) {|e|\n+                node_type_needs(cx, use_repr, e.id);\n+            }\n+        },\n+        visit_item: {|_i, _cx, _v|}\n+        with *visit::default_visitor()\n+    });\n+    v.visit_block(body, cx, v);\n+}"}, {"sha": "74dc8dde5fcc058b8514406345a14cc696d0d2d7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -23,7 +23,6 @@ export class_items_as_fields;\n export constr;\n export constr_general;\n export constr_table;\n-export count_ty_params;\n export ctxt;\n export def_has_ty_params;\n export expr_has_ty_params;\n@@ -124,7 +123,7 @@ export unify_mode;\n export set_default_mode;\n export unify;\n export variant_info;\n-export walk_ty;\n+export walk_ty, maybe_walk_ty;\n export occurs_check;\n export closure_kind;\n export ck_block;\n@@ -540,34 +539,38 @@ fn default_arg_mode_for_ty(ty: ty::t) -> ast::rmode {\n     else { ast::by_ref }\n }\n \n-fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n+fn walk_ty(ty: t, f: fn(t)) {\n+    maybe_walk_ty(ty, {|t| f(t); true});\n+}\n+\n+fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n+    if !f(ty) { ret; }\n     alt get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_send_type | ty_type | ty_opaque_box |\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {}\n       ty_box(tm) | ty_vec(tm) | ty_ptr(tm) | ty_rptr(_, tm) {\n-        walk_ty(cx, tm.ty, f);\n+        maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, subtys) | ty_iface(_, subtys) | ty_class(_, subtys)\n        | ty_self(subtys) {\n-        for subty: t in subtys { walk_ty(cx, subty, f); }\n+        for subty: t in subtys { maybe_walk_ty(subty, f); }\n       }\n       ty_rec(fields) {\n-        for fl: field in fields { walk_ty(cx, fl.mt.ty, f); }\n+        for fl: field in fields { maybe_walk_ty(fl.mt.ty, f); }\n       }\n-      ty_tup(ts) { for tt in ts { walk_ty(cx, tt, f); } }\n+      ty_tup(ts) { for tt in ts { maybe_walk_ty(tt, f); } }\n       ty_fn(ft) {\n-        for a: arg in ft.inputs { walk_ty(cx, a.ty, f); }\n-        walk_ty(cx, ft.output, f);\n+        for a: arg in ft.inputs { maybe_walk_ty(a.ty, f); }\n+        maybe_walk_ty(ft.output, f);\n       }\n       ty_res(_, sub, tps) {\n-        walk_ty(cx, sub, f);\n-        for tp: t in tps { walk_ty(cx, tp, f); }\n+        maybe_walk_ty(sub, f);\n+        for tp: t in tps { maybe_walk_ty(tp, f); }\n       }\n-      ty_constr(sub, _) { walk_ty(cx, sub, f); }\n-      ty_uniq(tm) { walk_ty(cx, tm.ty, f); }\n+      ty_constr(sub, _) { maybe_walk_ty(sub, f); }\n+      ty_uniq(tm) { maybe_walk_ty(tm.ty, f); }\n     }\n-    f(ty);\n }\n \n enum fold_mode {\n@@ -1090,9 +1093,9 @@ fn type_param(ty: t) -> option<uint> {\n \n // Returns a vec of all the type variables\n // occurring in t. It may contain duplicates.\n-fn vars_in_type(cx: ctxt, ty: t) -> [int] {\n+fn vars_in_type(ty: t) -> [int] {\n     let rslt = [];\n-    walk_ty(cx, ty) {|ty|\n+    walk_ty(ty) {|ty|\n         alt get(ty).struct { ty_var(v) { rslt += [v]; } _ { } }\n     }\n     rslt\n@@ -1293,22 +1296,6 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n     ret cx.node_type_substs.contains_key(id);\n }\n \n-// Returns the number of distinct type parameters in the given type.\n-fn count_ty_params(cx: ctxt, ty: t) -> uint {\n-    let param_indices = [];\n-    walk_ty(cx, ty) {|t|\n-        alt get(t).struct {\n-          ty_param(param_idx, _) {\n-            if !vec::any(param_indices, {|i| i == param_idx}) {\n-                param_indices += [param_idx];\n-            }\n-          }\n-          _ {}\n-        }\n-    }\n-    vec::len(param_indices)\n-}\n-\n // Type accessors for substructures of types\n fn ty_fn_args(fty: t) -> [arg] {\n     alt get(fty).struct {\n@@ -1445,7 +1432,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: int, rt: t) {\n     if !type_has_vars(rt) { ret; }\n \n     // Occurs check!\n-    if vec::contains(vars_in_type(tcx, rt), vid) {\n+    if vec::contains(vars_in_type(rt), vid) {\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die.\n@@ -2334,9 +2321,12 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::init(*path) + [ast_map::path_name(variant.node.name)]\n           }\n \n+          ast_map::node_ctor(i) {\n+            item_path(cx, ast_util::local_def(i.id))\n+          }\n+\n           ast_map::node_expr(_) | ast_map::node_arg(_, _) |\n-          ast_map::node_local(_) | ast_map::node_ctor(_) |\n-          ast_map::node_export(_, _) {\n+          ast_map::node_local(_) | ast_map::node_export(_, _) {\n             cx.sess.bug(#fmt[\"cannot find item_path for node %?\", node]);\n           }\n         }"}, {"sha": "2df5d1b158e44fc429f80780e018fa52c4392c4e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -3398,7 +3398,7 @@ mod vtable {\n                                 let subres = lookup_vtables(fcx, isc, sp,\n                                                             im_bs, params);\n                                 found = some(vtable_static(im.did, params,\n-                                                         subres));\n+                                                           subres));\n                             }\n                           }\n                           result::err(_) {}"}, {"sha": "01b7b1ea4f2cae5c7af82da02995a363f72838f7", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -27,6 +27,7 @@ mod middle {\n         mod native;\n         mod shape;\n         mod debuginfo;\n+        mod type_use;\n     }\n     mod ty;\n     mod ast_map;"}, {"sha": "5f92d533f3238f765b819ec488a429bd263e03e8", "filename": "src/rustc/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ed441a058ac517775e065405ba7c532d06d0f7/src%2Frustc%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fvisit.rs?ref=24ed441a058ac517775e065405ba7c532d06d0f7", "patch": "@@ -304,7 +304,7 @@ fn visit_exprs<E>(exprs: [@expr], e: E, v: vt<E>) {\n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     alt m.node {\n       ast::mac_invoc(pth, arg, body) {\n-        option::map(arg) {|arg| visit_expr(arg, e, v)}; }\n+        option::map(arg) {|arg| v.visit_expr(arg, e, v)}; }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n       ast::mac_embed_block(blk) { v.visit_block(blk, e, v); }\n       ast::mac_ellipsis { }"}]}