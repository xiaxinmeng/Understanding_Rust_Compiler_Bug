{"sha": "a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3N2UyYWQ1MzM4ZTBjNDE3ZGQ1YzRmNTk1OGI4YWFiNTI2MzIyZDY=", "commit": {"author": {"name": "Th\u00e9o Degioanni", "email": "degiotheo@gmail.com", "date": "2021-06-09T22:34:58Z"}, "committer": {"name": "Th\u00e9o Degioanni", "email": "degiotheo@gmail.com", "date": "2021-06-22T21:18:26Z"}, "message": "implemented separate_const_switch MIR opt\n\nun-update itertools\n\nimprove predecessor amount short-circuiting\n\ncleanup and comments\n\nsomewhat improved drawing", "tree": {"sha": "2dbb61018ea9a287f3cdfb2cb511c3cfc7e736a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dbb61018ea9a287f3cdfb2cb511c3cfc7e736a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "html_url": "https://github.com/rust-lang/rust/commit/a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/comments", "author": {"login": "Moxinilian", "id": 30992420, "node_id": "MDQ6VXNlcjMwOTkyNDIw", "avatar_url": "https://avatars.githubusercontent.com/u/30992420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Moxinilian", "html_url": "https://github.com/Moxinilian", "followers_url": "https://api.github.com/users/Moxinilian/followers", "following_url": "https://api.github.com/users/Moxinilian/following{/other_user}", "gists_url": "https://api.github.com/users/Moxinilian/gists{/gist_id}", "starred_url": "https://api.github.com/users/Moxinilian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Moxinilian/subscriptions", "organizations_url": "https://api.github.com/users/Moxinilian/orgs", "repos_url": "https://api.github.com/users/Moxinilian/repos", "events_url": "https://api.github.com/users/Moxinilian/events{/privacy}", "received_events_url": "https://api.github.com/users/Moxinilian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Moxinilian", "id": 30992420, "node_id": "MDQ6VXNlcjMwOTkyNDIw", "avatar_url": "https://avatars.githubusercontent.com/u/30992420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Moxinilian", "html_url": "https://github.com/Moxinilian", "followers_url": "https://api.github.com/users/Moxinilian/followers", "following_url": "https://api.github.com/users/Moxinilian/following{/other_user}", "gists_url": "https://api.github.com/users/Moxinilian/gists{/gist_id}", "starred_url": "https://api.github.com/users/Moxinilian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Moxinilian/subscriptions", "organizations_url": "https://api.github.com/users/Moxinilian/orgs", "repos_url": "https://api.github.com/users/Moxinilian/repos", "events_url": "https://api.github.com/users/Moxinilian/events{/privacy}", "received_events_url": "https://api.github.com/users/Moxinilian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8be3162d734f3583b240977615f3e1bae6b364a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8be3162d734f3583b240977615f3e1bae6b364a", "html_url": "https://github.com/rust-lang/rust/commit/b8be3162d734f3583b240977615f3e1bae6b364a"}], "stats": {"total": 1055, "additions": 1055, "deletions": 0}, "files": [{"sha": "bbe83aa3bd8adc3ee194d4aeabc618c737a486e0", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -48,6 +48,7 @@ pub mod remove_unneeded_drops;\n pub mod remove_zsts;\n pub mod required_consts;\n pub mod rustc_peek;\n+pub mod separate_const_switch;\n pub mod simplify;\n pub mod simplify_branches;\n pub mod simplify_comparison_integral;\n@@ -501,6 +502,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // inst combine is after MatchBranchSimplification to clean up Ne(_1, false)\n         &multiple_return_terminators::MultipleReturnTerminators,\n         &instcombine::InstCombine,\n+        &separate_const_switch::SeparateConstSwitch,\n         &const_prop::ConstProp,\n         &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n         &early_otherwise_branch::EarlyOtherwiseBranch,"}, {"sha": "87cd27984a073a214cb00c23d26143fa4419d598", "filename": "compiler/rustc_mir/src/transform/separate_const_switch.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fseparate_const_switch.rs?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,343 @@\n+//! A pass that duplicates switch-terminated blocks\n+//! into a new copy for each predecessor, provided\n+//! the predecessor sets the value being switched\n+//! over to a constant.\n+//!\n+//! The purpose of this pass is to help constant\n+//! propagation passes to simplify the switch terminator\n+//! of the copied blocks into gotos when some predecessors\n+//! statically determine the output of switches.\n+//!\n+//! ```text\n+//!     x = 12 ---              ---> something\n+//!               \\            / 12\n+//!                --> switch x\n+//!               /            \\ otherwise\n+//!     x = y  ---              ---> something else\n+//! ```\n+//! becomes\n+//! ```text\n+//!     x = 12 ---> switch x ------> something\n+//!                          \\ / 12\n+//!                           X\n+//!                          / \\ otherwise\n+//!     x = y  ---> switch x ------> something else\n+//! ```\n+//! so it can hopefully later be turned by another pass into\n+//! ```text\n+//!     x = 12 --------------------> something\n+//!                            / 12\n+//!                           /\n+//!                          /   otherwise\n+//!     x = y  ---- switch x ------> something else\n+//! ```\n+//!\n+//! This optimization is meant to cover simple cases\n+//! like `?` desugaring. For now, it thus focuses on\n+//! simplicity rather than completeness (it notably\n+//! sometimes duplicates abusively).\n+\n+use crate::transform::MirPass;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+use smallvec::SmallVec;\n+\n+pub struct SeparateConstSwitch;\n+\n+impl<'tcx> MirPass<'tcx> for SeparateConstSwitch {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.mir_opt_level() < 4 {\n+            return;\n+        }\n+\n+        // If execution did something, applying a simplification layer\n+        // helps later passes optimize the copy away.\n+        if separate_const_switch(body) > 0 {\n+            super::simplify::simplify_cfg(tcx, body);\n+        }\n+    }\n+}\n+\n+/// Returns the amount of blocks that were duplicated\n+pub fn separate_const_switch<'tcx>(body: &mut Body<'tcx>) -> usize {\n+    let mut new_blocks: SmallVec<[(BasicBlock, BasicBlock); 6]> = SmallVec::new();\n+    let predecessors = body.predecessors();\n+    'block_iter: for (block_id, block) in body.basic_blocks().iter_enumerated() {\n+        if let TerminatorKind::SwitchInt {\n+            discr: Operand::Copy(switch_place) | Operand::Move(switch_place),\n+            ..\n+        } = block.terminator().kind\n+        {\n+            // If the block is on an unwind path, do not\n+            // apply the optimization as unwind paths\n+            // rely on a unique parent invariant\n+            if block.is_cleanup {\n+                continue 'block_iter;\n+            }\n+\n+            // If the block has fewer than 2 predecessors, ignore it\n+            // we could maybe chain blocks that have exactly one\n+            // predecessor, but for now we ignore that\n+            if predecessors[block_id].len() < 2 {\n+                continue 'block_iter;\n+            }\n+\n+            // First, let's find a non-const place\n+            // that determines the result of the switch\n+            if let Some(switch_place) = find_determining_place(switch_place, block) {\n+                // We now have an input place for which it would\n+                // be interesting if predecessors assigned it from a const\n+\n+                let mut predecessors_left = predecessors[block_id].len();\n+                'predec_iter: for predecessor_id in predecessors[block_id].iter().copied() {\n+                    let predecessor = &body.basic_blocks()[predecessor_id];\n+\n+                    // First we make sure the predecessor jumps\n+                    // in a reasonable way\n+                    match &predecessor.terminator().kind {\n+                        // The following terminators are\n+                        // unconditionally valid\n+                        TerminatorKind::Goto { .. } | TerminatorKind::SwitchInt { .. } => {}\n+\n+                        TerminatorKind::FalseEdge { real_target, .. } => {\n+                            if *real_target != block_id {\n+                                continue 'predec_iter;\n+                            }\n+                        }\n+\n+                        // The following terminators are not allowed\n+                        TerminatorKind::Resume\n+                        | TerminatorKind::Drop { .. }\n+                        | TerminatorKind::DropAndReplace { .. }\n+                        | TerminatorKind::Call { .. }\n+                        | TerminatorKind::Assert { .. }\n+                        | TerminatorKind::FalseUnwind { .. }\n+                        | TerminatorKind::Yield { .. }\n+                        | TerminatorKind::Abort\n+                        | TerminatorKind::Return\n+                        | TerminatorKind::Unreachable\n+                        | TerminatorKind::InlineAsm { .. }\n+                        | TerminatorKind::GeneratorDrop => {\n+                            continue 'predec_iter;\n+                        }\n+                    }\n+\n+                    if is_likely_const(switch_place, predecessor) {\n+                        new_blocks.push((predecessor_id, block_id));\n+                        predecessors_left -= 1;\n+                        if predecessors_left < 2 {\n+                            // If the original block only has one predecessor left,\n+                            // we have nothing left to do\n+                            break 'predec_iter;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Once the analysis is done, perform the duplication\n+    let body_span = body.span;\n+    let copied_blocks = new_blocks.len();\n+    let blocks = body.basic_blocks_mut();\n+    for (pred_id, target_id) in new_blocks {\n+        let new_block = blocks[target_id].clone();\n+        let new_block_id = blocks.push(new_block);\n+        let terminator = blocks[pred_id].terminator_mut();\n+\n+        match terminator.kind {\n+            TerminatorKind::Goto { ref mut target } => {\n+                *target = new_block_id;\n+            }\n+\n+            TerminatorKind::FalseEdge { ref mut real_target, .. } => {\n+                if *real_target == target_id {\n+                    *real_target = new_block_id;\n+                }\n+            }\n+\n+            TerminatorKind::SwitchInt { ref mut targets, .. } => {\n+                targets.all_targets_mut().iter_mut().for_each(|x| {\n+                    if *x == target_id {\n+                        *x = new_block_id;\n+                    }\n+                });\n+            }\n+\n+            TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::InlineAsm { .. }\n+            | TerminatorKind::Yield { .. } => {\n+                span_bug!(\n+                    body_span,\n+                    \"basic block terminator had unexpected kind {:?}\",\n+                    &terminator.kind\n+                )\n+            }\n+        }\n+    }\n+\n+    copied_blocks\n+}\n+\n+/// This function describes a rough heuristic guessing\n+/// whether a place is last set with a const within the block.\n+/// Notably, it will be overly pessimistic in cases that are already\n+/// not handled by `separate_const_switch`.\n+fn is_likely_const<'tcx>(mut tracked_place: Place<'tcx>, block: &BasicBlockData<'tcx>) -> bool {\n+    for statement in block.statements.iter().rev() {\n+        match &statement.kind {\n+            StatementKind::Assign(assign) => {\n+                if assign.0 == tracked_place {\n+                    match assign.1 {\n+                        // These rvalues are definitely constant\n+                        Rvalue::Use(Operand::Constant(_))\n+                        | Rvalue::Ref(_, _, _)\n+                        | Rvalue::AddressOf(_, _)\n+                        | Rvalue::Cast(_, Operand::Constant(_), _)\n+                        | Rvalue::NullaryOp(_, _)\n+                        | Rvalue::UnaryOp(_, Operand::Constant(_)) => return true,\n+\n+                        // These rvalues make things ambiguous\n+                        Rvalue::Repeat(_, _)\n+                        | Rvalue::ThreadLocalRef(_)\n+                        | Rvalue::Len(_)\n+                        | Rvalue::BinaryOp(_, _)\n+                        | Rvalue::CheckedBinaryOp(_, _)\n+                        | Rvalue::Aggregate(_, _) => return false,\n+\n+                        // These rvalues move the place to track\n+                        Rvalue::Cast(_, Operand::Copy(place) | Operand::Move(place), _)\n+                        | Rvalue::Use(Operand::Copy(place) | Operand::Move(place))\n+                        | Rvalue::UnaryOp(_, Operand::Copy(place) | Operand::Move(place))\n+                        | Rvalue::Discriminant(place) => tracked_place = place,\n+                    }\n+                }\n+            }\n+\n+            // If the discriminant is set, it is always set\n+            // as a constant, so the job is done.\n+            // As we are **ignoring projections**, if the place\n+            // we are tracking sees its discriminant be set,\n+            // that means we had to be tracking the discriminant\n+            // specifically (as it is impossible to switch over\n+            // an enum directly, and if we were switching over\n+            // its content, we would have had to at least cast it to\n+            // some variant first)\n+            StatementKind::SetDiscriminant { place, .. } => {\n+                if **place == tracked_place {\n+                    return true;\n+                }\n+            }\n+\n+            // If inline assembly is found, we probably should\n+            // not try to analyze the code\n+            StatementKind::LlvmInlineAsm(_) => return false,\n+\n+            // These statements have no influence on the place\n+            // we are interested in\n+            StatementKind::FakeRead(_)\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::Retag(_, _)\n+            | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::Coverage(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::CopyNonOverlapping(_)\n+            | StatementKind::Nop => {}\n+        }\n+    }\n+\n+    // If no good reason for the place to be const is found,\n+    // give up. We could maybe go up predecessors, but in\n+    // most cases giving up now should be sufficient.\n+    false\n+}\n+\n+/// Finds a unique place that entirely determines the value\n+/// of `switch_place`, if it exists. This is only a heuristic.\n+/// Ideally we would like to track multiple determining places\n+/// for some edge cases, but one is enough for a lot of situations.\n+fn find_determining_place<'tcx>(\n+    mut switch_place: Place<'tcx>,\n+    block: &BasicBlockData<'tcx>,\n+) -> Option<Place<'tcx>> {\n+    for statement in block.statements.iter().rev() {\n+        match &statement.kind {\n+            StatementKind::Assign(op) => {\n+                if op.0 != switch_place {\n+                    continue;\n+                }\n+\n+                match op.1 {\n+                    // The following rvalues move the place\n+                    // that may be const in the predecessor\n+                    Rvalue::Use(Operand::Move(new) | Operand::Copy(new))\n+                    | Rvalue::UnaryOp(_, Operand::Copy(new) | Operand::Move(new))\n+                    | Rvalue::Cast(_, Operand::Move(new) | Operand::Copy(new), _)\n+                    | Rvalue::Repeat(Operand::Move(new) | Operand::Copy(new), _)\n+                    | Rvalue::Discriminant(new)\n+                    => switch_place = new,\n+\n+                    // The following rvalues might still make the block\n+                    // be valid but for now we reject them\n+                    Rvalue::Len(_)\n+                    | Rvalue::Ref(_, _, _)\n+                    | Rvalue::BinaryOp(_, _)\n+                    | Rvalue::CheckedBinaryOp(_, _)\n+                    | Rvalue::Aggregate(_, _)\n+\n+                    // The following rvalues definitely mean we cannot\n+                    // or should not apply this optimization\n+                    | Rvalue::Use(Operand::Constant(_))\n+                    | Rvalue::Repeat(Operand::Constant(_), _)\n+                    | Rvalue::ThreadLocalRef(_)\n+                    | Rvalue::AddressOf(_, _)\n+                    | Rvalue::NullaryOp(_, _)\n+                    | Rvalue::UnaryOp(_, Operand::Constant(_))\n+                    | Rvalue::Cast(_, Operand::Constant(_), _)\n+                    => return None,\n+                }\n+            }\n+\n+            // These statements have no influence on the place\n+            // we are interested in\n+            StatementKind::FakeRead(_)\n+            | StatementKind::StorageLive(_)\n+            | StatementKind::StorageDead(_)\n+            | StatementKind::Retag(_, _)\n+            | StatementKind::AscribeUserType(_, _)\n+            | StatementKind::Coverage(_)\n+            | StatementKind::CopyNonOverlapping(_)\n+            | StatementKind::Nop => {}\n+\n+            // If inline assembly is found, we probably should\n+            // not try to analyze the code\n+            StatementKind::LlvmInlineAsm(_) => return None,\n+\n+            // If the discriminant is set, it is always set\n+            // as a constant, so the job is already done.\n+            // As we are **ignoring projections**, if the place\n+            // we are tracking sees its discriminant be set,\n+            // that means we had to be tracking the discriminant\n+            // specifically (as it is impossible to switch over\n+            // an enum directly, and if we were switching over\n+            // its content, we would have had to at least cast it to\n+            // some variant first)\n+            StatementKind::SetDiscriminant { place, .. } => {\n+                if **place == switch_place {\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    Some(switch_place)\n+}"}, {"sha": "57299cee7b726782b78088124bfff9ee901cd54f", "filename": "src/test/mir-opt/separate_const_switch.identity.ConstProp.diff", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.ConstProp.diff?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,140 @@\n+- // MIR for `identity` before ConstProp\n++ // MIR for `identity` after ConstProp\n+  \n+  fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:28:13: 28:14\n+      let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:28:37: 28:53\n+      let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+      let mut _5: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _7: !;                       // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _8: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      scope 1 {\n+          debug residual => _6;            // in scope 1 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          scope 2 {\n+              scope 8 (inlined <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  debug residual => _8;    // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let _16: i32;            // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _17: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _18: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  scope 9 {\n+                      debug e => _16;      // in scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      scope 10 (inlined <i32 as From<i32>>::from) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                          debug t => _18;  // in scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      scope 3 {\n+          debug val => _9;                 // in scope 3 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 4 {\n+          }\n+      }\n+      scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+          debug self => _4;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _10: isize;              // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _11: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _12: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _13: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _14: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _15: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 6 {\n+              debug v => _11;              // in scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+          scope 7 {\n+              debug e => _13;              // in scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          StorageLive(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _10 = discriminant(_4);          // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          switchInt(move _10) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+      bb1: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _9 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _2 = _9;                         // scope 4 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+      bb2: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _8 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _16 = move ((_8 as Err).0: i32); // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _18 = move _16;                  // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _17 = move _18;                  // scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_0 as Err).0: i32) = move _17; // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_0) = 1;            // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+      bb3: {\n+          StorageLive(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _13 = move ((_4 as Err).0: i32); // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _15 = move _13;                  // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_14 as Err).0: i32) = move _15; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_14) = 1;           // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _14; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 1;            // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = const 1_isize;              // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(const 1_isize) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  \n+      bb4: {\n+          unreachable;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+      bb5: {\n+          StorageLive(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _11 = move ((_4 as Ok).0: i32);  // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _12 = move _11;                  // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Continue).0: i32) = move _12; // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 0;            // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = const 0_isize;              // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(const 0_isize) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  }\n+  "}, {"sha": "dee45c58403832435554e4c842826f9844fea71f", "filename": "src/test/mir-opt/separate_const_switch.identity.PreCodegen.after.mir", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.PreCodegen.after.mir?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,122 @@\n+// MIR for `identity` after PreCodegen\n+\n+fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n+    debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:28:13: 28:14\n+    let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:28:37: 28:53\n+    let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+    let _5: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+    let mut _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+    let _7: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    scope 1 {\n+        debug residual => _5;            // in scope 1 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        scope 2 {\n+            scope 8 (inlined <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                debug residual => _6;    // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                let _14: i32;            // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                let mut _15: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                let mut _16: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                scope 9 {\n+                    debug e => _14;      // in scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                    scope 10 (inlined <i32 as From<i32>>::from) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                        debug t => _16;  // in scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    scope 3 {\n+        debug val => _7;                 // in scope 3 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        scope 4 {\n+        }\n+    }\n+    scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+        debug self => _4;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _8: isize;               // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let _9: i32;                     // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _10: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let _11: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _12: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        let mut _13: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        scope 6 {\n+            debug v => _9;               // in scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        }\n+        scope 7 {\n+            debug e => _11;              // in scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+        _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+        StorageLive(_8);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _8 = discriminant(_4);           // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        switchInt(move _8) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    }\n+\n+    bb1: {\n+        StorageLive(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _11 = move ((_4 as Err).0: i32); // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_12);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_13);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _13 = move _11;                  // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_12 as Err).0: i32) = move _13; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_12) = 1;           // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_13);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _12; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_3) = 1;            // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_12);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_8);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_5);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        _5 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_6);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        _6 = _5;                         // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_14);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _14 = move ((_6 as Err).0: i32); // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_15);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_16);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _16 = move _14;                  // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _15 = move _16;                  // scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_16);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_0 as Err).0: i32) = move _15; // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_0) = 1;            // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_15);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_14);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_6);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageDead(_5);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+        StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+        return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+    }\n+\n+    bb2: {\n+        unreachable;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+    }\n+\n+    bb3: {\n+        StorageLive(_9);                 // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _9 = move ((_4 as Ok).0: i32);   // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageLive(_10);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _10 = move _9;                   // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        ((_3 as Continue).0: i32) = move _10; // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        discriminant(_3) = 0;            // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_10);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_9);                 // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_8);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        StorageLive(_7);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _7 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        _2 = _7;                         // scope 4 at $DIR/separate_const_switch.rs:29:8: 29:10\n+        StorageDead(_7);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+        ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+        discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+        StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+        return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+    }\n+}"}, {"sha": "4bfd0842db08407280e5065aeab7475e5386d8bf", "filename": "src/test/mir-opt/separate_const_switch.identity.SeparateConstSwitch.diff", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,150 @@\n+- // MIR for `identity` before SeparateConstSwitch\n++ // MIR for `identity` after SeparateConstSwitch\n+  \n+  fn identity(_1: Result<i32, i32>) -> Result<i32, i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:28:13: 28:14\n+      let mut _0: std::result::Result<i32, i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:28:37: 28:53\n+      let mut _2: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, i32>, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      let mut _4: std::result::Result<i32, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+      let mut _5: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _6: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _7: !;                       // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let mut _8: std::result::Result<std::convert::Infallible, i32>; // in scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      scope 1 {\n+          debug residual => _6;            // in scope 1 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          scope 2 {\n+              scope 8 (inlined <Result<i32, i32> as FromResidual<Result<Infallible, i32>>>::from_residual) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  debug residual => _8;    // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let _16: i32;            // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _17: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  let mut _18: i32;        // in scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                  scope 9 {\n+                      debug e => _16;      // in scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      scope 10 (inlined <i32 as From<i32>>::from) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+                          debug t => _18;  // in scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+      scope 3 {\n+          debug val => _9;                 // in scope 3 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 4 {\n+          }\n+      }\n+      scope 5 (inlined <Result<i32, i32> as Try>::branch) { // at $DIR/separate_const_switch.rs:29:8: 29:10\n+          debug self => _4;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _10: isize;              // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _11: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _12: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let _13: i32;                    // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _14: std::result::Result<std::convert::Infallible, i32>; // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          let mut _15: i32;                // in scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          scope 6 {\n+              debug v => _11;              // in scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+          scope 7 {\n+              debug e => _13;              // in scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_3);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:9\n+          StorageLive(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _10 = discriminant(_4);          // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         switchInt(move _10) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         switchInt(move _10) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+      bb1: {\n+-         StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-         switchInt(move _5) -> [0_isize: bb2, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+-     }\n+- \n+-     bb2: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _9 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _2 = _9;                         // scope 4 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:29:5: 29:11\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+-     bb3: {\n++     bb2: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          _8 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageLive(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _16 = move ((_8 as Err).0: i32); // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _18 = move _16;                  // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _17 = move _18;                  // scope 10 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_18);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_0 as Err).0: i32) = move _17; // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_0) = 1;            // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_17);                // scope 9 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_16);                // scope 8 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:29:10: 29:11\n+          StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:30:1: 30:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:30:2: 30:2\n+      }\n+  \n+-     bb4: {\n++     bb3: {\n+          StorageLive(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _13 = move ((_4 as Err).0: i32); // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _15 = move _13;                  // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_14 as Err).0: i32) = move _15; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_14) = 1;           // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_15);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _14; // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 1;            // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_14);                // scope 7 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_13);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         goto -> bb1;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  \n+-     bb5: {\n++     bb4: {\n+          unreachable;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+      }\n+  \n+-     bb6: {\n++     bb5: {\n+          StorageLive(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _11 = move ((_4 as Ok).0: i32);  // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageLive(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          _12 = move _11;                  // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          ((_3 as Continue).0: i32) = move _12; // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          discriminant(_3) = 0;            // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_12);                // scope 6 at $DIR/separate_const_switch.rs:29:8: 29:10\n+          StorageDead(_11);                // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n+-         goto -> bb1;                     // scope 5 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:29:8: 29:10\n++         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n++         switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:29:9: 29:10\n+      }\n+  }\n+  "}, {"sha": "5d82acf4d60905259414f168367a26ac7b818044", "filename": "src/test/mir-opt/separate_const_switch.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.rs?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,35 @@\n+#![feature(control_flow_enum)]\n+#![feature(try_trait_v2)]\n+\n+use std::ops::ControlFlow;\n+\n+// EMIT_MIR separate_const_switch.too_complex.SeparateConstSwitch.diff\n+// EMIT_MIR separate_const_switch.too_complex.ConstProp.diff\n+// EMIT_MIR separate_const_switch.too_complex.PreCodegen.after.mir\n+fn too_complex(x: Result<i32, usize>) -> Option<i32> {\n+    // The pass should break the outer match into\n+    // two blocks that only have one parent each.\n+    // Parents are one of the two branches of the first\n+    // match, so a later pass can propagate constants.\n+    match {\n+        match x {\n+            Ok(v) => ControlFlow::Continue(v),\n+            Err(r) => ControlFlow::Break(r),\n+        }\n+    } {\n+        ControlFlow::Continue(v) => Some(v),\n+        ControlFlow::Break(r) => None,\n+    }\n+}\n+\n+// EMIT_MIR separate_const_switch.identity.SeparateConstSwitch.diff\n+// EMIT_MIR separate_const_switch.identity.ConstProp.diff\n+// EMIT_MIR separate_const_switch.identity.PreCodegen.after.mir\n+fn identity(x: Result<i32, i32>) -> Result<i32, i32> {\n+    Ok(x?)\n+}\n+\n+fn main() {\n+    too_complex(Ok(0));\n+    identity(Ok(0));\n+}"}, {"sha": "973b7838eca35808a222861da4736ce815043136", "filename": "src/test/mir-opt/separate_const_switch.too_complex.ConstProp.diff", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.ConstProp.diff?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,91 @@\n+- // MIR for `too_complex` before ConstProp\n++ // MIR for `too_complex` after ConstProp\n+  \n+  fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:9:16: 9:17\n+      let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:9:42: 9:53\n+      let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+      let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:16:44: 16:45\n+      let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      let mut _7: usize;                   // in scope 0 at $DIR/separate_const_switch.rs:17:42: 17:43\n+      let mut _8: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      let mut _10: i32;                    // in scope 0 at $DIR/separate_const_switch.rs:20:42: 20:43\n+      let _11: usize;                      // in scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      scope 1 {\n+          debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      }\n+      scope 2 {\n+          debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      }\n+      scope 3 {\n+          debug v => _9;                   // in scope 3 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      }\n+      scope 4 {\n+          debug r => _11;                  // in scope 4 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+          _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+          switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      }\n+  \n+      bb1: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:43: 17:44\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:43: 17:44\n+-         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+-         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         _8 = const 1_isize;              // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(const 1_isize) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+      bb2: {\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:45: 16:46\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:45: 16:46\n+-         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+-         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         _8 = const 0_isize;              // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(const 0_isize) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+      bb3: {\n+          StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          _11 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:21:34: 21:38\n+          StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:37: 21:38\n+          goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+      bb4: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          _9 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          StorageLive(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          _10 = _9;                        // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          ((_0 as Some).0: i32) = move _10; // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          StorageDead(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:43: 20:44\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:43: 20:44\n+          goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+      bb5: {\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:23:1: 23:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:23:2: 23:2\n+      }\n+  }\n+  "}, {"sha": "cc941f251cea5fadf07a36229ea5ccae2312cf52", "filename": "src/test/mir-opt/separate_const_switch.too_complex.PreCodegen.after.mir", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.PreCodegen.after.mir?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,74 @@\n+// MIR for `too_complex` after PreCodegen\n+\n+fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n+    debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:9:16: 9:17\n+    let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:9:42: 9:53\n+    let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+    let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+    let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+    let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:16:44: 16:45\n+    let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+    let mut _7: usize;                   // in scope 0 at $DIR/separate_const_switch.rs:17:42: 17:43\n+    let _8: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+    let mut _9: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:20:42: 20:43\n+    let _10: usize;                      // in scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+    scope 1 {\n+        debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:16:16: 16:17\n+    }\n+    scope 2 {\n+        debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:17:17: 17:18\n+    }\n+    scope 3 {\n+        debug v => _8;                   // in scope 3 at $DIR/separate_const_switch.rs:20:31: 20:32\n+    }\n+    scope 4 {\n+        debug r => _10;                  // in scope 4 at $DIR/separate_const_switch.rs:21:28: 21:29\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+        _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+        switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+    }\n+\n+    bb1: {\n+        StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+        _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+        StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+        _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+        ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+        discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+        StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:43: 17:44\n+        StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:43: 17:44\n+        StorageLive(_10);                // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+        _10 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+        discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:21:34: 21:38\n+        StorageDead(_10);                // scope 0 at $DIR/separate_const_switch.rs:21:37: 21:38\n+        goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+    }\n+\n+    bb2: {\n+        StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+        _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+        StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+        _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+        ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+        discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+        StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:45: 16:46\n+        StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:45: 16:46\n+        StorageLive(_8);                 // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+        _8 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+        StorageLive(_9);                 // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+        _9 = _8;                         // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+        ((_0 as Some).0: i32) = move _9; // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+        discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+        StorageDead(_9);                 // scope 3 at $DIR/separate_const_switch.rs:20:43: 20:44\n+        StorageDead(_8);                 // scope 0 at $DIR/separate_const_switch.rs:20:43: 20:44\n+        goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+    }\n+\n+    bb3: {\n+        StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:23:1: 23:2\n+        return;                          // scope 0 at $DIR/separate_const_switch.rs:23:2: 23:2\n+    }\n+}"}, {"sha": "ce32227ed653b87e82d3fd592b79cd009cd85510", "filename": "src/test/mir-opt/separate_const_switch.too_complex.SeparateConstSwitch.diff", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a77e2ad5338e0c417dd5c4f5958b8aab526322d6/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff?ref=a77e2ad5338e0c417dd5c4f5958b8aab526322d6", "patch": "@@ -0,0 +1,98 @@\n+- // MIR for `too_complex` before SeparateConstSwitch\n++ // MIR for `too_complex` after SeparateConstSwitch\n+  \n+  fn too_complex(_1: Result<i32, usize>) -> Option<i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/separate_const_switch.rs:9:16: 9:17\n+      let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/separate_const_switch.rs:9:42: 9:53\n+      let mut _2: std::ops::ControlFlow<usize, i32>; // in scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+      let mut _3: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      let _4: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      let mut _5: i32;                     // in scope 0 at $DIR/separate_const_switch.rs:16:44: 16:45\n+      let _6: usize;                       // in scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      let mut _7: usize;                   // in scope 0 at $DIR/separate_const_switch.rs:17:42: 17:43\n+      let mut _8: isize;                   // in scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      let _9: i32;                         // in scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      let mut _10: i32;                    // in scope 0 at $DIR/separate_const_switch.rs:20:42: 20:43\n+      let _11: usize;                      // in scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      scope 1 {\n+          debug v => _4;                   // in scope 1 at $DIR/separate_const_switch.rs:16:16: 16:17\n+      }\n+      scope 2 {\n+          debug r => _6;                   // in scope 2 at $DIR/separate_const_switch.rs:17:17: 17:18\n+      }\n+      scope 3 {\n+          debug v => _9;                   // in scope 3 at $DIR/separate_const_switch.rs:20:31: 20:32\n+      }\n+      scope 4 {\n+          debug r => _11;                  // in scope 4 at $DIR/separate_const_switch.rs:21:28: 21:29\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:14:11: 19:6\n+          _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+          switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/separate_const_switch.rs:16:13: 16:18\n+      }\n+  \n+      bb1: {\n+          StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:17:17: 17:18\n+          StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:17:42: 17:43\n+          ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:17:23: 17:44\n+          StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:17:43: 17:44\n+          StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:17:43: 17:44\n+-         goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:15:9: 18:10\n++         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+      bb2: {\n+          StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:16:16: 16:17\n+          StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:16:44: 16:45\n+          ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:16:22: 16:46\n+          StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:16:45: 16:46\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:16:45: 16:46\n+-         goto -> bb3;                     // scope 0 at $DIR/separate_const_switch.rs:15:9: 18:10\n+-     }\n+- \n+-     bb3: {\n+          _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+-         switchInt(move _8) -> [0_isize: bb5, otherwise: bb4]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n++         switchInt(move _8) -> [0_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:20:9: 20:33\n+      }\n+  \n+-     bb4: {\n++     bb3: {\n+          StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          _11 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:21:28: 21:29\n+          discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:21:34: 21:38\n+          StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:21:37: 21:38\n+-         goto -> bb6;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n++         goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+-     bb5: {\n++     bb4: {\n+          StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          _9 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:20:31: 20:32\n+          StorageLive(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          _10 = _9;                        // scope 3 at $DIR/separate_const_switch.rs:20:42: 20:43\n+          ((_0 as Some).0: i32) = move _10; // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:20:37: 20:44\n+          StorageDead(_10);                // scope 3 at $DIR/separate_const_switch.rs:20:43: 20:44\n+          StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:20:43: 20:44\n+-         goto -> bb6;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n++         goto -> bb5;                     // scope 0 at $DIR/separate_const_switch.rs:14:5: 22:6\n+      }\n+  \n+-     bb6: {\n++     bb5: {\n+          StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:23:1: 23:2\n+          return;                          // scope 0 at $DIR/separate_const_switch.rs:23:2: 23:2\n+      }\n+  }\n+  "}]}