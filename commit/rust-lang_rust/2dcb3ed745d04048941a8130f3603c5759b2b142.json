{"sha": "2dcb3ed745d04048941a8130f3603c5759b2b142", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkY2IzZWQ3NDVkMDQwNDg5NDFhODEzMGYzNjAzYzU3NTliMmIxNDI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-02-05T18:33:28Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-02-05T18:33:28Z"}, "message": "Merge", "tree": {"sha": "b02ae43f09244c7f4549a9c4171516d0cc257997", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b02ae43f09244c7f4549a9c4171516d0cc257997"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dcb3ed745d04048941a8130f3603c5759b2b142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dcb3ed745d04048941a8130f3603c5759b2b142", "html_url": "https://github.com/rust-lang/rust/commit/2dcb3ed745d04048941a8130f3603c5759b2b142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dcb3ed745d04048941a8130f3603c5759b2b142/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "html_url": "https://github.com/rust-lang/rust/commit/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a"}, {"sha": "2f46b763da2c098913884f101b6d71d69af41b49", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f46b763da2c098913884f101b6d71d69af41b49", "html_url": "https://github.com/rust-lang/rust/commit/2f46b763da2c098913884f101b6d71d69af41b49"}], "stats": {"total": 11682, "additions": 5903, "deletions": 5779}, "files": [{"sha": "a7b55520b8d4580f1770a5623e9188d7b4e2a9c3", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -106,6 +106,7 @@ Margaret Meyerhofer <mmeyerho@andrew.cmu.edu>\n Marijn Haverbeke <marijnh@gmail.com>\n Mark Lacey <641@rudkx.com>\n Martin DeMello <martindemello@gmail.com>\n+Marvin L\u00f6bel <loebel.marvin@gmail.com>\n Matt Brubeck <mbrubeck@limpet.net>\n Matthew O'Connor <thegreendragon@gmail.com>\n Max Penet <max.penet@gmail.com>"}, {"sha": "c6e9478713d588e599e2a8d0d0cb682155410006", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -1,15 +1,24 @@\n ## Pull request procedure\n \n-Pull requests should be targeted at Rust's `incoming` branch (note that by default Github will aim them at the `master` branch) -- see \"Changing The Commit Range and Destination Repository\" in Github's documentation on [pull requests](https://help.github.com/articles/using-pull-requests). Before pushing to your Github repo and issuing the pull request, please do two things:\n+Pull requests should be targeted at Rust's `incoming` branch (note that by default Github will aim them at the `master` branch) --\n+see \"Changing The Commit Range and Destination Repository\" in Github's documentation on [pull requests](https://help.github.com/articles/using-pull-requests).\n+Before pushing to your Github repo and issuing the pull request, please do two things:\n \n 1. [Rebase](http://git-scm.com/book/en/Git-Branching-Rebasing) your local changes against the `incoming` branch. Resolve any conflicts that arise.\n-2. Run the full Rust test suite with the `make check` command. You're not off the hook even if you just stick to documentation; code examples in the docs are tested as well!\n+2. Run the full Rust test suite with the `make check` command.\n+You're not off the hook even if you just stick to documentation; code examples in the docs are tested as well!\n \n-Pull requests will be treated as \"review requests\", and we will give feedback we expect to see corrected on [style](https://github.com/mozilla/rust/wiki/Note-style-guide) and substance before pulling. Changes contributed via pull request should focus on a single issue at a time, like any other. We will not look kindly on pull-requests that try to \"sneak\" unrelated changes in.\n+Pull requests will be treated as \"review requests\",\n+and we will give feedback we expect to see corrected on [style](https://github.com/mozilla/rust/wiki/Note-style-guide) and substance before pulling.\n+Changes contributed via pull request should focus on a single issue at a time, like any other.\n+We will not look accept pull-requests that try to \"sneak\" unrelated changes in.\n \n-Normally, all pull requests must include regression tests (see [Note-testsuite](https://github.com/mozilla/rust/wiki/Note-testsuite)) that test your change. Occasionally, a change will be very difficult to test for. In those cases, please include a note in your commit message explaining why.\n+Normally, all pull requests must include regression tests (see [Note-testsuite](https://github.com/mozilla/rust/wiki/Note-testsuite)) that test your change.\n+Occasionally, a change will be very difficult to test for.\n+In those cases, please include a note in your commit message explaining why.\n \n-In the licensing header at the beginning of any files you change, please make sure the listed date range includes the current year. For example, if it's 2013, and you change a Rust file that was created in 2010, it should begin:\n+In the licensing header at the beginning of any files you change, please make sure the listed date range includes the current year.\n+For example, if it's 2013, and you change a Rust file that was created in 2010, it should begin:\n \n ```\n // Copyright 2010-2013 The Rust Project Developers."}, {"sha": "27b63c1080bd458d9be17010fc2e2ee0806b87a5", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -42,7 +42,7 @@ packages:\n Assuming you're on a relatively modern *nix system and have met the\n prerequisites, something along these lines should work.\n \n-    $ wget http://static.rust-lang.org/dist/rust-0.5.tar.gz\n+    $ curl -O http://static.rust-lang.org/dist/rust-0.5.tar.gz\n     $ tar -xzf rust-0.5.tar.gz\n     $ cd rust-0.5\n     $ ./configure"}, {"sha": "052669be6f5fde2a79914dd8f5d9404d89337606", "filename": "doc/lib/codemirror-rust.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-rust.js?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -2,7 +2,7 @@ CodeMirror.defineMode(\"rust\", function() {\n   var indentUnit = 4, altIndentUnit = 2;\n   var valKeywords = {\n     \"if\": \"if-style\", \"while\": \"if-style\", \"loop\": \"if-style\", \"else\": \"else-style\",\n-    \"do\": \"else-style\", \"return\": \"else-style\", \"fail\": \"else-style\",\n+    \"do\": \"else-style\", \"return\": \"else-style\",\n     \"break\": \"atom\", \"cont\": \"atom\", \"const\": \"let\", \"resource\": \"fn\",\n     \"let\": \"let\", \"fn\": \"fn\", \"for\": \"for\", \"match\": \"match\", \"trait\": \"trait\",\n     \"impl\": \"impl\", \"type\": \"type\", \"enum\": \"enum\", \"struct\": \"atom\", \"mod\": \"mod\","}, {"sha": "fc8ce9f9c38fc35d46870b1e383a428d1d84d4be", "filename": "doc/rust.md", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -216,7 +216,7 @@ break\n const copy\n do drop\n else enum extern\n-fail false fn for\n+false fn for\n if impl\n let log loop\n match mod move mut\n@@ -448,10 +448,10 @@ expression context, the final namespace qualifier is omitted.\n Two examples of paths with type arguments:\n \n ~~~~\n-# use std::map;\n+# use std::oldmap;\n # fn f() {\n # fn id<T:Copy>(t: T) -> T { t }\n-type t = map::HashMap<int,~str>;  // Type arguments used in a type expression\n+type t = oldmap::HashMap<int,~str>;  // Type arguments used in a type expression\n let x = id::<int>(10);           // Type arguments used in a call expression\n # }\n ~~~~\n@@ -692,15 +692,15 @@ mod math {\n     type complex = (f64, f64);\n     fn sin(f: f64) -> f64 {\n         ...\n-# fail;\n+# die!();\n     }\n     fn cos(f: f64) -> f64 {\n         ...\n-# fail;\n+# die!();\n     }\n     fn tan(f: f64) -> f64 {\n         ...\n-# fail;\n+# die!();\n     }\n }\n ~~~~~~~~\n@@ -844,13 +844,16 @@ mod quux {\n         pub fn bar() { }\n         pub fn baz() { }\n     }\n-    \n+\n     pub use quux::foo::*;\n }\n ~~~~\n \n In this example, the module `quux` re-exports all of the public names defined in `foo`.\n \n+Also note that the paths contained in `use` items are relative to the crate root; so, in the previous\n+example, the use refers to `quux::foo::*`, and not simply to `foo::*`.\n+\n ### Functions\n \n A _function item_ defines a sequence of [statements](#statements) and an optional final [expression](#expressions), along with a name and a set of parameters.\n@@ -989,13 +992,13 @@ output slot type would normally be. For example:\n ~~~~\n fn my_err(s: &str) -> ! {\n     log(info, s);\n-    fail;\n+    die!();\n }\n ~~~~\n \n We call such functions \"diverging\" because they never return a value to the\n caller. Every control path in a diverging function must end with a\n-[`fail`](#fail-expressions) or a call to another diverging function on every\n+`fail!()` or a call to another diverging function on every\n control path. The `!` annotation does *not* denote a type. Rather, the result\n type of a diverging function is a special type called $\\bot$ (\"bottom\") that\n unifies with any type. Rust has no syntax for $\\bot$.\n@@ -1007,7 +1010,7 @@ were declared without the `!` annotation, the following code would not\n typecheck:\n \n ~~~~\n-# fn my_err(s: &str) -> ! { fail }\n+# fn my_err(s: &str) -> ! { die!() }\n \n fn f(i: int) -> int {\n    if i == 42 {\n@@ -1239,7 +1242,7 @@ trait Num {\n impl float: Num {\n     static pure fn from_int(n: int) -> float { n as float }\n }\n-let x: float = Num::from_int(42);     \n+let x: float = Num::from_int(42);\n ~~~~\n \n Traits may inherit from other traits. For example, in\n@@ -1612,7 +1615,7 @@ The following are examples of structure expressions:\n ~~~~\n # struct Point { x: float, y: float }\n # struct TuplePoint(float, float);\n-# mod game { pub struct User { name: &str, age: uint, mut score: uint } } \n+# mod game { pub struct User { name: &str, age: uint, mut score: uint } }\n # use game;\n Point {x: 10f, y: 20f};\n TuplePoint(10f, 20f);\n@@ -1716,15 +1719,12 @@ vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr]\n \n A [_vector_](#vector-types) _expression_ is written by enclosing zero or\n more comma-separated expressions of uniform type in square brackets.\n-The keyword `mut` can be written after the opening bracket to\n-indicate that the elements of the resulting vector may be mutated.\n-When no mutability is specified, the vector is immutable.\n \n ~~~~\n [1, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n [0, ..128];             // vector with 128 zeros\n-[mut 0u8, 0u8, 0u8, 0u8];\n+[0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n ### Index expressions\n@@ -1746,7 +1746,6 @@ task in a _failing state_.\n # do task::spawn_unlinked {\n \n ([1, 2, 3, 4])[0];\n-([mut 'x', 'y'])[1] = 'z';\n ([\"a\", \"b\"])[10]; // fails\n \n # }\n@@ -1909,8 +1908,8 @@ No allocation or destruction is entailed.\n An example of three different swap expressions:\n \n ~~~~~~~~\n-# let mut x = &[mut 0];\n-# let mut a = &[mut 0];\n+# let mut x = &mut [0];\n+# let mut a = &mut [0];\n # let i = 0;\n # let y = {mut z: 0};\n # let b = {mut c: 0};\n@@ -2005,11 +2004,11 @@ the unary copy operator is typically only used to cause an argument to a functio\n An example of a copy expression:\n \n ~~~~\n-fn mutate(vec: ~[mut int]) {\n+fn mutate(mut vec: ~[int]) {\n    vec[0] = 10;\n }\n \n-let v = ~[mut 1,2,3];\n+let v = ~[1,2,3];\n \n mutate(copy v);   // Pass a copy\n \n@@ -2291,9 +2290,9 @@ enum List<X> { Nil, Cons(X, @List<X>) }\n let x: List<int> = Cons(10, @Cons(11, @Nil));\n \n match x {\n-    Cons(_, @Nil) => fail ~\"singleton list\",\n+    Cons(_, @Nil) => die!(~\"singleton list\"),\n     Cons(*)       => return,\n-    Nil           => fail ~\"empty list\"\n+    Nil           => die!(~\"empty list\")\n }\n ~~~~\n \n@@ -2330,7 +2329,7 @@ match x {\n         return;\n     }\n     _ => {\n-        fail;\n+        die!();\n     }\n }\n ~~~~\n@@ -2418,23 +2417,10 @@ guard may refer to the variables bound within the pattern they follow.\n let message = match maybe_digit {\n   Some(x) if x < 10 => process_digit(x),\n   Some(x) => process_other(x),\n-  None => fail\n+  None => die!()\n };\n ~~~~\n \n-\n-### Fail expressions\n-\n-~~~~~~~~{.ebnf .gram}\n-fail_expr : \"fail\" expr ? ;\n-~~~~~~~~\n-\n-Evaluating a `fail` expression causes a task to enter the *failing* state. In\n-the *failing* state, a task unwinds its stack, destroying all frames and\n-running all destructors until it reaches its entry frame, at which point it\n-halts execution in the *dead* state.\n-\n-\n ### Return expressions\n \n ~~~~~~~~{.ebnf .gram}\n@@ -2822,7 +2808,7 @@ trait Printable {\n }\n \n impl int: Printable {\n-  fn to_str() -> ~str { int::to_str(self, 10) }\n+  fn to_str() -> ~str { int::to_str(self) }\n }\n \n fn print(a: @Printable) {\n@@ -3154,7 +3140,7 @@ unblock and transition back to *running*.\n \n A task may transition to the *failing* state at any time, due being\n killed by some external event or internally, from the evaluation of a\n-`fail` expression. Once *failing*, a task unwinds its stack and\n+`fail!()` macro. Once *failing*, a task unwinds its stack and\n transitions to the *dead* state. Unwinding the stack of a task is done by\n the task itself, on its own control stack. If a value with a destructor is\n freed during unwinding, the code for the destructor is run, also on the task's"}, {"sha": "4db584f20650d215a4d65ec553651d8e0595d64d", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -218,7 +218,7 @@ match x {\n                 // complicated stuff goes here\n                 return result + val;\n             },\n-            _ => fail ~\"Didn't get good_2\"\n+            _ => die!(~\"Didn't get good_2\")\n         }\n     }\n     _ => return 0 // default value\n@@ -260,7 +260,7 @@ macro_rules! biased_match (\n biased_match!((x)       ~ (good_1(g1, val)) else { return 0 };\n               binds g1, val )\n biased_match!((g1.body) ~ (good_2(result) )\n-                  else { fail ~\"Didn't get good_2\" };\n+                  else { die!(~\"Didn't get good_2\") };\n               binds result )\n // complicated stuff goes here\n return result + val;\n@@ -362,7 +362,7 @@ macro_rules! biased_match (\n # fn f(x: t1) -> uint {\n biased_match!(\n     (x)       ~ (good_1(g1, val)) else { return 0 };\n-    (g1.body) ~ (good_2(result) ) else { fail ~\"Didn't get good_2\" };\n+    (g1.body) ~ (good_2(result) ) else { die!(~\"Didn't get good_2\") };\n     binds val, result )\n // complicated stuff goes here\n return result + val;"}, {"sha": "f814970375a7d6d4b5459a0adec33b7ff0f2d01f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,7 +13,7 @@ cheaper to create than traditional threads, Rust can create hundreds of\n thousands of concurrent tasks on a typical 32-bit system.\n \n Tasks provide failure isolation and recovery. When an exception occurs in Rust\n-code (as a result of an explicit call to `fail`, an assertion failure, or\n+code (as a result of an explicit call to `fail!()`, an assertion failure, or\n another invalid operation), the runtime system destroys the entire\n task. Unlike in languages such as Java and C++, there is no way to `catch` an\n exception. Instead, tasks may monitor each other for failure.\n@@ -296,9 +296,9 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n \n # Handling task failure\n \n-Rust has a built-in mechanism for raising exceptions. The `fail` construct\n-(which can also be written with an error string as an argument: `fail\n-~reason`) and the `assert` construct (which effectively calls `fail` if a\n+Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n+(which can also be written with an error string as an argument: `fail!(\n+~reason)`) and the `assert` construct (which effectively calls `fail!()` if a\n boolean expression is false) are both ways to raise exceptions. When a task\n raises an exception the task unwinds its stack---running destructors and\n freeing memory along the way---and then exits. Unlike exceptions in C++,\n@@ -313,7 +313,7 @@ of all tasks are intertwined: if one fails, so do all the others.\n # fn do_some_work() { loop { task::yield() } }\n # do task::try {\n // Create a child task that fails\n-do spawn { fail }\n+do spawn { die!() }\n \n // This will also fail because the task we spawned failed\n do_some_work();\n@@ -337,7 +337,7 @@ let result: Result<int, ()> = do task::try {\n     if some_condition() {\n         calculate_result()\n     } else {\n-        fail ~\"oops!\";\n+        die!(~\"oops!\");\n     }\n };\n assert result.is_err();\n@@ -354,7 +354,7 @@ an `Error` result.\n > ***Note:*** A failed task does not currently produce a useful error\n > value (`try` always returns `Err(())`). In the\n > future, it may be possible for tasks to intercept the value passed to\n-> `fail`.\n+> `fail!()`.\n \n TODO: Need discussion of `future_result` in order to make failure\n modes useful.\n@@ -377,7 +377,7 @@ either task dies, it kills the other one.\n # do task::try {\n do task::spawn {\n     do task::spawn {\n-        fail;  // All three tasks will die.\n+        die!();  // All three tasks will die.\n     }\n     sleep_forever();  // Will get woken up by force, then fail\n }\n@@ -432,7 +432,7 @@ do task::spawn_supervised {\n     // Intermediate task immediately exits\n }\n wait_for_a_while();\n-fail;  // Will kill grandchild even if child has already exited\n+die!();  // Will kill grandchild even if child has already exited\n # };\n ~~~\n \n@@ -446,10 +446,10 @@ other at all, using `task::spawn_unlinked` for _isolated failure_.\n let (time1, time2) = (random(), random());\n do task::spawn_unlinked {\n     sleep_for(time2);  // Won't get forced awake\n-    fail;\n+    die!();\n }\n sleep_for(time1);  // Won't get forced awake\n-fail;\n+die!();\n // It will take MAX(time1,time2) for the program to finish.\n # };\n ~~~\n@@ -473,7 +473,7 @@ fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n-        channel.send(uint::to_str(value, 10));\n+        channel.send(uint::to_str(value));\n         if value == 0 { break; }\n     }\n }\n@@ -497,7 +497,7 @@ Here is the code for the parent task:\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();\n-#         channel.send(uint::to_str(value, 10u));\n+#         channel.send(uint::to_str(value));\n #         if value == 0u { break; }\n #     }\n # }"}, {"sha": "1087689b9bee17e5dbeab310b492eb42628c1ed6", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -1791,11 +1791,11 @@ illegal to copy and pass by value.\n Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n ~~~~\n-# use std::map::HashMap;\n+# use std::oldmap::HashMap;\n type Set<T> = HashMap<T, ()>;\n \n struct Stack<T> {\n-    elements: ~[mut T]\n+    elements: ~[T]\n }\n \n enum Option<T> {"}, {"sha": "81ccbf4b7ad1b9123e3ce96912b277ac80a0fd51", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -57,15 +57,12 @@ RUNTIME_CXXS_$(1) := \\\n               rt/rust_sched_reaper.cpp \\\n               rt/rust_task.cpp \\\n               rt/rust_stack.cpp \\\n-              rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n               rt/rust_crate_map.cpp \\\n               rt/rust_log.cpp \\\n               rt/rust_gc_metadata.cpp \\\n-              rt/rust_port_selector.cpp \\\n               rt/rust_util.cpp \\\n-              rt/circular_buffer.cpp \\\n               rt/isaac/randport.cpp \\\n               rt/miniz.cpp \\\n               rt/rust_kernel.cpp \\"}, {"sha": "67bb055dfc7f315b3fa27acaa099a62c7a249e78", "filename": "mk/target.mk", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,13 +14,6 @@\n # $(2) is the target triple\n # $(3) is the host triple\n \n-# If you are making non-backwards compatible changes to the runtime\n-# (resp.  corelib), set this flag to 1.  It will cause stage1 to use\n-# the snapshot runtime (resp. corelib) rather than the runtime\n-# (resp. corelib) from the working directory.\n-USE_SNAPSHOT_RUNTIME=0\n-USE_SNAPSHOT_CORELIB=0\n-USE_SNAPSHOT_STDLIB=0\n \n define TARGET_STAGE_N\n \n@@ -59,86 +52,17 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX): \\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) $(BORROWCK) -o $$@ $$< && touch $$@\n \n-endef\n-\n-# The stage0 (snapshot) compiler produces binaries that expect the\n-# snapshot runtime.  Normally the working directory runtime and\n-# snapshot runtime are compatible, so this is no problem. But\n-# sometimes we want to make non-backwards-compatible changes.  In\n-# those cases, the stage1 compiler and libraries (which are produced\n-# by stage0) should use the runtime from the snapshot.  The stage2\n-# compiler and libraries (which are produced by stage1) will be the\n-# first that are expecting to run against the runtime as defined in\n-# the working directory.\n-#\n-# The catch is that you may not add new functions to the runtime\n-# in this case!\n-#\n-# Arguments are the same as for TARGET_BASE_STAGE_N\n-define TARGET_RT_FROM_SNAPSHOT\n-\n-$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUNTIME): \\\n-\t\t$$(HLIB$(1)_H_$(3))/$$(CFG_RUNTIME)\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-endef\n-\n-# This rule copies from the runtime for the working directory.  It\n-# applies to targets produced by stage1 or later.  See comment on\n-# previous rule.\n-#\n-# Arguments are the same as for TARGET_BASE_STAGE_N\n-define TARGET_RT_FROM_WD\n-\n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUNTIME): \\\n \t\trt/$(2)/$$(CFG_RUNTIME)\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n-endef\n-\n-# As above, but builds the corelib either by taking it out of the\n-# snapshot or from the working directory.\n-\n-define TARGET_CORELIB_FROM_SNAPSHOT\n-\n-$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB): \\\n-\t\t$$(HLIB$(1)_H_$(3))/$$(CFG_CORELIB) \\\n-\t\t$$(CORELIB_INPUTS) \\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\t$$(Q)cp $$(HLIB$(1)_H_$(3))/$$(CORELIB_GLOB) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))\n-\n-endef\n-\n-define TARGET_CORELIB_FROM_WD\n-\n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB): \\\n \t\t$$(CORELIB_CRATE) $$(CORELIB_INPUTS) \\\n \t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n \n-endef\n-\n-define TARGET_STDLIB_FROM_SNAPSHOT\n-\n-$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB): \\\n-\t\t$$(HLIB$(1)_H_$(3))/$$(CFG_STDLIB) \\\n-\t\t$$(STDLIB_INPUTS) \\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\t$$(Q)cp $$(HLIB$(1)_H_$(3))/$$(STDLIB_GLOB) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))\n-\n-endef\n-\n-define TARGET_STDLIB_FROM_WD\n-\n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB): \\\n \t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n \t        $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB) \\\n@@ -155,52 +79,3 @@ $(foreach source,$(CFG_TARGET_TRIPLES),\t\t\t\t\\\n   $(eval $(call TARGET_STAGE_N,1,$(target),$(source)))\t\t\\\n   $(eval $(call TARGET_STAGE_N,2,$(target),$(source)))\t\t\\\n   $(eval $(call TARGET_STAGE_N,3,$(target),$(source)))))\n-\n-# Host triple either uses the snapshot runtime or runtime from\n-# working directory, depending on the USE_SNAPSHOT_RUNTIME var.\n-ifeq ($(USE_SNAPSHOT_RUNTIME),1)\n-    $(foreach src,$(CFG_HOST_TRIPLE),\\\n-\t\t$(eval $(call TARGET_RT_FROM_SNAPSHOT,0,$(src),$(src))))\n-else \n-    $(foreach src,$(CFG_HOST_TRIPLE),\\\n-\t\t$(eval $(call TARGET_RT_FROM_WD,0,$(src),$(src))))\n-endif\n-\n-ifeq ($(USE_SNAPSHOT_CORELIB),1)\n-    $(foreach src,$(CFG_HOST_TRIPLE),\\\n-\t\t$(eval $(call TARGET_CORELIB_FROM_SNAPSHOT,0,$(src),$(src))))\n-else \n-    $(foreach src,$(CFG_HOST_TRIPLE),\\\n-\t\t$(eval $(call TARGET_CORELIB_FROM_WD,0,$(src),$(src))))\n-endif\n-\n-ifeq ($(USE_SNAPSHOT_STDLIB),1)\n-    $(foreach src,$(CFG_HOST_TRIPLE),\\\n-\t\t$(eval $(call TARGET_STDLIB_FROM_SNAPSHOT,0,$(src),$(src))))\n-else\n-    $(foreach src,$(CFG_HOST_TRIPLE),\\\n-\t\t$(eval $(call TARGET_STDLIB_FROM_WD,0,$(src),$(src))))\n-endif\n-\n-# Non-host triples build the stage0 runtime from the working directory\n-$(foreach source,$(CFG_TARGET_TRIPLES),\t\t\t\t\\\n- $(foreach target,$(NON_HOST_TRIPLES),\t\t\t\t\\\n-  $(eval $(call TARGET_RT_FROM_WD,0,$(target),$(source)))       \\\n-  $(eval $(call TARGET_CORELIB_FROM_WD,0,$(target),$(source)))  \\\n-  $(eval $(call TARGET_STDLIB_FROM_WD,0,$(target),$(source)))  \\\n-))\n-\n-# After stage0, always build the stage0 runtime from the working directory\n-$(foreach source,$(CFG_TARGET_TRIPLES),\t\t\t\t\\\n- $(foreach target,$(CFG_TARGET_TRIPLES),\t\t\t\\\n-  $(eval $(call TARGET_RT_FROM_WD,1,$(target),$(source)))\t\\\n-  $(eval $(call TARGET_RT_FROM_WD,2,$(target),$(source)))\t\\\n-  $(eval $(call TARGET_RT_FROM_WD,3,$(target),$(source)))  \t\\\n-  $(eval $(call TARGET_CORELIB_FROM_WD,1,$(target),$(source)))\t\\\n-  $(eval $(call TARGET_CORELIB_FROM_WD,2,$(target),$(source)))\t\\\n-  $(eval $(call TARGET_CORELIB_FROM_WD,3,$(target),$(source)))\t\\\n-  $(eval $(call TARGET_STDLIB_FROM_WD,1,$(target),$(source)))\t\\\n-  $(eval $(call TARGET_STDLIB_FROM_WD,2,$(target),$(source)))\t\\\n-  $(eval $(call TARGET_STDLIB_FROM_WD,3,$(target),$(source)))\t\\\n-))\n-"}, {"sha": "c8029098cfaf40d42668666ad02884307a0acbc2", "filename": "src/README.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -17,6 +17,7 @@ rt/sync            - Concurrency utils\n rt/util            - Small utility classes for the runtime.\n rt/vg              - Valgrind headers\n rt/msvc            - MSVC support\n+rt/linenoise       - a readline-like line editing library\n \n test/              Testsuite\n test/compile-fail  - Tests that should fail to compile"}, {"sha": "8f5f9547c520e9b016b44d915e726729fc770381", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -69,7 +69,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n     let matches =\n         &match getopts::getopts(args_, opts) {\n           Ok(m) => m,\n-          Err(f) => fail getopts::fail_str(f)\n+          Err(f) => die!(getopts::fail_str(f))\n         };\n \n     fn opt_path(m: &getopts::Matches, nm: ~str) -> Path {\n@@ -131,7 +131,7 @@ pub fn str_mode(s: ~str) -> mode {\n       ~\"run-fail\" => mode_run_fail,\n       ~\"run-pass\" => mode_run_pass,\n       ~\"pretty\" => mode_pretty,\n-      _ => fail ~\"invalid mode\"\n+      _ => die!(~\"invalid mode\")\n     }\n }\n \n@@ -148,7 +148,7 @@ pub fn run_tests(config: config) {\n     let opts = test_opts(config);\n     let tests = make_tests(config);\n     let res = test::run_tests_console(&opts, tests);\n-    if !res { fail ~\"Some tests failed\"; }\n+    if !res { die!(~\"Some tests failed\"); }\n }\n \n pub fn test_opts(config: config) -> test::TestOpts {"}, {"sha": "0b9d67426ae35ae749fce2b906cab7285f47383b", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -119,7 +119,7 @@ fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n         match strs.len() {\n           1u => (strs[0], ~\"\"),\n           2u => (strs[0], strs[1]),\n-          n => fail fmt!(\"Expected 1 or 2 strings, not %u\", n)\n+          n => die!(fmt!(\"Expected 1 or 2 strings, not %u\", n))\n         }\n     }\n }"}, {"sha": "a8e4d91d89a8888f1dc51d9743b3c548f56cd714", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -71,7 +71,7 @@ pub fn run(lib_path: ~str,\n         os::close(pipe_in.out);\n         os::close(pipe_out.in);\n         os::close(pipe_err.in);\n-        fail;\n+        die!();\n     }\n \n \n@@ -99,7 +99,7 @@ pub fn run(lib_path: ~str,\n           (2, s) => {\n             errs = s;\n           }\n-          _ => { fail }\n+          _ => { die!() }\n         };\n         count -= 1;\n     };"}, {"sha": "a71b8a360a246f6a771ff5392ab35a6dec0ee4b4", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -200,7 +200,7 @@ actual:\\n\\\n \\n\",\n                      expected, actual);\n             io::stdout().write_str(msg);\n-            fail;\n+            die!();\n         }\n     }\n \n@@ -467,7 +467,7 @@ fn compose_and_run_compiler(\n fn ensure_dir(path: &Path) {\n     if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n-        fail fmt!(\"can't make dir %s\", path.to_str());\n+        die!(fmt!(\"can't make dir %s\", path.to_str()));\n     }\n }\n \n@@ -617,7 +617,7 @@ fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n \n fn error(err: ~str) { io::stdout().write_line(fmt!(\"\\nerror: %s\", err)); }\n \n-fn fatal(err: ~str) -> ! { error(err); fail; }\n+fn fatal(err: ~str) -> ! { error(err); die!(); }\n \n fn fatal_ProcRes(err: ~str, ProcRes: ProcRes) -> ! {\n     let msg =\n@@ -635,5 +635,5 @@ stderr:\\n\\\n \\n\",\n              err, ProcRes.cmdline, ProcRes.stdout, ProcRes.stderr);\n     io::stdout().write_str(msg);\n-    fail;\n+    die!();\n }"}, {"sha": "4ff7783888f8d38e2d7b0c79192c07228e1dccd7", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -12,25 +12,24 @@ endif\n \n syn match     rustAssert      \"\\<assert\\(\\w\\)*\"\n syn keyword   rustKeyword     as break\n-syn keyword   rustKeyword     const copy do drop else export extern fail\n+syn keyword   rustKeyword     copy do drop else extern\n syn keyword   rustKeyword     for if impl let log\n-syn keyword   rustKeyword     loop match mod move mut once priv pure\n-syn match     rustKeyword     \"\\<pub\\>\"\n+syn keyword   rustKeyword     loop match mod move once priv pub pure\n syn keyword   rustKeyword     ref return static\n-syn match     rustKeyword     \"\\<unsafe\\>\" \" Allows also matching unsafe::foo()\n-syn keyword   rustKeyword     use while\n+syn keyword   rustKeyword     unsafe use while\n \" FIXME: Scoped impl's name is also fallen in this category\n syn keyword   rustKeyword     mod trait struct enum type nextgroup=rustIdentifier skipwhite\n syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite\n+syn keyword   rustStorage     const mut\n \n syn match     rustIdentifier  contains=rustIdentifierPrime \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n syn match     rustFuncName    \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n \n \" Reserved words\n-syn keyword   rustKeyword     m32 m64 m128 f80 f16 f128\n+syn keyword   rustKeyword     m32 m64 m128 f80 f16 f128 be\n \n syn keyword   rustType        int uint float char bool u8 u16 u32 u64 f32\n-syn keyword   rustType        f64 i8 i16 i32 i64 str\n+syn keyword   rustType        f64 i8 i16 i32 i64 str Self\n syn keyword   rustType        Option Either\n \n \" Types from libc\n@@ -134,6 +133,7 @@ hi def link rustMacro         Macro\n hi def link rustType          Type\n hi def link rustTodo          Todo\n hi def link rustAttribute     PreProc\n+hi def link rustStorage       StorageClass\n \n \" Other Suggestions:\n \" hi rustAssert ctermfg=yellow"}, {"sha": "960bcf88eb7ef7fc3b2ff972f01ffbfa841a1472", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -53,8 +53,8 @@ use core::io::WriterUtil;\n use core::result::{Ok, Err};\n use core::hashmap::linear::LinearMap;\n use std::getopts::{optflag, optopt, opt_present};\n-use std::map::HashMap;\n-use std::{map, json, tempfile, term, sort, getopts};\n+use std::oldmap::HashMap;\n+use std::{oldmap, json, tempfile, term, sort, getopts};\n use syntax::codemap::span;\n use syntax::diagnostic::span_handler;\n use syntax::diagnostic;\n@@ -110,9 +110,9 @@ pub struct Cargo {\n     libdir: Path,\n     workdir: Path,\n     sourcedir: Path,\n-    sources: map::HashMap<~str, @Source>,\n+    sources: oldmap::HashMap<~str, @Source>,\n     mut current_install: ~str,\n-    dep_cache: map::HashMap<~str, bool>,\n+    dep_cache: oldmap::HashMap<~str, bool>,\n     opts: Options\n }\n \n@@ -286,7 +286,7 @@ pub fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n     let mut uuid = None;\n     for mis.each |a| {\n         match a.node {\n-            ast::meta_name_value(v, ast::spanned { node: ast::lit_str(s),\n+            ast::meta_name_value(v, codemap::spanned { node: ast::lit_str(s),\n                                                    _ }) => {\n                 match v {\n                     ~\"name\" => name = Some(*s),\n@@ -295,7 +295,7 @@ pub fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n                     _ => { }\n                 }\n             }\n-            _ => fail ~\"load_link: meta items must be name-values\"\n+            _ => die!(~\"load_link: meta items must be name-values\")\n         }\n     }\n     (name, vers, uuid)\n@@ -314,7 +314,7 @@ pub fn load_crate(filename: &Path) -> Option<Crate> {\n \n     for c.node.attrs.each |a| {\n         match a.node.value.node {\n-            ast::meta_name_value(v, ast::spanned { node: ast::lit_str(_),\n+            ast::meta_name_value(v, codemap::spanned { node: ast::lit_str(_),\n                                                    _ }) => {\n                 match v {\n                     ~\"desc\" => desc = Some(v),\n@@ -332,8 +332,8 @@ pub fn load_crate(filename: &Path) -> Option<Crate> {\n                 }\n             }\n             _ => {\n-                fail ~\"crate attributes may not contain \" +\n-                     ~\"meta_words\";\n+                die!(~\"crate attributes may not contain \" +\n+                     ~\"meta_words\");\n             }\n         }\n     }\n@@ -435,7 +435,7 @@ pub fn rest(s: ~str, start: uint) -> ~str {\n pub fn need_dir(s: &Path) {\n     if os::path_is_dir(s) { return; }\n     if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n-        fail fmt!(\"can't make_dir %s\", s.to_str());\n+        die!(fmt!(\"can't make_dir %s\", s.to_str()));\n     }\n }\n \n@@ -453,14 +453,14 @@ pub fn valid_pkg_name(s: &str) -> bool {\n \n pub fn parse_source(name: ~str, j: &json::Json) -> @Source {\n     if !valid_pkg_name(name) {\n-        fail fmt!(\"'%s' is an invalid source name\", name);\n+        die!(fmt!(\"'%s' is an invalid source name\", name));\n     }\n \n     match *j {\n         json::Object(j) => {\n             let mut url = match j.find(&~\"url\") {\n                 Some(&json::String(u)) => copy u,\n-                _ => fail ~\"needed 'url' field in source\"\n+                _ => die!(~\"needed 'url' field in source\")\n             };\n             let method = match j.find(&~\"method\") {\n                 Some(&json::String(u)) => copy u,\n@@ -485,12 +485,12 @@ pub fn parse_source(name: ~str, j: &json::Json) -> @Source {\n                 mut keyfp: keyfp,\n                 packages: DVec() };\n         }\n-        _ => fail ~\"needed dict value in source\"\n+        _ => die!(~\"needed dict value in source\")\n     };\n }\n \n pub fn try_parse_sources(filename: &Path,\n-                         sources: map::HashMap<~str, @Source>) {\n+                         sources: oldmap::HashMap<~str, @Source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(c.get()) {\n@@ -500,8 +500,8 @@ pub fn try_parse_sources(filename: &Path,\n                 debug!(\"source: %s\", *k);\n             }\n         }\n-        Ok(_) => fail ~\"malformed sources.json\",\n-        Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n+        Ok(_) => die!(~\"malformed sources.json\"),\n+        Err(e) => die!(fmt!(\"%s:%s\", filename.to_str(), e.to_str()))\n     }\n }\n \n@@ -662,7 +662,7 @@ pub fn build_cargo_options(argv: ~[~str]) -> Options {\n     let matches = &match getopts::getopts(argv, opts()) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n-            fail fmt!(\"%s\", getopts::fail_str(f));\n+            die!(fmt!(\"%s\", getopts::fail_str(f)));\n         }\n     };\n \n@@ -675,10 +675,10 @@ pub fn build_cargo_options(argv: ~[~str]) -> Options {\n     let is_install = len > 1u && matches.free[1] == ~\"install\";\n     let is_uninstall = len > 1u && matches.free[1] == ~\"uninstall\";\n \n-    if G && g { fail ~\"-G and -g both provided\"; }\n+    if G && g { die!(~\"-G and -g both provided\"); }\n \n     if !is_install && !is_uninstall && (g || G) {\n-        fail ~\"-g and -G are only valid for `install` and `uninstall|rm`\";\n+        die!(~\"-g and -G are only valid for `install` and `uninstall|rm`\");\n     }\n \n     let mode =\n@@ -730,7 +730,7 @@ pub fn configure(opts: Options) -> Cargo {\n     need_dir(&c.libdir);\n     need_dir(&c.bindir);\n \n-    for sources.each_key |k| {\n+    for sources.each_key_ref |&k| {\n         let mut s = sources.get(k);\n         load_source_packages(&c, s);\n         sources.insert(k, s);\n@@ -748,7 +748,7 @@ pub fn configure(opts: Options) -> Cargo {\n }\n \n pub fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n-    for c.sources.each_value |v| {\n+    for c.sources.each_value_ref |&v| {\n         for v.packages.each |p| {\n             b(v, p);\n         }\n@@ -833,7 +833,7 @@ pub fn rustc_sysroot() -> ~str {\n     }\n }\n \n-pub fn install_source(c: &Cargo, path: &Path) {\n+pub fn install_source(c: &mut Cargo, path: &Path) {\n     debug!(\"source: %s\", path.to_str());\n     os::change_dir(path);\n \n@@ -845,7 +845,7 @@ pub fn install_source(c: &Cargo, path: &Path) {\n     }\n \n     if vec::is_empty(cratefiles) {\n-        fail ~\"this doesn't look like a rust package (no .rc files)\";\n+        die!(~\"this doesn't look like a rust package (no .rc files)\");\n     }\n \n     for cratefiles.each |cf| {\n@@ -872,7 +872,8 @@ pub fn install_source(c: &Cargo, path: &Path) {\n     }\n }\n \n-pub fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n+pub fn install_git(c: &mut Cargo, wd: &Path, url: ~str,\n+                   reference: Option<~str>) {\n     run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n     if reference.is_some() {\n         let r = reference.get();\n@@ -883,27 +884,27 @@ pub fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     install_source(c, wd);\n }\n \n-pub fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n+pub fn install_curl(c: &mut Cargo, wd: &Path, url: ~str) {\n     let tarpath = wd.push(\"pkg.tar\");\n     let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                          tarpath.to_str(), url]);\n     if p.status != 0 {\n-        fail fmt!(\"fetch of %s failed: %s\", url, p.err);\n+        die!(fmt!(\"fetch of %s failed: %s\", url, p.err));\n     }\n     run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n                                ~\"-C\", wd.to_str(),\n                                ~\"-f\", tarpath.to_str()]);\n     install_source(c, wd);\n }\n \n-pub fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n+pub fn install_file(c: &mut Cargo, wd: &Path, path: &Path) {\n     run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n                                   ~\"-C\", wd.to_str(),\n                                   ~\"-f\", path.to_str()]);\n     install_source(c, wd);\n }\n \n-pub fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n+pub fn install_package(c: &mut Cargo, src: ~str, wd: &Path, pkg: Package) {\n     let url = copy pkg.url;\n     let method = match pkg.method {\n         ~\"git\" => ~\"git\",\n@@ -922,15 +923,15 @@ pub fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n }\n \n pub fn cargo_suggestion(c: &Cargo, fallback: fn()) {\n-    if c.sources.size() == 0u {\n+    if c.sources.is_empty() {\n         error(~\"no sources defined - you may wish to run \" +\n               ~\"`cargo init`\");\n         return;\n     }\n     fallback();\n }\n \n-pub fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n+pub fn install_uuid(c: &mut Cargo, wd: &Path, uuid: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n@@ -954,7 +955,7 @@ pub fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n     }\n }\n \n-pub fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n+pub fn install_named(c: &mut Cargo, wd: &Path, name: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.name == name {\n@@ -978,7 +979,8 @@ pub fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n     }\n }\n \n-pub fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n+pub fn install_uuid_specific(c: &mut Cargo, wd: &Path, src: ~str,\n+                             uuid: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -993,7 +995,8 @@ pub fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + uuid);\n }\n \n-pub fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n+pub fn install_named_specific(c: &mut Cargo, wd: &Path, src: ~str,\n+                              name: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -1060,7 +1063,7 @@ pub fn cmd_uninstall(c: &Cargo) {\n     }\n }\n \n-pub fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n+pub fn install_query(c: &mut Cargo, wd: &Path, target: ~str) {\n     match c.dep_cache.find(target) {\n         Some(inst) => {\n             if inst {\n@@ -1112,23 +1115,20 @@ pub fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n     // a bit of a hack. It should be cleaned up in the future.\n \n     if target == c.current_install {\n-        for c.dep_cache.each |k, _v| {\n-            c.dep_cache.remove(k);\n-        }\n-\n+        c.dep_cache.clear();\n         c.current_install = ~\"\";\n     }\n }\n \n pub fn get_temp_workdir(c: &Cargo) -> Path {\n     match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n       Some(wd) => wd,\n-      None => fail fmt!(\"needed temp dir: %s\",\n-                        c.workdir.to_str())\n+      None => die!(fmt!(\"needed temp dir: %s\",\n+                        c.workdir.to_str()))\n     }\n }\n \n-pub fn cmd_install(c: &Cargo) {\n+pub fn cmd_install(c: &mut Cargo) {\n     unsafe {\n         let wd = get_temp_workdir(c);\n \n@@ -1138,7 +1138,7 @@ pub fn cmd_install(c: &Cargo) {\n                                                    wd.to_str()]);\n \n             if status != 0 {\n-                fail fmt!(\"could not copy directory: %s\", cwd.to_str());\n+                die!(fmt!(\"could not copy directory: %s\", cwd.to_str()));\n             }\n \n             install_source(c, &wd);\n@@ -1155,7 +1155,7 @@ pub fn cmd_install(c: &Cargo) {\n }\n \n pub fn sync(c: &Cargo) {\n-    for c.sources.each_key |k| {\n+    for c.sources.each_key_ref |&k| {\n         let mut s = c.sources.get(k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n@@ -1569,7 +1569,7 @@ pub fn cmd_list(c: &Cargo) {\n             }\n         }\n     } else {\n-        for c.sources.each_value |v| {\n+        for c.sources.each_value_ref |&v| {\n             print_source(v);\n         }\n     }\n@@ -1620,7 +1620,7 @@ pub fn dump_cache(c: &Cargo) {\n }\n \n pub fn dump_sources(c: &Cargo) {\n-    if c.sources.size() < 1u {\n+    if c.sources.is_empty() {\n         return;\n     }\n \n@@ -1636,7 +1636,7 @@ pub fn dump_sources(c: &Cargo) {\n         result::Ok(writer) => {\n             let mut hash = ~LinearMap::new();\n \n-            for c.sources.each |k, v| {\n+            for c.sources.each_ref |&k, &v| {\n                 let mut chash = ~LinearMap::new();\n \n                 chash.insert(~\"url\", json::String(v.url));\n@@ -1675,7 +1675,7 @@ pub fn copy_warn(srcfile: &Path, destfile: &Path) {\n \n pub fn cmd_sources(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n-        for c.sources.each_value |v| {\n+        for c.sources.each_value_ref |&v| {\n             info(fmt!(\"%s (%s) via %s\",\n                       v.name, v.url, v.method));\n         }\n@@ -1686,8 +1686,8 @@ pub fn cmd_sources(c: &Cargo) {\n \n     match action {\n         ~\"clear\" => {\n-          for c.sources.each_key |k| {\n-                c.sources.remove(k);\n+          for c.sources.each_key_ref |&k| {\n+                c.sources.remove(&k);\n             }\n \n             info(~\"cleared sources\");\n@@ -1706,7 +1706,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            if c.sources.contains_key(name) {\n+            if c.sources.contains_key_ref(&name) {\n                 error(fmt!(\"source already exists: %s\", name));\n             } else {\n                 c.sources.insert(name, @Source {\n@@ -1733,8 +1733,8 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            if c.sources.contains_key(name) {\n-                c.sources.remove(name);\n+            if c.sources.contains_key_ref(&name) {\n+                c.sources.remove(&name);\n                 info(fmt!(\"removed source: %s\", name));\n             } else {\n                 error(fmt!(\"no such source: %s\", name));\n@@ -1825,7 +1825,7 @@ pub fn cmd_sources(c: &Cargo) {\n \n             match c.sources.find(name) {\n                 Some(source) => {\n-                    c.sources.remove(name);\n+                    c.sources.remove(&name);\n                     c.sources.insert(newn, source);\n                     info(fmt!(\"renamed source: %s to %s\", name, newn));\n                 }\n@@ -1967,7 +1967,7 @@ pub fn main() {\n \n     match o.free[1] {\n         ~\"init\" => cmd_init(&c),\n-        ~\"install\" => cmd_install(&c),\n+        ~\"install\" => cmd_install(&mut c),\n         ~\"uninstall\" => cmd_uninstall(&c),\n         ~\"list\" => cmd_list(&c),\n         ~\"search\" => cmd_search(&c),"}, {"sha": "18b1c49efb14e2f9d09fbbc4a60035267e82fc9a", "filename": "src/libcargo/pgp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fpgp.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -87,7 +87,7 @@ pub fn init(root: &Path) {\n         p.input().write_str(signing_key());\n         let s = p.finish();\n         if s != 0 {\n-            fail ~\"pgp init failed\";\n+            die!(~\"pgp init failed\");\n         }\n     }\n }\n@@ -98,7 +98,7 @@ pub fn add(root: &Path, key: &Path) {\n         run::program_output(~\"gpg\", ~[~\"--homedir\", path.to_str(),\n                                       ~\"--import\", key.to_str()]);\n     if p.status != 0 {\n-        fail ~\"pgp add failed: \" + p.out;\n+        die!(~\"pgp add failed: \" + p.out);\n     }\n }\n "}, {"sha": "deecdc98ffa832e0cac5434f8d631703e81fee90", "filename": "src/libcore/char.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -118,6 +118,26 @@ pub pure fn is_digit(c: char) -> bool {\n         unicode::general_category::No(c);\n }\n \n+/**\n+ * Checks if a character parses as a numeric digit in the given radix.\n+ * Compared to `is_digit()`, this function only recognizes the ascii\n+ * characters `0-9`, `a-z` and `A-Z`.\n+ *\n+ * Returns `true` if `c` is a valid digit under `radix`, and `false`\n+ * otherwise.\n+ *\n+ * Fails if given a `radix` > 36.\n+ *\n+ * Note: This just wraps `to_digit()`.\n+ */\n+#[inline(always)]\n+pub pure fn is_digit_radix(c: char, radix: uint) -> bool {\n+    match to_digit(c, radix) {\n+        Some(_) => true,\n+        None    => false\n+    }\n+}\n+\n /**\n  * Convert a char to the corresponding digit.\n  *\n@@ -127,9 +147,15 @@ pub pure fn is_digit(c: char) -> bool {\n  * between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n  * 'b' or 'B', 11, etc. Returns none if the char does not\n  * refer to a digit in the given radix.\n+ *\n+ * # Failure\n+ * Fails if given a `radix` outside the range `[0..36]`.\n  */\n #[inline]\n pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n+    if radix > 36 {\n+        die!(fmt!(\"to_digit: radix %? is to high (maximum 36)\", radix));\n+    }\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n       'a' .. 'z' => c as uint + 10u - ('a' as uint),\n@@ -140,6 +166,30 @@ pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n     else { None }\n }\n \n+/**\n+ * Converts a number to the ascii character representing it.\n+ *\n+ * Returns `Some(char)` if `num` represents one digit under `radix`,\n+ * using one character of `0-9` or `a-z`, or `None` if it doesn't.\n+ *\n+ * Fails if given an `radix` > 36.\n+ */\n+#[inline]\n+pub pure fn from_digit(num: uint, radix: uint) -> Option<char> {\n+    if radix > 36 {\n+        die!(fmt!(\"from_digit: radix %? is to high (maximum 36)\", num));\n+    }\n+    if num < radix {\n+        if num < 10 {\n+            Some(('0' as uint + num) as char)\n+        } else {\n+            Some(('a' as uint + num - 10u) as char)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n /**\n  * Return the hexadecimal unicode escape of a char.\n  *\n@@ -150,7 +200,7 @@ pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n pub pure fn escape_unicode(c: char) -> ~str {\n-    let s = u32::to_str(c as u32, 16u);\n+    let s = u32::to_str_radix(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n                     else { ('U', 8u) });"}, {"sha": "1967f1771bea97935e1cf88dabf86729c1856917", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -88,7 +88,6 @@ struct Task {\n     kernel: *Kernel,                    // 112\n     name: *c_char,                      // 116\n     list_index: i32,                    // 120\n-    rendezvous_ptr: *uintptr_t,         // 124\n     boxed_region: BoxedRegion           // 128\n }\n \n@@ -107,7 +106,6 @@ struct Task {\n     kernel: *Kernel,\n     name: *c_char,\n     list_index: i32,\n-    rendezvous_ptr: *uintptr_t,\n     boxed_region: BoxedRegion\n }\n "}, {"sha": "8ad4ad7cd8cb88356b2bfad25bf8c140629f570d", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -37,7 +37,7 @@ impl<T, U> Condition<T, U> {\n \n     fn raise(t: T) -> U {\n         let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n-        self.raise_default(t, || fail copy msg)\n+        self.raise_default(t, || die!(copy msg))\n     }\n \n     fn raise_default(t: T, default: &fn() -> U) -> U {"}, {"sha": "aece60652a21a74b4ed888dd929cbf08b639b963", "filename": "src/libcore/core.rc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -60,30 +60,33 @@ pub mod prelude;\n \n /* Primitive types */\n \n-#[path = \"int-template.rs\"] #[merge = \"int-template/int.rs\"]\n+#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/int.rs\"]\n pub mod int;\n-#[path = \"int-template.rs\"] #[merge = \"int-template/i8.rs\"]\n+#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i8.rs\"]\n pub mod i8;\n-#[path = \"int-template.rs\"] #[merge = \"int-template/i16.rs\"]\n+#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i16.rs\"]\n pub mod i16;\n-#[path = \"int-template.rs\"] #[merge = \"int-template/i32.rs\"]\n+#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i32.rs\"]\n pub mod i32;\n-#[path = \"int-template.rs\"] #[merge = \"int-template/i64.rs\"]\n+#[path = \"num/int-template.rs\"] #[merge = \"num/int-template/i64.rs\"]\n pub mod i64;\n-#[path = \"uint-template.rs\"] #[merge = \"uint-template/uint.rs\"]\n+#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/uint.rs\"]\n pub mod uint;\n \n-#[path = \"uint-template.rs\"] #[merge = \"uint-template/u8.rs\"]\n+#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u8.rs\"]\n pub mod u8;\n-#[path = \"uint-template.rs\"] #[merge = \"uint-template/u16.rs\"]\n+#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u16.rs\"]\n pub mod u16;\n-#[path = \"uint-template.rs\"] #[merge = \"uint-template/u32.rs\"]\n+#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u32.rs\"]\n pub mod u32;\n-#[path = \"uint-template.rs\"] #[merge = \"uint-template/u64.rs\"]\n+#[path = \"num/uint-template.rs\"] #[merge = \"num/uint-template/u64.rs\"]\n pub mod u64;\n \n+#[path = \"num/float.rs\"]\n pub mod float;\n+#[path = \"num/f32.rs\"]\n pub mod f32;\n+#[path = \"num/f64.rs\"]\n pub mod f64;\n \n pub mod nil;\n@@ -116,6 +119,7 @@ pub mod managed;\n /* Common traits */\n \n pub mod from_str;\n+#[path = \"num/num.rs\"]\n pub mod num;\n pub mod iter;\n pub mod to_str;\n@@ -144,7 +148,6 @@ pub mod hashmap;\n \n /* Tasks and communication */\n \n-pub mod oldcomm;\n #[path = \"task/mod.rs\"]\n pub mod task;\n pub mod pipes;\n@@ -233,6 +236,7 @@ pub mod private;\n /* For internal use, not exported */\n \n mod unicode;\n+#[path = \"num/cmath.rs\"]\n mod cmath;\n mod stackwalk;\n \n@@ -251,6 +255,7 @@ pub mod core {\n     pub use condition;\n     pub use option;\n     pub use kinds;\n+    pub use sys;\n }\n \n "}, {"sha": "d4216b283a9b35bc452479e46f0dc9012fba2147", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -48,18 +48,18 @@ priv impl<T> DListNode<T> {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n               Some(me) => if !managed::ptr_eq(self, me) {\n-                  fail ~\"Asymmetric next-link in dlist node.\"\n+                  die!(~\"Asymmetric next-link in dlist node.\")\n               },\n-              None => fail ~\"One-way next-link in dlist node.\"\n+              None => die!(~\"One-way next-link in dlist node.\")\n             },\n             None => ()\n         }\n         match self.prev {\n             Some(neighbour) => match neighbour.next {\n               Some(me) => if !managed::ptr_eq(me, self) {\n-                  fail ~\"Asymmetric prev-link in dlist node.\"\n+                  die!(~\"Asymmetric prev-link in dlist node.\")\n               },\n-              None => fail ~\"One-way prev-link in dlist node.\"\n+              None => die!(~\"One-way prev-link in dlist node.\")\n             },\n             None => ()\n         }\n@@ -76,7 +76,7 @@ impl<T> DListNode<T> {\n     pure fn next_node(@self) -> @DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n-            None       => fail ~\"This dlist node has no next neighbour.\"\n+            None       => die!(~\"This dlist node has no next neighbour.\")\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n@@ -88,7 +88,7 @@ impl<T> DListNode<T> {\n     pure fn prev_node(@self) -> @DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n-            None       => fail ~\"This dlist node has no previous neighbour.\"\n+            None       => die!(~\"This dlist node has no previous neighbour.\")\n         }\n     }\n }\n@@ -135,21 +135,21 @@ priv impl<T> DList<T> {\n         // These asserts could be stronger if we had node-root back-pointers,\n         // but those wouldn't allow for O(1) append.\n         if self.size == 0 {\n-            fail ~\"This dlist is empty; that node can't be on it.\"\n+            die!(~\"This dlist is empty; that node can't be on it.\")\n         }\n-        if !nobe.linked { fail ~\"That node isn't linked to any dlist.\" }\n+        if !nobe.linked { die!(~\"That node isn't linked to any dlist.\") }\n         if !((nobe.prev.is_some()\n               || managed::ptr_eq(self.hd.expect(~\"headless dlist?\"),\n                                  nobe)) &&\n              (nobe.next.is_some()\n               || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n                                  nobe))) {\n-            fail ~\"That node isn't on this dlist.\"\n+            die!(~\"That node isn't on this dlist.\")\n         }\n     }\n     fn make_mine(nobe: @DListNode<T>) {\n         if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n-            fail ~\"Cannot insert node that's already on a dlist!\"\n+            die!(~\"Cannot insert node that's already on a dlist!\")\n         }\n         nobe.linked = true;\n     }\n@@ -313,14 +313,16 @@ impl<T> DList<T> {\n     pure fn head_n(@self) -> @DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n-            None       => fail ~\"Attempted to get the head of an empty dlist.\"\n+            None       => die!(\n+                ~\"Attempted to get the head of an empty dlist.\")\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n     pure fn tail_n(@self) -> @DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n-            None       => fail ~\"Attempted to get the tail of an empty dlist.\"\n+            None       => die!(\n+                ~\"Attempted to get the tail of an empty dlist.\")\n         }\n     }\n \n@@ -333,7 +335,7 @@ impl<T> DList<T> {\n      */\n     fn append(@self, them: @DList<T>) {\n         if managed::ptr_eq(self, them) {\n-            fail ~\"Cannot append a dlist to itself!\"\n+            die!(~\"Cannot append a dlist to itself!\")\n         }\n         if them.len() > 0 {\n             self.link(self.tl, them.hd);\n@@ -350,7 +352,7 @@ impl<T> DList<T> {\n      */\n     fn prepend(@self, them: @DList<T>) {\n         if managed::ptr_eq(self, them) {\n-            fail ~\"Cannot prepend a dlist to itself!\"\n+            die!(~\"Cannot prepend a dlist to itself!\")\n         }\n         if them.len() > 0 {\n             self.link(them.tl, self.hd);"}, {"sha": "2fd7d71a7fc5d15c77fbf1703edf27b90768c550", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -91,7 +91,7 @@ priv impl<A> DVec<A> {\n         unsafe {\n             let data: *() = cast::reinterpret_cast(&self.data);\n             if data.is_null() {\n-                fail ~\"Recursive use of dvec\";\n+                die!(~\"Recursive use of dvec\");\n             }\n         }\n     }\n@@ -102,7 +102,7 @@ priv impl<A> DVec<A> {\n             let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n             let data_ptr: *() = cast::reinterpret_cast(&data);\n-            if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n+            if data_ptr.is_null() { die!(~\"Recursive use of dvec\"); }\n             return f(move data);\n         }\n     }\n@@ -179,7 +179,7 @@ impl<A> DVec<A> {\n             let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n             let data_ptr: *() = cast::reinterpret_cast(&data);\n-            if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n+            if data_ptr.is_null() { die!(~\"Recursive use of dvec\"); }\n             self.data = move ~[move t];\n             self.data.push_all_move(move data);\n         }\n@@ -329,7 +329,7 @@ impl<A: Copy> DVec<A> {\n \n         let length = self.len();\n         if length == 0 {\n-            fail ~\"attempt to retrieve the last element of an empty vector\";\n+            die!(~\"attempt to retrieve the last element of an empty vector\");\n         }\n \n         return self.data[length - 1];"}, {"sha": "6b327b919e55c8b482a64dfd2bbe3ed65f05c143", "filename": "src/libcore/either.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -136,7 +136,7 @@ pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n     match move eith {\n-        Left(move x) => move x, Right(_) => fail ~\"either::unwrap_left Right\"\n+        Left(move x) => move x, Right(_) => die!(~\"either::unwrap_left Right\")\n     }\n }\n \n@@ -145,7 +145,7 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n     match move eith {\n-        Right(move x) => move x, Left(_) => fail ~\"either::unwrap_right Left\"\n+        Right(move x) => move x, Left(_) => die!(~\"either::unwrap_right Left\")\n     }\n }\n "}, {"sha": "259895da2a5145593475482957f6898dded052da", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -342,7 +342,7 @@ pub mod ct {\n     }\n \n     #[cfg(test)]\n-    fn die(s: &str) -> ! { fail s.to_owned() }\n+    fn die(s: &str) -> ! { die!(s.to_owned()) }\n \n     #[test]\n     fn test_parse_count() {\n@@ -557,7 +557,7 @@ pub mod rt {\n     pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n-              CountImplied => (float::to_str, 6u)\n+              CountImplied => (float::to_str_digits, 6u)\n         };\n         let mut s = unsafe { to_str(f, digits) };\n         if 0.0 <= f {\n@@ -590,7 +590,7 @@ pub mod rt {\n         return if prec == 0u && num == 0u {\n                 ~\"\"\n             } else {\n-                let s = uint::to_str(num, radix);\n+                let s = uint::to_str_radix(num, radix);\n                 let len = str::char_len(s);\n                 if len < prec {\n                     let diff = prec - len;"}, {"sha": "8150bfbe0ee83233f86bdc469b1c9039644bcf03", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -312,7 +312,7 @@ fn expect_sentinel() -> bool { false }\n // heap and stack allocations requiring drop, and runs all\n // destructors.\n //\n-// This should only be called from fail, as it will drop the roots\n+// This should only be called from fail!, as it will drop the roots\n // which are *live* on the stack, rather than dropping those that are\n // dead.\n pub fn cleanup_stack_for_failure() {"}, {"sha": "d676570e1e6cb9df3fb8ab1144a1907873e1d901", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -286,7 +286,7 @@ impl SipState : io::Writer {\n     }\n \n     fn seek(&self, _x: int, _s: io::SeekStyle) {\n-        fail;\n+        die!();\n     }\n     fn tell(&self) -> uint {\n         self.length\n@@ -354,7 +354,7 @@ impl &SipState : Streaming {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for vec::each(r) |b| {\n-            s += uint::to_str(*b as uint, 16u);\n+            s += uint::to_str_radix(*b as uint, 16u);\n         }\n         move s\n     }\n@@ -449,7 +449,7 @@ pub fn test_siphash() {\n     fn to_hex_str(r:  &[u8 * 8]) -> ~str {\n         let mut s = ~\"\";\n         for vec::each(*r) |b| {\n-            s += uint::to_str(*b as uint, 16u);\n+            s += uint::to_str_radix(*b as uint, 16u);\n         }\n         move s\n     }"}, {"sha": "adb16a9290553191a1dc2d5ff7532ff8cc7e217e", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -167,7 +167,7 @@ pub mod linear {\n         /// True if there was no previous entry with that key\n         fn insert_internal(&mut self, hash: uint, k: K, v: V) -> bool {\n             match self.bucket_for_key_with_hash(self.buckets, hash, &k) {\n-                TableFull => { fail ~\"Internal logic error\"; }\n+                TableFull => { die!(~\"Internal logic error\"); }\n                 FoundHole(idx) => {\n                     debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n                            k, v, idx, hash);\n@@ -301,7 +301,7 @@ pub mod linear {\n                             Some(&bkt.value)\n                         }\n                         None => {\n-                            fail ~\"LinearMap::find: internal logic error\"\n+                            die!(~\"LinearMap::find: internal logic error\")\n                         }\n                     }\n                 }\n@@ -386,7 +386,7 @@ pub mod linear {\n         pure fn get(&self, k: &K) -> &self/V {\n             match self.find(k) {\n                 Some(v) => v,\n-                None => fail fmt!(\"No entry found for key: %?\", k),\n+                None => die!(fmt!(\"No entry found for key: %?\", k)),\n             }\n         }\n     }\n@@ -623,7 +623,7 @@ mod test_map {\n         assert m.find(&1).is_none();\n         m.insert(1, 2);\n         match m.find(&1) {\n-            None => fail,\n+            None => die!(),\n             Some(v) => assert *v == 2\n         }\n     }"}, {"sha": "b726cf62cfe52647f7f68996eda2bb90281ec559", "filename": "src/libcore/io.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -611,7 +611,7 @@ impl *libc::FILE: Writer {\n                 if nout != len as size_t {\n                     error!(\"error writing buffer\");\n                     log(error, os::last_os_error());\n-                    fail;\n+                    die!();\n                 }\n             }\n         }\n@@ -661,7 +661,7 @@ impl fd_t: Writer {\n                     if nout < 0 as ssize_t {\n                         error!(\"error writing buffer\");\n                         log(error, os::last_os_error());\n-                        fail;\n+                        die!();\n                     }\n                     count += nout as uint;\n                 }\n@@ -670,11 +670,11 @@ impl fd_t: Writer {\n     }\n     fn seek(&self, _offset: int, _whence: SeekStyle) {\n         error!(\"need 64-bit foreign calls for seek, sorry\");\n-        fail;\n+        die!();\n     }\n     fn tell(&self) -> uint {\n         error!(\"need 64-bit foreign calls for tell, sorry\");\n-        fail;\n+        die!();\n     }\n     fn flush(&self) -> int { 0 }\n     fn get_type(&self) -> WriterType {\n@@ -910,7 +910,7 @@ impl<T: Writer> T : WriterUtil {\n         int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_uint(&self, n: uint) {\n-        uint::to_str_bytes(false, n, 10u, |bytes| self.write(bytes))\n+        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_le_uint(&self, n: uint) {\n         u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n@@ -1279,7 +1279,7 @@ mod tests {\n           result::Err(copy e) => {\n             assert e == ~\"error opening not a file\";\n           }\n-          result::Ok(_) => fail\n+          result::Ok(_) => die!()\n         }\n     }\n \n@@ -1320,7 +1320,7 @@ mod tests {\n           result::Err(copy e) => {\n             assert str::starts_with(e, \"error opening\");\n           }\n-          result::Ok(_) => fail\n+          result::Ok(_) => die!()\n         }\n     }\n \n@@ -1330,7 +1330,7 @@ mod tests {\n           result::Err(copy e) => {\n             assert str::starts_with(e, \"error opening\");\n           }\n-          result::Ok(_) => fail\n+          result::Ok(_) => die!()\n         }\n     }\n "}, {"sha": "cf67d478983cdc69f841ae59983e74fe8d9660d3", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -33,7 +33,7 @@ mod inst {\n             if !f(&nobe.data) { break; }\n             // Check (weakly) that the user didn't do a remove.\n             if self.size == 0 {\n-                fail ~\"The dlist became empty during iteration??\"\n+                die!(~\"The dlist became empty during iteration??\")\n             }\n             if !nobe.linked ||\n                 (!((nobe.prev.is_some()\n@@ -42,7 +42,7 @@ mod inst {\n                    && (nobe.next.is_some()\n                     || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n                                        nobe)))) {\n-                fail ~\"Removing a dlist node during iteration is forbidden!\"\n+                die!(~\"Removing a dlist node during iteration is forbidden!\")\n             }\n             link = nobe.next_link();\n         }"}, {"sha": "2ffa870226179c3976209cb360567c75dafc2b67", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -220,7 +220,7 @@ pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n         }\n     } {\n         Some(move val) => val,\n-        None => fail ~\"min called on empty iterator\"\n+        None => die!(~\"min called on empty iterator\")\n     }\n }\n \n@@ -235,7 +235,7 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n         }\n     } {\n         Some(move val) => val,\n-        None => fail ~\"max called on empty iterator\"\n+        None => die!(~\"max called on empty iterator\")\n     }\n }\n "}, {"sha": "4623a3f45431d6c159979f2e9d5ff6e3c351ac90", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -48,8 +48,8 @@ pub fn unwrap<T>(m: Mut<T>) -> T {\n impl<T> Data<T> {\n     fn borrow_mut<R>(op: &fn(t: &mut T) -> R) -> R {\n         match self.mode {\n-            Immutable => fail fmt!(\"%? currently immutable\",\n-                                   self.value),\n+            Immutable => die!(fmt!(\"%? currently immutable\",\n+                                   self.value)),\n             ReadOnly | Mutable => {}\n         }\n \n@@ -64,8 +64,8 @@ impl<T> Data<T> {\n \n     fn borrow_imm<R>(op: &fn(t: &T) -> R) -> R {\n         match self.mode {\n-          Mutable => fail fmt!(\"%? currently mutable\",\n-                               self.value),\n+          Mutable => die!(fmt!(\"%? currently mutable\",\n+                               self.value)),\n           ReadOnly | Immutable => {}\n         }\n "}, {"sha": "5680e3116bfb661e0c4c9c3a43e55a35bcbdbbcd", "filename": "src/libcore/num.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Flibcore%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Flibcore%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum.rs?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An interface for numeric types\n-\n-pub trait Num {\n-    // FIXME: Trait composition. (#2616)\n-    pure fn add(&self, other: &Self) -> Self;\n-    pure fn sub(&self, other: &Self) -> Self;\n-    pure fn mul(&self, other: &Self) -> Self;\n-    pure fn div(&self, other: &Self) -> Self;\n-    pure fn modulo(&self, other: &Self) -> Self;\n-    pure fn neg(&self) -> Self;\n-\n-    pure fn to_int(&self) -> int;\n-    static pure fn from_int(n: int) -> Self;\n-}\n-\n-pub trait IntConvertible {\n-    pure fn to_int(&self) -> int;\n-    static pure fn from_int(n: int) -> Self;\n-}\n-\n-pub trait Zero {\n-    static pure fn zero() -> Self;\n-}\n-\n-pub trait One {\n-    static pure fn one() -> Self;\n-}"}, {"sha": "6341481809e21685875edef693821a0ec27ff32f", "filename": "src/libcore/num/cmath.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fcmath.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/cmath.rs"}, {"sha": "24ad5c114af28716bfc31b65ef70bb428d474dbb", "filename": "src/libcore/num/f32.rs", "status": "renamed", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -18,6 +18,9 @@ use cmath;\n use cmp;\n use libc::{c_float, c_int};\n use num;\n+use option::Option;\n+use from_str;\n+use to_str;\n \n pub use cmath::c_float_targ_consts::*;\n \n@@ -306,6 +309,246 @@ pub extern {\n     fn floorf32(val: f32) -> f32;\n }\n \n+impl f32: num::Round {\n+    #[inline(always)]\n+    pure fn round(&self, mode: num::RoundMode) -> f32 {\n+        match mode {\n+            num::RoundDown                           => floor(*self),\n+            num::RoundUp                             => ceil(*self),\n+            num::RoundToZero   if is_negative(*self) => ceil(*self),\n+            num::RoundToZero                         => floor(*self),\n+            num::RoundFromZero if is_negative(*self) => floor(*self),\n+            num::RoundFromZero                       => ceil(*self)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pure fn floor(&self) -> f32 { floor(*self) }\n+    #[inline(always)]\n+    pure fn ceil(&self) -> f32 { ceil(*self) }\n+    #[inline(always)]\n+    pure fn fract(&self) -> f32 {\n+        if is_negative(*self) {\n+            (*self) - ceil(*self)\n+        } else {\n+            (*self) - floor(*self)\n+        }\n+    }\n+}\n+\n+/**\n+ * Section: String Conversions\n+ */\n+\n+/**\n+ * Converts a float to a string\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str(num: f32) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in hexadecimal format\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str_hex(num: f32) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in a given radix\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ *\n+ * # Failure\n+ *\n+ * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+ * possible misinterpretation of the result at higher bases. If those values\n+ * are expected, use `to_str_radix_special()` instead.\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix(num: f32, rdx: uint) -> ~str {\n+    let (r, special) = num::to_str_common(\n+        &num, rdx, true, true, num::SignNeg, num::DigAll);\n+    if special { die!(~\"number has a special value, \\\n+                      try to_str_radix_special() if those are expected\") }\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in a given radix, and a flag indicating\n+ * whether it's a special value\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n+    num::to_str_common(&num, rdx, true, true, num::SignNeg, num::DigAll)\n+}\n+\n+/**\n+ * Converts a float to a string with exactly the number of\n+ * provided significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_exact(num: f32, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigExact(dig));\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string with a maximum number of\n+ * significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_digits(num: f32, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigMax(dig));\n+    r\n+}\n+\n+impl f32: to_str::ToStr {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+}\n+\n+impl f32: num::ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+        to_str_radix(*self, rdx)\n+    }\n+}\n+\n+/**\n+ * Convert a string in base 10 to a float.\n+ * Accepts a optional decimal exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * '3.14'\n+ * * '+3.14', equivalent to '3.14'\n+ * * '-3.14'\n+ * * '2.5E10', or equivalently, '2.5e10'\n+ * * '2.5E-10'\n+ * * '.' (understood as 0)\n+ * * '5.'\n+ * * '.5', or, equivalently,  '0.5'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str(num: &str) -> Option<f32> {\n+    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+}\n+\n+/**\n+ * Convert a string in base 16 to a float.\n+ * Accepts a optional binary exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * 'a4.fe'\n+ * * '+a4.fe', equivalent to 'a4.fe'\n+ * * '-a4.fe'\n+ * * '2b.aP128', or equivalently, '2b.ap128'\n+ * * '2b.aP-128'\n+ * * '.' (understood as 0)\n+ * * 'c.'\n+ * * '.c', or, equivalently,  '0.c'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_hex(num: &str) -> Option<f32> {\n+    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+}\n+\n+/**\n+ * Convert a string in an given base to a float.\n+ *\n+ * Due to possible conflicts, this function does **not** accept\n+ * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+ * does it recognize exponents of any kind.\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ * * radix - The base to use. Must lie in the range [2 .. 36]\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number. Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f32> {\n+    num::from_str_common(num, rdx, true, true, false, num::ExpNone, false)\n+}\n+\n+impl f32: from_str::FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(val: &str) -> Option<f32> { from_str(val) }\n+}\n+\n+impl f32: num::FromStrRadix {\n+    #[inline(always)]\n+    static pure fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n+        from_str_radix(val, rdx)\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust", "previous_filename": "src/libcore/f32.rs"}, {"sha": "126a48cf28073935c09465fb1b1cd46a3417fae5", "filename": "src/libcore/num/f64.rs", "status": "renamed", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -19,6 +19,9 @@ use cmp;\n use libc::{c_double, c_int};\n use libc;\n use num;\n+use option::Option;\n+use to_str;\n+use from_str;\n \n pub use cmath::c_double_targ_consts::*;\n \n@@ -330,6 +333,246 @@ pub extern {\n     fn floorf64(val: f64) -> f64;\n }\n \n+impl f64: num::Round {\n+    #[inline(always)]\n+    pure fn round(&self, mode: num::RoundMode) -> f64 {\n+        match mode {\n+            num::RoundDown                           => floor(*self),\n+            num::RoundUp                             => ceil(*self),\n+            num::RoundToZero   if is_negative(*self) => ceil(*self),\n+            num::RoundToZero                         => floor(*self),\n+            num::RoundFromZero if is_negative(*self) => floor(*self),\n+            num::RoundFromZero                       => ceil(*self)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pure fn floor(&self) -> f64 { floor(*self) }\n+    #[inline(always)]\n+    pure fn ceil(&self) -> f64 { ceil(*self) }\n+    #[inline(always)]\n+    pure fn fract(&self) -> f64 {\n+        if is_negative(*self) {\n+            (*self) - ceil(*self)\n+        } else {\n+            (*self) - floor(*self)\n+        }\n+    }\n+}\n+\n+/**\n+ * Section: String Conversions\n+ */\n+\n+/**\n+ * Converts a float to a string\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str(num: f64) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in hexadecimal format\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str_hex(num: f64) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in a given radix\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ *\n+ * # Failure\n+ *\n+ * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+ * possible misinterpretation of the result at higher bases. If those values\n+ * are expected, use `to_str_radix_special()` instead.\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix(num: f64, rdx: uint) -> ~str {\n+    let (r, special) = num::to_str_common(\n+        &num, rdx, true, true, num::SignNeg, num::DigAll);\n+    if special { die!(~\"number has a special value, \\\n+                      try to_str_radix_special() if those are expected\") }\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string in a given radix, and a flag indicating\n+ * whether it's a special value\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n+    num::to_str_common(&num, rdx, true, true, num::SignNeg, num::DigAll)\n+}\n+\n+/**\n+ * Converts a float to a string with exactly the number of\n+ * provided significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_exact(num: f64, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigExact(dig));\n+    r\n+}\n+\n+/**\n+ * Converts a float to a string with a maximum number of\n+ * significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n+#[inline(always)]\n+pub pure fn to_str_digits(num: f64, dig: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigMax(dig));\n+    r\n+}\n+\n+impl f64: to_str::ToStr {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+}\n+\n+impl f64: num::ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, rdx: uint) -> ~str {\n+        to_str_radix(*self, rdx)\n+    }\n+}\n+\n+/**\n+ * Convert a string in base 10 to a float.\n+ * Accepts a optional decimal exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * '3.14'\n+ * * '+3.14', equivalent to '3.14'\n+ * * '-3.14'\n+ * * '2.5E10', or equivalently, '2.5e10'\n+ * * '2.5E-10'\n+ * * '.' (understood as 0)\n+ * * '5.'\n+ * * '.5', or, equivalently,  '0.5'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str(num: &str) -> Option<f64> {\n+    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+}\n+\n+/**\n+ * Convert a string in base 16 to a float.\n+ * Accepts a optional binary exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * 'a4.fe'\n+ * * '+a4.fe', equivalent to 'a4.fe'\n+ * * '-a4.fe'\n+ * * '2b.aP128', or equivalently, '2b.ap128'\n+ * * '2b.aP-128'\n+ * * '.' (understood as 0)\n+ * * 'c.'\n+ * * '.c', or, equivalently,  '0.c'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_hex(num: &str) -> Option<f64> {\n+    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+}\n+\n+/**\n+ * Convert a string in an given base to a float.\n+ *\n+ * Due to possible conflicts, this function does **not** accept\n+ * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+ * does it recognize exponents of any kind.\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ * * radix - The base to use. Must lie in the range [2 .. 36]\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number. Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_radix(num: &str, rdx: uint) -> Option<f64> {\n+    num::from_str_common(num, rdx, true, true, false, num::ExpNone, false)\n+}\n+\n+impl f64: from_str::FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(val: &str) -> Option<f64> { from_str(val) }\n+}\n+\n+impl f64: num::FromStrRadix {\n+    #[inline(always)]\n+    static pure fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n+        from_str_radix(val, rdx)\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust", "previous_filename": "src/libcore/f64.rs"}, {"sha": "32cda029cd182bdb78893caecfa21bc9347beb85", "filename": "src/libcore/num/float.rs", "status": "renamed", "additions": 276, "deletions": 206, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -34,6 +34,8 @@ use num::Num::from_int;\n use option::{None, Option, Some};\n use str;\n use uint;\n+use to_str;\n+use from_str;\n \n pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n@@ -95,7 +97,7 @@ pub mod consts {\n     pub const ln_10: float = 2.30258509299404568401799145468436421;\n }\n \n-/**\n+/*\n  * Section: String Conversions\n  */\n \n@@ -105,85 +107,63 @@ pub mod consts {\n  * # Arguments\n  *\n  * * num - The float value\n- * * digits - The number of significant digits\n- * * exact - Whether to enforce the exact number of significant digits\n  */\n-pub pure fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n-    if is_NaN(num) { return ~\"NaN\"; }\n-    if num == infinity { return ~\"inf\"; }\n-    if num == neg_infinity { return ~\"-inf\"; }\n-\n-    let mut (num, sign) = if num < 0.0 { (-num, ~\"-\") } else { (num, ~\"\") };\n-\n-    // truncated integer\n-    let trunc = num as uint;\n-\n-    // decimal remainder\n-    let mut frac = num - (trunc as float);\n-\n-    // stack of digits\n-    let mut fractionalParts = ~[];\n-\n-    // FIXME: (#2608)\n-    // This used to return right away without rounding, as \"~[-]num\",\n-    // but given epsilon like in f64.rs, I don't see how the comparison\n-    // to epsilon did much when only used there.\n-    //    if (frac < epsilon && !exact) || digits == 0u { return accum; }\n-    //\n-    // With something better, possibly weird results like this can be avoided:\n-    //     assert \"3.14158999999999988262\" == my_to_str_exact(3.14159, 20u);\n-\n-    let mut ii = digits;\n-    let mut epsilon_prime = 1.0 / pow_with_uint(10u, ii);\n-\n-    // while we still need digits\n-    // build stack of digits\n-    while ii > 0 && (frac >= epsilon_prime || exact) {\n-        // store the next digit\n-        frac *= 10.0;\n-        let digit = frac as uint;\n-        // Bleh: not really unsafe.\n-        unsafe { fractionalParts.push(digit); }\n-\n-        // calculate the next frac\n-        frac -= digit as float;\n-        epsilon_prime *= 10.0;\n-        ii -= 1u;\n-    }\n-\n-    let mut acc;\n-    let mut racc = ~\"\";\n-    let mut carry = if frac * 10.0 as uint >= 5 { 1 } else { 0 };\n-\n-    // turn digits into string\n-    // using stack of digits\n-    while !fractionalParts.is_empty() {\n-        // Bleh; shouldn't need to be unsafe\n-        let mut adjusted_digit = carry + unsafe { fractionalParts.pop() };\n-\n-        if adjusted_digit == 10 {\n-            carry = 1;\n-            adjusted_digit %= 10\n-        } else {\n-            carry = 0;\n-        };\n+#[inline(always)]\n+pub pure fn to_str(num: float) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n \n-        racc = uint::str(adjusted_digit) + racc;\n-    }\n+/**\n+ * Converts a float to a string in hexadecimal format\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ */\n+#[inline(always)]\n+pub pure fn to_str_hex(num: float) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 16u, true, true, num::SignNeg, num::DigAll);\n+    r\n+}\n \n-    // pad decimals with trailing zeroes\n-    while racc.len() < digits && exact {\n-        racc += ~\"0\"\n-    }\n+/**\n+ * Converts a float to a string in a given radix\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ *\n+ * # Failure\n+ *\n+ * Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+ * possible misinterpretation of the result at higher bases. If those values\n+ * are expected, use `to_str_radix_special()` instead.\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix(num: float, radix: uint) -> ~str {\n+    let (r, special) = num::to_str_common(\n+        &num, radix, true, true, num::SignNeg, num::DigAll);\n+    if special { die!(~\"number has a special value, \\\n+                      try to_str_radix_special() if those are expected\") }\n+    r\n+}\n \n-    // combine ints and decimals\n-    let mut ones = uint::str(trunc + carry);\n-    if racc == ~\"\" {\n-        acc = sign + ones;\n-    } else {\n-        acc = sign + ones + ~\".\" + racc;\n-    }\n-    move acc\n+/**\n+ * Converts a float to a string in a given radix, and a flag indicating\n+ * whether it's a special value\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * radix - The base to use\n+ */\n+#[inline(always)]\n+pub pure fn to_str_radix_special(num: float, radix: uint) -> (~str, bool) {\n+    num::to_str_common(&num, radix, true, true, num::SignNeg, num::DigAll)\n }\n \n /**\n@@ -197,7 +177,9 @@ pub pure fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n  */\n #[inline(always)]\n pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n-    to_str_common(num, digits, true)\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigExact(digits));\n+    r\n }\n \n #[test]\n@@ -206,7 +188,6 @@ pub fn test_to_str_exact_do_decimal() {\n     assert s == ~\"5.0000\";\n }\n \n-\n /**\n  * Converts a float to a string with a maximum number of\n  * significant digits\n@@ -217,12 +198,27 @@ pub fn test_to_str_exact_do_decimal() {\n  * * digits - The number of significant digits\n  */\n #[inline(always)]\n-pub pure fn to_str(num: float, digits: uint) -> ~str {\n-    to_str_common(num, digits, false)\n+pub pure fn to_str_digits(num: float, digits: uint) -> ~str {\n+    let (r, _) = num::to_str_common(\n+        &num, 10u, true, true, num::SignNeg, num::DigMax(digits));\n+    r\n+}\n+\n+impl float: to_str::ToStr {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str { to_str_digits(*self, 8) }\n+}\n+\n+impl float: num::ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+        to_str_radix(*self, radix)\n+    }\n }\n \n /**\n- * Convert a string to a float\n+ * Convert a string in base 10 to a float.\n+ * Accepts a optional decimal exponent.\n  *\n  * This function accepts strings such as\n  *\n@@ -231,12 +227,12 @@ pub pure fn to_str(num: float, digits: uint) -> ~str {\n  * * '-3.14'\n  * * '2.5E10', or equivalently, '2.5e10'\n  * * '2.5E-10'\n- * * '', or, equivalently, '.' (understood as 0)\n+ * * '.' (understood as 0)\n  * * '5.'\n  * * '.5', or, equivalently,  '0.5'\n- * * 'inf', '-inf', 'NaN'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n  *\n- * Leading and trailing whitespace are ignored.\n+ * Leading and trailing whitespace represent an error.\n  *\n  * # Arguments\n  *\n@@ -245,125 +241,79 @@ pub pure fn to_str(num: float, digits: uint) -> ~str {\n  * # Return value\n  *\n  * `none` if the string did not represent a valid number.  Otherwise,\n- * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n  */\n+#[inline(always)]\n pub pure fn from_str(num: &str) -> Option<float> {\n-   if num == \"inf\" {\n-       return Some(infinity as float);\n-   } else if num == \"-inf\" {\n-       return Some(neg_infinity as float);\n-   } else if num == \"NaN\" {\n-       return Some(NaN as float);\n-   }\n-\n-   let mut pos = 0u;               //Current byte position in the string.\n-                                   //Used to walk the string in O(n).\n-   let len = str::len(num);        //Length of the string, in bytes.\n-\n-   if len == 0u { return None; }\n-   let mut total = 0f;             //Accumulated result\n-   let mut c     = 'z';            //Latest char.\n-\n-   //The string must start with one of the following characters.\n-   match str::char_at(num, 0u) {\n-      '-' | '+' | '0' .. '9' | '.' => (),\n-      _ => return None\n-   }\n-\n-   //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n-   let mut neg = false;               //Sign of the result\n-   match str::char_at(num, 0u) {\n-      '-' => {\n-          neg = true;\n-          pos = 1u;\n-      }\n-      '+' => {\n-          pos = 1u;\n-      }\n-      _ => ()\n-   }\n+    num::from_str_common(num, 10u, true, true, true, num::ExpDec, false)\n+}\n \n-   //Examine the following chars until '.', 'e', 'E'\n-   while(pos < len) {\n-       let char_range = str::char_range_at(num, pos);\n-       c   = char_range.ch;\n-       pos = char_range.next;\n-       match c {\n-         '0' .. '9' => {\n-           total = total * 10f;\n-           total += ((c as int) - ('0' as int)) as float;\n-         }\n-         '.' | 'e' | 'E' => break,\n-         _ => return None\n-       }\n-   }\n+/**\n+ * Convert a string in base 16 to a float.\n+ * Accepts a optional binary exponent.\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * 'a4.fe'\n+ * * '+a4.fe', equivalent to 'a4.fe'\n+ * * '-a4.fe'\n+ * * '2b.aP128', or equivalently, '2b.ap128'\n+ * * '2b.aP-128'\n+ * * '.' (understood as 0)\n+ * * 'c.'\n+ * * '.c', or, equivalently,  '0.c'\n+ * * '+inf', 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_hex(num: &str) -> Option<float> {\n+    num::from_str_common(num, 16u, true, true, true, num::ExpBin, false)\n+}\n \n-   if c == '.' {//Examine decimal part\n-      let mut decimal = 1f;\n-      while(pos < len) {\n-         let char_range = str::char_range_at(num, pos);\n-         c = char_range.ch;\n-         pos = char_range.next;\n-         match c {\n-            '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9'  => {\n-                 decimal /= 10f;\n-                 total += (((c as int) - ('0' as int)) as float)*decimal;\n-             }\n-             'e' | 'E' => break,\n-             _ => return None\n-         }\n-      }\n-   }\n+/**\n+ * Convert a string in an given base to a float.\n+ *\n+ * Due to possible conflicts, this function does **not** accept\n+ * the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n+ * does it recognize exponents of any kind.\n+ *\n+ * Leading and trailing whitespace represent an error.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ * * radix - The base to use. Must lie in the range [2 .. 36]\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number. Otherwise,\n+ * `Some(n)` where `n` is the floating-point number represented by `num`.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_radix(num: &str, radix: uint) -> Option<float> {\n+    num::from_str_common(num, radix, true, true, false, num::ExpNone, false)\n+}\n \n-   if (c == 'e') || (c == 'E') { //Examine exponent\n-      let mut exponent = 0u;\n-      let mut neg_exponent = false;\n-      if(pos < len) {\n-          let char_range = str::char_range_at(num, pos);\n-          c   = char_range.ch;\n-          match c  {\n-             '+' => {\n-                pos = char_range.next;\n-             }\n-             '-' => {\n-                pos = char_range.next;\n-                neg_exponent = true;\n-             }\n-             _ => ()\n-          }\n-          while(pos < len) {\n-             let char_range = str::char_range_at(num, pos);\n-             c = char_range.ch;\n-             match c {\n-                 '0' | '1' | '2' | '3' | '4' | '5' | '6'| '7' | '8' | '9' => {\n-                     exponent *= 10u;\n-                     exponent += ((c as uint) - ('0' as uint));\n-                 }\n-                 _ => break\n-             }\n-             pos = char_range.next;\n-          }\n-          let multiplier = pow_with_uint(10u, exponent);\n-              //Note: not ~[int::pow], otherwise, we'll quickly\n-              //end up with a nice overflow\n-          if neg_exponent {\n-             total = total / multiplier;\n-          } else {\n-             total = total * multiplier;\n-          }\n-      } else {\n-         return None;\n-      }\n-   }\n+impl float: from_str::FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(val: &str) -> Option<float> { from_str(val) }\n+}\n \n-   if(pos < len) {\n-     return None;\n-   } else {\n-     if(neg) {\n-        total *= -1f;\n-     }\n-     return Some(total);\n-   }\n+impl float: num::FromStrRadix {\n+    #[inline(always)]\n+    static pure fn from_str_radix(val: &str, radix: uint) -> Option<float> {\n+        from_str_radix(val, radix)\n+    }\n }\n \n /**\n@@ -488,9 +438,41 @@ impl float: num::One {\n     static pure fn one() -> float { 1.0 }\n }\n \n+impl float: num::Round {\n+    #[inline(always)]\n+    pure fn round(&self, mode: num::RoundMode) -> float {\n+        match mode {\n+            num::RoundDown\n+                => f64::floor(*self as f64) as float,\n+            num::RoundUp\n+                => f64::ceil(*self as f64) as float,\n+            num::RoundToZero   if is_negative(*self)\n+                => f64::ceil(*self as f64) as float,\n+            num::RoundToZero\n+                => f64::floor(*self as f64) as float,\n+            num::RoundFromZero if is_negative(*self)\n+                => f64::floor(*self as f64) as float,\n+            num::RoundFromZero\n+                => f64::ceil(*self as f64) as float\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pure fn floor(&self) -> float { f64::floor(*self as f64) as float}\n+    #[inline(always)]\n+    pure fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n+    #[inline(always)]\n+    pure fn fract(&self) -> float {\n+        if is_negative(*self) {\n+            (*self) - (f64::ceil(*self as f64) as float)\n+        } else {\n+            (*self) - (f64::floor(*self as f64) as float)\n+        }\n+    }\n+}\n+\n #[test]\n pub fn test_from_str() {\n-   assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3.14\") == Some(3.14);\n    assert from_str(~\"+3.14\") == Some(3.14);\n@@ -504,19 +486,24 @@ pub fn test_from_str() {\n    assert from_str(~\"5.\") == Some(5.);\n    assert from_str(~\".5\") == Some(0.5);\n    assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"-.5\") == Some(-0.5);\n    assert from_str(~\"-.5\") == Some(-0.5);\n    assert from_str(~\"-5\") == Some(-5.);\n-   assert from_str(~\"-0\") == Some(-0.);\n-   assert from_str(~\"0\") == Some(0.);\n    assert from_str(~\"inf\") == Some(infinity);\n+   assert from_str(~\"+inf\") == Some(infinity);\n    assert from_str(~\"-inf\") == Some(neg_infinity);\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str(~\"NaN\") {\n        Some(f) => assert is_NaN(f),\n-       None => fail\n+       None => die!()\n+   }\n+   // note: -0 == 0, hence these slightly more complex tests\n+   match from_str(~\"-0\") {\n+       Some(v) if is_zero(v) => assert is_negative(v),\n+       _ => die!()\n+   }\n+   match from_str(~\"0\") {\n+       Some(v) if is_zero(v) => assert is_positive(v),\n+       _ => die!()\n    }\n \n    assert from_str(~\"\").is_none();\n@@ -531,6 +518,89 @@ pub fn test_from_str() {\n    assert from_str(~\"1e1-1\").is_none();\n }\n \n+#[test]\n+pub fn test_from_str_hex() {\n+   assert from_str_hex(~\"a4\") == Some(164.);\n+   assert from_str_hex(~\"a4.fe\") == Some(164.9921875);\n+   assert from_str_hex(~\"-a4.fe\") == Some(-164.9921875);\n+   assert from_str_hex(~\"+a4.fe\") == Some(164.9921875);\n+   assert from_str_hex(~\"ff0P4\") == Some(0xff00 as float);\n+   assert from_str_hex(~\"ff0p4\") == Some(0xff00 as float);\n+   assert from_str_hex(~\"ff0p-4\") == Some(0xff as float);\n+   assert from_str_hex(~\".\") == Some(0.);\n+   assert from_str_hex(~\".p1\") == Some(0.);\n+   assert from_str_hex(~\".p-1\") == Some(0.);\n+   assert from_str_hex(~\"f.\") == Some(15.);\n+   assert from_str_hex(~\".f\") == Some(0.9375);\n+   assert from_str_hex(~\"0.f\") == Some(0.9375);\n+   assert from_str_hex(~\"-.f\") == Some(-0.9375);\n+   assert from_str_hex(~\"-f\") == Some(-15.);\n+   assert from_str_hex(~\"inf\") == Some(infinity);\n+   assert from_str_hex(~\"+inf\") == Some(infinity);\n+   assert from_str_hex(~\"-inf\") == Some(neg_infinity);\n+   // note: NaN != NaN, hence this slightly complex test\n+   match from_str_hex(~\"NaN\") {\n+       Some(f) => assert is_NaN(f),\n+       None => die!()\n+   }\n+   // note: -0 == 0, hence these slightly more complex tests\n+   match from_str_hex(~\"-0\") {\n+       Some(v) if is_zero(v) => assert is_negative(v),\n+       _ => die!()\n+   }\n+   match from_str_hex(~\"0\") {\n+       Some(v) if is_zero(v) => assert is_positive(v),\n+       _ => die!()\n+   }\n+   assert from_str_hex(~\"e\") == Some(14.);\n+   assert from_str_hex(~\"E\") == Some(14.);\n+   assert from_str_hex(~\"E1\") == Some(225.);\n+   assert from_str_hex(~\"1e1e1\") == Some(123361.);\n+   assert from_str_hex(~\"1e1.1\") == Some(481.0625);\n+\n+   assert from_str_hex(~\"\").is_none();\n+   assert from_str_hex(~\"x\").is_none();\n+   assert from_str_hex(~\" \").is_none();\n+   assert from_str_hex(~\"   \").is_none();\n+   assert from_str_hex(~\"p\").is_none();\n+   assert from_str_hex(~\"P\").is_none();\n+   assert from_str_hex(~\"P1\").is_none();\n+   assert from_str_hex(~\"1p1p1\").is_none();\n+   assert from_str_hex(~\"1p1.1\").is_none();\n+   assert from_str_hex(~\"1p1-1\").is_none();\n+}\n+\n+#[test]\n+pub fn test_to_str_hex() {\n+   assert to_str_hex(164.) == ~\"a4\";\n+   assert to_str_hex(164.9921875) == ~\"a4.fe\";\n+   assert to_str_hex(-164.9921875) == ~\"-a4.fe\";\n+   assert to_str_hex(0xff00 as float) == ~\"ff00\";\n+   assert to_str_hex(-(0xff00 as float)) == ~\"-ff00\";\n+   assert to_str_hex(0.) == ~\"0\";\n+   assert to_str_hex(15.) == ~\"f\";\n+   assert to_str_hex(-15.) == ~\"-f\";\n+   assert to_str_hex(0.9375) == ~\"0.f\";\n+   assert to_str_hex(-0.9375) == ~\"-0.f\";\n+   assert to_str_hex(infinity) == ~\"inf\";\n+   assert to_str_hex(neg_infinity) == ~\"-inf\";\n+   assert to_str_hex(NaN) == ~\"NaN\";\n+   assert to_str_hex(0.) == ~\"0\";\n+   assert to_str_hex(-0.) == ~\"-0\";\n+}\n+\n+#[test]\n+pub fn test_to_str_radix() {\n+   assert to_str_radix(36., 36u) == ~\"10\";\n+   assert to_str_radix(8.125, 2u) == ~\"1000.001\";\n+}\n+\n+#[test]\n+pub fn test_from_str_radix() {\n+   assert from_str_radix(~\"10\", 36u) == Some(36.);\n+   assert from_str_radix(~\"1000.001\", 2u) == Some(8.125);\n+}\n+\n #[test]\n pub fn test_positive() {\n   assert(is_positive(infinity));\n@@ -577,8 +647,8 @@ pub fn test_nonnegative() {\n \n #[test]\n pub fn test_to_str_inf() {\n-    assert to_str(infinity, 10u) == ~\"inf\";\n-    assert to_str(-infinity, 10u) == ~\"-inf\";\n+    assert to_str_digits(infinity, 10u) == ~\"inf\";\n+    assert to_str_digits(-infinity, 10u) == ~\"-inf\";\n }\n \n #[test]", "previous_filename": "src/libcore/float.rs"}, {"sha": "8b02f3a94c5ff94450367e1d869942b6fcdbfff5", "filename": "src/libcore/num/int-template.rs", "status": "renamed", "additions": 162, "deletions": 65, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -17,13 +17,18 @@ use T = self::inst::T;\n use char;\n use cmp::{Eq, Ord};\n use cmp;\n+use to_str::ToStr;\n use from_str::FromStr;\n+use num::{ToStrRadix, FromStrRadix};\n use num;\n use num::Num::from_int;\n use prelude::*;\n use str;\n use uint;\n use vec;\n+use i8;\n+use i16;\n+use i32;\n \n pub const bits : uint = inst::bits;\n pub const bytes : uint = (inst::bits / 8);\n@@ -112,7 +117,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n pub pure fn range_step(start: T, stop: T, step: T, it: fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n-        fail ~\"range_step called with step == 0\";\n+        die!(~\"range_step called with step == 0\");\n     } else if step > 0 { // ascending\n         while i < stop {\n             if !it(i) { break }\n@@ -200,83 +205,112 @@ impl T: num::One {\n     static pure fn one() -> T { 1 }\n }\n \n-/**\n- * Parse a buffer of bytes\n- *\n- * # Arguments\n- *\n- * * buf - A byte buffer\n- * * radix - The base of the number\n- */\n-pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n-    if vec::len(buf) == 0u { return None; }\n-    let mut i = vec::len(buf) - 1u;\n-    let mut start = 0u;\n-    let mut power = 1 as T;\n-\n-    if buf[0] == ('-' as u8) {\n-        power = -1 as T;\n-        start = 1u;\n-    }\n-    let mut n = 0 as T;\n-    loop {\n-        match char::to_digit(buf[i] as char, radix) {\n-          Some(d) => n += (d as T) * power,\n-          None => return None\n-        }\n-        power *= radix as T;\n-        if i <= start { return Some(n); }\n-        i -= 1u;\n-    };\n+impl T: num::Round {\n+    #[inline(always)]\n+    pure fn round(&self, _: num::RoundMode) -> T { *self }\n+\n+    #[inline(always)]\n+    pure fn floor(&self) -> T { *self }\n+    #[inline(always)]\n+    pure fn ceil(&self) -> T { *self }\n+    #[inline(always)]\n+    pure fn fract(&self) -> T { 0 }\n+}\n+\n+// String conversion functions and impl str -> num\n+\n+/// Parse a string as a number in base 10.\n+#[inline(always)]\n+pub pure fn from_str(s: &str) -> Option<T> {\n+    num::from_str_common(s, 10u, true, false, false,\n+                         num::ExpNone, false)\n }\n \n-/// Parse a string to an int\n+/// Parse a string as a number in the given base.\n #[inline(always)]\n-pub pure fn from_str(s: &str) -> Option<T>\n-{\n-    parse_bytes(str::to_bytes(s), 10u)\n+pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+    num::from_str_common(s, radix, true, false, false,\n+                         num::ExpNone, false)\n+}\n+\n+/// Parse a byte slice as a number in the given base.\n+#[inline(always)]\n+pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+    num::from_str_bytes_common(buf, radix, true, false, false,\n+                               num::ExpNone, false)\n }\n \n impl T : FromStr {\n     #[inline(always)]\n-    static pure fn from_str(s: &str) -> Option<T> { from_str(s) }\n+    static pure fn from_str(s: &str) -> Option<T> {\n+        from_str(s)\n+    }\n }\n \n-/// Convert to a string in a given base\n-#[inline(always)]\n-pub pure fn to_str(n: T, radix: uint) -> ~str {\n-    do to_str_bytes(n, radix) |slice| {\n-        do vec::as_imm_buf(slice) |p, len| {\n-            unsafe { str::raw::from_buf_len(p, len) }\n-        }\n+impl T : FromStrRadix {\n+    #[inline(always)]\n+    static pure fn from_str_radix(&self, s: &str, radix: uint) -> Option<T> {\n+        from_str_radix(s, radix)\n     }\n }\n \n+// String conversion functions and impl num -> str\n+\n+/// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n-    if n < 0 as T {\n-        uint::to_str_bytes(true, -n as uint, radix, f)\n-    } else {\n-        uint::to_str_bytes(false, n as uint, radix, f)\n-    }\n+    let (buf, _) = num::to_str_bytes_common(&n, radix, false, false,\n+                                            num::SignNeg, num::DigAll);\n+    f(buf)\n }\n \n-/// Convert to a string\n+/// Convert to a string in base 10.\n #[inline(always)]\n-pub pure fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub pure fn to_str(num: T) -> ~str {\n+    let (buf, _) = num::to_str_common(&num, 10u, false, false,\n+                                      num::SignNeg, num::DigAll);\n+    buf\n+}\n+\n+/// Convert to a string in a given base.\n+#[inline(always)]\n+pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n+    let (buf, _) = num::to_str_common(&num, radix, false, false,\n+                                      num::SignNeg, num::DigAll);\n+    buf\n+}\n+\n+/// Convert to a string.\n+/// *Deprecated*, use to_str() instead.\n+#[inline(always)]\n+pub pure fn str(i: T) -> ~str { to_str(i) }\n+\n+impl T : ToStr {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        to_str(*self)\n+    }\n+}\n+\n+impl T : ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+        to_str_radix(*self, radix)\n+    }\n+}\n \n #[test]\n fn test_from_str() {\n     assert from_str(~\"0\") == Some(0 as T);\n     assert from_str(~\"3\") == Some(3 as T);\n     assert from_str(~\"10\") == Some(10 as T);\n-    assert from_str(~\"123456789\") == Some(123456789 as T);\n+    assert i32::from_str(~\"123456789\") == Some(123456789 as i32);\n     assert from_str(~\"00100\") == Some(100 as T);\n \n     assert from_str(~\"-1\") == Some(-1 as T);\n     assert from_str(~\"-3\") == Some(-3 as T);\n     assert from_str(~\"-10\") == Some(-10 as T);\n-    assert from_str(~\"-123456789\") == Some(-123456789 as T);\n+    assert i32::from_str(~\"-123456789\") == Some(-123456789 as i32);\n     assert from_str(~\"-00100\") == Some(-100 as T);\n \n     assert from_str(~\" \").is_none();\n@@ -289,18 +323,18 @@ fn test_parse_bytes() {\n     assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T);\n     assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T);\n     assert parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T);\n-    assert parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as T);\n-    assert parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535 as T);\n-    assert parse_bytes(to_bytes(~\"FFFF\"), 16u) == Some(65535 as T);\n+    assert i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32);\n+    assert i32::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535 as i32);\n+    assert i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) == Some(65535 as i32);\n     assert parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T);\n     assert parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T);\n \n     assert parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T);\n     assert parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T);\n     assert parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T);\n-    assert parse_bytes(to_bytes(~\"-123\"), 16u) == Some(-291 as T);\n-    assert parse_bytes(to_bytes(~\"-ffff\"), 16u) == Some(-65535 as T);\n-    assert parse_bytes(to_bytes(~\"-FFFF\"), 16u) == Some(-65535 as T);\n+    assert i32::parse_bytes(to_bytes(~\"-123\"), 16u) == Some(-291 as i32);\n+    assert i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) == Some(-65535 as i32);\n+    assert i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) == Some(-65535 as i32);\n     assert parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T);\n     assert parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T);\n \n@@ -310,11 +344,74 @@ fn test_parse_bytes() {\n \n #[test]\n fn test_to_str() {\n-    assert (to_str(0 as T, 10u) == ~\"0\");\n-    assert (to_str(1 as T, 10u) == ~\"1\");\n-    assert (to_str(-1 as T, 10u) == ~\"-1\");\n-    assert (to_str(127 as T, 16u) == ~\"7f\");\n-    assert (to_str(100 as T, 10u) == ~\"100\");\n+    assert (to_str_radix(0 as T, 10u) == ~\"0\");\n+    assert (to_str_radix(1 as T, 10u) == ~\"1\");\n+    assert (to_str_radix(-1 as T, 10u) == ~\"-1\");\n+    assert (to_str_radix(127 as T, 16u) == ~\"7f\");\n+    assert (to_str_radix(100 as T, 10u) == ~\"100\");\n+\n+}\n+\n+#[test]\n+fn test_int_to_str_overflow() {\n+    let mut i8_val: i8 = 127_i8;\n+    assert (i8::to_str(i8_val) == ~\"127\");\n+\n+    i8_val += 1 as i8;\n+    assert (i8::to_str(i8_val) == ~\"-128\");\n+\n+    let mut i16_val: i16 = 32_767_i16;\n+    assert (i16::to_str(i16_val) == ~\"32767\");\n+\n+    i16_val += 1 as i16;\n+    assert (i16::to_str(i16_val) == ~\"-32768\");\n+\n+    let mut i32_val: i32 = 2_147_483_647_i32;\n+    assert (i32::to_str(i32_val) == ~\"2147483647\");\n+\n+    i32_val += 1 as i32;\n+    assert (i32::to_str(i32_val) == ~\"-2147483648\");\n+\n+    let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+    assert (i64::to_str(i64_val) == ~\"9223372036854775807\");\n+\n+    i64_val += 1 as i64;\n+    assert (i64::to_str(i64_val) == ~\"-9223372036854775808\");\n+}\n+\n+#[test]\n+fn test_int_from_str_overflow() {\n+    let mut i8_val: i8 = 127_i8;\n+    assert (i8::from_str(~\"127\") == Some(i8_val));\n+    assert (i8::from_str(~\"128\").is_none());\n+\n+    i8_val += 1 as i8;\n+    assert (i8::from_str(~\"-128\") == Some(i8_val));\n+    assert (i8::from_str(~\"-129\").is_none());\n+\n+    let mut i16_val: i16 = 32_767_i16;\n+    assert (i16::from_str(~\"32767\") == Some(i16_val));\n+    assert (i16::from_str(~\"32768\").is_none());\n+\n+    i16_val += 1 as i16;\n+    assert (i16::from_str(~\"-32768\") == Some(i16_val));\n+    assert (i16::from_str(~\"-32769\").is_none());\n+\n+    let mut i32_val: i32 = 2_147_483_647_i32;\n+    assert (i32::from_str(~\"2147483647\") == Some(i32_val));\n+    assert (i32::from_str(~\"2147483648\").is_none());\n+\n+    i32_val += 1 as i32;\n+    assert (i32::from_str(~\"-2147483648\") == Some(i32_val));\n+    assert (i32::from_str(~\"-2147483649\").is_none());\n+\n+    let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+    assert (i64::from_str(~\"9223372036854775807\") == Some(i64_val));\n+    assert (i64::from_str(~\"9223372036854775808\").is_none());\n+\n+    i64_val += 1 as i64;\n+    assert (i64::from_str(~\"-9223372036854775808\") == Some(i64_val));\n+    assert (i64::from_str(~\"-9223372036854775809\").is_none());\n }\n \n #[test]\n@@ -359,16 +456,16 @@ pub fn test_ranges() {\n \n     // None of the `fail`s should execute.\n     for range(10,0) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n     for range_rev(0,10) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n     for range_step(10,0,1) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n     for range_step(0,10,-1) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n }\n ", "previous_filename": "src/libcore/int-template.rs"}, {"sha": "da60b567f665afd33ea87eacc18ff28d0d9e85f4", "filename": "src/libcore/num/int-template/i16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/int-template/i16.rs"}, {"sha": "1bc45bb71af7eb0dcc8ca638d7b2a6e60e760e4b", "filename": "src/libcore/num/int-template/i32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/int-template/i32.rs"}, {"sha": "83d15aa857d95fa52714e8106f8c2b8153dfd8bf", "filename": "src/libcore/num/int-template/i64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/int-template/i64.rs"}, {"sha": "740442ed725be7fda7e7e14f951b94bf21d23692", "filename": "src/libcore/num/int-template/i8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/int-template/i8.rs"}, {"sha": "224da0dc062d35dde0376e60184cd5d95cf00fcb", "filename": "src/libcore/num/int-template/int.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/int-template/int.rs"}, {"sha": "05b03a53dcdeafaa02e68e0dc974167c0e48f7f3", "filename": "src/libcore/num/num.rs", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -0,0 +1,688 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An interface for numeric types\n+use core::cmp::{Ord, Eq};\n+use option::{None, Option, Some};\n+use char;\n+use str;\n+use kinds::Copy;\n+use vec;\n+\n+pub trait Num {\n+    // FIXME: Trait composition. (#2616)\n+    pure fn add(&self, other: &Self) -> Self;\n+    pure fn sub(&self, other: &Self) -> Self;\n+    pure fn mul(&self, other: &Self) -> Self;\n+    pure fn div(&self, other: &Self) -> Self;\n+    pure fn modulo(&self, other: &Self) -> Self;\n+    pure fn neg(&self) -> Self;\n+\n+    pure fn to_int(&self) -> int;\n+    static pure fn from_int(n: int) -> Self;\n+}\n+\n+pub trait IntConvertible {\n+    pure fn to_int(&self) -> int;\n+    static pure fn from_int(n: int) -> Self;\n+}\n+\n+pub trait Zero {\n+    static pure fn zero() -> Self;\n+}\n+\n+pub trait One {\n+    static pure fn one() -> Self;\n+}\n+\n+pub trait Round {\n+    pure fn round(&self, mode: RoundMode) -> Self;\n+\n+    pure fn floor(&self) -> Self;\n+    pure fn ceil(&self)  -> Self;\n+    pure fn fract(&self) -> Self;\n+}\n+\n+pub enum RoundMode {\n+    RoundDown,\n+    RoundUp,\n+    RoundToZero,\n+    RoundFromZero\n+}\n+\n+pub trait ToStrRadix {\n+    pub pure fn to_str_radix(&self, radix: uint) -> ~str;\n+}\n+\n+pub trait FromStrRadix {\n+    static pub pure fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+}\n+\n+// Generic math functions:\n+\n+/// Dynamically calculates the value `inf` (`1/0`).\n+/// Can fail on integer types.\n+#[inline(always)]\n+pub pure fn infinity<T: Num One Zero>() -> T {\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+    _1 / _0\n+}\n+\n+/// Dynamically calculates the value `-inf` (`-1/0`).\n+/// Can fail on integer types.\n+#[inline(always)]\n+pub pure fn neg_infinity<T: Num One Zero>() -> T {\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+    - _1 / _0\n+}\n+\n+/// Dynamically calculates the value `NaN` (`0/0`).\n+/// Can fail on integer types.\n+#[inline(always)]\n+pub pure fn NaN<T: Num Zero>() -> T {\n+    let _0: T = Zero::zero();\n+    _0 / _0\n+}\n+\n+/// Returns `true` if `num` has the value `inf` (`1/0`).\n+/// Can fail on integer types.\n+#[inline(always)]\n+pub pure fn is_infinity<T: Num One Zero Eq>(num: &T) -> bool {\n+    (*num) == (infinity::<T>())\n+}\n+\n+/// Returns `true` if `num` has the value `-inf` (`-1/0`).\n+/// Can fail on integer types.\n+#[inline(always)]\n+pub pure fn is_neg_infinity<T: Num One Zero Eq>(num: &T) -> bool {\n+    (*num) == (neg_infinity::<T>())\n+}\n+\n+/// Returns `true` if `num` has the value `NaN` (is not equal to itself).\n+#[inline(always)]\n+pub pure fn is_NaN<T: Num Eq>(num: &T) -> bool {\n+    (*num) != (*num)\n+}\n+\n+/// Returns `true` if `num` has the value `-0` (`1/num == -1/0`).\n+/// Can fail on integer types.\n+#[inline(always)]\n+pub pure fn is_neg_zero<T: Num One Zero Eq>(num: &T) -> bool {\n+    let _1: T = One::one();\n+    let _0: T = Zero::zero();\n+    *num == _0 && is_neg_infinity(&(_1 / *num))\n+}\n+\n+/**\n+ * Calculates a power to a given radix, optimized for uint `pow` and `radix`.\n+ *\n+ * Returns `radix^pow` as `T`.\n+ *\n+ * Note:\n+ * Also returns `1` for `0^0`, despite that technically being an\n+ * undefined number. The reason for this is twofold:\n+ * - If code written to use this function cares about that special case, it's\n+ *   probably going to catch it before making the call.\n+ * - If code written to use this function doesn't care about it, it's\n+ *   probably assuming that `x^0` always equals `1`.\n+ */\n+pub pure fn pow_with_uint<T: Num One Zero Copy>(radix: uint,\n+                                                pow: uint) -> T {\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+\n+    if pow   == 0u { return _1; }\n+    if radix == 0u { return _0; }\n+    let mut my_pow     = pow;\n+    let mut total      = _1;\n+    let mut multiplier = Num::from_int(radix as int);\n+    while (my_pow > 0u) {\n+        if my_pow % 2u == 1u {\n+            total *= multiplier;\n+        }\n+        my_pow     /= 2u;\n+        multiplier *= multiplier;\n+    }\n+    total\n+}\n+\n+pub enum ExponentFormat {\n+    ExpNone,\n+    ExpDec,\n+    ExpBin\n+}\n+\n+pub enum SignificantDigits {\n+    DigAll,\n+    DigMax(uint),\n+    DigExact(uint)\n+}\n+\n+pub enum SignFormat {\n+    SignNone,\n+    SignNeg,\n+    SignAll\n+}\n+\n+/**\n+ * Converts a number to its string representation as a byte vector.\n+ * This is meant to be a common base implementation for all numeric string\n+ * conversion functions like `to_str()` or `to_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `num`           - The number to convert. Accepts any number that\n+ *                     implements the numeric traits.\n+ * - `radix`         - Base to use. Accepts only the values 2-36.\n+ * - `special`       - Whether to attempt to compare to special values like\n+ *                     `inf` or `NaN`. Also needed to detect negative 0.\n+ *                     Can fail if it doesn't match `num`s type\n+ *                     (see safety note).\n+ * - `negative_zero` - Whether to treat the special value `-0` as\n+ *                     `-0` or as `+0`.\n+ * - `sign`          - How to emit the sign. Options are:\n+ *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n+ *     - `SignNeg`:  Only `-` on negative values.\n+ *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n+ * - `digits`        - The amount of digits to use for emitting the\n+ *                     fractional part, if any. Options are:\n+ *     - `DigAll`:         All calculatable digits. Beware of bignums or\n+ *                         fractions!\n+ *     - `DigMax(uint)`:   Maximum N digits, truncating any trailing zeros.\n+ *     - `DigExact(uint)`: Exactly N digits.\n+ *\n+ * # Return value\n+ * A tuple containing the byte vector, and a boolean flag indicating\n+ * whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n+ * It returns a tuple because there can be ambiguity between a special value\n+ * and a number representation at higher bases.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails on wrong value for `special` (see safety note).\n+ *\n+ * # Safety note\n+ * The function detects the special values `inf`, `-inf` and `NaN` by\n+ * dynamically comparing `num` to `1 / 0`, `-1 / 0` and `0 / 0`\n+ * (each of type T) if `special` is `true`. This will fail on integer types\n+ * with a 'divide by zero'. Likewise, it will fail if `num` **is** one of\n+ * those special values, and `special` is `false`, because then the\n+ * algorithm just does normal calculations on them.\n+ */\n+pub pure fn to_str_bytes_common<T: Num Zero One Eq Ord Round Copy>(\n+        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n+    if radix as int <  2 {\n+        die!(fmt!(\"to_str_bytes_common: radix %? to low, \\\n+                   must lie in the range [2, 36]\", radix));\n+    } else if radix as int > 36 {\n+        die!(fmt!(\"to_str_bytes_common: radix %? to high, \\\n+                   must lie in the range [2, 36]\", radix));\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+\n+    if special {\n+        if is_NaN(num) {\n+            return (str::to_bytes(\"NaN\"), true);\n+        } else if is_infinity(num){\n+            return match sign {\n+                SignAll => (str::to_bytes(\"+inf\"), true),\n+                _       => (str::to_bytes(\"inf\"), true)\n+            }\n+        } else if is_neg_infinity(num) {\n+            return match sign {\n+                SignNone => (str::to_bytes(\"inf\"), true),\n+                _        => (str::to_bytes(\"-inf\"), true),\n+            }\n+        }\n+    }\n+\n+    let neg = *num < _0 || (negative_zero && *num == _0\n+                            && special && is_neg_zero(num));\n+    let mut buf: ~[u8] = ~[];\n+    let radix_gen      = Num::from_int::<T>(radix as int);\n+\n+    let mut deccum;\n+\n+    // First emit the non-fractional part, looping at least once to make\n+    // sure at least a `0` gets emitted.\n+    deccum = num.round(RoundToZero);\n+    loop {\n+        // Calculate the absolute value of each digit instead of only\n+        // doing it once for the whole number because a\n+        // representable negative number doesn't necessary have an\n+        // representable additive inverse of the same type\n+        // (See twos complement). But we assume that for the\n+        // numbers [-35 .. 0] we always have [0 .. 35].\n+        let current_digit_signed = deccum % radix_gen;\n+        let current_digit = if current_digit_signed < _0 {\n+            -current_digit_signed\n+        } else {\n+            current_digit_signed\n+        };\n+\n+        // Decrease the deccumulator one digit at a time\n+        deccum /= radix_gen;\n+        deccum = deccum.round(RoundToZero);\n+\n+        unsafe { // FIXME: Pureness workaround (#4568)\n+            buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n+                 .unwrap() as u8);\n+        }\n+\n+        // No more digits to calculate for the non-fractional part -> break\n+        if deccum == _0 { break; }\n+    }\n+\n+    // If limited digits, calculate one digit more for rounding.\n+    let (limit_digits, digit_count, exact) = match digits {\n+        DigAll          => (false, 0u,      false),\n+        DigMax(count)   => (true,  count+1, false),\n+        DigExact(count) => (true,  count+1, true)\n+    };\n+\n+    // Decide what sign to put in front\n+    match sign {\n+        SignNeg | SignAll if neg => {\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push('-' as u8);\n+            }\n+        }\n+        SignAll => {\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push('+' as u8);\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    unsafe { // FIXME: Pureness workaround (#4568)\n+        vec::reverse(buf);\n+    }\n+\n+    // Remember start of the fractional digits.\n+    // Points one beyond end of buf if none get generated,\n+    // or at the '.' otherwise.\n+    let start_fractional_digits = buf.len();\n+\n+    // Now emit the fractional part, if any\n+    deccum = num.fract();\n+    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n+        unsafe { // FIXME: Pureness workaround (#4568)\n+            buf.push('.' as u8);\n+        }\n+        let mut dig = 0u;\n+\n+        // calculate new digits while\n+        // - there is no limit and there are digits left\n+        // - or there is a limit, it's not reached yet and\n+        //   - it's exact\n+        //   - or it's a maximum, and there are still digits left\n+        while (!limit_digits && deccum != _0)\n+           || (limit_digits && dig < digit_count && (\n+                   exact\n+                || (!exact && deccum != _0)\n+              )\n+        ) {\n+            // Shift first fractional digit into the integer part\n+            deccum *= radix_gen;\n+\n+            // Calculate the absolute value of each digit.\n+            // See note in first loop.\n+            let current_digit_signed = deccum.round(RoundToZero);\n+            let current_digit = if current_digit_signed < _0 {\n+                -current_digit_signed\n+            } else {\n+                current_digit_signed\n+            };\n+\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                buf.push(char::from_digit(\n+                    current_digit.to_int() as uint, radix).unwrap() as u8);\n+            }\n+\n+            // Decrease the deccumulator one fractional digit at a time\n+            deccum = deccum.fract();\n+            dig += 1u;\n+        }\n+\n+        // If digits are limited, and that limit has been reached,\n+        // cut off the one extra digit, and depending on its value\n+        // round the remaining ones.\n+        if limit_digits && dig == digit_count {\n+            let ascii2value = |chr: u8| {\n+                char::to_digit(chr as char, radix).unwrap() as uint\n+            };\n+            let value2ascii = |val: uint| {\n+                char::from_digit(val, radix).unwrap() as u8\n+            };\n+\n+            unsafe { // FIXME: Pureness workaround (#4568)\n+                let extra_digit = ascii2value(buf.pop());\n+                if extra_digit >= radix / 2 { // -> need to round\n+                    let mut i: int = buf.len() as int - 1;\n+                    loop {\n+                        // If reached left end of number, have to\n+                        // insert additional digit:\n+                        if i < 0\n+                        || buf[i] == '-' as u8\n+                        || buf[i] == '+' as u8 {\n+                            buf.insert((i + 1) as uint, value2ascii(1));\n+                            break;\n+                        }\n+\n+                        // Skip the '.'\n+                        if buf[i] == '.' as u8 { i -= 1; loop; }\n+\n+                        // Either increment the digit,\n+                        // or set to 0 if max and carry the 1.\n+                        let current_digit = ascii2value(buf[i]);\n+                        if current_digit < (radix - 1) {\n+                            buf[i] = value2ascii(current_digit+1);\n+                            break;\n+                        } else {\n+                            buf[i] = value2ascii(0);\n+                            i -= 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // if number of digits is not exact, remove all trailing '0's up to\n+    // and including the '.'\n+    if !exact {\n+        let buf_max_i = buf.len() - 1;\n+\n+        // index to truncate from\n+        let mut i = buf_max_i;\n+\n+        // discover trailing zeros of fractional part\n+        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+            i -= 1;\n+        }\n+\n+        // Only attempt to truncate digits if buf has fractional digits\n+        if i >= start_fractional_digits {\n+            // If buf ends with '.', cut that too.\n+            if buf[i] == '.' as u8 { i -= 1 }\n+\n+            // only resize buf if we actually remove digits\n+            if i < buf_max_i {\n+                buf = buf.slice(0, i + 1);\n+            }\n+        }\n+    } // If exact and trailing '.', just cut that\n+    else {\n+        let max_i = buf.len() - 1;\n+        if buf[max_i] == '.' as u8 {\n+            buf = buf.slice(0, max_i);\n+        }\n+    }\n+\n+    (buf, false)\n+}\n+\n+/**\n+ * Converts a number to its string representation. This is a wrapper for\n+ * `to_str_bytes_common()`, for details see there.\n+ */\n+#[inline(always)]\n+pub pure fn to_str_common<T: Num Zero One Eq Ord Round Copy>(\n+        num: &T, radix: uint, special: bool, negative_zero: bool,\n+        sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n+    let (bytes, special) = to_str_bytes_common(num, radix, special,\n+                               negative_zero, sign, digits);\n+    (str::from_bytes(bytes), special)\n+}\n+\n+// Some constants for from_str_bytes_common's input validation,\n+// they define minimum radix values for which the character is a valid digit.\n+priv const DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n+priv const DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n+priv const DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+\n+/**\n+ * Parses a byte slice as a number. This is meant to\n+ * be a common base implementation for all numeric string conversion\n+ * functions like `from_str()` or `from_str_radix()`.\n+ *\n+ * # Arguments\n+ * - `buf`        - The byte slice to parse.\n+ * - `radix`      - Which base to parse the number as. Accepts 2-36.\n+ * - `negative`   - Whether to accept negative numbers.\n+ * - `fractional` - Whether to accept numbers with fractional parts.\n+ * - `special`    - Whether to accept special values like `inf`\n+ *                  and `NaN`. Can conflict with `radix`, see Failure.\n+ * - `exponent`   - Which exponent format to accept. Options are:\n+ *     - `ExpNone`: No Exponent, accepts just plain numbers like `42` or\n+ *                  `-8.2`.\n+ *     - `ExpDec`:  Accepts numbers with a decimal exponent like `42e5` or\n+ *                  `8.2E-2`. The exponent string itself is always base 10.\n+ *                  Can conflict with `radix`, see Failure.\n+ *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n+ *                  `FFp128`. The exponent string itself is always base 10.\n+ *                  Can conflict with `radix`, see Failure.\n+ * - `empty_zero` - Whether to accept a empty `buf` as a 0 or not.\n+ *\n+ * # Return value\n+ * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n+ * `None` otherwise, depending on the constraints set by the remaining\n+ * arguments.\n+ *\n+ * # Failure\n+ * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails if `radix` > 14 and `exponent` is `ExpDec` due to conflict\n+ *   between digit and exponent sign `'e'`.\n+ * - Fails if `radix` > 25 and `exponent` is `ExpBin` due to conflict\n+ *   between digit and exponent sign `'p'`.\n+ * - Fails if `radix` > 18 and `special == true` due to conflict\n+ *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n+ *\n+ * # Possible improvements\n+ * - Could accept option to allow ignoring underscores, allowing for numbers\n+ *   formated like `FF_AE_FF_FF`.\n+ */\n+pub pure fn from_str_bytes_common<T: Num Zero One Ord Copy>(\n+        buf: &[u8], radix: uint, negative: bool, fractional: bool,\n+        special: bool, exponent: ExponentFormat, empty_zero: bool\n+        ) -> Option<T> {\n+    match exponent {\n+        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n+          => die!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        use of 'e' as decimal exponent\", radix)),\n+        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n+          => die!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        use of 'p' as binary exponent\", radix)),\n+        _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n+          => die!(fmt!(\"from_str_bytes_common: radix %? incompatible with \\\n+                        special values 'inf' and 'NaN'\", radix)),\n+        _ if radix as int < 2\n+          => die!(fmt!(\"from_str_bytes_common: radix %? to low, \\\n+                        must lie in the range [2, 36]\", radix)),\n+        _ if radix as int > 36\n+          => die!(fmt!(\"from_str_bytes_common: radix %? to high, \\\n+                        must lie in the range [2, 36]\", radix)),\n+        _ => ()\n+    }\n+\n+    let _0: T = Zero::zero();\n+    let _1: T = One::one();\n+    let radix_gen: T = Num::from_int(radix as int);\n+\n+    let len = buf.len();\n+\n+    if len == 0 {\n+        if empty_zero {\n+            return Some(_0);\n+        } else {\n+            return None;\n+        }\n+    }\n+\n+    if special {\n+        if buf == str::to_bytes(\"inf\") || buf == str::to_bytes(\"+inf\") {\n+            return Some(infinity());\n+        } else if buf == str::to_bytes(\"-inf\") {\n+            if negative {\n+                return Some(neg_infinity());\n+            } else {\n+                return None;\n+            }\n+        } else if buf == str::to_bytes(\"NaN\") {\n+            return Some(NaN());\n+        }\n+    }\n+\n+    let (start, accum_positive) = match buf[0] {\n+      '-' as u8 if !negative => return None,\n+      '-' as u8 => (1u, false),\n+      '+' as u8 => (1u, true),\n+       _        => (0u, true)\n+    };\n+\n+    // Initialize accumulator with signed zero for floating point parsing to\n+    // work\n+    let mut accum      = if accum_positive { _0 } else { -_1 * _0};\n+    let mut last_accum = accum; // Necessary to detect overflow\n+    let mut i          = start;\n+    let mut exp_found  = false;\n+\n+    // Parse integer part of number\n+    while i < len {\n+        let c = buf[i] as char;\n+\n+        match char::to_digit(c, radix) {\n+            Some(digit) => {\n+                // shift accum one digit left\n+                accum *= radix_gen;\n+\n+                // add/subtract current digit depending on sign\n+                if accum_positive {\n+                    accum += Num::from_int(digit as int);\n+                } else {\n+                    accum -= Num::from_int(digit as int);\n+                }\n+\n+                // Detect overflow by comparing to last value\n+                if accum_positive && accum < last_accum { return None; }\n+                if !accum_positive && accum > last_accum { return None; }\n+                last_accum = accum;\n+            }\n+            None => match c {\n+                'e' | 'E' | 'p' | 'P' => {\n+                    exp_found = true;\n+                    break;                       // start of exponent\n+                }\n+                '.' if fractional => {\n+                    i += 1u;                     // skip the '.'\n+                    break;                       // start of fractional part\n+                }\n+                _ => return None                 // invalid number\n+            }\n+        }\n+\n+        i += 1u;\n+    }\n+\n+    // Parse fractional part of number\n+    // Skip if already reached start of exponent\n+    if !exp_found {\n+        let mut power = _1;\n+\n+        while i < len {\n+            let c = buf[i] as char;\n+\n+            match char::to_digit(c, radix) {\n+                Some(digit) => {\n+                    // Decrease power one order of magnitude\n+                    power /= radix_gen;\n+\n+                    // add/subtract current digit depending on sign\n+                    if accum_positive {\n+                        accum += Num::from_int::<T>(digit as int) * power;\n+                    } else {\n+                        accum -= Num::from_int::<T>(digit as int) * power;\n+                    }\n+\n+                    // Detect overflow by comparing to last value\n+                    if accum_positive && accum < last_accum { return None; }\n+                    if !accum_positive && accum > last_accum { return None; }\n+                    last_accum = accum;\n+                }\n+                None => match c {\n+                    'e' | 'E' | 'p' | 'P' => {\n+                        exp_found = true;\n+                        break;                   // start of exponent\n+                    }\n+                    _ => return None             // invalid number\n+                }\n+            }\n+\n+            i += 1u;\n+        }\n+    }\n+\n+    // Special case: buf not empty, but does not contain any digit in front\n+    // of the exponent sign -> number is empty string\n+    if i == start {\n+        if empty_zero {\n+            return Some(_0);\n+        } else {\n+            return None;\n+        }\n+    }\n+\n+    let mut multiplier = _1;\n+\n+    if exp_found {\n+        let c = buf[i] as char;\n+        let base = match (c, exponent) {\n+            ('e', ExpDec) | ('E', ExpDec) => 10u,\n+            ('p', ExpBin) | ('P', ExpBin) => 2u,\n+            _ => return None // char doesn't fit given exponent format\n+        };\n+\n+        // parse remaining bytes as decimal integer,\n+        // skipping the exponent char\n+        let exp: Option<int> = from_str_bytes_common(\n+            buf.view(i+1, len), 10, true, false, false, ExpNone, false);\n+\n+        match exp {\n+            Some(exp_pow) => {\n+                multiplier = if exp_pow < 0 {\n+                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int()) as uint)\n+                } else {\n+                    pow_with_uint::<T>(base, exp_pow.to_int() as uint)\n+                }\n+            }\n+            None => return None // invalid exponent -> invalid number\n+        }\n+    }\n+\n+    Some(accum * multiplier)\n+}\n+\n+/**\n+ * Parses a string as a number. This is a wrapper for\n+ * `from_str_bytes_common()`, for details see there.\n+ */\n+#[inline(always)]\n+pub pure fn from_str_common<T: Num Zero One Ord Copy>(\n+        buf: &str, radix: uint, negative: bool, fractional: bool,\n+        special: bool, exponent: ExponentFormat, empty_zero: bool\n+        ) -> Option<T> {\n+    from_str_bytes_common(str::to_bytes(buf), radix, negative,\n+                            fractional, special, exponent, empty_zero)\n+}"}, {"sha": "82c6e0170145fc14973c4aba288ee76c0d2a6d2c", "filename": "src/libcore/num/uint-template.rs", "status": "renamed", "additions": 159, "deletions": 116, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -17,12 +17,19 @@ use T_SIGNED = self::inst::T_SIGNED;\n \n use char;\n use cmp::{Eq, Ord};\n+use cmp;\n+use to_str::ToStr;\n use from_str::FromStr;\n+use num::{ToStrRadix, FromStrRadix};\n use num;\n use option::{None, Option, Some};\n+use prelude::*;\n use str;\n use uint;\n use vec;\n+use u8;\n+use u16;\n+use u32;\n \n pub const bits : uint = inst::bits;\n pub const bytes : uint = (inst::bits / 8);\n@@ -76,7 +83,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n pub pure fn range_step(start: T, stop: T, step: T_SIGNED, it: fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n-        fail ~\"range_step called with step == 0\";\n+        die!(~\"range_step called with step == 0\");\n     }\n     if step >= 0 {\n         while i < stop {\n@@ -160,143 +167,117 @@ impl T: num::One {\n     static pure fn one() -> T { 1 }\n }\n \n-/**\n- * Parse a buffer of bytes\n- *\n- * # Arguments\n- *\n- * * buf - A byte buffer\n- * * radix - The base of the number\n- *\n- * # Failure\n- *\n- * `buf` must not be empty\n- */\n-pub pure fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n-    if vec::len(buf) == 0u { return None; }\n-    let mut i = vec::len(buf) - 1u;\n-    let mut power = 1u as T;\n-    let mut n = 0u as T;\n-    loop {\n-        match char::to_digit(buf[i] as char, radix) {\n-          Some(d) => n += d as T * power,\n-          None => return None\n-        }\n-        power *= radix as T;\n-        if i == 0u { return Some(n); }\n-        i -= 1u;\n-    };\n+impl T: num::Round {\n+    #[inline(always)]\n+    pure fn round(&self, _: num::RoundMode) -> T { *self }\n+\n+    #[inline(always)]\n+    pure fn floor(&self) -> T { *self }\n+    #[inline(always)]\n+    pure fn ceil(&self) -> T { *self }\n+    #[inline(always)]\n+    pure fn fract(&self) -> T { 0 }\n }\n \n-/// Parse a string to an int\n+// String conversion functions and impl str -> num\n+\n+/// Parse a string as a number in base 10.\n #[inline(always)]\n-pub pure fn from_str(s: &str) -> Option<T>\n-{\n-    parse_bytes(str::to_bytes(s), 10u)\n+pub pure fn from_str(s: &str) -> Option<T> {\n+    num::from_str_common(s, 10u, false, false, false,\n+                         num::ExpNone, false)\n }\n \n-impl T : FromStr {\n-    #[inline(always)]\n-    static pure fn from_str(s: &str) -> Option<T> { from_str(s) }\n+/// Parse a string as a number in the given base.\n+#[inline(always)]\n+pub pure fn from_str_radix(s: &str, radix: uint) -> Option<T> {\n+    num::from_str_common(s, radix, false, false, false,\n+                         num::ExpNone, false)\n }\n \n-/// Parse a string as an unsigned integer.\n-pub fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n-    if str::len(buf) == 0u { return None; }\n-    let mut i = str::len(buf) - 1u;\n-    let mut power = 1u64, n = 0u64;\n-    loop {\n-        match char::to_digit(buf[i] as char, radix as uint) {\n-          Some(d) => n += d as u64 * power,\n-          None => return None\n-        }\n-        power *= radix;\n-        if i == 0u { return Some(n); }\n-        i -= 1u;\n-    };\n+/// Parse a byte slice as a number in the given base.\n+#[inline(always)]\n+pub pure fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+    num::from_str_bytes_common(buf, radix, false, false, false,\n+                               num::ExpNone, false)\n }\n \n-/**\n- * Convert to a string in a given base\n- *\n- * # Failure\n- *\n- * Fails if `radix` < 2 or `radix` > 16\n- */\n-#[inline(always)]\n-pub pure fn to_str(num: T, radix: uint) -> ~str {\n-    do to_str_bytes(false, num, radix) |slice| {\n-        do vec::as_imm_buf(slice) |p, len| {\n-            unsafe { str::raw::from_buf_len(p, len) }\n-        }\n+impl T : FromStr {\n+    #[inline(always)]\n+    static pure fn from_str(s: &str) -> Option<T> {\n+        from_str(s)\n     }\n }\n \n-/// Low-level helper routine for string conversion.\n-pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n-                   f: fn(v: &[u8]) -> U) -> U {\n-\n+impl T : FromStrRadix {\n     #[inline(always)]\n-    pure fn digit(n: T) -> u8 {\n-        if n <= 9u as T {\n-            n as u8 + '0' as u8\n-        } else if n <= 15u as T {\n-            (n - 10 as T) as u8 + 'a' as u8\n-        } else {\n-            fail;\n-        }\n+    static pure fn from_str_radix(&self, s: &str, radix: uint) -> Option<T> {\n+        from_str_radix(s, radix)\n     }\n+}\n \n-    assert (1u < radix && radix <= 16u);\n-\n-    // Enough room to hold any number in any radix.\n-    // Worst case: 64-bit number, binary-radix, with\n-    // a leading negative sign = 65 bytes.\n-    let buf : [mut u8 * 65] = [mut 0u8, ..65];\n-    let len = buf.len();\n-\n-    let mut i = len;\n-    let mut n = num;\n-    let radix = radix as T;\n-    loop {\n-        i -= 1u;\n-        assert 0u < i && i < len;\n-        buf[i] = digit(n % radix);\n-        n /= radix;\n-        if n == 0 as T { break; }\n-    }\n+// String conversion functions and impl num -> str\n \n-    assert 0u < i && i < len;\n+/// Convert to a string as a byte slice in a given base.\n+#[inline(always)]\n+pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+    let (buf, _) = num::to_str_bytes_common(&n, radix, false, false,\n+                                            num::SignNeg, num::DigAll);\n+    f(buf)\n+}\n \n-    if neg {\n-        i -= 1u;\n-        buf[i] = '-' as u8;\n-    }\n+/// Convert to a string in base 10.\n+#[inline(always)]\n+pub pure fn to_str(num: T) -> ~str {\n+    let (buf, _) = num::to_str_common(&num, 10u, false, false,\n+                                      num::SignNeg, num::DigAll);\n+    buf\n+}\n \n-    f(vec::view(buf, i, len))\n+/// Convert to a string in a given base.\n+#[inline(always)]\n+pub pure fn to_str_radix(num: T, radix: uint) -> ~str {\n+    let (buf, _) = num::to_str_common(&num, radix, false, false,\n+                                      num::SignNeg, num::DigAll);\n+    buf\n }\n \n-/// Convert to a string\n+/// Convert to a string.\n+/// *Deprecated*, use to_str() instead.\n #[inline(always)]\n-pub pure fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub pure fn str(i: T) -> ~str { to_str(i) }\n+\n+impl T : ToStr {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        to_str(*self)\n+    }\n+}\n+\n+impl T : ToStrRadix {\n+    #[inline(always)]\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+        to_str_radix(*self, radix)\n+    }\n+}\n \n #[test]\n pub fn test_to_str() {\n-    assert to_str(0 as T, 10u) == ~\"0\";\n-    assert to_str(1 as T, 10u) == ~\"1\";\n-    assert to_str(2 as T, 10u) == ~\"2\";\n-    assert to_str(11 as T, 10u) == ~\"11\";\n-    assert to_str(11 as T, 16u) == ~\"b\";\n-    assert to_str(255 as T, 16u) == ~\"ff\";\n-    assert to_str(0xff as T, 10u) == ~\"255\";\n+    assert to_str_radix(0 as T, 10u) == ~\"0\";\n+    assert to_str_radix(1 as T, 10u) == ~\"1\";\n+    assert to_str_radix(2 as T, 10u) == ~\"2\";\n+    assert to_str_radix(11 as T, 10u) == ~\"11\";\n+    assert to_str_radix(11 as T, 16u) == ~\"b\";\n+    assert to_str_radix(255 as T, 16u) == ~\"ff\";\n+    assert to_str_radix(0xff as T, 10u) == ~\"255\";\n }\n \n #[test]\n pub fn test_from_str() {\n     assert from_str(~\"0\") == Some(0u as T);\n     assert from_str(~\"3\") == Some(3u as T);\n     assert from_str(~\"10\") == Some(10u as T);\n-    assert from_str(~\"123456789\") == Some(123456789u as T);\n+    assert u32::from_str(~\"123456789\") == Some(123456789 as u32);\n     assert from_str(~\"00100\") == Some(100u as T);\n \n     assert from_str(~\"\").is_none();\n@@ -310,26 +291,88 @@ pub fn test_parse_bytes() {\n     assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T);\n     assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T);\n     assert parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T);\n-    assert parse_bytes(to_bytes(~\"123\"), 16u) == Some(291u as T);\n-    assert parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535u as T);\n+    assert u16::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291u as u16);\n+    assert u16::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535u as u16);\n     assert parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T);\n \n     assert parse_bytes(to_bytes(~\"Z\"), 10u).is_none();\n     assert parse_bytes(to_bytes(~\"_\"), 2u).is_none();\n }\n \n+#[test]\n+fn test_uint_to_str_overflow() {\n+    let mut u8_val: u8 = 255_u8;\n+    assert (u8::to_str(u8_val) == ~\"255\");\n+\n+    u8_val += 1 as u8;\n+    assert (u8::to_str(u8_val) == ~\"0\");\n+\n+    let mut u16_val: u16 = 65_535_u16;\n+    assert (u16::to_str(u16_val) == ~\"65535\");\n+\n+    u16_val += 1 as u16;\n+    assert (u16::to_str(u16_val) == ~\"0\");\n+\n+    let mut u32_val: u32 = 4_294_967_295_u32;\n+    assert (u32::to_str(u32_val) == ~\"4294967295\");\n+\n+    u32_val += 1 as u32;\n+    assert (u32::to_str(u32_val) == ~\"0\");\n+\n+    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+    assert (u64::to_str(u64_val) == ~\"18446744073709551615\");\n+\n+    u64_val += 1 as u64;\n+    assert (u64::to_str(u64_val) == ~\"0\");\n+}\n+\n+#[test]\n+fn test_uint_from_str_overflow() {\n+    let mut u8_val: u8 = 255_u8;\n+    assert (u8::from_str(~\"255\") == Some(u8_val));\n+    assert (u8::from_str(~\"256\").is_none());\n+\n+    u8_val += 1 as u8;\n+    assert (u8::from_str(~\"0\") == Some(u8_val));\n+    assert (u8::from_str(~\"-1\").is_none());\n+\n+    let mut u16_val: u16 = 65_535_u16;\n+    assert (u16::from_str(~\"65535\") == Some(u16_val));\n+    assert (u16::from_str(~\"65536\").is_none());\n+\n+    u16_val += 1 as u16;\n+    assert (u16::from_str(~\"0\") == Some(u16_val));\n+    assert (u16::from_str(~\"-1\").is_none());\n+\n+    let mut u32_val: u32 = 4_294_967_295_u32;\n+    assert (u32::from_str(~\"4294967295\") == Some(u32_val));\n+    assert (u32::from_str(~\"4294967296\").is_none());\n+\n+    u32_val += 1 as u32;\n+    assert (u32::from_str(~\"0\") == Some(u32_val));\n+    assert (u32::from_str(~\"-1\").is_none());\n+\n+    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+    assert (u64::from_str(~\"18446744073709551615\") == Some(u64_val));\n+    assert (u64::from_str(~\"18446744073709551616\").is_none());\n+\n+    u64_val += 1 as u64;\n+    assert (u64::from_str(~\"0\") == Some(u64_val));\n+    assert (u64::from_str(~\"-1\").is_none());\n+}\n+\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n pub fn to_str_radix1() {\n-    uint::to_str(100u, 1u);\n+    uint::to_str_radix(100u, 1u);\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-pub fn to_str_radix17() {\n-    uint::to_str(100u, 17u);\n+pub fn to_str_radix37() {\n+    uint::to_str_radix(100u, 37u);\n }\n \n use io;\n@@ -357,16 +400,16 @@ pub fn test_ranges() {\n \n     // None of the `fail`s should execute.\n     for range(0,0) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n     for range_rev(0,0) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n     for range_step(10,0,1) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n     for range_step(0,1,-10) |_i| {\n-        fail ~\"unreachable\";\n+        die!(~\"unreachable\");\n     }\n }\n ", "previous_filename": "src/libcore/uint-template.rs"}, {"sha": "b9a007af2f67adad0d88f85e65f62f5bf932f42d", "filename": "src/libcore/num/uint-template/u16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/uint-template/u16.rs"}, {"sha": "141509c49e555adc4fb00f8fa4fbbe12d06d6186", "filename": "src/libcore/num/uint-template/u32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/uint-template/u32.rs"}, {"sha": "35210eae9a75c8b31ff804caf142fa6c615735df", "filename": "src/libcore/num/uint-template/u64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/uint-template/u64.rs"}, {"sha": "e273a2032132649706a4e1bf463e30210a86d7af", "filename": "src/libcore/num/uint-template/u8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/uint-template/u8.rs"}, {"sha": "93f59cd2d9f97eefed4e5d0215085cb8ff44b020", "filename": "src/libcore/num/uint-template/uint.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "previous_filename": "src/libcore/uint-template/uint.rs"}, {"sha": "dc245f5bffd5691c50d30ac540fa3eecbff21d37", "filename": "src/libcore/oldcomm.rs", "status": "removed", "additions": 0, "deletions": 547, "changes": 547, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Flibcore%2Foldcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Flibcore%2Foldcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foldcomm.rs?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,547 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Deprecated communication between tasks\n-\n-Communication between tasks is facilitated by ports (in the receiving\n-task), and channels (in the sending task). Any number of channels may\n-feed into a single port.  Ports and channels may only transmit values\n-of unique types; that is, values that are statically guaranteed to be\n-accessed by a single 'owner' at a time.  Unique types include scalars,\n-vectors, strings, and records, tags, tuples and unique boxes (`~T`)\n-thereof. Most notably, shared boxes (`@T`) may not be transmitted\n-across channels.\n-\n-# Example\n-\n-~~~\n-let po = oldcomm::Port();\n-let ch = oldcomm::Chan(&po);\n-\n-do task::spawn {\n-    oldcomm::send(ch, ~\"Hello, World\");\n-}\n-\n-io::println(oldcomm::recv(po));\n-~~~\n-\n-# Note\n-\n-Use of this module is deprecated in favor of `core::pipes`. In the\n-`core::comm` will likely be rewritten with pipes, at which point it\n-will once again be the preferred module for intertask communication.\n-\n-*/\n-\n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n-use cast;\n-use either;\n-use either::Either;\n-use iter;\n-use libc;\n-use libc::size_t;\n-use prelude::*;\n-use ptr;\n-use result;\n-use sys;\n-use task;\n-use vec;\n-\n-// After snapshot, change p2::addr_of => addr_of\n-\n-/**\n- * A communication endpoint that can receive messages\n- *\n- * Each port has a unique per-task identity and may not be replicated or\n- * transmitted. If a port value is copied, both copies refer to the same\n- * port.  Ports may be associated with multiple `chan`s.\n- */\n-pub enum Port<T> {\n-    Port_(@PortPtr<T>)\n-}\n-\n-// It's critical that this only have one variant, so it has a record\n-// layout, and will work in the rust_task structure in task.rs.\n-/**\n- * A communication endpoint that can send messages\n- *\n- * Each channel is bound to a port when the channel is constructed, so\n- * the destination port for a channel must exist before the channel\n- * itself.  Channels are weak: a channel does not keep the port it is\n- * bound to alive. If a channel attempts to send data to a dead port that\n- * data will be silently dropped.  Channels may be duplicated and\n- * themselves transmitted over other channels.\n- */\n-pub enum Chan<T> {\n-    Chan_(port_id)\n-}\n-\n-/// Constructs a port\n-pub fn Port<T: Owned>() -> Port<T> {\n-    unsafe {\n-        Port_(@PortPtr(rustrt::new_port(sys::nonzero_size_of::<T>()\n-                                        as size_t)))\n-    }\n-}\n-\n-impl<T: Owned> Port<T> {\n-\n-    fn chan() -> Chan<T> { Chan(&self) }\n-    fn send(v: T) { self.chan().send(move v) }\n-    fn recv() -> T { recv(self) }\n-    fn peek() -> bool { peek(self) }\n-\n-}\n-\n-impl<T: Owned> Chan<T> {\n-\n-    fn chan() -> Chan<T> { self }\n-    fn send(v: T) { send(self, move v) }\n-    fn recv() -> T { recv_chan(self) }\n-    fn peek() -> bool { peek_chan(self) }\n-\n-}\n-\n-/// Open a new receiving channel for the duration of a function\n-pub fn listen<T: Owned, U>(f: fn(Chan<T>) -> U) -> U {\n-    let po = Port();\n-    f(po.chan())\n-}\n-\n-struct PortPtr<T> {\n-  po: *rust_port,\n-  drop {\n-    unsafe {\n-      do task::unkillable {\n-        // Once the port is detached it's guaranteed not to receive further\n-        // messages\n-        let yield = 0;\n-        let yieldp = ptr::addr_of(&yield);\n-        rustrt::rust_port_begin_detach(self.po, yieldp);\n-        if yield != 0 {\n-            // Need to wait for the port to be detached\n-            task::yield();\n-        }\n-        rustrt::rust_port_end_detach(self.po);\n-\n-        // Drain the port so that all the still-enqueued items get dropped\n-        while rustrt::rust_port_size(self.po) > 0 as size_t {\n-            recv_::<T>(self.po);\n-        }\n-        rustrt::del_port(self.po);\n-      }\n-    }\n-  }\n-}\n-\n-fn PortPtr<T: Owned>(po: *rust_port) -> PortPtr<T> {\n-    PortPtr {\n-        po: po\n-    }\n-}\n-\n-/**\n- * Internal function for converting from a channel to a port\n- *\n- * # Failure\n- *\n- * Fails if the port is detached or dead. Fails if the port\n- * is owned by a different task.\n- */\n-fn as_raw_port<T: Owned, U>(ch: Chan<T>, f: fn(*rust_port) -> U) -> U {\n-\n-    struct PortRef {\n-        p: *rust_port,\n-        drop {\n-            unsafe {\n-                if !ptr::is_null(self.p) {\n-                    rustrt::rust_port_drop(self.p);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn PortRef(p: *rust_port) -> PortRef {\n-        PortRef {\n-            p: p\n-        }\n-    }\n-\n-    unsafe {\n-        let p = PortRef(rustrt::rust_port_take(*ch));\n-\n-        if ptr::is_null(p.p) {\n-            fail ~\"unable to locate port for channel\"\n-        } else if rustrt::get_task_id() != rustrt::rust_port_task(p.p) {\n-            fail ~\"unable to access unowned port\"\n-        }\n-\n-        f(p.p)\n-    }\n-}\n-\n-/**\n- * Constructs a channel. The channel is bound to the port used to\n- * construct it.\n- */\n-pub fn Chan<T: Owned>(p: &Port<T>) -> Chan<T> {\n-    unsafe {\n-        Chan_(rustrt::get_port_id((**p).po))\n-    }\n-}\n-\n-/**\n- * Sends data over a channel. The sent data is moved into the channel,\n- * whereupon the caller loses access to it.\n- */\n-pub fn send<T: Owned>(ch: Chan<T>, data: T) {\n-    unsafe {\n-        let Chan_(p) = ch;\n-        let data_ptr = ptr::addr_of(&data) as *();\n-        let res = rustrt::rust_port_id_send(p, data_ptr);\n-        if res != 0 {\n-            // Data sent successfully\n-            cast::forget(move data);\n-        }\n-        task::yield();\n-    }\n-}\n-\n-/**\n- * Receive from a port.  If no data is available on the port then the\n- * task will block until data becomes available.\n- */\n-pub fn recv<T: Owned>(p: Port<T>) -> T { recv_((**p).po) }\n-\n-/// Returns true if there are messages available\n-pub fn peek<T: Owned>(p: Port<T>) -> bool { peek_((**p).po) }\n-\n-#[doc(hidden)]\n-pub fn recv_chan<T: Owned>(ch: Chan<T>) -> T {\n-    as_raw_port(ch, |x|recv_(x))\n-}\n-\n-fn peek_chan<T: Owned>(ch: Chan<T>) -> bool {\n-    as_raw_port(ch, |x|peek_(x))\n-}\n-\n-/// Receive on a raw port pointer\n-fn recv_<T>(p: *rust_port) -> T {\n-    unsafe {\n-        let yield = 0;\n-        let yieldp = ptr::addr_of(&yield);\n-        let mut res;\n-        res = rusti::init::<T>();\n-        rustrt::port_recv(ptr::addr_of(&res) as *uint, p, yieldp);\n-\n-        if yield != 0 {\n-            // Data isn't available yet, so res has not been initialized.\n-            task::yield();\n-        } else {\n-            // In the absence of compiler-generated preemption points\n-            // this is a good place to yield\n-            task::yield();\n-        }\n-        move res\n-    }\n-}\n-\n-fn peek_(p: *rust_port) -> bool {\n-    unsafe {\n-        // Yield here before we check to see if someone sent us a message\n-        // FIXME #524, if the compiler generates yields, we don't need this\n-        task::yield();\n-        rustrt::rust_port_size(p) != 0 as libc::size_t\n-    }\n-}\n-\n-/// Receive on one of two ports\n-pub fn select2<A: Owned, B: Owned>(p_a: Port<A>, p_b: Port<B>)\n-    -> Either<A, B> {\n-    unsafe {\n-        let ports = ~[(**p_a).po, (**p_b).po];\n-        let yield = 0, yieldp = ptr::addr_of(&yield);\n-\n-        let mut resport: *rust_port;\n-        resport = rusti::init::<*rust_port>();\n-        do vec::as_imm_buf(ports) |ports, n_ports| {\n-            rustrt::rust_port_select(ptr::addr_of(&resport), ports,\n-                                     n_ports as size_t, yieldp);\n-        }\n-\n-        if yield != 0 {\n-            // Wait for data\n-            task::yield();\n-        } else {\n-            // As in recv, this is a good place to yield anyway until\n-            // the compiler generates yield calls\n-            task::yield();\n-        }\n-\n-        // Now we know the port we're supposed to receive from\n-        assert resport != ptr::null();\n-\n-        if resport == (**p_a).po {\n-            either::Left(recv(p_a))\n-        } else if resport == (**p_b).po {\n-            either::Right(recv(p_b))\n-        } else {\n-            fail ~\"unexpected result from rust_port_select\";\n-        }\n-    }\n-}\n-\n-\n-/* Implementation details */\n-\n-#[allow(non_camel_case_types)] // runtime type\n-enum rust_port {}\n-\n-#[allow(non_camel_case_types)] // runtime type\n-type port_id = int;\n-\n-#[abi = \"cdecl\"]\n-extern mod rustrt {\n-    unsafe fn rust_port_id_send(target_port: port_id, data: *())\n-                             -> libc::uintptr_t;\n-\n-    unsafe fn new_port(unit_sz: libc::size_t) -> *rust_port;\n-    unsafe fn del_port(po: *rust_port);\n-    unsafe fn rust_port_begin_detach(po: *rust_port,\n-                              yield: *libc::uintptr_t);\n-    unsafe fn rust_port_end_detach(po: *rust_port);\n-    unsafe fn get_port_id(po: *rust_port) -> port_id;\n-    unsafe fn rust_port_size(po: *rust_port) -> libc::size_t;\n-    unsafe fn port_recv(dptr: *uint, po: *rust_port,\n-                 yield: *libc::uintptr_t);\n-    unsafe fn rust_port_select(dptr: **rust_port, ports: **rust_port,\n-                        n_ports: libc::size_t,\n-                        yield: *libc::uintptr_t);\n-    unsafe fn rust_port_take(port_id: port_id) -> *rust_port;\n-    unsafe fn rust_port_drop(p: *rust_port);\n-    unsafe fn rust_port_task(p: *rust_port) -> libc::uintptr_t;\n-    unsafe fn get_task_id() -> libc::uintptr_t;\n-}\n-\n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn init<T>() -> T;\n-}\n-\n-\n-/* Tests */\n-\n-\n-#[test]\n-fn create_port_and_chan() { let p = Port::<int>(); Chan(&p); }\n-\n-#[test]\n-fn send_int() {\n-    let p = Port::<int>();\n-    let c = Chan(&p);\n-    send(c, 22);\n-}\n-\n-#[test]\n-fn send_recv_fn() {\n-    let p = Port::<int>();\n-    let c = Chan::<int>(&p);\n-    send(c, 42);\n-    assert (recv(p) == 42);\n-}\n-\n-#[test]\n-fn send_recv_fn_infer() {\n-    let p = Port();\n-    let c = Chan(&p);\n-    send(c, 42);\n-    assert (recv(p) == 42);\n-}\n-\n-#[test]\n-fn chan_chan_infer() {\n-    let p = Port(), p2 = Port::<int>();\n-    let c = Chan(&p);\n-    send(c, Chan(&p2));\n-    recv(p);\n-}\n-\n-#[test]\n-fn chan_chan() {\n-    let p = Port::<Chan<int>>(), p2 = Port::<int>();\n-    let c = Chan(&p);\n-    send(c, Chan(&p2));\n-    recv(p);\n-}\n-\n-#[test]\n-fn test_peek() {\n-    let po = Port();\n-    let ch = Chan(&po);\n-    assert !peek(po);\n-    send(ch, ());\n-    assert peek(po);\n-    recv(po);\n-    assert !peek(po);\n-}\n-\n-#[test]\n-fn test_select2_available() {\n-    let po_a = Port();\n-    let po_b = Port();\n-    let ch_a = Chan(&po_a);\n-    let ch_b = Chan(&po_b);\n-\n-    send(ch_a, ~\"a\");\n-\n-    assert select2(po_a, po_b) == either::Left(~\"a\");\n-\n-    send(ch_b, ~\"b\");\n-\n-    assert select2(po_a, po_b) == either::Right(~\"b\");\n-}\n-\n-#[test]\n-fn test_select2_rendezvous() {\n-    let po_a = Port();\n-    let po_b = Port();\n-    let ch_a = Chan(&po_a);\n-    let ch_b = Chan(&po_b);\n-\n-    for iter::repeat(10) {\n-        do task::spawn {\n-            for iter::repeat(10) { task::yield() }\n-            send(ch_a, ~\"a\");\n-        };\n-\n-        assert select2(po_a, po_b) == either::Left(~\"a\");\n-\n-        do task::spawn {\n-            for iter::repeat(10) { task::yield() }\n-            send(ch_b, ~\"b\");\n-        };\n-\n-        assert select2(po_a, po_b) == either::Right(~\"b\");\n-    }\n-}\n-\n-#[test]\n-fn test_select2_stress() {\n-    let po_a = Port();\n-    let po_b = Port();\n-    let ch_a = Chan(&po_a);\n-    let ch_b = Chan(&po_b);\n-\n-    let msgs = 100;\n-    let times = 4u;\n-\n-    for iter::repeat(times) {\n-        do task::spawn {\n-            for iter::repeat(msgs) {\n-                send(ch_a, ~\"a\")\n-            }\n-        };\n-        do task::spawn {\n-            for iter::repeat(msgs) {\n-                send(ch_b, ~\"b\")\n-            }\n-        };\n-    }\n-\n-    let mut as_ = 0;\n-    let mut bs = 0;\n-    for iter::repeat(msgs * times * 2u) {\n-        match select2(po_a, po_b) {\n-          either::Left(~\"a\") => as_ += 1,\n-          either::Right(~\"b\") => bs += 1,\n-          _ => fail ~\"test_select_2_stress failed\"\n-        }\n-    }\n-\n-    assert as_ == 400;\n-    assert bs == 400;\n-}\n-\n-#[test]\n-fn test_recv_chan() {\n-    let po = Port();\n-    let ch = Chan(&po);\n-    send(ch, ~\"flower\");\n-    assert recv_chan(ch) == ~\"flower\";\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_recv_chan_dead() {\n-    let ch = Chan(&Port());\n-    send(ch, ~\"flower\");\n-    recv_chan(ch);\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_recv_chan_wrong_task() {\n-    let po = Port();\n-    let ch = Chan(&po);\n-    send(ch, ~\"flower\");\n-    assert result::is_err(&task::try(||\n-        recv_chan(ch)\n-    ))\n-}\n-\n-#[test]\n-fn test_port_send() {\n-    let po = Port();\n-    po.send(());\n-    po.recv();\n-}\n-\n-#[test]\n-fn test_chan_peek() {\n-    let po = Port();\n-    let ch = po.chan();\n-    ch.send(());\n-    assert ch.peek();\n-}\n-\n-#[test]\n-fn test_listen() {\n-    do listen |parent| {\n-        do task::spawn {\n-            parent.send(~\"oatmeal-salad\");\n-        }\n-        assert parent.recv() == ~\"oatmeal-salad\";\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-fn test_port_detach_fail() {\n-    for iter::repeat(100) {\n-        do task::spawn_unlinked {\n-            let po = Port();\n-            let ch = po.chan();\n-\n-            do task::spawn {\n-                fail;\n-            }\n-\n-            do task::spawn {\n-                ch.send(());\n-            }\n-        }\n-    }\n-}"}, {"sha": "9cb955ad352b913e0d749bdb1d308a601d7c07c8", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -78,7 +78,7 @@ pub pure fn get<T: Copy>(opt: Option<T>) -> T {\n \n     match opt {\n       Some(copy x) => return x,\n-      None => fail ~\"option::get none\"\n+      None => die!(~\"option::get none\")\n     }\n }\n \n@@ -100,7 +100,7 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n      */\n     match *opt {\n         Some(ref x) => x,\n-        None => fail ~\"option::get_ref none\"\n+        None => die!(~\"option::get_ref none\")\n     }\n }\n \n@@ -229,7 +229,7 @@ pub pure fn unwrap<T>(opt: Option<T>) -> T {\n      */\n     match move opt {\n         Some(move x) => move x,\n-        None => fail ~\"option::unwrap none\"\n+        None => die!(~\"option::unwrap none\")\n     }\n }\n \n@@ -243,7 +243,7 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n \n     Fails if the value equals `None`.\n      */\n-    if opt.is_none() { fail ~\"option::swap_unwrap none\" }\n+    if opt.is_none() { die!(~\"option::swap_unwrap none\") }\n     unwrap(util::replace(opt, None))\n }\n \n@@ -252,7 +252,7 @@ pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     match move opt {\n         Some(move val) => val,\n-        None => fail reason.to_owned(),\n+        None => die!(reason.to_owned()),\n     }\n }\n "}, {"sha": "af484454ef466addf42a8753c3c37ad8d947cfd5", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -1212,7 +1212,7 @@ mod tests {\n           assert (libc::fclose(ostream) == (0u as c_int));\n           let rs = os::copy_file(&in, &out);\n           if (!os::path_exists(&in)) {\n-            fail (fmt!(\"%s doesn't exist\", in.to_str()));\n+            die!(fmt!(\"%s doesn't exist\", in.to_str()));\n           }\n           assert(rs);\n           let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);"}, {"sha": "0b64df8c1124c93ac1f08a889cc92bafd7645344", "filename": "src/libcore/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -368,7 +368,7 @@ impl Path {\n }\n \n impl PosixPath : ToStr {\n-    pure fn to_str() -> ~str {\n+    pure fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         if self.is_absolute {\n             s += \"/\";\n@@ -531,7 +531,7 @@ impl PosixPath : GenericPath {\n \n \n impl WindowsPath : ToStr {\n-    pure fn to_str() -> ~str {\n+    pure fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         match self.host {\n           Some(ref h) => { s += \"\\\\\\\\\"; s += *h; }"}, {"sha": "5f9eed7086871633db577fafaeb4f19729ecc982", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -332,7 +332,7 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n \n         let killed = rustrt::task_wait_event(this, &mut event);\n         if killed && !task::failing() {\n-            fail ~\"killed\"\n+            die!(~\"killed\")\n         }\n         event\n     }\n@@ -408,7 +408,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n             //unsafe { forget(p); }\n             return true;\n         }\n-        Full => fail ~\"duplicate send\",\n+        Full => die!(~\"duplicate send\"),\n         Blocked => {\n             debug!(\"waking up task for %?\", p_);\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n@@ -526,7 +526,7 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n             debug!(\"woke up, p.state = %?\", copy p.header.state);\n           }\n           Blocked => if first {\n-            fail ~\"blocking on already blocked packet\"\n+            die!(~\"blocking on already blocked packet\")\n           },\n           Full => {\n             let mut payload = None;\n@@ -562,7 +562,7 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n pub pure fn peek<T: Owned, Tb: Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty | Terminated => false,\n-      Blocked => fail ~\"peeking on blocked packet\",\n+      Blocked => die!(~\"peeking on blocked packet\"),\n       Full => true\n     }\n }\n@@ -595,7 +595,7 @@ fn sender_terminate<T: Owned>(p: *Packet<T>) {\n       }\n       Full => {\n         // This is impossible\n-        fail ~\"you dun goofed\"\n+        die!(~\"you dun goofed\")\n       }\n       Terminated => {\n         assert p.header.blocked_task.is_null();\n@@ -658,7 +658,7 @@ fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n                 (*p).state = old;\n                 break;\n               }\n-              Blocked => fail ~\"blocking on blocked packet\",\n+              Blocked => die!(~\"blocking on blocked packet\"),\n               Empty => ()\n             }\n         }\n@@ -731,7 +731,7 @@ pub fn select2<A: Owned, Ab: Owned, B: Owned, Bb: Owned>(\n     match i {\n       0 => Left((try_recv(move a), move b)),\n       1 => Right((move a, try_recv(move b))),\n-      _ => fail ~\"select2 return an invalid packet\"\n+      _ => die!(~\"select2 return an invalid packet\")\n     }\n }\n \n@@ -755,7 +755,7 @@ pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n     match wait_many([a.header(), b.header()]) {\n       0 => Left(()),\n       1 => Right(()),\n-      _ => fail ~\"wait returned unexpected index\"\n+      _ => die!(~\"wait returned unexpected index\")\n     }\n }\n \n@@ -833,7 +833,7 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n             //forget(packet);\n             header\n           },\n-          None => fail ~\"packet already consumed\"\n+          None => die!(~\"packet already consumed\")\n         }\n     }\n \n@@ -899,7 +899,7 @@ impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> : Selectable {\n             //forget(packet);\n             header\n           },\n-          None => fail ~\"packet already consumed\"\n+          None => die!(~\"packet already consumed\")\n         }\n     }\n }\n@@ -1095,7 +1095,7 @@ impl<T: Owned> Port<T>: Peekable<T> {\n             endp <-> self.endp;\n             let peek = match &endp {\n               &Some(ref endp) => pipes::peek(endp),\n-              &None => fail ~\"peeking empty stream\"\n+              &None => die!(~\"peeking empty stream\")\n             };\n             self.endp <-> endp;\n             peek\n@@ -1108,7 +1108,7 @@ impl<T: Owned> Port<T>: Selectable {\n         unsafe {\n             match self.endp {\n               Some(ref endp) => endp.header(),\n-              None => fail ~\"peeking empty stream\"\n+              None => die!(~\"peeking empty stream\")\n             }\n         }\n     }\n@@ -1325,7 +1325,7 @@ pub mod test {\n         c1.send(~\"abc\");\n \n         match (move p1, move p2).select() {\n-          Right(_) => fail,\n+          Right(_) => die!(),\n           _ => ()\n         }\n "}, {"sha": "6bd319a15d261134d960bd65885e7f579d00b88a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -69,7 +69,6 @@ pub use io;\n pub use iter;\n pub use libc;\n pub use num;\n-pub use oldcomm;\n pub use ops;\n pub use option;\n pub use os;"}, {"sha": "1fb8166ed12dccc8518d6fe8e697435228ec1c75", "filename": "src/libcore/private.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -225,7 +225,7 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n             cast::forget(move ptr);\n             // Also we have to free the (rejected) server endpoints.\n             let _server: UnwrapProto = cast::transmute(move serverp);\n-            fail ~\"Another task is already unwrapping this ARC!\";\n+            die!(~\"Another task is already unwrapping this ARC!\");\n         }\n     }\n }\n@@ -371,7 +371,7 @@ impl<T: Owned> Exclusive<T> {\n         let rec = unsafe { get_shared_mutable_state(&self.x) };\n         do rec.lock.lock {\n             if rec.failed {\n-                fail ~\"Poisoned exclusive - another task failed inside!\";\n+                die!(~\"Poisoned exclusive - another task failed inside!\");\n             }\n             rec.failed = true;\n             let result = f(&mut rec.data);\n@@ -513,7 +513,7 @@ pub mod tests {\n             let x2 = x.clone();\n             do task::spawn {\n                 for 10.times { task::yield(); } // try to let the unwrapper go\n-                fail; // punt it awake from its deadlock\n+                die!(); // punt it awake from its deadlock\n             }\n             let _z = unwrap_exclusive(move x);\n             do x2.with |_hello| { }"}, {"sha": "2c27b8ab3a2ca317a89a0cb21a6943588830b5e2", "filename": "src/libcore/private/finally.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Ffinally.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -71,7 +71,7 @@ fn test_fail() {\n     let mut i = 0;\n     do (|| {\n         i = 10;\n-        fail;\n+        die!();\n     }).finally {\n         assert failing();\n         assert i == 10;\n@@ -95,4 +95,4 @@ fn test_compact() {\n     fn but_always_run_this_function() { }\n     do_some_fallible_work.finally(\n         but_always_run_this_function);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "cc46c19c3d27da0b7b378bfd1af41a436fae5f94", "filename": "src/libcore/private/global.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fglobal.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -269,7 +269,7 @@ fn test_modify() {\n                         Some(~shared_mutable_state(10))\n                     }\n                 }\n-                _ => fail\n+                _ => die!()\n             }\n         }\n \n@@ -280,7 +280,7 @@ fn test_modify() {\n                     assert *v == 10;\n                     None\n                 },\n-                _ => fail\n+                _ => die!()\n             }\n         }\n \n@@ -291,7 +291,7 @@ fn test_modify() {\n                         Some(~shared_mutable_state(10))\n                     }\n                 }\n-                _ => fail\n+                _ => die!()\n             }\n         }\n     }"}, {"sha": "9d57cd5a466acc7ec0f1fe735b9be01a63fa13ea", "filename": "src/libcore/private/weak_task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fprivate%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fweak_task.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -112,7 +112,7 @@ fn run_weak_task_service(port: Port<ServiceMsg>) {\n                         // nobody will receive this\n                         shutdown_chan.send(());\n                     }\n-                    None => fail\n+                    None => die!()\n                 }\n             }\n             Shutdown => break\n@@ -195,7 +195,7 @@ fn test_select_stream_and_oneshot() {\n             do weaken_task |signal| {\n                 match select2i(&port, &signal) {\n                     Left(*) => (),\n-                    Right(*) => fail\n+                    Right(*) => die!()\n                 }\n             }\n         }"}, {"sha": "1f04f9e77a9d351f8ab000ffee1cd578d379397b", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -297,7 +297,7 @@ impl ReprVisitor : TyVisitor {\n     }\n \n     // Type no longer exists, vestigial function.\n-    fn visit_str(&self) -> bool { fail; }\n+    fn visit_str(&self) -> bool { die!(); }\n \n     fn visit_estr_box(&self) -> bool {\n         do self.get::<@str> |s| {\n@@ -319,7 +319,7 @@ impl ReprVisitor : TyVisitor {\n \n     // Type no longer exists, vestigial function.\n     fn visit_estr_fixed(&self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { fail; }\n+                        _align: uint) -> bool { die!(); }\n \n     fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write_char('@');\n@@ -355,7 +355,7 @@ impl ReprVisitor : TyVisitor {\n     }\n \n     // Type no longer exists, vestigial function.\n-    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { fail; }\n+    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { die!(); }\n \n \n     fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n@@ -562,7 +562,7 @@ impl ReprVisitor : TyVisitor {\n     }\n \n     // Type no longer exists, vestigial function.\n-    fn visit_constr(&self, _inner: *TyDesc) -> bool { fail; }\n+    fn visit_constr(&self, _inner: *TyDesc) -> bool { die!(); }\n \n     fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n }\n@@ -596,7 +596,7 @@ fn test_repr() {\n     exact_test(&10, \"10\");\n     exact_test(&true, \"true\");\n     exact_test(&false, \"false\");\n-    exact_test(&1.234, \"1.2340\");\n+    exact_test(&1.234, \"1.234\");\n     exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n     exact_test(&(@\"hello\"), \"@\\\"hello\\\"\");\n     exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n@@ -621,11 +621,11 @@ fn test_repr() {\n     exact_test(&(&[\"hi\", \"there\"]),\n                \"&[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(P{a:10, b:1.234}),\n-               \"{a: 10, b: 1.2340}\");\n+               \"{a: 10, b: 1.234}\");\n     exact_test(&(@P{a:10, b:1.234}),\n-               \"@{a: 10, b: 1.2340}\");\n+               \"@{a: 10, b: 1.234}\");\n     exact_test(&(~P{a:10, b:1.234}),\n-               \"~{a: 10, b: 1.2340}\");\n+               \"~{a: 10, b: 1.234}\");\n     exact_test(&(10_u8, ~\"hello\"),\n                \"(10, ~\\\"hello\\\")\");\n     exact_test(&(10_u16, ~\"hello\"),"}, {"sha": "d04667698fd27fc844f25d5d07eec05b149c506c", "filename": "src/libcore/result.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -44,7 +44,7 @@ pub pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n       Err(ref the_err) => unsafe {\n-        fail fmt!(\"get called on error result: %?\", *the_err)\n+        die!(fmt!(\"get called on error result: %?\", *the_err))\n       }\n     }\n }\n@@ -61,7 +61,7 @@ pub pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n     match *res {\n         Ok(ref t) => t,\n         Err(ref the_err) => unsafe {\n-            fail fmt!(\"get_ref called on error result: %?\", *the_err)\n+            die!(fmt!(\"get_ref called on error result: %?\", *the_err))\n         }\n     }\n }\n@@ -77,7 +77,7 @@ pub pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n     match *res {\n       Err(copy u) => u,\n-      Ok(_) => fail ~\"get_err called on ok result\"\n+      Ok(_) => die!(~\"get_err called on ok result\")\n     }\n }\n \n@@ -382,7 +382,7 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match move res {\n       Ok(move t) => move t,\n-      Err(_) => fail ~\"unwrap called on an err result\"\n+      Err(_) => die!(~\"unwrap called on an err result\")\n     }\n }\n \n@@ -391,7 +391,7 @@ pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n pub pure fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match move res {\n       Err(move u) => move u,\n-      Ok(_) => fail ~\"unwrap called on an ok result\"\n+      Ok(_) => die!(~\"unwrap called on an ok result\")\n     }\n }\n "}, {"sha": "c10eacc7a0adc7dfa5bbb8e18fac5e8bc990e5ac", "filename": "src/libcore/run.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -184,7 +184,7 @@ fn with_dirp<T>(d: &Option<~str>,\n pub fn run_program(prog: &str, args: &[~str]) -> int {\n     let pid = spawn_process(prog, args, &None, &None,\n                             0i32, 0i32, 0i32);\n-    if pid == -1 as pid_t { fail; }\n+    if pid == -1 as pid_t { die!(); }\n     return waitpid(pid);\n }\n \n@@ -214,7 +214,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n                       pipe_err.out);\n \n     unsafe {\n-        if pid == -1 as pid_t { fail; }\n+        if pid == -1 as pid_t { die!(); }\n         libc::close(pipe_input.in);\n         libc::close(pipe_output.out);\n         libc::close(pipe_err.out);\n@@ -328,7 +328,7 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n             os::close(pipe_in.out);\n             os::close(pipe_out.in);\n             os::close(pipe_err.in);\n-            fail;\n+            die!();\n         }\n \n         os::close(pipe_in.out);\n@@ -362,7 +362,7 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n                     errs = move s;\n                 }\n                 (n, _) => {\n-                    fail(fmt!(\"program_output received an unexpected file \\\n+                    die!(fmt!(\"program_output received an unexpected file \\\n                                number: %u\", n));\n                 }\n             };\n@@ -474,7 +474,7 @@ mod tests {\n         os::close(pipe_out.out);\n         os::close(pipe_err.out);\n \n-        if pid == -1i32 { fail; }\n+        if pid == -1i32 { die!(); }\n         let expected = ~\"test\";\n         writeclose(pipe_in.out, copy expected);\n         let actual = readclose(pipe_out.in);"}, {"sha": "64695be21d5156d8127a076599d44565b8035b0e", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -2990,7 +2990,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_bytes_fail() {\n         // Don't double free\n-        as_bytes::<()>(&~\"\", |_bytes| fail );\n+        as_bytes::<()>(&~\"\", |_bytes| die!() );\n     }\n \n     #[test]\n@@ -3090,12 +3090,12 @@ mod tests {\n               0 => assert ch == 'x',\n               1 => assert ch == '\\u03c0',\n               2 => assert ch == 'y',\n-              _ => fail ~\"test_chars_each failed\"\n+              _ => die!(~\"test_chars_each failed\")\n             }\n             i += 1;\n         }\n \n-        chars_each(~\"\", |_ch| fail ); // should not fail\n+        chars_each(~\"\", |_ch| die!() ); // should not fail\n     }\n \n     #[test]\n@@ -3107,7 +3107,7 @@ mod tests {\n               0 => assert bb == 'x' as u8,\n               1 => assert bb == 'y' as u8,\n               2 => assert bb == 'z' as u8,\n-              _ => fail ~\"test_bytes_each failed\"\n+              _ => die!(~\"test_bytes_each failed\")\n             }\n             i += 1;\n         }\n@@ -3169,7 +3169,7 @@ mod tests {\n             ii += 1;\n         }\n \n-        words_each(~\"\", |_x| fail); // should not fail\n+        words_each(~\"\", |_x| die!()); // should not fail\n     }\n \n     #[test]"}, {"sha": "5136af810e8d2ec0e113c26ed8836197b910e847", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -133,15 +133,15 @@ fn test_tls_modify() {\n         fn my_key(_x: @~str) { }\n         local_data_modify(my_key, |data| {\n             match data {\n-                Some(@ref val) => fail ~\"unwelcome value: \" + *val,\n+                Some(@ref val) => die!(~\"unwelcome value: \" + *val),\n                 None       => Some(@~\"first data\")\n             }\n         });\n         local_data_modify(my_key, |data| {\n             match data {\n                 Some(@~\"first data\") => Some(@~\"next data\"),\n-                Some(@ref val)           => fail ~\"wrong value: \" + *val,\n-                None                 => fail ~\"missing value\"\n+                Some(@ref val)           => die!(~\"wrong value: \" + *val),\n+                None                 => die!(~\"missing value\")\n             }\n         });\n         assert *(local_data_pop(my_key).get()) == ~\"next data\";\n@@ -212,11 +212,11 @@ fn test_tls_cleanup_on_failure() {\n                 local_data_set(str_key, @~\"string data\");\n                 local_data_set(box_key, @@());\n                 local_data_set(int_key, @42);\n-                fail;\n+                die!();\n             }\n         }\n         // Not quite nondeterministic.\n         local_data_set(int_key, @31337);\n-        fail;\n+        die!();\n     }\n }"}, {"sha": "d276f0c6ea9e2250f4048d29710304e037548cf3", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -218,7 +218,7 @@ pub fn task() -> TaskBuilder {\n priv impl TaskBuilder {\n     fn consume() -> TaskBuilder {\n         if self.consumed {\n-            fail ~\"Cannot copy a task_builder\"; // Fake move mode on self\n+            die!(~\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n         self.consumed = true;\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n@@ -314,7 +314,7 @@ impl TaskBuilder {\n         // sending out messages.\n \n         if self.opts.notify_chan.is_some() {\n-            fail ~\"Can't set multiple future_results for one task!\";\n+            die!(~\"Can't set multiple future_results for one task!\");\n         }\n \n         // Construct the future and give it to the caller.\n@@ -548,7 +548,7 @@ pub fn yield() {\n         let task_ = rt::rust_get_task();\n         let killed = rt::rust_task_yield(task_);\n         if killed && !failing() {\n-            fail ~\"killed\";\n+            die!(~\"killed\");\n         }\n     }\n }\n@@ -694,24 +694,24 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n             for iter::repeat(16) { task::yield(); }\n             ch.send(()); // If killed first, grandparent hangs.\n         }\n-        fail; // Shouldn't kill either (grand)parent or (grand)child.\n+        die!(); // Shouldn't kill either (grand)parent or (grand)child.\n     }\n     po.recv();\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n-    do spawn_unlinked { fail; }\n+    do spawn_unlinked { die!(); }\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n-    do spawn_supervised { fail; }\n+    do spawn_supervised { die!(); }\n     // Give child a chance to fail-but-not-kill-us.\n     for iter::repeat(16) { task::yield(); }\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n     do spawn_supervised { loop { task::yield(); } }\n-    fail; // Shouldn't leave a child hanging around.\n+    die!(); // Shouldn't leave a child hanging around.\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -733,7 +733,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n         can_not_copy: None,\n         .. b0\n     };\n-    do b1.spawn { fail; }\n+    do b1.spawn { die!(); }\n     po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -754,26 +754,26 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n         .. b0\n     };\n     do b1.spawn { loop { task::yield(); } }\n-    fail; // *both* mechanisms would be wrong if this didn't kill the child...\n+    die!(); // *both* mechanisms would be wrong if this didn't kill the child\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n     let (po, _ch) = stream::<()>();\n     // Default options are to spawn linked & unsupervised.\n-    do spawn { fail; }\n+    do spawn { die!(); }\n     po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n     // Default options are to spawn linked & unsupervised.\n     do spawn { loop { task::yield(); } }\n-    fail;\n+    die!();\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n     // Make sure the above test is the same as this one.\n     do task().linked().spawn { loop { task::yield(); } }\n-    fail;\n+    die!();\n }\n \n // A couple bonus linked failure tests - testing for failure propagation even\n@@ -788,7 +788,7 @@ fn test_spawn_failure_propagate_grandchild() {\n         }\n     }\n     for iter::repeat(16) { task::yield(); }\n-    fail;\n+    die!();\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -800,7 +800,7 @@ fn test_spawn_failure_propagate_secondborn() {\n         }\n     }\n     for iter::repeat(16) { task::yield(); }\n-    fail;\n+    die!();\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -812,7 +812,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n         }\n     }\n     for iter::repeat(16) { task::yield(); }\n-    fail;\n+    die!();\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -824,7 +824,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n         }\n     }\n     for iter::repeat(16) { task::yield(); }\n-    fail;\n+    die!();\n }\n \n #[test]\n@@ -868,7 +868,7 @@ fn test_future_result() {\n     result = None;\n     do task().future_result(|+r|\n         { result = Some(move r); }).unlinked().spawn {\n-        fail;\n+        die!();\n     }\n     assert option::unwrap(move result).recv() == Failure;\n }\n@@ -884,18 +884,18 @@ fn test_try_success() {\n         ~\"Success!\"\n     } {\n         result::Ok(~\"Success!\") => (),\n-        _ => fail\n+        _ => die!()\n     }\n }\n \n #[test]\n #[ignore(cfg(windows))]\n fn test_try_fail() {\n     match do try {\n-        fail\n+        die!()\n     } {\n         result::Err(()) => (),\n-        result::Ok(()) => fail\n+        result::Ok(()) => die!()\n     }\n }\n \n@@ -1095,7 +1095,7 @@ fn test_unkillable() {\n         yield();\n         // We want to fail after the unkillable task\n         // blocks on recv\n-        fail;\n+        die!();\n     }\n \n     unsafe {\n@@ -1130,7 +1130,7 @@ fn test_unkillable_nested() {\n         yield();\n         // We want to fail after the unkillable task\n         // blocks on recv\n-        fail;\n+        die!();\n     }\n \n     unsafe {"}, {"sha": "c88587067c1eb068e3a3f0a8087609dbb4837871", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -75,7 +75,6 @@\n \n use cast;\n use container::Map;\n-use oldcomm;\n use option;\n use pipes::{Chan, GenericChan, GenericPort, Port, stream};\n use pipes;\n@@ -646,25 +645,25 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n \n     fn new_task_in_sched(opts: SchedOpts) -> *rust_task {\n         if opts.foreign_stack_size != None {\n-            fail ~\"foreign_stack_size scheduler option unimplemented\";\n+            die!(~\"foreign_stack_size scheduler option unimplemented\");\n         }\n \n         let num_threads = match opts.mode {\n-          DefaultScheduler\n-          | CurrentScheduler\n-          | ExistingScheduler(*)\n-          | PlatformThread => 0u, /* Won't be used */\n-          SingleThreaded => 1u,\n-          ThreadPerCore => unsafe { rt::rust_num_threads() },\n-          ThreadPerTask => {\n-            fail ~\"ThreadPerTask scheduling mode unimplemented\"\n-          }\n-          ManualThreads(threads) => {\n-            if threads == 0u {\n-                fail ~\"can not create a scheduler with no threads\";\n+            DefaultScheduler\n+            | CurrentScheduler\n+            | ExistingScheduler(*)\n+            | PlatformThread => 0u, /* Won't be used */\n+            SingleThreaded => 1u,\n+            ThreadPerCore => unsafe { rt::rust_num_threads() },\n+            ThreadPerTask => {\n+                die!(~\"ThreadPerTask scheduling mode unimplemented\")\n+            }\n+            ManualThreads(threads) => {\n+                if threads == 0u {\n+                    die!(~\"can not create a scheduler with no threads\");\n+                }\n+                threads\n             }\n-            threads\n-          }\n         };\n \n         unsafe {\n@@ -697,7 +696,7 @@ fn test_spawn_raw_unsupervise() {\n         .. default_task_opts()\n     };\n     do spawn_raw(move opts) {\n-        fail;\n+        die!();\n     }\n }\n \n@@ -727,7 +726,7 @@ fn test_spawn_raw_notify_failure() {\n         .. default_task_opts()\n     };\n     do spawn_raw(move opts) {\n-        fail;\n+        die!();\n     }\n     assert notify_po.recv() == Failure;\n }"}, {"sha": "0e46b4fd004b3d3aec8d5d37446db74046f8f345", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 36, "deletions": 72, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,104 +22,68 @@ use kinds::Copy;\n use str;\n use vec;\n \n-pub trait ToStr { pub pure fn to_str() -> ~str; }\n-\n-impl int: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::int::str(self) }\n-}\n-impl i8: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::i8::str(self) }\n-}\n-impl i16: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::i16::str(self) }\n-}\n-impl i32: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::i32::str(self) }\n-}\n-impl i64: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::i64::str(self) }\n-}\n-impl uint: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::uint::str(self) }\n-}\n-impl u8: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u8::str(self) }\n-}\n-impl u16: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u16::str(self) }\n-}\n-impl u32: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u32::str(self) }\n-}\n-impl u64: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::u64::str(self) }\n-}\n-impl float: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::float::to_str(self, 4u) }\n-}\n-impl f32: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::float::to_str(self as float, 4u) }\n-}\n-impl f64: ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str { ::float::to_str(self as float, 4u) }\n+pub trait ToStr {\n+    pure fn to_str(&self) -> ~str;\n }\n+\n impl bool: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str { ::bool::to_str(self) }\n+    pure fn to_str(&self) -> ~str { ::bool::to_str(*self) }\n }\n impl (): ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str { ~\"()\" }\n+    pure fn to_str(&self) -> ~str { ~\"()\" }\n }\n impl ~str: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str { copy self }\n+    pure fn to_str(&self) -> ~str { copy *self }\n }\n impl &str: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str { ::str::from_slice(self) }\n+    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n impl @str: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str { ::str::from_slice(self) }\n+    pure fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n }\n \n-impl<A: ToStr Copy, B: ToStr Copy> (A, B): ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str {\n-        let (a, b) = self;\n-        ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\")\"\n+impl<A: ToStr, B: ToStr> (A, B): ToStr {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        // FIXME(#4760): this causes an llvm assertion\n+        //let &(ref a, ref b) = self;\n+        match *self {\n+            (ref a, ref b) => {\n+                ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\")\"\n+            }\n+        }\n     }\n }\n-impl<A: ToStr Copy, B: ToStr Copy, C: ToStr Copy> (A, B, C): ToStr {\n-    #[inline(always)]\n-    pure fn to_str() -> ~str {\n-        let (a, b, c) = self;\n-        ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\", \" + c.to_str() + ~\")\"\n+impl<A: ToStr, B: ToStr, C: ToStr> (A, B, C): ToStr {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        // FIXME(#4760): this causes an llvm assertion\n+        //let &(ref a, ref b, ref c) = self;\n+        match *self {\n+            (ref a, ref b, ref c) => {\n+                fmt!(\"(%s, %s, %s)\",\n+                    (*a).to_str(),\n+                    (*b).to_str(),\n+                    (*c).to_str()\n+                )\n+            }\n+        }\n     }\n }\n \n impl<A: ToStr> ~[A]: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str {\n+    pure fn to_str(&self) -> ~str {\n         unsafe {\n             // Bleh -- not really unsafe\n             // push_str and push_char\n             let mut acc = ~\"[\", first = true;\n-            for vec::each(self) |elt| {\n+            for self.each |elt| {\n                 unsafe {\n                     if first { first = false; }\n                     else { str::push_str(&mut acc, ~\", \"); }\n@@ -134,11 +98,11 @@ impl<A: ToStr> ~[A]: ToStr {\n \n impl<A: ToStr> @A: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str { ~\"@\" + (*self).to_str() }\n+    pure fn to_str(&self) -> ~str { ~\"@\" + (**self).to_str() }\n }\n impl<A: ToStr> ~A: ToStr {\n     #[inline(always)]\n-    pure fn to_str() -> ~str { ~\"~\" + (*self).to_str() }\n+    pure fn to_str(&self) -> ~str { ~\"~\" + (**self).to_str() }\n }\n \n #[cfg(test)]"}, {"sha": "8dff492e634cc08379cb07fb0feb9610b9acd02c", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -100,7 +100,7 @@ fn choose_weighted_item(v: &[Item]) -> Item {\n \n */\n pub fn unreachable() -> ! {\n-    fail ~\"internal error: entered unreachable code\";\n+    die!(~\"internal error: entered unreachable code\");\n }\n \n mod tests {"}, {"sha": "7846d3d03024041aafbacb18d2c40f65cc3b415f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -241,7 +241,7 @@ pub pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n pub pure fn last<T: Copy>(v: &[const T]) -> T {\n-    if len(v) == 0u { fail ~\"last_unsafe: empty vector\" }\n+    if len(v) == 0u { die!(~\"last_unsafe: empty vector\") }\n     v[len(v) - 1u]\n }\n \n@@ -568,7 +568,7 @@ pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n pub fn pop<T>(v: &mut ~[T]) -> T {\n     let ln = v.len();\n     if ln == 0 {\n-        fail ~\"sorry, cannot vec::pop an empty vector\"\n+        die!(~\"sorry, cannot vec::pop an empty vector\")\n     }\n     let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n     unsafe {\n@@ -589,7 +589,7 @@ pub fn pop<T>(v: &mut ~[T]) -> T {\n pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n     let ln = v.len();\n     if index >= ln {\n-        fail fmt!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n+        die!(fmt!(\"vec::swap_remove - index %u >= length %u\", index, ln));\n     }\n     if index < ln - 1 {\n         v[index] <-> v[ln - 1];\n@@ -831,7 +831,7 @@ pub pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n pub pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n                                   f: fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n-    if v0_len != len(v1) { fail; }\n+    if v0_len != len(v1) { die!(); }\n     let mut u: ~[V] = ~[];\n     let mut i = 0u;\n     while i < v0_len {\n@@ -2859,7 +2859,7 @@ mod tests {\n     #[test]\n     fn test_each_empty() {\n         for each::<int>(~[]) |_v| {\n-            fail; // should never be executed\n+            die!(); // should never be executed\n         }\n     }\n \n@@ -2886,7 +2886,7 @@ mod tests {\n     #[test]\n     fn test_reach_empty() {\n         for rev_each::<int>(~[]) |_v| {\n-            fail; // should never execute\n+            die!(); // should never execute\n         }\n     }\n \n@@ -3388,7 +3388,7 @@ mod tests {\n     #[should_fail]\n     fn test_from_fn_fail() {\n         do from_fn(100) |v| {\n-            if v == 50 { fail }\n+            if v == 50 { die!() }\n             (~0, @0)\n         };\n     }\n@@ -3402,7 +3402,7 @@ mod tests {\n             push((~0, @0));\n             push((~0, @0));\n             push((~0, @0));\n-            fail;\n+            die!();\n         };\n     }\n \n@@ -3415,7 +3415,7 @@ mod tests {\n         let mut i = 0;\n         do split(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3432,7 +3432,7 @@ mod tests {\n         let mut i = 0;\n         do split(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3449,7 +3449,7 @@ mod tests {\n         let mut i = 0;\n         do splitn(v, 100) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3466,7 +3466,7 @@ mod tests {\n         let mut i = 0;\n         do split(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3483,7 +3483,7 @@ mod tests {\n         let mut i = 0;\n         do rsplit(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3500,7 +3500,7 @@ mod tests {\n         let mut i = 0;\n         do rsplit(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3517,7 +3517,7 @@ mod tests {\n         let mut i = 0;\n         do rsplitn(v, 100) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3534,7 +3534,7 @@ mod tests {\n         let mut i = 0;\n         do rsplitn(v, 100) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n \n@@ -3550,7 +3550,7 @@ mod tests {\n         let mut i = 0;\n         do consume(v) |_i, _elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n         };\n@@ -3564,7 +3564,7 @@ mod tests {\n         let mut i = 0;\n         do consume_mut(v) |_i, _elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 1;\n         };\n@@ -3578,7 +3578,7 @@ mod tests {\n         let mut v = ~[];\n         do v.grow_fn(100) |i| {\n             if i == 50 {\n-                fail\n+                die!()\n             }\n             (~0, @0)\n         }\n@@ -3592,7 +3592,7 @@ mod tests {\n         let mut i = 0;\n         do map(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             ~[(~0, @0)]\n@@ -3607,7 +3607,7 @@ mod tests {\n         let mut i = 0;\n         do map_consume(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             ~[(~0, @0)]\n@@ -3622,7 +3622,7 @@ mod tests {\n         let mut i = 0;\n         do mapi(v) |_i, _elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             ~[(~0, @0)]\n@@ -3637,7 +3637,7 @@ mod tests {\n         let mut i = 0;\n         do map(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             ~[(~0, @0)]\n@@ -3653,7 +3653,7 @@ mod tests {\n         let mut i = 0;\n         do map2(v, v) |_elt1, _elt2| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             ~[(~0, @0)]\n@@ -3669,7 +3669,7 @@ mod tests {\n         let mut i = 0;\n         do filter_map(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             Some((~0, @0))\n@@ -3685,7 +3685,7 @@ mod tests {\n         let mut i = 0;\n         do v.filtered |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             true\n@@ -3701,7 +3701,7 @@ mod tests {\n         let mut i = 0;\n         do foldl((~0, @0), v) |_a, _b| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             (~0, @0)\n@@ -3717,7 +3717,7 @@ mod tests {\n         let mut i = 0;\n         do foldr(v, (~0, @0)) |_a, _b| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             (~0, @0)\n@@ -3732,7 +3732,7 @@ mod tests {\n         let mut i = 0;\n         do any(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             false\n@@ -3747,7 +3747,7 @@ mod tests {\n         let mut i = 0;\n         do any(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             false\n@@ -3762,7 +3762,7 @@ mod tests {\n         let mut i = 0;\n         do all(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             true\n@@ -3777,7 +3777,7 @@ mod tests {\n         let mut i = 0;\n         do alli(v) |_i, _elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             true\n@@ -3792,7 +3792,7 @@ mod tests {\n         let mut i = 0;\n         do all2(v, v) |_elt1, _elt2| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             true\n@@ -3808,7 +3808,7 @@ mod tests {\n         let mut i = 0;\n         do find(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             false\n@@ -3823,7 +3823,7 @@ mod tests {\n         let mut i = 0;\n         do position(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             false\n@@ -3838,7 +3838,7 @@ mod tests {\n         let mut i = 0;\n         do rposition(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             false\n@@ -3853,7 +3853,7 @@ mod tests {\n         let mut i = 0;\n         do each(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             false\n@@ -3868,7 +3868,7 @@ mod tests {\n         let mut i = 0;\n         do eachi(v) |_i, _elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n             false\n@@ -3884,7 +3884,7 @@ mod tests {\n         let mut i = 0;\n         for each_permutation(v) |_elt| {\n             if i == 2 {\n-                fail\n+                die!()\n             }\n             i += 0;\n         }\n@@ -3896,7 +3896,7 @@ mod tests {\n     fn test_as_imm_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do as_imm_buf(v) |_buf, _i| {\n-            fail\n+            die!()\n         }\n     }\n \n@@ -3906,7 +3906,7 @@ mod tests {\n     fn test_as_const_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do as_const_buf(v) |_buf, _i| {\n-            fail\n+            die!()\n         }\n     }\n \n@@ -3916,7 +3916,7 @@ mod tests {\n     fn test_as_mut_buf_fail() {\n         let v = [mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do as_mut_buf(v) |_buf, _i| {\n-            fail\n+            die!()\n         }\n     }\n "}, {"sha": "a64700494c8975c7070242d0253674596f755033", "filename": "src/libfuzzer/cycles.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -43,7 +43,7 @@ type pointy = {\n     mut g : fn~()->(),\n \n     mut m : ~[maybe_pointy],\n-    mut n : ~[mut maybe_pointy],\n+    mut n : ~[maybe_pointy],\n     mut o : {x : int, y : maybe_pointy}\n };\n // To add: objects; traits; anything type-parameterized?\n@@ -58,7 +58,7 @@ fn empty_pointy() -> @pointy {\n         mut g : fn~()->(){},\n \n         mut m : ~[],\n-        mut n : ~[mut],\n+        mut n : ~[],\n         mut o : {x : 0, y : none}\n     }\n }\n@@ -68,7 +68,7 @@ fn nop<T>(_x: T) { }\n \n fn test_cycles(r : rand::rng, k: uint, n: uint)\n {\n-    let v : ~[mut @pointy] = ~[mut];\n+    let mut v : ~[@pointy] = ~[];\n \n     // Create a graph with no edges\n     range(0u, vlen) {|_i|"}, {"sha": "c8083554c8bafa3e317231f2778b12f4d04cf00f", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -74,19 +74,16 @@ pub fn common_exprs() -> ~[ast::expr] {\n             id: 0,\n             callee_id: -1,\n             node: e,\n-            span: ast_util::dummy_sp(),\n+            span: codemap::dummy_sp(),\n         }\n     }\n \n     fn dsl(l: ast::lit_) -> ast::lit {\n-        ast::spanned { node: l, span: ast_util::dummy_sp() }\n+        codemap::spanned { node: l, span: codemap::dummy_sp() }\n     }\n \n     ~[dse(ast::expr_break(option::None)),\n      dse(ast::expr_again(option::None)),\n-     dse(ast::expr_fail(option::None)),\n-     dse(ast::expr_fail(option::Some(\n-         @dse(ast::expr_lit(@dsl(ast::lit_str(@~\"boo\"))))))),\n      dse(ast::expr_ret(option::None)),\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n@@ -117,11 +114,10 @@ pub pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           ast::expr_binary(*) | ast::expr_assign(*) |\n           ast::expr_assign_op(*) => { false }\n \n-          ast::expr_fail(option::None) |\n           ast::expr_ret(option::None) => { false }\n \n           // https://github.com/mozilla/rust/issues/953\n-          ast::expr_fail(option::Some(_)) => { false }\n+          //ast::expr_fail(option::Some(_)) => { false }\n \n           // https://github.com/mozilla/rust/issues/928\n           //ast::expr_cast(_, _) { false }\n@@ -573,7 +569,7 @@ pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n         run::run_program(~\"diff\",\n                          ~[~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n                           ~\"round-trip-b.rs\"]);\n-        fail ~\"Mismatch\";\n+        die!(~\"Mismatch\");\n     }\n }\n "}, {"sha": "ea8bd05c38ba796411f48e92f27113a06f612dd6", "filename": "src/libfuzzer/rand_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -25,7 +25,7 @@ fn choice<T: copy>(r : rand::rng, v : ~[T]) -> T {\n fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n \n // shuffle a vec in place\n-fn shuffle<T>(r : rand::rng, &v : ~[mut T]) {\n+fn shuffle<T>(r : rand::rng, &v : ~[T]) {\n     let i = vec::len(v);\n     while i >= 2u {\n         // Loop invariant: elements with index >= i have been locked in place.\n@@ -42,7 +42,7 @@ fn shuffled<T: copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n }\n \n // sample from a population without replacement\n-//fn sample<T>(r : rand::rng, pop : ~[T], k : uint) -> ~[T] { fail }\n+//fn sample<T>(r : rand::rng, pop : ~[T], k : uint) -> ~[T] { die!() }\n \n // Two ways to make a weighted choice.\n // * weighted_choice is O(number of choices) time\n@@ -86,7 +86,7 @@ fn main()\n     log(error, choice(r, ~[10, 20, 30]));\n     log(error, if unlikely(r, 5u) { \"unlikely\" } else { \"likely\" });\n \n-    let a = ~[mut 1, 2, 3];\n+    let mut a = ~[1, 2, 3];\n     shuffle(r, a);\n     log(error, a);\n "}, {"sha": "22923cb7290423c715596abccb0946a1834b7ea0", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -36,7 +36,7 @@ use core::ptr;\n use core::run;\n use core::str;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std::sha1::sha1;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name};\n@@ -509,7 +509,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n               }\n               ast::meta_list(_, _) => {\n                 // FIXME (#607): Implement this\n-                fail ~\"unimplemented meta_item variant\";\n+                die!(~\"unimplemented meta_item variant\");\n               }\n             }\n         }"}, {"sha": "f6a5fec75aded03fe56ef50ad7e02cefc0632a49", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -18,8 +18,8 @@ use core::os;\n use core::uint;\n use core::util;\n use core::vec;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n \n pure fn not_win32(os: session::os) -> bool {\n   match os {\n@@ -179,15 +179,15 @@ pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n \n     if install_prefix == ~\"\" {\n-        fail ~\"rustc compiled without CFG_PREFIX environment variable\";\n+        die!(~\"rustc compiled without CFG_PREFIX environment variable\");\n     }\n \n     let tlib = filesearch::relative_target_lib_path(target_triple);\n     os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n }\n \n pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n-    let set = map::HashMap();\n+    let set = oldmap::HashMap();\n     let mut minimized = ~[];\n     for rpaths.each |rpath| {\n         let s = rpath.to_str();"}, {"sha": "1464fa29afc1298e646ad024ca26ca461ff7c94c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -35,7 +35,7 @@ use std::getopts::groups::{optopt, optmulti, optflag, optflagopt, getopts};\n use std::getopts::groups;\n use std::getopts::{opt_present};\n use std::getopts;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std;\n use syntax::ast;\n use syntax::ast_map;\n@@ -382,21 +382,21 @@ pub fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n         match node {\n           pprust::node_item(s, item) => {\n             pp::space(s.s);\n-            pprust::synth_comment(s, int::to_str(item.id, 10u));\n+            pprust::synth_comment(s, int::to_str(item.id));\n           }\n           pprust::node_block(s, ref blk) => {\n             pp::space(s.s);\n             pprust::synth_comment(\n-                s, ~\"block \" + int::to_str((*blk).node.id, 10u));\n+                s, ~\"block \" + int::to_str((*blk).node.id));\n           }\n           pprust::node_expr(s, expr) => {\n             pp::space(s.s);\n-            pprust::synth_comment(s, int::to_str(expr.id, 10u));\n+            pprust::synth_comment(s, int::to_str(expr.id));\n             pprust::pclose(s);\n           }\n           pprust::node_pat(s, pat) => {\n             pp::space(s.s);\n-            pprust::synth_comment(s, ~\"pat \" + int::to_str(pat.id, 10u));\n+            pprust::synth_comment(s, ~\"pat \" + int::to_str(pat.id));\n           }\n         }\n     }\n@@ -506,7 +506,7 @@ pub fn host_triple() -> ~str {\n     return if ht != ~\"\" {\n             ht\n         } else {\n-            fail ~\"rustc built without CFG_HOST_TRIPLE\"\n+            die!(~\"rustc built without CFG_HOST_TRIPLE\")\n         };\n }\n \n@@ -846,7 +846,7 @@ pub fn build_output_filenames(input: input,\n \n pub fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n     emitter(None, msg, diagnostic::fatal);\n-    fail;\n+    die!();\n }\n \n pub fn list_metadata(sess: Session, path: &Path, out: io::Writer) {\n@@ -874,8 +874,8 @@ pub mod test {\n         let matches =\n             &match getopts(~[~\"--test\"], optgroups()) {\n               Ok(copy m) => m,\n-              Err(copy f) => fail ~\"test_switch_implies_cfg_test: \" +\n-                             getopts::fail_str(f)\n+              Err(copy f) => die!(~\"test_switch_implies_cfg_test: \" +\n+                             getopts::fail_str(f))\n             };\n         let sessopts = build_session_options(\n             ~\"rustc\", matches, diagnostic::emit);\n@@ -892,8 +892,8 @@ pub mod test {\n             &match getopts(~[~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(copy m) => m,\n               Err(copy f) => {\n-                fail ~\"test_switch_implies_cfg_test_unless_cfg_test: \" +\n-                    getopts::fail_str(f);\n+                die!(~\"test_switch_implies_cfg_test_unless_cfg_test: \" +\n+                    getopts::fail_str(f));\n               }\n             };\n         let sessopts = build_session_options("}, {"sha": "9ffb29bc885c81942dee21378b87fefdd32f7fef", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -344,14 +344,15 @@ pub mod test {\n \n     use syntax::ast;\n     use syntax::ast_util;\n+    use syntax::codemap;\n \n     pub fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n-        ast_util::respan(ast_util::dummy_sp(), ast::attribute_ {\n+        codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n-            value: ast_util::respan(ast_util::dummy_sp(),\n+            value: codemap::respan(codemap::dummy_sp(),\n                 ast::meta_name_value(\n                     ~\"crate_type\",\n-                    ast_util::respan(ast_util::dummy_sp(),\n+                    codemap::respan(codemap::dummy_sp(),\n                                      ast::lit_str(@t)))),\n             is_sugared_doc: false\n         })\n@@ -361,7 +362,7 @@ pub mod test {\n         let mut attrs = ~[];\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n-        @ast_util::respan(ast_util::dummy_sp(), ast::crate_ {\n+        @codemap::respan(codemap::dummy_sp(), ast::crate_ {\n             module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,\n             config: ~[]"}, {"sha": "143eb556f96de36f00b8038df1e7c03a69b098e4", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -17,6 +17,7 @@ use syntax::ast;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::codemap;\n+use syntax::codemap::dummy_sp;\n use syntax::fold;\n \n const CORE_VERSION: &static/str = \"0.6\";\n@@ -36,8 +37,8 @@ fn use_core(crate: @ast::crate) -> bool {\n \n fn inject_libcore_ref(sess: Session,\n                       crate: @ast::crate) -> @ast::crate {\n-    fn spanned<T: Copy>(x: T) -> ast::spanned<T> {\n-        ast::spanned { node: x, span: dummy_sp() }\n+    fn spanned<T: Copy>(x: T) -> codemap::spanned<T> {\n+        codemap::spanned { node: x, span: dummy_sp() }\n     }\n \n     let precursor = @fold::AstFoldFns {"}, {"sha": "c660fa3ef805332aab2a105680b1b71a305a4e62", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use driver::session::Session;\n use syntax::parse;\n use syntax::ast;\n+use syntax::codemap::spanned;\n \n use core::vec;\n \n@@ -34,7 +35,7 @@ pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n \n     let items = vec::append(~[item], crate.node.module.items);\n \n-    @ast::spanned {\n+    @spanned {\n         node: ast::crate_ {\n             module: ast::_mod {\n                 items: items,"}, {"sha": "91eb8148bb786eed01b1a857842778ee8c975fe1", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -21,7 +21,8 @@ use core::option;\n use core::vec;\n use syntax::ast_util::*;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::{dummy_sp, span};\n+use syntax::codemap;\n use syntax::fold;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n@@ -237,8 +238,8 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     return @item;\n }\n \n-fn nospan<T: Copy>(t: T) -> ast::spanned<T> {\n-    ast::spanned { node: t, span: dummy_sp() }\n+fn nospan<T: Copy>(t: T) -> codemap::spanned<T> {\n+    codemap::spanned { node: t, span: dummy_sp() }\n }\n \n fn path_node(+ids: ~[ast::ident]) -> @ast::path {\n@@ -535,7 +536,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let body_: ast::blk_ =\n         default_block(~[], option::Some(test_main_call_expr),\n                       cx.sess.next_node_id());\n-    let body = ast::spanned { node: body_, span: dummy_sp() };\n+    let body = codemap::spanned { node: body_, span: dummy_sp() };\n \n     let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n     let item = ast::item {"}, {"sha": "e114a18f4fd382b42675b5ea66ec335d76ad3dc1", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,7 +20,7 @@ use core::ptr;\n use core::str;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -1451,7 +1451,7 @@ pub fn float_width(llt: TypeRef) -> uint {\n               2 => 64u,\n               3 => 80u,\n               4 | 5 => 128u,\n-              _ => fail ~\"llvm_float_width called on a non-float type\"\n+              _ => die!(~\"llvm_float_width called on a non-float type\")\n             };\n     }\n }"}, {"sha": "66956489a27ef5a486c7ce2ead8335aa94c17333", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -24,13 +24,13 @@ use core::either;\n use core::option;\n use core::vec;\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::visit;\n use syntax::{ast, ast_util};\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n@@ -294,7 +294,7 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n-            let fake_span = ast_util::dummy_sp();\n+            let fake_span = dummy_sp();\n             let local_cnum = resolve_crate(e, cname, cmetas,\n                                            /*bad*/copy dep.hash, fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);"}, {"sha": "59cc7d1dba603fae1982db774b4bc3ce873b0935", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -23,10 +23,10 @@ use core::dvec::DVec;\n use core::vec;\n use reader = std::ebml::reader;\n use std::ebml;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n use syntax::ast_util;\n use syntax::diagnostic::expect;\n use syntax::diagnostic::span_handler;"}, {"sha": "c8a1a619436b374178cf0b2ffcfcccbade0fac34", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -21,8 +21,8 @@ use metadata::decoder;\n use core::option;\n use core::str;\n use core::vec;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n use std;\n use syntax::{ast, attr};\n use syntax::parse::token::ident_interner;\n@@ -31,7 +31,7 @@ use syntax::parse::token::ident_interner;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = map::HashMap<ast::crate_num, ast::crate_num>;\n+pub type cnum_map = oldmap::HashMap<ast::crate_num, ast::crate_num>;\n \n pub type crate_metadata = @{name: ~str,\n                             data: @~[u8],\n@@ -46,24 +46,24 @@ pub type crate_metadata = @{name: ~str,\n pub enum CStore { private(cstore_private), }\n \n type cstore_private =\n-    @{metas: map::HashMap<ast::crate_num, crate_metadata>,\n+    @{metas: oldmap::HashMap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n       mut used_crate_files: ~[Path],\n       mut used_libraries: ~[~str],\n       mut used_link_args: ~[~str],\n       intr: @ident_interner};\n \n // Map from node_id's of local use statements to crate numbers\n-type use_crate_map = map::HashMap<ast::node_id, ast::crate_num>;\n+type use_crate_map = oldmap::HashMap<ast::node_id, ast::crate_num>;\n \n // Internal method to retrieve the data from the cstore\n pure fn p(cstore: CStore) -> cstore_private {\n     match cstore { private(p) => p }\n }\n \n pub fn mk_cstore(intr: @ident_interner) -> CStore {\n-    let meta_cache = map::HashMap();\n-    let crate_map = map::HashMap();\n+    let meta_cache = oldmap::HashMap();\n+    let crate_map = oldmap::HashMap();\n     return private(@{metas: meta_cache,\n                      use_crate_map: crate_map,\n                      mut used_crate_files: ~[],\n@@ -94,12 +94,12 @@ pub fn set_crate_data(cstore: CStore,\n }\n \n pub fn have_crate_data(cstore: CStore, cnum: ast::crate_num) -> bool {\n-    return p(cstore).metas.contains_key(cnum);\n+    return p(cstore).metas.contains_key_ref(&cnum);\n }\n \n pub fn iter_crate_data(cstore: CStore,\n                        i: fn(ast::crate_num, crate_metadata)) {\n-    for p(cstore).metas.each |k,v| { i(k, v);};\n+    for p(cstore).metas.each_ref |&k, &v| { i(k, v);};\n }\n \n pub fn add_used_crate_file(cstore: CStore, lib: &Path) {\n@@ -148,7 +148,7 @@ pub fn get_dep_hashes(cstore: CStore) -> ~[~str] {\n     type crate_hash = {name: ~str, hash: ~str};\n     let mut result = ~[];\n \n-    for p(cstore).use_crate_map.each_value |cnum| {\n+    for p(cstore).use_crate_map.each_value_ref |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         debug!(\"Add hash[%s]: %s\", cdata.name, hash);"}, {"sha": "c3c7c969cd87a05af5abba7b622fc26aa56e195b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -36,15 +36,16 @@ use core::str;\n use core::vec;\n use std::ebml::reader;\n use std::ebml;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n use std::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n+use syntax::codemap;\n \n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n@@ -91,7 +92,7 @@ fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n-       None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n+       None => die!(fmt!(\"lookup_item: id not found: %d\", item_id)),\n        Some(d) => d\n     }\n }\n@@ -149,7 +150,7 @@ fn item_family(item: ebml::Doc) -> Family {\n       'g' => PublicField,\n       'j' => PrivateField,\n       'N' => InheritedField,\n-       c => fail (fmt!(\"unexpected family char: %c\", c))\n+       c => die!(fmt!(\"unexpected family char: %c\", c))\n     }\n }\n \n@@ -396,7 +397,7 @@ pub fn struct_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n             Some(it) => it,\n-            None     => fail (fmt!(\"struct_dtor: class id not found \\\n+            None     => die!(fmt!(\"struct_dtor: class id not found \\\n               when looking up dtor for %d\", id))\n     };\n     for reader::tagged_docs(cls_items, tag_item_dtor) |doc| {\n@@ -421,8 +422,8 @@ pub enum def_like {\n fn def_like_to_def(def_like: def_like) -> ast::def {\n     match def_like {\n         dl_def(def) => return def,\n-        dl_impl(*) => fail ~\"found impl in def_like_to_def\",\n-        dl_field => fail ~\"found field in def_like_to_def\"\n+        dl_impl(*) => die!(~\"found impl in def_like_to_def\"),\n+        dl_field => die!(~\"found field in def_like_to_def\")\n     }\n }\n \n@@ -625,7 +626,7 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n             'm' => { ast::m_mutbl }\n             'c' => { ast::m_const }\n             _ => {\n-                fail fmt!(\"unknown mutability character: `%c`\", ch as char)\n+                die!(fmt!(\"unknown mutability character: `%c`\", ch as char))\n             }\n         }\n     }\n@@ -642,7 +643,7 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n         '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n         '&' => { return ast::sty_region(get_mutability(string[1])); }\n         _ => {\n-            fail fmt!(\"unknown self type code: `%c`\", self_ty_kind as char);\n+            die!(fmt!(\"unknown self type code: `%c`\", self_ty_kind as char));\n         }\n     }\n }\n@@ -832,7 +833,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n                     StaticMethod => purity = ast::impure_fn,\n                     UnsafeStaticMethod => purity = ast::unsafe_fn,\n                     PureStaticMethod => purity = ast::pure_fn,\n-                    _ => fail\n+                    _ => die!()\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n@@ -865,7 +866,7 @@ pure fn family_to_visibility(family: Family) -> ast::visibility {\n       PublicField => ast::public,\n       PrivateField => ast::private,\n       InheritedField => ast::inherited,\n-      _ => fail\n+      _ => die!()\n     }\n }\n \n@@ -915,7 +916,7 @@ fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n-        None => fail (fmt!(\"describe_def: item not found %?\", id))\n+        None => die!(fmt!(\"describe_def: item not found %?\", id))\n     };\n     return item_family_to_str(item_family(it));\n }\n@@ -981,13 +982,13 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items[0];\n             attrs.push(\n-                ast::spanned {\n+                codemap::spanned {\n                     node: ast::attribute_ {\n                         style: ast::attr_outer,\n                         value: /*bad*/copy *meta_item,\n                         is_sugared_doc: false,\n                     },\n-                    span: ast_util::dummy_sp()\n+                    span: codemap::dummy_sp()\n                 });\n         };\n       }\n@@ -1100,7 +1101,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n \n     match cdata.cnum_map.find(did.crate) {\n       option::Some(n) => ast::def_id { crate: n, node: did.node },\n-      option::None => fail ~\"didn't find a crate in the cnum_map\"\n+      option::None => die!(~\"didn't find a crate in the cnum_map\")\n     }\n }\n "}, {"sha": "438084a3bd7a5d60d3de0288199909ef46f66f59", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -36,9 +36,9 @@ use core::str;\n use core::to_bytes::IterBytes;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std::serialize::Encodable;\n-use std::{ebml, map};\n+use std::{ebml, oldmap};\n use std;\n use syntax::ast::*;\n use syntax::ast;\n@@ -52,7 +52,7 @@ use syntax;\n use writer = std::ebml::writer;\n \n // used by astencode:\n-type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n+type abbrev_map = oldmap::HashMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = fn@(ecx: @encode_ctxt,\n                                    ebml_w: writer::Encoder,\n@@ -99,7 +99,7 @@ pub enum encode_ctxt = {\n };\n \n pub fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n-    ecx.reachable.contains_key(id)\n+    ecx.reachable.contains_key_ref(&id)\n }\n \n fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Encoder, name: ident) {\n@@ -245,7 +245,7 @@ fn encode_discriminant(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                    disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n-    ebml_w.writer.write(str::to_bytes(int::to_str(disr_val,10u)));\n+    ebml_w.writer.write(str::to_bytes(int::to_str(disr_val)));\n     ebml_w.end_tag();\n }\n \n@@ -527,7 +527,7 @@ fn purity_static_method_family(p: purity) -> char {\n       unsafe_fn => 'U',\n       pure_fn => 'P',\n       impure_fn => 'F',\n-      _ => fail ~\"extern fn can't be static\"\n+      _ => die!(~\"extern fn can't be static\")\n     }\n }\n \n@@ -547,8 +547,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     let tcx = ecx.tcx;\n     let must_write =\n         match item.node {\n-          item_enum(_, _) | item_impl(*)\n-          | item_trait(*) | item_struct(*) => true,\n+          item_enum(_, _) | item_impl(*) | item_trait(*) | item_struct(*) |\n+          item_mod(*) | item_foreign_mod(*) => true,\n           _ => false\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n@@ -829,7 +829,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                                    true, item.id, *m, /*bad*/copy m.tps);\n         }\n       }\n-      item_mac(*) => fail ~\"item macros unimplemented\"\n+      item_mac(*) => die!(~\"item macros unimplemented\")\n     }\n }\n \n@@ -886,7 +886,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                         encode_info_for_item(ecx, ebml_w, i,\n                                              index, *pt);\n                     }\n-                    _ => fail ~\"bad item\"\n+                    _ => die!(~\"bad item\")\n                 }\n             }\n         },\n@@ -901,7 +901,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                                                      abi);\n                     }\n                     // case for separate item and foreign-item tables\n-                    _ => fail ~\"bad foreign item\"\n+                    _ => die!(~\"bad foreign item\")\n                 }\n             }\n         },"}, {"sha": "dfccaf77dfd320974d3fa0aff186077daf72d0d3", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -108,7 +108,7 @@ fn make_target_lib_path(sysroot: &Path,\n fn get_or_default_sysroot() -> Path {\n     match os::self_exe_path() {\n       option::Some(ref p) => (*p).pop(),\n-      option::None => fail ~\"can't determine value for sysroot\"\n+      option::None => die!(~\"can't determine value for sysroot\")\n     }\n }\n \n@@ -176,7 +176,7 @@ fn get_cargo_lib_path_nearest() -> Result<Path, ~str> {\n pub fn libdir() -> ~str {\n    let libdir = env!(\"CFG_LIBDIR\");\n    if str::is_empty(libdir) {\n-      fail ~\"rustc compiled without CFG_LIBDIR environment variable\";\n+      die!(~\"rustc compiled without CFG_LIBDIR environment variable\");\n    }\n    libdir\n }"}, {"sha": "c4cb154e21f0d8a580b2ac0d1c956952d04d8b14", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -150,10 +150,10 @@ pub fn crate_name_from_metas(+metas: ~[@ast::meta_item]) -> ~str {\n           Some(ref n) => (/*bad*/copy *n),\n           // FIXME (#2406): Probably want a warning here since the user\n           // is using the wrong type of meta item.\n-          _ => fail\n+          _ => die!()\n         }\n       }\n-      None => fail ~\"expected to find the crate name\"\n+      None => die!(~\"expected to find the crate name\")\n     }\n }\n "}, {"sha": "5dd499dfd63d7a125c434ccb2794e2d50192c081", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -26,9 +26,8 @@ use core::uint;\n use core::vec;\n use syntax::ast;\n use syntax::ast::*;\n-use syntax::ast_util;\n-use syntax::ast_util::respan;\n-use std::map::HashMap;\n+use syntax::codemap::{respan, dummy_sp};\n+use std::oldmap::HashMap;\n \n // Compact string representation for ty::t values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n@@ -114,7 +113,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n           ':' => { next(st); next(st); }\n           c => {\n             if c == '(' {\n-                return @ast::path { span: ast_util::dummy_sp(),\n+                return @ast::path { span: dummy_sp(),\n                                     global: false,\n                                     idents: idents,\n                                     rp: None,\n@@ -135,7 +134,7 @@ fn parse_proto(st: @pstate) -> ast::Proto {\n         '@' => ast::ProtoBox,\n         '~' => ast::ProtoUniq,\n         '&' => ast::ProtoBorrowed,\n-        _ => fail ~\"parse_proto(): bad input\"\n+        _ => die!(~\"parse_proto(): bad input\")\n     }\n }\n \n@@ -153,7 +152,7 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n       '&' => ty::vstore_slice(parse_region(st)),\n-      _ => fail ~\"parse_vstore: bad input\"\n+      _ => die!(~\"parse_vstore: bad input\")\n     }\n }\n \n@@ -188,7 +187,7 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n         assert next(st) == '|';\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n-      _ => fail ~\"parse_bound_region: bad input\"\n+      _ => die!(~\"parse_bound_region: bad input\")\n     }\n }\n \n@@ -213,15 +212,15 @@ fn parse_region(st: @pstate) -> ty::Region {\n       't' => {\n         ty::re_static\n       }\n-      _ => fail ~\"parse_region: bad input\"\n+      _ => die!(~\"parse_region: bad input\")\n     }\n }\n \n fn parse_opt<T>(st: @pstate, f: fn() -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f()),\n-      _ => fail ~\"parse_opt: bad input\"\n+      _ => die!(~\"parse_opt: bad input\")\n     }\n }\n \n@@ -254,7 +253,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           'D' => return ty::mk_mach_int(st.tcx, ast::ty_i64),\n           'f' => return ty::mk_mach_float(st.tcx, ast::ty_f32),\n           'F' => return ty::mk_mach_float(st.tcx, ast::ty_f64),\n-          _ => fail ~\"parse_ty: bad numeric type\"\n+          _ => die!(~\"parse_ty: bad numeric type\")\n         }\n       }\n       'c' => return ty::mk_char(st.tcx),\n@@ -353,7 +352,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           assert (next(st) == ']');\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n-      c => { error!(\"unexpected char in type string: %c\", c); fail;}\n+      c => { error!(\"unexpected char in type string: %c\", c); die!();}\n     }\n }\n \n@@ -405,15 +404,15 @@ fn parse_purity(c: char) -> purity {\n       'p' => pure_fn,\n       'i' => impure_fn,\n       'c' => extern_fn,\n-      _ => fail ~\"parse_purity: bad purity\"\n+      _ => die!(~\"parse_purity: bad purity\")\n     }\n }\n \n fn parse_onceness(c: char) -> ast::Onceness {\n     match c {\n         'o' => ast::Once,\n         'm' => ast::Many,\n-        _ => fail ~\"parse_onceness: bad onceness\"\n+        _ => die!(~\"parse_onceness: bad onceness\")\n     }\n }\n \n@@ -426,7 +425,7 @@ fn parse_mode(st: @pstate) -> ast::mode {\n         '+' => ast::by_copy,\n         '=' => ast::by_ref,\n         '#' => ast::by_val,\n-        _ => fail ~\"bad mode\"\n+        _ => die!(~\"bad mode\")\n     });\n     return m;\n }\n@@ -464,20 +463,20 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         error!(\"didn't find ':' when parsing def id\");\n-        fail;\n+        die!();\n     }\n \n     let crate_part = vec::view(buf, 0u, colon_idx);\n     let def_part = vec::view(buf, colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,\n-       None => fail (fmt!(\"internal error: parse_def_id: crate number \\\n+       None => die!(fmt!(\"internal error: parse_def_id: crate number \\\n                                expected, but found %?\", crate_part))\n     };\n     let def_num = match uint::parse_bytes(def_part, 10u) {\n        Some(dn) => dn as int,\n-       None => fail (fmt!(\"internal error: parse_def_id: id expected, but \\\n+       None => die!(fmt!(\"internal error: parse_def_id: id expected, but \\\n                                found %?\", def_part))\n     };\n     ast::def_id { crate: crate_num, node: def_num }\n@@ -500,7 +499,7 @@ fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n           'O' => ty::bound_durable,\n           'I' => ty::bound_trait(parse_ty(st, conv)),\n           '.' => break,\n-          _ => fail ~\"parse_bounds: bad bounds\"\n+          _ => die!(~\"parse_bounds: bad bounds\")\n         });\n     }\n     @bounds"}, {"sha": "a0e2065b20b8c36434243bdea3ba246d3186dac3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,7 +20,7 @@ use core::io::WriterUtil;\n use core::io;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n@@ -98,8 +98,8 @@ pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n             let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n             if abbrev_len < len {\n                 // I.e. it's actually an abbreviation.\n-                let s = ~\"#\" + uint::to_str(pos, 16u) + ~\":\" +\n-                    uint::to_str(len, 16u) + ~\"#\";\n+                let s = ~\"#\" + uint::to_str_radix(pos, 16u) + ~\":\" +\n+                    uint::to_str_radix(len, 16u) + ~\"#\";\n                 let a = {pos: pos, len: len, s: @s};\n                 abbrevs.insert(t, a);\n             }\n@@ -321,7 +321,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n           debug!(\"~~~~ %s\", ~\"]\");\n           w.write_char(']');\n       }\n-      ty::ty_err => fail ~\"Shouldn't encode error type\"\n+      ty::ty_err => die!(~\"Shouldn't encode error type\")\n     }\n }\n "}, {"sha": "2fc592e131e61a282a057fcb16904547087cc27e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -31,7 +31,7 @@ use std::ebml::reader::get_doc;\n use std::ebml::reader;\n use std::ebml::writer::Encoder;\n use std::ebml;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std::prettyprint;\n use std::serialize;\n use std::serialize::{Encodable, EncoderHelpers, DecoderHelpers};\n@@ -220,7 +220,7 @@ impl extended_decode_ctxt {\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n     fn tr_span(_span: span) -> span {\n-        ast_util::dummy_sp() // FIXME (#1972): handle span properly\n+        codemap::dummy_sp() // FIXME (#1972): handle span properly\n     }\n }\n \n@@ -300,11 +300,11 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         let stmts_sans_items = do blk.stmts.filtered |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@ast::spanned { node: ast::decl_local(_),\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                              span: _}, _) => true,\n-              ast::stmt_decl(@ast::spanned { node: ast::decl_item(_),\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_),\n                                              span: _}, _) => false,\n-              ast::stmt_mac(*) => fail ~\"unexpanded macro in astencode\"\n+              ast::stmt_mac(*) => die!(~\"unexpanded macro in astencode\")\n             }\n         };\n         let blk_sans_items = ast::blk_ {\n@@ -336,7 +336,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_dtor(ref dtor, nm, ref tps, parent_id) => {\n         let dtor_body = fld.fold_block((*dtor).node.body);\n         ast::ii_dtor(\n-            ast::spanned {\n+            codemap::spanned {\n                 node: ast::struct_dtor_ { body: dtor_body,\n                                           .. /*bad*/copy (*dtor).node },\n                 .. (/*bad*/copy *dtor) },\n@@ -377,7 +377,7 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n         let new_parent = xcx.tr_def_id(parent_id);\n         let new_self = fld.new_id((*dtor).node.self_id);\n         ast::ii_dtor(\n-            ast::spanned {\n+            codemap::spanned {\n                 node: ast::struct_dtor_ { id: dtor_id,\n                                           attrs: dtor_attrs,\n                                           self_id: new_self,\n@@ -717,7 +717,7 @@ impl reader::Decoder: vtable_decoder_helpers {\n                     )\n                   }\n                   // hard to avoid - user input\n-                  _ => fail ~\"bad enum variant\"\n+                  _ => die!(~\"bad enum variant\")\n                 }\n             }\n         }\n@@ -1288,6 +1288,6 @@ fn test_simplification() {\n         assert pprust::item_to_str(item_out, ext_cx.parse_sess().interner)\n             == pprust::item_to_str(item_exp, ext_cx.parse_sess().interner);\n       }\n-      _ => fail\n+      _ => die!()\n     }\n }"}, {"sha": "19740b6a929b28091ee465a6cc133e3c1604cb6b", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -35,7 +35,7 @@ use core::cmp;\n use core::dvec::DVec;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n use syntax::ast_util;\n@@ -665,7 +665,7 @@ fn check_loans_in_expr(expr: @ast::expr,\n \n     self.check_for_conflicting_loans(expr.id);\n \n-    if self.bccx.moves_map.contains_key(expr.id) {\n+    if self.bccx.moves_map.contains_key_ref(&expr.id) {\n         self.check_move_out_from_expr(expr);\n     }\n \n@@ -686,15 +686,15 @@ fn check_loans_in_expr(expr: @ast::expr,\n       }\n       ast::expr_index(_, rval) |\n       ast::expr_binary(_, _, rval)\n-      if self.bccx.method_map.contains_key(expr.id) => {\n+      if self.bccx.method_map.contains_key_ref(&expr.id) => {\n         self.check_call(expr,\n                         None,\n                         expr.callee_id,\n                         expr.span,\n                         ~[rval]);\n       }\n       ast::expr_unary(*) | ast::expr_index(*)\n-      if self.bccx.method_map.contains_key(expr.id) => {\n+      if self.bccx.method_map.contains_key_ref(&expr.id) => {\n         self.check_call(expr,\n                         None,\n                         expr.callee_id,"}, {"sha": "b7b9942492411618dac7b89656ce280c74c90b49", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -33,7 +33,7 @@ use util::ppaux::{expr_repr, region_to_str};\n use core::dvec;\n use core::hashmap::linear::LinearSet;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n@@ -204,7 +204,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       ast::expr_binary(_, rcvr, _) |\n       ast::expr_unary(_, rcvr) |\n       ast::expr_assign_op(_, rcvr, _)\n-      if self.bccx.method_map.contains_key(ex.id) => {\n+      if self.bccx.method_map.contains_key_ref(&ex.id) => {\n         // Receivers in method calls are always passed by ref.\n         //\n         // Here, in an overloaded operator, the call is this expression,\n@@ -241,7 +241,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n       // }\n \n       ast::expr_field(rcvr, _, _)\n-      if self.bccx.method_map.contains_key(ex.id) => {\n+      if self.bccx.method_map.contains_key_ref(&ex.id) => {\n         // Receivers in method calls are always passed by ref.\n         //\n         // Here, the field a.b is in fact a closure.  Eventually, this"}, {"sha": "0b06fbd2a3a4d4eba75c263d29d16bcbbd2e6378", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -33,7 +33,7 @@ mutability M_L, and a lifetime L_L where:\n   - immutable/mutable: the data cannot be moved or mutated\n - The lifetime L_L indicates the *scope* of the loan.\n \n-XXX --- much more needed, don't have time to write this all up now\n+FIXME #4730 --- much more needed, don't have time to write this all up now\n \n */\n "}, {"sha": "b160c2e5a146d3a72f4c46b469e100b1e692a047", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -241,7 +241,7 @@ use core::io;\n use core::result::{Result, Ok, Err};\n use std::list::{List, Cons, Nil};\n use std::list;\n-use std::map::{HashMap, Set};\n+use std::oldmap::{HashMap, Set};\n use syntax::ast::{mutability, m_mutbl, m_imm, m_const};\n use syntax::ast;\n use syntax::ast_map;"}, {"sha": "3bc34d2ef292cb9cd381cd55ff998817be3ed684", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -375,7 +375,7 @@ impl PreserveCtxt {\n                 // scope_id;`. Though that would potentially re-introduce\n                 // the ICE. See #3511 for more details.\n                 let scope_to_use = if\n-                    self.bccx.stmt_map.contains_key(scope_id) {\n+                    self.bccx.stmt_map.contains_key_ref(&scope_id) {\n                     // Root it in its parent scope, b/c\n                     // trans won't introduce a new scope for the\n                     // stmt"}, {"sha": "98c3fdaa8c35d84065164da1f45010442e20712c", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -18,8 +18,9 @@ use util::ppaux;\n \n use core::dvec::DVec;\n use core::option;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::*;\n+use syntax::codemap;\n use syntax::{visit, ast_util, ast_map};\n \n pub fn check_crate(sess: Session,\n@@ -64,7 +65,10 @@ pub fn check_pat(p: @pat, &&_is_const: bool, v: visit::vt<bool>) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n-                @expr { node: expr_lit(@spanned { node: lit_str(_), _}), _ },\n+                @expr { node: expr_lit(@codemap::spanned {\n+                    node: lit_str(_),\n+                    _}),\n+                       _ },\n                 expr_vstore_uniq\n             ) => true,\n             _ => false\n@@ -96,9 +100,9 @@ pub fn check_expr(sess: Session,\n                           ~\"disallowed operator in constant expression\");\n             return;\n           }\n-          expr_lit(@spanned {node: lit_str(_), _}) => { }\n+          expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n           expr_binary(_, _, _) | expr_unary(_, _) => {\n-            if method_map.contains_key(e.id) {\n+            if method_map.contains_key_ref(&e.id) {\n                 sess.span_err(e.span, ~\"user-defined operators are not \\\n                                        allowed in constant expressions\");\n             }\n@@ -183,15 +187,15 @@ pub fn check_expr(sess: Session,\n         }\n     }\n     match e.node {\n-      expr_lit(@spanned {node: lit_int(v, t), _}) => {\n+      expr_lit(@codemap::spanned {node: lit_int(v, t), _}) => {\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n                 if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n                 sess.span_err(e.span, ~\"literal out of range for its type\");\n             }\n         }\n       }\n-      expr_lit(@spanned {node: lit_uint(v, t), _}) => {\n+      expr_lit(@codemap::spanned {node: lit_uint(v, t), _}) => {\n         if v > ast_util::uint_ty_max(\n             if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n             sess.span_err(e.span, ~\"literal out of range for its type\");\n@@ -249,7 +253,7 @@ pub fn check_item_recursion(sess: Session,\n                   ast_map::node_item(it, _) => {\n                     (v.visit_item)(it, env, v);\n                   }\n-                  _ => fail ~\"const not bound to an item\"\n+                  _ => die!(~\"const not bound to an item\")\n                 }\n               }\n               _ => ()"}, {"sha": "e25ceee5d30164a005ebed785c71e0e309d18901", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -23,12 +23,11 @@ use core::cmp;\n use core::option;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std::sort;\n use syntax::ast::*;\n-use syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat, walk_pat};\n-use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::ast_util::{variant_def_ids, unguarded_pat, walk_pat};\n+use syntax::codemap::{span, dummy_sp, spanned};\n use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n \n@@ -60,7 +59,7 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n         return false;\n     }\n \n-    !cx.moves_map.contains_key(expr.id)\n+    !cx.moves_map.contains_key_ref(&expr.id)\n }\n \n pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n@@ -148,11 +147,11 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n           }\n           ty::ty_enum(id, _) => {\n               let vid = match (*ctor) { variant(id) => id,\n-              _ => fail ~\"check_exhaustive: non-variant ctor\" };\n+              _ => die!(~\"check_exhaustive: non-variant ctor\") };\n             match vec::find(*ty::enum_variants(cx.tcx, id),\n                                 |v| v.id == vid) {\n                 Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n-              None => fail ~\"check_exhaustive: bad variant in ctor\"\n+              None => die!(~\"check_exhaustive: bad variant in ctor\")\n             }\n           }\n           ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n@@ -367,7 +366,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n                     return Some(variant(v.id));\n                 }\n             }\n-            fail;\n+            die!();\n         } else { None }\n       }\n       ty::ty_nil => None,\n@@ -378,7 +377,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n               Some(val(const_bool(false))) => false_found = true,\n-              _ => fail ~\"impossible case\"\n+              _ => die!(~\"impossible case\")\n             }\n         }\n         if true_found && false_found { None }\n@@ -446,10 +445,10 @@ pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match ctor { variant(id) => id,\n-          _ => fail ~\"impossible case\" };\n+          _ => die!(~\"impossible case\") };\n         match vec::find(*ty::enum_variants(cx.tcx, eid), |v| v.id == id ) {\n             Some(v) => v.args.len(),\n-            None => fail ~\"impossible case\"\n+            None => die!(~\"impossible case\")\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n@@ -464,7 +463,7 @@ pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n }\n \n pub fn wild() -> @pat {\n-    @pat {id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n+    @pat {id: 0, node: pat_wild, span: dummy_sp()}\n }\n \n pub fn specialize(cx: @MatchCheckCtxt,\n@@ -497,7 +496,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                     compare_const_vals((*c_hi), e_v) <= 0\n                             }\n                             single => true,\n-                            _ => fail ~\"type error\"\n+                            _ => die!(~\"type error\")\n                         };\n                         if match_ { Some(vec::tail(r)) } else { None }\n                     }\n@@ -516,7 +515,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     }\n                     def_variant(_, _) => None,\n                     def_struct(*) => {\n-                        // XXX: Is this right? --pcw\n+                        // FIXME #4731: Is this right? --pcw\n                         let new_args;\n                         match args {\n                             Some(args) => new_args = args,\n@@ -530,7 +529,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             pat_rec(ref flds, _) => {\n                 let ty_flds = match /*bad*/copy ty::get(left_ty).sty {\n                     ty::ty_rec(flds) => flds,\n-                    _ => fail ~\"bad type for pat_rec\"\n+                    _ => die!(~\"bad type for pat_rec\")\n                 };\n                 let args = vec::map(ty_flds, |ty_fld| {\n                     match flds.find(|f| f.ident == ty_fld.ident) {\n@@ -545,7 +544,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 match cx.tcx.def_map.get(pat_id) {\n                     def_variant(_, variant_id) => {\n                         if variant(variant_id) == ctor_id {\n-                            // XXX: Is this right? --pcw\n+                            // FIXME #4731: Is this right? --pcw\n                             let args = flds.map(|ty_field| {\n                                 match flds.find(|f|\n                                                 f.ident == ty_field.ident) {\n@@ -596,7 +595,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             compare_const_vals((*c_hi), e_v) <= 0\n                     }\n                     single => true,\n-                    _ => fail ~\"type error\"\n+                    _ => die!(~\"type error\")\n                 };\n                 if match_ { Some(vec::tail(r)) } else { None }\n             }\n@@ -606,7 +605,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                     range(ref lo, ref hi) =>\n                         ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n                     single => return Some(vec::tail(r)),\n-                    _ => fail ~\"type error\"\n+                    _ => die!(~\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo),\n                 v_hi = eval_const_expr(cx.tcx, hi);\n@@ -735,7 +734,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                     by_ref_span = Some(span);\n                 }\n                 bind_infer => {\n-                    if cx.moves_map.contains_key(id) {\n+                    if cx.moves_map.contains_key_ref(&id) {\n                         any_by_move = true;\n                     }\n                 }\n@@ -775,7 +774,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     pat_ident(_, _, sub) => {\n-                        if cx.moves_map.contains_key(p.id) {\n+                        if cx.moves_map.contains_key_ref(&p.id) {\n                             check_move(p, sub);\n                         }\n                     }\n@@ -801,7 +800,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                                 behind_bad_pointer);\n \n                         if behind_bad_pointer &&\n-                            cx.moves_map.contains_key(pat.id)\n+                            cx.moves_map.contains_key_ref(&pat.id)\n                         {\n                             cx.tcx.sess.span_err(\n                                 pat.span,"}, {"sha": "f917964d2345f86a46ee9e6706c49b23cd10f3b4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -233,7 +233,7 @@ pub enum const_val {\n pub fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(ref r) => (/*bad*/copy *r),\n-        Err(ref s) => fail (/*bad*/copy *s)\n+        Err(ref s) => die!(/*bad*/copy *s)\n     }\n }\n \n@@ -459,7 +459,7 @@ pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n-    _ => fail ~\"compare_const_vals: ill-typed comparison\"\n+    _ => die!(~\"compare_const_vals: ill-typed comparison\")\n   }\n }\n "}, {"sha": "1e9d8c9c08e28b595c8a5db07454f2afd8470535", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -18,7 +18,7 @@ use middle::ty;\n use core::int;\n use core::option::*;\n use core::vec;\n-use std::map::*;\n+use std::oldmap::*;\n use syntax::codemap::span;\n use syntax::print::pprust::path_to_str;\n use syntax::{ast, ast_util, visit};\n@@ -59,7 +59,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n               ast::expr_path(*) => {\n                   let mut i = 0;\n                   match def_map.find(expr.id) {\n-                    None => fail ~\"path not found\",\n+                    None => die!(~\"path not found\"),\n                     Some(df) => {\n                       let mut def = df;\n                       while i < depth {\n@@ -71,7 +71,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n                       }\n                       if i == depth { // Made it to end of loop\n                         let dnum = ast_util::def_id_of_def(def).node;\n-                        if !seen.contains_key(dnum) {\n+                        if !seen.contains_key_ref(&dnum) {\n                             refs.push(@freevar_entry {\n                                 def: def,\n                                 span: expr.span,\n@@ -119,7 +119,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     match tcx.freevars.find(fid) {\n-      None => fail ~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\",\n+      None => die!(~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\"),\n       Some(d) => return d\n     }\n }"}, {"sha": "09232a2a0c52f5d9a08701422c662c6788f2f6ec", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -24,9 +24,9 @@ use util::ppaux::{ty_to_str, tys_to_str};\n use core::option;\n use core::str;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::*;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, spanned};\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit, ast_util};\n \n@@ -213,11 +213,11 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         };\n         if vec::len(*ts) != vec::len(*bounds) {\n             // Fail earlier to make debugging easier\n-            fail fmt!(\"internal error: in kind::check_expr, length \\\n+            die!(fmt!(\"internal error: in kind::check_expr, length \\\n                        mismatch between actual and declared bounds: actual = \\\n                         %s (%u tys), declared = %? (%u tys)\",\n                       tys_to_str(cx.tcx, *ts), ts.len(),\n-                      *bounds, (*bounds).len());\n+                      *bounds, (*bounds).len()));\n         }\n         for vec::each2(*ts, *bounds) |ty, bound| {\n             check_bounds(cx, type_parameter_id, e.span, *ty, *bound)"}, {"sha": "3eb65505e6462a8aceceda6ff606ea72b61ce531", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -33,7 +33,7 @@ use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::{visit_crate, visit_item};\n \n use core::ptr;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use str_eq = str::eq;\n \n pub enum LangItem {\n@@ -391,7 +391,7 @@ impl LanguageItemCollector {\n     }\n \n     fn check_completeness() {\n-        for self.item_refs.each |key, item_ref| {\n+        for self.item_refs.each_ref |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", key));"}, {"sha": "0dc7a746e9e8389ca90ef50faa5aa034ad0a720c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -32,13 +32,14 @@ use core::u32;\n use core::u64;\n use core::uint;\n use core::vec;\n-use std::map::{Map, HashMap};\n-use std::map;\n-use std::smallintmap::{Map, SmallIntMap};\n-use std::smallintmap;\n+use std::oldmap::{Map, HashMap};\n+use std::oldmap;\n+use std::oldsmallintmap::{Map, SmallIntMap};\n+use std::oldsmallintmap;\n use syntax::ast_util::{path_to_ident};\n use syntax::attr;\n use syntax::codemap::span;\n+use syntax::codemap;\n use syntax::print::pprust::{expr_to_str, mode_to_str, pat_to_str};\n use syntax::{ast, ast_util, visit};\n \n@@ -232,7 +233,7 @@ pub fn get_lint_dict() -> lint_dict {\n            default: warn}),\n         */\n     ];\n-    map::hash_from_vec(v)\n+    oldmap::hash_from_vec(v)\n }\n \n // This is a highly not-optimal set of data structure decisions.\n@@ -248,7 +249,7 @@ pub type lint_settings = {\n };\n \n pub fn mk_lint_settings() -> lint_settings {\n-    {default_settings: smallintmap::mk(),\n+    {default_settings: oldsmallintmap::mk(),\n      settings_map: HashMap()}\n }\n \n@@ -273,7 +274,8 @@ pub fn get_lint_settings_level(settings: lint_settings,\n // This is kind of unfortunate. It should be somewhere else, or we should use\n // a persistent data structure...\n fn clone_lint_modes(modes: lint_modes) -> lint_modes {\n-    smallintmap::SmallIntMap_(@smallintmap::SmallIntMap_ { v: copy modes.v })\n+    oldsmallintmap::SmallIntMap_(@oldsmallintmap::SmallIntMap_\n+    {v: copy modes.v})\n }\n \n type ctxt_ = {dict: lint_dict,\n@@ -393,12 +395,14 @@ fn build_settings_item(i: @ast::item, &&cx: ctxt, v: visit::vt<ctxt>) {\n \n pub fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n     let cx = ctxt_({dict: get_lint_dict(),\n-                    curr: smallintmap::mk(),\n+                    curr: oldsmallintmap::mk(),\n                     is_default: true,\n                     sess: sess});\n \n     // Install defaults.\n-    for cx.dict.each |_k, spec| { cx.set_level(spec.lint, spec.default); }\n+    for cx.dict.each_value_ref |&spec| {\n+        cx.set_level(spec.lint, spec.default);\n+    }\n \n     // Install command-line options, overriding defaults.\n     for sess.opts.lint_opts.each |pair| {\n@@ -452,7 +456,7 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n                 match e.node {\n                     ast::expr_while(cond, _) => {\n                         match cond.node {\n-                            ast::expr_lit(@ast::spanned {\n+                            ast::expr_lit(@codemap::spanned {\n                                 node: ast::lit_bool(true), _}) =>\n                             {\n                                 cx.sess.span_lint(\n@@ -481,7 +485,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n             ast::gt => v >= min,\n             ast::ge => v > min,\n             ast::eq | ast::ne => v >= min && v <= max,\n-            _ => fail\n+            _ => die!()\n         }\n     }\n \n@@ -540,7 +544,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n                         ast::lit_int_unsuffixed(v) => v,\n                         _ => return true\n                     },\n-                    _ => fail\n+                    _ => die!()\n                 };\n                 is_valid(norm_binop, lit_val, min, max)\n             }\n@@ -553,7 +557,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n                         ast::lit_int_unsuffixed(v) => v as u64,\n                         _ => return true\n                     },\n-                    _ => fail\n+                    _ => die!()\n                 };\n                 is_valid(norm_binop, lit_val, min, max)\n             }\n@@ -954,7 +958,7 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                                        ty_to_str(tcx, arg_ty.ty),\n                                        mode_to_str(arg_ast.mode));\n                                 error!(\"%?\",arg_ast.ty.node);\n-                                fail\n+                                die!()\n                             }\n                         };\n                     }"}, {"sha": "c13af3a32f200636832257d6ed5ce141f310feba", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -119,7 +119,7 @@ use core::ptr;\n use core::to_str;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n@@ -222,11 +222,11 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n impl LiveNode: to_str::ToStr {\n-    pure fn to_str() -> ~str { fmt!(\"ln(%u)\", *self) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"ln(%u)\", **self) }\n }\n \n impl Variable: to_str::ToStr {\n-    pure fn to_str() -> ~str { fmt!(\"v(%u)\", *self) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"v(%u)\", **self) }\n }\n \n // ______________________________________________________________________\n@@ -610,7 +610,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n       expr_tup(*) | expr_log(*) | expr_binary(*) |\n       expr_assert(*) | expr_addr_of(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_do_body(*) | expr_cast(*) |\n-      expr_unary(*) | expr_fail(*) |\n+      expr_unary(*) |\n       expr_break(_) | expr_again(_) | expr_lit(_) | expr_ret(*) |\n       expr_block(*) | expr_assign(*) |\n       expr_swap(*) | expr_assign_op(*) | expr_mac(*) | expr_struct(*) |\n@@ -1191,7 +1191,7 @@ impl Liveness {\n             self.propagate_through_expr(e, ln)\n           }\n \n-          expr_ret(o_e) | expr_fail(o_e) => {\n+          expr_ret(o_e) => {\n             // ignore succ and subst exit_ln:\n             self.propagate_through_opt_expr(o_e, self.s.exit_ln)\n           }\n@@ -1608,7 +1608,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n       expr_log(*) | expr_binary(*) |\n       expr_assert(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_do_body(*) |\n-      expr_cast(*) | expr_unary(*) | expr_fail(*) |\n+      expr_cast(*) | expr_unary(*) |\n       expr_ret(*) | expr_break(*) | expr_again(*) | expr_lit(_) |\n       expr_block(*) | expr_swap(*) | expr_mac(*) | expr_addr_of(*) |\n       expr_struct(*) | expr_repeat(*) | expr_paren(*) => {\n@@ -1754,7 +1754,8 @@ impl @Liveness {\n         // used by ExitNode would be arguments or fields in a ctor.\n         // we give a slightly different error message in those cases.\n         if lnk == ExitNode {\n-            // XXX this seems like it should be reported in the borrow checker\n+            // FIXME #4715: this seems like it should be reported in the\n+            // borrow checker\n             let vk = self.ir.var_kinds[*var];\n             match vk {\n               Arg(_, name, _) => {"}, {"sha": "94fc63b75ddaae2948bf82964ce8233b1f69b033", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -348,7 +348,7 @@ pub impl &mem_categorization_ctxt {\n         let expr_ty = tcx.ty(expr);\n         match expr.node {\n           ast::expr_unary(ast::deref, e_base) => {\n-            if self.method_map.contains_key(expr.id) {\n+            if self.method_map.contains_key_ref(&expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n \n@@ -357,7 +357,7 @@ pub impl &mem_categorization_ctxt {\n           }\n \n           ast::expr_field(base, f_name, _) => {\n-            if self.method_map.contains_key(expr.id) {\n+            if self.method_map.contains_key_ref(&expr.id) {\n                 return self.cat_method_ref(expr, expr_ty);\n             }\n \n@@ -366,7 +366,7 @@ pub impl &mem_categorization_ctxt {\n           }\n \n           ast::expr_index(base, _) => {\n-            if self.method_map.contains_key(expr.id) {\n+            if self.method_map.contains_key_ref(&expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n \n@@ -387,7 +387,7 @@ pub impl &mem_categorization_ctxt {\n           ast::expr_assert(*) | ast::expr_ret(*) |\n           ast::expr_loop_body(*) | ast::expr_do_body(*) |\n           ast::expr_unary(*) | ast::expr_method_call(*) |\n-          ast::expr_copy(*) | ast::expr_cast(*) | ast::expr_fail(*) |\n+          ast::expr_copy(*) | ast::expr_cast(*) |\n           ast::expr_vstore(*) | ast::expr_vec(*) | ast::expr_tup(*) |\n           ast::expr_if(*) | ast::expr_log(*) |\n           ast::expr_binary(*) | ast::expr_while(*) |"}, {"sha": "8adebdb45820d88c2c7b7e61558249c8c43f20de", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -217,7 +217,7 @@ use util::ppaux;\n use util::common::indenter;\n \n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n@@ -573,7 +573,6 @@ impl VisitContext {\n                 self.consume_block(blk, visitor);\n             }\n \n-            expr_fail(ref opt_expr) |\n             expr_ret(ref opt_expr) => {\n                 for opt_expr.each |expr| {\n                     self.consume_expr(*expr, visitor);\n@@ -641,7 +640,7 @@ impl VisitContext {\n                                arg_exprs: &[@expr],\n                                visitor: vt<VisitContext>) -> bool\n     {\n-        if !self.method_map.contains_key(expr.id) {\n+        if !self.method_map.contains_key_ref(&expr.id) {\n             return false;\n         }\n \n@@ -772,7 +771,7 @@ impl VisitContext {\n             for arm.pats.each |pat| {\n                 let mut found = false;\n                 do pat_bindings(self.tcx.def_map, *pat) |_, node_id, _, _| {\n-                    if moves_map.contains_key(node_id) {\n+                    if moves_map.contains_key_ref(&node_id) {\n                         found = true;\n                     }\n                 }\n@@ -812,4 +811,4 @@ impl VisitContext {\n             })\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c39d750a5814a4508acb678926e2bb42dfb62a3d", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,12 +14,11 @@ use middle::resolve;\n use middle::ty;\n \n use syntax::ast::*;\n-use syntax::ast_util;\n-use syntax::ast_util::{path_to_ident, respan, walk_pat};\n+use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::fold;\n use syntax::fold::*;\n-use syntax::codemap::span;\n-use std::map::HashMap;\n+use syntax::codemap::{span, respan};\n+use std::oldmap::HashMap;\n \n pub type PatIdMap = HashMap<ident, node_id>;\n "}, {"sha": "482f01f72016ffaee9adfcdebf51e4daacfe0fe0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -131,7 +131,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         }\n                     }\n                 } else {\n-                    // XXX: External crates.\n+                    // FIXME #4732: External crates.\n                 }\n             }\n             method_param(method_param {\n@@ -195,7 +195,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         }\n                     }\n                 } else {\n-                    // XXX: External crates.\n+                    // FIXME #4732: External crates.\n                 }\n             }\n         }"}, {"sha": "4602d2aff4ee95b43b24d2c6576ce47f6aabbd7b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -32,7 +32,7 @@ use core::dvec::DVec;\n use core::vec;\n use std::list;\n use std::list::list;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast_map;\n use syntax::codemap::span;\n use syntax::print::pprust;\n@@ -296,7 +296,7 @@ pub fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n       _ => {}\n     };\n \n-    if new_cx.root_exprs.contains_key(expr.id) {\n+    if new_cx.root_exprs.contains_key_ref(&expr.id) {\n         new_cx.parent = Some(expr.id);\n     }\n \n@@ -833,7 +833,7 @@ pub fn determine_rp_in_crate(sess: Session,\n \n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n-        for cx.region_paramd_items.each |key, value| {\n+        for cx.region_paramd_items.each_ref |&key, &value| {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "c40b6df692689de79e1ed0b9f2a63cfe9ab974f2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -58,15 +58,15 @@ use syntax::ast::{variant, view_item, view_item_import};\n use syntax::ast::{view_item_use, view_path_glob, view_path_list};\n use syntax::ast::{view_path_simple, visibility, anonymous, named, not};\n use syntax::ast::{unsafe_fn};\n-use syntax::ast_util::{def_id_of_def, dummy_sp, local_def};\n+use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr::{attr_metas, contains_name, attrs_contains_name};\n use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{pat_to_str, path_to_str};\n-use syntax::codemap::span;\n+use syntax::codemap::{span, dummy_sp};\n use syntax::visit::{default_visitor, fk_method, mk_vt, Visitor, visit_block};\n use syntax::visit::{visit_crate, visit_expr, visit_expr_opt, visit_fn};\n use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n@@ -79,7 +79,7 @@ use str::{connect, split_str};\n use vec::pop;\n \n use std::list::{Cons, List, Nil};\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use str_eq = str::eq;\n \n // Definition mapping\n@@ -322,7 +322,7 @@ pub fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode)\n         ForbidDuplicateModules | ForbidDuplicateTypes |\n         ForbidDuplicateTypesAndValues => TypeNS,\n         ForbidDuplicateValues => ValueNS,\n-        OverwriteDuplicates => fail ~\"OverwriteDuplicates has no namespace\"\n+        OverwriteDuplicates => die!(~\"OverwriteDuplicates has no namespace\")\n     }\n }\n \n@@ -604,8 +604,8 @@ pub impl NameBindings {\n     fn get_module() -> @Module {\n         match self.get_module_if_available() {\n             None => {\n-                fail ~\"get_module called on a node with no module \\\n-                       definition!\"\n+                die!(~\"get_module called on a node with no module \\\n+                       definition!\")\n             }\n             Some(module_def) => module_def\n         }\n@@ -1212,7 +1212,7 @@ pub impl Resolver {\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n                         let def_id = local_def(item.id);\n-                        name_bindings.define_module(privacy,\n+                        name_bindings.define_module(Public,\n                                                     parent_link,\n                                                     Some(def_id),\n                                                     TraitModuleKind,\n@@ -1326,7 +1326,7 @@ pub impl Resolver {\n             }\n \n             item_mac(*) => {\n-                fail ~\"item macros unimplemented\"\n+                die!(~\"item macros unimplemented\")\n             }\n         }\n     }\n@@ -1579,7 +1579,7 @@ pub impl Resolver {\n                     match existing_module.parent_link {\n                       NoParentLink |\n                       BlockParentLink(*) => {\n-                        fail ~\"can't happen\";\n+                        die!(~\"can't happen\");\n                       }\n                       ModuleParentLink(parent_module, ident) => {\n                         let name_bindings = parent_module.children.get(ident);\n@@ -1645,7 +1645,7 @@ pub impl Resolver {\n           def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n           def_use(*) | def_upvar(*) | def_region(*) |\n           def_typaram_binder(*) | def_label(*) | def_self_ty(*) => {\n-            fail fmt!(\"didn't expect `%?`\", def);\n+            die!(fmt!(\"didn't expect `%?`\", def));\n           }\n         }\n     }\n@@ -1913,7 +1913,7 @@ pub impl Resolver {\n                self.module_to_str(module_));\n         self.resolve_imports_for_module(module_);\n \n-        for module_.children.each |_name, child_node| {\n+        for module_.children.each_value_ref |&child_node| {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -1924,7 +1924,7 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each |_block_id, child_module| {\n+        for module_.anonymous_children.each_value_ref |&child_module| {\n             self.resolve_imports_for_module_subtree(child_module);\n         }\n     }\n@@ -2211,7 +2211,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key(target);\n+        assert module_.import_resolutions.contains_key_ref(&target);\n         let import_resolution = module_.import_resolutions.get(target);\n \n         match value_result {\n@@ -2221,7 +2221,7 @@ pub impl Resolver {\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail ~\"value result should be known at this point\";\n+                die!(~\"value result should be known at this point\");\n             }\n         }\n         match type_result {\n@@ -2231,7 +2231,7 @@ pub impl Resolver {\n             }\n             UnboundResult => { /* Continue. */ }\n             UnknownResult => {\n-                fail ~\"type result should be known at this point\";\n+                die!(~\"type result should be known at this point\");\n             }\n         }\n \n@@ -2370,7 +2370,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key(target);\n+        assert module_.import_resolutions.contains_key_ref(&target);\n         let import_resolution = module_.import_resolutions.get(target);\n \n         match module_result {\n@@ -2384,7 +2384,7 @@ pub impl Resolver {\n                         binding\");\n             }\n             UnknownResult => {\n-                fail ~\"module result should be known at this point\";\n+                die!(~\"module result should be known at this point\");\n             }\n         }\n \n@@ -2430,8 +2430,8 @@ pub impl Resolver {\n         assert containing_module.glob_count == 0;\n \n         // Add all resolved imports from the containing module.\n-        for containing_module.import_resolutions.each\n-                |ident, target_import_resolution| {\n+        for containing_module.import_resolutions.each_ref\n+                |&ident, &target_import_resolution| {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n@@ -2480,7 +2480,7 @@ pub impl Resolver {\n         }\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |ident, name_bindings| {\n+        for containing_module.children.each_ref |&ident, &name_bindings| {\n             let mut dest_import_resolution;\n             match module_.import_resolutions.find(ident) {\n                 None => {\n@@ -2996,7 +2996,7 @@ pub impl Resolver {\n                 allowable_namespaces = namespaces;\n             }\n             GlobImport => {\n-                fail ~\"found `import *`, which is invalid\";\n+                die!(~\"found `import *`, which is invalid\");\n             }\n         }\n \n@@ -3116,9 +3116,9 @@ pub impl Resolver {\n         // Otherwise, proceed and write in the bindings.\n         match module_.import_resolutions.find(target_name) {\n             None => {\n-                fail ~\"(resolving one-level renaming import) reduced graph \\\n+                die!(~\"(resolving one-level renaming import) reduced graph \\\n                       construction or glob importing should have created the \\\n-                      import resolution name by now\";\n+                      import resolution name by now\");\n             }\n             Some(import_resolution) => {\n                 debug!(\"(resolving one-level renaming import) writing module \\\n@@ -3148,7 +3148,7 @@ pub impl Resolver {\n         }\n \n         // Descend into children and anonymous children.\n-        for module_.children.each |_name, child_node| {\n+        for module_.children.each_value_ref |&child_node| {\n             match child_node.get_module_if_available() {\n                 None => {\n                     // Continue.\n@@ -3159,7 +3159,7 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each |_name, module_| {\n+        for module_.anonymous_children.each_value_ref |&module_| {\n             self.report_unresolved_imports(module_);\n         }\n     }\n@@ -3204,7 +3204,7 @@ pub impl Resolver {\n \n         self.record_exports_for_module(module_);\n \n-        for module_.children.each |_ident, child_name_bindings| {\n+        for module_.children.each_value_ref |&child_name_bindings| {\n             match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -3215,7 +3215,7 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each |_node_id, child_module| {\n+        for module_.anonymous_children.each_value_ref |&child_module| {\n             self.record_exports_for_module_subtree(child_module);\n         }\n     }\n@@ -3732,7 +3732,7 @@ pub impl Resolver {\n             }\n \n           item_mac(*) => {\n-            fail ~\"item macros unimplemented\"\n+            die!(~\"item macros unimplemented\")\n           }\n         }\n \n@@ -4068,7 +4068,7 @@ pub impl Resolver {\n         for arm.pats.eachi() |i, p| {\n             let map_i = self.binding_mode_map(*p);\n \n-            for map_0.each |key, binding_0| {\n+            for map_0.each_ref |&key, &binding_0| {\n                 match map_i.find(key) {\n                   None => {\n                     self.session.span_err(\n@@ -4089,8 +4089,8 @@ pub impl Resolver {\n                 }\n             }\n \n-            for map_i.each |key, binding| {\n-                if !map_0.contains_key(key) {\n+            for map_i.each_ref |&key, &binding| {\n+                if !map_0.contains_key_ref(&key) {\n                     self.session.span_err(\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n@@ -4319,7 +4319,8 @@ pub impl Resolver {\n \n                             match bindings_list {\n                                 Some(bindings_list)\n-                                if !bindings_list.contains_key(ident) => {\n+                                if !bindings_list.contains_key_ref(&ident)\n+                                    => {\n                                     let last_rib = (*self.value_ribs).last();\n                                     last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n@@ -4391,16 +4392,19 @@ pub impl Resolver {\n                 pat_struct(path, _, _) => {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n-                                if self.structs.contains_key(class_id) => {\n+                                if self.structs.contains_key_ref(&class_id)\n+                                     => {\n                             let class_def = def_struct(class_id);\n                             self.record_def(pattern.id, class_def);\n                         }\n                         Some(definition @ def_struct(class_id))\n-                                if self.structs.contains_key(class_id) => {\n+                                if self.structs.contains_key_ref(&class_id)\n+                                     => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         Some(definition @ def_variant(_, variant_id))\n-                                if self.structs.contains_key(variant_id) => {\n+                                if self.structs.contains_key_ref(&variant_id)\n+                                     => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n@@ -4430,8 +4434,8 @@ pub impl Resolver {\n             Success(target) => {\n                 match target.bindings.value_def {\n                     None => {\n-                        fail ~\"resolved name in the value namespace to a set \\\n-                              of name bindings with no def?!\";\n+                        die!(~\"resolved name in the value namespace to a set \\\n+                              of name bindings with no def?!\");\n                     }\n                     Some(def) => {\n                         match def.def {\n@@ -4450,7 +4454,7 @@ pub impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail ~\"unexpected indeterminate result\";\n+                die!(~\"unexpected indeterminate result\");\n             }\n \n             Failed => {\n@@ -4611,7 +4615,7 @@ pub impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail ~\"indeterminate unexpected\";\n+                die!(~\"indeterminate unexpected\");\n             }\n \n             Success(resulting_module) => {\n@@ -4658,7 +4662,7 @@ pub impl Resolver {\n             }\n \n             Indeterminate => {\n-                fail ~\"indeterminate unexpected\";\n+                die!(~\"indeterminate unexpected\");\n             }\n \n             Success(resulting_module) => {\n@@ -4736,7 +4740,7 @@ pub impl Resolver {\n                 }\n             }\n             Indeterminate => {\n-                fail ~\"unexpected indeterminate result\";\n+                die!(~\"unexpected indeterminate result\");\n             }\n             Failed => {\n                 return None;\n@@ -4848,12 +4852,12 @@ pub impl Resolver {\n \n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n-                            if self.structs.contains_key(class_id) => {\n+                            if self.structs.contains_key_ref(&class_id) => {\n                         let class_def = def_struct(class_id);\n                         self.record_def(expr.id, class_def);\n                     }\n                     Some(definition @ def_variant(_, class_id))\n-                            if self.structs.contains_key(class_id) => {\n+                            if self.structs.contains_key_ref(&class_id) => {\n                         self.record_def(expr.id, definition);\n                     }\n                     _ => {\n@@ -4997,7 +5001,7 @@ pub impl Resolver {\n             }\n \n             // Look for trait children.\n-            for search_module.children.each |_name, child_name_bindings| {\n+            for search_module.children.each_value_ref |&child_name_bindings| {\n                 match child_name_bindings.def_for_namespace(TypeNS) {\n                     Some(def) => {\n                         match def {\n@@ -5017,8 +5021,8 @@ pub impl Resolver {\n             }\n \n             // Look for imports.\n-            for search_module.import_resolutions.each\n-                    |_ident, import_resolution| {\n+            for search_module.import_resolutions.each_value_ref\n+                    |&import_resolution| {\n \n                 match import_resolution.target_for_namespace(TypeNS) {\n                     None => {\n@@ -5073,7 +5077,7 @@ pub impl Resolver {\n                self.session.str_of(name));\n \n         match self.trait_info.find(trait_def_id) {\n-            Some(trait_info) if trait_info.contains_key(name) => {\n+            Some(trait_info) if trait_info.contains_key_ref(&name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n@@ -5180,7 +5184,7 @@ pub impl Resolver {\n \n         self.check_for_unused_imports_in_module(module_);\n \n-        for module_.children.each |_ident, child_name_bindings| {\n+        for module_.children.each_value_ref |&child_name_bindings| {\n             match (*child_name_bindings).get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -5192,13 +5196,13 @@ pub impl Resolver {\n             }\n         }\n \n-        for module_.anonymous_children.each |_node_id, child_module| {\n+        for module_.anonymous_children.each_value_ref |&child_module| {\n             self.check_for_unused_imports_in_module_subtree(child_module);\n         }\n     }\n \n     fn check_for_unused_imports_in_module(module_: @Module) {\n-        for module_.import_resolutions.each |_name, import_resolution| {\n+        for module_.import_resolutions.each_value_ref |&import_resolution| {\n             if !import_resolution.used {\n                 match self.unused_import_lint_level {\n                     warn => {\n@@ -5257,12 +5261,12 @@ pub impl Resolver {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n-        for module_.children.each |name, _child| {\n+        for module_.children.each_key_ref |&name| {\n             debug!(\"* %s\", self.session.str_of(name));\n         }\n \n         debug!(\"Import resolutions:\");\n-        for module_.import_resolutions.each |name, import_resolution| {\n+        for module_.import_resolutions.each_ref |&name, &import_resolution| {\n             let mut value_repr;\n             match (*import_resolution).target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }"}, {"sha": "6913cf8e2f5187e83d14b5f94c92f0842f5e46ef", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -164,7 +164,7 @@ use util::common::indenter;\n \n use core::dvec::DVec;\n use core::dvec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::def_id;\n use syntax::ast;\n use syntax::ast_util::{dummy_sp, path_to_ident};\n@@ -209,8 +209,8 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                         a_expr = e.get();\n                     }\n                     UnitLikeStructLit(_) => {\n-                        fail ~\"UnitLikeStructLit should have been handled \\\n-                               above\"\n+                        die!(~\"UnitLikeStructLit should have been handled \\\n+                               above\")\n                     }\n                 }\n \n@@ -222,8 +222,8 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n                         b_expr = e.get();\n                     }\n                     UnitLikeStructLit(_) => {\n-                        fail ~\"UnitLikeStructLit should have been handled \\\n-                               above\"\n+                        die!(~\"UnitLikeStructLit should have been handled \\\n+                               above\")\n                     }\n                 }\n \n@@ -1085,7 +1085,7 @@ pub fn store_non_ref_bindings(bcx: block,\n      */\n \n     let mut bcx = bcx;\n-    for data.bindings_map.each_value |binding_info| {\n+    for data.bindings_map.each_value_ref |&binding_info| {\n         match binding_info.trmode {\n             TrByValue(is_move, lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n@@ -1119,7 +1119,7 @@ pub fn insert_lllocals(bcx: block,\n      * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n      * the bindings. */\n \n-    for data.bindings_map.each_value |binding_info| {\n+    for data.bindings_map.each_value_ref |&binding_info| {\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n@@ -1191,14 +1191,14 @@ pub fn compile_guard(bcx: block,\n \n     fn drop_bindings(bcx: block, data: &ArmData) -> block {\n         let mut bcx = bcx;\n-        for data.bindings_map.each_value |binding_info| {\n+        for data.bindings_map.each_value_ref |&binding_info| {\n             match binding_info.trmode {\n                 TrByValue(_, llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n                 }\n                 TrByRef | TrByImplicitRef => {}\n             }\n-            bcx.fcx.lllocals.remove(binding_info.id);\n+            bcx.fcx.lllocals.remove(&binding_info.id);\n         }\n         return bcx;\n     }\n@@ -1586,7 +1586,7 @@ pub fn trans_match_inner(scope_cx: block,\n                     // but during matching we need to store a *T as explained\n                     // above\n                     let is_move =\n-                        scope_cx.ccx().maps.moves_map.contains_key(p_id);\n+                        scope_cx.ccx().maps.moves_map.contains_key_ref(&p_id);\n                     llmatch = alloca(bcx, T_ptr(llvariable_ty));\n                     trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n                 }"}, {"sha": "a858ecb520a504bb9e0f132ecc4491a7b418a2c7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -75,9 +75,9 @@ use core::libc::{c_uint, c_ulonglong};\n use core::option::{is_none, is_some};\n use core::option;\n use core::uint;\n-use std::map::HashMap;\n-use std::smallintmap;\n-use std::{map, time, list};\n+use std::oldmap::HashMap;\n+use std::oldsmallintmap;\n+use std::{oldmap, time, list};\n use syntax::ast_map::{path, path_elt_to_str, path_mod, path_name};\n use syntax::ast_util::{def_id_of_def, local_def, path_to_ident};\n use syntax::attr;\n@@ -169,8 +169,7 @@ pub fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n                      +name: ~str,\n                      cc: lib::llvm::CallConv,\n                      ty: TypeRef) -> ValueRef {\n-    // XXX: Bad copy.\n-    if externs.contains_key(copy name) { return externs.get(name); }\n+    if externs.contains_key_ref(&name) { return externs.get(name); }\n     // XXX: Bad copy.\n     let f = decl_fn(llmod, copy name, cc, ty);\n     externs.insert(name, f);\n@@ -180,8 +179,7 @@ pub fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n                         +name: ~str, ty: TypeRef) -> ValueRef {\n     unsafe {\n-        // XXX: Bad copy.\n-        if externs.contains_key(copy name) { return externs.get(name); }\n+        if externs.contains_key_ref(&name) { return externs.get(name); }\n         let c = str::as_c_str(name, |buf| {\n             llvm::LLVMAddGlobal(llmod, ty, buf)\n         });\n@@ -451,7 +449,7 @@ pub fn set_glue_inlining(f: ValueRef, t: ty::t) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: @crate_ctxt, +sym: ~str) {\n     // XXX: Bad copy.\n-    if ccx.all_llvm_symbols.contains_key(copy sym) {\n+    if ccx.all_llvm_symbols.contains_key_ref(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     ccx.all_llvm_symbols.insert(sym, ());\n@@ -679,7 +677,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             let variant_cx =\n                 sub_block(cx,\n                                    ~\"enum-iter-variant-\" +\n-                                       int::to_str(variant.disr_val, 10u));\n+                                       int::to_str(variant.disr_val));\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             let variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, *variant,\n@@ -1850,7 +1848,7 @@ pub fn trans_enum_variant(ccx: @crate_ctxt,\n             ty: varg.ty,\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n-                ast_util::dummy_sp(),\n+                codemap::dummy_sp(),\n                 special_idents::arg),\n             id: varg.id,\n         }\n@@ -1888,7 +1886,7 @@ pub fn trans_enum_variant(ccx: @crate_ctxt,\n         // works. So we have to cast to the destination's view of the type.\n         let llarg = match fcx.llargs.find(va.id) {\n             Some(local_mem(x)) => x,\n-            _ => fail ~\"trans_enum_variant: how do we know this works?\",\n+            _ => die!(~\"trans_enum_variant: how do we know this works?\"),\n         };\n         let arg_ty = arg_tys[i].ty;\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n@@ -1913,7 +1911,7 @@ pub fn trans_tuple_struct(ccx: @crate_ctxt,\n             is_mutbl: false,\n             ty: field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n-                                        ast_util::dummy_sp(),\n+                                        codemap::dummy_sp(),\n                                         special_idents::arg),\n             id: field.node.id\n         }\n@@ -2024,7 +2022,7 @@ pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let path = match ccx.tcx.items.get(item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n-        _ => fail ~\"trans_item\",\n+        _ => die!(~\"trans_item\"),\n     };\n     match /*bad*/copy item.node {\n       // XXX: Bad copies.\n@@ -2044,7 +2042,7 @@ pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         } else {\n             for vec::each((*body).node.stmts) |stmt| {\n                 match stmt.node {\n-                  ast::stmt_decl(@ast::spanned { node: ast::decl_item(i),\n+                  ast::stmt_decl(@codemap::spanned { node: ast::decl_item(i),\n                                                  _ }, _) => {\n                     trans_item(ccx, *i);\n                   }\n@@ -2280,7 +2278,7 @@ pub fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n         /*bad*/copy *match ccx.tcx.items.get(i.id) {\n             ast_map::node_item(_, p) => p,\n                 // separate map for paths?\n-            _ => fail ~\"item_path\"\n+            _ => die!(~\"item_path\")\n         },\n         ~[path_name(i.ident)])\n }\n@@ -2367,7 +2365,7 @@ pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 set_inline_hint_if_appr(/*bad*/copy i.attrs, llfn);\n                 llfn\n               }\n-              _ => fail ~\"get_item_val: weird result in table\"\n+              _ => die!(~\"get_item_val: weird result in table\")\n             }\n           }\n           ast_map::node_trait_method(trait_method, _, pth) => {\n@@ -2448,14 +2446,14 @@ pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                       ast::item_enum(_, _) => {\n                         register_fn(ccx, (*v).span, pth, id, enm.attrs)\n                       }\n-                      _ => fail ~\"node_variant, shouldn't happen\"\n+                      _ => die!(~\"node_variant, shouldn't happen\")\n                     };\n                 }\n                 ast::struct_variant_kind(_) => {\n-                    fail ~\"struct variant kind unexpected in get_item_val\"\n+                    die!(~\"struct variant kind unexpected in get_item_val\")\n                 }\n                 ast::enum_variant_kind(_) => {\n-                    fail ~\"enum variant kind unexpected in get_item_val\"\n+                    die!(~\"enum variant kind unexpected in get_item_val\")\n                 }\n             }\n             set_inline_hint(llfn);\n@@ -2485,7 +2483,7 @@ pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             ccx.sess.bug(~\"get_item_val(): unexpected variant\")\n           }\n         };\n-        if !(exprt || ccx.reachable.contains_key(id)) {\n+        if !(exprt || ccx.reachable.contains_key_ref(&id)) {\n             lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n         }\n         ccx.item_vals.insert(id, val);\n@@ -2798,7 +2796,7 @@ pub fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n \n pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let elttype = T_struct(~[ccx.int_type, ccx.int_type]);\n-    let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n+    let maptype = T_array(elttype, ccx.module_data.len() + 1);\n     let map = str::as_c_str(~\"_rust_mod_map\", |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n@@ -2808,7 +2806,7 @@ pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n         lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     }\n     let mut elts: ~[ValueRef] = ~[];\n-    for ccx.module_data.each |key, val| {\n+    for ccx.module_data.each_ref |&key, &val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, key)),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n@@ -3016,7 +3014,7 @@ pub fn trans_crate(sess: session::Session,\n               monomorphized: HashMap(),\n               monomorphizing: HashMap(),\n               type_use_cache: HashMap(),\n-              vtables: map::HashMap(),\n+              vtables: oldmap::HashMap(),\n               const_cstr_cache: HashMap(),\n               const_globals: HashMap(),\n               const_values: HashMap(),\n@@ -3089,7 +3087,7 @@ pub fn trans_crate(sess: session::Session,\n         }\n \n         if ccx.sess.count_llvm_insns() {\n-            for ccx.stats.llvm_insns.each |k, v| {\n+            for ccx.stats.llvm_insns.each_ref |&k, &v| {\n                 io::println(fmt!(\"%-7u %s\", v, k));\n             }\n         }"}, {"sha": "7923643358026ada337091c835c1eb9ae5eb28f2", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,7 +22,7 @@ use core::cast;\n use core::libc;\n use core::str;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::codemap;\n \n pub fn terminate(cx: block, _: &str) {\n@@ -33,7 +33,7 @@ pub fn terminate(cx: block, _: &str) {\n \n pub fn check_not_terminated(cx: block) {\n     if cx.terminated {\n-        fail ~\"already terminated!\";\n+        die!(~\"already terminated!\");\n     }\n }\n "}, {"sha": "d3eb2157ee340db725d57621b1861f7b4c2d981b", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -96,7 +96,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                     let elt = llvm::LLVMGetElementType(ty);\n                     ty_align(elt)\n                 }\n-                _ => fail ~\"ty_size: unhandled type\"\n+                _ => die!(~\"ty_size: unhandled type\")\n             };\n         }\n     }\n@@ -122,7 +122,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                   let eltsz = ty_size(elt);\n                   len * eltsz\n                 }\n-                _ => fail ~\"ty_size: unhandled type\"\n+                _ => die!(~\"ty_size: unhandled type\")\n             };\n         }\n     }\n@@ -215,7 +215,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                         i += 1u;\n                     }\n                 }\n-                _ => fail ~\"classify: unhandled type\"\n+                _ => die!(~\"classify: unhandled type\")\n             }\n         }\n     }\n@@ -315,7 +315,7 @@ fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n                 sse_ds_class => {\n                     tys.push(T_f64());\n                 }\n-                _ => fail ~\"llregtype: unhandled class\"\n+                _ => die!(~\"llregtype: unhandled class\")\n             }\n             i += 1u;\n         }"}, {"sha": "833cff80d2ddb9d69f55a381e14962637168e064", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -383,7 +383,7 @@ pub fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n                     llfnty = T_ptr(struct_elt(llfnty, 0));\n                     new_llval = PointerCast(callee.bcx, fn_data.llfn, llfnty);\n                 }\n-                _ => fail\n+                _ => die!()\n             }\n             Callee { bcx: callee.bcx, data: Fn(FnData { llfn: new_llval }) }\n         },\n@@ -672,7 +672,8 @@ pub fn trans_arg_expr(bcx: block,\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                assert !bcx.ccx().maps.moves_map.contains_key(arg_expr.id);\n+                assert !bcx.ccx().maps.moves_map.contains_key_ref(\n+                    &arg_expr.id);\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n@@ -682,16 +683,16 @@ pub fn trans_arg_expr(bcx: block,\n                         // the explicit self code currently passes by-ref, it\n                         // does not hold.\n                         //\n-                        //assert !bcx.ccx().maps.moves_map.contains_key(\n-                        //    arg_expr.id);\n+                        //assert !bcx.ccx().maps.moves_map.contains_key_ref(\n+                        //    &arg_expr.id);\n                         val = arg_datum.to_ref_llval(bcx);\n                     }\n \n                     ast::by_val => {\n                         // NB: avoid running the take glue.\n \n-                        assert !bcx.ccx().maps.moves_map.contains_key(\n-                            arg_expr.id);\n+                        assert !bcx.ccx().maps.moves_map.contains_key_ref(\n+                            &arg_expr.id);\n                         val = arg_datum.to_value_llval(bcx);\n                     }\n "}, {"sha": "4cbf6a4f4b74a6abe875d934307a642b35a7f594", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -28,7 +28,7 @@ use middle::trans::type_of::*;\n use util::ppaux::ty_to_str;\n \n use core::libc::c_uint;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name};\n use syntax::ast_util;\n@@ -121,8 +121,8 @@ pub struct EnvValue {\n }\n \n pub impl EnvAction {\n-    fn to_str() -> ~str {\n-        match self {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n             EnvCopy => ~\"EnvCopy\",\n             EnvMove => ~\"EnvMove\",\n             EnvRef => ~\"EnvRef\""}, {"sha": "571f16e4b34ee6369bdf5e34c233b802893bc0dc", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -53,7 +53,7 @@ use core::str;\n use core::to_bytes;\n use core::vec::raw::to_ptr;\n use core::vec;\n-use std::map::{HashMap, Set};\n+use std::oldmap::{HashMap, Set};\n use syntax::ast::ident;\n use syntax::ast_map::path;\n use syntax::codemap::span;\n@@ -720,7 +720,7 @@ pub impl block {\n     fn ty_to_str(t: ty::t) -> ~str {\n         ty_to_str(self.tcx(), t)\n     }\n-    fn to_str() -> ~str {\n+    fn to_str(&self) -> ~str {\n         match self.node_info {\n           Some(node_info) => {\n             fmt!(\"[block %d]\", node_info.id)"}, {"sha": "b5652fed10e6dbbdadc1bb9070b4c4dfb4323275", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -126,7 +126,7 @@ pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n     if !ast_util::is_local(def_id) {\n         cx.tcx.sess.bug(~\"cross-crate constants\");\n     }\n-    if !cx.const_values.contains_key(def_id.node) {\n+    if !cx.const_values.contains_key_ref(&def_id.node) {\n         match cx.tcx.items.get(def_id.node) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_const(_, subexpr), _"}, {"sha": "240c323965faa4f8fd68521bac8dffbfb42f9f6b", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -183,8 +183,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     // XXX: Bad copy.\n     let modname = path_str(ccx.sess, copy modpath);\n \n-    // XXX: Bad copy.\n-    let global = if ccx.module_data.contains_key(copy modname) {\n+    let global = if ccx.module_data.contains_key_ref(&modname) {\n         ccx.module_data.get(modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq("}, {"sha": "554cebbbcb781fa1756430caaa212b6d1783d215", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -223,7 +223,7 @@ pub impl Datum {\n          * `id` is located in the move table, but copies otherwise.\n          */\n \n-        if bcx.ccx().maps.moves_map.contains_key(id) {\n+        if bcx.ccx().maps.moves_map.contains_key_ref(&id) {\n             self.move_to(bcx, action, dst)\n         } else {\n             self.copy_to(bcx, action, dst)\n@@ -841,7 +841,7 @@ pub impl DatumBlock {\n         self.bcx.tcx()\n     }\n \n-    fn to_str() -> ~str {\n+    fn to_str(&self) -> ~str {\n         self.datum.to_str(self.ccx())\n     }\n }"}, {"sha": "35abddfb85a515c5b47cd6787cd1d6cf552641be", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -26,8 +26,8 @@ use util::ppaux::ty_to_str;\n use core::libc;\n use core::option;\n use core::sys;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n use syntax::ast::Ty;\n use syntax::codemap::{span, CharPos};\n use syntax::parse::token::ident_interner;\n@@ -111,13 +111,13 @@ pub type debug_ctxt = {\n };\n \n pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n-    {llmetadata: map::HashMap(),\n+    {llmetadata: oldmap::HashMap(),\n      names: new_namegen(intr),\n      crate_file: crate}\n }\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n-    let existing = if cache.contains_key(mdtag) {\n+    let existing = if cache.contains_key_ref(&mdtag) {\n         cache.get(mdtag)\n     } else {\n         ~[]\n@@ -176,7 +176,7 @@ fn cached_metadata<T: Copy>(cache: metadata_cache,\n                             eq_fn: fn(md: T) -> bool)\n                          -> Option<T> {\n     unsafe {\n-        if cache.contains_key(mdtag) {\n+        if cache.contains_key_ref(&mdtag) {\n             let items = cache.get(mdtag);\n             for items.each |item| {\n                 let md: T = md_from_metadata::<T>(*item);\n@@ -268,7 +268,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     while cx.node_info.is_none() {\n         match cx.parent {\n           Some(b) => cx = b,\n-          None => fail\n+          None => die!()\n         }\n     }\n     let sp = cx.node_info.get().span;\n@@ -548,7 +548,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::Ty)\n      * elsewhere, not be self-contained.\n      */\n \n-    fail;\n+    die!();\n     /*\n     fn t_to_ty(cx: crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n         let ty = match ty::get(t).struct {\n@@ -664,7 +664,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         let name = match local.node.pat.node {\n           ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n           // FIXME this should be handled (#2533)\n-          _ => fail ~\"no single variable name for local\"\n+          _ => die!(~\"no single variable name for local\")\n         };\n         let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n         let ty = node_id_type(bcx, local.node.id);"}, {"sha": "4cf449cd972104e7a0413c9d6b321e7f3e98f2e1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -142,7 +142,7 @@ use util::ppaux::ty_to_str;\n \n use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n-use syntax::ast::spanned;\n+use syntax::codemap::spanned;\n \n // Destinations\n \n@@ -265,7 +265,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n }\n \n pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n-    if bcx.tcx().adjustments.contains_key(expr.id) {\n+    if bcx.tcx().adjustments.contains_key_ref(&expr.id) {\n         // use trans_to_datum, which is mildly less efficient but\n         // which will perform the adjustments:\n         let datumblock = trans_to_datum(bcx, expr);\n@@ -426,7 +426,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n         ast::expr_binary(op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n-            assert !bcx.ccx().maps.method_map.contains_key(expr.id);\n+            assert !bcx.ccx().maps.method_map.contains_key_ref(&expr.id);\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n@@ -468,9 +468,6 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         ast::expr_ret(ex) => {\n             return controlflow::trans_ret(bcx, ex);\n         }\n-        ast::expr_fail(why) => {\n-            return controlflow::trans_fail_expr(bcx, Some(expr.span), why);\n-        }\n         ast::expr_log(_, lvl, a) => {\n             return controlflow::trans_log(expr, lvl, bcx, a);\n         }\n@@ -552,7 +549,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_tup(ref args) => {\n             return trans_tup(bcx, *args, dest);\n         }\n-        ast::expr_lit(@ast::spanned {node: ast::lit_str(s), _}) => {\n+        ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n         ast::expr_vstore(contents, ast::expr_vstore_slice) |\n@@ -1246,7 +1243,7 @@ fn trans_unary_datum(bcx: block,\n     assert op != ast::deref;\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert !bcx.ccx().maps.method_map.contains_key(un_expr.id);\n+    assert !bcx.ccx().maps.method_map.contains_key_ref(&un_expr.id);\n \n     let un_ty = expr_ty(bcx, un_expr);\n     let sub_ty = expr_ty(bcx, sub_expr);"}, {"sha": "3d441dc973a2b5fd75c0e8c8b42963f1b8649fd9", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -500,7 +500,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n           if tp_sz != out_sz {\n               let sp = match ccx.tcx.items.get(ref_id.get()) {\n                   ast_map::node_expr(e) => e.span,\n-                  _ => fail ~\"reinterpret_cast or forget has non-expr arg\"\n+                  _ => die!(~\"reinterpret_cast or forget has non-expr arg\")\n               };\n               ccx.sess.span_fatal(\n                   sp, fmt!(\"reinterpret_cast called on types \\\n@@ -958,7 +958,7 @@ fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n       None => match ccx.tcx.items.get(i.id) {\n         ast_map::node_foreign_item(_, abi, _) => abi,\n         // ??\n-        _ => fail ~\"abi_of_foreign_fn: not foreign\"\n+        _ => die!(~\"abi_of_foreign_fn: not foreign\")\n       },\n       Some(_) => match attr::foreign_abi(i.attrs) {\n         either::Right(abi) => abi,"}, {"sha": "849a718a52e9c6268bb887eccbd20eb976403a14", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -380,7 +380,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(ty_visitor_name);\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n     let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n@@ -757,7 +757,7 @@ pub fn emit_tydescs(ccx: @crate_ctxt) {\n     let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;\n-    for ccx.tydescs.each |_key, val| {\n+    for ccx.tydescs.each_value_ref |&val| {\n         let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n         let ti = val;\n "}, {"sha": "1b3e13cddabffe17c4cc8c831e7930283e664606", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -178,7 +178,7 @@ pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n \n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key(t) { return cx.enum_sizes.get(t); }\n+    if cx.enum_sizes.contains_key_ref(&t) { return cx.enum_sizes.get(t); }\n     match ty::get(t).sty {\n       ty::ty_enum(tid, ref substs) => {\n         // Compute max(variant sizes)."}, {"sha": "f488c32437c73d0f8618a6f20198961feec4535d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -33,7 +33,7 @@ use middle::typeck;\n use util::ppaux::{ty_to_str, tys_to_str};\n \n use core::libc::c_uint;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast_map::{path, path_mod, path_name, node_id_to_str};\n use syntax::ast_util::local_def;\n use syntax::print::pprust::expr_to_str;\n@@ -253,7 +253,7 @@ pub fn trans_method_callee(bcx: block,\n                                                trait_id, off, vtbl)\n                 }\n                 // how to get rid of this?\n-                None => fail ~\"trans_method_callee: missing param_substs\"\n+                None => die!(~\"trans_method_callee: missing param_substs\")\n             }\n         }\n         typeck::method_trait(_, off, vstore) => {\n@@ -265,7 +265,8 @@ pub fn trans_method_callee(bcx: block,\n                                mentry.explicit_self)\n         }\n         typeck::method_self(*) | typeck::method_super(*) => {\n-            fail ~\"method_self or method_super should have been handled above\"\n+            die!(~\"method_self or method_super should have been handled \\\n+                above\")\n         }\n     }\n }\n@@ -311,13 +312,13 @@ pub fn trans_static_method_callee(bcx: block,\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(*trait_method).ident\n             }\n-            _ => fail ~\"callee is not a trait method\"\n+            _ => die!(~\"callee is not a trait method\")\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n         match path[path.len()-1] {\n             path_name(s) => { s }\n-            path_mod(_) => { fail ~\"path doesn't have a name?\" }\n+            path_mod(_) => { die!(~\"path doesn't have a name?\") }\n         }\n     };\n     debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n@@ -347,8 +348,8 @@ pub fn trans_static_method_callee(bcx: block,\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n-            fail ~\"vtable_param left in monomorphized \\\n-                   function's vtable substs\";\n+            die!(~\"vtable_param left in monomorphized \\\n+                   function's vtable substs\");\n         }\n     }\n }\n@@ -368,7 +369,7 @@ pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n             }, _) => {\n             method_from_methods(/*bad*/copy *ms, name).get()\n           }\n-          _ => fail ~\"method_with_name\"\n+          _ => die!(~\"method_with_name\")\n         }\n     } else {\n         csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n@@ -396,13 +397,13 @@ pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n                                   return pmi.method_info.did;\n                               }\n                           }\n-                          fail\n+                          die!()\n                       }\n-                      None => fail\n+                      None => die!()\n                   }\n               }\n           }\n-          _ => fail ~\"method_with_name\"\n+          _ => die!(~\"method_with_name\")\n         }\n     } else {\n         csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n@@ -421,14 +422,14 @@ pub fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n                         method_ty_param_count(\n                             ccx, source.method_id, source.impl_id)\n                     }\n-                    None => fail\n+                    None => die!()\n                 }\n             }\n             Some(ast_map::node_trait_method(@ast::provided(@ref m), _, _))\n                 => {\n                 m.tps.len()\n             }\n-            copy e => fail fmt!(\"method_ty_param_count %?\", e)\n+            copy e => die!(fmt!(\"method_ty_param_count %?\", e))\n         }\n     } else {\n         csearch::get_type_param_count(ccx.sess.cstore, m_id) -\n@@ -493,7 +494,8 @@ pub fn trans_monomorphized_callee(bcx: block,\n                              mentry.explicit_self)\n       }\n       typeck::vtable_param(*) => {\n-          fail ~\"vtable_param left in monomorphized function's vtable substs\";\n+          die!(~\"vtable_param left in monomorphized function's \" +\n+              \"vtable substs\");\n       }\n     };\n \n@@ -768,7 +770,7 @@ pub fn vtable_id(ccx: @crate_ctxt,\n             }\n         }\n         // can't this be checked at the callee?\n-        _ => fail ~\"vtable_id\"\n+        _ => die!(~\"vtable_id\")\n     }\n }\n \n@@ -783,7 +785,7 @@ pub fn get_vtable(ccx: @crate_ctxt,\n         typeck::vtable_static(id, substs, sub_vtables) => {\n             make_impl_vtable(ccx, id, substs, sub_vtables)\n         }\n-        _ => fail ~\"get_vtable: expected a static origin\"\n+        _ => die!(~\"get_vtable: expected a static origin\")\n       }\n     }\n }\n@@ -869,7 +871,7 @@ pub fn trans_trait_cast(bcx: block,\n     match vstore {\n         ty::vstore_slice(*) | ty::vstore_box => {\n             let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n-            if bcx.tcx().legacy_boxed_traits.contains_key(id) {\n+            if bcx.tcx().legacy_boxed_traits.contains_key_ref(&id) {\n                 // Allocate an @ box and store the value into it\n                 let {bcx: new_bcx, box: llbox, body: body} =\n                     malloc_boxed(bcx, v_ty);"}, {"sha": "02e07e8484abd79f5fa59ceeb08438935569098f", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,7 +22,7 @@ use middle::ty;\n use middle::typeck;\n \n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::def_id_of_def;\n use syntax::attr;\n@@ -95,7 +95,7 @@ fn traverse_public_mod(cx: ctx, mod_id: node_id, m: _mod) {\n }\n \n fn traverse_public_item(cx: ctx, item: @item) {\n-    if cx.rmap.contains_key(item.id) { return; }\n+    if cx.rmap.contains_key_ref(&item.id) { return; }\n     cx.rmap.insert(item.id, ());\n     match /*bad*/copy item.node {\n       item_mod(m) => traverse_public_mod(cx, item.id, m),\n@@ -135,7 +135,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       }\n       item_const(*) |\n       item_enum(*) | item_trait(*) => (),\n-      item_mac(*) => fail ~\"item macros unimplemented\"\n+      item_mac(*) => die!(~\"item macros unimplemented\")\n     }\n }\n \n@@ -145,7 +145,7 @@ fn mk_ty_visitor() -> visit::vt<ctx> {\n }\n \n fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n-    if cx.rmap.contains_key(ty.id) { return; }\n+    if cx.rmap.contains_key_ref(&ty.id) { return; }\n     cx.rmap.insert(ty.id, ());\n \n     match ty.node {\n@@ -223,7 +223,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n \n fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n     visit::visit_mod(\n-        crate_mod, ast_util::dummy_sp(), 0, cx,\n+        crate_mod, codemap::dummy_sp(), 0, cx,\n         visit::mk_vt(@visit::Visitor {\n             visit_expr: |_e, _cx, _v| { },\n             visit_item: |i, cx, v| {"}, {"sha": "b9a055ad8ab23e02ed57702c110bedb47743b449", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -24,7 +24,7 @@ use middle::trans::meth;\n use middle::trans::type_of::*;\n use util::ppaux::ty_to_str;\n \n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::def_id;\n use syntax::ast;\n \n@@ -316,7 +316,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n                                  -> block {\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(tydesc);\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&tydesc);\n     let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(tydesc);\n     let tydesc_ty = type_of::type_of(bcx.ccx(), tydesc_ty);\n     let r = reflector({"}, {"sha": "4f0e59b723ec4507d172e0e4958abb6635573b51", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -26,9 +26,9 @@ use util::ppaux::ty_to_str;\n use core::dvec::DVec;\n use core::option::is_some;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n use syntax::codemap::span;\n use syntax::util::interner;\n "}, {"sha": "e103ae1559325a0319541c19fba8f386a304ab2a", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -201,7 +201,7 @@ pub fn trans_slice_vstore(bcx: block,\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n-        ast::expr_lit(@ast::spanned {node: ast::lit_str(s), span: _}) => {\n+        ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), span: _}) => {\n             return trans_lit_str(bcx, content_expr, s, dest);\n         }\n         _ => {}\n@@ -296,7 +296,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n     match heap {\n         heap_exchange => {\n             match content_expr.node {\n-                ast::expr_lit(@ast::spanned {\n+                ast::expr_lit(@codemap::spanned {\n                     node: ast::lit_str(s), _\n                 }) => {\n                     let llptrval = C_cstr(bcx.ccx(), copy *s);\n@@ -354,7 +354,7 @@ pub fn write_content(bcx: block,\n     let _indenter = indenter();\n \n     match /*bad*/copy content_expr.node {\n-        ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n+        ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             match dest {\n                 Ignore => {\n                     return bcx;\n@@ -461,7 +461,7 @@ pub fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match /*bad*/copy content_expr.node {\n-        ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n+        ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             s.len() + 1\n         },\n         ast::expr_vec(es, _) => es.len(),"}, {"sha": "72efab0c371c4eecfdbecbbfb0d4d5c3b0558f23", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -17,7 +17,7 @@ use middle::trans::expr;\n use middle::trans::machine;\n use util::ppaux;\n \n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n \n pub fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n@@ -87,7 +87,7 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n-    if cx.lltypes.contains_key(t) { return cx.lltypes.get(t); }\n+    if cx.lltypes.contains_key_ref(&t) { return cx.lltypes.get(t); }\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain"}, {"sha": "350b1393c33336b90291ab222dfbfff38cb7de12", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -38,7 +38,7 @@ use core::uint;\n use core::vec;\n use std::list::{List, Cons, Nil};\n use std::list;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::*;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -147,7 +147,7 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                 ~\"bswap16\" | ~\"bswap32\" | ~\"bswap64\" => 0,\n \n                 // would be cool to make these an enum instead of strings!\n-                _ => fail ~\"unknown intrinsic in type_use\"\n+                _ => die!(~\"unknown intrinsic in type_use\")\n             };\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }\n@@ -340,7 +340,7 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n       }\n       expr_paren(e) => mark_for_expr(cx, e),\n       expr_match(*) | expr_block(_) | expr_if(*) |\n-      expr_while(*) | expr_fail(_) | expr_break(_) | expr_again(_) |\n+      expr_while(*) | expr_break(_) | expr_again(_) |\n       expr_unary(_, _) | expr_lit(_) | expr_assert(_) |\n       expr_mac(_) | expr_addr_of(_, _) |\n       expr_ret(_) | expr_loop(_, _) |"}, {"sha": "8610e3c85d7f53891b340b95dd6f438c89b2ca6b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -41,12 +41,13 @@ use core::result;\n use core::to_bytes;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n-use std::{map, smallintmap};\n+use std::oldmap::HashMap;\n+use std::{oldmap, oldsmallintmap};\n use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};\n use syntax::ast_util;\n use syntax::codemap::span;\n+use syntax::codemap;\n use syntax::print::pprust;\n use syntax::{ast, ast_map};\n use syntax;\n@@ -666,43 +667,43 @@ pub impl TyVid: Vid {\n }\n \n pub impl TyVid: ToStr {\n-    pure fn to_str() -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n pub impl IntVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n \n pub impl IntVid: ToStr {\n-    pure fn to_str() -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n pub impl FloatVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n \n pub impl FloatVid: ToStr {\n-    pure fn to_str() -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n pub impl RegionVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n \n pub impl RegionVid: ToStr {\n-    pure fn to_str() -> ~str { fmt!(\"%?\", self) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"%?\", self) }\n }\n \n pub impl FnSig : ToStr {\n-    pure fn to_str() -> ~str {\n+    pure fn to_str(&self) -> ~str {\n         // grr, without tcx not much we can do.\n         return ~\"(...)\";\n     }\n }\n \n pub impl InferTy: ToStr {\n-    pure fn to_str() -> ~str {\n-        match self {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n             TyVar(ref v) => v.to_str(),\n             IntVar(ref v) => v.to_str(),\n             FloatVar(ref v) => v.to_str()\n@@ -711,8 +712,8 @@ pub impl InferTy: ToStr {\n }\n \n pub impl IntVarValue : ToStr {\n-    pure fn to_str() -> ~str {\n-        match self {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n             IntType(ref v) => v.to_str(),\n             UintType(ref v) => v.to_str(),\n         }\n@@ -785,15 +786,15 @@ type type_cache = HashMap<ast::def_id, ty_param_bounds_and_ty>;\n \n type constness_cache = HashMap<ast::def_id, const_eval::constness>;\n \n-pub type node_type_table = @smallintmap::SmallIntMap<t>;\n+pub type node_type_table = @oldsmallintmap::SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n-    return map::HashMap();\n+    return oldmap::HashMap();\n }\n \n-pub fn new_ty_hash<V: Copy>() -> map::HashMap<t, V> {\n-    map::HashMap()\n+pub fn new_ty_hash<V: Copy>() -> oldmap::HashMap<t, V> {\n+    oldmap::HashMap()\n }\n \n pub fn mk_ctxt(s: session::Session,\n@@ -821,7 +822,7 @@ pub fn mk_ctxt(s: session::Session,\n         }\n     }\n \n-    let interner = map::HashMap();\n+    let interner = oldmap::HashMap();\n     let vecs_implicitly_copyable =\n         get_lint_level(s.lint_settings.default_settings,\n                        lint::vecs_implicitly_copyable) == allow;\n@@ -837,10 +838,10 @@ pub fn mk_ctxt(s: session::Session,\n         def_map: dm,\n         region_map: region_map,\n         region_paramd_items: region_paramd_items,\n-        node_types: @smallintmap::mk(),\n-        node_type_substs: map::HashMap(),\n+        node_types: @oldsmallintmap::mk(),\n+        node_type_substs: oldmap::HashMap(),\n         items: amap,\n-        intrinsic_defs: map::HashMap(),\n+        intrinsic_defs: oldmap::HashMap(),\n         freevars: freevars,\n         tcache: HashMap(),\n         rcache: mk_rcache(),\n@@ -1568,7 +1569,7 @@ pub fn get_element_type(ty: t, i: uint) -> t {\n     match /*bad*/copy get(ty).sty {\n       ty_rec(flds) => return flds[i].mt.ty,\n       ty_tup(ts) => return ts[i],\n-      _ => fail ~\"get_element_type called on invalid type\"\n+      _ => die!(~\"get_element_type called on invalid type\")\n     }\n }\n \n@@ -1744,7 +1745,7 @@ pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n-                              tycache: map::HashMap<t, ()>,\n+                              tycache: oldmap::HashMap<t, ()>,\n                               encountered_box: bool) -> bool {\n \n     // Prevent infinite recursion\n@@ -2794,12 +2795,12 @@ impl sty : to_bytes::IterBytes {\n }\n \n pub fn br_hashmap<V:Copy>() -> HashMap<bound_region, V> {\n-    map::HashMap()\n+    oldmap::HashMap()\n }\n \n pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n-    //io::println(fmt!(\"%?/%?\", id, cx.node_types.size()));\n-    match smallintmap::find(*cx.node_types, id as uint) {\n+    //io::println(fmt!(\"%?/%?\", id, cx.node_types.len()));\n+    match oldsmallintmap::find(*cx.node_types, id as uint) {\n        Some(t) => t,\n        None => cx.sess.bug(\n            fmt!(\"node_id_to_type: no type for node `%s`\",\n@@ -2816,35 +2817,35 @@ pub fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n }\n \n fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n-    return cx.node_type_substs.contains_key(id);\n+    return cx.node_type_substs.contains_key_ref(&id);\n }\n \n // Type accessors for substructures of types\n pub fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).sty {\n       ty_fn(ref f) => /*bad*/copy f.sig.inputs,\n-      _ => fail ~\"ty_fn_args() called on non-fn type\"\n+      _ => die!(~\"ty_fn_args() called on non-fn type\")\n     }\n }\n \n pub fn ty_fn_proto(fty: t) -> Proto {\n     match get(fty).sty {\n       ty_fn(ref f) => f.meta.proto,\n-      _ => fail ~\"ty_fn_proto() called on non-fn type\"\n+      _ => die!(~\"ty_fn_proto() called on non-fn type\")\n     }\n }\n \n pub fn ty_fn_purity(fty: t) -> ast::purity {\n     match get(fty).sty {\n       ty_fn(ref f) => f.meta.purity,\n-      _ => fail ~\"ty_fn_purity() called on non-fn type\"\n+      _ => die!(~\"ty_fn_purity() called on non-fn type\")\n     }\n }\n \n pub pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n         ty_fn(ref f) => f.sig.output,\n-        _ => fail ~\"ty_fn_ret() called on non-fn type\"\n+        _ => die!(~\"ty_fn_ret() called on non-fn type\")\n     }\n }\n \n@@ -2859,7 +2860,7 @@ pub pure fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n         ty_evec(_, vstore) => vstore,\n         ty_estr(vstore) => vstore,\n-        ref s => fail fmt!(\"ty_vstore() called on invalid sty: %?\", s)\n+        ref s => die!(fmt!(\"ty_vstore() called on invalid sty: %?\", s))\n     }\n }\n \n@@ -2868,7 +2869,8 @@ pub fn ty_region(ty: t) -> Region {\n       ty_rptr(r, _) => r,\n       ty_evec(_, vstore_slice(r)) => r,\n       ty_estr(vstore_slice(r)) => r,\n-      ref s => fail fmt!(\"ty_region() invoked on in appropriate ty: %?\", (*s))\n+      ref s => die!(fmt!(\"ty_region() invoked on in appropriate ty: %?\",\n+          (*s)))\n     }\n }\n \n@@ -3112,7 +3114,7 @@ pub enum ExprKind {\n pub fn expr_kind(tcx: ctxt,\n                  method_map: typeck::method_map,\n                  expr: @ast::expr) -> ExprKind {\n-    if method_map.contains_key(expr.id) {\n+    if method_map.contains_key_ref(&expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n         // exception, as its result is always unit.\n@@ -3166,7 +3168,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_block(*) |\n         ast::expr_copy(*) |\n         ast::expr_repeat(*) |\n-        ast::expr_lit(@ast::spanned {node: lit_str(_), _}) |\n+        ast::expr_lit(@codemap::spanned {node: lit_str(_), _}) |\n         ast::expr_vstore(_, ast::expr_vstore_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_mut_slice) |\n         ast::expr_vstore(_, ast::expr_vstore_fixed(_)) |\n@@ -3175,7 +3177,7 @@ pub fn expr_kind(tcx: ctxt,\n         }\n \n         ast::expr_cast(*) => {\n-            match smallintmap::find(*tcx.node_types, expr.id as uint) {\n+            match oldsmallintmap::find(*tcx.node_types, expr.id as uint) {\n                 Some(t) => {\n                     if ty::type_is_immediate(t) {\n                         RvalueDatumExpr\n@@ -3204,7 +3206,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_again(*) |\n         ast::expr_ret(*) |\n         ast::expr_log(*) |\n-        ast::expr_fail(*) |\n         ast::expr_assert(*) |\n         ast::expr_while(*) |\n         ast::expr_loop(*) |\n@@ -3239,7 +3240,7 @@ pub fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n       ast::stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) => {\n         return id;\n       }\n-      ast::stmt_mac(*) => fail ~\"unexpanded macro in trans\"\n+      ast::stmt_mac(*) => die!(~\"unexpanded macro in trans\")\n     }\n }\n \n@@ -3263,7 +3264,7 @@ pub fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n     match vec::find(get_fields(rec_ty), |f| f.ident == id) {\n       Some(f) => f,\n       // Do we only call this when we know the field is legit?\n-      None => fail (fmt!(\"get_field: ty doesn't have a field %s\",\n+      None => die!(fmt!(\"get_field: ty doesn't have a field %s\",\n                          tcx.sess.str_of(id)))\n     }\n }\n@@ -3272,7 +3273,7 @@ pub fn get_fields(rec_ty:t) -> ~[field] {\n     match /*bad*/copy get(rec_ty).sty {\n       ty_rec(fields) => fields,\n       // Can we check at the caller?\n-      _ => fail ~\"get_fields: not a record type\"\n+      _ => die!(~\"get_fields: not a record type\")\n     }\n }\n \n@@ -3929,10 +3930,10 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                          }\n                     }\n                     ast::struct_variant_kind(_) => {\n-                        fail ~\"struct variant kinds unimpl in enum_variants\"\n+                        die!(~\"struct variant kinds unimpl in enum_variants\")\n                     }\n                     ast::enum_variant_kind(_) => {\n-                        fail ~\"enum variant kinds unimpl in enum_variants\"\n+                        die!(~\"enum variant kinds unimpl in enum_variants\")\n                     }\n                 }\n             })\n@@ -4358,7 +4359,7 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n         if f(trait_ty) {\n             // Add all the supertraits to the hash map,\n             // executing <f> on each of them\n-            while i < supertrait_map.size() && !fin {\n+            while i < supertrait_map.len() && !fin {\n                 let init_trait_id = seen_def_ids[i];\n                 i += 1;\n                  // Add supertraits to supertrait_map\n@@ -4367,7 +4368,7 @@ pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n                     let super_t = supertrait.tpt.ty;\n                     let d_id = ty_to_def_id(super_t).expect(\"supertrait \\\n                         should be a trait ty\");\n-                    if !supertrait_map.contains_key(d_id) {\n+                    if !supertrait_map.contains_key_ref(&d_id) {\n                         supertrait_map.insert(d_id, super_t);\n                         trait_ty = super_t;\n                         seen_def_ids.push(d_id);"}, {"sha": "3e898ce3aa676742c8887104e13c6e0987733304", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,7 +20,7 @@ use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::require_same_types;\n \n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast_util::walk_pat;\n use syntax::ast_util;\n@@ -239,7 +239,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     // Report an error if not all the fields were specified.\n     if !etc {\n         for class_fields.eachi |i, field| {\n-            if found_fields.contains_key(i) {\n+            if found_fields.contains_key_ref(&i) {\n                 loop;\n             }\n             tcx.sess.span_err(span,"}, {"sha": "5a12f9fc3a1968e567b03928cba730c3dc4fc418", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -101,14 +101,14 @@ use core::dvec::DVec;\n use core::result;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast::{def_id, sty_by_ref, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, node_id, by_copy, by_ref};\n use syntax::ast::{m_const, m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_map::node_id_to_str;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n use syntax::codemap::span;\n \n pub fn lookup(\n@@ -1171,11 +1171,12 @@ pub impl LookupContext {\n         match candidate.origin {\n             method_static(method_id) | method_self(method_id, _)\n                 | method_super(method_id, _) => {\n-                bad = self.tcx().destructors.contains_key(method_id);\n+                bad = self.tcx().destructors.contains_key_ref(&method_id);\n             }\n             method_param(method_param { trait_id: trait_id, _ }) |\n             method_trait(trait_id, _, _) => {\n-                bad = self.tcx().destructor_for_type.contains_key(trait_id);\n+                bad = self.tcx().destructor_for_type.contains_key_ref(\n+                    &trait_id);\n             }\n         }\n \n@@ -1233,7 +1234,7 @@ pub impl LookupContext {\n         let span = if did.crate == ast::local_crate {\n             match self.tcx().items.find(did.node) {\n               Some(ast_map::node_method(m, _, _)) => m.span,\n-              _ => fail fmt!(\"report_static_candidate: bad item %?\", did)\n+              _ => die!(fmt!(\"report_static_candidate: bad item %?\", did))\n             }\n         } else {\n             self.expr.span"}, {"sha": "f3abfe3282a3131a53bab4ea1e554b6e2c667895", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -115,15 +115,15 @@ use core::result;\n use core::str;\n use core::vec;\n use std::list::Nil;\n-use std::map::HashMap;\n-use std::map;\n-use syntax::ast::{provided, required, spanned, ty_i};\n+use std::oldmap::HashMap;\n+use std::oldmap;\n+use syntax::ast::{provided, required, ty_i};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{Private, Public, is_local, local_def, respan};\n+use syntax::ast_util::{Private, Public, is_local, local_def};\n use syntax::ast_util::{visibility_to_privacy};\n use syntax::ast_util;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, spanned, respan};\n use syntax::codemap;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n@@ -209,9 +209,9 @@ pub fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n     @inherited {\n         infcx: infer::new_infer_ctxt(ccx.tcx),\n         locals: HashMap(),\n-        node_types: map::HashMap(),\n-        node_type_substs: map::HashMap(),\n-        adjustments: map::HashMap()\n+        node_types: oldmap::HashMap(),\n+        node_type_substs: oldmap::HashMap(),\n+        adjustments: oldmap::HashMap()\n     }\n }\n \n@@ -528,7 +528,7 @@ pub fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                         def_id: local_def(id),\n                         explicit_self:\n                             spanned { node: ast::sty_by_ref,\n-                                      span: ast_util::dummy_sp() } };\n+                                      span: codemap::dummy_sp() } };\n         // typecheck the dtor\n         let dtor_dec = ast_util::dtor_dec();\n         check_bare_fn(ccx, &dtor_dec,\n@@ -1919,7 +1919,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     match /*bad*/copy expr.node {\n       ast::expr_vstore(ev, vst) => {\n         let typ = match /*bad*/copy ev.node {\n-          ast::expr_lit(@ast::spanned { node: ast::lit_str(s), _ }) => {\n+          ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n             ty::mk_estr(tcx, tt)\n           }\n@@ -2087,17 +2087,6 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         instantiate_path(fcx, pth, tpt, expr.span, expr.id, region_lb);\n       }\n       ast::expr_mac(_) => tcx.sess.bug(~\"unexpanded macro\"),\n-      ast::expr_fail(expr_opt) => {\n-        bot = true;\n-        match expr_opt {\n-          None => {/* do nothing */ }\n-          Some(e) => {\n-            check_expr_has_type(\n-                fcx, e, ty::mk_estr(tcx, ty::vstore_uniq));\n-          }\n-        }\n-        fcx.write_bot(id);\n-      }\n       ast::expr_break(_) => { fcx.write_bot(id); bot = true; }\n       ast::expr_again(_) => { fcx.write_bot(id); bot = true; }\n       ast::expr_ret(expr_opt) => {\n@@ -2247,7 +2236,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n                 }\n                 // argh\n-                _ => fail ~\"expr_fn_block\"\n+                _ => die!(~\"expr_fn_block\")\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n@@ -2287,7 +2276,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n           }\n           // argh\n-          _ => fail ~\"expected fn ty\"\n+          _ => die!(~\"expected fn ty\")\n         }\n         fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n@@ -2608,7 +2597,7 @@ pub fn check_block_with_expected(fcx0: @fn_ctxt,\n         for blk.node.stmts.each |s| {\n             if bot && !warned &&\n                 match s.node {\n-                  ast::stmt_decl(@ast::spanned { node: ast::decl_local(_),\n+                  ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                                  _}, _) |\n                   ast::stmt_expr(_, _) | ast::stmt_semi(_, _) => {\n                     true\n@@ -3089,8 +3078,8 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n           let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n-          assert tcx.intrinsic_defs.contains_key(tydesc_name);\n-          assert ccx.tcx.intrinsic_defs.contains_key(ty_visitor_name);\n+          assert tcx.intrinsic_defs.contains_key_ref(&tydesc_name);\n+          assert ccx.tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get(tydesc_name);\n           let (_, visitor_trait) = tcx.intrinsic_defs.get(ty_visitor_name);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,"}, {"sha": "9ae55d4556b15bc1b99d691de168a25e2efb160e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -211,7 +211,7 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n             // `constrain_auto_ref()` on all exprs.  But that causes a\n             // lot of spurious errors because of how the region\n             // hierarchy is setup.\n-            if rcx.fcx.ccx.method_map.contains_key(callee.id) {\n+            if rcx.fcx.ccx.method_map.contains_key_ref(&callee.id) {\n                 match callee.node {\n                     ast::expr_field(base, _, _) => {\n                         constrain_auto_ref(rcx, base);\n@@ -689,7 +689,6 @@ pub mod guarantor {\n             ast::expr_again(*) |\n             ast::expr_ret(*) |\n             ast::expr_log(*) |\n-            ast::expr_fail(*) |\n             ast::expr_assert(*) |\n             ast::expr_while(*) |\n             ast::expr_loop(*) |\n@@ -751,7 +750,7 @@ pub mod guarantor {\n         let _i = ::util::common::indenter();\n \n         let guarantor = {\n-            if rcx.fcx.ccx.method_map.contains_key(expr.id) {\n+            if rcx.fcx.ccx.method_map.contains_key_ref(&expr.id) {\n                 None\n             } else {\n                 guarantor(rcx, expr)"}, {"sha": "8ea35824e32a1ccfb136fc747f45119057f749da", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,6 +22,7 @@ use util::ppaux;\n \n use std::list::Cons;\n use syntax::ast;\n+use syntax::codemap;\n use syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n@@ -57,7 +58,7 @@ pub fn replace_bound_regions_in_fn_sig(\n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n     match self_info {\n-      Some({explicit_self: ast::spanned { node: ast::sty_region(m),\n+      Some({explicit_self: codemap::spanned { node: ast::sty_region(m),\n                                           _}, _}) => {\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,"}, {"sha": "18a4f20d031b5be7bbe5ccd6360394287f8d4166", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -28,7 +28,7 @@ use core::result;\n use core::uint;\n use core::vec;\n use result::{Result, Ok, Err};\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n@@ -148,7 +148,7 @@ pub fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n           ty::ty_trait(_, ref substs_f, _) => (/*bad*/copy *substs_f),\n-          _ => fail ~\"t_f should be a trait\"\n+          _ => die!(~\"t_f should be a trait\")\n         }\n     }\n }\n@@ -268,7 +268,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                         // im is one specific impl of trait_ty.\n \n                         // First, ensure we haven't processed this impl yet.\n-                        if impls_seen.contains_key(im.did) {\n+                        if impls_seen.contains_key_ref(&im.did) {\n                             loop;\n                         }\n                         impls_seen.insert(im.did, ());"}, {"sha": "64ea45c8704001cf44747ddf56a35dc698c007e4", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -28,7 +28,7 @@ use util::ppaux;\n \n use core::result::{Result, Ok, Err};\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n@@ -141,7 +141,7 @@ fn maybe_resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span,\n                                     id: ast::node_id)\n     -> Option<ty::t>\n {\n-    if wbcx.fcx.inh.node_types.contains_key(id) {\n+    if wbcx.fcx.inh.node_types.contains_key_ref(&id) {\n         resolve_type_vars_for_node(wbcx, sp, id)\n     } else {\n         None"}, {"sha": "5ad8fd4c8208ce311fcb37619759f493743ef2e8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -46,9 +46,9 @@ use syntax::ast::{trait_ref};\n use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, dummy_sp, local_def};\n+use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::attr;\n-use syntax::codemap::span;\n+use syntax::codemap::{span, dummy_sp};\n use syntax::parse;\n use syntax::visit::{default_simple_visitor, default_visitor};\n use syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n@@ -63,7 +63,7 @@ use core::uint::range;\n use core::uint;\n use core::vec::{len, push};\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub struct UniversalQuantificationResult {\n     monotype: t,\n@@ -135,8 +135,8 @@ pub fn get_base_type_def_id(inference_context: @InferCtxt,\n                     return Some(def_id);\n                 }\n                 _ => {\n-                    fail ~\"get_base_type() returned a type that wasn't an \\\n-                           enum, class, or trait\";\n+                    die!(~\"get_base_type() returned a type that wasn't an \\\n+                           enum, class, or trait\");\n                 }\n             }\n         }\n@@ -417,7 +417,7 @@ pub impl CoherenceChecker {\n         let coherence_info = &self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n-        for extension_methods.each_key |trait_id| {\n+        for extension_methods.each_key_ref |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n@@ -502,7 +502,7 @@ pub impl CoherenceChecker {\n         }\n \n         for ty::trait_methods(tcx, trait_did).each |method| {\n-            if provided_method_idents.contains_key(method.ident) {\n+            if provided_method_idents.contains_key_ref(&method.ident) {\n                 if !f(method) {\n                     break;\n                 }\n@@ -912,7 +912,7 @@ pub impl CoherenceChecker {\n         let tcx = self.crate_context.tcx;\n         let pmm = tcx.provided_methods;\n \n-        if pmm.contains_key(trait_def_id) { return; }\n+        if pmm.contains_key_ref(&trait_def_id) { return; }\n \n         debug!(\"(adding default methods for trait) processing trait\");\n "}, {"sha": "32d924891886aac8fe29d8304b0766a755883a87", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -326,7 +326,7 @@ pub fn ensure_supertraits(ccx: @crate_ctxt,\n                           rp: Option<ty::region_variance>,\n                           trait_refs: &[@ast::trait_ref]) {\n     let tcx = ccx.tcx;\n-    if tcx.supertraits.contains_key(local_def(id)) { return; }\n+    if tcx.supertraits.contains_key_ref(&local_def(id)) { return; }\n \n     let instantiated = dvec::DVec();\n     for trait_refs.each |trait_ref| {\n@@ -913,8 +913,8 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n           return tpt;\n       }\n       ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_foreign_mod(_) => fail,\n-      ast::item_mac(*) => fail ~\"item macros unimplemented\"\n+      ast::item_foreign_mod(_) => die!(),\n+      ast::item_mac(*) => die!(~\"item macros unimplemented\")\n     }\n }\n "}, {"sha": "6140390a24e127f5ea05587ebac98510a4bdb09e", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -280,13 +280,14 @@ use core::result::{Result, Ok, Err, map_vec, map_vec2, iter_vec2};\n use core::result;\n use core::vec;\n use std::list::Nil;\n-use std::map::HashMap;\n-use std::smallintmap;\n+use std::oldmap::HashMap;\n+use std::oldsmallintmap;\n use syntax::ast::{ret_style, purity};\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn, impure_fn, pure_fn, extern_fn};\n use syntax::ast;\n-use syntax::ast_util::dummy_sp;\n+use syntax::codemap::dummy_sp;\n+use syntax::codemap;\n use syntax::ast_util;\n use syntax::codemap::span;\n \n@@ -353,7 +354,7 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n \n fn new_ValsAndBindings<V:Copy, T:Copy>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n-        vals: smallintmap::mk(),\n+        vals: oldsmallintmap::mk(),\n         mut bindings: ~[]\n     }\n }\n@@ -389,7 +390,7 @@ pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            cx.sub(true, ast_util::dummy_sp()).tys(a, b)\n+            cx.sub(true, codemap::dummy_sp()).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -429,7 +430,7 @@ pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            let span = ast_util::dummy_sp();\n+            let span = codemap::dummy_sp();\n             Coerce(cx.combine_fields(true, span)).tys(a, b)\n         }\n     }.to_ures()"}, {"sha": "1a8e25239b34a28f40b4ccdb6ecf917ed7688e72", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -559,7 +559,7 @@ use core::uint;\n use core::vec;\n use result::Result;\n use result::{Ok, Err};\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std::cell::{Cell, empty_cell};\n use std::list::{List, Nil, Cons};\n use syntax::codemap::span;\n@@ -712,11 +712,11 @@ pub impl RegionVarBindings {\n                 assert self.var_spans.len() == *vid + 1;\n                 self.var_spans.pop();\n               }\n-              AddConstraint(constraint) => {\n+              AddConstraint(ref constraint) => {\n                 self.constraints.remove(constraint);\n               }\n               AddCombination(map, ref regions) => {\n-                map.remove((*regions));\n+                map.remove(regions);\n               }\n             }\n         }\n@@ -1226,7 +1226,7 @@ impl RegionVarBindings {\n \n     fn construct_graph(&self) -> Graph {\n         let num_vars = self.num_vars();\n-        let num_edges = self.constraints.size();\n+        let num_edges = self.constraints.len();\n \n         let nodes = vec::from_fn(num_vars, |var_idx| {\n             GraphNode {"}, {"sha": "416dcbcd30a1b9dddcb152d0c333a1b66959b19c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -30,8 +30,8 @@ use std::getopts::groups;\n use std::getopts::{opt_present};\n use std::getopts;\n use std::getopts;\n-use std::map::HashMap;\n-use syntax::ast_util::dummy_sp;\n+use std::oldmap::HashMap;\n+use syntax::codemap::dummy_sp;\n use syntax::parse::parse_crate_from_source_str;\n use syntax::{ast, attr, parse};\n \n@@ -102,7 +102,7 @@ impl Env {\n         return match search_mod(self, &self.crate.node.module, 0, names) {\n             Some(id) => id,\n             None => {\n-                fail fmt!(\"No item found: `%s`\", str::connect(names, \"::\"));\n+                die!(fmt!(\"No item found: `%s`\", str::connect(names, \"::\")));\n             }\n         };\n \n@@ -155,17 +155,17 @@ impl Env {\n \n     fn assert_subtype(&self, a: ty::t, b: ty::t) {\n         if !self.is_subtype(a, b) {\n-            fail fmt!(\"%s is not a subtype of %s, but it should be\",\n+            die!(fmt!(\"%s is not a subtype of %s, but it should be\",\n                       self.ty_to_str(a),\n-                      self.ty_to_str(b));\n+                      self.ty_to_str(b)));\n         }\n     }\n \n     fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n         if self.is_subtype(a, b) {\n-            fail fmt!(\"%s is a subtype of %s, but it shouldn't be\",\n+            die!(fmt!(\"%s is a subtype of %s, but it shouldn't be\",\n                       self.ty_to_str(a),\n-                      self.ty_to_str(b));\n+                      self.ty_to_str(b)));\n         }\n     }\n \n@@ -240,7 +240,7 @@ impl Env {\n     fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n         match self.lub().tys(t1, t2) {\n             Err(e) => {\n-                fail fmt!(\"Unexpected error computing LUB: %?\", e)\n+                die!(fmt!(\"Unexpected error computing LUB: %?\", e))\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n@@ -262,7 +262,7 @@ impl Env {\n                self.ty_to_str(t_glb));\n         match self.glb().tys(t1, t2) {\n             Err(e) => {\n-                fail fmt!(\"Unexpected error computing LUB: %?\", e)\n+                die!(fmt!(\"Unexpected error computing LUB: %?\", e))\n             }\n             Ok(t) => {\n                 self.assert_eq(t, t_glb);\n@@ -281,8 +281,8 @@ impl Env {\n         match self.lub().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail fmt!(\"Unexpected success computing LUB: %?\",\n-                          self.ty_to_str(t))\n+                die!(fmt!(\"Unexpected success computing LUB: %?\",\n+                          self.ty_to_str(t)))\n             }\n         }\n     }\n@@ -292,8 +292,8 @@ impl Env {\n         match self.glb().tys(t1, t2) {\n             Err(_) => {}\n             Ok(t) => {\n-                fail fmt!(\"Unexpected success computing GLB: %?\",\n-                          self.ty_to_str(t))\n+                die!(fmt!(\"Unexpected success computing GLB: %?\",\n+                          self.ty_to_str(t)))\n             }\n         }\n     }"}, {"sha": "57e05926173d1a0f57331c09f02494e515ad431b", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -88,7 +88,7 @@ pub impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n         match *self {\n           Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n           Root(ref pt, rk) => fmt!(\"Root(%s, %s)\", pt.inf_str(cx),\n-                               uint::to_str(rk, 10u))\n+                               uint::to_str_radix(rk, 10u))\n         }\n     }\n }"}, {"sha": "3b38197c51c449f06f27e5d5ed1e820895a37560", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n use core::result;\n-use std::smallintmap::SmallIntMap;\n+use std::oldsmallintmap::SmallIntMap;\n \n use middle::ty::{Vid, expected_found, IntVarValue};\n use middle::ty;"}, {"sha": "d292f04caa4066d23eb68f25b8758c85045d9415", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -67,13 +67,13 @@ use core::result;\n use core::vec;\n use std::list::{List, Nil, Cons};\n use std::list;\n-use std::map::HashMap;\n-use std::map;\n-use std::smallintmap;\n-use syntax::ast::{provided, required, spanned};\n+use std::oldmap::HashMap;\n+use std::oldmap;\n+use std::oldsmallintmap;\n+use syntax::ast::{provided, required};\n use syntax::ast_map::node_id_to_str;\n-use syntax::ast_util::{local_def, respan, split_trait_methods};\n-use syntax::codemap::span;\n+use syntax::ast_util::{local_def, split_trait_methods};\n+use syntax::codemap::{span, spanned, respan};\n use syntax::print::pprust::*;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};\n@@ -212,7 +212,7 @@ pub enum crate_ctxt {\n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n-    smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n+    oldsmallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n pub fn write_substs_to_tcx(tcx: ty::ctxt,\n                            node_id: ast::node_id,\n@@ -377,8 +377,8 @@ pub fn check_crate(tcx: ty::ctxt,\n \n     let ccx = @crate_ctxt_(crate_ctxt__ {\n         trait_map: trait_map,\n-        method_map: map::HashMap(),\n-        vtable_map: map::HashMap(),\n+        method_map: oldmap::HashMap(),\n+        vtable_map: oldmap::HashMap(),\n         coherence_info: @coherence::CoherenceInfo(),\n         tcx: tcx\n     });"}, {"sha": "99203d9d6a4066b9e74887fafb28ae363f544acf", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -136,7 +136,7 @@ pub mod lib {\n use result::{Ok, Err};\n use io::ReaderUtil;\n use std::getopts;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use getopts::{opt_present};\n use getopts::groups;\n use syntax::codemap;\n@@ -177,7 +177,7 @@ Available lint options:\n \n     let lint_dict = lint::get_lint_dict();\n     let mut max_key = 0;\n-    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n+    for lint_dict.each_key_ref |&k| { max_key = uint::max(k.len(), max_key); }\n     fn padded(max: uint, s: &str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n@@ -186,7 +186,7 @@ Available lint options:\n                      padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n-    for lint_dict.each |k, v| {\n+    for lint_dict.each_ref |&k, &v| {\n         let k = str::replace(k, ~\"_\", ~\"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n@@ -368,7 +368,7 @@ pub fn monitor(+f: fn~(diagnostic::emitter)) {\n                 }\n             }\n             // Fail so the process returns a failure code\n-            fail;\n+            die!();\n         }\n     }\n }"}, {"sha": "85f4ba94e5a9bd541f3a2191b66a357140aeecb8", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -19,7 +19,7 @@ use syntax;\n use core::option;\n use core::str;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub fn indent<R>(op: fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`"}, {"sha": "2ed2d3ea5d7fe255bfe49d4a4cc448a8bf6656b0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -36,7 +36,7 @@ use syntax::ast_map;\n \n use core::str;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub fn note_and_explain_region(cx: ctxt,\n                                prefix: ~str,"}, {"sha": "dd6e889008f3b3bb275064be92f4f39d8b391ef5", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,17 +22,17 @@ use core::prelude::*;\n use parse;\n use util;\n \n-use core::pipes::stream;\n-use core::oldcomm;\n+use core::pipes::{stream, Chan, SharedChan, Port};\n use core::vec;\n+use core::ops::Drop;\n use rustc::back::link;\n use rustc::driver::driver;\n use rustc::driver::session::Session;\n use rustc::driver::session::{basic_options, options};\n use rustc::driver::session;\n use rustc::front;\n use rustc::metadata::filesearch;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::codemap;\n@@ -55,11 +55,15 @@ enum Msg {\n }\n \n pub struct Srv {\n-    ch: oldcomm::Chan<Msg>\n+    ch: SharedChan<Msg>\n }\n \n impl Srv: Clone {\n-    fn clone(&self) -> Srv { copy *self }\n+    fn clone(&self) -> Srv {\n+        Srv {\n+            ch: self.ch.clone()\n+        }\n+    }\n }\n \n pub fn from_str<T>(source: ~str, owner: SrvOwner<T>) -> T {\n@@ -72,18 +76,22 @@ pub fn from_file<T>(file: ~str, owner: SrvOwner<T>) -> T {\n \n fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n \n+    let (po, ch) = stream();\n+\n+    do task::spawn {\n+        act(&po, copy source, copy parse);\n+    }\n+\n     let srv_ = Srv {\n-        ch: do util::spawn_listener |copy source, move parse, po| {\n-            act(po, copy source, copy parse);\n-        }\n+        ch: SharedChan(ch)\n     };\n \n-    let res = owner(srv_);\n-    oldcomm::send(srv_.ch, Exit);\n+    let res = owner(srv_.clone());\n+    srv_.ch.send(Exit);\n     move res\n }\n \n-fn act(po: oldcomm::Port<Msg>, source: ~str, parse: Parser) {\n+fn act(po: &Port<Msg>, source: ~str, parse: Parser) {\n     let sess = build_session();\n \n     let ctxt = build_ctxt(\n@@ -93,7 +101,7 @@ fn act(po: oldcomm::Port<Msg>, source: ~str, parse: Parser) {\n \n     let mut keep_going = true;\n     while keep_going {\n-        match oldcomm::recv(po) {\n+        match po.recv() {\n           HandleRequest(f) => {\n             f(ctxt);\n           }\n@@ -112,7 +120,7 @@ pub fn exec<T:Owned>(\n     let msg = HandleRequest(fn~(move f, ctxt: Ctxt) {\n         ch.send(f(ctxt))\n     });\n-    oldcomm::send(srv.ch, move msg);\n+    srv.ch.send(move msg);\n     po.recv()\n }\n \n@@ -156,7 +164,7 @@ fn srv_should_build_ast_map() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            assert ctxt.ast_map.size() != 0u\n+            assert !ctxt.ast_map.is_empty()\n         };\n     }\n }"}, {"sha": "0e70900520d2ceeac3083de98c4ed70513467c05", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -31,7 +31,7 @@ use core::option;\n use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std::par;\n \n pub fn mk_pass() -> Pass {\n@@ -46,6 +46,7 @@ pub fn run(\n     doc: doc::Doc\n ) -> doc::Doc {\n     let fold = Fold {\n+        ctxt: srv.clone(),\n         fold_crate: fold_crate,\n         fold_item: fold_item,\n         fold_enum: fold_enum,\n@@ -61,7 +62,7 @@ fn fold_crate(\n     doc: doc::CrateDoc\n ) -> doc::CrateDoc {\n \n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n     let doc = fold::default_seq_fold_crate(fold, doc);\n \n     let attrs = do astsrv::exec(srv) |ctxt| {\n@@ -92,7 +93,7 @@ fn fold_item(\n     doc: doc::ItemDoc\n ) -> doc::ItemDoc {\n \n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n     let desc = if doc.id == ast::crate_node_id {\n@@ -118,7 +119,7 @@ fn parse_item_attrs<T:Owned>(\n         let attrs = match ctxt.ast_map.get(id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n           ast_map::node_foreign_item(item, _, _) => copy item.attrs,\n-          _ => fail ~\"parse_item_attrs: not an item\"\n+          _ => die!(~\"parse_item_attrs: not an item\")\n         };\n         parse_attrs(attrs)\n     }\n@@ -159,16 +160,16 @@ fn fold_enum(\n     doc: doc::EnumDoc\n ) -> doc::EnumDoc {\n \n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n     let doc_id = doc.id();\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     doc::EnumDoc {\n-        variants: do par::map(doc.variants) |variant| {\n+        variants: do vec::map(doc.variants) |variant| {\n             let variant = copy *variant;\n             let desc = {\n                 let variant = copy variant;\n-                do astsrv::exec(srv) |ctxt| {\n+                do astsrv::exec(srv.clone()) |ctxt| {\n                     match ctxt.ast_map.get(doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n@@ -182,9 +183,9 @@ fn fold_enum(\n                                 copy ast_variant.node.attrs)\n                         }\n                         _ => {\n-                            fail fmt!(\"Enum variant %s has id that's \\\n+                            die!(fmt!(\"Enum variant %s has id that's \\\n                                        not bound to an enum item\",\n-                                      variant.name)\n+                                      variant.name))\n                         }\n                     }\n                 }\n@@ -216,7 +217,7 @@ fn fold_trait(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::TraitDoc\n ) -> doc::TraitDoc {\n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n@@ -257,7 +258,7 @@ fn merge_method_attrs(\n                  attr_parser::parse_desc(copy method.attrs))\n             })\n           }\n-          _ => fail ~\"unexpected item\"\n+          _ => die!(~\"unexpected item\")\n         }\n     };\n \n@@ -293,7 +294,7 @@ fn fold_impl(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ImplDoc\n ) -> doc::ImplDoc {\n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n@@ -328,8 +329,8 @@ mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            run(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            run(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "ff6b745612dee6346cee26652e26580e4a729001", "filename": "src/librustdoc/demo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdemo.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -71,7 +71,7 @@ fn take_my_order_please(\n      * This function is full of fail\n      */\n \n-    fail;\n+    die!();\n }\n \n mod fortress_of_solitude {\n@@ -192,6 +192,6 @@ impl OmNomNomy: TheShunnedHouse {\n     }\n \n     fn construct(&self) -> bool {\n-        fail;\n+        die!();\n     }\n }"}, {"sha": "225b62f72cb831f762541896799aaf9ca42fefef", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -111,9 +111,9 @@ pub mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv, doc);\n-            run(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            run(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "fc572e3da2c1d80afa16626ee30c97adb92deb8a", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -322,7 +322,8 @@ fn structdoc_from_struct(\n         fields: do struct_def.fields.map |field| {\n             match field.node.kind {\n                 ast::named_field(ident, _, _) => to_str(ident),\n-                ast::unnamed_field => fail ~\"what is an unnamed struct field?\"\n+                ast::unnamed_field => die!(\n+                    ~\"what is an unnamed struct field?\")\n             }\n         },\n         sig: None"}, {"sha": "c93d9f3d7c159d784abee31ebf5a573b4f6ba983", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -193,11 +193,10 @@ pub fn default_any_fold_mod<T:Owned Clone>(\n     fold: &Fold<T>,\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n-    let fold_copy = fold.clone();\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: par::map(doc.items, |ItemTag, move fold_copy| {\n-            fold_ItemTag(&fold_copy, copy *ItemTag)\n+        items: vec::map(doc.items, |ItemTag| {\n+            fold_ItemTag(fold, copy *ItemTag)\n         }),\n         .. doc\n     }\n@@ -220,11 +219,10 @@ pub fn default_par_fold_mod<T:Owned Clone>(\n     fold: &Fold<T>,\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n-    let fold_copy = fold.clone();\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: par::map(doc.items, |ItemTag, move fold_copy| {\n-            fold_ItemTag(&fold_copy, copy *ItemTag)\n+        items: vec::map(doc.items, |ItemTag| {\n+            fold_ItemTag(fold, copy *ItemTag)\n         }),\n         .. doc\n     }\n@@ -234,11 +232,10 @@ pub fn default_any_fold_nmod<T:Owned Clone>(\n     fold: &Fold<T>,\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n-    let fold_copy = fold.clone();\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: par::map(doc.fns, |FnDoc, move fold_copy| {\n-            (fold_copy.fold_fn)(&fold_copy, copy *FnDoc)\n+        fns: vec::map(doc.fns, |FnDoc| {\n+            (fold.fold_fn)(fold, copy *FnDoc)\n         }),\n         .. doc\n     }\n@@ -261,11 +258,10 @@ pub fn default_par_fold_nmod<T:Owned Clone>(\n     fold: &Fold<T>,\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n-    let fold_copy = fold.clone();\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: par::map(doc.fns, |FnDoc, move fold_copy| {\n-            (fold_copy.fold_fn)(&fold_copy, copy *FnDoc)\n+        fns: vec::map(doc.fns, |FnDoc| {\n+            (fold.fold_fn)(fold, copy *FnDoc)\n         }),\n         .. doc\n     }"}, {"sha": "776d2fe9083c71439881372bb182e4fce77f8a60", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -274,11 +274,11 @@ mod test {\n                 output_style: output_style,\n                 .. config::default_config(&Path(\"whatever\"))\n             };\n-            let doc = extract::from_srv(srv, ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv, doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv, doc);\n-            let doc = (path_pass::mk_pass().f)(srv, doc);\n-            run(srv, doc, config)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n+            run(srv.clone(), doc, config)\n         }\n     }\n }"}, {"sha": "fc13af8a22133807a457b9b6b2f28c07d54483ff", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -35,16 +35,17 @@ use trim_pass;\n use unindent_pass;\n \n use core::iter;\n-use core::oldcomm;\n use core::str;\n use core::vec;\n use std::par;\n+use std::cell::Cell;\n use syntax;\n \n pub fn mk_pass(writer_factory: WriterFactory) -> Pass {\n+    let writer_factory = Cell(writer_factory);\n     let f = fn~(move writer_factory,\n                 srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-        run(srv, doc, copy writer_factory)\n+        run(srv, doc, writer_factory.take())\n     };\n \n     Pass {\n@@ -155,7 +156,7 @@ fn should_request_new_writer_for_each_page() {\n     write_markdown(doc, move writer_factory);\n     // We expect two pages to have been written\n     for iter::repeat(2) {\n-        oldcomm::recv(po);\n+        po.recv();\n     }\n }\n \n@@ -186,7 +187,7 @@ fn should_write_title_for_each_page() {\n     let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n     write_markdown(doc, move writer_factory);\n     for iter::repeat(2) {\n-        let (page, markdown) = oldcomm::recv(po);\n+        let (page, markdown) = po.recv();\n         match page {\n           doc::CratePage(_) => {\n             assert str::contains(markdown, ~\"% Crate core\");\n@@ -331,7 +332,7 @@ fn should_write_full_path_to_mod() {\n     assert str::contains(markdown, ~\"# Module `a::b::c`\");\n }\n \n-fn write_oldcommon(\n+fn write_common(\n     ctxt: &Ctxt,\n     desc: Option<~str>,\n     sections: &[doc::Section]\n@@ -380,7 +381,7 @@ fn write_mod_contents(\n     ctxt: &Ctxt,\n     doc: doc::ModDoc\n ) {\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n         write_index(ctxt, (&doc.index).get());\n     }\n@@ -483,7 +484,7 @@ fn should_write_index_for_foreign_mods() {\n }\n \n fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n         write_index(ctxt, (&doc.index).get());\n     }\n@@ -534,7 +535,7 @@ fn write_fnlike(\n     sections: &[doc::Section]\n ) {\n     write_sig(ctxt, sig);\n-    write_oldcommon(ctxt, desc, sections);\n+    write_common(ctxt, desc, sections);\n }\n \n fn write_sig(ctxt: &Ctxt, sig: Option<~str>) {\n@@ -543,7 +544,7 @@ fn write_sig(ctxt: &Ctxt, sig: Option<~str>) {\n         ctxt.w.write_line(code_block_indent(sig));\n         ctxt.w.write_line(~\"\");\n       }\n-      None => fail ~\"unimplemented\"\n+      None => die!(~\"unimplemented\")\n     }\n }\n \n@@ -603,7 +604,7 @@ fn write_const(\n     doc: doc::ConstDoc\n ) {\n     write_sig(ctxt, copy doc.sig);\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -624,7 +625,7 @@ fn write_enum(\n     ctxt: &Ctxt,\n     doc: doc::EnumDoc\n ) {\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     write_variants(ctxt, doc.variants);\n }\n \n@@ -705,7 +706,7 @@ fn should_write_variant_list_with_signatures() {\n }\n \n fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n@@ -753,7 +754,7 @@ fn should_write_trait_method_signature() {\n }\n \n fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n@@ -795,7 +796,7 @@ fn write_type(\n     doc: doc::TyDoc\n ) {\n     write_sig(ctxt, copy doc.sig);\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -822,7 +823,7 @@ fn write_struct(\n     doc: doc::StructDoc\n ) {\n     write_sig(ctxt, copy doc.sig);\n-    write_oldcommon(ctxt, doc.desc(), doc.sections());\n+    write_common(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -848,7 +849,6 @@ mod test {\n     use tystr_pass;\n     use unindent_pass;\n \n-    use core::oldcomm;\n     use core::path::Path;\n     use core::str;\n \n@@ -867,25 +867,26 @@ mod test {\n                 .. config::default_config(&Path(\"whatever\"))\n             };\n \n-            let doc = extract::from_srv(srv, ~\"\");\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n             debug!(\"doc (extract): %?\", doc);\n-            let doc = (tystr_pass::mk_pass().f)(srv, doc);\n+            let doc = (tystr_pass::mk_pass().f)(srv.clone(), doc);\n             debug!(\"doc (tystr): %?\", doc);\n-            let doc = (path_pass::mk_pass().f)(srv, doc);\n+            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n             debug!(\"doc (path): %?\", doc);\n-            let doc = (attr_pass::mk_pass().f)(srv, doc);\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n             debug!(\"doc (attr): %?\", doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv, doc);\n+            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n             debug!(\"doc (desc_to_brief): %?\", doc);\n-            let doc = (unindent_pass::mk_pass().f)(srv, doc);\n+            let doc = (unindent_pass::mk_pass().f)(srv.clone(), doc);\n             debug!(\"doc (unindent): %?\", doc);\n-            let doc = (sectionalize_pass::mk_pass().f)(srv, doc);\n+            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n             debug!(\"doc (trim): %?\", doc);\n-            let doc = (trim_pass::mk_pass().f)(srv, doc);\n+            let doc = (trim_pass::mk_pass().f)(srv.clone(), doc);\n             debug!(\"doc (sectionalize): %?\", doc);\n-            let doc = (markdown_index_pass::mk_pass(config).f)(srv, doc);\n+            let doc = (markdown_index_pass::mk_pass(config).f)(\n+                srv.clone(), doc);\n             debug!(\"doc (index): %?\", doc);\n-            (srv, doc)\n+            (srv.clone(), doc)\n         }\n     }\n \n@@ -899,7 +900,7 @@ mod test {\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         write_markdown(doc, move writer_factory);\n-        return oldcomm::recv(po).second();\n+        return po.recv().second();\n     }\n \n     pub fn write_markdown_str_srv(\n@@ -909,7 +910,7 @@ mod test {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         let pass = mk_pass(move writer_factory);\n         (pass.f)(srv, doc);\n-        return oldcomm::recv(po).second();\n+        return po.recv().second();\n     }\n \n     #[test]"}, {"sha": "9b5efb7c90dac11545c72777312dd7bd8a8cf3e2", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -19,13 +19,13 @@ use pass::Pass;\n use core::io::ReaderUtil;\n use core::io;\n use core::libc;\n-use core::oldcomm;\n use core::os;\n use core::pipes;\n use core::result;\n use core::run;\n use core::str;\n use core::task;\n+use core::pipes::*;\n use std::future;\n use syntax;\n \n@@ -145,7 +145,7 @@ fn pandoc_writer(\n         if status != 0 {\n             error!(\"pandoc-out: %s\", stdout);\n             error!(\"pandoc-err: %s\", stderr);\n-            fail ~\"pandoc failed\";\n+            die!(~\"pandoc failed\");\n         }\n     }\n }\n@@ -156,7 +156,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n         let file = os::fdopen(fd);\n         let reader = io::FILE_reader(file, false);\n         let buf = io::with_bytes_writer(|writer| {\n-            let mut bytes = [mut 0, ..4096];\n+            let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n                 writer.write(bytes.view(0, nread));\n@@ -168,12 +168,8 @@ fn readclose(fd: libc::c_int) -> ~str {\n }\n \n fn generic_writer(process: fn~(markdown: ~str)) -> Writer {\n-    let (setup_po, setup_ch) = pipes::stream();\n+    let (po, ch) = stream::<WriteInstr>();\n     do task::spawn |move process, move setup_ch| {\n-        let po: oldcomm::Port<WriteInstr> = oldcomm::Port();\n-        let ch = oldcomm::Chan(&po);\n-        setup_ch.send(ch);\n-\n         let mut markdown = ~\"\";\n         let mut keep_going = true;\n         while keep_going {\n@@ -184,10 +180,8 @@ fn generic_writer(process: fn~(markdown: ~str)) -> Writer {\n         }\n         process(move markdown);\n     };\n-    let ch = setup_po.recv();\n-\n     fn~(instr: WriteInstr) {\n-        oldcomm::send(ch, instr);\n+        ch.send(instr);\n     }\n }\n \n@@ -279,8 +273,8 @@ mod test {\n \n     pub fn mk_doc(name: ~str, source: ~str) -> doc::Doc {\n         do astsrv::from_str(source) |srv| {\n-            let doc = extract::from_srv(srv, copy name);\n-            let doc = (path_pass::mk_pass().f)(srv, doc);\n+            let doc = extract::from_srv(srv.clone(), copy name);\n+            let doc = (path_pass::mk_pass().f)(srv.clone(), doc);\n             doc\n         }\n     }\n@@ -293,21 +287,22 @@ fn write_file(path: &Path, s: ~str) {\n       result::Ok(writer) => {\n         writer.write_str(s);\n       }\n-      result::Err(e) => fail e\n+      result::Err(e) => die!(e)\n     }\n }\n \n pub fn future_writer_factory(\n-) -> (WriterFactory, oldcomm::Port<(doc::Page, ~str)>) {\n-    let markdown_po = oldcomm::Port();\n-    let markdown_ch = oldcomm::Chan(&markdown_po);\n+) -> (WriterFactory, Port<(doc::Page, ~str)>) {\n+    let (markdown_po, markdown_ch) = stream();\n+    let markdown_ch = SharedChan(markdown_ch);\n     let writer_factory = fn~(page: doc::Page) -> Writer {\n         let (writer_po, writer_ch) = pipes::stream();\n+        let markdown_ch = markdown_ch.clone();\n         do task::spawn |move writer_ch| {\n             let (writer, future) = future_writer();\n             writer_ch.send(move writer);\n             let s = future.get();\n-            oldcomm::send(markdown_ch, (copy page, s));\n+            markdown_ch.send((copy page, s));\n         }\n         writer_po.recv()\n     };"}, {"sha": "c8509826fdbabebfb6d68b59f8166ebf38c4a221", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -28,9 +28,9 @@ use sort_pass;\n use util::NominalOp;\n use util;\n \n-use core::oldcomm;\n use core::option;\n use core::vec;\n+use core::pipes::*;\n use syntax::ast;\n \n pub fn mk_pass(output_style: config::OutputStyle) -> Pass {\n@@ -52,24 +52,26 @@ pub fn run(\n         return doc;\n     }\n \n-    let (result_port, page_chan) = do util::spawn_conversation\n-        |page_port, result_chan| {\n-        oldcomm::send(result_chan, make_doc_from_pages(page_port));\n+    let (result_port, result_chan) = stream();\n+    let (page_port, page_chan) = stream();\n+    let page_chan = SharedChan(page_chan);\n+    do task::spawn {\n+        result_chan.send(make_doc_from_pages(&page_port));\n     };\n \n     find_pages(doc, page_chan);\n-    oldcomm::recv(result_port)\n+    result_port.recv()\n }\n \n-type PagePort = oldcomm::Port<Option<doc::Page>>;\n-type PageChan = oldcomm::Chan<Option<doc::Page>>;\n+type PagePort = Port<Option<doc::Page>>;\n+type PageChan = SharedChan<Option<doc::Page>>;\n \n type NominalPageChan = NominalOp<PageChan>;\n \n-fn make_doc_from_pages(page_port: PagePort) -> doc::Doc {\n+fn make_doc_from_pages(page_port: &PagePort) -> doc::Doc {\n     let mut pages = ~[];\n     loop {\n-        let val = oldcomm::recv(page_port);\n+        let val = page_port.recv();\n         if val.is_some() {\n             pages += ~[option::unwrap(move val)];\n         } else {\n@@ -83,14 +85,15 @@ fn make_doc_from_pages(page_port: PagePort) -> doc::Doc {\n \n fn find_pages(doc: doc::Doc, page_chan: PageChan) {\n     let fold = Fold {\n+        ctxt: NominalOp { op: page_chan.clone() },\n         fold_crate: fold_crate,\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n-        .. fold::default_any_fold(NominalOp { op: page_chan })\n+        .. fold::default_any_fold(NominalOp { op: page_chan.clone() })\n     };\n     (fold.fold_doc)(&fold, copy doc);\n \n-    oldcomm::send(page_chan, None);\n+    page_chan.send(None);\n }\n \n fn fold_crate(\n@@ -105,7 +108,7 @@ fn fold_crate(\n         .. copy doc\n     });\n \n-    oldcomm::send(fold.ctxt.op, Some(page));\n+    fold.ctxt.op.send(Some(page));\n \n     doc\n }\n@@ -121,7 +124,7 @@ fn fold_mod(\n \n         let doc = strip_mod(copy doc);\n         let page = doc::ItemPage(doc::ModTag(doc));\n-        oldcomm::send(fold.ctxt.op, Some(page));\n+        fold.ctxt.op.send(Some(page));\n     }\n \n     doc\n@@ -146,7 +149,7 @@ fn fold_nmod(\n ) -> doc::NmodDoc {\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n     let page = doc::ItemPage(doc::NmodTag(copy doc));\n-    oldcomm::send(fold.ctxt.op, Some(page));\n+    fold.ctxt.op.send(Some(page));\n     return doc;\n }\n \n@@ -196,8 +199,8 @@ mod test {\n         source: ~str\n     ) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            run(srv, doc, output_style)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            run(srv.clone(), doc, output_style)\n         }\n     }\n "}, {"sha": "91e3264db1c06a4e0bef152ec994f479ca47ffe5", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -33,7 +33,7 @@ pub fn run_passes(\n         log(debug, fmt!(\"pass #%d\", passno));\n         passno += 1;\n         do time(copy pass.name) {\n-            (pass.f)(srv, copy doc)\n+            (pass.f)(srv.clone(), copy doc)\n         }\n     }\n }\n@@ -90,7 +90,7 @@ fn test_run_passes() {\n                 f: pass2\n             }\n         ];\n-        let doc = extract::from_srv(srv, ~\"one\");\n+        let doc = extract::from_srv(srv.clone(), ~\"one\");\n         let doc = run_passes(srv, doc, passes);\n         assert doc.cratemod().name() == ~\"onetwothree\";\n     }"}, {"sha": "165ab989a2f065bfe1ba5357de7227155fb914e3", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -35,7 +35,12 @@ struct Ctxt {\n }\n \n impl Ctxt: Clone {\n-    fn clone(&self) -> Ctxt { copy *self }\n+    fn clone(&self) -> Ctxt {\n+        Ctxt {\n+            srv: self.srv.clone(),\n+            path: copy self.path\n+        }\n+    }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -45,6 +50,7 @@ fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n         mut path: ~[]\n     };\n     let fold = Fold {\n+        ctxt: ctxt.clone(),\n         fold_item: fold_item,\n         fold_mod: fold_mod,\n         fold_nmod: fold_nmod,\n@@ -89,8 +95,8 @@ fn fold_nmod(fold: &fold::Fold<Ctxt>, doc: doc::NmodDoc) -> doc::NmodDoc {\n fn should_record_mod_paths() {\n     let source = ~\"mod a { mod b { mod c { } } mod d { mod e { } } }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = run(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = run(srv.clone(), doc);\n         assert doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n             == ~[~\"a\", ~\"b\"];\n         assert doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n@@ -102,8 +108,8 @@ fn should_record_mod_paths() {\n fn should_record_fn_paths() {\n     let source = ~\"mod a { fn b() { } }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = run(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = run(srv.clone(), doc);\n         assert doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"];\n     }\n }\n@@ -112,8 +118,8 @@ fn should_record_fn_paths() {\n fn should_record_foreign_mod_paths() {\n     let source = ~\"mod a { extern mod b { } }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = run(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = run(srv.clone(), doc);\n         assert doc.cratemod().mods()[0].nmods()[0].path() == ~[~\"a\"];\n     }\n }\n@@ -122,8 +128,8 @@ fn should_record_foreign_mod_paths() {\n fn should_record_foreign_fn_paths() {\n     let source = ~\"extern mod a { fn b(); }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = run(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = run(srv.clone(), doc);\n         assert doc.cratemod().nmods()[0].fns[0].path() == ~[~\"a\"];\n     }\n }"}, {"sha": "f039bb74583e56a8e1cbcb6d828d4bd779b66bdd", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -19,7 +19,7 @@ use fold;\n use pass::Pass;\n \n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub fn mk_pass() -> Pass {\n     Pass {\n@@ -30,6 +30,7 @@ pub fn mk_pass() -> Pass {\n \n pub fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n     let fold = Fold {\n+        ctxt: srv.clone(),\n         fold_mod: fold_mod,\n         .. fold::default_any_fold(srv)\n     };\n@@ -44,7 +45,7 @@ fn fold_mod(\n \n     doc::ModDoc {\n         items: do doc.items.filtered |ItemTag| {\n-            !is_hidden(fold.ctxt, ItemTag.item())\n+            !is_hidden(fold.ctxt.clone(), ItemTag.item())\n         },\n         .. doc\n     }\n@@ -78,8 +79,8 @@ pub mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            run(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            run(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "4b47b71449af2e06cfea267fbd2f90ccb7cdc5a5", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -31,6 +31,7 @@ pub fn mk_pass() -> Pass {\n \n pub fn run(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n     let fold = Fold {\n+        ctxt: srv.clone(),\n         fold_mod: fold_mod,\n         .. fold::default_any_fold(srv)\n     };\n@@ -45,7 +46,7 @@ fn fold_mod(\n \n     doc::ModDoc {\n         items: doc.items.filtered(|ItemTag| {\n-            is_visible(fold.ctxt, ItemTag.item())\n+            is_visible(fold.ctxt.clone(), ItemTag.item())\n         }),\n         .. doc\n     }\n@@ -82,8 +83,8 @@ pub mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            run(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            run(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "b3e9c43e87a1eb8aa03b5d312110555ad4fc4440", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -94,14 +94,14 @@ fn run(config: Config) {\n \n         // Just time how long it takes for the AST to become available\n         do time(~\"wait_ast\") {\n-            do astsrv::exec(srv) |_ctxt| { }\n+            do astsrv::exec(srv.clone()) |_ctxt| { }\n         };\n \n         // Extract the initial doc tree from the AST. This contains\n         // just names and node ids.\n         let doc = time(~\"extract\", || {\n             let default_name = copy source_file;\n-            extract::from_srv(srv, default_name.to_str())\n+            extract::from_srv(srv.clone(), default_name.to_str())\n         });\n \n         // Refine and publish the document"}, {"sha": "d6455c4c783fffcd56e561b7e1c1ae341d4cf62a", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -261,9 +261,9 @@ pub mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv, doc);\n-            run(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            run(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "946be67ee1099ed8287d9f988aed299c0dff92f8", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -28,8 +28,8 @@ pub fn mk_pass() -> Pass {\n fn test() {\n     let source = ~\"mod z { } fn y() { }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = (mk_pass().f)(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = (mk_pass().f)(srv.clone(), doc);\n         assert doc.cratemod().items[0].name() == ~\"y\";\n         assert doc.cratemod().items[1].name() == ~\"z\";\n     }"}, {"sha": "646dc12d336e9941d05e0064c4777d10958a61c4", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -55,8 +55,8 @@ fn test() {\n          type itype = int; \\\n          struct istruct { f: () }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = (mk_pass().f)(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = (mk_pass().f)(srv.clone(), doc);\n         assert doc.cratemod().items[0].name() == ~\"iconst\";\n         assert doc.cratemod().items[1].name() == ~\"itype\";\n         assert doc.cratemod().items[2].name() == ~\"ienum\";"}, {"sha": "2792508483ca151a161972172092c2b8645e8c3a", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -69,8 +69,8 @@ fn test() {\n \n     let source = ~\"mod z { mod y { } fn x() { } } mod w { }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = (mk_pass(~\"\", name_lteq).f)(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = (mk_pass(~\"\", name_lteq).f)(srv.clone(), doc);\n         assert doc.cratemod().mods()[0].name() == ~\"w\";\n         assert doc.cratemod().mods()[1].items[0].name() == ~\"x\";\n         assert doc.cratemod().mods()[1].items[1].name() == ~\"y\";\n@@ -86,11 +86,11 @@ fn should_be_stable() {\n \n     let source = ~\"mod a { mod b { } } mod c { mod d { } }\";\n     do astsrv::from_str(source) |srv| {\n-        let doc = extract::from_srv(srv, ~\"\");\n-        let doc = (mk_pass(~\"\", always_eq).f)(srv, doc);\n+        let doc = extract::from_srv(srv.clone(), ~\"\");\n+        let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n         assert doc.cratemod().mods()[0].items[0].name() == ~\"b\";\n         assert doc.cratemod().mods()[1].items[0].name() == ~\"d\";\n-        let doc = (mk_pass(~\"\", always_eq).f)(srv, doc);\n+        let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n         assert doc.cratemod().mods()[0].items[0].name() == ~\"b\";\n         assert doc.cratemod().mods()[1].items[0].name() == ~\"d\";\n     }"}, {"sha": "aec8b56341fd3ae0aec935ac201f62ed7974100b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -73,7 +73,7 @@ fn fold_item(\n }\n \n fn apply_to_sections(\n-    +op: NominalOp<Op>,\n+    op: NominalOp<Op>,\n     sections: ~[doc::Section]\n ) -> ~[doc::Section] {\n     par::map(sections, |section, copy op| doc::Section {\n@@ -306,11 +306,11 @@ mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv, doc);\n-            let doc = (desc_to_brief_pass::mk_pass().f)(srv, doc);\n-            let doc = (sectionalize_pass::mk_pass().f)(srv, doc);\n-            (mk_pass(~\"\", |s| str::trim(s) ).f)(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (desc_to_brief_pass::mk_pass().f)(srv.clone(), doc);\n+            let doc = (sectionalize_pass::mk_pass().f)(srv.clone(), doc);\n+            (mk_pass(~\"\", |s| str::trim(s) ).f)(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "39557a92e01eec8979d8097f9a9d22424f9917db", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -45,9 +45,9 @@ mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            let doc = (attr_pass::mk_pass().f)(srv, doc);\n-            (mk_pass().f)(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            let doc = (attr_pass::mk_pass().f)(srv.clone(), doc);\n+            (mk_pass().f)(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "4ab40530cfb875ff5f8ef5c84f30b788d90597b4", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,7 +22,7 @@ use fold;\n use pass::Pass;\n \n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n use std::par;\n use syntax::ast;\n use syntax::print::pprust;\n@@ -40,6 +40,7 @@ pub fn run(\n     doc: doc::Doc\n ) -> doc::Doc {\n     let fold = Fold {\n+        ctxt: srv.clone(),\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n@@ -57,7 +58,7 @@ fn fold_fn(\n     doc: doc::FnDoc\n ) -> doc::FnDoc {\n \n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n \n     doc::SimpleItemDoc {\n         sig: get_fn_sig(srv, doc.id()),\n@@ -79,7 +80,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n             Some(pprust::fun_to_str(*decl, ident, copy *tys,\n                                     extract::interner()))\n           }\n-          _ => fail ~\"get_fn_sig: fn_id not bound to a fn item\"\n+          _ => die!(~\"get_fn_sig: fn_id not bound to a fn item\")\n         }\n     }\n }\n@@ -100,7 +101,7 @@ fn fold_const(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::ConstDoc\n ) -> doc::ConstDoc {\n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n \n     doc::SimpleItemDoc {\n         sig: Some({\n@@ -112,7 +113,7 @@ fn fold_const(\n                     }, _) => {\n                         pprust::ty_to_str(ty, extract::interner())\n                     }\n-                    _ => fail ~\"fold_const: id not bound to a const item\"\n+                    _ => die!(~\"fold_const: id not bound to a const item\")\n                 }\n             }}),\n         .. doc\n@@ -130,13 +131,13 @@ fn fold_enum(\n     doc: doc::EnumDoc\n ) -> doc::EnumDoc {\n     let doc_id = doc.id();\n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n \n     doc::EnumDoc {\n-        variants: do par::map(doc.variants) |variant| {\n+        variants: do vec::map(doc.variants) |variant| {\n             let sig = {\n                 let variant = copy *variant;\n-                do astsrv::exec(srv) |copy variant, ctxt| {\n+                do astsrv::exec(srv.clone()) |copy variant, ctxt| {\n                     match ctxt.ast_map.get(doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n@@ -149,7 +150,7 @@ fn fold_enum(\n                             pprust::variant_to_str(\n                                 ast_variant, extract::interner())\n                         }\n-                        _ => fail ~\"enum variant not bound to an enum item\"\n+                        _ => die!(~\"enum variant not bound to an enum item\")\n                     }\n                 }\n             };\n@@ -174,7 +175,7 @@ fn fold_trait(\n     doc: doc::TraitDoc\n ) -> doc::TraitDoc {\n     doc::TraitDoc {\n-        methods: merge_methods(fold.ctxt, doc.id(), copy doc.methods),\n+        methods: merge_methods(fold.ctxt.clone(), doc.id(), copy doc.methods),\n         .. doc\n     }\n }\n@@ -184,9 +185,9 @@ fn merge_methods(\n     item_id: doc::AstId,\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n-    do par::map(docs) |doc| {\n+    do vec::map(docs) |doc| {\n         doc::MethodDoc {\n-            sig: get_method_sig(srv, item_id, copy doc.name),\n+            sig: get_method_sig(srv.clone(), item_id, copy doc.name),\n             .. copy *doc\n         }\n     }\n@@ -228,7 +229,7 @@ fn get_method_sig(\n                     }\n                   }\n                 }\n-                _ => fail ~\"method not found\"\n+                _ => die!(~\"method not found\")\n             }\n           }\n           ast_map::node_item(@ast::item {\n@@ -245,10 +246,10 @@ fn get_method_sig(\n                         extract::interner()\n                     ))\n                 }\n-                None => fail ~\"method not found\"\n+                None => die!(~\"method not found\")\n             }\n           }\n-          _ => fail ~\"get_method_sig: item ID not bound to trait or impl\"\n+          _ => die!(~\"get_method_sig: item ID not bound to trait or impl\")\n         }\n     }\n }\n@@ -265,7 +266,7 @@ fn fold_impl(\n     doc: doc::ImplDoc\n ) -> doc::ImplDoc {\n \n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n \n     let (trait_types, self_ty) = {\n         let doc = copy doc;\n@@ -281,15 +282,15 @@ fn fold_impl(\n                      Some(pprust::ty_to_str(\n                          self_ty, extract::interner())))\n                 }\n-                _ => fail ~\"expected impl\"\n+                _ => die!(~\"expected impl\")\n             }\n         }\n     };\n \n     doc::ImplDoc {\n         trait_types: trait_types,\n         self_ty: self_ty,\n-        methods: merge_methods(fold.ctxt, doc.id(), copy doc.methods),\n+        methods: merge_methods(fold.ctxt.clone(), doc.id(), copy doc.methods),\n         .. doc\n     }\n }\n@@ -314,7 +315,7 @@ fn should_add_impl_self_ty() {\n \n #[test]\n fn should_add_impl_method_sigs() {\n-    let doc = test::mk_doc(~\"impl int { fn a<T>() -> int { fail } }\");\n+    let doc = test::mk_doc(~\"impl int { fn a<T>() -> int { die!() } }\");\n     assert doc.cratemod().impls()[0].methods[0].sig\n         == Some(~\"fn a<T>() -> int\");\n }\n@@ -324,7 +325,7 @@ fn fold_type(\n     doc: doc::TyDoc\n ) -> doc::TyDoc {\n \n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n \n     doc::SimpleItemDoc {\n         sig: {\n@@ -344,7 +345,7 @@ fn fold_type(\n                                               extract::interner())\n                         ))\n                     }\n-                    _ => fail ~\"expected type\"\n+                    _ => die!(~\"expected type\")\n                 }\n             }\n         },\n@@ -362,7 +363,7 @@ fn fold_struct(\n     fold: &fold::Fold<astsrv::Srv>,\n     doc: doc::StructDoc\n ) -> doc::StructDoc {\n-    let srv = fold.ctxt;\n+    let srv = fold.ctxt.clone();\n \n     doc::StructDoc {\n         sig: {\n@@ -374,7 +375,7 @@ fn fold_struct(\n                         Some(pprust::item_to_str(item,\n                                                  extract::interner()))\n                     }\n-                    _ => fail ~\"not an item\"\n+                    _ => die!(~\"not an item\")\n                 }\n             }\n         },\n@@ -395,7 +396,7 @@ fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n             };\n             ast::item_struct(def, tys)\n         }\n-        _ => fail ~\"not a struct\"\n+        _ => die!(~\"not a struct\")\n     };\n \n     @ast::item {\n@@ -434,8 +435,8 @@ pub mod test {\n \n     pub fn mk_doc(source: ~str) -> doc::Doc {\n         do astsrv::from_str(copy source) |srv| {\n-            let doc = extract::from_srv(srv, ~\"\");\n-            run(srv, doc)\n+            let doc = extract::from_srv(srv.clone(), ~\"\");\n+            run(srv.clone(), doc)\n         }\n     }\n }"}, {"sha": "aa15c104540f60f2371f5a117bbd500cbf8aff7d", "filename": "src/librustdoc/util.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrustdoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Futil.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,7 +10,6 @@\n \n use core::prelude::*;\n \n-use core::oldcomm;\n use core::task;\n \n // Just a named container for our op, so it can have impls\n@@ -21,27 +20,3 @@ pub struct NominalOp<T> {\n impl<T: Copy> NominalOp<T>: Clone {\n     fn clone(&self) -> NominalOp<T> { copy *self }\n }\n-\n-pub fn spawn_listener<A: Owned>(\n-    f: fn~(oldcomm::Port<A>)) -> oldcomm::Chan<A> {\n-    let setup_po = oldcomm::Port();\n-    let setup_ch = oldcomm::Chan(&setup_po);\n-    do task::spawn |move f| {\n-        let po = oldcomm::Port();\n-        let ch = oldcomm::Chan(&po);\n-        oldcomm::send(setup_ch, ch);\n-        f(move po);\n-    }\n-    oldcomm::recv(setup_po)\n-}\n-\n-pub fn spawn_conversation<A: Owned, B: Owned>\n-    (f: fn~(oldcomm::Port<A>, oldcomm::Chan<B>))\n-    -> (oldcomm::Port<B>, oldcomm::Chan<A>) {\n-    let from_child = oldcomm::Port();\n-    let to_parent = oldcomm::Chan(&from_child);\n-    let to_child = do spawn_listener |move f, from_parent| {\n-        f(from_parent, to_parent)\n-    };\n-    (from_child, to_child)\n-}"}, {"sha": "0e551066449935792eab82f4afad71499c83b402", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -178,10 +178,10 @@ fn run(repl: Repl, input: ~str) -> Repl {\n         ast::expr_call(_, exprs, _) => {\n             match exprs[0].node {\n                 ast::expr_block(blk) => @blk,\n-                _ => fail\n+                _ => die!()\n             }\n         }\n-        _ => fail\n+        _ => die!()\n     };\n     debug!(\"recording input into repl history\");\n     record(repl, blk, sess.parse_sess.interner)\n@@ -320,7 +320,7 @@ fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n             let mut end_multiline = false;\n             while (!end_multiline) {\n                 match get_line(~\"rusti| \") {\n-                    None => fail ~\"unterminated multiline command :{ .. :}\",\n+                    None => die!(~\"unterminated multiline command :{ .. :}\"),\n                     Some(line) => {\n                         if str::trim(line) == ~\":}\" {\n                             end_multiline = true;"}, {"sha": "a8d3f15610467d41c1e14fa111d622ffea901f16", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -221,7 +221,7 @@ pub fn unwrap_mutex_arc<T: Owned>(arc: MutexARC<T>) -> T {\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let MutexARCInner { failed: failed, data: data, _ } = move inner;\n     if failed {\n-        fail ~\"Can't unwrap poisoned MutexARC - another task failed inside!\"\n+        die!(~\"Can't unwrap poisoned MutexARC - another task failed inside!\")\n     }\n     move data\n }\n@@ -232,9 +232,9 @@ pub fn unwrap_mutex_arc<T: Owned>(arc: MutexARC<T>) -> T {\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n         if is_mutex {\n-            fail ~\"Poisoned MutexARC - another task failed inside!\";\n+            die!(~\"Poisoned MutexARC - another task failed inside!\");\n         } else {\n-            fail ~\"Poisoned rw_arc - another task failed inside!\";\n+            die!(~\"Poisoned rw_arc - another task failed inside!\");\n         }\n     }\n }\n@@ -410,7 +410,7 @@ pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let RWARCInner { failed: failed, data: data, _ } = move inner;\n     if failed {\n-        fail ~\"Can't unwrap poisoned RWARC - another task failed inside!\"\n+        die!(~\"Can't unwrap poisoned RWARC - another task failed inside!\")\n     }\n     move data\n }"}, {"sha": "3e21a320d4436164b3d7253765566120a95c3969", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -305,6 +305,6 @@ fn test_arena_destructors_fail() {\n         // get freed too.\n         do arena.alloc { @20 };\n         // Now fail.\n-        fail;\n+        die!();\n     };\n }"}, {"sha": "5813e0919d958546bac2d64ce034349fe6a86c9a", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -65,7 +65,7 @@ impl &[u8]: ToBase64 {\n                 str::push_char(&mut s, chars[(n >> 6u) & 63u]);\n                 str::push_char(&mut s, '=');\n               }\n-              _ => fail ~\"Algebra is broken, please alert the math police\"\n+              _ => die!(~\"Algebra is broken, please alert the math police\")\n             }\n         }\n         s\n@@ -84,7 +84,7 @@ pub trait FromBase64 {\n \n impl ~[u8]: FromBase64 {\n     pure fn from_base64() -> ~[u8] {\n-        if self.len() % 4u != 0u { fail ~\"invalid base64 length\"; }\n+        if self.len() % 4u != 0u { die!(~\"invalid base64 length\"); }\n \n         let len = self.len();\n         let mut padding = 0u;\n@@ -126,10 +126,10 @@ impl ~[u8]: FromBase64 {\n                             r.push(((n >> 10u) & 0xFFu) as u8);\n                             return copy r;\n                           }\n-                          _ => fail ~\"invalid base64 padding\"\n+                          _ => die!(~\"invalid base64 padding\")\n                         }\n                     } else {\n-                        fail ~\"invalid base64 character\";\n+                        die!(~\"invalid base64 character\");\n                     }\n \n                     i += 1u;"}, {"sha": "092a0d18a0fe4260c54c39a6110bb9a94e079466", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -88,7 +88,7 @@ impl BigUint : Ord {\n }\n \n impl BigUint : ToStr {\n-    pure fn to_str() -> ~str { self.to_str_radix(10) }\n+    pure fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl BigUint : from_str::FromStr {\n@@ -245,7 +245,7 @@ impl BigUint : Modulo<BigUint, BigUint> {\n }\n \n impl BigUint : Neg<BigUint> {\n-    pure fn neg(&self) -> BigUint { fail }\n+    pure fn neg(&self) -> BigUint { die!() }\n }\n \n impl BigUint : IntConvertible {\n@@ -332,7 +332,7 @@ pub impl BigUint {\n     }\n \n     pure fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail }\n+        if other.is_zero() { die!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return (copy *self, Zero::zero()); }\n \n@@ -456,7 +456,7 @@ pub impl BigUint {\n         pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             str::trim_left_chars(str::concat(vec::reversed(v).map(|n| {\n-                let s = uint::to_str(*n as uint, radix);\n+                let s = uint::to_str_radix(*n as uint, radix);\n                 str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n             })), ['0'])\n         }\n@@ -523,7 +523,7 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (1475789056, 8),\n         15 => (2562890625, 8),\n         16 => (4294967296, 8),\n-        _  => fail\n+        _  => die!()\n     }\n }\n \n@@ -547,7 +547,7 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n         14 => (38416, 4),\n         15 => (50625, 4),\n         16 => (65536, 4),\n-        _  => fail\n+        _  => die!()\n     }\n }\n \n@@ -605,7 +605,7 @@ impl BigInt : Ord {\n }\n \n impl BigInt : ToStr {\n-    pure fn to_str() -> ~str { self.to_str_radix(10) }\n+    pure fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl BigInt : from_str::FromStr {\n@@ -797,7 +797,7 @@ pub impl BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui),\n             m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail,\n+            (_,    Zero)   => die!(),\n             (Plus, Plus)  | (Zero, Plus)  => (d, m),\n             (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n                 (-d, Zero::zero())\n@@ -828,7 +828,7 @@ pub impl BigInt {\n         let q = BigInt::from_biguint(Plus, q_ui);\n         let r = BigInt::from_biguint(Plus, r_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail,\n+            (_,    Zero)   => die!(),\n             (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n             (Plus, Minus) | (Zero, Minus) => (-q,  r),\n             (Minus, Plus)                 => (-q, -r),\n@@ -1193,7 +1193,7 @@ mod biguint_tests {\n              ~\"2\" +\n              str::from_chars(vec::from_elem(bits / 2 - 1, '0')) + \"1\"),\n             (10, match bits {\n-                32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail\n+                32 => ~\"8589934593\", 16 => ~\"131073\", _ => die!()\n             }),\n             (16,\n              ~\"2\" +\n@@ -1210,7 +1210,7 @@ mod biguint_tests {\n             (10, match bits {\n                 32 => ~\"55340232229718589441\",\n                 16 => ~\"12885032961\",\n-                _ => fail\n+                _ => die!()\n             }),\n             (16, ~\"3\" +\n              str::from_chars(vec::from_elem(bits / 4 - 1, '0')) + \"2\" +\n@@ -1257,7 +1257,7 @@ mod biguint_tests {\n         fn check(n: uint, s: &str) {\n             let n = factor(n);\n             let ans = match BigUint::from_str_radix(s, 10) {\n-                Some(x) => x, None => fail\n+                Some(x) => x, None => die!()\n             };\n             assert n == ans;\n         }"}, {"sha": "d49c2ef95f6af8064944990083f1728f0ffa5d4d", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -106,10 +106,10 @@ impl SmallBitv {\n \n struct BigBitv {\n     // only mut b/c of clone and lack of other constructor\n-    mut storage: ~[mut uint]\n+    mut storage: ~[uint]\n }\n \n-fn BigBitv(storage: ~[mut uint]) -> BigBitv {\n+fn BigBitv(storage: ~[uint]) -> BigBitv {\n     BigBitv {storage: move storage}\n }\n \n@@ -233,7 +233,7 @@ pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n         let nelems = nbits/uint_bits +\n                      if nbits % uint_bits == 0 {0} else {1};\n         let elem = if init {!0} else {0};\n-        let s = cast_to_mut(from_elem(nelems, elem));\n+        let s = from_elem(nelems, elem);\n         Big(~BigBitv(move s))\n     };\n     Bitv {rep: move rep, nbits: nbits}\n@@ -242,7 +242,7 @@ pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n priv impl Bitv {\n \n     fn die() -> ! {\n-        fail ~\"Tried to do operation on bit vectors with different sizes\";\n+        die!(~\"Tried to do operation on bit vectors with different sizes\");\n     }\n \n     #[inline(always)]\n@@ -474,7 +474,7 @@ impl Bitv {\n      * The resulting string has the same length as `self`, and each\n      * character is either '0' or '1'.\n      */\n-     fn to_str() -> ~str {\n+     fn to_str(&self) -> ~str {\n        let mut rs = ~\"\";\n        for self.each() |i| { if i { rs += ~\"1\"; } else { rs += ~\"0\"; } };\n        rs\n@@ -518,7 +518,7 @@ impl Bitv: Clone {\n             Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n           }\n           Big(ref b) => {\n-            let st = cast_to_mut(from_elem(self.nbits / uint_bits + 1, 0));\n+            let mut st = from_elem(self.nbits / uint_bits + 1, 0);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n             Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: move st})}"}, {"sha": "aae84a8695783e39e2bf3c9117e7b629ded94195", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -34,7 +34,7 @@ impl<T> Cell<T> {\n     /// Yields the value, failing if the cell is empty.\n     fn take() -> T {\n         if self.is_empty() {\n-            fail ~\"attempt to take an empty cell\";\n+            die!(~\"attempt to take an empty cell\");\n         }\n \n         let mut value = None;\n@@ -45,7 +45,7 @@ impl<T> Cell<T> {\n     /// Returns the value, failing if the cell is full.\n     fn put_back(value: T) {\n         if !self.is_empty() {\n-            fail ~\"attempt to put a value back into a full cell\";\n+            die!(~\"attempt to put a value back into a full cell\");\n         }\n         self.value = Some(move value);\n     }"}, {"sha": "2f001ae866c6b7cb82290216dba1c84fb053b31e", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -58,7 +58,7 @@ pub fn create<T: Copy>() -> Deque<T> {\n         move rv\n     }\n     fn get<T: Copy>(elts: &DVec<Cell<T>>, i: uint) -> T {\n-        match (*elts).get_elt(i) { Some(move t) => t, _ => fail }\n+        match (*elts).get_elt(i) { Some(move t) => t, _ => die!() }\n     }\n \n     struct Repr<T> {"}, {"sha": "25deaf2a9b5961ae2fb10ebe2e603f9cace6397e", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -104,7 +104,7 @@ pub mod reader {\n                         (data[start + 2u] as uint) << 8u |\n                         (data[start + 3u] as uint),\n                     next: start + 4u};\n-        } else { error!(\"vint too big\"); fail; }\n+        } else { error!(\"vint too big\"); die!(); }\n     }\n \n     pub fn Doc(data: @~[u8]) -> Doc {\n@@ -140,7 +140,7 @@ pub mod reader {\n             Some(d) => d,\n             None => {\n                 error!(\"failed to find block with tag %u\", tg);\n-                fail;\n+                die!();\n             }\n         }\n     }\n@@ -227,7 +227,8 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = doc_as_str(r_doc);\n                     if lbl != str {\n-                        fail fmt!(\"Expected label %s but found %s\", lbl, str);\n+                        die!(fmt!(\"Expected label %s but found %s\", lbl,\n+                            str));\n                     }\n                 }\n             }\n@@ -236,20 +237,20 @@ pub mod reader {\n         fn next_doc(exp_tag: EbmlEncoderTag) -> Doc {\n             debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n             if self.pos >= self.parent.end {\n-                fail ~\"no more documents in current node!\";\n+                die!(~\"no more documents in current node!\");\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 doc_at(self.parent.data, self.pos);\n             debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                    copy self.parent.start, copy self.parent.end,\n                    copy self.pos, r_tag, r_doc.start, r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                fail fmt!(\"expected EBML doc with tag %? but found tag %?\",\n-                          exp_tag, r_tag);\n+                die!(fmt!(\"expected EBML doc with tag %? but found tag %?\",\n+                          exp_tag, r_tag));\n             }\n             if r_doc.end > self.parent.end {\n-                fail fmt!(\"invalid EBML, child extends to 0x%x, \\\n-                           parent to 0x%x\", r_doc.end, self.parent.end);\n+                die!(fmt!(\"invalid EBML, child extends to 0x%x, \\\n+                           parent to 0x%x\", r_doc.end, self.parent.end));\n             }\n             self.pos = r_doc.end;\n             r_doc\n@@ -291,7 +292,7 @@ pub mod reader {\n         fn read_uint(&self) -> uint {\n             let v = doc_as_u64(self.next_doc(EsUint));\n             if v > (::core::uint::max_value as u64) {\n-                fail fmt!(\"uint %? too large for this architecture\", v);\n+                die!(fmt!(\"uint %? too large for this architecture\", v));\n             }\n             v as uint\n         }\n@@ -303,22 +304,22 @@ pub mod reader {\n         fn read_int(&self) -> int {\n             let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n             if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-                fail fmt!(\"int %? out of range for this architecture\", v);\n+                die!(fmt!(\"int %? out of range for this architecture\", v));\n             }\n             v as int\n         }\n \n         fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool))\n                                          as bool }\n \n-        fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n-        fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n-        fn read_float(&self) -> float { fail ~\"read_float()\"; }\n+        fn read_f64(&self) -> f64 { die!(~\"read_f64()\"); }\n+        fn read_f32(&self) -> f32 { die!(~\"read_f32()\"); }\n+        fn read_float(&self) -> float { die!(~\"read_float()\"); }\n \n-        fn read_char(&self) -> char { fail ~\"read_char()\"; }\n+        fn read_char(&self) -> char { die!(~\"read_char()\"); }\n \n         fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n-        fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n+        fn read_managed_str(&self) -> @str { die!(~\"read_managed_str()\"); }\n \n         // Compound types:\n         fn read_owned<T>(&self, f: fn() -> T) -> T {\n@@ -427,7 +428,7 @@ pub mod writer {\n                             n as u8]),\n             4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n-            _ => fail fmt!(\"vint to write too big: %?\", n)\n+            _ => die!(fmt!(\"vint to write too big: %?\", n))\n         };\n     }\n \n@@ -436,7 +437,7 @@ pub mod writer {\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-        fail fmt!(\"vint to write too big: %?\", n);\n+        die!(fmt!(\"vint to write too big: %?\", n));\n     }\n \n     pub fn Encoder(w: io::Writer) -> Encoder {\n@@ -598,17 +599,17 @@ pub mod writer {\n \n         // FIXME (#2742): implement these\n         fn emit_f64(&self, _v: f64) {\n-            fail ~\"Unimplemented: serializing an f64\";\n+            die!(~\"Unimplemented: serializing an f64\");\n         }\n         fn emit_f32(&self, _v: f32) {\n-            fail ~\"Unimplemented: serializing an f32\";\n+            die!(~\"Unimplemented: serializing an f32\");\n         }\n         fn emit_float(&self, _v: float) {\n-            fail ~\"Unimplemented: serializing a float\";\n+            die!(~\"Unimplemented: serializing a float\");\n         }\n \n         fn emit_char(&self, _v: char) {\n-            fail ~\"Unimplemented: serializing a char\";\n+            die!(~\"Unimplemented: serializing a char\");\n         }\n \n         fn emit_borrowed_str(&self, v: &str) {"}, {"sha": "ba95fa5b66137acf7147da98e9fefc073893f444", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -262,7 +262,7 @@ pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n     fn recv() -> T {\n         match self.try_recv() {\n             Some(move val) => move val,\n-            None => fail ~\"port is closed\"\n+            None => die!(~\"port is closed\")\n         }\n     }\n     fn try_recv() -> Option<T> {\n@@ -298,7 +298,7 @@ pub impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P>: GenericPort<T> {\n             }\n         }\n         else {\n-            fail ~\"flatpipe: unrecognized command\";\n+            die!(~\"flatpipe: unrecognized command\");\n         }\n     }\n }\n@@ -480,7 +480,7 @@ pub mod flatteners {\n                 Ok(move json) => {\n                     json::Decoder(move json)\n                 }\n-                Err(e) => fail fmt!(\"flatpipe: can't parse json: %?\", e)\n+                Err(e) => die!(fmt!(\"flatpipe: can't parse json: %?\", e))\n             }\n         }\n     }"}, {"sha": "57b768a742f3c2f07056f46b1a57ac7882bba5ef", "filename": "src/libstd/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -65,14 +65,14 @@ impl<A> Future<A> {\n         unsafe {\n             match self.state {\n                 Forced(ref mut v) => { return cast::transmute(v); }\n-                Evaluating => fail ~\"Recursive forcing of future!\",\n+                Evaluating => die!(~\"Recursive forcing of future!\"),\n                 Pending(_) => {}\n             }\n \n             let mut state = Evaluating;\n             self.state <-> state;\n             match move state {\n-                Forced(_) | Evaluating => fail ~\"Logic error.\",\n+                Forced(_) | Evaluating => die!(~\"Logic error.\"),\n                 Pending(move f) => {\n                     self.state = Forced(move f());\n                     self.get_ref()\n@@ -195,7 +195,7 @@ pub mod test {\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n     pub fn test_futurefail() {\n-        let f = spawn(|| fail);\n+        let f = spawn(|| die!());\n         let _x: ~str = f.get();\n     }\n "}, {"sha": "6e1a08610350711863b78621850a0f0305cdd61d", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -56,7 +56,7 @@\n  *         ];\n  *         let matches = match getopts(vec::tail(args), opts) {\n  *             result::ok(m) { m }\n- *             result::err(f) { fail fail_str(f) }\n+ *             result::err(f) { die!(fail_str(f)) }\n  *         };\n  *         if opt_present(matches, \"h\") || opt_present(matches, \"help\") {\n  *             print_usage(program);\n@@ -348,7 +348,7 @@ fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {\n       Some(id) => mm.vals[id],\n       None => {\n         error!(\"No option '%s' defined\", nm);\n-        fail\n+        die!()\n       }\n     };\n }\n@@ -384,7 +384,7 @@ pub fn opts_present(mm: &Matches, names: &[~str]) -> bool {\n  * argument\n  */\n pub fn opt_str(mm: &Matches, nm: &str) -> ~str {\n-    return match opt_val(mm, nm) { Val(copy s) => s, _ => fail };\n+    return match opt_val(mm, nm) { Val(copy s) => s, _ => die!() };\n }\n \n /**\n@@ -400,7 +400,7 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n           _ => ()\n         }\n     }\n-    fail;\n+    die!();\n }\n \n \n@@ -550,7 +550,7 @@ pub mod groups {\n         match ((*lopt).short_name.len(),\n                (*lopt).long_name.len()) {\n \n-           (0,0) => fail ~\"this long-format option was given no name\",\n+           (0,0) => die!(~\"this long-format option was given no name\"),\n \n            (0,_) => ~[Opt {name:   Long(((*lopt).long_name)),\n                            hasarg: (*lopt).hasarg,\n@@ -567,7 +567,7 @@ pub mod groups {\n                            hasarg: (*lopt).hasarg,\n                            occur:  (*lopt).occur}],\n \n-           (_,_) => fail ~\"something is wrong with the long-form opt\"\n+           (_,_) => die!(~\"something is wrong with the long-form opt\")\n         }\n     }\n \n@@ -598,7 +598,7 @@ pub mod groups {\n             row += match short_name.len() {\n                 0 => ~\"\",\n                 1 => ~\"-\" + short_name + \" \",\n-                _ => fail ~\"the short name should only be 1 char long\",\n+                _ => die!(~\"the short name should only be 1 char long\"),\n             };\n \n             // long option\n@@ -668,7 +668,7 @@ mod tests {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n-          _ => { fail ~\"test_reqopt_long failed\"; }\n+          _ => { die!(~\"test_reqopt_long failed\"); }\n         }\n     }\n \n@@ -679,7 +679,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -690,7 +690,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -701,7 +701,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -715,7 +715,7 @@ mod tests {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -726,7 +726,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -737,7 +737,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -748,7 +748,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -764,7 +764,7 @@ mod tests {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -775,7 +775,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -786,7 +786,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -797,7 +797,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -811,7 +811,7 @@ mod tests {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -822,7 +822,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -833,7 +833,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -844,7 +844,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -857,7 +857,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (opt_present(m, ~\"test\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -868,7 +868,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -882,7 +882,7 @@ mod tests {\n             log(error, fail_str(f));\n             check_fail_type(f, UnexpectedArgument_);\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -893,7 +893,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -904,7 +904,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (opt_present(m, ~\"t\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -915,7 +915,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -930,7 +930,7 @@ mod tests {\n \n             assert (m.free[0] == ~\"20\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -941,7 +941,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -955,7 +955,7 @@ mod tests {\n           Ok(ref m) => {\n             assert (opt_count(m, ~\"v\") == 1);\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -968,7 +968,7 @@ mod tests {\n           Ok(ref m) => {\n             assert (opt_count(m, ~\"v\") == 2);\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -981,7 +981,7 @@ mod tests {\n           Ok(ref m) => {\n             assert (opt_count(m, ~\"v\") == 2);\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -994,7 +994,7 @@ mod tests {\n           Ok(ref m) => {\n             assert (opt_count(m, ~\"verbose\") == 1);\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1007,7 +1007,7 @@ mod tests {\n           Ok(ref m) => {\n             assert (opt_count(m, ~\"verbose\") == 2);\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1022,7 +1022,7 @@ mod tests {\n             assert (opt_present(m, ~\"test\"));\n             assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1033,7 +1033,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1044,7 +1044,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1061,7 +1061,7 @@ mod tests {\n               assert (pair[0] == ~\"20\");\n               assert (pair[1] == ~\"30\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1075,7 +1075,7 @@ mod tests {\n             assert (opt_present(m, ~\"t\"));\n             assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1086,7 +1086,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1097,7 +1097,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1114,7 +1114,7 @@ mod tests {\n             assert (pair[0] == ~\"20\");\n             assert (pair[1] == ~\"30\");\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1125,7 +1125,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1136,7 +1136,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1168,7 +1168,7 @@ mod tests {\n             assert (pair[1] == ~\"-60 70\");\n             assert (!opt_present(m, ~\"notpresent\"));\n           }\n-          _ => fail\n+          _ => die!()\n         }\n     }\n \n@@ -1178,7 +1178,7 @@ mod tests {\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(move m) => m,\n-          result::Err(_) => fail\n+          result::Err(_) => die!()\n         };\n         assert opts_present(matches, ~[~\"e\"]);\n         assert opts_present(matches, ~[~\"encrypt\"]);\n@@ -1199,7 +1199,7 @@ mod tests {\n         let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(move m) => m,\n-          result::Err(_) => fail\n+          result::Err(_) => die!()\n         };\n         assert opts_present(matches, ~[~\"L\"]);\n         assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";"}, {"sha": "9a90b811e44c540fbca0a48fa328754356ef0ff3", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -43,7 +43,7 @@ pub impl BufReader {\n }\n \n impl BufReader: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         self.as_bytes_reader(|r| r.read(bytes, len) )\n     }\n     fn read_byte(&self) -> int {"}, {"sha": "4b34f318e91b28501360a716d1e6601fb99d3084", "filename": "src/libstd/json.rs", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -109,7 +109,7 @@ pub impl Encoder: serialize::Encoder {\n     fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n     fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n     fn emit_float(&self, v: float) {\n-        self.wr.write_str(float::to_str(v, 6u));\n+        self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n     fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }\n@@ -123,7 +123,7 @@ pub impl Encoder: serialize::Encoder {\n     fn emit_managed(&self, f: fn()) { f() }\n \n     fn emit_enum(&self, name: &str, f: fn()) {\n-        if name != \"option\" { fail ~\"only supports option enum\" }\n+        if name != \"option\" { die!(~\"only supports option enum\") }\n         f()\n     }\n     fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n@@ -213,7 +213,7 @@ pub impl PrettyEncoder: serialize::Encoder {\n     fn emit_f64(&self, v: f64) { self.emit_float(v as float); }\n     fn emit_f32(&self, v: f32) { self.emit_float(v as float); }\n     fn emit_float(&self, v: float) {\n-        self.wr.write_str(float::to_str(v, 6u));\n+        self.wr.write_str(float::to_str_digits(v, 6u));\n     }\n \n     fn emit_char(&self, v: char) { self.emit_borrowed_str(str::from_char(v)) }\n@@ -227,7 +227,7 @@ pub impl PrettyEncoder: serialize::Encoder {\n     fn emit_managed(&self, f: fn()) { f() }\n \n     fn emit_enum(&self, name: &str, f: fn()) {\n-        if name != \"option\" { fail ~\"only supports option enum\" }\n+        if name != \"option\" { die!(~\"only supports option enum\") }\n         f()\n     }\n     fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n@@ -743,7 +743,7 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_nil\");\n         match *self.pop() {\n             Null => (),\n-            _ => fail ~\"not a null\"\n+            _ => die!(~\"not a null\")\n         }\n     }\n \n@@ -763,7 +763,7 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_bool\");\n         match *self.pop() {\n             Boolean(b) => b,\n-            _ => fail ~\"not a boolean\"\n+            _ => die!(~\"not a boolean\")\n         }\n     }\n \n@@ -773,29 +773,29 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_float\");\n         match *self.pop() {\n             Number(f) => f,\n-            _ => fail ~\"not a number\"\n+            _ => die!(~\"not a number\")\n         }\n     }\n \n     fn read_char(&self) -> char {\n         let v = str::chars(self.read_owned_str());\n-        if v.len() != 1 { fail ~\"string must have one character\" }\n+        if v.len() != 1 { die!(~\"string must have one character\") }\n         v[0]\n     }\n \n     fn read_owned_str(&self) -> ~str {\n         debug!(\"read_owned_str\");\n         match *self.pop() {\n             String(ref s) => copy *s,\n-            _ => fail ~\"not a string\"\n+            _ => die!(~\"not a string\")\n         }\n     }\n \n     fn read_managed_str(&self) -> @str {\n         debug!(\"read_managed_str\");\n         match *self.pop() {\n             String(ref s) => s.to_managed(),\n-            _ => fail ~\"not a string\"\n+            _ => die!(~\"not a string\")\n         }\n     }\n \n@@ -811,7 +811,7 @@ pub impl Decoder: serialize::Decoder {\n \n     fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n-        if name != ~\"option\" { fail ~\"only supports the option enum\" }\n+        if name != ~\"option\" { die!(~\"only supports the option enum\") }\n         f()\n     }\n \n@@ -826,15 +826,15 @@ pub impl Decoder: serialize::Decoder {\n \n     fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        if idx != 0 { fail ~\"unknown index\" }\n+        if idx != 0 { die!(~\"unknown index\") }\n         f()\n     }\n \n     fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n         debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n             List(list) => list.len(),\n-            _ => fail ~\"not a list\",\n+            _ => die!(~\"not a list\"),\n         };\n         let res = f(len);\n         self.pop();\n@@ -845,7 +845,7 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n             List(ref list) => list.len(),\n-            _ => fail ~\"not a list\",\n+            _ => die!(~\"not a list\"),\n         };\n         let res = f(len);\n         self.pop();\n@@ -862,7 +862,7 @@ pub impl Decoder: serialize::Decoder {\n                 self.stack.push(&list[idx]);\n                 f()\n             }\n-            _ => fail ~\"not a list\",\n+            _ => die!(~\"not a list\"),\n         }\n     }\n \n@@ -889,20 +889,20 @@ pub impl Decoder: serialize::Decoder {\n                 let obj: &self/~Object = obj;\n \n                 match obj.find(&name.to_owned()) {\n-                    None => fail fmt!(\"no such field: %s\", name),\n+                    None => die!(fmt!(\"no such field: %s\", name)),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f()\n                     }\n                 }\n             }\n-            Number(_) => fail ~\"num\",\n-            String(_) => fail ~\"str\",\n-            Boolean(_) => fail ~\"bool\",\n-            List(_) => fail fmt!(\"list: %?\", top),\n-            Null => fail ~\"null\",\n+            Number(_) => die!(~\"num\"),\n+            String(_) => die!(~\"str\"),\n+            Boolean(_) => die!(~\"bool\"),\n+            List(_) => die!(fmt!(\"list: %?\", top)),\n+            Null => die!(~\"null\"),\n \n-            //_ => fail fmt!(\"not an object: %?\", *top)\n+            //_ => die!(fmt!(\"not an object: %?\", *top))\n         }\n     }\n \n@@ -922,7 +922,7 @@ pub impl Decoder: serialize::Decoder {\n                 self.stack.push(&list[idx]);\n                 f()\n             }\n-            _ => fail ~\"not a list\"\n+            _ => die!(~\"not a list\")\n         }\n     }\n }\n@@ -1162,18 +1162,6 @@ impl <A: ToJson Copy> LinearMap<~str, A>: ToJson {\n     }\n }\n \n-/*\n-impl <A: ToJson Copy> @std::map::HashMap<~str, A>: ToJson {\n-    fn to_json() -> Json {\n-        let mut d = LinearMap::new();\n-        for self.each_ref |key, value| {\n-            d.insert(copy *key, value.to_json());\n-        }\n-        Object(~d)\n-    }\n-}\n-*/\n-\n impl <A: ToJson> Option<A>: ToJson {\n     fn to_json() -> Json {\n         match self {\n@@ -1184,11 +1172,11 @@ impl <A: ToJson> Option<A>: ToJson {\n }\n \n impl Json: to_str::ToStr {\n-    pure fn to_str() -> ~str { to_str(&self) }\n+    pure fn to_str(&self) -> ~str { to_str(self) }\n }\n \n impl Error: to_str::ToStr {\n-    pure fn to_str() -> ~str {\n+    pure fn to_str(&self) -> ~str {\n         fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }"}, {"sha": "3016abee464da8f7f5f2a6c6b2491b6029352d98", "filename": "src/libstd/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -94,7 +94,7 @@ pub pure fn len<T>(ls: @List<T>) -> uint {\n pub pure fn tail<T: Copy>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n-        Nil => fail ~\"list empty\"\n+        Nil => die!(~\"list empty\")\n     }\n }\n \n@@ -103,7 +103,7 @@ pub pure fn head<T: Copy>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(copy hd, _) => hd,\n       // makes me sad\n-      _ => fail ~\"head invoked on empty list\"\n+      _ => die!(~\"head invoked on empty list\")\n     }\n }\n "}, {"sha": "e1e2bb2697f8cdc73a180b98c118800be0c699a2", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -109,7 +109,7 @@ pub pure fn md4_str(msg: &[u8]) -> ~str {\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;\n             if byte <= 16u8 { result += ~\"0\"; }\n-            result += uint::to_str(byte as uint, 16u);\n+            result += uint::to_str_radix(byte as uint, 16u);\n             i += 1u32;\n         }\n     }"}, {"sha": "f4fd69aae1e12380a3f44fd08eb9536e4683c770", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -64,14 +64,14 @@ pub fn format_addr(ip: &IpAddr) -> ~str {\n       Ipv4(ref addr) =>  unsafe {\n         let result = uv_ip4_name(addr);\n         if result == ~\"\" {\n-            fail ~\"failed to convert inner sockaddr_in address to str\"\n+            die!(~\"failed to convert inner sockaddr_in address to str\")\n         }\n         result\n       },\n       Ipv6(ref addr) => unsafe {\n         let result = uv_ip6_name(addr);\n         if result == ~\"\" {\n-            fail ~\"failed to convert inner sockaddr_in address to str\"\n+            die!(~\"failed to convert inner sockaddr_in address to str\")\n         }\n         result\n       }\n@@ -183,7 +183,7 @@ pub mod v4 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(move addr) => move addr,\n-          result::Err(ref err_data) => fail err_data.err_msg\n+          result::Err(ref err_data) => die!(err_data.err_msg)\n         }\n     }\n     // the simple, old style numberic representation of\n@@ -278,7 +278,7 @@ pub mod v6 {\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(move addr) => move addr,\n-          result::Err(copy err_data) => fail err_data.err_msg\n+          result::Err(copy err_data) => die!(err_data.err_msg)\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n@@ -400,7 +400,7 @@ mod test {\n             assert true;\n           }\n           result::Ok(ref addr) => {\n-            fail fmt!(\"Expected failure, but got addr %?\", addr);\n+            die!(fmt!(\"Expected failure, but got addr %?\", addr));\n           }\n         }\n     }\n@@ -413,7 +413,7 @@ mod test {\n             assert true;\n           }\n           result::Ok(ref addr) => {\n-            fail fmt!(\"Expected failure, but got addr %?\", addr);\n+            die!(fmt!(\"Expected failure, but got addr %?\", addr));\n           }\n         }\n     }\n@@ -424,7 +424,7 @@ mod test {\n         let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n         if result::is_err(&ga_result) {\n-            fail ~\"got err result from net::ip::get_addr();\"\n+            die!(~\"got err result from net::ip::get_addr();\")\n         }\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm."}, {"sha": "429bd6ae474556539ffc5fd927a7cae5e24823f0", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -863,7 +863,7 @@ impl TcpSocket {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n-    fn read(&self, buf: &[mut u8], len: uint) -> uint {\n+    fn read(&self, buf: &mut [u8], len: uint) -> uint {\n         if len == 0 { return 0 }\n         let mut count: uint = 0;\n \n@@ -940,7 +940,7 @@ impl TcpSocketBuf: io::Reader {\n               } else {\n                   debug!(\"ERROR sock_buf as io::reader.read err %? %?\",\n                          err_data.err_name, err_data.err_msg);\n-                  fail\n+                  die!()\n               }\n           }\n           else {\n@@ -1644,7 +1644,7 @@ pub mod test {\n             hl_loop);\n         match actual_resp_result.get_err() {\n           ConnectionRefused => (),\n-          _ => fail ~\"unknown error.. expected connection_refused\"\n+          _ => die!(~\"unknown error.. expected connection_refused\")\n         }\n     }\n     pub fn impl_gl_tcp_ipv4_server_address_in_use() {\n@@ -1685,8 +1685,8 @@ pub mod test {\n             assert true;\n           }\n           _ => {\n-            fail ~\"expected address_in_use listen error,\"+\n-                ~\"but got a different error varient. check logs.\";\n+            die!(~\"expected address_in_use listen error,\"+\n+                ~\"but got a different error varient. check logs.\");\n           }\n         }\n     }\n@@ -1704,8 +1704,8 @@ pub mod test {\n             assert true;\n           }\n           _ => {\n-            fail ~\"expected address_in_use listen error,\"+\n-                      ~\"but got a different error varient. check logs.\";\n+            die!(~\"expected address_in_use listen error,\"+\n+                      ~\"but got a different error varient. check logs.\");\n           }\n         }\n     }\n@@ -1884,14 +1884,14 @@ pub mod test {\n         if result::is_err(&listen_result) {\n             match result::get_err(&listen_result) {\n               GenericListenErr(ref name, ref msg) => {\n-                fail fmt!(\"SERVER: exited abnormally name %s msg %s\",\n-                                *name, *msg);\n+                die!(fmt!(\"SERVER: exited abnormally name %s msg %s\",\n+                                *name, *msg));\n               }\n               AccessDenied => {\n-                fail ~\"SERVER: exited abnormally, got access denied..\";\n+                die!(~\"SERVER: exited abnormally, got access denied..\");\n               }\n               AddressInUse => {\n-                fail ~\"SERVER: exited abnormally, got address in use...\";\n+                die!(~\"SERVER: exited abnormally, got address in use...\");\n               }\n             }\n         }\n@@ -1910,15 +1910,15 @@ pub mod test {\n                 debug!(\"establish_cb %?\", kill_ch);\n             },\n             |new_conn, kill_ch| {\n-                fail fmt!(\"SERVER: shouldn't be called.. %? %?\",\n-                           new_conn, kill_ch);\n+                die!(fmt!(\"SERVER: shouldn't be called.. %? %?\",\n+                           new_conn, kill_ch));\n         });\n         // err check on listen_result\n         if result::is_err(&listen_result) {\n             result::get_err(&listen_result)\n         }\n         else {\n-            fail ~\"SERVER: did not fail as expected\"\n+            die!(~\"SERVER: did not fail as expected\")\n         }\n     }\n \n@@ -1962,7 +1962,7 @@ pub mod test {\n             debug!(\"tcp_write_single err name: %s msg: %s\",\n                 err_data.err_name, err_data.err_msg);\n             // meh. torn on what to do here.\n-            fail ~\"tcp_write_single failed\";\n+            die!(~\"tcp_write_single failed\");\n         }\n     }\n }"}, {"sha": "b32c97c699837744ea434d8963157df381c68c3f", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -718,8 +718,8 @@ pub pure fn to_str(url: &Url) -> ~str {\n }\n \n impl Url: to_str::ToStr {\n-    pub pure fn to_str() -> ~str {\n-        to_str(&self)\n+    pub pure fn to_str(&self) -> ~str {\n+        to_str(self)\n     }\n }\n "}, {"sha": "a4d4a4e806b0dd566b0dd64e486fa5ab0d625e5c", "filename": "src/libstd/oldmap.rs", "status": "renamed", "additions": 78, "deletions": 164, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A map type\n+//! A map type - **deprecated**, use `core::hashmap` instead\n #[forbid(deprecated_mode)];\n \n+use core::container::{Container, Mutable, Map};\n use core::cmp::Eq;\n use core::hash::Hash;\n use core::io::WriterUtil;\n use core::io;\n use core::ops;\n use core::to_str::ToStr;\n-use core::mutable::Mut;\n use core::prelude::*;\n use core::to_bytes::IterBytes;\n use core::uint;\n@@ -28,84 +28,6 @@ pub type Set<K> = HashMap<K, ()>;\n \n pub type HashMap<K, V> = chained::T<K, V>;\n \n-pub trait StdMap<K:Eq IterBytes Hash Copy, V: Copy> {\n-    /// Return the number of elements in the map\n-    pure fn size() -> uint;\n-\n-    /**\n-     * Add a value to the map.\n-     *\n-     * If the map already contains a value for the specified key then the\n-     * original value is replaced.\n-     *\n-     * Returns true if the key did not already exist in the map\n-     */\n-    fn insert(key: K, value: V) -> bool;\n-\n-    /**\n-     * Add a value to the map.\n-     *\n-     * If the map contains a value for the key, use the function\n-     * to set a new value.\n-     */\n-    fn update_with_key(key: K, newval: V, ff: fn(K, V, V) -> V) -> bool;\n-\n-    /**\n-     * Add a value to the map.\n-     *\n-     * If the map contains a value for the key, use the function to\n-     * set a new value.  (Like `update_with_key`, but with a\n-     * function of only values.)\n-     */\n-    fn update(key: K, newval: V, ff: fn(V, V) -> V) -> bool;\n-\n-    /// Returns true if the map contains a value for the specified key\n-    pure fn contains_key(key: K) -> bool;\n-\n-    /// Returns true if the map contains a value for the specified\n-    /// key, taking the key by reference.\n-    pure fn contains_key_ref(key: &K) -> bool;\n-\n-    /**\n-     * Get the value for the specified key. Fails if the key does not exist in\n-     * the map.\n-     */\n-    pure fn get(key: K) -> V;\n-\n-    /**\n-     * Get the value for the specified key. If the key does not exist in\n-     * the map then returns none.\n-     */\n-    pure fn find(key: K) -> Option<V>;\n-\n-    /**\n-     * Remove and return a value from the map. Returns true if the\n-     * key was present in the map, otherwise false.\n-     */\n-    fn remove(key: K) -> bool;\n-\n-    /// Clear the map, removing all key/value pairs.\n-    fn clear();\n-\n-    /// Iterate over all the key/value pairs in the map by value\n-    pure fn each(fn(key: K, value: V) -> bool);\n-\n-    /// Iterate over all the keys in the map by value\n-    pure fn each_key(fn(key: K) -> bool);\n-\n-    /// Iterate over all the values in the map by value\n-    pure fn each_value(fn(value: V) -> bool);\n-\n-    /// Iterate over all the key/value pairs in the map by reference\n-    pure fn each_ref(fn(key: &K, value: &V) -> bool);\n-\n-    /// Iterate over all the keys in the map by reference\n-    pure fn each_key_ref(fn(key: &K) -> bool);\n-\n-    /// Iterate over all the values in the map by reference\n-    pure fn each_value_ref(fn(value: &V) -> bool);\n-}\n-\n pub mod util {\n     pub struct Rational {\n         // : int::positive(*.den);\n@@ -124,7 +46,7 @@ pub mod util {\n // FIXME (#2344): package this up and export it as a datatype usable for\n // external code that doesn't want to pay the cost of a box.\n pub mod chained {\n-    use map::{StdMap, util};\n+    use super::util;\n \n     use core::io;\n     use core::ops;\n@@ -144,7 +66,7 @@ pub mod chained {\n \n     struct HashMap_<K, V> {\n         mut count: uint,\n-        mut chains: ~[mut Option<@Entry<K,V>>]\n+        mut chains: ~[Option<@Entry<K,V>>]\n     }\n \n     pub type T<K, V> = @HashMap_<K, V>;\n@@ -209,7 +131,7 @@ pub mod chained {\n         fn rehash() {\n             let n_old_chains = self.chains.len();\n             let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n-            let new_chains = chains(n_new_chains);\n+            let mut new_chains = chains(n_new_chains);\n             for self.each_entry |entry| {\n                 let idx = entry.hash % n_new_chains;\n                 entry.next = new_chains[idx];\n@@ -239,14 +161,20 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: StdMap<K, V> {\n-        pure fn size() -> uint { self.count }\n+    impl<K: Eq IterBytes Hash, V> T<K, V>: Container {\n+        pure fn len(&self) -> uint { self.count }\n+        pure fn is_empty(&self) -> bool { self.count == 0 }\n+    }\n \n-        pure fn contains_key(k: K) -> bool {\n-            self.contains_key_ref(&k)\n+    impl<K: Eq IterBytes Hash, V> T<K, V>: Mutable {\n+        fn clear(&mut self) {\n+            self.count = 0u;\n+            self.chains = chains(initial_capacity);\n         }\n+    }\n \n-        pure fn contains_key_ref(k: &K) -> bool {\n+    impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V> {\n+        pure fn contains_key_ref(&self, k: &K) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n               NotFound => false,\n@@ -298,7 +226,7 @@ pub mod chained {\n             }\n         }\n \n-        pure fn find(k: K) -> Option<V> {\n+        pure fn find(&self, k: K) -> Option<V> {\n             unsafe {\n                 match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n                   NotFound => None,\n@@ -363,16 +291,16 @@ pub mod chained {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n-        pure fn get(k: K) -> V {\n+        pure fn get(&self, k: K) -> V {\n             let opt_v = self.find(k);\n             if opt_v.is_none() {\n-                fail fmt!(\"Key not found in table: %?\", k);\n+                die!(fmt!(\"Key not found in table: %?\", k));\n             }\n             option::unwrap(move opt_v)\n         }\n \n-        fn remove(k: K) -> bool {\n-            match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n+        fn remove(k: &K) -> bool {\n+            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n               NotFound => false,\n               FoundFirst(idx, entry) => {\n                 self.count -= 1u;\n@@ -387,34 +315,17 @@ pub mod chained {\n             }\n         }\n \n-        fn clear() {\n-            self.count = 0u;\n-            self.chains = chains(initial_capacity);\n-        }\n-\n-        pure fn each(blk: fn(key: K, value: V) -> bool) {\n-            self.each_ref(|k, v| blk(*k, *v))\n-        }\n-\n-        pure fn each_key(blk: fn(key: K) -> bool) {\n-            self.each_key_ref(|p| blk(*p))\n-        }\n-\n-        pure fn each_value(blk: fn(value: V) -> bool) {\n-            self.each_value_ref(|p| blk(*p))\n-        }\n-\n-        pure fn each_ref(blk: fn(key: &K, value: &V) -> bool) {\n+        pure fn each_ref(&self, blk: fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n                 if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        pure fn each_key_ref(blk: fn(key: &K) -> bool) {\n+        pure fn each_key_ref(&self, blk: fn(key: &K) -> bool) {\n             self.each_ref(|k, _v| blk(k))\n         }\n \n-        pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n+        pure fn each_value_ref(&self, blk: fn(value: &V) -> bool) {\n             self.each_ref(|_k, v| blk(v))\n         }\n     }\n@@ -442,7 +353,7 @@ pub mod chained {\n     }\n \n     impl<K:Eq IterBytes Hash Copy ToStr, V: ToStr Copy> T<K, V>: ToStr {\n-        pure fn to_str() -> ~str {\n+        pure fn to_str(&self) -> ~str {\n             unsafe {\n                 // Meh -- this should be safe\n                 do io::with_str_writer |wr| { self.to_writer(wr) }\n@@ -458,8 +369,8 @@ pub mod chained {\n         }\n     }\n \n-    fn chains<K,V>(nchains: uint) -> ~[mut Option<@Entry<K,V>>] {\n-        vec::cast_to_mut(vec::from_elem(nchains, None))\n+    fn chains<K,V>(nchains: uint) -> ~[Option<@Entry<K,V>>] {\n+        vec::from_elem(nchains, None)\n     }\n \n     pub fn mk<K:Eq IterBytes Hash, V: Copy>() -> T<K,V> {\n@@ -486,8 +397,8 @@ pub fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, key: K) -> bool {\n \n /// Convert a set into a vector.\n pub pure fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n-    do vec::build_sized(s.size()) |push| {\n-        for s.each_key() |k| {\n+    do vec::build_sized(s.len()) |push| {\n+        for s.each_key_ref() |&k| {\n             push(k);\n         }\n     }\n@@ -509,20 +420,20 @@ pub fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n \n #[cfg(test)]\n mod tests {\n-    use map;\n-\n     use core::option::None;\n     use core::option;\n     use core::uint;\n \n+    use super::*;\n+\n     #[test]\n     fn test_simple() {\n         debug!(\"*** starting test_simple\");\n         pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n         pure fn uint_id(x: &uint) -> uint { *x }\n         debug!(\"uint -> uint\");\n-        let hm_uu: map::HashMap<uint, uint> =\n-            map::HashMap::<uint, uint>();\n+        let hm_uu: HashMap<uint, uint> =\n+            HashMap::<uint, uint>();\n         assert (hm_uu.insert(10u, 12u));\n         assert (hm_uu.insert(11u, 13u));\n         assert (hm_uu.insert(12u, 14u));\n@@ -537,8 +448,8 @@ mod tests {\n         let eleven: ~str = ~\"eleven\";\n         let twelve: ~str = ~\"twelve\";\n         debug!(\"str -> uint\");\n-        let hm_su: map::HashMap<~str, uint> =\n-            map::HashMap::<~str, uint>();\n+        let hm_su: HashMap<~str, uint> =\n+            HashMap::<~str, uint>();\n         assert (hm_su.insert(~\"ten\", 12u));\n         assert (hm_su.insert(eleven, 13u));\n         assert (hm_su.insert(~\"twelve\", 14u));\n@@ -551,8 +462,8 @@ mod tests {\n         assert (!hm_su.insert(~\"twelve\", 12u));\n         assert (hm_su.get(~\"twelve\") == 12u);\n         debug!(\"uint -> str\");\n-        let hm_us: map::HashMap<uint, ~str> =\n-            map::HashMap::<uint, ~str>();\n+        let hm_us: HashMap<uint, ~str> =\n+            HashMap::<uint, ~str>();\n         assert (hm_us.insert(10u, ~\"twelve\"));\n         assert (hm_us.insert(11u, ~\"thirteen\"));\n         assert (hm_us.insert(12u, ~\"fourteen\"));\n@@ -564,8 +475,8 @@ mod tests {\n         assert (!hm_us.insert(12u, ~\"twelve\"));\n         assert hm_us.get(12u) == ~\"twelve\";\n         debug!(\"str -> str\");\n-        let hm_ss: map::HashMap<~str, ~str> =\n-            map::HashMap::<~str, ~str>();\n+        let hm_ss: HashMap<~str, ~str> =\n+            HashMap::<~str, ~str>();\n         assert (hm_ss.insert(ten, ~\"twelve\"));\n         assert (hm_ss.insert(eleven, ~\"thirteen\"));\n         assert (hm_ss.insert(twelve, ~\"fourteen\"));\n@@ -590,8 +501,8 @@ mod tests {\n         pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n         pure fn uint_id(x: &uint) -> uint { *x }\n         debug!(\"uint -> uint\");\n-        let hm_uu: map::HashMap<uint, uint> =\n-            map::HashMap::<uint, uint>();\n+        let hm_uu: HashMap<uint, uint> =\n+            HashMap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm_uu.insert(i, i * i));\n@@ -615,36 +526,39 @@ mod tests {\n             i += 1u;\n         }\n         debug!(\"str -> str\");\n-        let hm_ss: map::HashMap<~str, ~str> =\n-            map::HashMap::<~str, ~str>();\n+        let hm_ss: HashMap<~str, ~str> =\n+            HashMap::<~str, ~str>();\n         i = 0u;\n         while i < num_to_insert {\n-            assert hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u));\n+            assert hm_ss.insert(uint::to_str_radix(i, 2u),\n+                                uint::to_str_radix(i * i, 2u));\n             debug!(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n-                   uint::to_str(i, 2u),\n-                   uint::to_str(i*i, 2u));\n+                   uint::to_str_radix(i, 2u),\n+                   uint::to_str_radix(i*i, 2u));\n             i += 1u;\n         }\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n-                   uint::to_str(i, 2u),\n-                   hm_ss.get(uint::to_str(i, 2u)));\n-            assert hm_ss.get(uint::to_str(i, 2u)) == uint::to_str(i * i, 2u);\n+                   uint::to_str_radix(i, 2u),\n+                   hm_ss.get(uint::to_str_radix(i, 2u)));\n+            assert hm_ss.get(uint::to_str_radix(i, 2u)) ==\n+                             uint::to_str_radix(i * i, 2u);\n             i += 1u;\n         }\n-        assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n-                             uint::to_str(17u, 2u)));\n-        assert hm_ss.get(uint::to_str(num_to_insert, 2u)) ==\n-            uint::to_str(17u, 2u);\n+        assert (hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n+                             uint::to_str_radix(17u, 2u)));\n+        assert hm_ss.get(uint::to_str_radix(num_to_insert, 2u)) ==\n+            uint::to_str_radix(17u, 2u);\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n-                   uint::to_str(i, 2u),\n-                   hm_ss.get(uint::to_str(i, 2u)));\n-            assert hm_ss.get(uint::to_str(i, 2u)) == uint::to_str(i * i, 2u);\n+                   uint::to_str_radix(i, 2u),\n+                   hm_ss.get(uint::to_str_radix(i, 2u)));\n+            assert hm_ss.get(uint::to_str_radix(i, 2u)) ==\n+                             uint::to_str_radix(i * i, 2u);\n             i += 1u;\n         }\n         debug!(\"*** finished test_growth\");\n@@ -654,24 +568,24 @@ mod tests {\n     fn test_removal() {\n         debug!(\"*** starting test_removal\");\n         let num_to_insert: uint = 64u;\n-        let hm: map::HashMap<uint, uint> =\n-            map::HashMap::<uint, uint>();\n+        let hm: HashMap<uint, uint> =\n+            HashMap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm.insert(i, i * i));\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 1u;\n         }\n-        assert (hm.size() == num_to_insert);\n+        assert (hm.len() == num_to_insert);\n         debug!(\"-----\");\n         debug!(\"removing evens\");\n         i = 0u;\n         while i < num_to_insert {\n-            let v = hm.remove(i);\n+            let v = hm.remove(&i);\n             assert v;\n             i += 2u;\n         }\n-        assert (hm.size() == num_to_insert / 2u);\n+        assert (hm.len() == num_to_insert / 2u);\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n@@ -693,7 +607,7 @@ mod tests {\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 2u;\n         }\n-        assert (hm.size() == num_to_insert);\n+        assert (hm.len() == num_to_insert);\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n@@ -702,7 +616,7 @@ mod tests {\n             i += 1u;\n         }\n         debug!(\"-----\");\n-        assert (hm.size() == num_to_insert);\n+        assert (hm.len() == num_to_insert);\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(i));\n@@ -715,16 +629,16 @@ mod tests {\n     #[test]\n     fn test_contains_key() {\n         let key = ~\"k\";\n-        let map = map::HashMap::<~str, ~str>();\n-        assert (!map.contains_key(key));\n+        let map = HashMap::<~str, ~str>();\n+        assert (!map.contains_key_ref(&key));\n         map.insert(key, ~\"val\");\n-        assert (map.contains_key(key));\n+        assert (map.contains_key_ref(&key));\n     }\n \n     #[test]\n     fn test_find() {\n         let key = ~\"k\";\n-        let map = map::HashMap::<~str, ~str>();\n+        let map = HashMap::<~str, ~str>();\n         assert (option::is_none(&map.find(key)));\n         map.insert(key, ~\"val\");\n         assert (option::get(map.find(key)) == ~\"val\");\n@@ -733,31 +647,31 @@ mod tests {\n     #[test]\n     fn test_clear() {\n         let key = ~\"k\";\n-        let map = map::HashMap::<~str, ~str>();\n+        let mut map = HashMap::<~str, ~str>();\n         map.insert(key, ~\"val\");\n-        assert (map.size() == 1);\n-        assert (map.contains_key(key));\n+        assert (map.len() == 1);\n+        assert (map.contains_key_ref(&key));\n         map.clear();\n-        assert (map.size() == 0);\n-        assert (!map.contains_key(key));\n+        assert (map.len() == 0);\n+        assert (!map.contains_key_ref(&key));\n     }\n \n     #[test]\n     fn test_hash_from_vec() {\n-        let map = map::hash_from_vec(~[\n+        let map = hash_from_vec(~[\n             (~\"a\", 1),\n             (~\"b\", 2),\n             (~\"c\", 3)\n         ]);\n-        assert map.size() == 3u;\n+        assert map.len() == 3u;\n         assert map.get(~\"a\") == 1;\n         assert map.get(~\"b\") == 2;\n         assert map.get(~\"c\") == 3;\n     }\n \n     #[test]\n     fn test_update_with_key() {\n-        let map = map::HashMap::<~str, uint>();\n+        let map = HashMap::<~str, uint>();\n \n         // given a new key, initialize it with this new count, given\n         // given an existing key, add more to its count", "previous_filename": "src/libstd/map.rs"}, {"sha": "803e75e4cf7a3c034146b2db63267bbb31856b87", "filename": "src/libstd/oldsmallintmap.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Foldsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Foldsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldsmallintmap.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * A simple map based on a vector for small integer keys. Space requirements\n+ * are O(highest integer key).\n+ */\n+#[forbid(deprecated_mode)];\n+\n+use core::container::{Container, Mutable, Map, Set};\n+use core::dvec::DVec;\n+use core::ops;\n+use core::option::{Some, None};\n+use core::option;\n+use core::prelude::*;\n+\n+// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n+// requires this to be.\n+struct SmallIntMap_<T> {\n+    v: DVec<Option<T>>,\n+}\n+\n+pub enum SmallIntMap<T> {\n+    SmallIntMap_(@SmallIntMap_<T>)\n+}\n+\n+/// Create a smallintmap\n+pub fn mk<T: Copy>() -> SmallIntMap<T> {\n+    let v = DVec();\n+    SmallIntMap_(@SmallIntMap_ { v: v } )\n+}\n+\n+/**\n+ * Add a value to the map. If the map already contains a value for\n+ * the specified key then the original value is replaced.\n+ */\n+#[inline(always)]\n+pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n+    //io::println(fmt!(\"%?\", key));\n+    self.v.grow_set_elt(key, &None, Some(val));\n+}\n+\n+/**\n+ * Get the value for the specified key. If the key does not exist\n+ * in the map then returns none\n+ */\n+pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n+    if key < self.v.len() { return self.v.get_elt(key); }\n+    return None::<T>;\n+}\n+\n+/**\n+ * Get the value for the specified key\n+ *\n+ * # Failure\n+ *\n+ * If the key does not exist in the map\n+ */\n+pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n+    match find(self, key) {\n+      None => {\n+        error!(\"smallintmap::get(): key not present\");\n+        die!();\n+      }\n+      Some(move v) => return v\n+    }\n+}\n+\n+/// Returns true if the map contains a value for the specified key\n+pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n+    return !find(self, key).is_none();\n+}\n+\n+impl<V> SmallIntMap<V>: Container {\n+    /// Return the number of elements in the map\n+    pure fn len(&self) -> uint {\n+        let mut sz = 0u;\n+        for self.v.each |item| {\n+            match *item {\n+              Some(_) => sz += 1u,\n+              _ => ()\n+            }\n+        }\n+        sz\n+    }\n+\n+    /// Return true if the map contains no elements\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl<V> SmallIntMap<V>: Mutable {\n+    fn clear(&mut self) { self.v.set(~[]) }\n+}\n+\n+/// Implements the map::map interface for smallintmap\n+impl<V: Copy> SmallIntMap<V> {\n+    #[inline(always)]\n+    fn insert(key: uint, value: V) -> bool {\n+        let exists = contains_key(self, key);\n+        insert(self, key, value);\n+        return !exists;\n+    }\n+    fn remove(key: uint) -> bool {\n+        if key >= self.v.len() {\n+            return false;\n+        }\n+        let old = self.v.get_elt(key);\n+        self.v.set_elt(key, None);\n+        old.is_some()\n+    }\n+    pure fn contains_key(key: uint) -> bool {\n+        contains_key(self, key)\n+    }\n+    pure fn contains_key_ref(key: &uint) -> bool {\n+        contains_key(self, *key)\n+    }\n+    pure fn get(key: uint) -> V { get(self, key) }\n+    pure fn find(key: uint) -> Option<V> { find(self, key) }\n+\n+    fn update_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n+        match self.find(key) {\n+            None            => return self.insert(key, val),\n+            Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n+        }\n+    }\n+\n+    fn update(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    }\n+\n+    pure fn each(it: fn(key: uint, value: V) -> bool) {\n+        self.each_ref(|k, v| it(*k, *v))\n+    }\n+    pure fn each_key(it: fn(key: uint) -> bool) {\n+        self.each_ref(|k, _v| it(*k))\n+    }\n+    pure fn each_value(it: fn(value: V) -> bool) {\n+        self.each_ref(|_k, v| it(*v))\n+    }\n+    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n+        let mut idx = 0u, l = self.v.len();\n+        while idx < l {\n+            match self.v.get_elt(idx) {\n+              Some(ref elt) => if !it(&idx, elt) { break },\n+              None => ()\n+            }\n+            idx += 1u;\n+        }\n+    }\n+    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n+        self.each_ref(|k, _v| blk(k))\n+    }\n+    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n+        self.each_ref(|_k, v| blk(v))\n+    }\n+}\n+\n+impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n+    pure fn index(&self, key: uint) -> V {\n+        unsafe {\n+            get(*self, key)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{mk, SmallIntMap};\n+\n+    use core::option::None;\n+\n+    #[test]\n+    fn test_len() {\n+        let mut map = mk();\n+        assert map.len() == 0;\n+        assert map.is_empty();\n+        map.insert(5, 20);\n+        assert map.len() == 1;\n+        assert !map.is_empty();\n+        map.insert(11, 12);\n+        assert map.len() == 2;\n+        assert !map.is_empty();\n+        map.insert(14, 22);\n+        assert map.len() == 3;\n+        assert !map.is_empty();\n+    }\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut map = mk();\n+        map.insert(5, 20);\n+        map.insert(11, 12);\n+        map.insert(14, 22);\n+        map.clear();\n+        assert map.is_empty();\n+        assert map.find(5).is_none();\n+        assert map.find(11).is_none();\n+        assert map.find(14).is_none();\n+    }\n+\n+    #[test]\n+    fn test_insert_with_key() {\n+        let map: SmallIntMap<uint> = mk();\n+\n+        // given a new key, initialize it with this new count, given\n+        // given an existing key, add more to its count\n+        fn addMoreToCount(_k: uint, v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        // count integers\n+        map.update(3, 1, addMoreToCount_simple);\n+        map.update_with_key(9, 1, addMoreToCount);\n+        map.update(3, 7, addMoreToCount_simple);\n+        map.update_with_key(5, 3, addMoreToCount);\n+        map.update_with_key(3, 2, addMoreToCount);\n+\n+        // check the total counts\n+        assert map.find(3).get() == 10;\n+        assert map.find(5).get() == 3;\n+        assert map.find(9).get() == 1;\n+\n+        // sadly, no sevens were counted\n+        assert None == map.find(7);\n+    }\n+}"}, {"sha": "c7601f6b6b5f5e49cbd72f1dd4ee5f84907f205e", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -100,7 +100,7 @@ pub fn of_str(str: @~str) -> Rope {\n  */\n pub fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n     if byte_len == 0u { return node::Empty; }\n-    if byte_offset + byte_len  > str::len(*str) { fail; }\n+    if byte_offset + byte_len  > str::len(*str) { die!(); }\n     return node::Content(node::of_substr(str, byte_offset, byte_len));\n }\n \n@@ -246,9 +246,9 @@ Section: Transforming ropes\n pub fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n     if char_len == 0u { return node::Empty; }\n     match (rope) {\n-      node::Empty => fail,\n+      node::Empty => die!(),\n       node::Content(node) => if char_len > node::char_len(node) {\n-        fail\n+        die!()\n       } else {\n         return node::Content(node::sub_chars(node, char_offset, char_len))\n       }\n@@ -271,9 +271,9 @@ pub fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n pub fn sub_bytes(rope: Rope, byte_offset: uint, byte_len: uint) -> Rope {\n     if byte_len == 0u { return node::Empty; }\n     match (rope) {\n-      node::Empty => fail,\n+      node::Empty => die!(),\n       node::Content(node) =>if byte_len > node::byte_len(node) {\n-        fail\n+        die!()\n       } else {\n         return node::Content(node::sub_bytes(node, byte_offset, byte_len))\n       }\n@@ -550,7 +550,7 @@ pub pure fn byte_len(rope: Rope) -> uint {\n  */\n pub fn char_at(rope: Rope, pos: uint) -> char {\n    match (rope) {\n-      node::Empty => fail,\n+      node::Empty => die!(),\n       node::Content(x) => return node::char_at(x, pos)\n    }\n }\n@@ -788,7 +788,7 @@ pub mod node {\n      * * forest - The forest. This vector is progressively rewritten during\n      *            execution and should be discarded as meaningless afterwards.\n      */\n-    pub fn tree_from_forest_destructive(forest: &[mut @Node]) -> @Node {\n+    pub fn tree_from_forest_destructive(forest: &mut [@Node]) -> @Node {\n         let mut i;\n         let mut len = vec::len(forest);\n         while len > 1u {\n@@ -1158,18 +1158,17 @@ pub mod node {\n         use core::vec;\n \n         pub struct T {\n-            stack: ~[mut @Node],\n+            mut stack: ~[@Node],\n             mut stackpos: int,\n         }\n \n         pub fn empty() -> T {\n-            let stack : ~[mut @Node] = ~[mut];\n+            let mut stack : ~[@Node] = ~[];\n             T { stack: stack, stackpos: -1 }\n         }\n \n         pub fn start(node: @Node) -> T {\n-            let stack = vec::cast_to_mut(\n-                vec::from_elem(height(node)+1u, node));\n+            let stack = vec::from_elem(height(node)+1u, node);\n             T {\n                 stack: stack,\n                 stackpos:  0,"}, {"sha": "4938ead9ea8143062465cebf97ce5e19b2af4a61", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -390,7 +390,7 @@ pub impl<D: Decoder, T: Decodable<D>> Option<T>: Decodable<D> {\n                   0 => None,\n                   1 => Some(d.read_enum_variant_arg(\n                       0u, || Decodable::decode(d))),\n-                  _ => fail(fmt!(\"Bad variant for option: %u\", i))\n+                  _ => die!(fmt!(\"Bad variant for option: %u\", i))\n                 }\n             }\n         }"}, {"sha": "a5c740c343cfcb0600d8b9ccc0c82360d39bb9f3", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -85,7 +85,7 @@ pub fn sha1() -> Sha1 {\n                 st.len_high += 1u32;\n                 if st.len_high == 0u32 {\n                     // FIXME: Need better failure mode (#2346)\n-                    fail;\n+                    die!();\n                 }\n             }\n             if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n@@ -253,7 +253,7 @@ pub fn sha1() -> Sha1 {\n             let rr = mk_result(&self);\n             let mut s = ~\"\";\n             for vec::each(rr) |b| {\n-                s += uint::to_str(*b as uint, 16u);\n+                s += uint::to_str_radix(*b as uint, 16u);\n             }\n             return s;\n         }"}, {"sha": "a21328b3d6340e671707ef38632bd2593b375033", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 120, "deletions": 130, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,171 +14,161 @@\n  */\n #[forbid(deprecated_mode)];\n \n-use map;\n-use map::StdMap;\n-\n-use core::dvec::DVec;\n-use core::ops;\n+use core::container::{Container, Mutable, Map, Set};\n use core::option::{Some, None};\n-use core::option;\n use core::prelude::*;\n \n-// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n-// requires this to be.\n-struct SmallIntMap_<T> {\n-    v: DVec<Option<T>>,\n-}\n-\n-pub enum SmallIntMap<T> {\n-    SmallIntMap_(@SmallIntMap_<T>)\n+pub struct SmallIntMap<T> {\n+    priv v: ~[Option<T>],\n }\n \n-/// Create a smallintmap\n-pub fn mk<T: Copy>() -> SmallIntMap<T> {\n-    let v = DVec();\n-    SmallIntMap_(@SmallIntMap_ { v: v } )\n-}\n+impl<V> SmallIntMap<V>: Container {\n+    /// Return the number of elements in the map\n+    pure fn len(&self) -> uint {\n+        let mut sz = 0;\n+        for self.v.each |item| {\n+            if item.is_some() {\n+                sz += 1;\n+            }\n+        }\n+        sz\n+    }\n \n-/**\n- * Add a value to the map. If the map already contains a value for\n- * the specified key then the original value is replaced.\n- */\n-#[inline(always)]\n-pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n-    //io::println(fmt!(\"%?\", key));\n-    self.v.grow_set_elt(key, &None, Some(val));\n+    /// Return true if the map contains no elements\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n-/**\n- * Get the value for the specified key. If the key does not exist\n- * in the map then returns none\n- */\n-pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n-    if key < self.v.len() { return self.v.get_elt(key); }\n-    return None::<T>;\n+impl<V> SmallIntMap<V>: Mutable {\n+    /// Clear the map, removing all key-value pairs.\n+    fn clear(&mut self) { self.v.clear() }\n }\n \n-/**\n- * Get the value for the specified key\n- *\n- * # Failure\n- *\n- * If the key does not exist in the map\n- */\n-pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n-    match find(self, key) {\n-      None => {\n-        error!(\"smallintmap::get(): key not present\");\n-        fail;\n-      }\n-      Some(move v) => return v\n+impl<V> SmallIntMap<V>: Map<uint, V> {\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &uint) -> bool {\n+        self.find(key).is_some()\n     }\n-}\n-\n-/// Returns true if the map contains a value for the specified key\n-pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n-    return !find(self, key).is_none();\n-}\n \n-/// Implements the map::map interface for smallintmap\n-impl<V: Copy> SmallIntMap<V>: map::StdMap<uint, V> {\n-    pure fn size() -> uint {\n-        let mut sz = 0u;\n-        for self.v.each |item| {\n-            match *item {\n-              Some(_) => sz += 1u,\n-              _ => ()\n+    /// Visit all key-value pairs\n+    pure fn each(&self, it: fn(key: &uint, value: &V) -> bool) {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { break },\n+              None => ()\n             }\n         }\n-        sz\n-    }\n-    #[inline(always)]\n-    fn insert(key: uint, value: V) -> bool {\n-        let exists = contains_key(self, key);\n-        insert(self, key, value);\n-        return !exists;\n-    }\n-    fn remove(key: uint) -> bool {\n-        if key >= self.v.len() {\n-            return false;\n-        }\n-        let old = self.v.get_elt(key);\n-        self.v.set_elt(key, None);\n-        old.is_some()\n     }\n-    fn clear() {\n-        self.v.set(~[]);\n-    }\n-    pure fn contains_key(key: uint) -> bool {\n-        contains_key(self, key)\n+\n+    /// Visit all keys\n+    pure fn each_key(&self, blk: fn(key: &uint) -> bool) {\n+        self.each(|k, _| blk(k))\n     }\n-    pure fn contains_key_ref(key: &uint) -> bool {\n-        contains_key(self, *key)\n+\n+    /// Visit all values\n+    pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+        self.each(|_, v| blk(v))\n     }\n-    pure fn get(key: uint) -> V { get(self, key) }\n-    pure fn find(key: uint) -> Option<V> { find(self, key) }\n \n-    fn update_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n-        match self.find(key) {\n-            None            => return self.insert(key, val),\n-            Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n+    /// Return the value corresponding to the key in the map\n+    pure fn find(&self, key: &uint) -> Option<&self/V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n         }\n     }\n \n-    fn update(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n-        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: uint, value: V) -> bool {\n+        let exists = self.contains_key(&key);\n+        let len = self.v.len();\n+        if len <= key {\n+            vec::grow_fn(&mut self.v, key - len + 1, |_| None);\n+        }\n+        self.v[key] = Some(value);\n+        !exists\n     }\n \n-    pure fn each(it: fn(key: uint, value: V) -> bool) {\n-        self.each_ref(|k, v| it(*k, *v))\n-    }\n-    pure fn each_key(it: fn(key: uint) -> bool) {\n-        self.each_ref(|k, _v| it(*k))\n-    }\n-    pure fn each_value(it: fn(value: V) -> bool) {\n-        self.each_ref(|_k, v| it(*v))\n-    }\n-    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n-        let mut idx = 0u, l = self.v.len();\n-        while idx < l {\n-            match self.v.get_elt(idx) {\n-              Some(ref elt) => if !it(&idx, elt) { break },\n-              None => ()\n-            }\n-            idx += 1u;\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &uint) -> bool {\n+        if *key >= self.v.len() {\n+            return false;\n         }\n+        let removed = self.v[*key].is_some();\n+        self.v[*key] = None;\n+        removed\n     }\n-    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n-        self.each_ref(|k, _v| blk(k))\n-    }\n-    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n-        self.each_ref(|_k, v| blk(v))\n+}\n+\n+pub impl<V> SmallIntMap<V> {\n+    /// Create an empty SmallIntMap\n+    static pure fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+\n+    pure fn get(&self, key: &uint) -> &self/V {\n+        self.find(key).expect(\"key not present\")\n     }\n }\n \n-impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n-    pure fn index(&self, key: uint) -> V {\n-        unsafe {\n-            get(*self, key)\n+pub impl<V: Copy> SmallIntMap<V> {\n+    // FIXME: #4733, remove after the next snapshot\n+    #[cfg(stage2)]\n+    fn update_with_key(&mut self, key: uint, val: V,\n+                       ff: fn(uint, V, V) -> V) -> bool {\n+        match self.find(&key) {\n+          None => self.insert(key, val),\n+          Some(orig) => self.insert(key, ff(key, copy *orig, val)),\n         }\n     }\n-}\n \n-/// Cast the given smallintmap to a map::map\n-pub fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::StdMap<uint, V> {\n-    s as map::StdMap::<uint, V>\n+    // FIXME: #4733, remove after the next snapshot\n+    #[cfg(stage2)]\n+    fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+        self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use smallintmap::{mk, SmallIntMap};\n+    use super::SmallIntMap;\n \n-    use core::option::None;\n-    use core::option;\n+    #[test]\n+    fn test_len() {\n+        let mut map = SmallIntMap::new();\n+        assert map.len() == 0;\n+        assert map.is_empty();\n+        assert map.insert(5, 20);\n+        assert map.len() == 1;\n+        assert !map.is_empty();\n+        assert map.insert(11, 12);\n+        assert map.len() == 2;\n+        assert !map.is_empty();\n+        assert map.insert(14, 22);\n+        assert map.len() == 3;\n+        assert !map.is_empty();\n+    }\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut map = SmallIntMap::new();\n+        assert map.insert(5, 20);\n+        assert map.insert(11, 12);\n+        assert map.insert(14, 22);\n+        map.clear();\n+        assert map.is_empty();\n+        assert map.find(&5).is_none();\n+        assert map.find(&11).is_none();\n+        assert map.find(&14).is_none();\n+    }\n \n     #[test]\n     fn test_insert_with_key() {\n-        let map: SmallIntMap<uint> = mk();\n+        let mut map = SmallIntMap::new();\n \n         // given a new key, initialize it with this new count, given\n         // given an existing key, add more to its count\n@@ -198,11 +188,11 @@ mod tests {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        assert 10 == option::get(map.find(3));\n-        assert  3 == option::get(map.find(5));\n-        assert  1 == option::get(map.find(9));\n+        assert map.find(&3).get() == &10;\n+        assert map.find(&5).get() == &3;\n+        assert map.find(&9).get() == &1;\n \n         // sadly, no sevens were counted\n-        assert None == map.find(7);\n+        assert map.find(&7).is_none();\n     }\n }"}, {"sha": "6e89cd9e24f9233faf00ce5af8578a9de3510122", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -64,7 +64,7 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     }\n }\n \n-fn part<T: Copy>(arr: &[mut T], left: uint,\n+fn part<T: Copy>(arr: &mut [T], left: uint,\n                 right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -81,7 +81,7 @@ fn part<T: Copy>(arr: &[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: Copy>(arr: &[mut T], left: uint,\n+fn qsort<T: Copy>(arr: &mut [T], left: uint,\n              right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -100,12 +100,12 @@ fn qsort<T: Copy>(arr: &[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-pub fn quick_sort<T: Copy>(arr: &[mut T], compare_func: Le<T>) {\n+pub fn quick_sort<T: Copy>(arr: &mut [T], compare_func: Le<T>) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }\n \n-fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n+fn qsort3<T: Copy Ord Eq>(arr: &mut [T], left: int, right: int) {\n     if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -162,7 +162,7 @@ fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-pub fn quick_sort3<T: Copy Ord Eq>(arr: &[mut T]) {\n+pub fn quick_sort3<T: Copy Ord Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n@@ -171,15 +171,15 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<T: Copy Ord Eq> &[mut T] : Sort {\n+impl<T: Copy Ord Eq> &mut [T] : Sort {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n const MIN_MERGE: uint = 64;\n const MIN_GALLOP: uint = 7;\n const INITIAL_TMP_STORAGE: uint = 128;\n \n-pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n+pub fn tim_sort<T: Copy Ord>(array: &mut [T]) {\n     let size = array.len();\n     if size < 2 {\n         return;\n@@ -218,7 +218,7 @@ pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n     ms.merge_force_collapse(array);\n }\n \n-fn binarysort<T: Copy Ord>(array: &[mut T], start: uint) {\n+fn binarysort<T: Copy Ord>(array: &mut [T], start: uint) {\n     let size = array.len();\n     let mut start = start;\n     assert start <= size;\n@@ -249,7 +249,7 @@ fn binarysort<T: Copy Ord>(array: &[mut T], start: uint) {\n }\n \n // Reverse the order of elements in a slice, in place\n-fn reverse_slice<T>(v: &[mut T], start: uint, end:uint) {\n+fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n         util::swap(&mut v[i], &mut v[end - i - 1]);\n@@ -268,7 +268,7 @@ pure fn min_run_length(n: uint) -> uint {\n     return n + r;\n }\n \n-fn count_run_ascending<T: Copy Ord>(array: &[mut T]) -> uint {\n+fn count_run_ascending<T: Copy Ord>(array: &mut [T]) -> uint {\n     let size = array.len();\n     assert size > 0;\n     if size == 1 { return 1; }\n@@ -412,7 +412,7 @@ impl<T: Copy Ord> MergeState<T> {\n         self.runs.push(tmp);\n     }\n \n-    fn merge_at(&self, n: uint, array: &[mut T]) {\n+    fn merge_at(&self, n: uint, array: &mut [T]) {\n         let mut size = self.runs.len();\n         assert size >= 2;\n         assert n == size-2 || n == size-3;\n@@ -453,7 +453,7 @@ impl<T: Copy Ord> MergeState<T> {\n         self.runs.pop();\n     }\n \n-    fn merge_lo(&self, array: &[mut T], base1: uint, len1: uint,\n+    fn merge_lo(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n@@ -548,15 +548,15 @@ impl<T: Copy Ord> MergeState<T> {\n             copy_vec(array, dest, array, c2, len2);\n             array[dest+len2] <-> tmp[c1];\n         } else if len1 == 0 {\n-            fail ~\"Comparison violates its contract!\";\n+            die!(~\"Comparison violates its contract!\");\n         } else {\n             assert len2 == 0;\n             assert len1 > 1;\n             copy_vec(array, dest, tmp, c1, len1);\n         }\n     }\n \n-    fn merge_hi(&self, array: &[mut T], base1: uint, len1: uint,\n+    fn merge_hi(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n@@ -666,15 +666,15 @@ impl<T: Copy Ord> MergeState<T> {\n             copy_vec(array, dest+1, array, c1+1, len1);\n             array[dest] <-> tmp[c2];\n         } else if len2 == 0 {\n-            fail ~\"Comparison violates its contract!\";\n+            die!(~\"Comparison violates its contract!\");\n         } else {\n             assert len1 == 0;\n             assert len2 != 0;\n             copy_vec(array, dest-(len2-1), tmp, 0, len2);\n         }\n     }\n \n-    fn merge_collapse(&self, array: &[mut T]) {\n+    fn merge_collapse(&self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             let chk = do self.runs.borrow |arr| {\n@@ -692,7 +692,7 @@ impl<T: Copy Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_force_collapse(&self, array: &[mut T]) {\n+    fn merge_force_collapse(&self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             if n > 0 {\n@@ -708,7 +708,7 @@ impl<T: Copy Ord> MergeState<T> {\n }\n \n #[inline(always)]\n-fn copy_vec<T: Copy>(dest: &[mut T], s1: uint,\n+fn copy_vec<T: Copy>(dest: &mut [T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     assert s1+len <= dest.len() && s2+len <= from.len();\n \n@@ -726,7 +726,7 @@ mod test_qsort3 {\n \n     use core::vec;\n \n-    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n@@ -740,24 +740,24 @@ mod test_qsort3 {\n     #[test]\n     pub fn test() {\n         {\n-            let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = ~[mut 1, 1, 1];\n-            let v2 = ~[mut 1, 1, 1];\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: ~[mut int] = ~[mut];\n-            let v2: ~[mut int] = ~[mut];\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n             check_sort(v1, v2);\n         }\n-        { let v1 = ~[mut 9]; let v2 = ~[mut 9]; check_sort(v1, v2); }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n         {\n-            let v1 = ~[mut 9, 3, 3, 3, 9];\n-            let v2 = ~[mut 3, 3, 3, 9, 9];\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n@@ -772,7 +772,7 @@ mod test_qsort {\n     use core::int;\n     use core::vec;\n \n-    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n@@ -787,38 +787,38 @@ mod test_qsort {\n     #[test]\n     pub fn test() {\n         {\n-            let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = ~[mut 1, 1, 1];\n-            let v2 = ~[mut 1, 1, 1];\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: ~[mut int] = ~[mut];\n-            let v2: ~[mut int] = ~[mut];\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n             check_sort(v1, v2);\n         }\n-        { let v1 = ~[mut 9]; let v2 = ~[mut 9]; check_sort(v1, v2); }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n         {\n-            let v1 = ~[mut 9, 3, 3, 3, 9];\n-            let v2 = ~[mut 3, 3, 3, 9, 9];\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n \n     // Regression test for #750\n     #[test]\n     pub fn test_simple() {\n-        let names = ~[mut 2, 1, 3];\n+        let mut names = ~[2, 1, 3];\n \n         let expected = ~[1, 2, 3];\n \n         do quick_sort(names) |x, y| { int::le(*x, *y) };\n \n-        let immut_names = vec::cast_from_mut(move names);\n+        let immut_names = move names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n         for vec::each(pairs) |p| {\n@@ -870,7 +870,7 @@ mod tests {\n     #[test]\n     pub fn test_merge_sort_mutable() {\n         pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let v1 = ~[mut 3, 2, 1];\n+        let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         assert v2 == ~[1, 2, 3];\n     }\n@@ -914,7 +914,7 @@ mod test_tim_sort {\n         pure fn lt(&self, other: &CVal) -> bool {\n             unsafe {\n                 let rng = rand::Rng();\n-                if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n+                if rng.gen_float() > 0.995 { die!(~\"It's happening!!!\"); }\n             }\n             (*self).val < other.val\n         }\n@@ -923,7 +923,7 @@ mod test_tim_sort {\n         pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n-    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n@@ -937,24 +937,24 @@ mod test_tim_sort {\n     #[test]\n     fn test() {\n         {\n-            let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = ~[mut 1, 1, 1];\n-            let v2 = ~[mut 1, 1, 1];\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: ~[mut int] = ~[mut];\n-            let v2: ~[mut int] = ~[mut];\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n             check_sort(v1, v2);\n         }\n-        { let v1 = ~[mut 9]; let v2 = ~[mut 9]; check_sort(v1, v2); }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n         {\n-            let v1 = ~[mut 9, 3, 3, 3, 9];\n-            let v2 = ~[mut 3, 3, 3, 9, 9];\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n@@ -970,7 +970,7 @@ mod test_tim_sort {\n         };\n \n         tim_sort(arr);\n-        fail ~\"Guarantee the fail\";\n+        die!(~\"Guarantee the fail\");\n     }\n \n     struct DVal { val: uint }\n@@ -1019,12 +1019,12 @@ mod big_tests {\n         tabulate_managed(low, high);\n     }\n \n-    fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[mut T] {\n+    fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n         };\n-        vec::cast_to_mut(move res)\n+        move res\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n@@ -1038,7 +1038,7 @@ mod big_tests {\n         fn isSorted<T: Ord>(arr: &[const T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n-                    fail ~\"Array not sorted\";\n+                    die!(~\"Array not sorted\");\n                 }\n             }\n         }\n@@ -1050,7 +1050,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 rng.gen_float()\n             };\n-            let arr = vec::cast_to_mut(move arr);\n+            let mut arr = move arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1088,7 +1088,7 @@ mod big_tests {\n             tim_sort(arr);\n             isSorted(arr);\n \n-            let arr = if n > 4 {\n+            let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n             } else { move arr };\n@@ -1110,7 +1110,7 @@ mod big_tests {\n         fn isSorted<T: Ord>(arr: &[const @T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n-                    fail ~\"Array not sorted\";\n+                    die!(~\"Array not sorted\");\n                 }\n             }\n         }\n@@ -1122,7 +1122,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 @rng.gen_float()\n             };\n-            let arr = vec::cast_to_mut(move arr);\n+            let mut arr = move arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1160,7 +1160,7 @@ mod big_tests {\n             tim_sort(arr);\n             isSorted(arr);\n \n-            let arr = if n > 4 {\n+            let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n             } else { move arr };\n@@ -1193,7 +1193,7 @@ mod big_tests {\n                         task::local_data::local_data_set(self.key, @(y+1));\n                     }\n                 }\n-                _ => fail ~\"Expected key to work\",\n+                _ => die!(~\"Expected key to work\"),\n             }\n         }\n     }"}, {"sha": "65122bea7506e5a3926d093c6b9fab0c8bffb0fd", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -79,10 +79,11 @@ pub mod bitv;\n pub mod deque;\n pub mod fun_treemap;\n pub mod list;\n-pub mod map;\n+pub mod oldmap;\n pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;\n+pub mod oldsmallintmap;\n pub mod sort;\n pub mod treemap;\n "}, {"sha": "31c596c50382d01036ef07cece952c70fc71dce8", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -92,12 +92,12 @@ fn new_sem<Q: Owned>(count: int, q: Q) -> Sem<Q> {\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n-        -> Sem<~[mut Waitqueue]> {\n+        -> Sem<~[Waitqueue]> {\n     let mut queues = ~[];\n     for num_condvars.times {\n         queues.push(new_waitqueue());\n     }\n-    new_sem(count, vec::cast_to_mut(move queues))\n+    new_sem(count, queues)\n }\n \n #[doc(hidden)]\n@@ -150,7 +150,7 @@ impl &Sem<()> {\n     }\n }\n #[doc(hidden)]\n-impl &Sem<~[mut Waitqueue]> {\n+impl &Sem<~[Waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n@@ -166,7 +166,7 @@ impl &Sem<~[mut Waitqueue]> {\n // FIXME(#3588) should go inside of access()\n #[doc(hidden)]\n type SemRelease = SemReleaseGeneric<()>;\n-type SemAndSignalRelease = SemReleaseGeneric<~[mut Waitqueue]>;\n+type SemAndSignalRelease = SemReleaseGeneric<~[Waitqueue]>;\n struct SemReleaseGeneric<Q> { sem: &Sem<Q> }\n \n impl<Q: Owned> SemReleaseGeneric<Q> : Drop {\n@@ -181,15 +181,15 @@ fn SemRelease(sem: &r/Sem<()>) -> SemRelease/&r {\n     }\n }\n \n-fn SemAndSignalRelease(sem: &r/Sem<~[mut Waitqueue]>)\n+fn SemAndSignalRelease(sem: &r/Sem<~[Waitqueue]>)\n     -> SemAndSignalRelease/&r {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar { priv sem: &Sem<~[mut Waitqueue]> }\n+pub struct Condvar { priv sem: &Sem<~[Waitqueue]> }\n \n impl Condvar : Drop { fn finalize(&self) {} }\n \n@@ -259,7 +259,7 @@ impl &Condvar {\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct SemAndSignalReacquire {\n-            sem: &Sem<~[mut Waitqueue]>,\n+            sem: &Sem<~[Waitqueue]>,\n         }\n \n         impl SemAndSignalReacquire : Drop {\n@@ -273,7 +273,7 @@ impl &Condvar {\n             }\n         }\n \n-        fn SemAndSignalReacquire(sem: &r/Sem<~[mut Waitqueue]>)\n+        fn SemAndSignalReacquire(sem: &r/Sem<~[Waitqueue]>)\n             -> SemAndSignalReacquire/&r {\n             SemAndSignalReacquire {\n                 sem: sem\n@@ -335,17 +335,17 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n                         blk: fn() -> U) -> U {\n     match out_of_bounds {\n         Some(0) =>\n-            fail fmt!(\"%s with illegal ID %u - this lock has no condvars!\",\n-                      act, id),\n+            die!(fmt!(\"%s with illegal ID %u - this lock has no condvars!\",\n+                      act, id)),\n         Some(length) =>\n-            fail fmt!(\"%s with illegal ID %u - ID must be less than %u\",\n-                      act, id, length),\n+            die!(fmt!(\"%s with illegal ID %u - ID must be less than %u\",\n+                      act, id, length)),\n         None => blk()\n     }\n }\n \n #[doc(hidden)]\n-impl &Sem<~[mut Waitqueue]> {\n+impl &Sem<~[Waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n     fn access_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n         do self.access { blk(&Condvar { sem: self }) }\n@@ -400,7 +400,7 @@ impl &Semaphore {\n  * A task which fails while holding a mutex will unlock the mutex as it\n  * unwinds.\n  */\n-struct Mutex { priv sem: Sem<~[mut Waitqueue]> }\n+struct Mutex { priv sem: Sem<~[Waitqueue]> }\n \n /// Create a new mutex, with one associated condvar.\n pub fn Mutex() -> Mutex { mutex_with_condvars(1) }\n@@ -450,7 +450,7 @@ struct RWlockInner {\n  */\n struct RWlock {\n     priv order_lock:  Semaphore,\n-    priv access_lock: Sem<~[mut Waitqueue]>,\n+    priv access_lock: Sem<~[Waitqueue]>,\n     priv state:       Exclusive<RWlockInner>\n }\n \n@@ -582,7 +582,7 @@ impl &RWlock {\n     /// To be called inside of the write_downgrade block.\n     fn downgrade(token: RWlockWriteMode/&a) -> RWlockReadMode/&a {\n         if !ptr::ref_eq(self, token.lock) {\n-            fail ~\"Can't downgrade() with a different rwlock's write_mode!\";\n+            die!(~\"Can't downgrade() with a different rwlock's write_mode!\");\n         }\n         unsafe {\n             do task::unkillable {\n@@ -935,7 +935,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try |move m2| {\n             do m2.lock {\n-                fail;\n+                die!();\n             }\n         };\n         assert result.is_err();\n@@ -954,7 +954,7 @@ mod tests {\n             do task::spawn |move p| { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::yield();\n-                fail;\n+                die!();\n             }\n             do m2.lock_cond |cond| {\n                 c.send(()); // tell sibling go ahead\n@@ -996,7 +996,7 @@ mod tests {\n             }\n             do m2.lock { }\n             c.send(move sibling_convos); // let parent wait on all children\n-            fail;\n+            die!();\n         };\n         assert result.is_err();\n         // child task must have finished by the time try returns\n@@ -1050,7 +1050,7 @@ mod tests {\n             let _ = p.recv();\n             do m.lock_cond |cond| {\n                 if !cond.signal_on(0) {\n-                    fail; // success; punt sibling awake.\n+                    die!(); // success; punt sibling awake.\n                 }\n             }\n         };\n@@ -1290,7 +1290,7 @@ mod tests {\n \n         let result: result::Result<(),()> = do task::try |move x2| {\n             do lock_rwlock_in_mode(x2, mode1) {\n-                fail;\n+                die!();\n             }\n         };\n         assert result.is_err();"}, {"sha": "5a2693a42c143af6fc535be5808ec7a8df75d25a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -68,9 +68,9 @@ pub fn test_main(args: &[~str], tests: &[TestDesc]) {\n     let opts =\n         match parse_opts(args) {\n           either::Left(move o) => o,\n-          either::Right(move m) => fail m\n+          either::Right(move m) => die!(m)\n         };\n-    if !run_tests_console(&opts, tests) { fail ~\"Some tests failed\"; }\n+    if !run_tests_console(&opts, tests) { die!(~\"Some tests failed\"); }\n }\n \n pub struct TestOpts {\n@@ -167,7 +167,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                                             ~[io::Create, io::Truncate]) {\n           result::Ok(w) => Some(w),\n           result::Err(ref s) => {\n-              fail(fmt!(\"can't open output file: %s\", *s))\n+              die!(fmt!(\"can't open output file: %s\", *s))\n           }\n         },\n         None => None\n@@ -446,7 +446,7 @@ mod tests {\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n-        fn f() { fail; }\n+        fn f() { die!(); }\n         let desc = TestDesc {\n             name: ~\"whatever\",\n             testfn: f,\n@@ -479,7 +479,7 @@ mod tests {\n     #[test]\n     #[ignore(cfg(windows))]\n     pub fn test_should_fail() {\n-        fn f() { fail; }\n+        fn f() { die!(); }\n         let desc = TestDesc {\n             name: ~\"whatever\",\n             testfn: f,\n@@ -514,7 +514,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,\n-          _ => fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"\n+          _ => die!(~\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n         assert ~\"filter\" == opts.filter.get();\n     }\n@@ -524,7 +524,7 @@ mod tests {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,\n-          _ => fail ~\"Malformed arg in parse_ignored_flag\"\n+          _ => die!(~\"Malformed arg in parse_ignored_flag\")\n         };\n         assert (opts.run_ignored);\n     }"}, {"sha": "dd25fc36d2ddf6fb94f2126145f3014535e3a840", "filename": "src/libstd/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -926,7 +926,7 @@ mod tests {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n-        log(debug, ~\"s0=\" + float::to_str(s0, 9u) + ~\" sec\");\n+        log(debug, ~\"s0=\" + float::to_str_digits(s0, 9u) + ~\" sec\");\n         assert s0 > 0.;\n         let ns0 = (s0 * 1000000000.) as u64;\n         log(debug, ~\"ns0=\" + u64::str(ns0) + ~\" ns\");\n@@ -1042,7 +1042,7 @@ mod tests {\n             == Err(~\"Invalid time\");\n \n         match strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n-          Err(copy e) => fail e,\n+          Err(copy e) => die!(e),\n           Ok(ref tm) => {\n             assert tm.tm_sec == 30_i32;\n             assert tm.tm_min == 31_i32;\n@@ -1062,7 +1062,7 @@ mod tests {\n         fn test(s: &str, format: &str) -> bool {\n             match strptime(s, format) {\n               Ok(ref tm) => tm.strftime(format) == str::from_slice(s),\n-              Err(copy e) => fail e\n+              Err(copy e) => die!(e)\n             }\n         }\n "}, {"sha": "f89830ed12a9076a575ae85217d599509060950d", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -69,13 +69,13 @@ pub fn delayed_send<T: Owned>(iotask: &IoTask,\n                         } else {\n                             let error_msg = uv::ll::get_last_err_info(\n                                 loop_ptr);\n-                            fail ~\"timer::delayed_send() start failed: \" +\n-                                error_msg;\n+                            die!(~\"timer::delayed_send() start failed: \" +\n+                                error_msg);\n                         }\n                     } else {\n                         let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                        fail ~\"timer::delayed_send() init failed: \" +\n-                            error_msg;\n+                        die!(~\"timer::delayed_send() init failed: \" +\n+                            error_msg);\n                     }\n                 }\n             };\n@@ -159,7 +159,7 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n         } else {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n             let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-            fail ~\"timer::sleep() init failed: \"+error_msg;\n+            die!(~\"timer::sleep() init failed: \"+error_msg);\n         }\n     }\n }"}, {"sha": "736954f6b222f36f868b73920aa7ebf0a1c18629", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -185,14 +185,12 @@ mod test {\n                         let start_status = ll::timer_start(timer_ptr,\n                                                            simple_timer_cb,\n                                                            1u, 0u);\n-                        if(start_status == 0i32) {\n-                        }\n-                        else {\n-                            fail ~\"failure on ll::timer_start()\";\n+                        if(start_status != 0i32) {\n+                            die!(~\"failure on ll::timer_start()\");\n                         }\n                     }\n                     else {\n-                        fail ~\"failure on ll::timer_init()\";\n+                        die!(~\"failure on ll::timer_init()\");\n                     }\n                 }\n             };"}, {"sha": "4e9df14419b18e6f13ea0e0919bb6e8b175ebfea", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -380,7 +380,7 @@ fn unwrap<T:Owned\n     ww.res <-> s;\n \n     match move s {\n-        None => fail,\n+        None => die!(),\n         Some(Left(move v)) => move v,\n         Some(Right(move port)) => {\n "}, {"sha": "bc808495ca33b5c0e7ffe4a4fb48ee069d1e464f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,7 +10,7 @@\n \n // The Rust abstract syntax tree.\n \n-use codemap::{span, FileName};\n+use codemap::{span, FileName, spanned};\n \n use core::cast;\n use core::cmp;\n@@ -21,10 +21,6 @@ use core::to_bytes;\n use core::to_str::ToStr;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-#[auto_encode]\n-#[auto_decode]\n-pub struct spanned<T> { node: T, span: span }\n-\n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n macro_rules! interner_key (\n@@ -40,7 +36,7 @@ pub impl<S: Encoder> ident: Encodable<S> {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {\n-            None => fail ~\"encode: TLS interner not set up\",\n+            None => die!(~\"encode: TLS interner not set up\"),\n             Some(intr) => intr\n         };\n \n@@ -53,7 +49,7 @@ pub impl<D: Decoder> ident: Decodable<D> {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n         } {\n-            None => fail ~\"decode: TLS interner not set up\",\n+            None => die!(~\"decode: TLS interner not set up\"),\n             Some(intr) => intr\n         };\n \n@@ -690,7 +686,7 @@ pub enum expr_ {\n     expr_cast(@expr, @Ty),\n     expr_if(@expr, blk, Option<@expr>),\n     expr_while(@expr, blk),\n-    /* Conditionless loop (can be exited with break, cont, ret, or fail)\n+    /* Conditionless loop (can be exited with break, cont, or ret)\n        Same semantics as while(true) { body }, but typestate knows that the\n        (implicit) condition is always true. */\n     expr_loop(blk, Option<ident>),\n@@ -716,7 +712,6 @@ pub enum expr_ {\n     expr_index(@expr, @expr),\n     expr_path(@path),\n     expr_addr_of(mutability, @expr),\n-    expr_fail(Option<@expr>),\n     expr_break(Option<ident>),\n     expr_again(Option<ident>),\n     expr_ret(Option<@expr>),\n@@ -928,8 +923,8 @@ pub enum trait_method {\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n pub impl int_ty : ToStr {\n-    pure fn to_str() -> ~str {\n-        ::ast_util::int_ty_to_str(self)\n+    pure fn to_str(&self) -> ~str {\n+        ::ast_util::int_ty_to_str(*self)\n     }\n }\n \n@@ -964,8 +959,8 @@ pub impl int_ty : cmp::Eq {\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n pub impl uint_ty : ToStr {\n-    pure fn to_str() -> ~str {\n-        ::ast_util::uint_ty_to_str(self)\n+    pure fn to_str(&self) -> ~str {\n+        ::ast_util::uint_ty_to_str(*self)\n     }\n }\n \n@@ -998,8 +993,8 @@ pub impl uint_ty : cmp::Eq {\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n pub impl float_ty : ToStr {\n-    pure fn to_str() -> ~str {\n-        ::ast_util::float_ty_to_str(self)\n+    pure fn to_str(&self) -> ~str {\n+        ::ast_util::float_ty_to_str(*self)\n     }\n }\n \n@@ -1101,8 +1096,8 @@ pub enum Onceness {\n }\n \n pub impl Onceness : ToStr {\n-    pure fn to_str() -> ~str {\n-        match self {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n             Once => ~\"once\",\n             Many => ~\"many\"\n         }\n@@ -1193,8 +1188,8 @@ pub enum purity {\n }\n \n pub impl purity : ToStr {\n-    pure fn to_str() -> ~str {\n-        match self {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n             impure_fn => ~\"impure\",\n             unsafe_fn => ~\"unsafe\",\n             pure_fn => ~\"pure\","}, {"sha": "e6a4639ad80684f732b775a4044686e4b2496d9d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -25,8 +25,8 @@ use core::cmp;\n use core::either;\n use core::str;\n use core::vec;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n use std;\n \n pub enum path_elt {\n@@ -106,7 +106,7 @@ pub enum ast_node {\n     node_struct_ctor(@struct_def, @item, @path),\n }\n \n-pub type map = std::map::HashMap<node_id, ast_node>;\n+pub type map = std::oldmap::HashMap<node_id, ast_node>;\n pub struct ctx {\n     map: map,\n     mut path: path,\n@@ -134,7 +134,7 @@ pub fn mk_ast_map_visitor() -> vt {\n \n pub fn map_crate(diag: span_handler, c: crate) -> map {\n     let cx = ctx {\n-        map: std::map::HashMap(),\n+        map: std::oldmap::HashMap(),\n         mut path: ~[],\n         mut local_id: 0u,\n         diag: diag,\n@@ -316,7 +316,7 @@ pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n                     cx.map.insert(ctor_id,\n                                   node_struct_ctor(struct_def, item, p));\n                 }\n-                _ => fail ~\"struct def parent wasn't an item\"\n+                _ => die!(~\"struct def parent wasn't an item\")\n             }\n         }\n     }\n@@ -400,7 +400,7 @@ pub fn node_item_query<Result>(items: map, id: node_id,\n                            error_msg: ~str) -> Result {\n     match items.find(id) {\n         Some(node_item(it, _)) => query(it),\n-        _ => fail(error_msg)\n+        _ => die!(error_msg)\n     }\n }\n "}, {"sha": "c659d6d602048cf0690e8acf8a6fdebd70cecb08", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 26, "deletions": 48, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use ast::*;\n use ast;\n use ast_util;\n-use codemap::{span, BytePos};\n+use codemap::{span, BytePos, dummy_sp};\n use parse::token;\n use visit;\n \n@@ -24,28 +24,6 @@ use core::str;\n use core::to_bytes;\n use core::vec;\n \n-pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n-    respan(mk_sp(lo, hi), move t)\n-}\n-\n-pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n-    spanned {node: t, span: sp}\n-}\n-\n-pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n-    respan(dummy_sp(), move t)\n-}\n-\n-/* assuming that we're not in macro expansion */\n-pub pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n-    span {lo: lo, hi: hi, expn_info: None}\n-}\n-\n-// make this a const, once the compiler supports it\n-pub pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n-\n-\n-\n pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n                      -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n@@ -66,7 +44,7 @@ pub pure fn stmt_id(s: stmt) -> node_id {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n       stmt_semi(_, id) => id,\n-      stmt_mac(*) => fail ~\"attempted to analyze unexpanded stmt\",\n+      stmt_mac(*) => die!(~\"attempted to analyze unexpanded stmt\")\n     }\n }\n \n@@ -75,7 +53,7 @@ pub fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n       def_variant(enum_id, var_id) => {\n         return {enm: enum_id, var: var_id}\n       }\n-      _ => fail ~\"non-variant in variant_def_ids\"\n+      _ => die!(~\"non-variant in variant_def_ids\")\n     }\n }\n \n@@ -93,7 +71,7 @@ pub pure fn def_id_of_def(d: def) -> def_id {\n         local_def(id)\n       }\n \n-      def_prim_ty(_) => fail\n+      def_prim_ty(_) => die!()\n     }\n }\n \n@@ -320,38 +298,38 @@ pub pure fn struct_field_visibility(field: ast::struct_field) -> visibility {\n }\n \n pub trait inlined_item_utils {\n-    fn ident() -> ident;\n-    fn id() -> ast::node_id;\n-    fn accept<E>(e: E, v: visit::vt<E>);\n+    fn ident(&self) -> ident;\n+    fn id(&self) -> ast::node_id;\n+    fn accept<E>(&self, e: E, v: visit::vt<E>);\n }\n \n pub impl inlined_item: inlined_item_utils {\n-    fn ident() -> ident {\n-        match self {\n-          ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n-          ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n-          ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n-          ii_dtor(_, nm, _, _) => /* FIXME (#2543) */ copy nm\n+    fn ident(&self) -> ident {\n+        match *self {\n+            ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n+            ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n+            ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n+            ii_dtor(_, nm, _, _) => /* FIXME (#2543) */ copy nm\n         }\n     }\n \n-    fn id() -> ast::node_id {\n-        match self {\n-          ii_item(i) => i.id,\n-          ii_foreign(i) => i.id,\n-          ii_method(_, m) => m.id,\n-          ii_dtor(ref dtor, _, _, _) => (*dtor).node.id\n+    fn id(&self) -> ast::node_id {\n+        match *self {\n+            ii_item(i) => i.id,\n+            ii_foreign(i) => i.id,\n+            ii_method(_, m) => m.id,\n+            ii_dtor(ref dtor, _, _, _) => (*dtor).node.id\n         }\n     }\n \n-    fn accept<E>(e: E, v: visit::vt<E>) {\n-        match self {\n-          ii_item(i) => (v.visit_item)(i, e, v),\n-          ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n-          ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-          ii_dtor(ref dtor, _, tps, parent_id) => {\n+    fn accept<E>(&self, e: E, v: visit::vt<E>) {\n+        match *self {\n+            ii_item(i) => (v.visit_item)(i, e, v),\n+            ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n+            ii_method(_, m) => visit::visit_method_helper(m, e, v),\n+            ii_dtor(ref dtor, _, tps, parent_id) => {\n               visit::visit_struct_dtor_helper((*dtor), tps, parent_id, e, v);\n-          }\n+            }\n         }\n     }\n }"}, {"sha": "ca28641c4a3bc62845d327101ec2a93cb62dab99", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,7 +13,7 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::{spanned, dummy_spanned};\n+use codemap::{spanned, dummy_spanned};\n use attr;\n use codemap::BytePos;\n use diagnostic::span_handler;\n@@ -24,8 +24,8 @@ use core::either::Either;\n use core::either;\n use core::option;\n use core::vec;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n use std;\n \n /* Constructors */\n@@ -199,7 +199,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n             // FIXME (#607): Needs implementing\n             // This involves probably sorting the list by name and\n             // meta_item variant\n-            fail ~\"unimplemented meta_item variant\"\n+            die!(~\"unimplemented meta_item variant\")\n           }\n         }\n }\n@@ -269,9 +269,9 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let v: ~[mut @ast::meta_item] = vec::cast_to_mut(items);\n+    let mut v: ~[@ast::meta_item] = items;\n     std::sort::quick_sort(v, lteq);\n-    vec::cast_from_mut(move v)\n+    move v\n }\n \n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n@@ -358,12 +358,12 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n \n pub fn require_unique_names(diagnostic: span_handler,\n                             metas: &[@ast::meta_item]) {\n-    let map = map::HashMap();\n+    let map = oldmap::HashMap();\n     for metas.each |meta| {\n         let name = get_meta_item_name(*meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)\n-        if map.contains_key(name) {\n+        if map.contains_key_ref(&name) {\n             diagnostic.span_fatal(meta.span,\n                                   fmt!(\"duplicate meta item `%s`\", name));\n         }"}, {"sha": "31ed65d8065882ceebeacd489c9b69922ac97129", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 105, "deletions": 31, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -23,8 +23,6 @@ source code snippets, etc.\n \n use core::prelude::*;\n \n-use ast_util;\n-\n use core::cmp;\n use core::dvec::DVec;\n use core::str;\n@@ -130,6 +128,10 @@ pub struct span {\n     expn_info: Option<@ExpnInfo>\n }\n \n+#[auto_encode]\n+#[auto_decode]\n+pub struct spanned<T> { node: T, span: span }\n+\n pub impl span : cmp::Eq {\n     pure fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n@@ -144,10 +146,32 @@ pub impl<S: Encoder> span: Encodable<S> {\n \n pub impl<D: Decoder> span: Decodable<D> {\n     static fn decode(_d: &D) -> span {\n-        ast_util::dummy_sp()\n+        dummy_sp()\n     }\n }\n \n+pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n+    respan(mk_sp(lo, hi), move t)\n+}\n+\n+pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n+    spanned {node: t, span: sp}\n+}\n+\n+pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n+    respan(dummy_sp(), move t)\n+}\n+\n+/* assuming that we're not in macro expansion */\n+pub pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n+    span {lo: lo, hi: hi, expn_info: None}\n+}\n+\n+// make this a const, once the compiler supports it\n+pub pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n+\n+\n+\n /// A source code location used for error reporting\n pub struct Loc {\n     /// Information about the original source\n@@ -158,6 +182,20 @@ pub struct Loc {\n     col: CharPos\n }\n \n+/// A source code location used as the result of lookup_char_pos_adj\n+// Actually, *none* of the clients use the filename *or* file field;\n+// perhaps they should just be removed.\n+pub struct LocWithOpt {\n+    filename: ~str,\n+    line: uint,\n+    col: CharPos,\n+    file: Option<@FileMap>,\n+}\n+\n+// used to be structural records. Better names, anyone?\n+pub struct FileMapAndLine {fm: @FileMap, line: uint}\n+pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+\n /// Extra information for tracking macro expansion of spans\n pub enum ExpnInfo {\n     ExpandedFrom({call_site: span,\n@@ -204,10 +242,19 @@ pub struct FileMap {\n }\n \n pub impl FileMap {\n+    // EFFECT: register a start-of-line offset in the\n+    // table of line-beginnings.\n+    // UNCHECKED INVARIANT: these offsets must be added in the right\n+    // order and must be in the right places; there is shared knowledge\n+    // about what ends a line between this file and parse.rs\n     fn next_line(&self, +pos: BytePos) {\n+        // the new charpos must be > the last one (or it's the first one).\n+        assert ((self.lines.len() == 0)\n+                || (self.lines[self.lines.len() - 1] < pos));\n         self.lines.push(pos);\n     }\n \n+    // get a line from the list of pre-computed line-beginnings\n     pub fn get_line(&self, line: int) -> ~str {\n         unsafe {\n             let begin: BytePos = self.lines[line] - self.start_pos;\n@@ -279,27 +326,25 @@ pub impl CodeMap {\n         return self.lookup_pos(pos);\n     }\n \n-    pub fn lookup_char_pos_adj(&self, +pos: BytePos)\n-        -> {filename: ~str, line: uint, col: CharPos, file: Option<@FileMap>}\n+    pub fn lookup_char_pos_adj(&self, +pos: BytePos) -> LocWithOpt\n     {\n         let loc = self.lookup_char_pos(pos);\n         match (loc.file.substr) {\n-            FssNone => {\n-                {filename: /* FIXME (#2543) */ copy loc.file.name,\n-                 line: loc.line,\n-                 col: loc.col,\n-                 file: Some(loc.file)}\n-            }\n-            FssInternal(sp) => {\n-                self.lookup_char_pos_adj(\n-                    sp.lo + (pos - loc.file.start_pos))\n-            }\n-            FssExternal(ref eloc) => {\n-                {filename: /* FIXME (#2543) */ copy (*eloc).filename,\n-                 line: (*eloc).line + loc.line - 1u,\n-                 col: if loc.line == 1 {eloc.col + loc.col} else {loc.col},\n-                 file: None}\n-            }\n+            FssNone =>\n+            LocWithOpt {\n+                filename: /* FIXME (#2543) */ copy loc.file.name,\n+                line: loc.line,\n+                col: loc.col,\n+                file: Some(loc.file)},\n+            FssInternal(sp) =>\n+            self.lookup_char_pos_adj(\n+                sp.lo + (pos - loc.file.start_pos)),\n+            FssExternal(ref eloc) =>\n+            LocWithOpt {\n+                filename: /* FIXME (#2543) */ copy (*eloc).filename,\n+                line: (*eloc).line + loc.line - 1u,\n+                col: if loc.line == 1 {eloc.col + loc.col} else {loc.col},\n+                file: None}\n         }\n     }\n \n@@ -319,7 +364,7 @@ pub impl CodeMap {\n     }\n \n     pub fn span_to_str(&self, sp: span) -> ~str {\n-        if self.files.len() == 0 && sp == ast_util::dummy_sp() {\n+        if self.files.len() == 0 && sp == dummy_sp() {\n             return ~\"no-location\";\n         }\n \n@@ -356,7 +401,7 @@ pub impl CodeMap {\n         for self.files.each |fm| { if fm.name == filename { return *fm; } }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n-        fail; // (\"asking for \" + filename + \" which we don't know about\");\n+        die!(); // (\"asking for \" + filename + \" which we don't know about\");\n     }\n \n }\n@@ -376,15 +421,14 @@ priv impl CodeMap {\n             }\n         }\n         if (a >= len) {\n-            fail fmt!(\"position %u does not resolve to a source location\",\n-                      pos.to_uint())\n+            die!(fmt!(\"position %u does not resolve to a source location\",\n+                      pos.to_uint()))\n         }\n \n         return a;\n     }\n \n-    fn lookup_line(&self, +pos: BytePos)\n-        -> {fm: @FileMap, line: uint}\n+    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine\n     {\n         let idx = self.lookup_filemap_idx(pos);\n         let f = self.files[idx];\n@@ -394,11 +438,11 @@ priv impl CodeMap {\n             let m = (a + b) / 2u;\n             if f.lines[m] > pos { b = m; } else { a = m; }\n         }\n-        return {fm: f, line: a};\n+        return FileMapAndLine {fm: f, line: a};\n     }\n \n     fn lookup_pos(&self, +pos: BytePos) -> Loc {\n-        let {fm: f, line: a} = self.lookup_line(pos);\n+        let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_local_charpos(pos);\n         let linebpos = f.lines[a];\n@@ -424,11 +468,11 @@ priv impl CodeMap {\n     }\n \n     fn lookup_byte_offset(&self, +bpos: BytePos)\n-        -> {fm: @FileMap, pos: BytePos} {\n+        -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = self.files[idx];\n         let offset = bpos - fm.start_pos;\n-        return {fm: fm, pos: offset};\n+        return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n \n     // Converts an absolute BytePos to a CharPos relative to the file it is\n@@ -458,6 +502,36 @@ priv impl CodeMap {\n     }\n }\n \n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::testing::check_equal;\n+\n+    #[test]\n+    fn t1 () {\n+        let cm = CodeMap::new();\n+        let fm = cm.new_filemap(~\"blork.rs\",@~\"first line.\\nsecond line\");\n+        fm.next_line(BytePos(0));\n+        check_equal(&fm.get_line(0),&~\"first line.\");\n+        // TESTING BROKEN BEHAVIOR:\n+        fm.next_line(BytePos(10));\n+        check_equal(&fm.get_line(1),&~\".\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn t2 () {\n+        let cm = CodeMap::new();\n+        let fm = cm.new_filemap(~\"blork.rs\",@~\"first line.\\nsecond line\");\n+        // TESTING *REALLY* BROKEN BEHAVIOR:\n+        fm.next_line(BytePos(0));\n+        fm.next_line(BytePos(10));\n+        fm.next_line(BytePos(2));\n+    }\n+}\n+\n+\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "c454f5dde2b5174d3f5d27234431e7c84377897f", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -63,7 +63,7 @@ struct codemap_t {\n impl codemap_t: span_handler {\n     fn span_fatal(sp: span, msg: &str) -> ! {\n         self.handler.emit(Some((self.cm, sp)), msg, fatal);\n-        fail;\n+        die!();\n     }\n     fn span_err(sp: span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, error);\n@@ -89,7 +89,7 @@ impl codemap_t: span_handler {\n impl handler_t: handler {\n     fn fatal(msg: &str) -> ! {\n         (self.emit)(None, msg, fatal);\n-        fail;\n+        die!();\n     }\n     fn err(msg: &str) {\n         (self.emit)(None, msg, error);"}, {"sha": "03aa0cde811025573ea94e8393a5249ab4d60a58", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -98,8 +98,8 @@ use ext::base::*;\n use parse;\n \n use core::vec;\n-use std::map;\n-use std::map::HashMap;\n+use std::oldmap;\n+use std::oldmap::HashMap;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -311,7 +311,7 @@ priv impl ext_ctxt {\n     }\n \n     fn stmt(expr: @ast::expr) -> @ast::stmt {\n-        @ast::spanned { node: ast::stmt_semi(expr, self.next_id()),\n+        @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n                        span: expr.span }\n     }\n \n@@ -322,7 +322,7 @@ priv impl ext_ctxt {\n                 self.expr(\n                     span,\n                     ast::expr_lit(\n-                        @ast::spanned { node: ast::lit_str(s),\n+                        @codemap::spanned { node: ast::lit_str(s),\n                                         span: span})),\n                 ast::expr_vstore_uniq))\n     }\n@@ -331,7 +331,7 @@ priv impl ext_ctxt {\n         self.expr(\n             span,\n             ast::expr_lit(\n-                @ast::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n+                @codemap::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n                                 span: span}))\n     }\n \n@@ -342,7 +342,7 @@ priv impl ext_ctxt {\n     }\n \n     fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        ast::spanned {\n+        codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n                 stmts: stmts,\n@@ -355,7 +355,7 @@ priv impl ext_ctxt {\n     }\n \n     fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        ast::spanned {\n+        codemap::spanned {\n             node: ast::blk_ {\n                 view_items: ~[],\n                 stmts: ~[],\n@@ -593,7 +593,7 @@ fn mk_ser_method(\n         ident: cx.ident_of(~\"encode\"),\n         attrs: ~[],\n         tps: ~[],\n-        self_ty: ast::spanned { node: ast::sty_region(ast::m_imm),\n+        self_ty: codemap::spanned { node: ast::sty_region(ast::m_imm),\n                                 span: span },\n         purity: ast::impure_fn,\n         decl: ser_decl,\n@@ -651,7 +651,7 @@ fn mk_deser_method(\n         ident: cx.ident_of(~\"decode\"),\n         attrs: ~[],\n         tps: ~[],\n-        self_ty: ast::spanned { node: ast::sty_static, span: span },\n+        self_ty: codemap::spanned { node: ast::sty_static, span: span },\n         purity: ast::impure_fn,\n         decl: deser_decl,\n         body: deser_body,\n@@ -762,7 +762,7 @@ fn mk_struct_deser_impl(\n             ]\n         );\n \n-        ast::spanned {\n+        codemap::spanned {\n             node: ast::field_ {\n                 mutbl: field.mutbl,\n                 ident: field.ident,\n@@ -812,8 +812,8 @@ fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n     do fields.map |field| {\n         let (ident, mutbl) = match field.node.kind {\n             ast::named_field(ident, mutbl, _) => (ident, mutbl),\n-            _ => fail ~\"[auto_encode] does not support \\\n-                        unnamed fields\",\n+            _ => die!(~\"[auto_encode] does not support \\\n+                        unnamed fields\")\n         };\n \n         field {\n@@ -954,9 +954,9 @@ fn mk_enum_ser_body(\n             ast::tuple_variant_kind(args) =>\n                 ser_variant(cx, span, variant.node.name, v_idx, args),\n             ast::struct_variant_kind(*) =>\n-                fail ~\"struct variants unimplemented\",\n+                die!(~\"struct variants unimplemented\"),\n             ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\",\n+                die!(~\"enum variants unimplemented\"),\n         }\n     };\n \n@@ -1025,7 +1025,7 @@ fn mk_enum_deser_variant_nary(\n }\n \n fn mk_enum_deser_body(\n-    cx: ext_ctxt,\n+    ext_cx: ext_ctxt,\n     span: span,\n     name: ast::ident,\n     variants: ~[ast::variant]\n@@ -1035,112 +1035,117 @@ fn mk_enum_deser_body(\n             ast::tuple_variant_kind(args) => {\n                 if args.is_empty() {\n                     // for a nullary variant v, do \"v\"\n-                    cx.expr_path(span, ~[variant.node.name])\n+                    ext_cx.expr_path(span, ~[variant.node.name])\n                 } else {\n                     // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n                     mk_enum_deser_variant_nary(\n-                        cx,\n+                        ext_cx,\n                         span,\n                         variant.node.name,\n                         args\n                     )\n                 }\n             },\n             ast::struct_variant_kind(*) =>\n-                fail ~\"struct variants unimplemented\",\n+                die!(~\"struct variants unimplemented\"),\n             ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\",\n+                die!(~\"enum variants unimplemented\")\n         };\n \n         let pat = @ast::pat {\n-            id: cx.next_id(),\n-            node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n+            id: ext_cx.next_id(),\n+            node: ast::pat_lit(ext_cx.lit_uint(span, v_idx)),\n             span: span,\n         };\n \n         ast::arm {\n             pats: ~[pat],\n             guard: None,\n-            body: cx.expr_blk(body),\n+            body: ext_cx.expr_blk(body),\n         }\n     };\n \n+    let quoted_expr = quote_expr!(\n+      ::core::sys::begin_unwind(~\"explicit failure\", ~\"empty\", 1);\n+    ).node;\n+\n     let impossible_case = ast::arm {\n         pats: ~[@ast::pat {\n-            id: cx.next_id(),\n+            id: ext_cx.next_id(),\n             node: ast::pat_wild,\n             span: span,\n         }],\n         guard: None,\n \n         // FIXME(#3198): proper error message\n-        body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n+        body: ext_cx.expr_blk(ext_cx.expr(span, quoted_expr)),\n     };\n \n     arms.push(impossible_case);\n \n     // ast for `|i| { match i { $(arms) } }`\n-    let expr_lambda = cx.expr(\n+    let expr_lambda = ext_cx.expr(\n         span,\n         ast::expr_fn_block(\n             ast::fn_decl {\n                 inputs: ~[ast::arg {\n-                    mode: ast::infer(cx.next_id()),\n+                    mode: ast::infer(ext_cx.next_id()),\n                     is_mutbl: false,\n                     ty: @ast::Ty {\n-                        id: cx.next_id(),\n+                        id: ext_cx.next_id(),\n                         node: ast::ty_infer,\n                         span: span\n                     },\n                     pat: @ast::pat {\n-                        id: cx.next_id(),\n+                        id: ext_cx.next_id(),\n                         node: ast::pat_ident(\n                             ast::bind_by_copy,\n-                            ast_util::ident_to_path(span, cx.ident_of(~\"i\")),\n+                            ast_util::ident_to_path(span,\n+                                ext_cx.ident_of(~\"i\")),\n                             None),\n                         span: span,\n                     },\n-                    id: cx.next_id(),\n+                    id: ext_cx.next_id(),\n                 }],\n                 output: @ast::Ty {\n-                    id: cx.next_id(),\n+                    id: ext_cx.next_id(),\n                     node: ast::ty_infer,\n                     span: span,\n                 },\n                 cf: ast::return_val,\n             },\n-            cx.expr_blk(\n-                cx.expr(\n+            ext_cx.expr_blk(\n+                ext_cx.expr(\n                     span,\n-                    ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n+                    ast::expr_match(ext_cx.expr_var(span, ~\"i\"), arms)\n                 )\n             )\n         )\n     );\n \n     // ast for `__d.read_enum_variant($(expr_lambda))`\n-    let expr_lambda = cx.lambda_expr(\n-        cx.expr_call(\n+    let expr_lambda = ext_cx.lambda_expr(\n+        ext_cx.expr_call(\n             span,\n-            cx.expr_field(\n+            ext_cx.expr_field(\n                 span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_enum_variant\")\n+                ext_cx.expr_var(span, ~\"__d\"),\n+                ext_cx.ident_of(~\"read_enum_variant\")\n             ),\n             ~[expr_lambda]\n         )\n     );\n \n     // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n-    cx.expr_call(\n+    ext_cx.expr_call(\n         span,\n-        cx.expr_field(\n+        ext_cx.expr_field(\n             span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_enum\")\n+            ext_cx.expr_var(span, ~\"__d\"),\n+            ext_cx.ident_of(~\"read_enum\")\n         ),\n         ~[\n-            cx.lit_str(span, @cx.str_of(name)),\n+            ext_cx.lit_str(span, @ext_cx.str_of(name)),\n             expr_lambda\n         ]\n     )"}, {"sha": "3efae9559656b16585fc6062800dbee62d123a5e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,17 +11,16 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::dummy_sp;\n use codemap;\n-use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom};\n+use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom, dummy_sp};\n use diagnostic::span_handler;\n use ext;\n use parse;\n use parse::{parser, token};\n \n use core::io;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n // new-style macro! tt code:\n //"}, {"sha": "4d8fd39c9609134f97141a050f9f517b353c8198", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -32,7 +32,7 @@ pub fn mk_expr(cx: ext_ctxt,\n }\n \n pub fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n-    let sp_lit = @ast::spanned { node: lit, span: sp };\n+    let sp_lit = @codemap::spanned { node: lit, span: sp };\n     mk_expr(cx, sp, ast::expr_lit(sp_lit))\n }\n pub fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n@@ -149,7 +149,7 @@ pub fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n }\n pub fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n              -> ast::field {\n-    ast::spanned {\n+    codemap::spanned {\n         node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n         span: sp,\n     }\n@@ -188,7 +188,7 @@ pub fn mk_global_struct_e(cx: ext_ctxt,\n pub fn mk_glob_use(cx: ext_ctxt,\n                    sp: span,\n                    path: ~[ast::ident]) -> @ast::view_item {\n-    let glob = @ast::spanned {\n+    let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n     };\n@@ -209,7 +209,7 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n         span: sp,\n     };\n     let ty = @ast::Ty { id: cx.next_id(), node: ast::ty_infer, span: sp };\n-    let local = @ast::spanned {\n+    let local = @codemap::spanned {\n         node: ast::local_ {\n             is_mutbl: mutbl,\n             ty: ty,\n@@ -219,14 +219,14 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n         },\n         span: sp,\n     };\n-    let decl = ast::spanned {node: ast::decl_local(~[local]), span: sp};\n-    @ast::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n+    let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n+    @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n pub fn mk_block(cx: ext_ctxt, span: span,\n                 view_items: ~[@ast::view_item],\n                 stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n-    let blk = ast::spanned {\n+    let blk = codemap::spanned {\n         node: ast::blk_ {\n              view_items: view_items,\n              stmts: stmts,\n@@ -242,7 +242,7 @@ pub fn mk_block_(cx: ext_ctxt,\n                  span: span,\n                  +stmts: ~[@ast::stmt])\n               -> ast::blk {\n-    ast::spanned {\n+    codemap::spanned {\n         node: ast::blk_ {\n             view_items: ~[],\n             stmts: stmts,\n@@ -257,7 +257,7 @@ pub fn mk_simple_block(cx: ext_ctxt,\n                        span: span,\n                        expr: @ast::expr)\n                     -> ast::blk {\n-    ast::spanned {\n+    codemap::spanned {\n         node: ast::blk_ {\n             view_items: ~[],\n             stmts: ~[],\n@@ -307,13 +307,14 @@ pub fn mk_pat_struct(cx: ext_ctxt,\n     mk_pat(cx, span, move pat)\n }\n pub fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n-    let lit_expr = ast::expr_lit(@ast::spanned { node: ast::lit_bool(value),\n-                                                 span: span });\n+    let lit_expr = ast::expr_lit(@codemap::spanned {\n+        node: ast::lit_bool(value),\n+        span: span });\n     build::mk_expr(cx, span, move lit_expr)\n }\n pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n-    @ast::spanned { node: move stmt_, span: span }\n+    @codemap::spanned { node: move stmt_, span: span }\n }\n pub fn mk_ty_path(cx: ext_ctxt,\n                   span: span,"}, {"sha": "8e87357f8b5b986243334a5fbbc2295e9a8c04a0", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -18,12 +18,12 @@ use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n use ast::{enum_variant_kind, expr, expr_match, ident, item, item_};\n use ast::{item_enum, item_impl, item_struct, m_imm, meta_item, method};\n use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n-use ast::{re_anon, spanned, stmt, struct_def, struct_variant_kind};\n+use ast::{re_anon, stmt, struct_def, struct_variant_kind};\n use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, ty_param};\n use ast::{ty_param_bound, ty_path, ty_rptr, unnamed_field, variant};\n use ext::base::ext_ctxt;\n use ext::build;\n-use codemap::span;\n+use codemap::{span, spanned};\n use parse::token::special_idents::clownshoes_extensions;\n \n use core::dvec;"}, {"sha": "227a86e0766fd3ccb19af9cc9f9a8411e9106e9f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,7 +20,7 @@ use parse::{parser, parse_expr_from_source_str, new_parser_from_tts};\n \n use core::option;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n                    e: expr_, s: span, fld: ast_fold,\n@@ -154,7 +154,7 @@ pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n                        fld: ast_fold) -> Option<@ast::item> {\n \n     let (pth, tts) = match it.node {\n-        item_mac(ast::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n+        item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n             (pth, (*tts))\n         }\n         _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n@@ -234,7 +234,7 @@ pub fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n                 {call_site: sp, callie: {name: *extname, span: exp_sp}}));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n-                    @ast::spanned { node: stmt_expr(e, cx.next_id()),\n+                    @codemap::spanned { node: stmt_expr(e, cx.next_id()),\n                                     span: e.span},\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n@@ -296,6 +296,15 @@ pub fn core_macros() -> ~str {\n         )\n     )\n \n+    macro_rules! fail(\n+        ($msg: expr) => (\n+            ::core::sys::begin_unwind($msg, file!().to_owned(), line!())\n+        );\n+        () => (\n+            die!(~\\\"explicit failure\\\")\n+        )\n+    )\n+\n     macro_rules! fail_unless(\n         ($cond:expr) => {\n             if !$cond {"}, {"sha": "58ab05987a60099d8afa9bd4c283006431b875f9", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -17,10 +17,11 @@ use core::prelude::*;\n \n use ast::{ident, node_id};\n use ast;\n-use ast_util::{ident_to_path, respan, dummy_sp};\n+use ast_util::{ident_to_path};\n use ast_util;\n use attr;\n-use codemap::span;\n+use codemap::{span, respan, dummy_sp};\n+use codemap;\n use ext::base::{ext_ctxt, mk_ctxt};\n use ext::quote::rt::*;\n \n@@ -310,7 +311,7 @@ pub impl ext_ctxt: ext_ctxt_ast_builder {\n         // XXX: Total hack: import `core::kinds::Owned` to work around a\n         // parser bug whereby `fn f<T: ::kinds::Owned>` doesn't parse.\n         let vi = ast::view_item_import(~[\n-            @ast::spanned {\n+            @codemap::spanned {\n                 node: ast::view_path_simple(\n                     self.ident_of(~\"Owned\"),\n                     path(\n@@ -319,19 +320,19 @@ pub impl ext_ctxt: ext_ctxt_ast_builder {\n                             self.ident_of(~\"kinds\"),\n                             self.ident_of(~\"Owned\")\n                         ],\n-                        ast_util::dummy_sp()\n+                        codemap::dummy_sp()\n                     ),\n                     ast::type_value_ns,\n                     self.next_id()\n                 ),\n-                span: ast_util::dummy_sp()\n+                span: codemap::dummy_sp()\n             }\n         ]);\n         let vi = @ast::view_item {\n             node: vi,\n             attrs: ~[],\n             vis: ast::private,\n-            span: ast_util::dummy_sp()\n+            span: codemap::dummy_sp()\n         };\n \n         self.item("}, {"sha": "1502332859cc3a626f6f8a990e209fcc8039b519", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -40,13 +40,13 @@ pub impl parser::Parser: proto_parser {\n         self.expect(token::COLON);\n         let dir = match copy self.token {\n           token::IDENT(n, _) => self.interner.get(n),\n-          _ => fail\n+          _ => die!()\n         };\n         self.bump();\n         let dir = match dir {\n           @~\"send\" => send,\n           @~\"recv\" => recv,\n-          _ => fail\n+          _ => die!()\n         };\n \n         let typarms = if self.token == token::LT {"}, {"sha": "da0ac4e08ab06c0b3445173869dee577428a841d", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,7 +11,7 @@\n // A protocol compiler for Rust.\n \n use ast::ident;\n-use ast_util::dummy_sp;\n+use codemap::dummy_sp;\n use ext::base::ext_ctxt;\n use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n use ext::pipes::ast_builder::{path_global};"}, {"sha": "6a1d93576941db3ff00bb1a9ad85ea353324ee84", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -34,8 +34,8 @@ pub impl direction : cmp::Eq {\n }\n \n pub impl direction: ToStr {\n-    pure fn to_str() -> ~str {\n-        match self {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n           send => ~\"Send\",\n           recv => ~\"Recv\"\n         }"}, {"sha": "4a9a22de50f50b81c542826fdeb128c6fd23e5d8", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -184,7 +184,7 @@ pub mod rt {\n                 Some(ast) => ast,\n                 None => {\n                     error!(\"Parse error with ```\\n%s\\n```\", s);\n-                    fail\n+                    die!()\n                 }\n             }\n         }\n@@ -399,7 +399,7 @@ fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n                                   ~[mk_ident(cx, sp, ident)]);\n         }\n \n-        INTERPOLATED(_) => fail ~\"quote! with interpolated token\",\n+        INTERPOLATED(_) => die!(~\"quote! with interpolated token\"),\n \n         _ => ()\n     }\n@@ -437,7 +437,7 @@ fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n         DOLLAR => \"DOLLAR\",\n         UNDERSCORE => \"UNDERSCORE\",\n         EOF => \"EOF\",\n-        _ => fail\n+        _ => die!()\n     };\n     build::mk_path(cx, sp,\n                    ids_ext(cx, ~[name.to_owned()]))\n@@ -467,7 +467,7 @@ fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree)\n         }\n \n         ast::tt_delim(ref tts) => mk_tts(cx, sp, *tts),\n-        ast::tt_seq(*) => fail ~\"tt_seq in quote!\",\n+        ast::tt_seq(*) => die!(~\"tt_seq in quote!\"),\n \n         ast::tt_nonterminal(sp, ident) => {\n "}, {"sha": "9548db70b94c3e85f7d8652d07f4673517629a27", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,8 +10,7 @@\n \n // Earley-like parser for macros.\n use ast::{matcher, match_tok, match_seq, match_nonterminal, ident};\n-use ast_util::mk_sp;\n-use codemap::BytePos;\n+use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::common::*; //resolve bug?\n use parse::lexer::*; //resolve bug?\n@@ -27,7 +26,7 @@ use core::option;\n use core::str;\n use core::uint;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n /* This is an Earley-like parser, without support for in-grammar nonterminals,\n only by calling out to the main rust parser for named nonterminals (which it\n@@ -125,7 +124,7 @@ pub type matcher_pos = ~{\n pub fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n     match &mpu {\n       &matcher_pos_up(Some(ref mp)) => copy (*mp),\n-      _ => fail\n+      _ => die!()\n     }\n }\n \n@@ -189,16 +188,16 @@ pub fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n              ret_val: HashMap<ident, @named_match>) {\n         match m {\n-          ast::spanned {node: match_tok(_), _} => (),\n-          ast::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n+          codemap::spanned {node: match_tok(_), _} => (),\n+          codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n             for (*more_ms).each() |next_m| {\n                 n_rec(p_s, *next_m, res, ret_val)\n             };\n           }\n-          ast::spanned {\n+          codemap::spanned {\n                 node: match_nonterminal(bind_name, _, idx), span: sp\n           } => {\n-            if ret_val.contains_key(bind_name) {\n+            if ret_val.contains_key_ref(&bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n                                                *p_s.interner.get(bind_name))\n             }\n@@ -239,7 +238,7 @@ pub fn parse(sess: parse_sess,\n         let mut next_eis = ~[]; // or proceed normally\n         let mut eof_eis = ~[];\n \n-        let {tok: tok, sp: sp} = rdr.peek();\n+        let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n \n         /* we append new items to this while we go */\n         while cur_eis.len() > 0u { /* for each Earley Item */\n@@ -362,7 +361,7 @@ pub fn parse(sess: parse_sess,\n                         fmt!(\"%s ('%s')\", *sess.interner.get(name),\n                              *sess.interner.get(bind))\n                       }\n-                      _ => fail\n+                      _ => die!()\n                     } }), ~\" or \");\n                 return error(sp, fmt!(\n                     \"Local ambiguity: multiple parsing options: \\\n@@ -387,7 +386,7 @@ pub fn parse(sess: parse_sess,\n                         parse_nt(rust_parser, *sess.interner.get(name))));\n                     ei.idx += 1u;\n                   }\n-                  _ => fail\n+                  _ => die!()\n                 }\n                 cur_eis.push(move ei);\n "}, {"sha": "31172cbfa85275016c4baf4eb01b8ac34f439133", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,8 +13,7 @@ use core::prelude::*;\n use ast::{ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n-use ast_util::dummy_sp;\n-use codemap::span;\n+use codemap::{span, spanned, dummy_sp};\n use ext::base::{ext_ctxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n use ext::base;\n use ext::tt::macro_parser::{error};\n@@ -27,13 +26,13 @@ use parse::token::{FAT_ARROW, SEMI, LBRACE, RBRACE, nt_matchers, nt_tt};\n use print;\n \n use core::io;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                          arg: ~[ast::token_tree]) -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n-        ast::spanned { node: m, span: dummy_sp() }\n+        spanned { node: m, span: dummy_sp() }\n     }\n \n     let lhs_nm =  cx.parse_sess().interner.gensym(@~\"lhs\");"}, {"sha": "6bf90617a6e96e0fa943135bb4baec9ca7972fb3", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,15 +13,16 @@ use core::prelude::*;\n use ast;\n use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n use ast_util;\n-use codemap::span;\n+use codemap::{span, dummy_sp};\n use diagnostic::span_handler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n+use parse::lexer::TokenAndSpan;\n \n use core::option;\n use core::vec;\n use std;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n enum tt_frame_up { /* to break a circularity */\n     tt_frame_up(Option<tt_frame>)\n@@ -43,7 +44,7 @@ pub type tt_reader = @{\n     interner: @ident_interner,\n     mut cur: tt_frame,\n     /* for MBE-style macro transcription */\n-    interpolations: std::map::HashMap<ident, @named_match>,\n+    interpolations: std::oldmap::HashMap<ident, @named_match>,\n     mut repeat_idx: ~[uint],\n     mut repeat_len: ~[uint],\n     /* cached: */\n@@ -55,21 +56,21 @@ pub type tt_reader = @{\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: span_handler, itr: @ident_interner,\n-                     interp: Option<std::map::HashMap<ident,@named_match>>,\n+                     interp: Option<std::oldmap::HashMap<ident,@named_match>>,\n                      src: ~[ast::token_tree])\n                   -> tt_reader {\n     let r = @{sp_diag: sp_diag, interner: itr,\n               mut cur: @{readme: src, mut idx: 0u, dotdotdoted: false,\n                          sep: None, up: tt_frame_up(option::None)},\n               interpolations: match interp { /* just a convienience */\n-                None => std::map::HashMap(),\n+                None => std::oldmap::HashMap(),\n                 Some(x) => x\n               },\n               mut repeat_idx: ~[],\n               mut repeat_len: ~[],\n               /* dummy values, never read: */\n               mut cur_tok: EOF,\n-              mut cur_span: ast_util::dummy_sp()\n+              mut cur_span: dummy_sp()\n              };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n     return r;\n@@ -149,8 +150,8 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n }\n \n \n-pub fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n-    let ret_val = { tok: r.cur_tok, sp: r.cur_span };\n+pub fn tt_next_token(&&r: tt_reader) -> TokenAndSpan {\n+    let ret_val = TokenAndSpan { tok: r.cur_tok, sp: r.cur_span };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */\n         if ! r.cur.dotdotdoted"}, {"sha": "cfa8a3c11532d7beeed74b52683b42243dcdafa7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -495,7 +495,6 @@ pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n           expr_path(pth) => expr_path(fld.fold_path(pth)),\n-          expr_fail(e) => expr_fail(option::map(&e, |x| fld.fold_expr(*x))),\n           expr_break(opt_ident) =>\n             expr_break(option::map(&opt_ident, |x| fld.fold_ident(*x))),\n           expr_again(opt_ident) =>"}, {"sha": "e6ba543cf790db280ee3e828ec50da5df57f2280", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,7 +11,7 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::spanned;\n+use codemap::spanned;\n use codemap::BytePos;\n use parse::common::*; //resolve bug?\n use parse::token;"}, {"sha": "4ceb04c55d09a495cdc72a6a1d827cbdb1aa9d74", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,6 +13,7 @@\n  */\n \n use ast;\n+use codemap;\n use ast_util::operator_prec;\n \n pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n@@ -31,7 +32,8 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     match e.node {\n         ast::expr_block(\n-            ast::spanned { node: ast::blk_ { rules: ast::default_blk, _ }, _ }\n+            codemap::spanned {\n+                node: ast::blk_ { rules: ast::default_blk, _ }, _ }\n         ) => true,\n       _ => false\n     }"}, {"sha": "d7640ce3a23f8c761e4dbdc035f667730d72a19a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,7 +14,7 @@ use ast;\n use codemap::{BytePos, CharPos, CodeMap, FileMap, Pos};\n use diagnostic;\n use parse::lexer::{is_whitespace, get_str_from, reader};\n-use parse::lexer::{string_reader, bump, is_eof, nextch};\n+use parse::lexer::{string_reader, bump, is_eof, nextch, TokenAndSpan};\n use parse::lexer;\n use parse::token;\n use parse;\n@@ -117,7 +117,7 @@ pub fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n         return str::connect(lines, ~\"\\n\");\n     }\n \n-    fail ~\"not a doc-comment: \" + comment;\n+    die!(~\"not a doc-comment: \" + comment);\n }\n \n fn read_to_eol(rdr: string_reader) -> ~str {\n@@ -295,7 +295,7 @@ fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n         read_block_comment(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n-    } else { fail; }\n+    } else { die!(); }\n     debug!(\"<<< consume comment\");\n }\n \n@@ -334,7 +334,7 @@ pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         let bstart = rdr.pos;\n         rdr.next_token();\n         //discard, and look ahead; we're working with internal state\n-        let {tok: tok, sp: sp} = rdr.peek();\n+        let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(tok) {\n             let s = get_str_from(rdr, bstart);\n             literals.push({lit: s, pos: sp.lo});"}, {"sha": "d82a5a1803949b037824546d2b2fb116d296fd15", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,15 +11,14 @@\n use core::prelude::*;\n \n use ast;\n-use ast_util::spanned;\n-use codemap::BytePos;\n+use codemap::{BytePos, spanned};\n use parse::lexer::reader;\n use parse::parser::Parser;\n use parse::token;\n \n use core::option::{None, Option, Some};\n use core::option;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub type seq_sep = {\n     sep: Option<token::Token>,\n@@ -190,7 +189,9 @@ pub impl Parser {\n         if self.token == token::GT {\n             self.bump();\n         } else if self.token == token::BINOP(token::SHR) {\n-            self.swap(token::GT, self.span.lo + BytePos(1u), self.span.hi);\n+            self.replace_token(token::GT,\n+                               self.span.lo + BytePos(1u),\n+                               self.span.hi);\n         } else {\n             let mut s: ~str = ~\"expected `\";\n             s += token_to_str(self.reader, token::GT);\n@@ -229,7 +230,7 @@ pub impl Parser {\n     }\n \n     fn parse_seq_lt_gt<T: Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> ast::spanned<~[T]> {\n+                                f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n@@ -277,7 +278,7 @@ pub impl Parser {\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     fn parse_seq<T: Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n-                          f: fn(Parser) -> T) -> ast::spanned<~[T]> {\n+                          f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);"}, {"sha": "5decb2351e389a026d1c6e1c7e84a18ac89487a0", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,8 +10,7 @@\n \n use parser::Parser;\n use attr::parser_attr;\n-use ast_util::mk_sp;\n-use codemap::span;\n+use codemap::{span, mk_sp};\n \n type ctx =\n     @{sess: parse::parse_sess,\n@@ -75,7 +74,7 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n         // XXX: Using a dummy span, but this code will go away soon\n         let p0 = new_sub_parser_from_file(cx.sess, cx.cfg,\n                                           modpath,\n-                                          ast_util::dummy_sp());\n+                                          codemap::dummy_sp());\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n         let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n         return (m0.view_items, m0.items, inner_attrs.inner);"}, {"sha": "381183e736cf76e5f3287b0f49e1abca7f4f67ab", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 84, "deletions": 35, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -30,14 +30,17 @@ use std;\n \n pub trait reader {\n     fn is_eof() -> bool;\n-    fn next_token() -> {tok: token::Token, sp: span};\n+    fn next_token() -> TokenAndSpan;\n     fn fatal(~str) -> !;\n     fn span_diag() -> span_handler;\n     pure fn interner() -> @token::ident_interner;\n-    fn peek() -> {tok: token::Token, sp: span};\n+    fn peek() -> TokenAndSpan;\n     fn dup() -> reader;\n }\n \n+#[deriving_eq]\n+pub struct TokenAndSpan {tok: token::Token, sp: span}\n+\n pub type string_reader = @{\n     span_diagnostic: span_handler,\n     src: @~str,\n@@ -79,11 +82,14 @@ pub fn new_low_level_string_reader(span_diagnostic: span_handler,\n               filemap: filemap, interner: itr,\n               /* dummy values; not read */\n               mut peek_tok: token::EOF,\n-              mut peek_span: ast_util::dummy_sp()};\n+              mut peek_span: codemap::dummy_sp()};\n     bump(r);\n     return r;\n }\n \n+// duplicating the string reader is probably a bad idea, in\n+// that using them will cause interleaved pushes of line\n+// offsets to the underlying filemap...\n fn dup_string_reader(&&r: string_reader) -> string_reader {\n     @{span_diagnostic: r.span_diagnostic, src: r.src,\n       mut pos: r.pos,\n@@ -95,8 +101,9 @@ fn dup_string_reader(&&r: string_reader) -> string_reader {\n \n impl string_reader: reader {\n     fn is_eof() -> bool { is_eof(self) }\n-    fn next_token() -> {tok: token::Token, sp: span} {\n-        let ret_val = {tok: self.peek_tok, sp: self.peek_span};\n+    // return the next token. EFFECT: advances the string_reader.\n+    fn next_token() -> TokenAndSpan {\n+        let ret_val = TokenAndSpan {tok: self.peek_tok, sp: self.peek_span};\n         string_advance_token(self);\n         return ret_val;\n     }\n@@ -105,15 +112,15 @@ impl string_reader: reader {\n     }\n     fn span_diag() -> span_handler { self.span_diagnostic }\n     pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> {tok: token::Token, sp: span} {\n-        {tok: self.peek_tok, sp: self.peek_span}\n+    fn peek() -> TokenAndSpan {\n+        TokenAndSpan {tok: self.peek_tok, sp: self.peek_span}\n     }\n     fn dup() -> reader { dup_string_reader(self) as reader }\n }\n \n pub impl tt_reader: reader {\n     fn is_eof() -> bool { self.cur_tok == token::EOF }\n-    fn next_token() -> {tok: token::Token, sp: span} {\n+    fn next_token() -> TokenAndSpan {\n         /* weird resolve bug: if the following `if`, or any of its\n         statements are removed, we get resolution errors */\n         if false {\n@@ -127,27 +134,29 @@ pub impl tt_reader: reader {\n     }\n     fn span_diag() -> span_handler { self.sp_diag }\n     pure fn interner() -> @token::ident_interner { self.interner }\n-    fn peek() -> {tok: token::Token, sp: span} {\n-        { tok: self.cur_tok, sp: self.cur_span }\n+    fn peek() -> TokenAndSpan {\n+        TokenAndSpan { tok: self.cur_tok, sp: self.cur_span }\n     }\n     fn dup() -> reader { dup_tt_reader(self) as reader }\n }\n \n+// EFFECT: advance peek_tok and peek_span to refer to the next token.\n fn string_advance_token(&&r: string_reader) {\n-    for consume_whitespace_and_comments(r).each |comment| {\n-        r.peek_tok = comment.tok;\n-        r.peek_span = comment.sp;\n-        return;\n+    match (consume_whitespace_and_comments(r)) {\n+        Some(comment) => {\n+            r.peek_tok = comment.tok;\n+            r.peek_span = comment.sp;\n+        },\n+        None => {\n+            if is_eof(r) {\n+                r.peek_tok = token::EOF;\n+            } else {\n+                let start_bytepos = r.last_pos;\n+                r.peek_tok = next_token_inner(r);\n+                r.peek_span = codemap::mk_sp(start_bytepos, r.last_pos);\n+            };\n+        }\n     }\n-\n-    if is_eof(r) {\n-        r.peek_tok = token::EOF;\n-    } else {\n-        let start_bytepos = r.last_pos;\n-        r.peek_tok = next_token_inner(r);\n-        r.peek_span = ast_util::mk_sp(start_bytepos, r.last_pos);\n-    };\n-\n }\n \n fn byte_offset(rdr: string_reader) -> BytePos {\n@@ -163,6 +172,8 @@ pub fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n     }\n }\n \n+// EFFECT: advance the StringReader by one character. If a newline is\n+// discovered, add it to the FileMap's list of line start offsets.\n pub fn bump(rdr: string_reader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n@@ -203,7 +214,7 @@ fn hex_digit_val(c: char) -> int {\n     if in_range(c, '0', '9') { return (c as int) - ('0' as int); }\n     if in_range(c, 'a', 'f') { return (c as int) - ('a' as int) + 10; }\n     if in_range(c, 'A', 'F') { return (c as int) - ('A' as int) + 10; }\n-    fail;\n+    die!();\n }\n \n fn bin_digit_value(c: char) -> int { if c == '0' { return 0; } return 1; }\n@@ -233,16 +244,19 @@ fn is_hex_digit(c: char) -> bool {\n \n fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n \n-// might return a sugared-doc-attr\n+// EFFECT: eats whitespace and comments.\n+// returns a Some(sugared-doc-attr) if one exists, None otherwise.\n fn consume_whitespace_and_comments(rdr: string_reader)\n-                                -> Option<{tok: token::Token, sp: span}> {\n+    -> Option<TokenAndSpan> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n }\n \n-// might return a sugared-doc-attr\n+// PRECONDITION: rdr.curr is not whitespace\n+// EFFECT: eats any kind of comment.\n+// returns a Some(sugared-doc-attr) if one exists, None otherwise\n fn consume_any_line_comment(rdr: string_reader)\n-                                -> Option<{tok: token::Token, sp: span}> {\n+                                -> Option<TokenAndSpan> {\n     if rdr.curr == '/' {\n         match nextch(rdr) {\n           '/' => {\n@@ -256,9 +270,9 @@ fn consume_any_line_comment(rdr: string_reader)\n                     str::push_char(&mut acc, rdr.curr);\n                     bump(rdr);\n                 }\n-                return Some({\n+                return Some(TokenAndSpan{\n                     tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                    sp: ast_util::mk_sp(start_bpos, rdr.pos)\n+                    sp: codemap::mk_sp(start_bpos, rdr.pos)\n                 });\n             } else {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n@@ -285,7 +299,7 @@ fn consume_any_line_comment(rdr: string_reader)\n \n // might return a sugared-doc-attr\n fn consume_block_comment(rdr: string_reader)\n-                                -> Option<{tok: token::Token, sp: span}> {\n+                                -> Option<TokenAndSpan> {\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n@@ -301,9 +315,9 @@ fn consume_block_comment(rdr: string_reader)\n             acc += ~\"*/\";\n             bump(rdr);\n             bump(rdr);\n-            return Some({\n+            return Some(TokenAndSpan{\n                 tok: token::DOC_COMMENT(rdr.interner.intern(@acc)),\n-                sp: ast_util::mk_sp(start_bpos, rdr.pos)\n+                sp: codemap::mk_sp(start_bpos, rdr.pos)\n             });\n         }\n     } else {\n@@ -403,7 +417,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = u64::from_str_radix(num_str, base as u64).get();\n+        let parsed = u64::from_str_radix(num_str, base as uint).get();\n         match tp {\n           either::Left(t) => return token::LIT_INT(parsed as i64, t),\n           either::Right(t) => return token::LIT_UINT(parsed, t)\n@@ -457,7 +471,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = u64::from_str_radix(num_str, base as u64).get();\n+        let parsed = u64::from_str_radix(num_str, base as uint).get();\n \n         debug!(\"lexing %s as an unsuffixed integer literal\",\n                num_str);\n@@ -702,6 +716,41 @@ fn consume_whitespace(rdr: string_reader) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) { bump(rdr); }\n }\n \n+#[cfg(test)]\n+pub mod test {\n+\n+    use super::*;\n+    use util::interner;\n+    use diagnostic;\n+    use util::testing::{check_equal, check_equal_ptr};\n+    #[test] fn t1 () {\n+        let teststr =\n+            @~\"/* my source file */\n+fn main() { io::println(~\\\"zebra\\\"); }\\n\";\n+        let cm = CodeMap::new();\n+        let fm = cm.new_filemap(~\"zebra.rs\",teststr);\n+        let ident_interner = token::mk_ident_interner(); // interner::mk();\n+        let id = ident_interner.intern(@~\"fn\");\n+        let span_handler =\n+            diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n+        let string_reader = new_string_reader(span_handler,fm,ident_interner);\n+        let tok1 = string_reader.next_token();\n+        let tok2 = TokenAndSpan{\n+            tok:token::IDENT(id, false),\n+            sp:span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n+        check_equal (tok1,tok2);\n+        // the 'main' id is already read:\n+        check_equal (string_reader.last_pos,BytePos(28));\n+        // read another token:\n+        let tok3 = string_reader.next_token();\n+        let tok4 = TokenAndSpan{\n+            tok:token::IDENT(ident_interner.intern (@~\"main\"), false),\n+            sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n+        check_equal (tok3,tok4);\n+        // the lparen is already read:\n+        check_equal (string_reader.last_pos,BytePos(29))\n+    }\n+}\n \n //\n // Local Variables:"}, {"sha": "6169233c1b714dad0ff2266f0f90c68fd4cb770b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,6 +10,7 @@\n \n //! The main parser interface\n \n+\n use ast::node_id;\n use ast;\n use codemap::{span, CodeMap, FileMap, CharPos, BytePos};\n@@ -33,6 +34,7 @@ pub mod token;\n pub mod comments;\n pub mod attr;\n \n+\n /// Common routines shared by parser mods\n pub mod common;\n \n@@ -215,3 +217,4 @@ pub fn new_parser_from_tts(sess: parse_sess, cfg: ast::crate_cfg,\n                                     None, tts);\n     return Parser(sess, cfg, trdr as reader)\n }\n+"}, {"sha": "cdde542bb1f32381c52de8736e455a51f19fcd84", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -21,8 +21,7 @@ use core::prelude::*;\n \n use ast::{expr, expr_lit, lit_nil};\n use ast;\n-use ast_util::{respan};\n-use codemap::span;\n+use codemap::{span, respan};\n use parse::parser::Parser;\n use parse::token::Token;\n use parse::token;\n@@ -138,7 +137,7 @@ pub impl Parser {\n                    desc: &str) {\n         self.span_err(sp, fmt!(\"obsolete syntax: %s\", kind_str));\n \n-        if !self.obsolete_set.contains_key(kind) {\n+        if !self.obsolete_set.contains_key_ref(&kind) {\n             self.sess.span_diagnostic.handler().note(fmt!(\"%s\", desc));\n             self.obsolete_set.insert(kind, ());\n         }"}, {"sha": "5cd78dd90490b5f3243e6b584654cb99b57fb0f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 106, "deletions": 90, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,7 +20,7 @@ use ast::{decl_local, default_blk, deref, div, enum_def, enum_variant_kind};\n use ast::{expl, expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assert, expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n-use ast::{expr_fail, expr_field, expr_fn, expr_fn_block, expr_if, expr_index};\n+use ast::{expr_field, expr_fn, expr_fn_block, expr_if, expr_index};\n use ast::{expr_lit, expr_log, expr_loop, expr_loop_body, expr_mac};\n use ast::{expr_method_call, expr_paren, expr_path, expr_rec, expr_repeat};\n use ast::{expr_ret, expr_swap, expr_struct, expr_tup, expr_unary};\n@@ -55,15 +55,16 @@ use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n use ast::{visibility, vstore, vstore_box, vstore_fixed, vstore_slice};\n use ast::{vstore_uniq};\n use ast;\n-use ast_util::{spanned, respan, mk_sp, ident_to_path, operator_prec};\n+use ast_util::{ident_to_path, operator_prec};\n use ast_util;\n use classify;\n-use codemap::{span,FssNone, BytePos};\n+use codemap::{span,FssNone, BytePos, spanned, respan, mk_sp};\n use codemap;\n use parse::attr::parser_attr;\n use parse::common::{seq_sep_none, token_to_str};\n use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n use parse::lexer::reader;\n+use parse::lexer::TokenAndSpan;\n use parse::obsolete::{ObsoleteClassTraits, ObsoleteModeInFnType};\n use parse::obsolete::{ObsoleteLet, ObsoleteFieldTerminator};\n use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove};\n@@ -86,7 +87,7 @@ use core::either;\n use core::result::Result;\n use core::vec::push;\n use core::vec;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n #[deriving_eq]\n enum restriction {\n@@ -193,7 +194,7 @@ pub fn Parser(sess: parse_sess,\n         token: tok0.tok,\n         span: span0,\n         last_span: span0,\n-        buffer: [mut {tok: tok0.tok, sp: span0}, ..4],\n+        mut buffer: [TokenAndSpan {tok: tok0.tok, sp: span0}, ..4],\n         buffer_start: 0,\n         buffer_end: 0,\n         tokens_consumed: 0u,\n@@ -213,7 +214,7 @@ pub struct Parser {\n     mut token: token::Token,\n     mut span: span,\n     mut last_span: span,\n-    mut buffer: [mut {tok: token::Token, sp: span} * 4],\n+    mut buffer: [TokenAndSpan * 4],\n     mut buffer_start: int,\n     mut buffer_end: int,\n     mut tokens_consumed: uint,\n@@ -234,6 +235,7 @@ pub struct Parser {\n }\n \n pub impl Parser {\n+    // advance the parser by one token\n     fn bump() {\n         self.last_span = self.span;\n         let next = if self.buffer_start == self.buffer_end {\n@@ -247,7 +249,8 @@ pub impl Parser {\n         self.span = next.sp;\n         self.tokens_consumed += 1u;\n     }\n-    fn swap(next: token::Token, +lo: BytePos, +hi: BytePos) {\n+    // EFFECT: replace the current token and span with the given one\n+    fn replace_token(next: token::Token, +lo: BytePos, +hi: BytePos) {\n         self.token = next;\n         self.span = mk_sp(lo, hi);\n     }\n@@ -800,7 +803,7 @@ pub impl Parser {\n             self.bump();\n             self.lit_from_token(tok)\n         };\n-        ast::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n+        codemap::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n     fn parse_path_without_tps() -> @path {\n@@ -875,7 +878,7 @@ pub impl Parser {\n                 self.parse_seq_lt_gt(Some(token::COMMA),\n                                      |p| p.parse_ty(false))\n             } else {\n-                ast::spanned {node: ~[], span: path.span}\n+                codemap::spanned {node: ~[], span: path.span}\n             }\n         };\n \n@@ -917,14 +920,14 @@ pub impl Parser {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n-            node: expr_mac(ast::spanned {node: m, span: mk_sp(lo, hi)}),\n+            node: expr_mac(codemap::spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n     fn mk_lit_u32(i: u32) -> @expr {\n         let span = self.span;\n-        let lv_lit = @ast::spanned { node: lit_uint(i as u64, ty_u32),\n+        let lv_lit = @codemap::spanned { node: lit_uint(i as u64, ty_u32),\n                                      span: span };\n \n         @expr {\n@@ -1031,12 +1034,6 @@ pub impl Parser {\n                 }\n             }\n             hi = self.span.hi;\n-        } else if self.eat_keyword(~\"fail\") {\n-            if can_begin_expr(self.token) {\n-                let e = self.parse_expr();\n-                hi = e.span.hi;\n-                ex = expr_fail(Some(e));\n-            } else { ex = expr_fail(None); }\n         } else if self.eat_keyword(~\"log\") {\n             self.expect(token::LPAREN);\n             let lvl = self.parse_expr();\n@@ -1404,7 +1401,7 @@ pub impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n-                  expr_vec(*) | expr_lit(@ast::spanned {\n+                  expr_vec(*) | expr_lit(@codemap::spanned {\n                     node: lit_str(_), span: _\n                   })\n                   if m == m_imm => {\n@@ -1429,7 +1426,7 @@ pub impl Parser {\n               expr_vec(*) if m == m_mutbl =>\n                 expr_vstore(e, expr_vstore_mut_box),\n               expr_vec(*) if m == m_imm => expr_vstore(e, expr_vstore_box),\n-              expr_lit(@ast::spanned {\n+              expr_lit(@codemap::spanned {\n                   node: lit_str(_), span: _}) if m == m_imm =>\n                 expr_vstore(e, expr_vstore_box),\n               _ => expr_unary(box(m), e)\n@@ -1442,7 +1439,7 @@ pub impl Parser {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n-              expr_vec(*) | expr_lit(@ast::spanned {\n+              expr_vec(*) | expr_lit(@codemap::spanned {\n                 node: lit_str(_), span: _})\n               if m == m_imm => expr_vstore(e, expr_vstore_uniq),\n               _ => expr_unary(uniq(m), e)\n@@ -1453,95 +1450,105 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, ex);\n     }\n \n-\n+    // parse an expression of binops\n     fn parse_binops() -> @expr {\n-        return self.parse_more_binops(self.parse_prefix_expr(), 0);\n+        self.parse_more_binops(self.parse_prefix_expr(), 0)\n     }\n \n+    // parse an expression of binops of at least min_prec precedence\n     fn parse_more_binops(lhs: @expr, min_prec: uint) ->\n         @expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n         let peeked = self.token;\n         if peeked == token::BINOP(token::OR) &&\n             (self.restriction == RESTRICT_NO_BAR_OP ||\n              self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) {\n-            return lhs;\n-        }\n-        if peeked == token::OROR &&\n+            lhs\n+        } else if peeked == token::OROR &&\n             self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP {\n-            return lhs;\n-        }\n-        let cur_opt   = token_to_binop(peeked);\n-        match cur_opt {\n-          Some(cur_op) => {\n-            let cur_prec = operator_prec(cur_op);\n-            if cur_prec > min_prec {\n-                self.bump();\n-                let expr = self.parse_prefix_expr();\n-                let rhs = self.parse_more_binops(expr, cur_prec);\n-                self.get_id(); // see ast_util::op_expr_callee_id\n-                let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n-                                        expr_binary(cur_op, lhs, rhs));\n-                return self.parse_more_binops(bin, min_prec);\n+            lhs\n+        } else {\n+            let cur_opt = token_to_binop(peeked);\n+            match cur_opt {\n+                Some(cur_op) => {\n+                    let cur_prec = operator_prec(cur_op);\n+                    if cur_prec > min_prec {\n+                        self.bump();\n+                        let expr = self.parse_prefix_expr();\n+                        let rhs = self.parse_more_binops(expr, cur_prec);\n+                        self.get_id(); // see ast_util::op_expr_callee_id\n+                        let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                                               expr_binary(cur_op, lhs, rhs));\n+                        self.parse_more_binops(bin, min_prec)\n+                    } else {\n+                        lhs\n+                    }\n+                }\n+                None => {\n+                    if as_prec > min_prec && self.eat_keyword(~\"as\") {\n+                        let rhs = self.parse_ty(true);\n+                        let _as = self.mk_expr(lhs.span.lo,\n+                                               rhs.span.hi,\n+                                               expr_cast(lhs, rhs));\n+                        self.parse_more_binops(_as, min_prec)\n+                    } else {\n+                        lhs\n+                    }\n+                }\n             }\n-          }\n-          _ => ()\n-        }\n-        if as_prec > min_prec && self.eat_keyword(~\"as\") {\n-            let rhs = self.parse_ty(true);\n-            let _as =\n-                self.mk_expr(lhs.span.lo, rhs.span.hi, expr_cast(lhs, rhs));\n-            return self.parse_more_binops(_as, min_prec);\n         }\n-        return lhs;\n     }\n \n+    // parse an assignment expression....\n+    // actually, this seems to be the main entry point for\n+    // parsing an arbitrary expression.\n     fn parse_assign_expr() -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match copy self.token {\n-          token::EQ => {\n-            self.bump();\n-            let rhs = self.parse_expr();\n-            return self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs));\n+            token::EQ => {\n+                self.bump();\n+                let rhs = self.parse_expr();\n+                self.mk_expr(lo, rhs.span.hi, expr_assign(lhs, rhs))\n           }\n           token::BINOPEQ(op) => {\n-            self.bump();\n-            let rhs = self.parse_expr();\n-            let mut aop;\n-            match op {\n-              token::PLUS => aop = add,\n-              token::MINUS => aop = subtract,\n-              token::STAR => aop = mul,\n-              token::SLASH => aop = div,\n-              token::PERCENT => aop = rem,\n-              token::CARET => aop = bitxor,\n-              token::AND => aop = bitand,\n-              token::OR => aop = bitor,\n-              token::SHL => aop = shl,\n-              token::SHR => aop = shr\n-            }\n-            self.get_id(); // see ast_util::op_expr_callee_id\n-            return self.mk_expr(lo, rhs.span.hi,\n-                                expr_assign_op(aop, lhs, rhs));\n+              self.bump();\n+              let rhs = self.parse_expr();\n+              let mut aop;\n+              match op {\n+                  token::PLUS => aop = add,\n+                  token::MINUS => aop = subtract,\n+                  token::STAR => aop = mul,\n+                  token::SLASH => aop = div,\n+                  token::PERCENT => aop = rem,\n+                  token::CARET => aop = bitxor,\n+                  token::AND => aop = bitand,\n+                  token::OR => aop = bitor,\n+                  token::SHL => aop = shl,\n+                  token::SHR => aop = shr\n+              }\n+              self.get_id(); // see ast_util::op_expr_callee_id\n+              self.mk_expr(lo, rhs.span.hi,\n+                           expr_assign_op(aop, lhs, rhs))\n           }\n           token::LARROW => {\n               self.obsolete(copy self.span, ObsoleteBinaryMove);\n               // Bogus value (but it's an error)\n               self.bump(); // <-\n               self.bump(); // rhs\n               self.bump(); // ;\n-              return self.mk_expr(lo, self.span.hi,\n-                                  expr_break(None));\n+              self.mk_expr(lo, self.span.hi,\n+                           expr_break(None))\n           }\n           token::DARROW => {\n             self.bump();\n             let rhs = self.parse_expr();\n-            return self.mk_expr(lo, rhs.span.hi, expr_swap(lhs, rhs));\n+            self.mk_expr(lo, rhs.span.hi, expr_swap(lhs, rhs))\n+          }\n+          _ => {\n+              lhs\n           }\n-          _ => {/* fall through */ }\n         }\n-        return lhs;\n     }\n \n     fn parse_if_expr() -> @expr {\n@@ -1556,7 +1563,7 @@ pub impl Parser {\n             hi = elexpr.span.hi;\n         }\n         let q = {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n-        return self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n+        self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els))\n     }\n \n     fn parse_fn_expr(proto: Proto) -> @expr {\n@@ -1567,8 +1574,9 @@ pub impl Parser {\n         let decl = self.parse_fn_decl(|p| p.parse_arg_or_capture_item());\n \n         let body = self.parse_block();\n-        return self.mk_expr(lo, body.span.hi,\n-                            expr_fn(proto, decl, body, @()));\n+\n+        self.mk_expr(lo, body.span.hi,\n+                            expr_fn(proto, decl, body, @()))\n     }\n \n     // `|args| { ... }` like in `do` expressions\n@@ -1794,7 +1802,7 @@ pub impl Parser {\n                 self.eat(token::COMMA);\n             }\n \n-            let blk = ast::spanned {\n+            let blk = codemap::spanned {\n                 node: ast::blk_ {\n                     view_items: ~[],\n                     stmts: ~[],\n@@ -1812,10 +1820,12 @@ pub impl Parser {\n         return self.mk_expr(lo, hi, expr_match(discriminant, arms));\n     }\n \n+    // parse an expression\n     fn parse_expr() -> @expr {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n+    // parse an expression, subject to the given restriction\n     fn parse_expr_res(r: restriction) -> @expr {\n         let old = self.restriction;\n         self.restriction = r;\n@@ -1943,7 +1953,9 @@ pub impl Parser {\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@ast::spanned {node: lit_str(_), span: _}), _\n+                node: expr_lit(@codemap::spanned {\n+                    node: lit_str(_),\n+                    span: _}), _\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n@@ -1963,7 +1975,9 @@ pub impl Parser {\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@ast::spanned {node: lit_str(_), span: _}), _\n+                node: expr_lit(@codemap::spanned {\n+                    node: lit_str(_),\n+                    span: _}), _\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n@@ -1985,7 +1999,7 @@ pub impl Parser {\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n                   pat_lit(e@@expr {\n-                      node: expr_lit(@ast::spanned {\n+                      node: expr_lit(@codemap::spanned {\n                             node: lit_str(_), span: _}), _\n                   }) => {\n                       let vst = @expr {\n@@ -2011,7 +2025,9 @@ pub impl Parser {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @ast::spanned {node: lit_nil, span: mk_sp(lo, hi)};\n+                let lit = @codemap::spanned {\n+                    node: lit_nil,\n+                    span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n@@ -2381,7 +2397,7 @@ pub impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@ast::spanned {\n+                                    stmts.push(@codemap::spanned {\n                                         node: stmt_semi(e, stmt_id),\n                                         .. *stmt});\n                                 }\n@@ -2406,7 +2422,7 @@ pub impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@ast::spanned {\n+                                    stmts.push(@codemap::spanned {\n                                         node: stmt_mac((*m), true),\n                                         .. *stmt});\n                                 }\n@@ -2500,7 +2516,7 @@ pub impl Parser {\n                           _ => None\n                         }\n                       }\n-                      _ => fail\n+                      _ => die!()\n                     };\n \n                     match maybe_bound {\n@@ -2940,7 +2956,7 @@ pub impl Parser {\n \n         let actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            ast::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n+            codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,\n                                                      self_id: self.get_id(),\n                                                      body: d_body},\n@@ -3445,7 +3461,7 @@ pub impl Parser {\n         self.bump();\n         let mut actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            ast::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n+            codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,\n                                                      self_id: self.get_id(),\n                                                      body: d_body },\n@@ -3737,7 +3753,7 @@ pub impl Parser {\n               _ => self.fatal(~\"expected open delimiter\")\n             };\n             let m = ast::mac_invoc_tt(pth, tts);\n-            let m: ast::mac = ast::spanned { node: m,\n+            let m: ast::mac = codemap::spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n             let item_ = item_mac(m);\n@@ -3892,7 +3908,7 @@ pub impl Parser {\n             let metadata = self.parse_optional_meta();\n             view_item_use(ident, metadata, self.get_id())\n         } else {\n-            fail;\n+            die!();\n         };\n         self.expect(token::SEMI);\n         @ast::view_item { node: node,"}, {"sha": "2770d823bf3776bfdb70be874dcd12ecf72a5e2c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -21,7 +21,7 @@ use core::char;\n use core::cmp;\n use core::str;\n use core::task;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n #[auto_encode]\n #[auto_decode]\n@@ -209,7 +209,7 @@ pub fn to_str(in: @ident_interner, t: Token) -> ~str {\n                       nt_block(*) => ~\"block\",\n                       nt_stmt(*) => ~\"statement\",\n                       nt_pat(*) => ~\"pattern\",\n-                      nt_expr(*) => fail ~\"should have been handled above\",\n+                      nt_expr(*) => die!(~\"should have been handled above\"),\n                       nt_ty(*) => ~\"type\",\n                       nt_ident(*) => ~\"identifier\",\n                       nt_path(*) => ~\"path\",\n@@ -262,7 +262,7 @@ pub fn flip_delimiter(t: token::Token) -> token::Token {\n       token::RPAREN => token::LPAREN,\n       token::RBRACE => token::LBRACE,\n       token::RBRACKET => token::LBRACKET,\n-      _ => fail\n+      _ => die!()\n     }\n }\n \n@@ -454,13 +454,13 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n  */\n pub fn keyword_table() -> HashMap<~str, ()> {\n     let keywords = HashMap();\n-    for temporary_keyword_table().each_key |word| {\n+    for temporary_keyword_table().each_key_ref |&word| {\n         keywords.insert(word, ());\n     }\n-    for strict_keyword_table().each_key |word| {\n+    for strict_keyword_table().each_key_ref |&word| {\n         keywords.insert(word, ());\n     }\n-    for reserved_keyword_table().each_key |word| {\n+    for reserved_keyword_table().each_key_ref |&word| {\n         keywords.insert(word, ());\n     }\n     keywords\n@@ -487,7 +487,7 @@ pub fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"const\", ~\"copy\",\n         ~\"do\", ~\"drop\",\n         ~\"else\", ~\"enum\", ~\"extern\",\n-        ~\"fail\", ~\"false\", ~\"fn\", ~\"for\",\n+        ~\"false\", ~\"fn\", ~\"for\",\n         ~\"if\", ~\"impl\",\n         ~\"let\", ~\"log\", ~\"loop\",\n         ~\"match\", ~\"mod\", ~\"move\", ~\"mut\","}, {"sha": "34ba4526c477ef99cfb9db0658c410965b995d22", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -119,7 +119,7 @@ pub fn tok_str(++t: token) -> ~str {\n     }\n }\n \n-pub fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n+pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n@@ -148,17 +148,17 @@ pub fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer %u\", linewidth);\n-    let token: ~[mut token] = vec::cast_to_mut(vec::from_elem(n, EOF));\n-    let size: ~[mut int] = vec::cast_to_mut(vec::from_elem(n, 0));\n-    let scan_stack: ~[mut uint] = vec::cast_to_mut(vec::from_elem(n, 0u));\n+    let mut token: ~[token] = vec::from_elem(n, EOF);\n+    let mut size: ~[int] = vec::from_elem(n, 0);\n+    let mut scan_stack: ~[uint] = vec::from_elem(n, 0u);\n     printer_(@{out: out,\n                buf_len: n,\n                mut margin: linewidth as int,\n                mut space: linewidth as int,\n                mut left: 0,\n                mut right: 0,\n-               token: move token,\n-               size: move size,\n+               mut token: move token,\n+               mut size: move size,\n                mut left_total: 0,\n                mut right_total: 0,\n                mut scan_stack: move scan_stack,\n@@ -254,8 +254,8 @@ pub type printer_ = {\n     mut space: int, // number of spaces left on line\n     mut left: uint, // index of left side of input stream\n     mut right: uint, // index of right side of input stream\n-    token: ~[mut token], // ring-buffr stream goes through\n-    size: ~[mut int], // ring-buffer of calculated sizes\n+    mut token: ~[token], // ring-buffr stream goes through\n+    mut size: ~[int], // ring-buffer of calculated sizes\n     mut left_total: int, // running size of stream \"...left\"\n     mut right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n@@ -264,7 +264,7 @@ pub type printer_ = {\n     // BEGIN (if there is any) on top of it. Stuff is flushed off the\n     // bottom as it becomes irrelevant due to the primary ring-buffer\n     // advancing.\n-    mut scan_stack: ~[mut uint],\n+    mut scan_stack: ~[uint],\n     mut scan_stack_empty: bool, // top==bottom disambiguator\n     mut top: uint, // index of top of scan_stack\n     mut bottom: uint, // index of bottom of scan_stack\n@@ -532,7 +532,7 @@ pub impl printer {\n           }\n           EOF => {\n             // EOF should never get here.\n-            fail;\n+            die!();\n           }\n         }\n     }"}, {"sha": "5079766239b00b98900b7d3164c198542c2f32ff", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -422,10 +422,10 @@ pub fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n         word(s.s, ~\"]\");\n       }\n       ast::ty_mac(_) => {\n-          fail ~\"print_type doesn't know how to print a ty_mac\";\n+          die!(~\"print_type doesn't know how to print a ty_mac\");\n       }\n       ast::ty_infer => {\n-          fail ~\"print_type shouldn't see a ty_infer\";\n+          die!(~\"print_type shouldn't see a ty_infer\");\n       }\n \n     }\n@@ -575,7 +575,7 @@ pub fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(ast::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n+      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n@@ -617,7 +617,7 @@ pub fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n         word_space(s, ~\"=\");\n         match enum_definition.variants[0].node.kind {\n             ast::tuple_variant_kind(args) => print_type(s, args[0].ty),\n-            _ => fail ~\"newtype syntax with struct?\"\n+            _ => die!(~\"newtype syntax with struct?\")\n         }\n         word(s.s, ~\";\");\n         end(s);\n@@ -686,7 +686,7 @@ pub fn print_struct(s: ps,\n             }\n \n             match field.node.kind {\n-                ast::named_field(*) => fail ~\"unexpected named field\",\n+                ast::named_field(*) => die!(~\"unexpected named field\"),\n                 ast::unnamed_field => {\n                     maybe_print_comment(s, field.span.lo);\n                     print_type(s, field.node.ty);\n@@ -709,7 +709,7 @@ pub fn print_struct(s: ps,\n \n         for struct_def.fields.each |field| {\n             match field.node.kind {\n-                ast::unnamed_field => fail ~\"unexpected unnamed field\",\n+                ast::unnamed_field => die!(~\"unexpected unnamed field\"),\n                 ast::named_field(ident, mutability, visibility) => {\n                     hardbreak_if_not_bol(s);\n                     maybe_print_comment(s, field.span.lo);\n@@ -995,7 +995,7 @@ pub fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n               }\n               // BLEAH, constraints would be great here\n               _ => {\n-                  fail ~\"print_if saw if with weird alternative\";\n+                  die!(~\"print_if saw if with weird alternative\");\n               }\n             }\n           }\n@@ -1296,7 +1296,7 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n                         }\n                         end(s); // close enclosing cbox\n                     }\n-                    None => fail\n+                    None => die!()\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n@@ -1393,13 +1393,6 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n         word(s.s, ~\"]\");\n       }\n       ast::expr_path(path) => print_path(s, path, true),\n-      ast::expr_fail(maybe_fail_val) => {\n-        word(s.s, ~\"fail\");\n-        match maybe_fail_val {\n-          Some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n-          _ => ()\n-        }\n-      }\n       ast::expr_break(opt_ident) => {\n         word(s.s, ~\"break\");\n         space(s.s);\n@@ -2013,24 +2006,24 @@ pub fn print_literal(s: ps, &&lit: @ast::lit) {\n       ast::lit_int(i, t) => {\n         if i < 0_i64 {\n             word(s.s,\n-                 ~\"-\" + u64::to_str(-i as u64, 10u)\n+                 ~\"-\" + u64::to_str_radix(-i as u64, 10u)\n                  + ast_util::int_ty_to_str(t));\n         } else {\n             word(s.s,\n-                 u64::to_str(i as u64, 10u)\n+                 u64::to_str_radix(i as u64, 10u)\n                  + ast_util::int_ty_to_str(t));\n         }\n       }\n       ast::lit_uint(u, t) => {\n         word(s.s,\n-             u64::to_str(u, 10u)\n+             u64::to_str_radix(u, 10u)\n              + ast_util::uint_ty_to_str(t));\n       }\n       ast::lit_int_unsuffixed(i) => {\n         if i < 0_i64 {\n-            word(s.s, ~\"-\" + u64::to_str(-i as u64, 10u));\n+            word(s.s, ~\"-\" + u64::to_str_radix(-i as u64, 10u));\n         } else {\n-            word(s.s, u64::to_str(i as u64, 10u));\n+            word(s.s, u64::to_str_radix(i as u64, 10u));\n         }\n       }\n       ast::lit_float(f, t) => {\n@@ -2241,10 +2234,11 @@ pub mod test {\n     use parse;\n     use super::*;\n     //use util;\n+    use util::testing::check_equal;\n \n     fn string_check<T : Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n-            fail (fmt!(\"given %?, expected %?\",given,expected));\n+            die!(fmt!(\"given %?, expected %?\",given,expected));\n         }\n     }\n \n@@ -2257,19 +2251,19 @@ pub mod test {\n             inputs: ~[],\n             output: @ast::Ty {id: 0,\n                               node: ast::ty_nil,\n-                              span: ast_util::dummy_sp()},\n+                              span: codemap::dummy_sp()},\n             cf: ast::return_val\n         };\n-        assert fun_to_str(decl, abba_ident, ~[],mock_interner)\n-            == ~\"fn abba()\";\n+        check_equal (&fun_to_str(decl, abba_ident, ~[],mock_interner),\n+                     &~\"fn abba()\");\n     }\n \n     #[test]\n     fn test_variant_to_str() {\n         let mock_interner = parse::token::mk_fake_ident_interner();\n         let ident = mock_interner.intern(@~\"principal_skinner\");\n \n-        let var = ast_util::respan(ast_util::dummy_sp(), ast::variant_ {\n+        let var = codemap::respan(codemap::dummy_sp(), ast::variant_ {\n             name: ident,\n             attrs: ~[],\n             // making this up as I go.... ?\n@@ -2280,7 +2274,7 @@ pub mod test {\n         });\n \n         let varstr = variant_to_str(var,mock_interner);\n-        string_check(&varstr,&~\"pub principal_skinner\");\n+        check_equal(&varstr,&~\"pub principal_skinner\");\n     }\n }\n "}, {"sha": "a6d50b9cf0908760e4175d7d9d9a06697d51ac16", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -46,10 +46,11 @@ pub mod ast_map;\n pub mod visit;\n pub mod fold;\n pub mod util {\n-    #[path = \"interner.rs\"]\n     pub mod interner;\n+    pub mod testing;\n }\n \n+\n #[path = \"parse/mod.rs\"]\n pub mod parse;\n \n@@ -86,3 +87,4 @@ pub mod ext {\n \n     pub mod trace_macros;\n }\n+"}, {"sha": "19b938ccd687a47e097e9992353f2144b299bb79", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -15,13 +15,13 @@\n use core::prelude::*;\n \n use core::dvec::DVec;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n \n pub type hash_interner<T> = {map: HashMap<T, uint>, vect: DVec<T>};\n \n pub fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n-    let m = map::HashMap::<T, uint>();\n+    let m = oldmap::HashMap::<T, uint>();\n     let hi: hash_interner<T> =\n         {map: m, vect: DVec()};\n     move ((move hi) as Interner::<T>)"}, {"sha": "39d3b003e66450b6ef16d0918a28e20bc3fce339", "filename": "src/libsyntax/util/testing.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Futil%2Ftesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Futil%2Ftesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Ftesting.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// support for test cases.\n+use core::cmp;\n+\n+pub pure fn check_equal_ptr<T : cmp::Eq> (given : &T, expected: &T) {\n+    if !((given == expected) && (expected == given )) {\n+        die!(fmt!(\"given %?, expected %?\",given,expected));\n+    }\n+}\n+\n+pub pure fn check_equal<T : cmp::Eq> (given : T, expected: T) {\n+    if !((given == expected) && (expected == given )) {\n+        die!(fmt!(\"given %?, expected %?\",given,expected));\n+    }\n+}"}, {"sha": "eea1a6906e44aa15e1b68cd62e728ba2351498bd", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -485,7 +485,6 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         (v.visit_expr)(b, e, v);\n       }\n       expr_path(p) => visit_path(p, e, v),\n-      expr_fail(eo) => visit_expr_opt(eo, e, v),\n       expr_break(_) => (),\n       expr_again(_) => (),\n       expr_ret(eo) => visit_expr_opt(eo, e, v),"}, {"sha": "c4fd0e3d9353744c38c9ff1be123a923242dd000", "filename": "src/rt/circular_buffer.cpp", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,204 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n- * A simple resizable circular buffer.\n- */\n-\n-#include \"circular_buffer.h\"\n-#include \"rust_globals.h\"\n-#include \"rust_kernel.h\"\n-\n-circular_buffer::circular_buffer(rust_kernel *kernel, size_t unit_sz) :\n-    kernel(kernel),\n-    unit_sz(unit_sz),\n-    _buffer_sz(initial_size()),\n-    _next(0),\n-    _unread(0),\n-    _buffer((uint8_t *)kernel->malloc(_buffer_sz, \"circular_buffer\")) {\n-\n-    assert(unit_sz && \"Unit size must be larger than zero.\");\n-\n-    KLOG(kernel, mem, \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n-         \"-> circular_buffer=0x%\" PRIxPTR,\n-         _buffer_sz, _unread, this);\n-\n-    assert(_buffer && \"Failed to allocate buffer.\");\n-}\n-\n-circular_buffer::~circular_buffer() {\n-    KLOG(kernel, mem, \"~circular_buffer 0x%\" PRIxPTR, this);\n-    assert(_buffer);\n-    assert(_unread == 0 && \"didn't expect bytes in the circular buffer\");\n-\n-    kernel->free(_buffer);\n-}\n-\n-size_t\n-circular_buffer::initial_size() {\n-    assert(unit_sz > 0);\n-    return INITIAL_CIRCULAR_BUFFER_SIZE_IN_UNITS * unit_sz;\n-}\n-\n-/**\n- * Copies the unread data from this buffer to the \"dst\" address.\n- */\n-void\n-circular_buffer::transfer(void *dst) {\n-    assert(dst);\n-    assert(_unread <= _buffer_sz);\n-\n-    uint8_t *ptr = (uint8_t *) dst;\n-\n-    // First copy from _next to either the end of the unread\n-    // items or the end of the buffer\n-    size_t head_sz;\n-    if (_next + _unread <= _buffer_sz) {\n-        head_sz = _unread;\n-    } else {\n-        head_sz = _buffer_sz - _next;\n-    }\n-    assert(_next + head_sz <= _buffer_sz);\n-    memcpy(ptr, _buffer + _next, head_sz);\n-\n-    // Then copy any other items from the beginning of the buffer\n-    assert(_unread >= head_sz);\n-    size_t tail_sz = _unread - head_sz;\n-    assert(head_sz + tail_sz <= _buffer_sz);\n-    memcpy(ptr + head_sz, _buffer, tail_sz);\n-}\n-\n-/**\n- * Copies the data at the \"src\" address into this buffer. The buffer is\n- * grown if it isn't large enough.\n- */\n-void\n-circular_buffer::enqueue(void *src) {\n-    assert(src);\n-    assert(_unread <= _buffer_sz);\n-    assert(_buffer);\n-\n-    // Grow if necessary.\n-    if (_unread == _buffer_sz) {\n-        grow();\n-    }\n-\n-    KLOG(kernel, mem, \"circular_buffer enqueue \"\n-         \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n-         _unread, _next, _buffer_sz, unit_sz);\n-\n-    assert(_unread < _buffer_sz);\n-    assert(_unread + unit_sz <= _buffer_sz);\n-\n-    // Copy data\n-    size_t dst_idx = _next + _unread;\n-    assert(dst_idx >= _buffer_sz || dst_idx + unit_sz <= _buffer_sz);\n-    if (dst_idx >= _buffer_sz) {\n-        dst_idx -= _buffer_sz;\n-\n-        assert(_next >= unit_sz);\n-        assert(dst_idx <= _next - unit_sz);\n-    }\n-\n-    assert(dst_idx + unit_sz <= _buffer_sz);\n-    memcpy(&_buffer[dst_idx], src, unit_sz);\n-    _unread += unit_sz;\n-\n-    KLOG(kernel, mem, \"circular_buffer pushed data at index: %d\", dst_idx);\n-}\n-\n-/**\n- * Copies data from this buffer to the \"dst\" address. The buffer is\n- * shrunk if possible. If the \"dst\" address is NULL, then the message\n- * is dequeued but is not copied.\n- */\n-void\n-circular_buffer::dequeue(void *dst) {\n-    assert(unit_sz > 0);\n-    assert(_unread >= unit_sz);\n-    assert(_unread <= _buffer_sz);\n-    assert(_buffer);\n-\n-    KLOG(kernel, mem,\n-             \"circular_buffer dequeue \"\n-             \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n-             _unread, _next, _buffer_sz, unit_sz);\n-\n-    assert(_next + unit_sz <= _buffer_sz);\n-    if (dst != NULL) {\n-        memcpy(dst, &_buffer[_next], unit_sz);\n-    }\n-    KLOG(kernel, mem, \"shifted data from index %d\", _next);\n-    _unread -= unit_sz;\n-    _next += unit_sz;\n-    if (_next == _buffer_sz) {\n-        _next = 0;\n-    }\n-\n-    // Shrink if possible.\n-    if (_buffer_sz > initial_size() && _unread <= _buffer_sz / 4) {\n-        shrink();\n-    }\n-}\n-\n-void\n-circular_buffer::grow() {\n-    size_t new_buffer_sz = _buffer_sz * 2;\n-    KLOG(kernel, mem, \"circular_buffer is growing to %d bytes\",\n-         new_buffer_sz);\n-    void *new_buffer = kernel->malloc(new_buffer_sz,\n-                                    \"new circular_buffer (grow)\");\n-    transfer(new_buffer);\n-    kernel->free(_buffer);\n-    _buffer = (uint8_t *)new_buffer;\n-    _next = 0;\n-    _buffer_sz = new_buffer_sz;\n-}\n-\n-void\n-circular_buffer::shrink() {\n-    size_t new_buffer_sz = _buffer_sz / 2;\n-    assert(initial_size() <= new_buffer_sz);\n-    KLOG(kernel, mem, \"circular_buffer is shrinking to %d bytes\",\n-         new_buffer_sz);\n-    void *new_buffer = kernel->malloc(new_buffer_sz,\n-                                    \"new circular_buffer (shrink)\");\n-    transfer(new_buffer);\n-    kernel->free(_buffer);\n-    _buffer = (uint8_t *)new_buffer;\n-    _next = 0;\n-    _buffer_sz = new_buffer_sz;\n-}\n-\n-uint8_t *\n-circular_buffer::peek() {\n-    return &_buffer[_next];\n-}\n-\n-bool\n-circular_buffer::is_empty() {\n-    return _unread == 0;\n-}\n-\n-size_t\n-circular_buffer::size() {\n-    return _unread;\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "172fa5c625b73b6b5d432afc4c96bebe2d4ff5cc", "filename": "src/rt/circular_buffer.h", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Fcircular_buffer.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Fcircular_buffer.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.h?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,72 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n- *\n- */\n-\n-#ifndef CIRCULAR_BUFFER_H\n-#define CIRCULAR_BUFFER_H\n-\n-#include \"rust_globals.h\"\n-#include \"rust_kernel.h\"\n-\n-class\n-circular_buffer : public kernel_owned<circular_buffer> {\n-    static const size_t INITIAL_CIRCULAR_BUFFER_SIZE_IN_UNITS = 8;\n-\n-public:\n-    rust_kernel *kernel;\n-    // Size of the data unit in bytes.\n-    const size_t unit_sz;\n-    circular_buffer(rust_kernel *kernel, size_t unit_sz);\n-    ~circular_buffer();\n-    void transfer(void *dst);\n-    void enqueue(void *src);\n-    void dequeue(void *dst);\n-    uint8_t *peek();\n-    bool is_empty();\n-    size_t size();\n-\n-private:\n-    // private and undefined to disable copying\n-    circular_buffer(const circular_buffer& rhs);\n-    circular_buffer& operator=(const circular_buffer& rhs);\n-\n-private:\n-    size_t initial_size();\n-    void grow();\n-    void shrink();\n-\n-    // Size of the buffer in bytes.\n-    size_t _buffer_sz;\n-\n-    // Byte offset within the buffer where to read the next unit of data.\n-    size_t _next;\n-\n-    // Number of bytes that have not been read from the buffer.\n-    size_t _unread;\n-\n-    // The buffer itself.\n-    uint8_t *_buffer;\n-};\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//\n-\n-#endif /* CIRCULAR_BUFFER_H */"}, {"sha": "32f2c4ebde2acddf1dc5769e7b86ce9d06447bd4", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -17,7 +17,6 @@\n #include \"sync/timer.h\"\n #include \"sync/rust_thread.h\"\n #include \"rust_abi.h\"\n-#include \"rust_port.h\"\n \n #include <time.h>\n \n@@ -694,88 +693,13 @@ rust_sched_threads() {\n     return task->sched->max_number_of_threads();\n }\n \n-extern \"C\" CDECL rust_port*\n-rust_port_take(rust_port_id id) {\n-    rust_task *task = rust_get_current_task();\n-    return task->kernel->get_port_by_id(id);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_drop(rust_port *p) {\n-    assert(p != NULL);\n-    p->deref();\n-}\n-\n-extern \"C\" CDECL rust_task_id\n-rust_port_task(rust_port *p) {\n-    assert(p != NULL);\n-    return p->task->id;\n-}\n-\n-extern \"C\" CDECL rust_port*\n-new_port(size_t unit_sz) {\n-    rust_task *task = rust_get_current_task();\n-    LOG(task, comm, \"new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n-        (uintptr_t) task, task->name, unit_sz);\n-    // port starts with refcount == 1\n-    return new (task->kernel, \"rust_port\") rust_port(task, unit_sz);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_begin_detach(rust_port *port, uintptr_t *yield) {\n-    rust_task *task = rust_get_current_task();\n-    LOG(task, comm, \"rust_port_detach(0x%\" PRIxPTR \")\", (uintptr_t) port);\n-    port->begin_detach(yield);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_end_detach(rust_port *port) {\n-    port->end_detach();\n-}\n-\n-extern \"C\" CDECL void\n-del_port(rust_port *port) {\n-    rust_task *task = rust_get_current_task();\n-    LOG(task, comm, \"del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n-    delete port;\n-}\n-\n-extern \"C\" CDECL size_t\n-rust_port_size(rust_port *port) {\n-    return port->size();\n-}\n-\n-extern \"C\" CDECL rust_port_id\n-get_port_id(rust_port *port) {\n-    return port->id;\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-rust_port_id_send(rust_port_id target_port_id, void *sptr) {\n-    rust_task *task = rust_get_current_task();\n-    return (uintptr_t)task->kernel->send_to_port(target_port_id, sptr);\n-}\n-\n // This is called by an intrinsic on the Rust stack and must run\n // entirely in the red zone. Do not call on the C stack.\n extern \"C\" CDECL MUST_CHECK bool\n rust_task_yield(rust_task *task, bool *killed) {\n     return task->yield();\n }\n \n-extern \"C\" CDECL void\n-port_recv(uintptr_t *dptr, rust_port *port, uintptr_t *yield) {\n-    port->receive(dptr, yield);\n-}\n-\n-extern \"C\" CDECL void\n-rust_port_select(rust_port **dptr, rust_port **ports,\n-                 size_t n_ports, uintptr_t *yield) {\n-    rust_task *task = rust_get_current_task();\n-    rust_port_selector *selector = task->get_port_selector();\n-    selector->select(task, dptr, ports, n_ports, yield);\n-}\n-\n extern \"C\" CDECL void\n rust_set_exit_status(intptr_t code) {\n     rust_task *task = rust_get_current_task();"}, {"sha": "99a6ed94944703a79c0de5cf095b273d9afbf199", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,7 +11,6 @@\n \n \n #include \"rust_kernel.h\"\n-#include \"rust_port.h\"\n #include \"rust_util.h\"\n #include \"rust_scheduler.h\"\n #include \"rust_sched_launcher.h\"\n@@ -26,7 +25,6 @@ rust_kernel::rust_kernel(rust_env *env) :\n     _region(env, true),\n     _log(NULL),\n     max_task_id(INIT_TASK_ID-1), // sync_add_and_fetch increments first\n-    max_port_id(1),\n     rval(0),\n     max_sched_id(1),\n     killed(false),\n@@ -264,47 +262,6 @@ rust_kernel::generate_task_id() {\n     return id;\n }\n \n-rust_port_id\n-rust_kernel::register_port(rust_port *port) {\n-    uintptr_t new_live_ports;\n-    rust_port_id new_port_id;\n-    {\n-        scoped_lock with(port_lock);\n-        new_port_id = max_port_id++;\n-        port_table.put(new_port_id, port);\n-        new_live_ports = port_table.count();\n-    }\n-    assert(new_port_id != INTPTR_MAX && \"Hit the maximum port id\");\n-    KLOG_(\"Registered port %\" PRIdPTR, new_port_id);\n-    KLOG_(\"Total outstanding ports: %d\", new_live_ports);\n-    return new_port_id;\n-}\n-\n-void\n-rust_kernel::release_port_id(rust_port_id id) {\n-    KLOG_(\"Releasing port %\" PRIdPTR, id);\n-    uintptr_t new_live_ports;\n-    {\n-        scoped_lock with(port_lock);\n-        port_table.remove(id);\n-        new_live_ports = port_table.count();\n-    }\n-    KLOG_(\"Total outstanding ports: %d\", new_live_ports);\n-}\n-\n-rust_port *\n-rust_kernel::get_port_by_id(rust_port_id id) {\n-    assert(id != 0 && \"invalid port id\");\n-    scoped_lock with(port_lock);\n-    rust_port *port = NULL;\n-    // get leaves port unchanged if not found.\n-    port_table.get(id, &port);\n-    if(port) {\n-        port->ref();\n-    }\n-    return port;\n-}\n-\n #ifdef __WIN32__\n void\n rust_kernel::win32_require(LPCTSTR fn, BOOL ok) {\n@@ -400,21 +357,6 @@ rust_kernel::begin_shutdown() {\n     allow_scheduler_exit();\n }\n \n-bool\n-rust_kernel::send_to_port(rust_port_id chan, void *sptr) {\n-    KLOG_(\"rust_port_id*_send port: 0x%\" PRIxPTR, (uintptr_t) chan);\n-\n-    rust_port *port = get_port_by_id(chan);\n-    if(port) {\n-        port->send(sptr);\n-        port->deref();\n-        return true;\n-    } else {\n-        KLOG_(\"didn't get the port\");\n-        return false;\n-    }\n-}\n-\n void\n rust_kernel::register_exit_function(spawn_fn runner, fn_env_pair *f) {\n     scoped_lock with(at_exit_lock);"}, {"sha": "c3d5a5a19bb4fe22d3f4d4fab97f1fedb9495447", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -15,8 +15,7 @@\n    The kernel is primarily responsible for managing the lifetime of\n    schedulers, which in turn run rust tasks. It provides a memory\n    allocator and logging service for use by other runtime components,\n-   it creates unique task and port ids and provides global access\n-   to ports by id.\n+   it creates unique task ids.\n \n    The kernel runs until there are no live schedulers.\n \n@@ -56,13 +55,11 @@ class rust_scheduler;\n class rust_sched_driver;\n class rust_sched_launcher_factory;\n struct rust_task_thread;\n-class rust_port;\n \n-// Scheduler, task, and port handles. These uniquely identify within a\n+// Scheduler, task handles. These uniquely identify within a\n // single kernel instance the objects they represent.\n typedef intptr_t rust_sched_id;\n typedef intptr_t rust_task_id;\n-typedef intptr_t rust_port_id;\n \n typedef std::map<rust_sched_id, rust_scheduler*> sched_map;\n \n@@ -80,12 +77,6 @@ class rust_kernel {\n     // The next task id\n     rust_task_id max_task_id;\n \n-    // Protects max_port_id and port_table\n-    lock_and_signal port_lock;\n-    // The next port id\n-    rust_task_id max_port_id;\n-    hash_map<rust_port_id, rust_port *> port_table;\n-\n     lock_and_signal rval_lock;\n     int rval;\n \n@@ -163,10 +154,6 @@ class rust_kernel {\n \n     rust_task_id generate_task_id();\n \n-    rust_port_id register_port(rust_port *port);\n-    rust_port *get_port_by_id(rust_port_id id);\n-    void release_port_id(rust_port_id tid);\n-\n     void set_exit_status(int code);\n \n     rust_sched_id main_sched_id() { return main_scheduler; }\n@@ -177,8 +164,6 @@ class rust_kernel {\n     void inc_weak_task_count();\n     void dec_weak_task_count();\n \n-    bool send_to_port(rust_port_id chan, void *sptr);\n-\n     void register_exit_function(spawn_fn runner, fn_env_pair *f);\n };\n "}, {"sha": "befa209d62fd475ebf40f478efd1f467748be692", "filename": "src/rt/rust_port.cpp", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,153 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_port.h\"\n-#include \"rust_task.h\"\n-\n-rust_port::rust_port(rust_task *task, size_t unit_sz)\n-    : ref_count(1), kernel(task->kernel), task(task),\n-      unit_sz(unit_sz), buffer(kernel, unit_sz) {\n-\n-    LOG(task, comm,\n-        \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n-        PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n-\n-    id = kernel->register_port(this);\n-}\n-\n-rust_port::~rust_port() {\n-    LOG(task, comm, \"~rust_port 0x%\" PRIxPTR, (uintptr_t) this);\n-}\n-\n-void rust_port::ref() {\n-    scoped_lock with(ref_lock);\n-    ref_count++;\n-}\n-\n-void rust_port::deref() {\n-    scoped_lock with(ref_lock);\n-    ref_count--;\n-    if (!ref_count) {\n-        // The port owner is waiting for the port to be detached (if it\n-        // hasn't already been killed)\n-        scoped_lock with(task->lifecycle_lock);\n-        if (task->blocked_on(&detach_cond)) {\n-            task->wakeup_inner(&detach_cond);\n-        }\n-    }\n-}\n-\n-void rust_port::begin_detach(uintptr_t *yield) {\n-    *yield = false;\n-\n-    kernel->release_port_id(id);\n-\n-    scoped_lock with(ref_lock);\n-    ref_count--;\n-\n-    if (ref_count != 0) {\n-        task->block(&detach_cond, \"waiting for port detach\");\n-        *yield = true;\n-    }\n-}\n-\n-void rust_port::end_detach() {\n-    // Just take the lock to make sure that the thread that signaled\n-    // the detach_cond isn't still holding it\n-    scoped_lock with(ref_lock);\n-    assert(ref_count == 0);\n-}\n-\n-void rust_port::send(void *sptr) {\n-    bool did_rendezvous = false;\n-    {\n-        scoped_lock with(lock);\n-\n-        buffer.enqueue(sptr);\n-\n-        assert(!buffer.is_empty() &&\n-               \"rust_chan::transmit with nothing to send.\");\n-\n-        {\n-            scoped_lock with(task->lifecycle_lock);\n-            if (task->blocked_on(this)) {\n-                KLOG(kernel, comm, \"dequeued in rendezvous_ptr\");\n-                buffer.dequeue(task->rendezvous_ptr);\n-                task->rendezvous_ptr = 0;\n-                task->wakeup_inner(this);\n-                did_rendezvous = true;\n-            }\n-        }\n-    }\n-\n-    if (!did_rendezvous) {\n-        // If the task wasn't waiting specifically on this port,\n-        // it may be waiting on a group of ports\n-\n-        rust_port_selector *port_selector = task->get_port_selector();\n-        // The port selector will check if the task is blocked, not us.\n-        port_selector->msg_sent_on(this);\n-    }\n-}\n-\n-void rust_port::receive(void *dptr, uintptr_t *yield) {\n-    LOG(task, comm, \"port: 0x%\" PRIxPTR \", dptr: 0x%\" PRIxPTR\n-        \", size: 0x%\" PRIxPTR,\n-        (uintptr_t) this, (uintptr_t) dptr, unit_sz);\n-\n-    scoped_lock with(lock);\n-\n-    *yield = false;\n-\n-    if (buffer.is_empty() == false) {\n-        buffer.dequeue(dptr);\n-        LOG(task, comm, \"<=== read data ===\");\n-        return;\n-    }\n-    memset(dptr, 0, buffer.unit_sz);\n-\n-    // No data was buffered on any incoming channel, so block this task on\n-    // the port. Remember the rendezvous location so that any sender task\n-    // can write to it before waking up this task.\n-\n-    LOG(task, comm, \"<=== waiting for rendezvous data ===\");\n-    task->rendezvous_ptr = (uintptr_t*) dptr;\n-    task->block(this, \"waiting for rendezvous data\");\n-\n-    // Blocking the task might fail if the task has already been killed, but\n-    // in the event of both failure and success the task needs to yield. On\n-    // success, it yields and waits to be unblocked. On failure it yields and\n-    // is then fails the task.\n-\n-    *yield = true;\n-}\n-\n-size_t rust_port::size() {\n-    scoped_lock with(lock);\n-    return buffer.size();\n-}\n-\n-void rust_port::log_state() {\n-    LOG(task, comm,\n-        \"port size: %d\",\n-        buffer.size());\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "3bbc3cfaa32c98535337c9897510bbf52fc15a18", "filename": "src/rt/rust_port.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.h?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_PORT_H\n-#define RUST_PORT_H\n-\n-#include \"rust_globals.h\"\n-#include \"circular_buffer.h\"\n-\n-class port_detach_cond : public rust_cond { };\n-\n-class rust_port : public kernel_owned<rust_port>, public rust_cond {\n-private:\n-    // Protects ref_count and detach_cond\n-    lock_and_signal ref_lock;\n-    intptr_t ref_count;\n-    port_detach_cond detach_cond;\n-\n-public:\n-    void ref();\n-    void deref();\n-\n-public:\n-    rust_port_id id;\n-\n-    rust_kernel *kernel;\n-    rust_task *task;\n-    size_t unit_sz;\n-    circular_buffer buffer;\n-\n-    lock_and_signal lock;\n-\n-public:\n-    rust_port(rust_task *task, size_t unit_sz);\n-    ~rust_port();\n-\n-    void log_state();\n-    void send(void *sptr);\n-    void receive(void *dptr, uintptr_t *yield);\n-    size_t size();\n-\n-    void begin_detach(uintptr_t *yield);\n-    void end_detach();\n-};\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//\n-\n-#endif /* RUST_PORT_H */"}, {"sha": "19745ffc7a186e32bd765bdefd7af1807133ce7c", "filename": "src/rt/rust_port_selector.cpp", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port_selector.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port_selector.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.cpp?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,103 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"rust_port.h\"\n-#include \"rust_port_selector.h\"\n-#include \"rust_task.h\"\n-\n-rust_port_selector::rust_port_selector()\n-    : ports(NULL), n_ports(0) {\n-}\n-\n-void\n-rust_port_selector::select(rust_task *task, rust_port **dptr,\n-                           rust_port **ports,\n-                           size_t n_ports, uintptr_t *yield) {\n-\n-    assert(this->ports == NULL);\n-    assert(this->n_ports == 0);\n-    assert(dptr != NULL);\n-    assert(ports != NULL);\n-    assert(n_ports != 0);\n-    assert(yield != NULL);\n-\n-    *yield = false;\n-    size_t locks_taken = 0;\n-    bool found_msg = false;\n-\n-    // Take each port's lock as we iterate through them because\n-    // if none of them contain a usable message then we need to\n-    // block the task before any of them can try to send another\n-    // message.\n-\n-    // Start looking for ports from a different index each time.\n-    size_t j = isaac_rand(&task->sched_loop->rctx);\n-    for (size_t i = 0; i < n_ports; i++) {\n-        size_t k = (i + j) % n_ports;\n-        rust_port *port = ports[k];\n-        assert(port != NULL);\n-\n-        port->lock.lock();\n-        locks_taken++;\n-\n-        if (port->buffer.size() > 0) {\n-            *dptr = port;\n-            found_msg = true;\n-            break;\n-        }\n-    }\n-\n-    if (!found_msg) {\n-        this->ports = ports;\n-        this->n_ports = n_ports;\n-        assert(task->rendezvous_ptr == NULL);\n-        task->rendezvous_ptr = (uintptr_t*)dptr;\n-        task->block(this, \"waiting for select rendezvous\");\n-\n-        // Blocking the task might fail if the task has already been\n-        // killed, but in the event of both failure and success the\n-        // task needs to yield. On success, it yields and waits to be\n-        // unblocked. On failure it yields and is then fails the task.\n-\n-        *yield = true;\n-    }\n-\n-    for (size_t i = 0; i < locks_taken; i++) {\n-        size_t k = (i + j) % n_ports;\n-        rust_port *port = ports[k];\n-        port->lock.unlock();\n-    }\n-}\n-\n-void\n-rust_port_selector::msg_sent_on(rust_port *port) {\n-    rust_task *task = port->task;\n-\n-    port->lock.must_not_have_lock();\n-\n-    // Prevent two ports from trying to wake up the task\n-    // simultaneously\n-    scoped_lock with(task->lifecycle_lock);\n-\n-    if (task->blocked_on(this)) {\n-        for (size_t i = 0; i < n_ports; i++) {\n-            if (port == ports[i]) {\n-                // This was one of the ports we were waiting on\n-                ports = NULL;\n-                n_ports = 0;\n-                *task->rendezvous_ptr = (uintptr_t) port;\n-                task->rendezvous_ptr = NULL;\n-                task->wakeup_inner(this);\n-                return;\n-            }\n-        }\n-    }\n-}"}, {"sha": "919d61f7cee6067aa033cb059b4d3a85e364cee7", "filename": "src/rt/rust_port_selector.h", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port_selector.h", "raw_url": "https://github.com/rust-lang/rust/raw/6f0bede97c3468eaba8cf59702d04c7ede8f4b0a/src%2Frt%2Frust_port_selector.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.h?ref=6f0bede97c3468eaba8cf59702d04c7ede8f4b0a", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef RUST_PORT_SELECTOR_H\n-#define RUST_PORT_SELECTOR_H\n-\n-#include \"rust_globals.h\"\n-\n-class rust_port;\n-\n-class rust_port_selector : public rust_cond {\n- private:\n-    rust_port **ports;\n-    size_t n_ports;\n-\n- public:\n-    rust_port_selector();\n-\n-    void select(rust_task *task,\n-                rust_port **dptr,\n-                rust_port **ports,\n-                size_t n_ports,\n-                uintptr_t *yield);\n-\n-    void msg_sent_on(rust_port *port);\n-};\n-\n-#endif /* RUST_PORT_SELECTOR_H */"}, {"sha": "a9246963ca462a8cf9b1ff8e102d28875c5fef8c", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -21,7 +21,6 @@\n \n #include \"rust_task.h\"\n #include \"rust_env.h\"\n-#include \"rust_port.h\"\n #include \"rust_globals.h\"\n #include \"rust_crate_map.h\"\n \n@@ -37,7 +36,6 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     kernel(sched_loop->kernel),\n     name(name),\n     list_index(-1),\n-    rendezvous_ptr(0),\n     boxed(sched_loop->kernel->env, &local_region),\n     local_region(&sched_loop->local_region),\n     unwinding(false),\n@@ -344,12 +342,6 @@ void rust_task::fail_sched_loop() {\n     sched_loop->fail();\n }\n \n-frame_glue_fns*\n-rust_task::get_frame_glue_fns(uintptr_t fp) {\n-    fp -= sizeof(uintptr_t);\n-    return *((frame_glue_fns**) fp);\n-}\n-\n void rust_task::assert_is_running()\n {\n     scoped_lock with(lifecycle_lock);"}, {"sha": "bff4af09b32f4855a6f4bf363842c1ecfcf446a2", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -116,7 +116,6 @@\n #include \"rust_kernel.h\"\n #include \"boxed_region.h\"\n #include \"rust_stack.h\"\n-#include \"rust_port_selector.h\"\n #include \"rust_type.h\"\n #include \"rust_sched_loop.h\"\n \n@@ -219,14 +218,6 @@ rust_task : public kernel_owned<rust_task>\n     const char *const name;\n     int32_t list_index;\n \n-    // Rendezvous pointer for receiving data when blocked on a port. If we're\n-    // trying to read data and no data is available on any incoming channel,\n-    // we block on the port, and yield control to the scheduler. Since, we\n-    // were not able to read anything, we remember the location where the\n-    // result should go in the rendezvous_ptr, and let the sender write to\n-    // that location before waking us up.\n-    uintptr_t* rendezvous_ptr;\n-\n     boxed_region boxed;\n     memory_region local_region;\n \n@@ -270,8 +261,6 @@ rust_task : public kernel_owned<rust_task>\n     uintptr_t next_c_sp;\n     uintptr_t next_rust_sp;\n \n-    rust_port_selector port_selector;\n-\n     // Called when the atomic refcount reaches zero\n     void delete_this();\n \n@@ -302,8 +291,6 @@ rust_task : public kernel_owned<rust_task>\n                                char const *file,\n                                size_t line);\n \n-    friend class rust_port;\n-    friend class rust_port_selector;\n     bool block_inner(rust_cond *on, const char* name);\n     void wakeup_inner(rust_cond *from);\n     bool blocked_on(rust_cond *cond);\n@@ -360,8 +347,6 @@ rust_task : public kernel_owned<rust_task>\n     // Propagate failure to the entire rust runtime.\n     void fail_sched_loop();\n \n-    frame_glue_fns *get_frame_glue_fns(uintptr_t fp);\n-\n     void *calloc(size_t size, const char *tag);\n \n     // Use this function sparingly. Depending on the ref count is generally\n@@ -381,8 +366,6 @@ rust_task : public kernel_owned<rust_task>\n     void call_on_rust_stack(void *args, void *fn_ptr);\n     bool have_c_stack() { return c_stack != NULL; }\n \n-    rust_port_selector *get_port_selector() { return &port_selector; }\n-\n     rust_task_state get_state() { return state; }\n     rust_cond *get_cond() { return cond; }\n     const char *get_cond_name() { return cond_name; }"}, {"sha": "0e6df8e14a451948229cb044a0a61a94de7b2282", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -124,23 +124,6 @@ struct s_trace_args {\n     size_t line;\n };\n \n-extern \"C\" CDECL void\n-upcall_s_trace(s_trace_args *args) {\n-    rust_task *task = args->task;\n-    LOG_UPCALL_ENTRY(task);\n-    LOG(task, trace, \"Trace %s:%d: %s\",\n-        args->file, args->line, args->msg);\n-}\n-\n-extern \"C\" CDECL void\n-upcall_trace(char const *msg,\n-             char const *file,\n-             size_t line) {\n-    rust_task *task = rust_get_current_task();\n-    s_trace_args args = {task,msg,file,line};\n-    UPCALL_SWITCH_STACK(task, &args, upcall_s_trace);\n-}\n-\n /**********************************************************************\n  * Allocate an object in the exchange heap\n  */\n@@ -302,17 +285,6 @@ rust_upcall_free(void* ptr) {\n     upcall_free(ptr);\n }\n \n-/**********************************************************************\n- * Sanity checks on boxes, insert when debugging possible\n- * use-after-free bugs.  See maybe_validate_box() in trans.rs.\n- */\n-\n-extern \"C\" CDECL void\n-upcall_validate_box(rust_opaque_box* ptr) {\n-    // XXX: Remove after snapshot\n-    abort();\n-}\n-\n /**********************************************************************/\n \n extern \"C\" _Unwind_Reason_Code\n@@ -369,12 +341,6 @@ upcall_rust_personality(int version,\n     return args.retval;\n }\n \n-extern \"C\" void\n-upcall_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n-    // XXX: Remove after snapshot\n-    abort();\n-}\n-\n // NB: This needs to be blazing fast. Don't switch stacks\n extern \"C\" CDECL void *\n upcall_new_stack(size_t stk_sz, void *args_addr, size_t args_sz) {"}, {"sha": "dcc02341e76de259b187c1f45b8411940ef586d9", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -1,14 +1,12 @@\n debug_box\n debug_fn\n debug_opaque\n-del_port\n debug_ptrcast\n debug_tag\n debug_tydesc\n debug_get_stk_seg\n debug_abi_1\n debug_abi_2\n-get_port_id\n get_task_id\n get_time\n rust_tzset\n@@ -17,12 +15,8 @@ rust_localtime\n rust_timegm\n rust_mktime\n last_os_error\n-new_port\n new_task\n-port_recv\n precise_time_ns\n-rust_port_id_send\n-rust_port_select\n rand_free\n rand_new\n rand_new_seeded\n@@ -45,9 +39,6 @@ rust_list_files\n rust_list_files2\n rust_log_console_on\n rust_log_console_off\n-rust_port_begin_detach\n-rust_port_end_detach\n-rust_port_size\n rust_process_wait\n rust_ptr_eq\n rust_run_program\n@@ -69,10 +60,7 @@ task_clear_event_reject\n task_wait_event\n task_signal_event\n upcall_fail\n-upcall_trace\n upcall_free\n-upcall_validate_box\n-upcall_log_type\n upcall_malloc\n upcall_rust_personality\n upcall_call_shim_on_c_stack\n@@ -171,9 +159,6 @@ rust_dbg_do_nothing\n rust_dbg_breakpoint\n rust_osmain_sched_id\n rust_compare_and_swap_ptr\n-rust_port_take\n-rust_port_drop\n-rust_port_task\n rust_task_inhibit_kill\n rust_task_allow_kill\n rust_task_inhibit_yield"}, {"sha": "c0140bff5b13ac975dd07d0922eaab586b0576da", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -18,7 +18,7 @@ pub mod kitty {\n     }\n \n     pub impl cat : ToStr {\n-       pure fn to_str() -> ~str { copy self.name }\n+       pure fn to_str(&self) -> ~str { copy self.name }\n     }\n \n     priv impl cat {"}, {"sha": "e9f799d1f75014319cc3d631fe4e375a5c749025", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -25,7 +25,7 @@ pub fn alist_get<A: Copy, B: Copy>(lst: alist<A,B>, k: A) -> B {\n     for lst.data.each |entry| {\n         if eq_fn(entry.key, k) { return entry.value; }\n     }\n-    fail;\n+    die!();\n }\n \n #[inline]"}, {"sha": "05d5cee47f2c866b822fb6fa754961c9e74c2d4c", "filename": "src/test/auxiliary/impl_privacy_xc_1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -0,0 +1,10 @@\n+#[crate_type = \"lib\"];\n+\n+pub struct Fish {\n+    x: int\n+}\n+\n+impl Fish {\n+    fn swim(&self) {}\n+}\n+"}, {"sha": "009e132f5985daac75c0308456941c921eb85e75", "filename": "src/test/auxiliary/impl_privacy_xc_2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -0,0 +1,15 @@\n+#[crate_type = \"lib\"];\n+\n+pub struct Fish {\n+    x: int\n+}\n+\n+mod unexported {\n+    use super::Fish;\n+    impl Fish : Eq {\n+        pure fn eq(&self, _: &Fish) -> bool { true }\n+        pure fn ne(&self, _: &Fish) -> bool { false }\n+    }\n+}\n+\n+"}, {"sha": "748c209229c29b965a9813775089d65acf8c6136", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,7 +14,7 @@\n extern mod std;\n \n use core::dvec::*;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n pub type header_map = HashMap<~str, @DVec<@~str>>;\n "}, {"sha": "a27d7a771c5c3159fd1f68680771cf619af42a7c", "filename": "src/test/auxiliary/issue2378a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fissue2378a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue2378a.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,7 +14,7 @@ impl methods<T:copy> for maybe<T> {\n     fn ~[](idx: uint) -> T {\n         match self {\n           just(t) { t }\n-          nothing { fail; }\n+          nothing { die!(); }\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ef74b61f93aea138470b27eb19278f2ce1dfd3f9", "filename": "src/test/auxiliary/issue_2723_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub unsafe fn f(xs: ~[int]) {\n-    xs.map(|_x| { unsafe fn q() { fail; } });\n+    xs.map(|_x| { unsafe fn q() { die!(); } });\n }"}, {"sha": "cda4f32ab5ceb6cb3f7d12ad6a7de6d90e7baaae", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -36,6 +36,6 @@ impl bool: read {\n pub fn read<T: read Copy>(s: ~str) -> T {\n     match read::readMaybe(s) {\n       Some(x) => x,\n-      _ => fail ~\"read failed!\"\n+      _ => die!(~\"read failed!\")\n     }\n }"}, {"sha": "67c071da26dae6397f81f557097553090ea1a47b", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern mod std;\n-use std::map;\n+use std::oldmap;\n use std::treemap::TreeMap;\n use core::hashmap::linear::*;\n use core::io::WriterUtil;\n@@ -35,7 +35,7 @@ fn timed(result: &mut float,\n fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n     {\n-        let map = map::HashMap();\n+        let map = oldmap::HashMap();\n         do timed(&mut results.sequential_ints) {\n             for uint::range(0, num_keys) |i| {\n                 map.insert(i, i+1);\n@@ -48,7 +48,7 @@ fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n     }\n \n     {\n-        let map = map::HashMap();\n+        let map = oldmap::HashMap();\n         do timed(&mut results.random_ints) {\n             for uint::range(0, num_keys) |i| {\n                 map.insert(rng.next() as uint, i);\n@@ -57,53 +57,53 @@ fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n     }\n \n     {\n-        let map = map::HashMap();\n+        let map = oldmap::HashMap();\n         for uint::range(0, num_keys) |i| {\n             map.insert(i, i);;\n         }\n \n         do timed(&mut results.delete_ints) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(i);\n+                assert map.remove(&i);\n             }\n         }\n     }\n }\n \n fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n     {\n-        let map = map::HashMap();\n+        let map = oldmap::HashMap();\n         do timed(&mut results.sequential_strings) {\n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i, 10);\n+                let s = uint::to_str(i);\n                 map.insert(s, i);\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i, 10);\n+                let s = uint::to_str(i);\n                 assert map.get(s) == i;\n             }\n         }\n     }\n \n     {\n-        let map = map::HashMap();\n+        let map = oldmap::HashMap();\n         do timed(&mut results.random_strings) {\n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint, 10);\n+                let s = uint::to_str(rng.next() as uint);\n                 map.insert(s, i);\n             }\n         }\n     }\n \n     {\n-        let map = map::HashMap();\n+        let map = oldmap::HashMap();\n         for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i, 10), i);\n+            map.insert(uint::to_str(i), i);\n         }\n         do timed(&mut results.delete_strings) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(uint::to_str(i, 10));\n+                assert map.remove(&uint::to_str(i));\n             }\n         }\n     }\n@@ -151,12 +151,12 @@ fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results)\n         let mut map = LinearMap::new();\n         do timed(&mut results.sequential_strings) {\n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i, 10);\n+                let s = uint::to_str(i);\n                 map.insert(s, i);\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i, 10);\n+                let s = uint::to_str(i);\n                 assert map.find(&s).unwrap() == &i;\n             }\n         }\n@@ -166,7 +166,7 @@ fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results)\n         let mut map = LinearMap::new();\n         do timed(&mut results.random_strings) {\n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint, 10);\n+                let s = uint::to_str(rng.next() as uint);\n                 map.insert(s, i);\n             }\n         }\n@@ -175,11 +175,11 @@ fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results)\n     {\n         let mut map = LinearMap::new();\n         for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i, 10), i);\n+            map.insert(uint::to_str(i), i);\n         }\n         do timed(&mut results.delete_strings) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&uint::to_str(i, 10));\n+                assert map.remove(&uint::to_str(i));\n             }\n         }\n     }\n@@ -227,12 +227,12 @@ fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n         let mut map = TreeMap::new();\n         do timed(&mut results.sequential_strings) {\n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i, 10);\n+                let s = uint::to_str(i);\n                 map.insert(s, i);\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i, 10);\n+                let s = uint::to_str(i);\n                 assert map.find(&s).unwrap() == &i;\n             }\n         }\n@@ -242,7 +242,7 @@ fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n         let mut map = TreeMap::new();\n         do timed(&mut results.random_strings) {\n             for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint, 10);\n+                let s = uint::to_str(rng.next() as uint);\n                 map.insert(s, i);\n             }\n         }\n@@ -251,11 +251,11 @@ fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n     {\n         let mut map = TreeMap::new();\n         for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i, 10), i);\n+            map.insert(uint::to_str(i), i);\n         }\n         do timed(&mut results.delete_strings) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&uint::to_str(i, 10));\n+                assert map.remove(&uint::to_str(i));\n             }\n         }\n     }\n@@ -309,7 +309,7 @@ fn main() {\n         let mut results = empty_results();\n         old_int_benchmarks(rng, num_keys, &mut results);\n         old_str_benchmarks(rng, num_keys, &mut results);\n-        write_results(\"std::map::HashMap\", &results);\n+        write_results(\"std::oldmap::HashMap\", &results);\n     }\n \n     {"}, {"sha": "32b6c49189882cb29a10cb84f57d96ecad9bbfa1", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,8 +13,8 @@\n extern mod std;\n \n use std::time::precise_time_s;\n-use std::map;\n-use std::map::{Map, HashMap};\n+use std::oldmap;\n+use std::oldmap::{Map, HashMap};\n \n use io::{Reader, ReaderUtil};\n \n@@ -75,12 +75,12 @@ fn read_line() {\n fn str_set() {\n     let r = rand::Rng();\n \n-    let s = map::HashMap();\n+    let s = oldmap::HashMap();\n \n     for int::range(0, 1000) |_i| {\n-        map::set_add(s, r.gen_str(10));\n+        oldmap::set_add(s, r.gen_str(10));\n     }\n-    \n+\n     let mut found = 0;\n     for int::range(0, 1000) |_i| {\n         match s.find(r.gen_str(10)) {\n@@ -93,7 +93,7 @@ fn str_set() {\n fn vec_plus() {\n     let r = rand::Rng();\n \n-    let mut v = ~[]; \n+    let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n         let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);"}, {"sha": "56f616c6f281524001d8b77d49a18d8c16add766", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     let n = uint::from_str(args[1]).get();\n \n     for uint::range(0u, n) |i| {\n-        let x = uint::to_str(i, 10u);\n+        let x = uint::to_str(i);\n         log(debug, x);\n     }\n }"}, {"sha": "5ade0c9ed25db9dc342139fc0ace76f4123e45bb", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -19,9 +19,9 @@ An implementation of the Graph500 Breadth First Search problem in Rust.\n extern mod std;\n use std::arc;\n use std::time;\n-use std::map;\n-use std::map::Map;\n-use std::map::HashMap;\n+use std::oldmap;\n+use std::oldmap::Map;\n+use std::oldmap::HashMap;\n use std::deque;\n use std::deque::Deque;\n use std::par;\n@@ -41,15 +41,15 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n         let A = 0.57;\n         let B = 0.19;\n         let C = 0.19;\n- \n+\n         if scale == 0u {\n             (i, j)\n         }\n         else {\n             let i = i * 2i64;\n             let j = j * 2i64;\n             let scale = scale - 1u;\n-            \n+\n             let x = r.gen_float();\n \n             if x < A {\n@@ -80,38 +80,38 @@ fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n \n fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n     let graph = do vec::from_fn(N) |_i| {\n-        map::HashMap::<node_id, ()>()\n+        oldmap::HashMap::<node_id, ()>()\n     };\n \n     do vec::each(edges) |e| {\n         match *e {\n             (i, j) => {\n-                map::set_add(graph[i], j);\n-                map::set_add(graph[j], i);\n+                oldmap::set_add(graph[i], j);\n+                oldmap::set_add(graph[j], i);\n             }\n         }\n         true\n     }\n \n     do graph.map() |v| {\n-        map::vec_from_set(*v)\n+        oldmap::vec_from_set(*v)\n     }\n }\n \n fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n-    let keys = map::HashMap::<node_id, ()>();\n+    let keys = oldmap::HashMap::<node_id, ()>();\n     let r = rand::Rng();\n \n-    while keys.size() < n {\n+    while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n         if graph[k].len() > 0u && vec::any(graph[k], |i| {\n             *i != k as node_id\n         }) {\n-            map::set_add(keys, k as node_id);\n+            oldmap::set_add(keys, k as node_id);\n         }\n     }\n-    map::vec_from_set(keys)\n+    oldmap::vec_from_set(keys)\n }\n \n /**\n@@ -120,8 +120,8 @@ fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n  * Nodes that are unreachable have a parent of -1.\n  */\n fn bfs(graph: graph, key: node_id) -> bfs_result {\n-    let marks : ~[mut node_id] \n-        = vec::cast_to_mut(vec::from_elem(vec::len(graph), -1i64));\n+    let mut marks : ~[node_id]\n+        = vec::from_elem(vec::len(graph), -1i64);\n \n     let Q = deque::create();\n \n@@ -140,7 +140,7 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n         };\n     }\n \n-    vec::cast_from_mut(move marks)\n+    move marks\n }\n \n /**\n@@ -212,7 +212,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         match *c {\n           white => { -1i64 }\n           black(parent) => { parent }\n-          _ => { fail ~\"Found remaining gray nodes in BFS\" }\n+          _ => { die!(~\"Found remaining gray nodes in BFS\") }\n         }\n     }\n }\n@@ -294,13 +294,13 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         match *c {\n           white => { -1i64 }\n           black(parent) => { parent }\n-          _ => { fail ~\"Found remaining gray nodes in BFS\" }\n+          _ => { die!(~\"Found remaining gray nodes in BFS\") }\n         }\n     }\n }\n \n /// Performs at least some of the validation in the Graph500 spec.\n-fn validate(edges: ~[(node_id, node_id)], \n+fn validate(edges: ~[(node_id, node_id)],\n             root: node_id, tree: bfs_result) -> bool {\n     // There are 5 things to test. Below is code for each of them.\n \n@@ -336,7 +336,7 @@ fn validate(edges: ~[(node_id, node_id)],\n             path.len() as int\n         }\n     };\n-    \n+\n     if !status { return status }\n \n     // 2. Each tree edge connects vertices whose BFS levels differ by\n@@ -366,7 +366,7 @@ fn validate(edges: ~[(node_id, node_id)],\n         abs(level[u] - level[v]) <= 1\n     };\n \n-    if !status { return status }    \n+    if !status { return status }\n \n     // 4. The BFS tree spans an entire connected component's vertices.\n \n@@ -388,7 +388,7 @@ fn validate(edges: ~[(node_id, node_id)],\n         }\n     };\n \n-    if !status { return status }    \n+    if !status { return status }\n \n     // If we get through here, all the tests passed!\n     true\n@@ -440,44 +440,44 @@ fn main() {\n             let start = time::precise_time_s();\n             let bfs_tree = bfs(copy graph, *root);\n             let stop = time::precise_time_s();\n-            \n+\n             //total_seq += stop - start;\n \n             io::stdout().write_line(\n                 fmt!(\"Sequential BFS completed in %? seconds.\",\n                      stop - start));\n-            \n+\n             if do_validate {\n                 let start = time::precise_time_s();\n                 assert(validate(copy edges, *root, bfs_tree));\n                 let stop = time::precise_time_s();\n-                \n+\n                 io::stdout().write_line(\n                     fmt!(\"Validation completed in %? seconds.\",\n                          stop - start));\n             }\n-            \n+\n             let start = time::precise_time_s();\n             let bfs_tree = bfs2(copy graph, *root);\n             let stop = time::precise_time_s();\n-            \n+\n             total_seq += stop - start;\n-            \n+\n             io::stdout().write_line(\n                 fmt!(\"Alternate Sequential BFS completed in %? seconds.\",\n                      stop - start));\n-            \n+\n             if do_validate {\n                 let start = time::precise_time_s();\n                 assert(validate(copy edges, *root, bfs_tree));\n                 let stop = time::precise_time_s();\n-                \n+\n                 io::stdout().write_line(\n                     fmt!(\"Validation completed in %? seconds.\",\n                          stop - start));\n             }\n         }\n-        \n+\n         let start = time::precise_time_s();\n         let bfs_tree = pbfs(graph_arc, *root);\n         let stop = time::precise_time_s();\n@@ -491,7 +491,7 @@ fn main() {\n             let start = time::precise_time_s();\n             assert(validate(copy edges, *root, bfs_tree));\n             let stop = time::precise_time_s();\n-            \n+\n             io::stdout().write_line(fmt!(\"Validation completed in %? seconds.\",\n                                          stop - start));\n         }"}, {"sha": "4a6eaad9e14ed27c58e7a2cac442b40ba20c098a", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -56,7 +56,7 @@ macro_rules! follow (\n             $(Some($message($($x,)* move next)) => {\n                 let $next = move next;\n                 move $e })+\n-                _ => { fail }\n+                _ => { die!() }\n         }\n     );\n \n@@ -67,7 +67,7 @@ macro_rules! follow (\n             $(Some($message(move next)) => {\n                 let $next = move next;\n                 move $e })+\n-                _ => { fail }\n+                _ => { die!() }\n         }\n     )\n )"}, {"sha": "6de8d13529a58ee04d89d11f8eff73d29fc039de", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,8 +11,8 @@\n // chameneos\n \n extern mod std;\n-use std::map;\n-use std::map::HashMap;\n+use std::oldmap;\n+use std::oldmap::HashMap;\n use std::sort;\n use std::cell::Cell;\n use core::pipes::*;\n@@ -63,7 +63,7 @@ fn show_digit(nn: uint) -> ~str {\n         7 => {~\"seven\"}\n         8 => {~\"eight\"}\n         9 => {~\"nine\"}\n-        _ => {fail ~\"expected digits from 0 to 9...\"}\n+        _ => {die!(~\"expected digits from 0 to 9...\")}\n     }\n }\n "}, {"sha": "0f4f22196ce67554a8e74a9da190b03de8f7f91c", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,15 +14,15 @@\n #[legacy_modes];\n \n extern mod std;\n-use std::map;\n-use std::map::HashMap;\n+use std::oldmap;\n+use std::oldmap::HashMap;\n use std::sort;\n use io::ReaderUtil;\n use pipes::{stream, Port, Chan};\n use cmp::Ord;\n \n // given a map, print a sorted version of it\n-fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str { \n+fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n    fn pct(xx: uint, yy: uint) -> float {\n       return (xx as float) * 100f / (yy as float);\n    }\n@@ -49,10 +49,9 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   mm.each(fn&(key: ~[u8], val: uint) -> bool {\n+   for mm.each_ref |&key, &val| {\n       pairs.push((key, pct(val, total)));\n-      return true;\n-   });\n+   }\n \n    let pairs_sorted = sortKV(pairs);\n \n@@ -95,13 +94,13 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n       ii += 1u;\n    }\n \n-   return vec::slice(bb, len - (nn - 1u), len); \n+   return vec::slice(bb, len - (nn - 1u), len);\n }\n \n fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,\n                            to_parent: pipes::Chan<~str>) {\n-   \n-   let freqs: HashMap<~[u8], uint> = map::HashMap();\n+\n+   let freqs: HashMap<~[u8], uint> = oldmap::HashMap();\n    let mut carry: ~[u8] = ~[];\n    let mut total: uint = 0u;\n \n@@ -118,7 +117,7 @@ fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,\n       });\n    }\n \n-   let buffer = match sz { \n+   let buffer = match sz {\n        1u => { sort_and_fmt(freqs, total) }\n        2u => { sort_and_fmt(freqs, total) }\n        3u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\") }\n@@ -165,11 +164,11 @@ fn main() {\n         do task::spawn_with(move from_parent) |move to_parent_, from_parent| {\n             make_sequence_processor(sz, from_parent, to_parent_);\n         };\n-        \n+\n         move to_child\n     });\n-         \n-   \n+\n+\n    // latch stores true after we've started\n    // reading the sequence of interest\n    let mut proc_mode = false;"}, {"sha": "8cf57b19825935786e3adcdbe70d617eab544879", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,7 +22,7 @@\n \n extern mod std;\n use io::WriterUtil;\n-use std::map::HashMap;\n+use std::oldmap::HashMap;\n \n struct cmplx {\n     re: f64,\n@@ -134,11 +134,11 @@ fn writer(path: ~str, pport: pipes::Port<Line>, size: uint)\n             done += 1_u;\n             let mut prev = done;\n             while prev <= i {\n-                if lines.contains_key(prev) {\n+                if lines.contains_key_ref(&prev) {\n                     debug!(\"WS %u\", prev);\n                     cout.write(lines.get(prev));\n                     done += 1_u;\n-                    lines.remove(prev);\n+                    lines.remove(&prev);\n                     prev += 1_u;\n                 }\n                 else {"}, {"sha": "06b46eab7598b0905338dbb0a6ca3d9a184de0ce", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -68,7 +68,7 @@ fn parse_opts(argv: ~[~str]) -> Config {\n       Ok(ref m) => {\n           return Config {stress: getopts::opt_present(m, ~\"stress\")}\n       }\n-      Err(_) => { fail; }\n+      Err(_) => { die!(); }\n     }\n }\n "}, {"sha": "b679b83228589de369a6c42ad24ca55f43b79fba", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -16,7 +16,7 @@ fn eval_A(i: uint, j: uint) -> float {\n     1.0/(((i+j)*(i+j+1u)/2u+i+1u) as float)\n }\n \n-fn eval_A_times_u(u: &[const float], Au: &[mut float]) {\n+fn eval_A_times_u(u: &[const float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -30,7 +30,7 @@ fn eval_A_times_u(u: &[const float], Au: &[mut float]) {\n     }\n }\n \n-fn eval_At_times_u(u: &[const float], Au: &[mut float]) {\n+fn eval_At_times_u(u: &[const float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -44,7 +44,7 @@ fn eval_At_times_u(u: &[const float], Au: &[mut float]) {\n     }\n }\n \n-fn eval_AtA_times_u(u: &[const float], AtAu: &[mut float]) {\n+fn eval_AtA_times_u(u: &[const float], AtAu: &mut [float]) {\n     let v = vec::cast_to_mut(vec::from_elem(vec::len(u), 0.0));\n     eval_A_times_u(u, v);\n     eval_At_times_u(v, AtAu);"}, {"sha": "0687799cf288c8c085c2382080a36c8fa668a0ad", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,19 +11,18 @@\n // Microbenchmark for the smallintmap library\n \n extern mod std;\n-use std::smallintmap;\n use std::smallintmap::SmallIntMap;\n use io::WriterUtil;\n \n-fn append_sequential(min: uint, max: uint, map: SmallIntMap<uint>) {\n+fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n         map.insert(i, i + 22u);\n     }\n }\n \n-fn check_sequential(min: uint, max: uint, map: SmallIntMap<uint>) {\n+fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n-        assert map.get(i) == i + 22u;\n+        assert *map.get(&i) == i + 22u;\n     }\n }\n \n@@ -43,11 +42,11 @@ fn main() {\n     let mut appendf = 0.0;\n \n     for uint::range(0u, rep) |_r| {\n-        let map = smallintmap::mk();\n+        let mut map = SmallIntMap::new();\n         let start = std::time::precise_time_s();\n-        append_sequential(0u, max, map);\n+        append_sequential(0u, max, &mut map);\n         let mid = std::time::precise_time_s();\n-        check_sequential(0u, max, map);\n+        check_sequential(0u, max, &map);\n         let end = std::time::precise_time_s();\n \n         checkf += (end - mid) as float;"}, {"sha": "750874e80c3a4c69ada680f34e960eee6f2b8b19", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -30,7 +30,7 @@ use io::{ReaderUtil, WriterUtil};\n //\n \n // internal type of sudoku grids\n-type grid = ~[~[mut u8]];\n+type grid = ~[~[u8]];\n \n // exported type of sudoku grids\n pub enum grid_t { grid_ctor(grid), }\n@@ -39,8 +39,8 @@ pub enum grid_t { grid_ctor(grid), }\n pub fn read_grid(f: io::Reader) -> grid_t {\n     assert f.read_line() == ~\"9,9\"; /* assert first line is exactly \"9,9\" */\n \n-    let g = vec::from_fn(10u, {|_i|\n-        vec::cast_to_mut(vec::from_elem(10u, 0 as u8))\n+    let mut g = vec::from_fn(10u, {|_i|\n+        vec::from_elem(10u, 0 as u8)\n     });\n     while !f.eof() {\n         let comps = str::split_char(str::trim(f.read_line()), ',');\n@@ -55,7 +55,7 @@ pub fn read_grid(f: io::Reader) -> grid_t {\n \n // solve sudoku grid\n pub fn solve_grid(g: grid_t) {\n-    fn next_color(g: grid, row: u8, col: u8, start_color: u8) -> bool {\n+    fn next_color(mut g: grid, row: u8, col: u8, start_color: u8) -> bool {\n         if start_color < 10u8 {\n             // colors not yet used\n             let avail = bitv::Bitv(10u, false);\n@@ -118,7 +118,7 @@ pub fn solve_grid(g: grid_t) {\n             ptr = ptr + 1u;\n         } else {\n             // no: redo this field aft recoloring pred; unless there is none\n-            if ptr == 0u { fail ~\"No solution found for this sudoku\"; }\n+            if ptr == 0u { die!(~\"No solution found for this sudoku\"); }\n             ptr = ptr - 1u;\n         }\n     }\n@@ -139,8 +139,8 @@ fn main() {\n     let grid = if vec::len(args) == 1u {\n         // FIXME create sudoku inline since nested vec consts dont work yet\n         // (#3733)\n-        let g = vec::from_fn(10u, |_i| {\n-            vec::cast_to_mut(vec::from_elem(10u, 0 as u8))\n+        let mut g = vec::from_fn(10u, |_i| {\n+            vec::from_elem(10u, 0 as u8)\n         });\n         g[0][1] = 4u8;\n         g[0][3] = 6u8;"}, {"sha": "20dcb079597e5ac99ac6e940c9a8885776cde5c4", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -66,7 +66,7 @@ fn r(l: @nillist) -> r {\n fn recurse_or_fail(depth: int, st: Option<State>) {\n     if depth == 0 {\n         debug!(\"unwinding %.4f\", precise_time_s());\n-        fail;\n+        die!();\n     } else {\n         let depth = depth - 1;\n "}, {"sha": "415df0e9fa8d905b324a13c9b5f23cf0d840059d", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -46,6 +46,6 @@ fn main() {\n     let (p,c) = pipes::stream();\n     child_generation(uint::from_str(args[1]).get(), move c);\n     if p.try_recv().is_none() {\n-        fail ~\"it happened when we slumbered\";\n+        die!(~\"it happened when we slumbered\");\n     }\n }"}, {"sha": "3b1a20136b6626d2487ed2b39481635cbbc547fa", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -77,7 +77,7 @@ fn main() {\n         }\n         // Grandparent group waits for middle group to be gone, then fails\n         error!(\"Grandparent group wakes up and fails\");\n-        fail;\n+        die!();\n     };\n     assert x.is_err();\n }"}, {"sha": "1cce1dee2f79c5b67378eafe32ac815713d3144b", "filename": "src/test/compile-fail/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-join.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,7 +11,7 @@\n // a good test that we merge paths correctly in the presence of a\n // variable that's used before it's declared\n \n-fn my_fail() -> ! { fail; }\n+fn my_fail() -> ! { die!(); }\n \n fn main() {\n     match true { false => { my_fail(); } true => { } }"}, {"sha": "d044d9bdc964b2dd4a153ddb933e6ce5630d79bb", "filename": "src/test/compile-fail/bad-bang-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-bang-ann.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -12,7 +12,7 @@\n // Tests that a function with a ! annotation always actually fails\n \n fn bad_bang(i: uint) -> ! {\n-    if i < 0u { } else { fail; }\n+    if i < 0u { } else { die!(); }\n     //~^ ERROR expected `!` but found `()`\n }\n "}, {"sha": "fea31ef1738269e4b0d3272da762a24fb001c096", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     let x = Some(X { x: () });\n     match move x {\n         Some(ref _y @ move _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail\n+        None => die!()\n     }\n }"}, {"sha": "b58fe788846dddf5f9f4eb8e309564c973a42885", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-2.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n     match move x {\n         Some((ref _y, move _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail\n+        None => die!()\n     }\n }"}, {"sha": "8f9682e662c69d03f1da9cd3d8e297e76cf83c00", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-3.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,6 +22,6 @@ fn main() {\n     let x = some2(X { x: () }, X { x: () });\n     match move x {\n         some2(ref _y, move _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        none2 => fail\n+        none2 => die!()\n     }\n }"}, {"sha": "6c14dd4d141873c77a139852326e753c849b2e8d", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-4.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     let x = Some((X { x: () }, X { x: () }));\n     match move x {\n         Some((move _y, ref _z)) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail\n+        None => die!()\n     }\n }"}, {"sha": "45b5a896f6b119a594a2f535de5042a02444f0e4", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -13,8 +13,8 @@ fn main() {\n     let x = Some(p);\n     c.send(false);\n     match move x {\n-        Some(move z) if z.recv() => { fail }, //~ ERROR cannot bind by-move into a pattern guard\n+        Some(move z) if z.recv() => { die!() }, //~ ERROR cannot bind by-move into a pattern guard\n         Some(move z) => { assert !z.recv(); },\n-        None => fail\n+        None => die!()\n     }\n }"}, {"sha": "c8b8ebecce812f11d069bbaa7d4477eaae5f7c41", "filename": "src/test/compile-fail/bind-by-move-no-lvalues-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-1.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -22,6 +22,6 @@ fn main() {\n     let x = Some(X { x: () });\n     match x {\n         Some(move _z) => { }, //~ ERROR cannot bind by-move when matching an lvalue\n-        None => fail\n+        None => die!()\n     }\n }"}, {"sha": "889ccb3fd99348165a54aa812feb831df84aed7a", "filename": "src/test/compile-fail/bind-by-move-no-lvalues-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-lvalues-2.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -24,6 +24,6 @@ fn main() {\n     let x = Y { y: Some(X { x: () }) };\n     match x.y {\n         Some(move _z) => { }, //~ ERROR cannot bind by-move when matching an lvalue\n-        None => fail\n+        None => die!()\n     }\n }"}, {"sha": "40196fe0817a4e76e5ad7735036d343ad578ac22", "filename": "src/test/compile-fail/bind-by-move-no-sub-bindings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     let x = Some(X { x: () });\n     match move x {\n         Some(move _y @ ref _z) => { }, //~ ERROR cannot bind by-move with sub-bindings\n-        None => fail\n+        None => die!()\n     }\n }"}, {"sha": "6ce631c68a3ddc70e8e2ab723c41fa09fae231df", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -23,7 +23,7 @@ fn main() {\n                 x = X(Left((0,0))); //~ ERROR assigning to captured outer mutable variable\n                 (*f)()\n             },\n-            _ => fail\n+            _ => die!()\n         }\n     }\n }"}, {"sha": "55cbb1cbdcab165282dd9a082c0cd1249ec51de4", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,8 +10,8 @@\n \n //buggy.rs\n extern mod std;\n-use std::map::HashMap;\n-use std::map;\n+use std::oldmap::HashMap;\n+use std::oldmap;\n \n fn main() {\n     let buggy_map :HashMap<uint, &uint> ="}, {"sha": "9aec4b49ef2606a5d869ef05a5e524f40228e396", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -16,7 +16,7 @@ use core::either::{Either, Left, Right};\n                 *x = Right(1.0);\n                 *z\n             }\n-            _ => fail\n+            _ => die!()\n         }\n     }\n "}, {"sha": "0c2903765fc4b853c0f11546882f6eec4e56f7f5", "filename": "src/test/compile-fail/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-into-rvalue.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         Some(ref m) => {\n             msg = m;\n         },  \n-        None => { fail }\n+        None => { die!() }\n     }   \n     io::println(*msg);\n }"}, {"sha": "940677002707b2eff0d1728b6d37587f8d50c5c9", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -2,7 +2,7 @@ fn a() -> &[int] {\n     let vec = [1, 2, 3, 4];\n     let tail = match vec { //~ ERROR illegal borrow\n         [_a, ..tail] => tail,\n-        _ => fail ~\"foo\"\n+        _ => die!(~\"foo\")\n     };\n     move tail\n }"}, {"sha": "0a200e736ba4319eb26095479f2723894c430591", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -4,7 +4,7 @@ fn a() {\n         [~ref _a] => {\n             vec[0] = ~4; //~ ERROR prohibited due to outstanding loan\n         }\n-        _ => fail ~\"foo\"\n+        _ => die!(~\"foo\")\n     }\n }\n "}, {"sha": "64bb571b2dcdc63c5e2ac746d28dc10bed7f9509", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -2,7 +2,7 @@ fn a() -> &int {\n     let vec = [1, 2, 3, 4];\n     let tail = match vec { //~ ERROR illegal borrow\n         [_a, ..tail] => &tail[0],\n-        _ => fail ~\"foo\"\n+        _ => die!(~\"foo\")\n     };\n     move tail\n }"}, {"sha": "a76649fb990995b11900bb79045396a52e253902", "filename": "src/test/compile-fail/closure-that-fails.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -2,6 +2,6 @@ fn foo(f: fn() -> !) {}\n \n fn main() {\n     // Type inference didn't use to be able to handle this:\n-    foo(|| fail);\n+    foo(|| die!());\n     foo(|| 22); //~ ERROR mismatched types\n }"}, {"sha": "ef84b11d5fc1c10120761521f2407180a7654781", "filename": "src/test/compile-fail/deref-non-pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderef-non-pointer.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -11,6 +11,6 @@\n // error-pattern:cannot be dereferenced\n fn main() {\n   match *1 {\n-      _ => { fail; }\n+      _ => { die!(); }\n   }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "6d4f5ba2f4c1bd893f6e99a4996e054d0d200f4d", "filename": "src/test/compile-fail/fail-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dcb3ed745d04048941a8130f3603c5759b2b142/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-expr.rs?ref=2dcb3ed745d04048941a8130f3603c5759b2b142", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:mismatched types\n \n-fn main() { fail 5; }\n+fn main() { die!(5); }"}]}