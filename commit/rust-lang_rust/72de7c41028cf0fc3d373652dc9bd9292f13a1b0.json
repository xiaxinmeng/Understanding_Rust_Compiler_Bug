{"sha": "72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "node_id": "C_kwDOAAsO6NoAKDcyZGU3YzQxMDI4Y2YwZmMzZDM3MzY1MmRjOWJkOTI5MmYxM2ExYjA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-02T01:43:14Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-02T02:22:04Z"}, "message": "Address review comments.", "tree": {"sha": "bc28897acbf43c2924632072d62189154509ed9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc28897acbf43c2924632072d62189154509ed9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "html_url": "https://github.com/rust-lang/rust/commit/72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72de7c41028cf0fc3d373652dc9bd9292f13a1b0/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b81d7cdc653f540e9fa219820928184e0273f5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b81d7cdc653f540e9fa219820928184e0273f5f", "html_url": "https://github.com/rust-lang/rust/commit/0b81d7cdc653f540e9fa219820928184e0273f5f"}], "stats": {"total": 127, "additions": 73, "deletions": 54}, "files": [{"sha": "1fa085926767d3402186f0042dea533c6cc0e680", "filename": "compiler/rustc_query_system/src/ich/impls_syntax.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/72de7c41028cf0fc3d373652dc9bd9292f13a1b0/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72de7c41028cf0fc3d373652dc9bd9292f13a1b0/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "patch": "@@ -5,7 +5,7 @@ use crate::ich::StableHashingContext;\n \n use rustc_ast as ast;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_span::{BytePos, NormalizedPos, SourceFile, SourceFileLines};\n+use rustc_span::{BytePos, NormalizedPos, SourceFile};\n use std::assert_matches::assert_matches;\n \n use smallvec::SmallVec;\n@@ -60,7 +60,7 @@ impl<'ctx> rustc_ast::HashStableContext for StableHashingContext<'ctx> {\n impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let SourceFile {\n-            ref name, // We hash the smaller name_hash instead of this\n+            name: _, // We hash the smaller name_hash instead of this\n             name_hash,\n             cnum,\n             // Do not hash the source as it is not encoded\n@@ -69,7 +69,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n             external_src: _,\n             start_pos,\n             end_pos: _,\n-            ref lines,\n+            lines: _,\n             ref multibyte_chars,\n             ref non_narrow_chars,\n             ref normalized_pos,\n@@ -79,18 +79,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n \n         src_hash.hash_stable(hcx, hasher);\n \n-        // We only hash the relative position within this source_file\n-        match &*lines.borrow() {\n-            SourceFileLines::Lines { lines } => {\n-                lines.len().hash_stable(hcx, hasher);\n-                for &line in lines.iter() {\n-                    stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n-                }\n-            }\n-            SourceFileLines::Diffs { .. } => {\n-                panic!(\"called hash_stable on SourceFileLines::Diffs for {:?}\", name);\n+        // We are always in `Lines` form by the time we reach here.\n+        assert!(self.lines.borrow().is_lines());\n+        self.lines(|lines| {\n+            // We only hash the relative position within this source_file\n+            lines.len().hash_stable(hcx, hasher);\n+            for &line in lines.iter() {\n+                stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n             }\n-        }\n+        });\n \n         // We only hash the relative position within this source_file\n         multibyte_chars.len().hash_stable(hcx, hasher);"}, {"sha": "6805d212f0b27dddbc058767541d1acd3fd89503", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 60, "deletions": 38, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/72de7c41028cf0fc3d373652dc9bd9292f13a1b0/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72de7c41028cf0fc3d373652dc9bd9292f13a1b0/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "patch": "@@ -1225,37 +1225,47 @@ impl DebuggerVisualizerFile {\n #[derive(Clone)]\n pub enum SourceFileLines {\n     /// The source file lines, in decoded (random-access) form.\n-    Lines { lines: Vec<BytePos> },\n+    Lines(Vec<BytePos>),\n \n-    /// The source file lines in difference list form. This matches the form\n-    /// used within metadata, which saves space by exploiting the fact that the\n-    /// lines list is sorted and individual lines are usually not that long.\n-    ///\n-    /// We read it directly from metadata and only decode it into `Lines` form\n-    /// when necessary. This is a significant performance win, especially for\n-    /// small crates where very little of `std`'s metadata is used.\n-    Diffs {\n-        /// Position of the first line. Note that this is always encoded as a\n-        /// `BytePos` because it is often much larger than any of the\n-        /// differences.\n-        line_start: BytePos,\n-\n-        /// Always 1, 2, or 4. Always as small as possible, while being big\n-        /// enough to hold the length of the longest line in the source file.\n-        /// The 1 case is by far the most common.\n-        bytes_per_diff: usize,\n-\n-        /// The number of diffs encoded in `raw_diffs`. Always one less than\n-        /// the number of lines in the source file.\n-        num_diffs: usize,\n-\n-        /// The diffs in \"raw\" form. Each segment of `bytes_per_diff` length\n-        /// encodes one little-endian diff. Note that they aren't LEB128\n-        /// encoded. This makes for much faster decoding. Besides, the\n-        /// bytes_per_diff==1 case is by far the most common, and LEB128\n-        /// encoding has no effect on that case.\n-        raw_diffs: Vec<u8>,\n-    },\n+    /// The source file lines, in undecoded difference list form.\n+    Diffs(SourceFileDiffs),\n+}\n+\n+impl SourceFileLines {\n+    pub fn is_lines(&self) -> bool {\n+        matches!(self, SourceFileLines::Lines(_))\n+    }\n+}\n+\n+/// The source file lines in difference list form. This matches the form\n+/// used within metadata, which saves space by exploiting the fact that the\n+/// lines list is sorted and individual lines are usually not that long.\n+///\n+/// We read it directly from metadata and only decode it into `Lines` form\n+/// when necessary. This is a significant performance win, especially for\n+/// small crates where very little of `std`'s metadata is used.\n+#[derive(Clone)]\n+pub struct SourceFileDiffs {\n+    /// Position of the first line. Note that this is always encoded as a\n+    /// `BytePos` because it is often much larger than any of the\n+    /// differences.\n+    line_start: BytePos,\n+\n+    /// Always 1, 2, or 4. Always as small as possible, while being big\n+    /// enough to hold the length of the longest line in the source file.\n+    /// The 1 case is by far the most common.\n+    bytes_per_diff: usize,\n+\n+    /// The number of diffs encoded in `raw_diffs`. Always one less than\n+    /// the number of lines in the source file.\n+    num_diffs: usize,\n+\n+    /// The diffs in \"raw\" form. Each segment of `bytes_per_diff` length\n+    /// encodes one little-endian diff. Note that they aren't LEB128\n+    /// encoded. This makes for much faster decoding. Besides, the\n+    /// bytes_per_diff==1 case is by far the most common, and LEB128\n+    /// encoding has no effect on that case.\n+    raw_diffs: Vec<u8>,\n }\n \n /// A single source in the [`SourceMap`].\n@@ -1298,6 +1308,8 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n             s.emit_struct_field(\"start_pos\", false, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", false, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", false, |s| {\n+                // We are always in `Lines` form by the time we reach here.\n+                assert!(self.lines.borrow().is_lines());\n                 self.lines(|lines| {\n                     // Store the length.\n                     s.emit_u32(lines.len() as u32)?;\n@@ -1384,9 +1396,14 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n                 // Read the difference list.\n                 let num_diffs = num_lines as usize - 1;\n                 let raw_diffs = d.read_raw_bytes(bytes_per_diff * num_diffs).to_vec();\n-                SourceFileLines::Diffs { line_start, bytes_per_diff, num_diffs, raw_diffs }\n+                SourceFileLines::Diffs(SourceFileDiffs {\n+                    line_start,\n+                    bytes_per_diff,\n+                    num_diffs,\n+                    raw_diffs,\n+                })\n             } else {\n-                SourceFileLines::Lines { lines: vec![] }\n+                SourceFileLines::Lines(vec![])\n             }\n         };\n         let multibyte_chars: Vec<MultiByteChar> = Decodable::decode(d);\n@@ -1448,7 +1465,7 @@ impl SourceFile {\n             external_src: Lock::new(ExternalSource::Unneeded),\n             start_pos,\n             end_pos: Pos::from_usize(end_pos),\n-            lines: Lock::new(SourceFileLines::Lines { lines }),\n+            lines: Lock::new(SourceFileLines::Lines(lines)),\n             multibyte_chars,\n             non_narrow_chars,\n             normalized_pos,\n@@ -1457,14 +1474,19 @@ impl SourceFile {\n         }\n     }\n \n-    pub fn lines<F, R>(&self, mut f: F) -> R\n+    pub fn lines<F, R>(&self, f: F) -> R\n     where\n-        F: FnMut(&[BytePos]) -> R,\n+        F: FnOnce(&[BytePos]) -> R,\n     {\n         let mut guard = self.lines.borrow_mut();\n         match &*guard {\n-            SourceFileLines::Lines { lines } => f(lines),\n-            SourceFileLines::Diffs { mut line_start, bytes_per_diff, num_diffs, raw_diffs } => {\n+            SourceFileLines::Lines(lines) => f(lines),\n+            SourceFileLines::Diffs(SourceFileDiffs {\n+                mut line_start,\n+                bytes_per_diff,\n+                num_diffs,\n+                raw_diffs,\n+            }) => {\n                 // Convert from \"diffs\" form to \"lines\" form.\n                 let num_lines = num_diffs + 1;\n                 let mut lines = Vec::with_capacity(num_lines);\n@@ -1504,7 +1526,7 @@ impl SourceFile {\n                     _ => unreachable!(),\n                 }\n                 let res = f(&lines);\n-                *guard = SourceFileLines::Lines { lines };\n+                *guard = SourceFileLines::Lines(lines);\n                 res\n             }\n         }"}, {"sha": "95ea7029617014715e25efe520be80e6ae7aa9fc", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72de7c41028cf0fc3d373652dc9bd9292f13a1b0/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72de7c41028cf0fc3d373652dc9bd9292f13a1b0/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=72de7c41028cf0fc3d373652dc9bd9292f13a1b0", "patch": "@@ -356,12 +356,12 @@ impl SourceMap {\n         // compiler backend can optimize away the repeated computations in a\n         // way that won't trigger overflow checks.\n         match &mut *file_local_lines.borrow_mut() {\n-            SourceFileLines::Lines { lines } => {\n+            SourceFileLines::Lines(lines) => {\n                 for pos in lines {\n                     *pos = (*pos - original_start_pos) + start_pos;\n                 }\n             }\n-            SourceFileLines::Diffs { line_start, .. } => {\n+            SourceFileLines::Diffs(SourceFileDiffs { line_start, .. }) => {\n                 *line_start = (*line_start - original_start_pos) + start_pos;\n             }\n         }"}]}