{"sha": "a785f3fc95752dc2cfced5e7ccef710e189acb9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ODVmM2ZjOTU3NTJkYzJjZmNlZDVlN2NjZWY3MTBlMTg5YWNiOWM=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-16T16:47:00Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T22:31:38Z"}, "message": "Adding a module with parallel vector operations.\n\nThis should go in libstd, but currently resolve bugs make this not\nwork.", "tree": {"sha": "d63ccde882a9ebf3270e91fb1b240bc7344025eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d63ccde882a9ebf3270e91fb1b240bc7344025eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a785f3fc95752dc2cfced5e7ccef710e189acb9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a785f3fc95752dc2cfced5e7ccef710e189acb9c", "html_url": "https://github.com/rust-lang/rust/commit/a785f3fc95752dc2cfced5e7ccef710e189acb9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a785f3fc95752dc2cfced5e7ccef710e189acb9c/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d485f23a1a1879b6c066ae56a1ccfe1f092785fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d485f23a1a1879b6c066ae56a1ccfe1f092785fd", "html_url": "https://github.com/rust-lang/rust/commit/d485f23a1a1879b6c066ae56a1ccfe1f092785fd"}], "stats": {"total": 221, "additions": 217, "deletions": 4}, "files": [{"sha": "5160e50fd9af8ebafe1f08f2f8378c711506219a", "filename": "src/libstd/par.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a785f3fc95752dc2cfced5e7ccef710e189acb9c/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a785f3fc95752dc2cfced5e7ccef710e189acb9c/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=a785f3fc95752dc2cfced5e7ccef710e189acb9c", "patch": "@@ -0,0 +1,103 @@\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n+import task::spawn;\n+\n+export future;\n+export map;\n+export alli;\n+\n+iface future<T: send> {\n+    fn get() -> T;\n+}\n+\n+type future_<T: send> = {\n+    mut slot : option<T>,\n+    port : port<T>,\n+};\n+\n+impl<T: send> of future<T> for future_<T> {\n+    fn get() -> T {\n+        alt(self.slot) {\n+          some(x) { x }\n+          none {\n+            let x = recv(self.port);\n+            self.slot = some(x);\n+            x\n+          }\n+        }\n+    }\n+}\n+\n+\n+#[doc=\"Executes a bit of code asynchronously.\n+\n+Returns a handle that can be used to retrieve the result at your\n+leisure.\"]\n+fn future<T: send>(thunk : fn~() -> T) -> future<T> {\n+    let p = port();\n+    let c = chan(p);\n+\n+    spawn() {||\n+        send(c, thunk());\n+    }\n+\n+    {mut slot: none::<T>, port : p} as future::<T>\n+}\n+\n+#[doc=\"The maximum number of tasks this module will spawn for a single\n+ operationg.\"]\n+const max_tasks : uint = 32u;\n+\n+#[doc=\"The minimum number of elements each task will process.\"]\n+const min_granularity : uint = 1024u;\n+\n+#[doc=\"An internal helper to map a function over a large vector and\n+ return the intermediate results.\n+\n+This is used to build most of the other parallel vector functions,\n+like map or alli.\"]\n+fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n+    let len = xs.len();\n+    if len < min_granularity {\n+        // This is a small vector, fall back on the normal map.\n+        [f(0u, xs)]\n+    }\n+    else {\n+        let num_tasks = uint::min(max_tasks, len / min_granularity);\n+\n+        let items_per_task = len / num_tasks;\n+\n+        let mut futures = [];\n+        let mut base = 0u;\n+        while base < len {\n+            let slice = vec::slice(xs, base,\n+                                   uint::min(len, base + items_per_task));\n+            futures += [future() {|copy base|\n+                f(base, slice)\n+            }];\n+            base += items_per_task;\n+        }\n+\n+        futures.map() {|ys|\n+            ys.get()\n+        }\n+    }\n+}\n+\n+#[doc=\"A parallel version of map.\"]\n+fn map<A: send, B: send>(xs: [A], f: fn~(A) -> B) -> [B] {\n+    vec::concat(map_slices(xs) {|_base, slice|\n+        map(slice, f)\n+    })\n+}\n+\n+#[doc=\"Returns true if the function holds for all elements in the vector.\"]\n+fn alli<A: send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n+    vec::all(map_slices(xs) {|base, slice|\n+        slice.alli() {|i, x|\n+            f(i + base, x)\n+        }\n+    }) {|x| x }\n+}"}, {"sha": "f25ceb87c3ca943c9140ec8daacf3c8e6a5b4bca", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a785f3fc95752dc2cfced5e7ccef710e189acb9c/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a785f3fc95752dc2cfced5e7ccef710e189acb9c/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=a785f3fc95752dc2cfced5e7ccef710e189acb9c", "patch": "@@ -19,6 +19,7 @@ export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap;\n export rope, arena;\n export ebml, dbg, getopts, json, rand, sha1, term, time, prettyprint;\n export test, tempfile, serialization;\n+export par;\n \n // General io and system-services modules\n \n@@ -58,6 +59,7 @@ mod getopts;\n mod json;\n mod sha1;\n mod md4;\n+mod par;\n mod tempfile;\n mod term;\n mod time;"}, {"sha": "d145da651b16b38d910c6f2b11c26ea9cd5ccfd3", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 112, "deletions": 4, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a785f3fc95752dc2cfced5e7ccef710e189acb9c/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a785f3fc95752dc2cfced5e7ccef710e189acb9c/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a785f3fc95752dc2cfced5e7ccef710e189acb9c", "patch": "@@ -10,6 +10,7 @@ import std::map;\n import std::map::hashmap;\n import std::deque;\n import std::deque::t;\n+//import std::par;\n import io::writer_util;\n import comm::*;\n import int::abs;\n@@ -221,13 +222,11 @@ fn validate(edges: [(node_id, node_id)],\n \n     log(info, \"Verifying tree and graph edges...\");\n \n-    let status = tree.alli() {|u, v|\n+    let status = par::alli(tree) {|u, v|\n         if v == -1 || u as int == root {\n             true\n         }\n         else {\n-            log(info, #fmt(\"Checking for %? or %?\",\n-                           (u, v), (v, u)));\n             edges.contains((u as int, v)) || edges.contains((v, u as int))\n         }\n     };\n@@ -269,9 +268,118 @@ fn main() {\n                                  stop - start));\n \n     let start = time::precise_time_s();\n-    assert(validate(graph, edges, root, bfs_tree));\n+    assert(validate(edges, root, bfs_tree));\n     let stop = time::precise_time_s();\n \n     io::stdout().write_line(#fmt(\"Validation completed in %? seconds.\",\n                                  stop - start));\n }\n+\n+\n+// par stuff /////////////////////////////////////////////////////////\n+\n+mod par {\n+import comm::port;\n+import comm::chan;\n+import comm::send;\n+import comm::recv;\n+import task::spawn;\n+\n+iface future<T: send> {\n+    fn get() -> T;\n+}\n+\n+type future_<T: send> = {\n+    mut slot : option<T>,\n+    port : port<T>,\n+};\n+\n+impl<T: send> of future<T> for future_<T> {\n+    fn get() -> T {\n+        get(self)\n+    }\n+}\n+\n+fn get<T: send>(f: future_<T>) -> T {\n+    alt(f.slot) {\n+      some(x) { x }\n+      none {\n+        let x = recv(f.port);\n+        f.slot = some(x);\n+        x\n+      }\n+    }\n+}\n+\n+\n+#[doc=\"Executes a bit of code asynchronously.\n+\n+Returns a handle that can be used to retrieve the result at your\n+leisure.\"]\n+fn future<T: send>(thunk : fn~() -> T) -> future<T> {\n+    let p = port();\n+    let c = chan(p);\n+\n+    spawn() {||\n+        send(c, thunk());\n+    }\n+\n+    {mut slot: none::<T>, port : p} as future::<T>\n+}\n+\n+#[doc=\"The maximum number of tasks this module will spawn for a single\n+ operationg.\"]\n+const max_tasks : uint = 32u;\n+\n+#[doc=\"The minimum number of elements each task will process.\"]\n+const min_granularity : uint = 1024u;\n+\n+#[doc=\"An internal helper to map a function over a large vector and\n+ return the intermediate results.\n+\n+This is used to build most of the other parallel vector functions,\n+like map or alli.\"]\n+fn map_slices<A: send, B: send>(xs: [A], f: fn~(uint, [A]) -> B) -> [B] {\n+    let len = xs.len();\n+    if len < min_granularity {\n+        // This is a small vector, fall back on the normal map.\n+        [f(0u, xs)]\n+    }\n+    else {\n+        let num_tasks = uint::min(max_tasks, len / min_granularity);\n+\n+        let items_per_task = len / num_tasks;\n+\n+        let mut futures = [];\n+        let mut base = 0u;\n+        while base < len {\n+            let slice = vec::slice(xs, base,\n+                                   uint::min(len, base + items_per_task));\n+            futures += [future() {|copy base|\n+                f(base, slice)\n+            }];\n+            base += items_per_task;\n+        }\n+\n+        futures.map() {|ys|\n+            ys.get()\n+        }\n+    }\n+}\n+\n+#[doc=\"A parallel version of map.\"]\n+fn map<A: send, B: send>(xs: [A], f: fn~(A) -> B) -> [B] {\n+    vec::concat(map_slices(xs) {|_base, slice|\n+        map(slice, f)\n+    })\n+}\n+\n+#[doc=\"Returns true if the function holds for all elements in the vector.\"]\n+fn alli<A: send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n+    vec::all(map_slices(xs) {|base, slice|\n+        slice.alli() {|i, x|\n+            f(i + base, x)\n+        }\n+    }) {|x| x }\n+}\n+}\n\\ No newline at end of file"}]}