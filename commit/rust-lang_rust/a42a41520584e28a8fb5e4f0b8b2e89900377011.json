{"sha": "a42a41520584e28a8fb5e4f0b8b2e89900377011", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MmE0MTUyMDU4NGUyOGE4ZmI1ZTRmMGI4YjJlODk5MDAzNzcwMTE=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-03T16:49:30Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-03T16:49:30Z"}, "message": "rework unsafe intro to be 1000% more adorable", "tree": {"sha": "d92319fff5a1466c500e142a0096d442c46cc7b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d92319fff5a1466c500e142a0096d442c46cc7b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a42a41520584e28a8fb5e4f0b8b2e89900377011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a42a41520584e28a8fb5e4f0b8b2e89900377011", "html_url": "https://github.com/rust-lang/rust/commit/a42a41520584e28a8fb5e4f0b8b2e89900377011", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a42a41520584e28a8fb5e4f0b8b2e89900377011/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd98edd60e845f0c020526a45bc56103365f121d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd98edd60e845f0c020526a45bc56103365f121d", "html_url": "https://github.com/rust-lang/rust/commit/dd98edd60e845f0c020526a45bc56103365f121d"}], "stats": {"total": 185, "additions": 131, "deletions": 54}, "files": [{"sha": "55e4bc5c87271f8af15cdc10800af1b45ce192c9", "filename": "README.md", "status": "modified", "additions": 131, "deletions": 54, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/a42a41520584e28a8fb5e4f0b8b2e89900377011/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a42a41520584e28a8fb5e4f0b8b2e89900377011/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a42a41520584e28a8fb5e4f0b8b2e89900377011", "patch": "@@ -13,26 +13,66 @@ Where TRPL introduces the language and teaches the basics, TURPL dives deep into\n the specification of the language, and all the nasty bits necessary to write\n Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n the basics of the language and systems programming. We will not explain the\n-stack or heap, we will not explain the syntax.\n+stack or heap, we will not explain the basic syntax.\n \n \n \n \n-# A Tale Of Two Languages\n \n+# Meet Safe and Unsafe\n+\n+Safe and Unsafe are Rust's chief engineers.\n+\n+TODO: ADORABLE PICTURES OMG\n+\n+Unsafe handles all the dangerous internal stuff. They build the foundations\n+and handle all the dangerous materials. By all accounts, Unsafe is really a bit\n+unproductive, because the nature of their work means that they have to spend a\n+lot of time checking and double-checking everything. What if there's an earthquake\n+on a leap year? Are we ready for that? Unsafe better be, because if they get\n+*anything* wrong, everything will blow up! What Unsafe brings to the table is\n+*quality*, not quantity. Still, nothing would ever get done if everything was\n+built to Unsafe's standards!\n+\n+That's where Safe comes in. Safe has to handle *everything else*. Since Safe needs\n+to *get work done*, they've grown to be fairly carless and clumsy! Safe doesn't worry\n+about all the crazy eventualities that Unsafe does, because life is too short to deal\n+with leap-year-earthquakes. Of course, this means there's some jobs that Safe just\n+can't handle. Safe is all about quantity over quality.\n+\n+Unsafe loves Safe to bits, but knows that tey *can never trust them to do the\n+right thing*. Still, Unsafe acknowledges that not every problem needs quite the\n+attention to detail that they apply. Indeed, Unsafe would *love* if Safe could do\n+*everything* for them. To accomplish this, Unsafe spends most of their time\n+building *safe abstractions*. These abstractions handle all the nitty-gritty\n+details for Safe, and choose good defaults so that the simplest solution (which\n+Safe will inevitably use) is usually the *right* one. Once a safe abstraction is\n+built, Unsafe ideally needs to never work on it again, and Safe can blindly use\n+it in all their work.\n+\n+Unsafe's attention to detail means that all the things that they mark as ok for\n+Safe to use can be combined in arbitrarily ridiculous ways, and all the rules\n+that Unsafe is forced to uphold will never be violated. If they *can* be violated\n+by Safe, that means *Unsafe*'s the one in the wrong. Safe can work carelessly,\n+knowing that if anything blows up, it's not *their* fault. Safe can also call in\n+Unsafe at any time if there's a hard problem they can't quite work out, or if they\n+can't meet the client's quality demands. Of course, Unsafe will beg and plead Safe\n+to try their latest safe abstraction first!\n+\n+In addition to being adorable, Safe and Unsafe are what makes Rust possible.\n Rust can be thought of as two different languages: Safe Rust, and Unsafe Rust.\n Any time someone opines the guarantees of Rust, they are almost surely talking about\n-Safe Rust. However Safe Rust is not sufficient to write every program. For that,\n-we need the Unsafe Rust superset.\n+Safe. However Safe is not sufficient to write every program. For that,\n+we need the Unsafe superset.\n \n Most fundamentally, writing bindings to other languages\n (such as the C exposed by your operating system) is never going to be safe. Rust\n-can't control what other languages do to program execution! However Unsafe Rust is\n+can't control what other languages do to program execution! However Unsafe is\n also necessary to construct fundamental abstractions where the type system is not\n sufficient to automatically prove what you're doing is sound.\n \n Indeed, the Rust standard library is implemented in Rust, and it makes substantial\n-use of Unsafe Rust for implementing IO, memory allocation, collections,\n+use of Unsafe for implementing IO, memory allocation, collections,\n synchronization, and other low-level computational primitives.\n \n Upon hearing this, many wonder why they would not simply just use C or C++ in place of\n@@ -47,46 +87,40 @@ one does not have to suddenly worry about indexing out of bounds on `y`.\n C and C++, by contrast, have pervasive unsafety baked into the language. Even the\n modern best practices like `unique_ptr` have various safety pitfalls.\n \n-It should also be noted that writing Unsafe Rust should be regarded as an exceptional\n-action. Unsafe Rust is often the domain of *fundamental libraries*. Anything that needs\n+It cannot be emphasized enough that Unsafe should be regarded as an exceptional\n+thing, not a normal one. Unsafe is often the domain of *fundamental libraries*: anything that needs\n to make FFI bindings or define core abstractions. These fundamental libraries then expose\n-a *safe* interface for intermediate libraries and applications to build upon. And these\n+a safe interface for intermediate libraries and applications to build upon. And these\n safe interfaces make an important promise: if your application segfaults, it's not your\n fault. *They* have a bug.\n \n And really, how is that different from *any* safe language? Python, Ruby, and Java libraries\n can internally do all sorts of nasty things. The languages themselves are no\n-different. Safe languages regularly have bugs that cause critical vulnerabilities.\n-The fact that Rust is written with a healthy spoonful of Unsafe Rust is no different.\n+different. Safe languages *regularly* have bugs that cause critical vulnerabilities.\n+The fact that Rust is written with a healthy spoonful of Unsafe is no different.\n However it *does* mean that Rust doesn't need to fall back to the pervasive unsafety of\n C to do the nasty things that need to get done.\n \n \n \n \n-# What does `unsafe` mean?\n \n-Rust tries to model memory safety through the `unsafe` keyword. Interestingly,\n-the meaning of `unsafe` largely revolves around what\n-its *absence* means. If the `unsafe` keyword is absent from a program, it should\n-not be possible to violate memory safety under *any* conditions. The presence\n-of `unsafe` means that there are conditions under which this code *could*\n-violate memory safety.\n+# What do Safe and Unsafe really mean?\n \n-To be more concrete, Rust cares about preventing the following things:\n+Rust cares about preventing the following things:\n \n-* Dereferencing null/dangling pointers\n-* Reading uninitialized memory\n-* Breaking the pointer aliasing rules (TBD) (llvm rules + noalias on &mut and & w/o UnsafeCell)\n-* Invoking Undefined Behaviour (in e.g. compiler intrinsics)\n+* Dereferencing null or dangling pointers\n+* Reading [uninitialized memory][]\n+* Breaking the [pointer aliasing rules][]\n * Producing invalid primitive values:\n     * dangling/null references\n     * a `bool` that isn't 0 or 1\n     * an undefined `enum` discriminant\n-    * a `char` larger than char::MAX\n+    * a `char` larger than char::MAX (TODO: check if stronger restrictions apply)\n     * A non-utf8 `str`\n-* Unwinding into an FFI function\n-* Causing a data race\n+* Unwinding into another language\n+* Causing a [data race][]\n+* Invoking Misc. Undefined Behaviour (in e.g. compiler intrinsics)\n \n That's it. That's all the Undefined Behaviour in Rust. Libraries are free to\n declare arbitrary requirements if they could transitively cause memory safety\n@@ -95,15 +129,17 @@ quite permisive with respect to other dubious operations. Rust considers it\n \"safe\" to:\n \n * Deadlock\n+* Have a Race Condition\n * Leak memory\n * Fail to call destructors\n * Overflow integers\n * Delete the production database\n \n-However any program that does such a thing is *probably* incorrect. Rust just isn't\n-interested in modeling these problems, as they are much harder to prevent in general,\n-and it's literally impossible to prevent incorrect programs from getting written.\n+However any program that does such a thing is *probably* incorrect. Rust\n+provides lots of tools to make doing these things rare, but these problems are\n+considered impractical to categorically prevent.\n \n+Rust models the seperation between Safe and Unsafe with the `unsafe` keyword.\n There are several places `unsafe` can appear in Rust today, which can largely be\n grouped into two categories:\n \n@@ -112,7 +148,7 @@ you to write `unsafe` elsewhere:\n     * On functions, `unsafe` is declaring the function to be unsafe to call. Users\n       of the function must check the documentation to determine what this means,\n       and then have to write `unsafe` somewhere to identify that they're aware of\n-    the danger.\n+      the danger.\n     * On trait declarations, `unsafe` is declaring that *implementing* the trait\n       is an unsafe operation, as it has contracts that other unsafe code is free to\n       trust blindly.\n@@ -126,19 +162,19 @@ unchecked contracts:\n \n There is also `#[unsafe_no_drop_flag]`, which is a special case that exists for\n historical reasons and is in the process of being phased out. See the section on\n-destructors for details.\n+[destructors][] for details.\n \n Some examples of unsafe functions:\n \n * `slice::get_unchecked` will perform unchecked indexing, allowing memory\n   safety to be freely violated.\n-* `ptr::offset` in an intrinsic that invokes Undefined Behaviour if it is\n+* `ptr::offset` is an intrinsic that invokes Undefined Behaviour if it is\n   not \"in bounds\" as defined by LLVM (see the lifetimes section for details).\n * `mem::transmute` reinterprets some value as having the given type,\n-  bypassing type safety in arbitrary ways. (see the conversions section for details)\n+  bypassing type safety in arbitrary ways. (see [conversions][] for details)\n * All FFI functions are `unsafe` because they can do arbitrary things.\n   C being an obvious culprit, but generally any language can do something\n-  that Rust isn't happy about. (see the FFI section for details)\n+  that Rust isn't happy about.\n \n As of Rust 1.0 there are exactly two unsafe traits:\n \n@@ -147,25 +183,60 @@ As of Rust 1.0 there are exactly two unsafe traits:\n * `Sync` is a marker trait that promises that threads can safely share\n   implementors through a shared reference.\n \n-All other traits that declare any kind of contract *really* can't be trusted\n-to adhere to their contract when memory-safety is at stake. For instance Rust has\n-`PartialOrd` and `Ord` to differentiate between types which can \"just\" be\n-compared and those that implement a total ordering. However you can't actually\n-trust an implementor of `Ord` to actually provide a total ordering if failing to\n-do so causes you to e.g. index out of bounds. But if it just makes your program\n-do a stupid thing, then it's \"fine\" to rely on `Ord`.\n-\n-The reason this is the case is that `Ord` is safe to implement, and it should be\n-impossible for bad *safe* code to violate memory safety. Rust has traditionally\n-avoided making traits unsafe because it makes `unsafe` pervasive in the language,\n-which is not desirable. The only reason `Send` and `Sync` are unsafe is because\n-thread safety is a sort of fundamental thing that a program can't really guard\n-against locally (even by-value message passing still requires a notion Send).\n-\n-\n-\n-\n-# Working with unsafe\n+The need for unsafe traits boils down to the fundamental lack of trust that Unsafe\n+has for Safe. All safe traits are free to declare arbitrary contracts, but because\n+implementing them is a job for Safe, Unsafe can't trust those contracts to actually\n+be upheld.\n+\n+For instance Rust has `PartialOrd` and `Ord` traits to try to differentiate\n+between types which can \"just\" be compared, and those that actually implement a\n+*total* ordering. Pretty much every API that wants to work with data that can be\n+compared *really* wants Ord data. For instance, a sorted map like BTreeMap\n+*doesn't even make sense* for partially ordered types. If you claim to implement\n+Ord for a type, but don't actually provide a proper total ordering, BTreeMap will\n+get *really confused* and start making a total mess of itself. Data that is\n+inserted may be impossible to find!\n+\n+But that's ok. BTreeMap is safe, so it guarantees that even if you give it a\n+*completely* garbage Ord implementation, it will still do something *safe*. You\n+won't start reading uninitialized memory or unallocated memory. In fact, BTreeMap\n+manages to not actually lose any of your data. When the map is dropped, all the\n+destructors will be successfully called! Hooray!\n+\n+However BTreeMap is implemented using a modest spoonful of Unsafe (most collections\n+are). That means that it is not necessarily *trivially true* that a bad Ord\n+implementation will make BTreeMap behave safely. Unsafe most be sure not to rely\n+on Ord *where safety is at stake*, because Ord is provided by Safe, and memory\n+safety is not Safe's responsibility to uphold. *It must be impossible for Safe\n+code to violate memory safety*.\n+\n+But wouldn't it be grand if there was some way for Unsafe to trust *some* trait\n+contracts *somewhere*? This is the problem that unsafe traits tackle: by marking\n+*the trait itself* as unsafe *to implement*, Unsafe can trust the implementation\n+to be correct (because Unsafe can trust themself).\n+\n+Rust has traditionally avoided making traits unsafe because it makes Unsafe\n+pervasive, which is not desirable. Send and Sync are unsafe is because\n+thread safety is a *fundamental property* that Unsafe cannot possibly hope to\n+defend against in the same way it would defend against a bad Ord implementation.\n+The only way to possibly defend against thread-unsafety would be to *not use\n+threading at all*. Making every operation atomic isn't even sufficient, because\n+it's possible for complex invariants between disjoint locations in memory.\n+\n+Even concurrent paradigms that are traditionally regarded as Totally Safe like\n+message passing implicitly rely on some notion of thread safety -- are you\n+really message-passing if you send a *pointer*? Send and Sync therefore require\n+some *fundamental* level of trust that Safe code can't provide, so they must be\n+unsafe to implement. To help obviate the pervasive unsafety that this would\n+introduce, Send (resp. Sync) is *automatically* derived for all types composed only\n+of Send (resp. Sync) values. 99% of types are Send and Sync, and 99% of those\n+never actually say it (the remaining 1% is overwhelmingly synchronization\n+primitives).\n+\n+\n+\n+\n+# Working with Unsafe\n \n Rust generally only gives us the tools to talk about safety in a scoped and\n binary manner. Unfortunately reality is significantly more complicated than that.\n@@ -254,5 +325,11 @@ trust the capacity field because there's no way to verify it.\n Generally, the only bullet-proof way to limit the scope of unsafe code is at the\n module boundary with privacy.\n \n-[trpl]: https://doc.rust-lang.org/book/\n \n+\n+[trpl]: https://doc.rust-lang.org/book/\n+[pointer aliasing rules]: lifetimes.html#references\n+[uninitialized memory]: uninitialized.html\n+[data race]: concurrency.html\n+[destructors]: raii.html\n+[conversions]: conversions.html"}]}