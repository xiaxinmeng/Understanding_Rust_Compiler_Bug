{"sha": "7f4c168a9dd2195b45998ddfecdac111663b26d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNGMxNjhhOWRkMjE5NWI0NTk5OGRkZmVjZGFjMTExNjYzYjI2ZDE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-23T01:08:07Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-23T06:06:16Z"}, "message": "Rename the fields in `SparseBitMatrix`.\n\nThe new names are clearer.", "tree": {"sha": "10791a1710b5fe27d3ba6ef8c65d93c0828a4824", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10791a1710b5fe27d3ba6ef8c65d93c0828a4824"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f4c168a9dd2195b45998ddfecdac111663b26d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f4c168a9dd2195b45998ddfecdac111663b26d1", "html_url": "https://github.com/rust-lang/rust/commit/7f4c168a9dd2195b45998ddfecdac111663b26d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f4c168a9dd2195b45998ddfecdac111663b26d1/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0d81b7fc1421859ba0218e8a437af29ae3b0967", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d81b7fc1421859ba0218e8a437af29ae3b0967", "html_url": "https://github.com/rust-lang/rust/commit/d0d81b7fc1421859ba0218e8a437af29ae3b0967"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "1ac32af55f6031ba882d780d6cadc262e3d157e7", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7f4c168a9dd2195b45998ddfecdac111663b26d1/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f4c168a9dd2195b45998ddfecdac111663b26d1/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=7f4c168a9dd2195b45998ddfecdac111663b26d1", "patch": "@@ -326,23 +326,23 @@ where\n     R: Idx,\n     C: Idx,\n {\n-    columns: usize,\n-    vector: IndexVec<R, BitArray<C>>,\n+    num_columns: usize,\n+    rows: IndexVec<R, BitArray<C>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Create a new empty sparse bit matrix with no rows or columns.\n-    pub fn new(columns: usize) -> Self {\n+    pub fn new(num_columns: usize) -> Self {\n         Self {\n-            columns,\n-            vector: IndexVec::new(),\n+            num_columns,\n+            rows: IndexVec::new(),\n         }\n     }\n \n     fn ensure_row(&mut self, row: R) {\n-        let columns = self.columns;\n-        self.vector\n-            .ensure_contains_elem(row, || BitArray::new(columns));\n+        let num_columns = self.num_columns;\n+        self.rows\n+            .ensure_contains_elem(row, || BitArray::new(num_columns));\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n@@ -351,15 +351,15 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: R, column: C) -> bool {\n         self.ensure_row(row);\n-        self.vector[row].insert(column)\n+        self.rows[row].insert(column)\n     }\n \n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.vector.get(row).map_or(false, |r| r.contains(column))\n+        self.rows.get(row).map_or(false, |r| r.contains(column))\n     }\n \n     /// Add the bits from row `read` to the bits from row `write`,\n@@ -370,49 +370,49 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n     pub fn merge(&mut self, read: R, write: R) -> bool {\n-        if read == write || self.vector.get(read).is_none() {\n+        if read == write || self.rows.get(read).is_none() {\n             return false;\n         }\n \n         self.ensure_row(write);\n-        let (bitvec_read, bitvec_write) = self.vector.pick2_mut(read, write);\n+        let (bitvec_read, bitvec_write) = self.rows.pick2_mut(read, write);\n         bitvec_write.merge(bitvec_read)\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n     pub fn merge_into(&mut self, into: R, from: &BitArray<C>) -> bool {\n         self.ensure_row(into);\n-        self.vector[into].merge(from)\n+        self.rows[into].merge(from)\n     }\n \n     /// Add all bits to the given row.\n     pub fn add_all(&mut self, row: R) {\n         self.ensure_row(row);\n-        self.vector[row].insert_all();\n+        self.rows[row].insert_all();\n     }\n \n     /// Number of elements in the matrix.\n     pub fn len(&self) -> usize {\n-        self.vector.len()\n+        self.rows.len()\n     }\n \n     pub fn rows(&self) -> impl Iterator<Item = R> {\n-        self.vector.indices()\n+        self.rows.indices()\n     }\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.vector.get(row).into_iter().flat_map(|r| r.iter())\n+        self.rows.get(row).into_iter().flat_map(|r| r.iter())\n     }\n \n     /// Iterates through each row and the accompanying bit set.\n     pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitArray<C>)> + 'a {\n-        self.vector.iter_enumerated()\n+        self.rows.iter_enumerated()\n     }\n \n     pub fn row(&self, row: R) -> Option<&BitArray<C>> {\n-        self.vector.get(row)\n+        self.rows.get(row)\n     }\n }\n "}]}