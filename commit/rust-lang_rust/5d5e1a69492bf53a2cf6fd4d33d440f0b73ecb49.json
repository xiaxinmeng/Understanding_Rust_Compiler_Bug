{"sha": "5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNWUxYTY5NDkyYmY1M2EyY2Y2ZmQ0ZDMzZDQ0MGYwYjczZWNiNDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-12T06:18:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-12T06:18:59Z"}, "message": "auto merge of #5849 : thestinger/rust/ffi, r=brson\n\nThe code samples are xfail'ed because the buildbot won't have `libsnappy.so` and I don't want to add boilerplate to all the snippets (but they're directly from my snappy bindings so I'll just send a pull request whenever they break). It works really well as an example because it's tiny library and lets the caller manage all the buffers.\r\n\r\nI think everything stated in the `Interoperability with foreign code` section is accurate but it deserves a thorough double-check :).", "tree": {"sha": "76163f16b11c1f232a6765ebcc283bd47d39fe4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76163f16b11c1f232a6765ebcc283bd47d39fe4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49", "html_url": "https://github.com/rust-lang/rust/commit/5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82a8815b94bae752c3d96562d76eb7a54fb4a54a", "url": "https://api.github.com/repos/rust-lang/rust/commits/82a8815b94bae752c3d96562d76eb7a54fb4a54a", "html_url": "https://github.com/rust-lang/rust/commit/82a8815b94bae752c3d96562d76eb7a54fb4a54a"}, {"sha": "1faa3596b021f391d2b79e4d5287082b519418b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1faa3596b021f391d2b79e4d5287082b519418b2", "html_url": "https://github.com/rust-lang/rust/commit/1faa3596b021f391d2b79e4d5287082b519418b2"}], "stats": {"total": 334, "additions": 139, "deletions": 195}, "files": [{"sha": "fc62fafa70090fa4c92da1bdb300041dfda002f6", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 139, "deletions": 195, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=5d5e1a69492bf53a2cf6fd4d33d440f0b73ecb49", "patch": "@@ -2,255 +2,199 @@\n \n # Introduction\n \n-Because Rust is a systems programming language, one of its goals is to\n-interoperate well with C code.\n+This tutorial will use the [snappy](https://code.google.com/p/snappy/)\n+compression/decompression library as an introduction to writing bindings for\n+foreign code. Rust is currently unable to call directly into a C++ library, but\n+snappy includes a C interface (documented in\n+[`snappy-c.h`](https://code.google.com/p/snappy/source/browse/trunk/snappy-c.h)).\n \n-We'll start with an example, which is a bit bigger than usual. We'll\n-go over it one piece at a time. This is a program that uses OpenSSL's\n-`SHA1` function to compute the hash of its first command-line\n-argument, which it then converts to a hexadecimal string and prints to\n-standard output. If you have the OpenSSL libraries installed, it\n-should compile and run without any extra effort.\n+The following is a minimal example of calling a foreign function which will compile if snappy is\n+installed:\n \n ~~~~ {.xfail-test}\n-extern mod std;\n-use core::libc::c_uint;\n+use core::libc::size_t;\n \n-extern mod crypto {\n-    fn SHA1(src: *u8, sz: c_uint, out: *u8) -> *u8;\n-}\n-\n-fn as_hex(data: ~[u8]) -> ~str {\n-    let mut acc = ~\"\";\n-    for data.each |&byte| { acc += fmt!(\"%02x\", byte as uint); }\n-    return acc;\n-}\n-\n-fn sha1(data: ~str) -> ~str {\n-    unsafe {\n-        let bytes = str::to_bytes(data);\n-        let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n-                                vec::len(bytes) as c_uint,\n-                                ptr::null());\n-        return as_hex(vec::from_buf(hash, 20));\n-    }\n+#[link_args = \"-lsnappy\"]\n+extern {\n+    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n }\n \n fn main() {\n-    io::println(sha1(core::os::args()[1]));\n+    let x = unsafe { snappy_max_compressed_length(100) };\n+    println(fmt!(\"max compressed length of a 100 byte buffer: %?\", x));\n }\n ~~~~\n \n-# Foreign modules\n-\n-Before we can call the `SHA1` function defined in the OpenSSL library, we have\n-to declare it. That is what this part of the program does:\n+The `extern` block is a list of function signatures in a foreign library, in this case with the\n+platform's C ABI. The `#[link_args]` attribute is used to instruct the linker to link against the\n+snappy library so the symbols are resolved.\n \n-~~~~ {.xfail-test}\n-extern mod crypto {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8; }\n-~~~~\n+Foreign functions are assumed to be unsafe so calls to them need to be wrapped with `unsafe {}` as a\n+promise to the compiler that everything contained within truly is safe. C libraries often expose\n+interfaces that aren't thread-safe, and almost any function that takes a pointer argument isn't\n+valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of\n+Rust's safe memory model.\n \n-An `extern` module declaration containing function signatures introduces the\n-functions listed as _foreign functions_. Foreign functions differ from regular\n-Rust functions in that they are implemented in some other language (usually C)\n-and called through Rust's foreign function interface (FFI). An extern module\n-like this is called a foreign module, and implicitly tells the compiler to\n-link with a library that contains the listed foreign functions, and has the\n-same name as the module.\n+When declaring the argument types to a foreign function, the Rust compiler will not check if the\n+declaration is correct, so specifying it correctly is part of keeping the binding correct at\n+runtime.\n \n-In this case, the Rust compiler changes the name `crypto` to a shared library\n-name in a platform-specific way (`libcrypto.so` on Linux, for example),\n-searches for the shared library with that name, and links the library into the\n-program. If you want the module to have a different name from the actual\n-library, you can use the `\"link_name\"` attribute, like:\n+The `extern` block can be extended to cover the entire snappy API:\n \n ~~~~ {.xfail-test}\n-#[link_name = \"crypto\"]\n-extern mod something {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n+use core::libc::{c_int, size_t};\n+\n+#[link_args = \"-lsnappy\"]\n+extern {\n+    fn snappy_compress(input: *u8,\n+                       input_length: size_t,\n+                       compressed: *mut u8,\n+                       compressed_length: *mut size_t) -> c_int;\n+    fn snappy_uncompress(compressed: *u8,\n+                         compressed_length: size_t,\n+                         uncompressed: *mut u8,\n+                         uncompressed_length: *mut size_t) -> c_int;\n+    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n+    fn snappy_uncompressed_length(compressed: *u8,\n+                                  compressed_length: size_t,\n+                                  result: *mut size_t) -> c_int;\n+    fn snappy_validate_compressed_buffer(compressed: *u8,\n+                                         compressed_length: size_t) -> c_int;\n }\n ~~~~\n \n-# Foreign calling conventions\n+# Creating a safe interface\n \n-Most foreign code is C code, which usually uses the `cdecl` calling\n-convention, so that is what Rust uses by default when calling foreign\n-functions. Some foreign functions, most notably the Windows API, use other\n-calling conventions. Rust provides the `\"abi\"` attribute as a way to hint to\n-the compiler which calling convention to use:\n+The raw C API needs to be wrapped to provide memory safety and make use higher-level concepts like\n+vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe\n+internal details.\n \n-~~~~\n-#[cfg(target_os = \"win32\")]\n-#[abi = \"stdcall\"]\n-extern mod kernel32 {\n-    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n+Wrapping the functions which expect buffers involves using the `vec::raw` module to manipulate Rust\n+vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The\n+length is number of elements currently contained, and the capacity is the total size in elements of\n+the allocated memory. The length is less than or equal to the capacity.\n+\n+~~~~ {.xfail-test}\n+pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n+    unsafe {\n+        snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\n+    }\n }\n ~~~~\n \n-The `\"abi\"` attribute applies to a foreign module (it cannot be applied\n-to a single function within a module), and must be either `\"cdecl\"`\n-or `\"stdcall\"`. We may extend the compiler in the future to support other\n-calling conventions.\n+The `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, but it makes the\n+guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function\n+signature.\n \n-# Unsafe pointers\n+The `snappy_compress` and `snappy_uncompress` functions are more complex, since a buffer has to be\n+allocated to hold the output too.\n \n-The foreign `SHA1` function takes three arguments, and returns a pointer.\n+The `snappy_max_compressed_length` function can be used to allocate a vector with the maximum\n+required capacity to hold the compressed output. The vector can then be passed to the\n+`snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n+the true length after compression for setting the length.\n \n ~~~~ {.xfail-test}\n-# extern mod crypto {\n-fn SHA1(src: *u8, sz: libc::c_uint, out: *u8) -> *u8;\n-# }\n-~~~~\n+pub fn compress(src: &[u8]) -> ~[u8] {\n+    unsafe {\n+        let srclen = src.len() as size_t;\n+        let psrc = vec::raw::to_ptr(src);\n \n-When declaring the argument types to a foreign function, the Rust\n-compiler has no way to check whether your declaration is correct, so\n-you have to be careful. If you get the number or types of the\n-arguments wrong, you're likely to cause a segmentation fault. Or,\n-probably even worse, your code will work on one platform, but break on\n-another.\n+        let mut dstlen = snappy_max_compressed_length(srclen);\n+        let mut dst = vec::with_capacity(dstlen as uint);\n+        let pdst = vec::raw::to_mut_ptr(dst);\n \n-In this case, we declare that `SHA1` takes two `unsigned char*`\n-arguments and one `unsigned long`. The Rust equivalents are `*u8`\n-unsafe pointers and an `uint` (which, like `unsigned long`, is a\n-machine-word-sized type).\n+        snappy_compress(psrc, srclen, pdst, &mut dstlen);\n+        vec::raw::set_len(&mut dst, dstlen as uint);\n+        dst\n+    }\n+}\n+~~~~\n \n-The standard library provides various functions to create unsafe pointers,\n-such as those in `core::cast`. Most of these functions have `unsafe` in their\n-name.  You can dereference an unsafe pointer with the `*` operator, but use\n-caution: unlike Rust's other pointer types, unsafe pointers are completely\n-unmanaged, so they might point at invalid memory, or be null pointers.\n+Decompression is similar, because snappy stores the uncompressed size as part of the compression\n+format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n-# Unsafe blocks\n+~~~~ {.xfail-test}\n+pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n+    unsafe {\n+        let srclen = src.len() as size_t;\n+        let psrc = vec::raw::to_ptr(src);\n \n-The `sha1` function is the most obscure part of the program.\n+        let mut dstlen: size_t = 0;\n+        snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n \n-~~~~\n-# pub mod crypto {\n-#   pub fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out }\n-# }\n-# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n-fn sha1(data: ~str) -> ~str {\n-    unsafe {\n-        let bytes = str::to_bytes(data);\n-        let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n-                                vec::len(bytes), ptr::null());\n-        return as_hex(vec::from_buf(hash, 20));\n+        let mut dst = vec::with_capacity(dstlen as uint);\n+        let pdst = vec::raw::to_mut_ptr(dst);\n+\n+        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n+            vec::raw::set_len(&mut dst, dstlen as uint);\n+            Some(dst)\n+        } else {\n+            None // SNAPPY_INVALID_INPUT\n+        }\n     }\n }\n ~~~~\n \n-First, what does the `unsafe` keyword at the top of the function\n-mean? `unsafe` is a block modifier\u2014it declares the block following it\n-to be known to be unsafe.\n+For reference, the examples used here are also available as an [library on\n+GitHub](https://github.com/thestinger/rust-snappy).\n \n-Some operations, like dereferencing unsafe pointers or calling\n-functions that have been marked unsafe, are only allowed inside unsafe\n-blocks. With the `unsafe` keyword, you're telling the compiler 'I know\n-what I'm doing'. The main motivation for such an annotation is that\n-when you have a memory error (and you will, if you're using unsafe\n-constructs), you have some idea where to look\u2014it will most likely be\n-caused by some unsafe code.\n+# Linking\n \n-Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n-advertise it to the world. An unsafe function is written like this:\n-\n-~~~~\n-unsafe fn kaboom() { ~\"I'm harmless!\"; }\n-~~~~\n+In addition to the `#[link_args]` attribute for explicitly passing arguments to the linker, an\n+`extern mod` block will pass `-lmodname` to the linker by default unless it has a `#[nolink]`\n+attribute applied.\n \n-This function can only be called from an `unsafe` block or another\n-`unsafe` function.\n-\n-# Pointer fiddling\n+# Unsafe blocks\n \n-The standard library defines a number of helper functions for dealing\n-with unsafe data, casting between types, and generally subverting\n-Rust's safety mechanisms.\n+Some operations, like dereferencing unsafe pointers or calling functions that have been marked\n+unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to\n+the compiler that the unsafety does not leak out of the block.\n \n-Let's look at our `sha1` function again.\n+Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\n+this:\n \n ~~~~\n-# pub mod crypto {\n-#     pub fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out }\n-# }\n-# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n-# fn x(data: ~str) -> ~str {\n-# unsafe {\n-let bytes = str::to_bytes(data);\n-let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n-                        vec::len(bytes), ptr::null());\n-return as_hex(vec::from_buf(hash, 20));\n-# }\n-# }\n+unsafe fn kaboom(ptr: *int) -> int { *ptr }\n ~~~~\n \n-The `str::to_bytes` function is perfectly safe: it converts a string to a\n-`~[u8]`. The program then feeds this byte array to `vec::raw::to_ptr`, which\n-returns an unsafe pointer to its contents.\n-\n-This pointer will become invalid at the end of the scope in which the vector\n-it points to (`bytes`) is valid, so you should be very careful how you use\n-it. In this case, the local variable `bytes` outlives the pointer, so we're\n-good.\n-\n-Passing a null pointer as the third argument to `SHA1` makes it use a\n-static buffer, and thus save us the effort of allocating memory\n-ourselves. `ptr::null` is a generic function that, in this case, returns an\n-unsafe null pointer of type `*u8`. (Rust generics are awesome\n-like that: they can take the right form depending on the type that they\n-are expected to return.)\n-\n-Finally, `vec::from_buf` builds up a new `~[u8]` from the\n-unsafe pointer that `SHA1` returned. SHA1 digests are always\n-twenty bytes long, so we can pass `20` for the length of the new\n-vector.\n-\n-# Passing structures\n+This function can only be called from an `unsafe` block or another `unsafe` function.\n \n-C functions often take pointers to structs as arguments. Since Rust\n-`struct`s are binary-compatible with C structs, Rust programs can call\n-such functions directly.\n+# Foreign calling conventions\n \n-This program uses the POSIX function `gettimeofday` to get a\n-microsecond-resolution timer.\n+Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when\n+calling foreign functions. Some foreign functions, most notably the Windows API, use other calling\n+conventions. Rust provides the `abi` attribute as a way to hint to the compiler which calling\n+convention to use:\n \n ~~~~\n-extern mod std;\n-use core::libc::c_ulonglong;\n-\n-struct timeval {\n-    tv_sec: c_ulonglong,\n-    tv_usec: c_ulonglong\n+#[cfg(target_os = \"win32\")]\n+#[abi = \"stdcall\"]\n+extern mod kernel32 {\n+    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> int;\n }\n+~~~~\n \n-#[nolink]\n-extern mod lib_c {\n-    fn gettimeofday(tv: *mut timeval, tz: *()) -> i32;\n-}\n-fn unix_time_in_microseconds() -> u64 {\n-    unsafe {\n-        let mut x = timeval {\n-            tv_sec: 0 as c_ulonglong,\n-            tv_usec: 0 as c_ulonglong\n-        };\n-        lib_c::gettimeofday(&mut x, ptr::null());\n-        return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n-    }\n-}\n+The `abi` attribute applies to a foreign module (it cannot be applied to a single function within a\n+module), and must be either `\"cdecl\"` or `\"stdcall\"`. The compiler may eventually support other\n+calling conventions.\n \n-# fn main() { assert!(fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"); }\n-~~~~\n+# Interoperability with foreign code\n \n-The `#[nolink]` attribute indicates that there's no foreign library to\n-link in. The standard C library is already linked with Rust programs.\n+Rust guarantees that the layout of a `struct` is compatible with the platform's representation in C.\n+A `#[packed]` attribute is available, which will lay out the struct members without padding.\n+However, there are currently no guarantees about the layout of an `enum`.\n \n-In C, a `timeval` is a struct with two 32-bit integer fields. Thus, we\n-define a `struct` type with the same contents, and declare\n-`gettimeofday` to take a pointer to such a `struct`.\n+Rust's owned and managed boxes use non-nullable pointers as handles which point to the contained\n+object. However, they should not be manually because they are managed by internal allocators.\n+Borrowed pointers can safely be assumed to be non-nullable pointers directly to the type. However,\n+breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw\n+pointers (`*`) if that's needed because the compiler can't make as many assumptions about them.\n \n-This program does not use the second argument to `gettimeofday` (the time\n- zone), so the `extern mod` declaration for it simply declares this argument\n- to be a pointer to the unit type (written `()`). Since all null pointers have\n- the same representation regardless of their referent type, this is safe.\n+Vectors and strings share the same basic memory layout, and utilities are available in the `vec` and\n+`str` modules for working with C APIs. Strings are terminated with `\\0` for interoperability with C,\n+but it should not be assumed because a slice will not always be nul-terminated. Instead, the\n+`str::as_c_str` function should be used.\n \n+The standard library includes type aliases and function definitions for the C standard library in\n+the `libc` module, and Rust links against `libc` and `libm` by default."}]}