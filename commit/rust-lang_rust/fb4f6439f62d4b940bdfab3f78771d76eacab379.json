{"sha": "fb4f6439f62d4b940bdfab3f78771d76eacab379", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNGY2NDM5ZjYyZDRiOTQwYmRmYWIzZjc4NzcxZDc2ZWFjYWIzNzk=", "commit": {"author": {"name": "Andy Wang", "email": "qian.wang19@imperial.ac.uk", "date": "2021-04-14T13:12:39Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2021-05-05T14:31:03Z"}, "message": "Revamp RealFileName public methods", "tree": {"sha": "d228b5f9453949c70950391acf828a5bb7b2eb03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d228b5f9453949c70950391acf828a5bb7b2eb03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb4f6439f62d4b940bdfab3f78771d76eacab379", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmCSrCcACgkQGBtJ+fOP\nM3RDCgv/SMdXNOUUGZ5G4CUcC2iGRJsxnxIMI3QqmPuTDqleil/wmJYjQWaMVbrr\n6Jcx3uaVMOjt8snf6+PqIcnY59KaZdBeEPl9ba6vCTrqHx53w0lWxfGvBszaHb8t\ntvRd6KkibHwRLoVYFW+NjZKmiGVNxtTiBA+jfnq7Y9SkQq7REJcvLazL6weatO6c\nLkpbrg6Gg6pjLFuw9/3tklHrcHJQ1Otiv1J0W+siY/KQTJe4rBsq2dEt4fu8ihJh\nELmLYNCH1gYcyiaAFuaxUEZs5ruxZpsVHpe4x8H1q+Izeki9QNpEoq8qsPCy1QXd\nYz+oqMXyUG6T3PW8qU3keUbhfYwI7/OJP5jxypGRDCS/SgodAWyMIy9yxkmtFBzW\ncFEoN2ugd31CG/j/8Mu4kOB29MNdtxPmhZ08FpCNLmwVodOxAOf8YZJduVCOAF8E\nXS39UjVJ2BDZQgjHcg9HZaOjNbZNz72Ynni5nTIrIvMGwbXqNadrSR/BJPCIyML5\nzHhiq65n\n=HmeF\n-----END PGP SIGNATURE-----", "payload": "tree d228b5f9453949c70950391acf828a5bb7b2eb03\nparent f8e55da6defaba1dff4d1e11f76dda3b366819be\nauthor Andy Wang <qian.wang19@imperial.ac.uk> 1618405959 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1620225063 +0100\n\nRevamp RealFileName public methods\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4f6439f62d4b940bdfab3f78771d76eacab379", "html_url": "https://github.com/rust-lang/rust/commit/fb4f6439f62d4b940bdfab3f78771d76eacab379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb4f6439f62d4b940bdfab3f78771d76eacab379/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8e55da6defaba1dff4d1e11f76dda3b366819be", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8e55da6defaba1dff4d1e11f76dda3b366819be", "html_url": "https://github.com/rust-lang/rust/commit/f8e55da6defaba1dff4d1e11f76dda3b366819be"}], "stats": {"total": 94, "additions": 53, "deletions": 41}, "files": [{"sha": "b3f700bc46794a1b628641654c7089bb296e48fa", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=fb4f6439f62d4b940bdfab3f78771d76eacab379", "patch": "@@ -66,7 +66,7 @@ fn line_program_add_file(\n ) -> FileId {\n     match &file.name {\n         FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.stable_name());\n+            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n             let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n             let file_name = osstr_as_utf8_bytes(file_name);\n "}, {"sha": "61e54a76f29ba514956cb25c6066ef6182190e79", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=fb4f6439f62d4b940bdfab3f78771d76eacab379", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> DebugContext<'tcx> {\n         // FIXME: how to get version when building out of tree?\n         // Normally this would use option_env!(\"CFG_VERSION\").\n         let producer = format!(\"cg_clif (rustc {})\", \"unknown version\");\n-        let comp_dir = tcx.sess.working_dir.stable_name().to_string_lossy().into_owned();\n+        let comp_dir = tcx.sess.working_dir.to_string_lossy(false).into_owned();\n         let (name, file_info) = match tcx.sess.local_crate_source_file.clone() {\n             Some(path) => {\n                 let name = path.to_string_lossy().into_owned();"}, {"sha": "6fad1996d7e6f99305e1c05dac9422bf6ce55706", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=fb4f6439f62d4b940bdfab3f78771d76eacab379", "patch": "@@ -764,7 +764,7 @@ pub fn file_metadata(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll\n     let hash = Some(&source_file.src_hash);\n     let file_name = Some(source_file.name.to_string());\n     let directory = if source_file.is_real_file() && !source_file.is_imported() {\n-        Some(cx.sess().working_dir.stable_name().to_string_lossy().to_string())\n+        Some(cx.sess().working_dir.to_string_lossy(false).to_string())\n     } else {\n         // If the path comes from an upstream crate we assume it has been made\n         // independent of the compiler's working directory one way or another.\n@@ -992,7 +992,7 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n-    let work_dir = tcx.sess.working_dir.stable_name().to_string_lossy();\n+    let work_dir = tcx.sess.working_dir.to_string_lossy(false);\n     let flags = \"\\0\";\n     let out_dir = &tcx.output_filenames(LOCAL_CRATE).out_directory;\n     let split_name = if tcx.sess.target_can_use_split_dwarf() {"}, {"sha": "fa62b664b9ecda64d08c622199fb962c2ff66984", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=fb4f6439f62d4b940bdfab3f78771d76eacab379", "patch": "@@ -490,22 +490,27 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     FileName::Real(ref realname) => {\n                         let mut adapted = (**source_file).clone();\n                         adapted.name = FileName::Real(match realname {\n-                            RealFileName::LocalPath(local_path) => {\n-                                // Prepend path of working directory onto local path.\n-                                // because relative paths are potentially relative to a\n-                                // wrong directory.\n+                            RealFileName::LocalPath(path_to_file) => {\n+                                // Prepend path of working directory onto potentially\n+                                // relative paths, because they could become relative\n+                                // to a wrong directory.\n                                 let working_dir = &self.tcx.sess.working_dir;\n-                                if let RealFileName::LocalPath(absolute) = working_dir {\n-                                    // If working_dir has not been remapped, then we emit a\n-                                    // LocalPath variant as it's likely to be a valid path\n-                                    RealFileName::LocalPath(Path::new(absolute).join(local_path))\n-                                } else {\n-                                    // If working_dir has been remapped, then we emit\n-                                    // Remapped variant as the expanded path won't be valid\n-                                    RealFileName::Remapped {\n-                                        local_path: None,\n-                                        virtual_name: Path::new(working_dir.stable_name())\n-                                            .join(local_path),\n+                                match working_dir {\n+                                    RealFileName::LocalPath(absolute) => {\n+                                        // If working_dir has not been remapped, then we emit a\n+                                        // LocalPath variant as it's likely to be a valid path\n+                                        RealFileName::LocalPath(\n+                                            Path::new(absolute).join(path_to_file),\n+                                        )\n+                                    }\n+                                    RealFileName::Remapped { local_path: _, virtual_name } => {\n+                                        // If working_dir has been remapped, then we emit\n+                                        // Remapped variant as the expanded path won't be valid\n+                                        RealFileName::Remapped {\n+                                            local_path: None,\n+                                            virtual_name: Path::new(virtual_name)\n+                                                .join(path_to_file),\n+                                        }\n                                     }\n                                 }\n                             }"}, {"sha": "06b2e41daf5db5f0f679a01a0821cbfa1c554716", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=fb4f6439f62d4b940bdfab3f78771d76eacab379", "patch": "@@ -190,7 +190,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n \n         let data = CompilationOptions {\n-            directory: self.tcx.sess.working_dir.stable_name().into(),\n+            directory: self.tcx.sess.working_dir.remapped_path_if_available().into(),\n             program,\n             arguments,\n             output: self.save_ctxt.compilation_output(crate_name),"}, {"sha": "3c4d7972380c405b386f4a57a16abc17c4ad5ca6", "filename": "compiler/rustc_save_analysis/src/span_utils.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fspan_utils.rs?ref=fb4f6439f62d4b940bdfab3f78771d76eacab379", "patch": "@@ -26,7 +26,12 @@ impl<'a> SpanUtils<'a> {\n                         .display()\n                         .to_string()\n                 } else {\n-                    self.sess.working_dir.stable_name().join(&path).display().to_string()\n+                    self.sess\n+                        .working_dir\n+                        .remapped_path_if_available()\n+                        .join(&path)\n+                        .display()\n+                        .to_string()\n                 }\n             }\n             // If the file name was remapped, we assume the user"}, {"sha": "787fe1d0f78cff8f091ab0bc2ec94ada421ce147", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4f6439f62d4b940bdfab3f78771d76eacab379/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=fb4f6439f62d4b940bdfab3f78771d76eacab379", "patch": "@@ -172,7 +172,7 @@ impl<S: Encoder> Encodable<S> for RealFileName {\n impl RealFileName {\n     /// Returns the path suitable for reading from the file system on the local host,\n     /// if this information exists.\n-    /// Avoid embedding this in build artifacts; see `stable_name()` for that.\n+    /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.\n     pub fn local_path(&self) -> Option<&Path> {\n         match self {\n             RealFileName::LocalPath(p) => Some(p),\n@@ -184,39 +184,41 @@ impl RealFileName {\n \n     /// Returns the path suitable for reading from the file system on the local host,\n     /// if this information exists.\n-    /// Avoid embedding this in build artifacts; see `stable_name()` for that.\n+    /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.\n     pub fn into_local_path(self) -> Option<PathBuf> {\n         match self {\n             RealFileName::LocalPath(p) => Some(p),\n             RealFileName::Remapped { local_path: p, virtual_name: _ } => p,\n         }\n     }\n \n-    /// Returns the path suitable for embedding into build artifacts. Note that\n-    /// a remapped path will not correspond to a valid file system path; see\n-    /// `local_path()` for something that is more likely to return paths into the\n-    /// local host file system.\n-    pub fn stable_name(&self) -> &Path {\n+    /// Returns the path suitable for embedding into build artifacts. This would still\n+    /// be a local path if it has not been remapped. A remapped path will not correspond\n+    /// to a valid file system path: see `local_path_if_available()` for something that\n+    /// is more likely to return paths into the local host file system.\n+    pub fn remapped_path_if_available(&self) -> &Path {\n         match self {\n             RealFileName::LocalPath(p)\n             | RealFileName::Remapped { local_path: _, virtual_name: p } => &p,\n         }\n     }\n \n-    fn to_string_lossy(&self, prefer_local: bool) -> Cow<'_, str> {\n-        use RealFileName::*;\n+    /// Returns the path suitable for reading from the file system on the local host,\n+    /// if this information exists. Otherwise returns the remapped name.\n+    /// Avoid embedding this in build artifacts; see `remapped_path_if_available()` for that.\n+    pub fn local_path_if_available(&self) -> &Path {\n+        match self {\n+            RealFileName::LocalPath(path)\n+            | RealFileName::Remapped { local_path: None, virtual_name: path }\n+            | RealFileName::Remapped { local_path: Some(path), virtual_name: _ } => path,\n+        }\n+    }\n+\n+    pub fn to_string_lossy(&self, prefer_local: bool) -> Cow<'_, str> {\n         if prefer_local {\n-            match self {\n-                LocalPath(path)\n-                | Remapped { local_path: None, virtual_name: path }\n-                | Remapped { local_path: Some(path), virtual_name: _ } => path.to_string_lossy(),\n-            }\n+            self.local_path_if_available().to_string_lossy()\n         } else {\n-            match self {\n-                LocalPath(path) | Remapped { local_path: _, virtual_name: path } => {\n-                    path.to_string_lossy()\n-                }\n-            }\n+            self.remapped_path_if_available().to_string_lossy()\n         }\n     }\n }\n@@ -1358,7 +1360,7 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n \n impl fmt::Debug for SourceFile {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"SourceFile({})\", self.name)\n+        write!(fmt, \"SourceFile({:?})\", self.name)\n     }\n }\n "}]}