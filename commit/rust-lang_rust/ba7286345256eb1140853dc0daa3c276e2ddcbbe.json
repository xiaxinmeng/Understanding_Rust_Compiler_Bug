{"sha": "ba7286345256eb1140853dc0daa3c276e2ddcbbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNzI4NjM0NTI1NmViMTE0MDg1M2RjMGRhYTNjMjc2ZTJkZGNiYmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T15:18:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T15:18:35Z"}, "message": "Merge #5063\n\n5063: Store field/variant attrs in ItemTree and use it for adt.rs queries r=jonas-schievink a=jonas-schievink\n\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "e5f328bc2e9794cc93413ecba4a121f8f6f020ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5f328bc2e9794cc93413ecba4a121f8f6f020ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba7286345256eb1140853dc0daa3c276e2ddcbbe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9MBLCRBK7hj4Ov3rIwAAdHIIAAuPVnRENDrLutukeTEjlt16\nUsbDzxTMEzgao5R/30NQBMWthLxfJ5dnGv0bc2EuPJfxJrUDeI157HarcCP4u4IB\n2cqnS3lvINZCmZOG4RDuyPCo95FJc7F5mfuLw4J3u0104we6fV26X6/Fv2qu7LXG\nC945U/KACm2G5VNbBA1LzKAfbr7+FcGcm36IpTuAly/PunlVRahKOhKjwLaqffR2\nXVUsi0Do+iP/RoqUq2/r/mROpbSR8NkvzdSKQcKR9TtIpRs7FM+y4rGWhA/LVyV3\nWoaZaEQ4eZpq4/GpkKybj5/Kn197IhIZUyF0OPKGAQo4laAzetFtbChlXPF70Uk=\n=BP5L\n-----END PGP SIGNATURE-----\n", "payload": "tree e5f328bc2e9794cc93413ecba4a121f8f6f020ad\nparent 96d335d578984b42c2e00c715c924bceca391a6c\nparent dad2f75b91bcc6ac7620326fec082aca7edea7ce\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593098315 +0000\ncommitter GitHub <noreply@github.com> 1593098315 +0000\n\nMerge #5063\n\n5063: Store field/variant attrs in ItemTree and use it for adt.rs queries r=jonas-schievink a=jonas-schievink\n\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba7286345256eb1140853dc0daa3c276e2ddcbbe", "html_url": "https://github.com/rust-lang/rust/commit/ba7286345256eb1140853dc0daa3c276e2ddcbbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba7286345256eb1140853dc0daa3c276e2ddcbbe/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96d335d578984b42c2e00c715c924bceca391a6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/96d335d578984b42c2e00c715c924bceca391a6c", "html_url": "https://github.com/rust-lang/rust/commit/96d335d578984b42c2e00c715c924bceca391a6c"}, {"sha": "dad2f75b91bcc6ac7620326fec082aca7edea7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/dad2f75b91bcc6ac7620326fec082aca7edea7ce", "html_url": "https://github.com/rust-lang/rust/commit/dad2f75b91bcc6ac7620326fec082aca7edea7ce"}], "stats": {"total": 223, "additions": 162, "deletions": 61}, "files": [{"sha": "4994a2125320fd7589eec94fddf4deeedffc1f08", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 68, "deletions": 26, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=ba7286345256eb1140853dc0daa3c276e2ddcbbe", "patch": "@@ -8,12 +8,12 @@ use hir_expand::{\n     InFile,\n };\n use ra_arena::{map::ArenaMap, Arena};\n-use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n     db::DefDatabase,\n+    item_tree::{Field, Fields, ItemTree},\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n@@ -22,6 +22,7 @@ use crate::{\n     EnumId, HasModule, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId,\n     VariantId,\n };\n+use ra_cfg::CfgOptions;\n \n /// Note that we use `StructData` for unions as well!\n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -59,39 +60,48 @@ pub struct FieldData {\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n-        let src = id.lookup(db).source(db);\n+        let loc = id.lookup(db);\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n \n-        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let variant_data =\n-            VariantData::new(db, src.map(|s| s.kind()), id.lookup(db).container.module(db));\n-        let variant_data = Arc::new(variant_data);\n-        Arc::new(StructData { name, variant_data })\n+        let strukt = &item_tree[loc.id.value];\n+        let variant_data = lower_fields(&item_tree, &cfg_options, &strukt.fields);\n+\n+        Arc::new(StructData { name: strukt.name.clone(), variant_data: Arc::new(variant_data) })\n     }\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n-        let src = id.lookup(db).source(db);\n-        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let variant_data = VariantData::new(\n-            db,\n-            src.map(|s| {\n-                s.record_field_def_list()\n-                    .map(ast::StructKind::Record)\n-                    .unwrap_or(ast::StructKind::Unit)\n-            }),\n-            id.lookup(db).container.module(db),\n-        );\n-        let variant_data = Arc::new(variant_data);\n-        Arc::new(StructData { name, variant_data })\n+        let loc = id.lookup(db);\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n+\n+        let union = &item_tree[loc.id.value];\n+        let variant_data = lower_fields(&item_tree, &cfg_options, &union.fields);\n+\n+        Arc::new(StructData { name: union.name.clone(), variant_data: Arc::new(variant_data) })\n     }\n }\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n-        let _p = profile(\"enum_data_query\");\n-        let src = e.lookup(db).source(db);\n-        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let mut trace = Trace::new_for_arena();\n-        lower_enum(db, &mut trace, &src, e.lookup(db).container.module(db));\n-        Arc::new(EnumData { name, variants: trace.into_arena() })\n+        let loc = e.lookup(db);\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n+\n+        let enum_ = &item_tree[loc.id.value];\n+        let mut variants = Arena::new();\n+        for var_id in enum_.variants.clone() {\n+            if item_tree.attrs(var_id.into()).is_cfg_enabled(&cfg_options) {\n+                let var = &item_tree[var_id];\n+                let var_data = lower_fields(&item_tree, &cfg_options, &var.fields);\n+\n+                variants.alloc(EnumVariantData {\n+                    name: var.name.clone(),\n+                    variant_data: Arc::new(var_data),\n+                });\n+            }\n+        }\n+\n+        Arc::new(EnumData { name: enum_.name.clone(), variants })\n     }\n \n     pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n@@ -251,3 +261,35 @@ fn lower_struct(\n         ast::StructKind::Unit => StructKind::Unit,\n     }\n }\n+\n+fn lower_fields(item_tree: &ItemTree, cfg_options: &CfgOptions, fields: &Fields) -> VariantData {\n+    match fields {\n+        Fields::Record(flds) => {\n+            let mut arena = Arena::new();\n+            for field_id in flds.clone() {\n+                if item_tree.attrs(field_id.into()).is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, &item_tree[field_id]));\n+                }\n+            }\n+            VariantData::Record(arena)\n+        }\n+        Fields::Tuple(flds) => {\n+            let mut arena = Arena::new();\n+            for field_id in flds.clone() {\n+                if item_tree.attrs(field_id.into()).is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, &item_tree[field_id]));\n+                }\n+            }\n+            VariantData::Tuple(arena)\n+        }\n+        Fields::Unit => VariantData::Unit,\n+    }\n+}\n+\n+fn lower_field(item_tree: &ItemTree, field: &Field) -> FieldData {\n+    FieldData {\n+        name: field.name.clone(),\n+        type_ref: field.type_ref.clone(),\n+        visibility: item_tree[field.visibility].clone(),\n+    }\n+}"}, {"sha": "e228e2145be08ae547d304cedabfa24a1ba4a1a9", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=ba7286345256eb1140853dc0daa3c276e2ddcbbe", "patch": "@@ -208,5 +208,5 @@ where\n fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> Attrs {\n     let tree = db.item_tree(id.file_id);\n     let mod_item = N::id_to_mod_item(id.value);\n-    tree.attrs(mod_item).clone()\n+    tree.attrs(mod_item.into()).clone()\n }"}, {"sha": "282ade2a3a63e4d28078a68dda024e0d5996e2f1", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=ba7286345256eb1140853dc0daa3c276e2ddcbbe", "patch": "@@ -40,7 +40,7 @@ impl FunctionData {\n             name: func.name.clone(),\n             params: func.params.to_vec(),\n             ret_type: func.ret_type.clone(),\n-            attrs: item_tree.attrs(loc.id.value.into()).clone(),\n+            attrs: item_tree.attrs(ModItem::from(loc.id.value).into()).clone(),\n             has_self_param: func.has_self_param,\n             is_unsafe: func.is_unsafe,\n             visibility: item_tree[func.visibility].clone(),\n@@ -224,7 +224,7 @@ fn collect_items(\n         match item {\n             AssocItem::Function(id) => {\n                 let item = &item_tree[id];\n-                let attrs = item_tree.attrs(id.into());\n+                let attrs = item_tree.attrs(ModItem::from(id).into());\n                 if !attrs.is_cfg_enabled(&cfg_options) {\n                     continue;\n                 }"}, {"sha": "3e603bd55841e5c6a0a05ee59971fcb42913fdb7", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=ba7286345256eb1140853dc0daa3c276e2ddcbbe", "patch": "@@ -5,6 +5,7 @@ mod lower;\n mod tests;\n \n use std::{\n+    any::type_name,\n     fmt::{self, Debug},\n     hash::{Hash, Hasher},\n     marker::PhantomData,\n@@ -178,8 +179,8 @@ impl ItemTree {\n         self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&Attrs::EMPTY)\n     }\n \n-    pub fn attrs(&self, of: ModItem) -> &Attrs {\n-        self.attrs.get(&AttrOwner::ModItem(of)).unwrap_or(&Attrs::EMPTY)\n+    pub fn attrs(&self, of: AttrOwner) -> &Attrs {\n+        self.attrs.get(&of).unwrap_or(&Attrs::EMPTY)\n     }\n \n     /// Returns the lowered inner items that `ast` corresponds to.\n@@ -282,15 +283,32 @@ struct ItemTreeData {\n }\n \n #[derive(Debug, Eq, PartialEq, Hash)]\n-enum AttrOwner {\n+pub enum AttrOwner {\n     /// Attributes on an item.\n     ModItem(ModItem),\n     /// Inner attributes of the source file.\n     TopLevel,\n+\n+    Variant(Idx<Variant>),\n+    Field(Idx<Field>),\n     // FIXME: Store variant and field attrs, and stop reparsing them in `attrs_query`.\n }\n \n-/// Trait implemented by all nodes in the item tree.\n+macro_rules! from_attrs {\n+    ( $( $var:ident($t:ty) ),+ ) => {\n+        $(\n+            impl From<$t> for AttrOwner {\n+                fn from(t: $t) -> AttrOwner {\n+                    AttrOwner::$var(t)\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+from_attrs!(ModItem(ModItem), Variant(Idx<Variant>), Field(Idx<Field>));\n+\n+/// Trait implemented by all item nodes in the item tree.\n pub trait ItemTreeNode: Clone {\n     type Source: AstNode + Into<ast::ModuleItem>;\n \n@@ -523,7 +541,7 @@ pub struct Enum {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n     pub generic_params: GenericParamsId,\n-    pub variants: Range<Idx<Variant>>,\n+    pub variants: IdRange<Variant>,\n     pub ast_id: FileAstId<ast::EnumDef>,\n }\n \n@@ -681,10 +699,48 @@ pub struct Variant {\n     pub fields: Fields,\n }\n \n+pub struct IdRange<T> {\n+    range: Range<u32>,\n+    _p: PhantomData<T>,\n+}\n+\n+impl<T> IdRange<T> {\n+    fn new(range: Range<Idx<T>>) -> Self {\n+        Self { range: range.start.into_raw().into()..range.end.into_raw().into(), _p: PhantomData }\n+    }\n+}\n+\n+impl<T> Iterator for IdRange<T> {\n+    type Item = Idx<T>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.range.next().map(|raw| Idx::from_raw(raw.into()))\n+    }\n+}\n+\n+impl<T> fmt::Debug for IdRange<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(&format!(\"IdRange::<{}>\", type_name::<T>())).field(&self.range).finish()\n+    }\n+}\n+\n+impl<T> Clone for IdRange<T> {\n+    fn clone(&self) -> Self {\n+        Self { range: self.range.clone(), _p: PhantomData }\n+    }\n+}\n+\n+impl<T> PartialEq for IdRange<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.range == other.range\n+    }\n+}\n+\n+impl<T> Eq for IdRange<T> {}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum Fields {\n-    Record(Range<Idx<Field>>),\n-    Tuple(Range<Idx<Field>>),\n+    Record(IdRange<Field>),\n+    Tuple(IdRange<Field>),\n     Unit,\n }\n "}, {"sha": "5149dd141ff3d39ce784a6855b8474fec135ab8d", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=ba7286345256eb1140853dc0daa3c276e2ddcbbe", "patch": "@@ -126,15 +126,15 @@ impl Ctx {\n \n         if !attrs.is_empty() {\n             for item in items.iter().flat_map(|items| &items.0) {\n-                self.add_attrs(*item, attrs.clone());\n+                self.add_attrs((*item).into(), attrs.clone());\n             }\n         }\n \n         items\n     }\n \n-    fn add_attrs(&mut self, item: ModItem, attrs: Attrs) {\n-        match self.tree.attrs.entry(AttrOwner::ModItem(item)) {\n+    fn add_attrs(&mut self, item: AttrOwner, attrs: Attrs) {\n+        match self.tree.attrs.entry(item) {\n             Entry::Occupied(mut entry) => {\n                 *entry.get_mut() = entry.get().merge(attrs);\n             }\n@@ -196,15 +196,16 @@ impl Ctx {\n         }\n     }\n \n-    fn lower_record_fields(&mut self, fields: &ast::RecordFieldDefList) -> Range<Idx<Field>> {\n+    fn lower_record_fields(&mut self, fields: &ast::RecordFieldDefList) -> IdRange<Field> {\n         let start = self.next_field_idx();\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n-                self.data().fields.alloc(data);\n+                let idx = self.data().fields.alloc(data);\n+                self.add_attrs(idx.into(), Attrs::new(&field, &self.hygiene));\n             }\n         }\n         let end = self.next_field_idx();\n-        start..end\n+        IdRange::new(start..end)\n     }\n \n     fn lower_record_field(&mut self, field: &ast::RecordFieldDef) -> Option<Field> {\n@@ -215,15 +216,16 @@ impl Ctx {\n         Some(res)\n     }\n \n-    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldDefList) -> Range<Idx<Field>> {\n+    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldDefList) -> IdRange<Field> {\n         let start = self.next_field_idx();\n         for (i, field) in fields.fields().enumerate() {\n             if let Some(data) = self.lower_tuple_field(i, &field) {\n-                self.data().fields.alloc(data);\n+                let idx = self.data().fields.alloc(data);\n+                self.add_attrs(idx.into(), Attrs::new(&field, &self.hygiene));\n             }\n         }\n         let end = self.next_field_idx();\n-        start..end\n+        IdRange::new(start..end)\n     }\n \n     fn lower_tuple_field(&mut self, idx: usize, field: &ast::TupleFieldDef) -> Option<Field> {\n@@ -242,7 +244,7 @@ impl Ctx {\n             Some(record_field_def_list) => {\n                 self.lower_fields(&StructKind::Record(record_field_def_list))\n             }\n-            None => Fields::Record(self.next_field_idx()..self.next_field_idx()),\n+            None => Fields::Record(IdRange::new(self.next_field_idx()..self.next_field_idx())),\n         };\n         let ast_id = self.source_ast_id_map.ast_id(union);\n         let res = Union { name, visibility, generic_params, fields, ast_id };\n@@ -255,22 +257,23 @@ impl Ctx {\n         let generic_params = self.lower_generic_params(GenericsOwner::Enum, enum_);\n         let variants = match &enum_.variant_list() {\n             Some(variant_list) => self.lower_variants(variant_list),\n-            None => self.next_variant_idx()..self.next_variant_idx(),\n+            None => IdRange::new(self.next_variant_idx()..self.next_variant_idx()),\n         };\n         let ast_id = self.source_ast_id_map.ast_id(enum_);\n         let res = Enum { name, visibility, generic_params, variants, ast_id };\n         Some(id(self.data().enums.alloc(res)))\n     }\n \n-    fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> Range<Idx<Variant>> {\n+    fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> IdRange<Variant> {\n         let start = self.next_variant_idx();\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n-                self.data().variants.alloc(data);\n+                let idx = self.data().variants.alloc(data);\n+                self.add_attrs(idx.into(), Attrs::new(&variant, &self.hygiene));\n             }\n         }\n         let end = self.next_variant_idx();\n-        start..end\n+        IdRange::new(start..end)\n     }\n \n     fn lower_variant(&mut self, variant: &ast::EnumVariant) -> Option<Variant> {\n@@ -419,7 +422,7 @@ impl Ctx {\n                         let attrs = Attrs::new(&item, &this.hygiene);\n                         this.collect_inner_items(item.syntax());\n                         this.lower_assoc_item(&item).map(|item| {\n-                            this.add_attrs(item.into(), attrs);\n+                            this.add_attrs(ModItem::from(item).into(), attrs);\n                             item\n                         })\n                     })\n@@ -453,7 +456,7 @@ impl Ctx {\n                 self.collect_inner_items(item.syntax());\n                 let assoc = self.lower_assoc_item(&item)?;\n                 let attrs = Attrs::new(&item, &self.hygiene);\n-                self.add_attrs(assoc.into(), attrs);\n+                self.add_attrs(ModItem::from(assoc).into(), attrs);\n                 Some(assoc)\n             })\n             .collect();\n@@ -539,7 +542,7 @@ impl Ctx {\n                 .filter_map(|item| {\n                     self.collect_inner_items(item.syntax());\n                     let attrs = Attrs::new(&item, &self.hygiene);\n-                    let id = match item {\n+                    let id: ModItem = match item {\n                         ast::ExternItem::FnDef(ast) => {\n                             let func = self.lower_function(&ast)?;\n                             func.into()\n@@ -549,7 +552,7 @@ impl Ctx {\n                             statik.into()\n                         }\n                     };\n-                    self.add_attrs(id, attrs);\n+                    self.add_attrs(id.into(), attrs);\n                     Some(id)\n                 })\n                 .collect()"}, {"sha": "08559fb92bddf067ae6c87d4acce1de54dbb6464", "filename": "crates/ra_hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=ba7286345256eb1140853dc0daa3c276e2ddcbbe", "patch": "@@ -92,7 +92,7 @@ fn print_item_tree(ra_fixture: &str) -> String {\n }\n \n fn fmt_mod_item(out: &mut String, tree: &ItemTree, item: ModItem) {\n-    let attrs = tree.attrs(item);\n+    let attrs = tree.attrs(item.into());\n     if !attrs.is_empty() {\n         format_to!(out, \"#[{:?}]\\n\", attrs);\n     }\n@@ -237,13 +237,13 @@ Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generi\n #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct0\"))] }, input: None }]) }]\n Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(3), kind: Unit }\n #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct1\"))] }, input: None }]) }]\n-Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(Idx::<Field>(0)..Idx::<Field>(1)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(4), kind: Tuple }\n+Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(IdRange::<ra_hir_def::item_tree::Field>(0..1)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(4), kind: Tuple }\n #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct2\"))] }, input: None }]) }]\n-Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(Idx::<Field>(1)..Idx::<Field>(2)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(5), kind: Record }\n+Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(1..2)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(5), kind: Record }\n #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"en\"))] }, input: None }]) }]\n-Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: Idx::<Variant>(0)..Idx::<Variant>(1), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::EnumDef>(6) }\n+Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: IdRange::<ra_hir_def::item_tree::Variant>(0..1), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::EnumDef>(6) }\n #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"un\"))] }, input: None }]) }]\n-Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(Idx::<Field>(3)..Idx::<Field>(4)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UnionDef>(7) }\n+Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(3..4)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UnionDef>(7) }\n     \"###);\n }\n "}, {"sha": "2ced4f66bbe15f37843d1578b709fc3621417b2d", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba7286345256eb1140853dc0daa3c276e2ddcbbe/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=ba7286345256eb1140853dc0daa3c276e2ddcbbe", "patch": "@@ -742,7 +742,7 @@ impl ModCollector<'_, '_> {\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            if self.is_cfg_enabled(self.item_tree.attrs(*item)) {\n+            if self.is_cfg_enabled(self.item_tree.attrs((*item).into())) {\n                 if let ModItem::ExternCrate(id) = item {\n                     let import = self.item_tree[*id].clone();\n                     if import.is_macro_use {\n@@ -753,7 +753,7 @@ impl ModCollector<'_, '_> {\n         }\n \n         for &item in items {\n-            let attrs = self.item_tree.attrs(item);\n+            let attrs = self.item_tree.attrs(item.into());\n             if self.is_cfg_enabled(attrs) {\n                 let module =\n                     ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };"}]}