{"sha": "780b23af73540dad0ec78488949bbcd380efd71e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MGIyM2FmNzM1NDBkYWQwZWM3ODQ4ODk0OWJiY2QzODBlZmQ3MWU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-11T01:27:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:24Z"}, "message": "libstd: add the new trait-based serialization\n\nThis will need a snapshot before we can convert ebml and rustc\nto use the new-style serialization.", "tree": {"sha": "5f085370704e3c8787e9ab0f2d6fc891c4c333c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f085370704e3c8787e9ab0f2d6fc891c4c333c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/780b23af73540dad0ec78488949bbcd380efd71e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/780b23af73540dad0ec78488949bbcd380efd71e", "html_url": "https://github.com/rust-lang/rust/commit/780b23af73540dad0ec78488949bbcd380efd71e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/780b23af73540dad0ec78488949bbcd380efd71e/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75935cea7f43c317fc876fe8f914c11ff43d1483", "url": "https://api.github.com/repos/rust-lang/rust/commits/75935cea7f43c317fc876fe8f914c11ff43d1483", "html_url": "https://github.com/rust-lang/rust/commit/75935cea7f43c317fc876fe8f914c11ff43d1483"}], "stats": {"total": 386, "additions": 385, "deletions": 1}, "files": [{"sha": "92461fed25809ff53fa8498e954dce5cd33383e6", "filename": "src/libstd/serialization2.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/780b23af73540dad0ec78488949bbcd380efd71e/src%2Flibstd%2Fserialization2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780b23af73540dad0ec78488949bbcd380efd71e/src%2Flibstd%2Fserialization2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization2.rs?ref=780b23af73540dad0ec78488949bbcd380efd71e", "patch": "@@ -0,0 +1,382 @@\n+//! Support code for serialization.\n+\n+/*\n+Core serialization interfaces.\n+*/\n+\n+trait Serializer {\n+    // Primitive types:\n+    fn emit_nil();\n+    fn emit_uint(v: uint);\n+    fn emit_u64(v: u64);\n+    fn emit_u32(v: u32);\n+    fn emit_u16(v: u16);\n+    fn emit_u8(v: u8);\n+    fn emit_int(v: int);\n+    fn emit_i64(v: i64);\n+    fn emit_i32(v: i32);\n+    fn emit_i16(v: i16);\n+    fn emit_i8(v: i8);\n+    fn emit_bool(v: bool);\n+    fn emit_float(v: float);\n+    fn emit_f64(v: f64);\n+    fn emit_f32(v: f32);\n+    fn emit_str(v: &str);\n+\n+    // Compound types:\n+    fn emit_enum(name: &str, f: fn());\n+    fn emit_enum_variant(v_name: &str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(idx: uint, f: fn());\n+    fn emit_vec(len: uint, f: fn());\n+    fn emit_vec_elt(idx: uint, f: fn());\n+    fn emit_box(f: fn());\n+    fn emit_uniq(f: fn());\n+    fn emit_rec(f: fn());\n+    fn emit_rec_field(f_name: &str, f_idx: uint, f: fn());\n+    fn emit_tup(sz: uint, f: fn());\n+    fn emit_tup_elt(idx: uint, f: fn());\n+}\n+\n+trait Deserializer {\n+    // Primitive types:\n+    fn read_nil() -> ();\n+    fn read_uint() -> uint;\n+    fn read_u64() -> u64;\n+    fn read_u32() -> u32;\n+    fn read_u16() -> u16;\n+    fn read_u8() -> u8;\n+    fn read_int() -> int;\n+    fn read_i64() -> i64;\n+    fn read_i32() -> i32;\n+    fn read_i16() -> i16;\n+    fn read_i8() -> i8;\n+    fn read_bool() -> bool;\n+    fn read_f64() -> f64;\n+    fn read_f32() -> f32;\n+    fn read_float() -> float;\n+    fn read_str() -> ~str;\n+\n+    // Compound types:\n+    fn read_enum<T>(name: ~str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T>(f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T>(idx: uint, f: fn() -> T) -> T;\n+    fn read_vec<T>(f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T;\n+    fn read_box<T>(f: fn() -> T) -> T;\n+    fn read_uniq<T>(f: fn() -> T) -> T;\n+    fn read_rec<T>(f: fn() -> T) -> T;\n+    fn read_rec_field<T>(f_name: ~str, f_idx: uint, f: fn() -> T) -> T;\n+    fn read_tup<T>(sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T>(idx: uint, f: fn() -> T) -> T;\n+}\n+\n+trait Serializable {\n+    fn serialize<S: Serializer>(s: S);\n+    static fn deserialize<D: Deserializer>(d: D) -> self;\n+}\n+\n+impl uint: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_uint(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> uint { d.read_uint() }\n+}\n+\n+impl u8: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_u8(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> u8 { d.read_u8() }\n+}\n+\n+impl u16: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_u16(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> u16 { d.read_u16() }\n+}\n+\n+impl u32: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_u32(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> u32 { d.read_u32() }\n+}\n+\n+impl u64: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_u64(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> u64 { d.read_u64() }\n+}\n+\n+impl int: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_int(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> int { d.read_int() }\n+}\n+\n+impl i8: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_i8(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> i8 { d.read_i8() }\n+}\n+\n+impl i16: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_i16(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> i16 { d.read_i16() }\n+}\n+\n+impl i32: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_i32(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> i32 { d.read_i32() }\n+}\n+\n+impl i64: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_i64(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> i64 { d.read_i64() }\n+}\n+\n+impl ~str: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_str(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> ~str { d.read_str() }\n+}\n+\n+impl float: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_float(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> float { d.read_float() }\n+}\n+\n+impl f32: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_f32(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> f32 { d.read_f32() }\n+}\n+\n+impl f64: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_f64(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> f64 { d.read_f64() }\n+}\n+\n+impl bool: Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_bool(self) }\n+    static fn deserialize<D: Deserializer>(d: D) -> bool { d.read_bool() }\n+}\n+\n+impl (): Serializable {\n+    fn serialize<S: Serializer>(s: S) { s.emit_nil() }\n+    static fn deserialize<D: Deserializer>(d: D) -> () { d.read_nil() }\n+}\n+\n+impl<T: Serializable> @T: Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        s.emit_box(|| (*self).serialize(s))\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> @T {\n+        d.read_box(|| @deserialize(d))\n+    }\n+}\n+\n+impl<T: Serializable> ~T: Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        s.emit_uniq(|| (*self).serialize(s))\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> ~T {\n+        d.read_uniq(|| ~deserialize(d))\n+    }\n+}\n+\n+impl<T: Serializable> ~[T]: Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        do s.emit_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> ~[T] {\n+        do d.read_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Serializable> Option<T>: Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        do s.emit_enum(~\"option\") {\n+            match self {\n+              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+              },\n+\n+              Some(v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+                s.emit_enum_variant_arg(0u, || v.serialize(s))\n+              }\n+            }\n+        }\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> Option<T> {\n+        do d.read_enum(~\"option\") {\n+            do d.read_enum_variant |i| {\n+                match i {\n+                  0 => None,\n+                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n+                  _ => fail(#fmt(\"Bad variant for option: %u\", i))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    T0: Serializable,\n+    T1: Serializable\n+> (T0, T1): Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        match self {\n+            (t0, t1) => {\n+                do s.emit_tup(2) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1) {\n+        do d.read_tup(2) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable\n+> (T0, T1, T2): Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        match self {\n+            (t0, t1, t2) => {\n+                do s.emit_tup(3) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1, T2) {\n+        do d.read_tup(3) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable,\n+    T3: Serializable\n+> (T0, T1, T2, T3): Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        match self {\n+            (t0, t1, t2, t3) => {\n+                do s.emit_tup(4) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1, T2, T3) {\n+        do d.read_tup(4) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable,\n+    T3: Serializable,\n+    T4: Serializable\n+> (T0, T1, T2, T3, T4): Serializable {\n+    fn serialize<S: Serializer>(s: S) {\n+        match self {\n+            (t0, t1, t2, t3, t4) => {\n+                do s.emit_tup(5) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                    s.emit_tup_elt(4, || t4.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+\n+    static fn deserialize<D: Deserializer>(d: D) -> (T0, T1, T2, T3, T4) {\n+        do d.read_tup(5) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d)),\n+                d.read_tup_elt(4, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n+\n+fn emit_from_vec<S: Serializer, T>(s: S, v: ~[T], f: fn(T)) {\n+    do s.emit_vec(v.len()) {\n+        for v.eachi |i, e| {\n+            do s.emit_vec_elt(i) {\n+                f(*e)\n+            }\n+        }\n+    }\n+}\n+\n+fn read_to_vec<D: Deserializer, T: Copy>(d: D, f: fn() -> T) -> ~[T] {\n+    do d.read_vec |len| {\n+        do vec::from_fn(len) |i| {\n+            d.read_vec_elt(i, || f())\n+        }\n+    }\n+}\n+\n+trait SerializerHelpers {\n+    fn emit_from_vec<T>(v: ~[T], f: fn(T));\n+}\n+\n+impl<S: Serializer> S: SerializerHelpers {\n+    fn emit_from_vec<T>(v: ~[T], f: fn(T)) {\n+        emit_from_vec(self, v, f)\n+    }\n+}\n+\n+trait DeserializerHelpers {\n+    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T];\n+}\n+\n+impl<D: Deserializer> D: DeserializerHelpers {\n+    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T] {\n+        read_to_vec(self, f)\n+    }\n+}"}, {"sha": "5979b98478fc162424a0f998be83ffcc19c1f5a8", "filename": "src/libstd/std.rc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/780b23af73540dad0ec78488949bbcd380efd71e/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/780b23af73540dad0ec78488949bbcd380efd71e/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=780b23af73540dad0ec78488949bbcd380efd71e", "patch": "@@ -35,7 +35,7 @@ export bitv, deque, fun_treemap, list, map;\n export smallintmap, sort, treemap;\n export rope, arena, par;\n export ebml, dbg, getopts, json, rand, sha1, term, time, prettyprint;\n-export test, tempfile, serialization;\n+export test, tempfile, serialization, serialization2;\n export cmp;\n export base64;\n export cell;\n@@ -144,6 +144,8 @@ mod unicode;\n mod test;\n #[legacy_exports]\n mod serialization;\n+#[legacy_exports]\n+mod serialization2;\n \n // Local Variables:\n // mode: rust;"}]}