{"sha": "6b7b09d329c174590a52ba570e20def528ea216a", "node_id": "C_kwDOAAsO6NoAKDZiN2IwOWQzMjljMTc0NTkwYTUyYmE1NzBlMjBkZWY1MjhlYTIxNmE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-01T19:31:04Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-02T22:44:23Z"}, "message": "internal: Record unresolved derive invocations in hir", "tree": {"sha": "0aca355c765ba3bd452401a29a8f13408899faa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aca355c765ba3bd452401a29a8f13408899faa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b7b09d329c174590a52ba570e20def528ea216a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b7b09d329c174590a52ba570e20def528ea216a", "html_url": "https://github.com/rust-lang/rust/commit/6b7b09d329c174590a52ba570e20def528ea216a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b7b09d329c174590a52ba570e20def528ea216a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989c06b25d7e9d5c10ce77831952cab7359d6ab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/989c06b25d7e9d5c10ce77831952cab7359d6ab2", "html_url": "https://github.com/rust-lang/rust/commit/989c06b25d7e9d5c10ce77831952cab7359d6ab2"}], "stats": {"total": 139, "additions": 87, "deletions": 52}, "files": [{"sha": "077ab40d08151cb1d136b0f9b38887504771debb", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -18,13 +18,14 @@ use smallvec::{smallvec, SmallVec};\n use syntax::{\n     algo::skip_trivia_token,\n     ast::{self, HasAttrs, HasGenericParams, HasLoopBody},\n-    match_ast, AstNode, Direction, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextSize,\n+    match_ast, AstNode, AstToken, Direction, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken,\n+    TextSize, T,\n };\n \n use crate::{\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, resolve_hir_path_as_macro, SourceAnalyzer},\n+    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     Access, AssocItem, BuiltinAttr, Callable, ConstParam, Crate, Field, Function, HasSource,\n     HirFileId, Impl, InFile, Label, LifetimeParam, Local, MacroDef, Module, ModuleDef, Name, Path,\n     ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n@@ -354,6 +355,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n \n+    pub fn resolve_derive_ident(&self, ident: &ast::Ident) -> Option<PathResolution> {\n+        self.imp.resolve_derive_ident(ident)\n+    }\n+\n     // FIXME: use this instead?\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n@@ -894,6 +899,64 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n \n+    fn resolve_derive_ident(&self, ident: &ast::Ident) -> Option<PathResolution> {\n+        // derive macros are always at depth 2, tokentree -> meta -> attribute\n+        let syntax = ident.syntax();\n+        let attr = syntax.ancestors().nth(2).and_then(ast::Attr::cast)?;\n+\n+        let tt = attr.token_tree()?;\n+        if !tt.syntax().text_range().contains_range(ident.syntax().text_range()) {\n+            return None;\n+        }\n+\n+        // Fetch hir::Attr definition\n+        // FIXME: Move this to ToDef impl?\n+        let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+        let attr_pos = adt.attrs().position(|it| it == attr)?;\n+        let attrs = {\n+            let file_id = self.find_file(adt.syntax()).file_id;\n+            let adt = InFile::new(file_id, adt);\n+            let def = self.with_ctx(|ctx| ctx.adt_to_def(adt))?;\n+            self.db.attrs(def.into())\n+        };\n+        let attr_def = attrs.get(attr_pos)?;\n+\n+        let mut derive_paths = attr_def.parse_path_comma_token_tree()?;\n+        let derives = self.resolve_derive_macro(&attr)?;\n+\n+        let derive_idx = tt\n+            .syntax()\n+            .children_with_tokens()\n+            .filter_map(SyntaxElement::into_token)\n+            .take_while(|tok| tok != syntax)\n+            .filter(|t| t.kind() == T![,])\n+            .count();\n+        let path_segment_idx = syntax\n+            .siblings_with_tokens(Direction::Prev)\n+            .filter_map(SyntaxElement::into_token)\n+            .take_while(|tok| matches!(tok.kind(), T![:] | T![ident]))\n+            .filter(|tok| tok.kind() == T![ident])\n+            .count();\n+\n+        let mut mod_path = derive_paths.nth(derive_idx)?;\n+\n+        if path_segment_idx < mod_path.len() {\n+            // the path for the given ident is a qualifier, resolve to module if possible\n+            while path_segment_idx < mod_path.len() {\n+                mod_path.pop_segment();\n+            }\n+            resolve_hir_path(\n+                self.db,\n+                &self.scope(attr.syntax()).resolver,\n+                &Path::from_known_path(mod_path, []),\n+            )\n+            .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_))))\n+        } else {\n+            // otherwise fetch the derive\n+            derives.get(derive_idx)?.map(PathResolution::Macro)\n+        }\n+    }\n+\n     fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.analyze(literal.syntax())\n             .record_literal_missing_fields(self.db, literal)\n@@ -1230,14 +1293,4 @@ impl<'a> SemanticsScope<'a> {\n         let path = Path::from_src(path.clone(), &ctx)?;\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }\n-\n-    /// Resolve a path as-if it was written at the given scope. This is\n-    /// necessary a heuristic, as it doesn't take hygiene into account.\n-    // FIXME: This special casing solely exists for attributes for now\n-    // ideally we should have a path resolution infra that properly knows about overlapping namespaces\n-    pub fn speculative_resolve_as_mac(&self, path: &ast::Path) -> Option<MacroDef> {\n-        let ctx = body::LowerCtx::new(self.db.upcast(), self.file_id);\n-        let path = Path::from_src(path.clone(), &ctx)?;\n-        resolve_hir_path_as_macro(self.db, &self.resolver, &path)\n-    }\n }"}, {"sha": "c63cd4c195bfe55f32cdae9547b45d85623bb08b", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -720,11 +720,8 @@ impl Attr {\n         Self::from_src(db, ast, hygiene, id)\n     }\n \n-    /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths\n-    /// to derive macros.\n-    ///\n-    /// Returns `None` when the attribute does not have a well-formed `#[derive]` attribute input.\n-    pub(crate) fn parse_derive(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+    /// Parses this attribute as a token tree consisting of comma separated paths.\n+    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n         let args = match self.input.as_deref() {\n             Some(AttrInput::TokenTree(args, _)) => args,\n             _ => return None,"}, {"sha": "be749c3b46f4420fbce717a3a3ded8b0d20e95c8", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -1145,7 +1145,7 @@ impl DefCollector<'_> {\n                             }\n                         }\n \n-                        match attr.parse_derive() {\n+                        match attr.parse_path_comma_token_tree() {\n                             Some(derive_macros) => {\n                                 let mut len = 0;\n                                 for (idx, path) in derive_macros.enumerate() {"}, {"sha": "4d638e687ae35d0f7c199eacf38cfc58b78190bc", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -1381,6 +1381,18 @@ mod foo {\n            // ^^^^\n }\n #[derive(foo::Copy$0)]\n+struct Foo;\n+            \"#,\n+        );\n+        check(\n+            r#\"\n+//- minicore:derive\n+mod foo {\n+ // ^^^\n+    #[rustc_builtin_macro]\n+    pub macro Copy {}\n+}\n+#[derive(foo$0::Copy)]\n struct Foo;\n             \"#,\n         );"}, {"sha": "f82ccaa1c7648ab0775a0f50ecf2d23670e171e5", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -3,7 +3,7 @@\n use hir::{AsAssocItem, HasVisibility, Semantics};\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n-    helpers::{try_resolve_derive_input, FamousDefs},\n+    helpers::FamousDefs,\n     RootDatabase, SymbolKind,\n };\n use rustc_hash::FxHashMap;\n@@ -40,13 +40,8 @@ pub(super) fn token(\n         BYTE => HlTag::ByteLiteral.into(),\n         CHAR => HlTag::CharLiteral.into(),\n         IDENT if parent_matches::<ast::TokenTree>(&token) => {\n-            match token.ancestors().nth(2).and_then(ast::Attr::cast) {\n-                Some(attr) => {\n-                    match try_resolve_derive_input(sema, &attr, &ast::Ident::cast(token).unwrap()) {\n-                        Some(res) => highlight_def(sema, krate, Definition::from(res)),\n-                        None => HlTag::None.into(),\n-                    }\n-                }\n+            match sema.resolve_derive_ident(&ast::Ident::cast(token).unwrap()) {\n+                Some(res) => highlight_def(sema, krate, Definition::from(res)),\n                 None => HlTag::None.into(),\n             }\n         }"}, {"sha": "d69fd9bd2170dfc190875c45441a0b3d2b05c7ab", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -17,7 +17,7 @@ use syntax::{\n     match_ast, AstToken, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n \n-use crate::{helpers::try_resolve_derive_input, RootDatabase};\n+use crate::RootDatabase;\n \n // FIXME: a more precise name would probably be `Symbol`?\n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -55,11 +55,8 @@ impl Definition {\n             let attr = ast::TokenTree::cast(parent.clone())\n                 .and_then(|tt| tt.parent_meta())\n                 .and_then(|meta| meta.parent_attr());\n-            if let Some(attr) = attr {\n-                return try_resolve_derive_input(&sema, &attr, &ident)\n-                    .map(Into::into)\n-                    .into_iter()\n-                    .collect();\n+            if let Some(_) = attr {\n+                return sema.resolve_derive_ident(&ident).map(Into::into).into_iter().collect();\n             }\n         }\n         Self::from_node(sema, &parent)"}, {"sha": "344f8db8d00a7569d6a3cf8064fce49cb7455eda", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -74,26 +74,6 @@ pub fn get_path_at_cursor_in_tt(cursor: &ast::Ident) -> Option<ast::Path> {\n         })\n }\n \n-/// Parses and resolves the path at the cursor position in the given attribute, if it is a derive.\n-/// This special case is required because the derive macro is a compiler builtin that discards the input derives.\n-pub fn try_resolve_derive_input(\n-    sema: &hir::Semantics<RootDatabase>,\n-    attr: &ast::Attr,\n-    cursor: &ast::Ident,\n-) -> Option<PathResolution> {\n-    let path = get_path_in_derive_attr(sema, attr, cursor)?;\n-    let scope = sema.scope(attr.syntax());\n-    // FIXME: This double resolve shouldn't be necessary\n-    // It's only here so we prefer macros over other namespaces\n-    match scope.speculative_resolve_as_mac(&path) {\n-        Some(mac) if mac.kind() == hir::MacroKind::Derive => Some(PathResolution::Macro(mac)),\n-        Some(_) => return None,\n-        None => scope\n-            .speculative_resolve(&path)\n-            .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_)))),\n-    }\n-}\n-\n /// Picks the token with the highest rank returned by the passed in function.\n pub fn pick_best_token(\n     tokens: TokenAtOffset<SyntaxToken>,"}, {"sha": "2356750bceb86c16f1c4a3bcd53cf595ba56962d", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b7b09d329c174590a52ba570e20def528ea216a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=6b7b09d329c174590a52ba570e20def528ea216a", "patch": "@@ -146,6 +146,7 @@ impl ImportAssets {\n         if let Some(_) = path.qualifier() {\n             return None;\n         }\n+\n         let name = NameToImport::exact_case_sensitive(path.segment()?.name_ref()?.to_string());\n         let candidate_node = attr.syntax().clone();\n         Some(Self {"}]}