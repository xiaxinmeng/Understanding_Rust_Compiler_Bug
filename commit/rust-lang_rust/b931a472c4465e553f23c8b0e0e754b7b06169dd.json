{"sha": "b931a472c4465e553f23c8b0e0e754b7b06169dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MzFhNDcyYzQ0NjVlNTUzZjIzYzhiMGUwZTc1NGI3YjA2MTY5ZGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-20T20:52:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-20T20:52:55Z"}, "message": "move extend selection from ra_ide_api_light to ra_ide_api", "tree": {"sha": "748877a47b9a94d65d40037fbcf0d6be375569ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748877a47b9a94d65d40037fbcf0d6be375569ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b931a472c4465e553f23c8b0e0e754b7b06169dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b931a472c4465e553f23c8b0e0e754b7b06169dd", "html_url": "https://github.com/rust-lang/rust/commit/b931a472c4465e553f23c8b0e0e754b7b06169dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b931a472c4465e553f23c8b0e0e754b7b06169dd/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eb56f7a6aab1e9814cb901c8cd90c2b4b3138af", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb56f7a6aab1e9814cb901c8cd90c2b4b3138af", "html_url": "https://github.com/rust-lang/rust/commit/3eb56f7a6aab1e9814cb901c8cd90c2b4b3138af"}], "stats": {"total": 804, "additions": 403, "deletions": 401}, "files": [{"sha": "eef6fa621da0c3b96361f6d131b08c31d8c4fd28", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b931a472c4465e553f23c8b0e0e754b7b06169dd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b931a472c4465e553f23c8b0e0e754b7b06169dd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b931a472c4465e553f23c8b0e0e754b7b06169dd", "patch": "@@ -945,6 +945,7 @@ dependencies = [\n  \"ra_batch 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n+ \"ra_ide_api 0.1.0\",\n  \"ra_ide_api_light 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"tools 0.1.0\","}, {"sha": "4c666f5569dbcc418d8408eae53bbe690b664a36", "filename": "crates/ra_cli/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2FCargo.toml?ref=b931a472c4465e553f23c8b0e0e754b7b06169dd", "patch": "@@ -13,6 +13,7 @@ flexi_logger = \"0.11.0\"\n indicatif = \"0.11.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n+ra_ide_api = { path = \"../ra_ide_api\" }\n ra_ide_api_light = { path = \"../ra_ide_api_light\" }\n tools = { path = \"../tools\" }\n ra_batch = { path = \"../ra_batch\" }"}, {"sha": "5285f1f28e901053e6f73d346f44be328097d716", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=b931a472c4465e553f23c8b0e0e754b7b06169dd", "patch": "@@ -4,7 +4,8 @@ use std::{fs, io::Read, path::Path, time::Instant};\n \n use clap::{App, Arg, SubCommand};\n use join_to_string::join;\n-use ra_ide_api_light::{extend_selection, file_structure};\n+use ra_ide_api::{Analysis, FileRange};\n+use ra_ide_api_light::file_structure;\n use ra_syntax::{SourceFile, TextRange, TreeArc, AstNode};\n use tools::collect_tests;\n use flexi_logger::Logger;\n@@ -59,8 +60,8 @@ fn main() -> Result<()> {\n         (\"extend-selection\", Some(matches)) => {\n             let start: u32 = matches.value_of(\"start\").unwrap().parse()?;\n             let end: u32 = matches.value_of(\"end\").unwrap().parse()?;\n-            let file = file()?;\n-            let sels = selections(&file, start, end);\n+            let text = read_stdin()?;\n+            let sels = selections(text, start, end);\n             println!(\"{}\", sels)\n         }\n         (\"analysis-stats\", Some(matches)) => {\n@@ -98,12 +99,17 @@ fn render_test(file: &Path, line: usize) -> Result<(String, String)> {\n     Ok((test.text, tree))\n }\n \n-fn selections(file: &SourceFile, start: u32, end: u32) -> String {\n+fn selections(text: String, start: u32, end: u32) -> String {\n+    let (analysis, file_id) = Analysis::from_single_file(text);\n     let mut ranges = Vec::new();\n-    let mut cur = Some(TextRange::from_to((start - 1).into(), (end - 1).into()));\n-    while let Some(r) = cur {\n-        ranges.push(r);\n-        cur = extend_selection(file.syntax(), r);\n+    let mut range = TextRange::from_to((start - 1).into(), (end - 1).into());\n+    loop {\n+        ranges.push(range);\n+        let next = analysis.extend_selection(FileRange { file_id, range }).unwrap();\n+        if range == next {\n+            break;\n+        }\n+        range = next;\n     }\n     let ranges = ranges\n         .iter()"}, {"sha": "63879a0b5466631e912522b0c2f7db8ffebde174", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 371, "deletions": 6, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=b931a472c4465e553f23c8b0e0e754b7b06169dd", "patch": "@@ -1,13 +1,378 @@\n use ra_db::SourceDatabase;\n-use ra_syntax::AstNode;\n-\n-use crate::{\n-    TextRange, FileRange,\n-    db::RootDatabase,\n+use ra_syntax::{\n+    Direction, SyntaxNode, TextRange, TextUnit, AstNode,\n+    algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n+    SyntaxKind::*,\n };\n \n+use crate::{FileRange, db::RootDatabase};\n+\n // FIXME: restore macro support\n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n     let source_file = db.parse(frange.file_id);\n-    ra_ide_api_light::extend_selection(source_file.syntax(), frange.range).unwrap_or(frange.range)\n+    try_extend_selection(source_file.syntax(), frange.range).unwrap_or(frange.range)\n+}\n+\n+fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange> {\n+    let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n+    let list_kinds = [\n+        FIELD_PAT_LIST,\n+        MATCH_ARM_LIST,\n+        NAMED_FIELD_DEF_LIST,\n+        POS_FIELD_DEF_LIST,\n+        NAMED_FIELD_LIST,\n+        ENUM_VARIANT_LIST,\n+        USE_TREE_LIST,\n+        TYPE_PARAM_LIST,\n+        TYPE_ARG_LIST,\n+        PARAM_LIST,\n+        ARG_LIST,\n+        ARRAY_EXPR,\n+    ];\n+\n+    if range.is_empty() {\n+        let offset = range.start();\n+        let mut leaves = find_leaf_at_offset(root, offset);\n+        if leaves.clone().all(|it| it.kind() == WHITESPACE) {\n+            return Some(extend_ws(root, leaves.next()?, offset));\n+        }\n+        let leaf_range = match leaves {\n+            LeafAtOffset::None => return None,\n+            LeafAtOffset::Single(l) => {\n+                if string_kinds.contains(&l.kind()) {\n+                    extend_single_word_in_comment_or_string(l, offset).unwrap_or_else(|| l.range())\n+                } else {\n+                    l.range()\n+                }\n+            }\n+            LeafAtOffset::Between(l, r) => pick_best(l, r).range(),\n+        };\n+        return Some(leaf_range);\n+    };\n+    let node = find_covering_node(root, range);\n+\n+    // Using shallowest node with same range allows us to traverse siblings.\n+    let node = node.ancestors().take_while(|n| n.range() == node.range()).last().unwrap();\n+\n+    if range == node.range() {\n+        if string_kinds.contains(&node.kind()) {\n+            if let Some(range) = extend_comments(node) {\n+                return Some(range);\n+            }\n+        }\n+\n+        if node.parent().map(|n| list_kinds.contains(&n.kind())) == Some(true) {\n+            if let Some(range) = extend_list_item(node) {\n+                return Some(range);\n+            }\n+        }\n+    }\n+\n+    match node.ancestors().skip_while(|n| n.range() == range).next() {\n+        None => None,\n+        Some(parent) => Some(parent.range()),\n+    }\n+}\n+\n+fn extend_single_word_in_comment_or_string(\n+    leaf: &SyntaxNode,\n+    offset: TextUnit,\n+) -> Option<TextRange> {\n+    let text: &str = leaf.leaf_text()?;\n+    let cursor_position: u32 = (offset - leaf.range().start()).into();\n+\n+    let (before, after) = text.split_at(cursor_position as usize);\n+\n+    fn non_word_char(c: char) -> bool {\n+        !(c.is_alphanumeric() || c == '_')\n+    }\n+\n+    let start_idx = before.rfind(non_word_char)? as u32;\n+    let end_idx = after.find(non_word_char).unwrap_or(after.len()) as u32;\n+\n+    let from: TextUnit = (start_idx + 1).into();\n+    let to: TextUnit = (cursor_position + end_idx).into();\n+\n+    let range = TextRange::from_to(from, to);\n+    if range.is_empty() {\n+        None\n+    } else {\n+        Some(range + leaf.range().start())\n+    }\n+}\n+\n+fn extend_ws(root: &SyntaxNode, ws: &SyntaxNode, offset: TextUnit) -> TextRange {\n+    let ws_text = ws.leaf_text().unwrap();\n+    let suffix = TextRange::from_to(offset, ws.range().end()) - ws.range().start();\n+    let prefix = TextRange::from_to(ws.range().start(), offset) - ws.range().start();\n+    let ws_suffix = &ws_text.as_str()[suffix];\n+    let ws_prefix = &ws_text.as_str()[prefix];\n+    if ws_text.contains('\\n') && !ws_suffix.contains('\\n') {\n+        if let Some(node) = ws.next_sibling() {\n+            let start = match ws_prefix.rfind('\\n') {\n+                Some(idx) => ws.range().start() + TextUnit::from((idx + 1) as u32),\n+                None => node.range().start(),\n+            };\n+            let end = if root.text().char_at(node.range().end()) == Some('\\n') {\n+                node.range().end() + TextUnit::of_char('\\n')\n+            } else {\n+                node.range().end()\n+            };\n+            return TextRange::from_to(start, end);\n+        }\n+    }\n+    ws.range()\n+}\n+\n+fn pick_best<'a>(l: &'a SyntaxNode, r: &'a SyntaxNode) -> &'a SyntaxNode {\n+    return if priority(r) > priority(l) { r } else { l };\n+    fn priority(n: &SyntaxNode) -> usize {\n+        match n.kind() {\n+            WHITESPACE => 0,\n+            IDENT | SELF_KW | SUPER_KW | CRATE_KW | LIFETIME => 2,\n+            _ => 1,\n+        }\n+    }\n+}\n+\n+/// Extend list item selection to include nearby comma and whitespace.\n+fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n+    fn is_single_line_ws(node: &SyntaxNode) -> bool {\n+        node.kind() == WHITESPACE && !node.leaf_text().unwrap().contains('\\n')\n+    }\n+\n+    fn nearby_comma(node: &SyntaxNode, dir: Direction) -> Option<&SyntaxNode> {\n+        node.siblings(dir)\n+            .skip(1)\n+            .skip_while(|node| is_single_line_ws(node))\n+            .next()\n+            .filter(|node| node.kind() == COMMA)\n+    }\n+\n+    if let Some(comma_node) = nearby_comma(node, Direction::Prev) {\n+        return Some(TextRange::from_to(comma_node.range().start(), node.range().end()));\n+    }\n+\n+    if let Some(comma_node) = nearby_comma(node, Direction::Next) {\n+        // Include any following whitespace when comma if after list item.\n+        let final_node = comma_node\n+            .siblings(Direction::Next)\n+            .skip(1)\n+            .next()\n+            .filter(|node| is_single_line_ws(node))\n+            .unwrap_or(comma_node);\n+\n+        return Some(TextRange::from_to(node.range().start(), final_node.range().end()));\n+    }\n+\n+    return None;\n+}\n+\n+fn extend_comments(node: &SyntaxNode) -> Option<TextRange> {\n+    let prev = adj_comments(node, Direction::Prev);\n+    let next = adj_comments(node, Direction::Next);\n+    if prev != next {\n+        Some(TextRange::from_to(prev.range().start(), next.range().end()))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn adj_comments(node: &SyntaxNode, dir: Direction) -> &SyntaxNode {\n+    let mut res = node;\n+    for node in node.siblings(dir) {\n+        match node.kind() {\n+            COMMENT => res = node,\n+            WHITESPACE if !node.leaf_text().unwrap().as_str().contains(\"\\n\\n\") => (),\n+            _ => break,\n+        }\n+    }\n+    res\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::{SourceFile, AstNode};\n+    use test_utils::extract_offset;\n+\n+    use super::*;\n+\n+    fn do_check(before: &str, afters: &[&str]) {\n+        let (cursor, before) = extract_offset(before);\n+        let file = SourceFile::parse(&before);\n+        let mut range = TextRange::offset_len(cursor, 0.into());\n+        for &after in afters {\n+            range = try_extend_selection(file.syntax(), range).unwrap();\n+            let actual = &before[range];\n+            assert_eq!(after, actual);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_arith() {\n+        do_check(r#\"fn foo() { <|>1 + 1 }\"#, &[\"1\", \"1 + 1\", \"{ 1 + 1 }\"]);\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_list() {\n+        do_check(r#\"fn foo(<|>x: i32) {}\"#, &[\"x\", \"x: i32\"]);\n+        do_check(r#\"fn foo(<|>x: i32, y: i32) {}\"#, &[\"x\", \"x: i32\", \"x: i32, \"]);\n+        do_check(r#\"fn foo(<|>x: i32,y: i32) {}\"#, &[\"x\", \"x: i32\", \"x: i32,\"]);\n+        do_check(r#\"fn foo(x: i32, <|>y: i32) {}\"#, &[\"y\", \"y: i32\", \", y: i32\"]);\n+        do_check(r#\"fn foo(x: i32, <|>y: i32, ) {}\"#, &[\"y\", \"y: i32\", \", y: i32\"]);\n+        do_check(r#\"fn foo(x: i32,<|>y: i32) {}\"#, &[\"y\", \"y: i32\", \",y: i32\"]);\n+\n+        do_check(r#\"const FOO: [usize; 2] = [ 22<|> , 33];\"#, &[\"22\", \"22 , \"]);\n+        do_check(r#\"const FOO: [usize; 2] = [ 22 , 33<|>];\"#, &[\"33\", \", 33\"]);\n+        do_check(r#\"const FOO: [usize; 2] = [ 22 , 33<|> ,];\"#, &[\"33\", \", 33\"]);\n+\n+        do_check(\n+            r#\"\n+const FOO: [usize; 2] = [\n+    22,\n+    <|>33,\n+]\"#,\n+            &[\"33\", \"33,\"],\n+        );\n+\n+        do_check(\n+            r#\"\n+const FOO: [usize; 2] = [\n+    22\n+    , 33<|>,\n+]\"#,\n+            &[\"33\", \", 33\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_start_of_the_line() {\n+        do_check(\n+            r#\"\n+impl S {\n+<|>    fn foo() {\n+\n+    }\n+}\"#,\n+            &[\"    fn foo() {\\n\\n    }\\n\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_doc_comments() {\n+        do_check(\n+            r#\"\n+struct A;\n+\n+/// bla\n+/// bla\n+struct B {\n+    <|>\n+}\n+            \"#,\n+            &[\"\\n    \\n\", \"{\\n    \\n}\", \"/// bla\\n/// bla\\nstruct B {\\n    \\n}\"],\n+        )\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_comments() {\n+        do_check(\n+            r#\"\n+fn bar(){}\n+\n+// fn foo() {\n+// 1 + <|>1\n+// }\n+\n+// fn foo(){}\n+    \"#,\n+            &[\"1\", \"// 1 + 1\", \"// fn foo() {\\n// 1 + 1\\n// }\"],\n+        );\n+\n+        do_check(\n+            r#\"\n+// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+// pub enum Direction {\n+//  <|>   Next,\n+//     Prev\n+// }\n+\"#,\n+            &[\n+                \"//     Next,\",\n+                \"// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\\n// pub enum Direction {\\n//     Next,\\n//     Prev\\n// }\",\n+            ],\n+        );\n+\n+        do_check(\n+            r#\"\n+/*\n+foo\n+_bar1<|>*/\n+    \"#,\n+            &[\"_bar1\", \"/*\\nfoo\\n_bar1*/\"],\n+        );\n+\n+        do_check(\n+            r#\"\n+//!<|>foo_2 bar\n+    \"#,\n+            &[\"foo_2\", \"//!foo_2 bar\"],\n+        );\n+\n+        do_check(\n+            r#\"\n+/<|>/foo bar\n+    \"#,\n+            &[\"//foo bar\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_prefer_idents() {\n+        do_check(\n+            r#\"\n+fn main() { foo<|>+bar;}\n+    \"#,\n+            &[\"foo\", \"foo+bar\"],\n+        );\n+        do_check(\n+            r#\"\n+fn main() { foo+<|>bar;}\n+    \"#,\n+            &[\"bar\", \"foo+bar\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_prefer_lifetimes() {\n+        do_check(r#\"fn foo<<|>'a>() {}\"#, &[\"'a\", \"<'a>\"]);\n+        do_check(r#\"fn foo<'a<|>>() {}\"#, &[\"'a\", \"<'a>\"]);\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_select_first_word() {\n+        do_check(r#\"// foo bar b<|>az quxx\"#, &[\"baz\", \"// foo bar baz quxx\"]);\n+        do_check(\n+            r#\"\n+impl S {\n+    fn foo() {\n+        // hel<|>lo world\n+    }\n+}\n+        \"#,\n+            &[\"hello\", \"// hello world\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_string() {\n+        do_check(\n+            r#\"\n+fn bar(){}\n+\n+\" fn f<|>oo() {\"\n+    \"#,\n+            &[\"foo\", \"\\\" fn foo() {\\\"\"],\n+        );\n+    }\n }"}, {"sha": "28d62f290559df08af83e729c386670906223b93", "filename": "crates/ra_ide_api_light/src/extend_selection.rs", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/3eb56f7a6aab1e9814cb901c8cd90c2b4b3138af/crates%2Fra_ide_api_light%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb56f7a6aab1e9814cb901c8cd90c2b4b3138af/crates%2Fra_ide_api_light%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fextend_selection.rs?ref=3eb56f7a6aab1e9814cb901c8cd90c2b4b3138af", "patch": "@@ -1,369 +0,0 @@\n-use ra_syntax::{\n-    Direction, SyntaxNode, TextRange, TextUnit,\n-    algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n-    SyntaxKind::*,\n-};\n-\n-pub fn extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange> {\n-    let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n-    let list_kinds = [\n-        FIELD_PAT_LIST,\n-        MATCH_ARM_LIST,\n-        NAMED_FIELD_DEF_LIST,\n-        POS_FIELD_DEF_LIST,\n-        NAMED_FIELD_LIST,\n-        ENUM_VARIANT_LIST,\n-        USE_TREE_LIST,\n-        TYPE_PARAM_LIST,\n-        TYPE_ARG_LIST,\n-        PARAM_LIST,\n-        ARG_LIST,\n-        ARRAY_EXPR,\n-    ];\n-\n-    if range.is_empty() {\n-        let offset = range.start();\n-        let mut leaves = find_leaf_at_offset(root, offset);\n-        if leaves.clone().all(|it| it.kind() == WHITESPACE) {\n-            return Some(extend_ws(root, leaves.next()?, offset));\n-        }\n-        let leaf_range = match leaves {\n-            LeafAtOffset::None => return None,\n-            LeafAtOffset::Single(l) => {\n-                if string_kinds.contains(&l.kind()) {\n-                    extend_single_word_in_comment_or_string(l, offset).unwrap_or_else(|| l.range())\n-                } else {\n-                    l.range()\n-                }\n-            }\n-            LeafAtOffset::Between(l, r) => pick_best(l, r).range(),\n-        };\n-        return Some(leaf_range);\n-    };\n-    let node = find_covering_node(root, range);\n-\n-    // Using shallowest node with same range allows us to traverse siblings.\n-    let node = node.ancestors().take_while(|n| n.range() == node.range()).last().unwrap();\n-\n-    if range == node.range() {\n-        if string_kinds.contains(&node.kind()) {\n-            if let Some(range) = extend_comments(node) {\n-                return Some(range);\n-            }\n-        }\n-\n-        if node.parent().map(|n| list_kinds.contains(&n.kind())) == Some(true) {\n-            if let Some(range) = extend_list_item(node) {\n-                return Some(range);\n-            }\n-        }\n-    }\n-\n-    match node.ancestors().skip_while(|n| n.range() == range).next() {\n-        None => None,\n-        Some(parent) => Some(parent.range()),\n-    }\n-}\n-\n-fn extend_single_word_in_comment_or_string(\n-    leaf: &SyntaxNode,\n-    offset: TextUnit,\n-) -> Option<TextRange> {\n-    let text: &str = leaf.leaf_text()?;\n-    let cursor_position: u32 = (offset - leaf.range().start()).into();\n-\n-    let (before, after) = text.split_at(cursor_position as usize);\n-\n-    fn non_word_char(c: char) -> bool {\n-        !(c.is_alphanumeric() || c == '_')\n-    }\n-\n-    let start_idx = before.rfind(non_word_char)? as u32;\n-    let end_idx = after.find(non_word_char).unwrap_or(after.len()) as u32;\n-\n-    let from: TextUnit = (start_idx + 1).into();\n-    let to: TextUnit = (cursor_position + end_idx).into();\n-\n-    let range = TextRange::from_to(from, to);\n-    if range.is_empty() {\n-        None\n-    } else {\n-        Some(range + leaf.range().start())\n-    }\n-}\n-\n-fn extend_ws(root: &SyntaxNode, ws: &SyntaxNode, offset: TextUnit) -> TextRange {\n-    let ws_text = ws.leaf_text().unwrap();\n-    let suffix = TextRange::from_to(offset, ws.range().end()) - ws.range().start();\n-    let prefix = TextRange::from_to(ws.range().start(), offset) - ws.range().start();\n-    let ws_suffix = &ws_text.as_str()[suffix];\n-    let ws_prefix = &ws_text.as_str()[prefix];\n-    if ws_text.contains('\\n') && !ws_suffix.contains('\\n') {\n-        if let Some(node) = ws.next_sibling() {\n-            let start = match ws_prefix.rfind('\\n') {\n-                Some(idx) => ws.range().start() + TextUnit::from((idx + 1) as u32),\n-                None => node.range().start(),\n-            };\n-            let end = if root.text().char_at(node.range().end()) == Some('\\n') {\n-                node.range().end() + TextUnit::of_char('\\n')\n-            } else {\n-                node.range().end()\n-            };\n-            return TextRange::from_to(start, end);\n-        }\n-    }\n-    ws.range()\n-}\n-\n-fn pick_best<'a>(l: &'a SyntaxNode, r: &'a SyntaxNode) -> &'a SyntaxNode {\n-    return if priority(r) > priority(l) { r } else { l };\n-    fn priority(n: &SyntaxNode) -> usize {\n-        match n.kind() {\n-            WHITESPACE => 0,\n-            IDENT | SELF_KW | SUPER_KW | CRATE_KW | LIFETIME => 2,\n-            _ => 1,\n-        }\n-    }\n-}\n-\n-/// Extend list item selection to include nearby comma and whitespace.\n-fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n-    fn is_single_line_ws(node: &SyntaxNode) -> bool {\n-        node.kind() == WHITESPACE && !node.leaf_text().unwrap().contains('\\n')\n-    }\n-\n-    fn nearby_comma(node: &SyntaxNode, dir: Direction) -> Option<&SyntaxNode> {\n-        node.siblings(dir)\n-            .skip(1)\n-            .skip_while(|node| is_single_line_ws(node))\n-            .next()\n-            .filter(|node| node.kind() == COMMA)\n-    }\n-\n-    if let Some(comma_node) = nearby_comma(node, Direction::Prev) {\n-        return Some(TextRange::from_to(comma_node.range().start(), node.range().end()));\n-    }\n-\n-    if let Some(comma_node) = nearby_comma(node, Direction::Next) {\n-        // Include any following whitespace when comma if after list item.\n-        let final_node = comma_node\n-            .siblings(Direction::Next)\n-            .skip(1)\n-            .next()\n-            .filter(|node| is_single_line_ws(node))\n-            .unwrap_or(comma_node);\n-\n-        return Some(TextRange::from_to(node.range().start(), final_node.range().end()));\n-    }\n-\n-    return None;\n-}\n-\n-fn extend_comments(node: &SyntaxNode) -> Option<TextRange> {\n-    let prev = adj_comments(node, Direction::Prev);\n-    let next = adj_comments(node, Direction::Next);\n-    if prev != next {\n-        Some(TextRange::from_to(prev.range().start(), next.range().end()))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn adj_comments(node: &SyntaxNode, dir: Direction) -> &SyntaxNode {\n-    let mut res = node;\n-    for node in node.siblings(dir) {\n-        match node.kind() {\n-            COMMENT => res = node,\n-            WHITESPACE if !node.leaf_text().unwrap().as_str().contains(\"\\n\\n\") => (),\n-            _ => break,\n-        }\n-    }\n-    res\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_syntax::{SourceFile, AstNode};\n-    use test_utils::extract_offset;\n-\n-    use super::*;\n-\n-    fn do_check(before: &str, afters: &[&str]) {\n-        let (cursor, before) = extract_offset(before);\n-        let file = SourceFile::parse(&before);\n-        let mut range = TextRange::offset_len(cursor, 0.into());\n-        for &after in afters {\n-            range = extend_selection(file.syntax(), range).unwrap();\n-            let actual = &before[range];\n-            assert_eq!(after, actual);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_arith() {\n-        do_check(r#\"fn foo() { <|>1 + 1 }\"#, &[\"1\", \"1 + 1\", \"{ 1 + 1 }\"]);\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_list() {\n-        do_check(r#\"fn foo(<|>x: i32) {}\"#, &[\"x\", \"x: i32\"]);\n-        do_check(r#\"fn foo(<|>x: i32, y: i32) {}\"#, &[\"x\", \"x: i32\", \"x: i32, \"]);\n-        do_check(r#\"fn foo(<|>x: i32,y: i32) {}\"#, &[\"x\", \"x: i32\", \"x: i32,\"]);\n-        do_check(r#\"fn foo(x: i32, <|>y: i32) {}\"#, &[\"y\", \"y: i32\", \", y: i32\"]);\n-        do_check(r#\"fn foo(x: i32, <|>y: i32, ) {}\"#, &[\"y\", \"y: i32\", \", y: i32\"]);\n-        do_check(r#\"fn foo(x: i32,<|>y: i32) {}\"#, &[\"y\", \"y: i32\", \",y: i32\"]);\n-\n-        do_check(r#\"const FOO: [usize; 2] = [ 22<|> , 33];\"#, &[\"22\", \"22 , \"]);\n-        do_check(r#\"const FOO: [usize; 2] = [ 22 , 33<|>];\"#, &[\"33\", \", 33\"]);\n-        do_check(r#\"const FOO: [usize; 2] = [ 22 , 33<|> ,];\"#, &[\"33\", \", 33\"]);\n-\n-        do_check(\n-            r#\"\n-const FOO: [usize; 2] = [\n-    22,\n-    <|>33,\n-]\"#,\n-            &[\"33\", \"33,\"],\n-        );\n-\n-        do_check(\n-            r#\"\n-const FOO: [usize; 2] = [\n-    22\n-    , 33<|>,\n-]\"#,\n-            &[\"33\", \", 33\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_start_of_the_line() {\n-        do_check(\n-            r#\"\n-impl S {\n-<|>    fn foo() {\n-\n-    }\n-}\"#,\n-            &[\"    fn foo() {\\n\\n    }\\n\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_doc_comments() {\n-        do_check(\n-            r#\"\n-struct A;\n-\n-/// bla\n-/// bla\n-struct B {\n-    <|>\n-}\n-            \"#,\n-            &[\"\\n    \\n\", \"{\\n    \\n}\", \"/// bla\\n/// bla\\nstruct B {\\n    \\n}\"],\n-        )\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_comments() {\n-        do_check(\n-            r#\"\n-fn bar(){}\n-\n-// fn foo() {\n-// 1 + <|>1\n-// }\n-\n-// fn foo(){}\n-    \"#,\n-            &[\"1\", \"// 1 + 1\", \"// fn foo() {\\n// 1 + 1\\n// }\"],\n-        );\n-\n-        do_check(\n-            r#\"\n-// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-// pub enum Direction {\n-//  <|>   Next,\n-//     Prev\n-// }\n-\"#,\n-            &[\n-                \"//     Next,\",\n-                \"// #[derive(Debug, Clone, Copy, PartialEq, Eq)]\\n// pub enum Direction {\\n//     Next,\\n//     Prev\\n// }\",\n-            ],\n-        );\n-\n-        do_check(\n-            r#\"\n-/*\n-foo\n-_bar1<|>*/\n-    \"#,\n-            &[\"_bar1\", \"/*\\nfoo\\n_bar1*/\"],\n-        );\n-\n-        do_check(\n-            r#\"\n-//!<|>foo_2 bar\n-    \"#,\n-            &[\"foo_2\", \"//!foo_2 bar\"],\n-        );\n-\n-        do_check(\n-            r#\"\n-/<|>/foo bar\n-    \"#,\n-            &[\"//foo bar\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_prefer_idents() {\n-        do_check(\n-            r#\"\n-fn main() { foo<|>+bar;}\n-    \"#,\n-            &[\"foo\", \"foo+bar\"],\n-        );\n-        do_check(\n-            r#\"\n-fn main() { foo+<|>bar;}\n-    \"#,\n-            &[\"bar\", \"foo+bar\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_prefer_lifetimes() {\n-        do_check(r#\"fn foo<<|>'a>() {}\"#, &[\"'a\", \"<'a>\"]);\n-        do_check(r#\"fn foo<'a<|>>() {}\"#, &[\"'a\", \"<'a>\"]);\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_select_first_word() {\n-        do_check(r#\"// foo bar b<|>az quxx\"#, &[\"baz\", \"// foo bar baz quxx\"]);\n-        do_check(\n-            r#\"\n-impl S {\n-    fn foo() {\n-        // hel<|>lo world\n-    }\n-}\n-        \"#,\n-            &[\"hello\", \"// hello world\"],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_extend_selection_string() {\n-        do_check(\n-            r#\"\n-fn bar(){}\n-\n-\" fn f<|>oo() {\"\n-    \"#,\n-            &[\"foo\", \"\\\" fn foo() {\\\"\"],\n-        );\n-    }\n-}"}, {"sha": "ca13eb018cac9ddb4db4239e96d365432d44acca", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b931a472c4465e553f23c8b0e0e754b7b06169dd/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=b931a472c4465e553f23c8b0e0e754b7b06169dd", "patch": "@@ -3,7 +3,6 @@\n //! This usually means functions which take syntax tree as an input and produce\n //! an edit or some auxiliary info.\n \n-mod extend_selection;\n mod folding_ranges;\n mod line_index;\n mod line_index_utils;\n@@ -14,32 +13,31 @@ mod join_lines;\n mod typing;\n mod diagnostics;\n \n-#[derive(Debug)]\n-pub struct LocalEdit {\n-    pub label: String,\n-    pub edit: ra_text_edit::TextEdit,\n-    pub cursor_position: Option<TextUnit>,\n-}\n+use rustc_hash::FxHashSet;\n+use ra_text_edit::TextEditBuilder;\n+use ra_syntax::{\n+    SourceFile, SyntaxNode, TextRange, TextUnit, Direction,\n+    algo::find_leaf_at_offset,\n+    SyntaxKind::{self, *},\n+    ast::{self, AstNode},\n+};\n \n-pub use self::{\n-    extend_selection::extend_selection,\n+pub use crate::{\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n     line_index::{LineCol, LineIndex},\n     line_index_utils::translate_offset_with_edit,\n     structure::{file_structure, StructureNode},\n     diagnostics::diagnostics,\n     join_lines::join_lines,\n     typing::{on_enter, on_dot_typed, on_eq_typed},\n-\n };\n-use ra_text_edit::TextEditBuilder;\n-use ra_syntax::{\n-    SourceFile, SyntaxNode, TextRange, TextUnit, Direction,\n-    SyntaxKind::{self, *},\n-    ast::{self, AstNode},\n-    algo::find_leaf_at_offset,\n-};\n-use rustc_hash::FxHashSet;\n+\n+#[derive(Debug)]\n+pub struct LocalEdit {\n+    pub label: String,\n+    pub edit: ra_text_edit::TextEdit,\n+    pub cursor_position: Option<TextUnit>,\n+}\n \n #[derive(Debug)]\n pub struct HighlightedRange {"}]}