{"sha": "efbee50600e63293608811d7ee200f12641f1958", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYmVlNTA2MDBlNjMyOTM2MDg4MTFkN2VlMjAwZjEyNjQxZjE5NTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-16T17:50:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-16T18:02:14Z"}, "message": "avoid manual Debug impls by adding extra Provenance bounds to types\n\nI wish the derive macro would support adding extra where clauses...", "tree": {"sha": "45a1a636132d1796525c43c187c8b3f761599215", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45a1a636132d1796525c43c187c8b3f761599215"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efbee50600e63293608811d7ee200f12641f1958", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efbee50600e63293608811d7ee200f12641f1958", "html_url": "https://github.com/rust-lang/rust/commit/efbee50600e63293608811d7ee200f12641f1958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efbee50600e63293608811d7ee200f12641f1958/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5299fb6889d6eabba2b4b1a7d7e9decd49182ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5299fb6889d6eabba2b4b1a7d7e9decd49182ee", "html_url": "https://github.com/rust-lang/rust/commit/a5299fb6889d6eabba2b4b1a7d7e9decd49182ee"}], "stats": {"total": 203, "additions": 51, "deletions": 152}, "files": [{"sha": "7e7a7119be6a8144e6c7892fb5a38cb51bc217d8", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=efbee50600e63293608811d7ee200f12641f1958", "patch": "@@ -86,7 +86,9 @@ impl<T: HasDataLayout> PointerArithmetic for T {}\n /// This trait abstracts over the kind of provenance that is associated with a `Pointer`. It is\n /// mostly opaque; the `Machine` trait extends it with some more operations that also have access to\n /// some global state.\n-pub trait Provenance: Copy {\n+/// We don't actually care about this `Debug` bound (we use `Provenance::fmt` to format the entire\n+/// pointer), but `derive` adds some unecessary bounds.\n+pub trait Provenance: Copy + fmt::Debug {\n     /// Says whether the `offset` field of `Pointer`s with this provenance is the actual physical address.\n     /// If `true, ptr-to-int casts work by simply discarding the provenance.\n     /// If `false`, ptr-to-int casts are not supported. The offset *must* be relative in that case.\n@@ -142,14 +144,14 @@ static_assert_size!(Pointer, 16);\n // all the Miri types.\n impl<Tag: Provenance> fmt::Debug for Pointer<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Tag::fmt(self, f)\n+        Provenance::fmt(self, f)\n     }\n }\n \n impl<Tag: Provenance> fmt::Debug for Pointer<Option<Tag>> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.provenance {\n-            Some(tag) => Tag::fmt(&Pointer::new(tag, self.offset), f),\n+            Some(tag) => Provenance::fmt(&Pointer::new(tag, self.offset), f),\n             None => write!(f, \"0x{:x}\", self.offset.bytes()),\n         }\n     }"}, {"sha": "516ef4f4e53ca8130a1c9a5d9f73b57d4c5f7982", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=efbee50600e63293608811d7ee200f12641f1958", "patch": "@@ -80,7 +80,7 @@ impl Drop for SpanGuard {\n }\n \n /// A stack frame.\n-pub struct Frame<'mir, 'tcx, Tag = AllocId, Extra = ()> {\n+pub struct Frame<'mir, 'tcx, Tag: Provenance = AllocId, Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n@@ -161,16 +161,16 @@ pub enum StackPopCleanup {\n \n /// State of a local variable including a memoized layout\n #[derive(Clone, PartialEq, Eq, HashStable)]\n-pub struct LocalState<'tcx, Tag = AllocId> {\n+pub struct LocalState<'tcx, Tag: Provenance = AllocId> {\n     pub value: LocalValue<Tag>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     #[stable_hasher(ignore)]\n     pub layout: Cell<Option<TyAndLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n-#[derive(Copy, Clone, PartialEq, Eq, HashStable)]\n-pub enum LocalValue<Tag = AllocId> {\n+#[derive(Copy, Clone, PartialEq, Eq, HashStable, Debug)] // Miri debug-prints these\n+pub enum LocalValue<Tag: Provenance = AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n     /// This local is alive but not yet initialized. It can be written to\n@@ -186,19 +186,7 @@ pub enum LocalValue<Tag = AllocId> {\n     Live(Operand<Tag>),\n }\n \n-impl<Tag: Provenance> std::fmt::Debug for LocalValue<Tag> {\n-    // Miri debug-prints these\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        use LocalValue::*;\n-        match self {\n-            Dead => f.debug_tuple(\"Dead\").finish(),\n-            Uninitialized => f.debug_tuple(\"Uninitialized\").finish(),\n-            Live(o) => f.debug_tuple(\"Live\").field(o).finish(),\n-        }\n-    }\n-}\n-\n-impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance + 'static> LocalState<'tcx, Tag> {\n     /// Read the local's value or error if the local is not yet live or not live anymore.\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n@@ -232,7 +220,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n+impl<'mir, 'tcx, Tag: Provenance> Frame<'mir, 'tcx, Tag> {\n     pub fn with_extra<Extra>(self, extra: Extra) -> Frame<'mir, 'tcx, Tag, Extra> {\n         Frame {\n             body: self.body,\n@@ -247,7 +235,7 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n+impl<'mir, 'tcx, Tag: Provenance, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     /// Get the current location within the Frame.\n     ///\n     /// If this is `Err`, we are not currently executing any particular statement in\n@@ -1024,7 +1012,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n     }\n }\n \n-impl<'ctx, 'mir, 'tcx, Tag, Extra> HashStable<StableHashingContext<'ctx>>\n+impl<'ctx, 'mir, 'tcx, Tag: Provenance, Extra> HashStable<StableHashingContext<'ctx>>\n     for Frame<'mir, 'tcx, Tag, Extra>\n where\n     Extra: HashStable<StableHashingContext<'ctx>>,"}, {"sha": "aba7db7816843001930e9a2f1cf58478617b1e3b", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 56, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=efbee50600e63293608811d7ee200f12641f1958", "patch": "@@ -27,40 +27,30 @@ use super::{\n /// operations and wide pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n-#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash)]\n-pub enum Immediate<Tag = AllocId> {\n+#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n+pub enum Immediate<Tag: Provenance = AllocId> {\n     Scalar(ScalarMaybeUninit<Tag>),\n     ScalarPair(ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>),\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Immediate, 56);\n \n-impl<Tag: Provenance> std::fmt::Debug for Immediate<Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        use Immediate::*;\n-        match self {\n-            Scalar(s) => f.debug_tuple(\"Scalar\").field(s).finish(),\n-            ScalarPair(s1, s2) => f.debug_tuple(\"ScalarPair\").field(s1).field(s2).finish(),\n-        }\n-    }\n-}\n-\n-impl<Tag> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n+impl<Tag: Provenance> From<ScalarMaybeUninit<Tag>> for Immediate<Tag> {\n     #[inline(always)]\n     fn from(val: ScalarMaybeUninit<Tag>) -> Self {\n         Immediate::Scalar(val)\n     }\n }\n \n-impl<Tag> From<Scalar<Tag>> for Immediate<Tag> {\n+impl<Tag: Provenance> From<Scalar<Tag>> for Immediate<Tag> {\n     #[inline(always)]\n     fn from(val: Scalar<Tag>) -> Self {\n         Immediate::Scalar(val.into())\n     }\n }\n \n-impl<'tcx, Tag> Immediate<Tag> {\n+impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     pub fn from_pointer(p: Pointer<Tag>, cx: &impl HasDataLayout) -> Self {\n         Immediate::Scalar(ScalarMaybeUninit::from_pointer(p, cx))\n     }\n@@ -93,22 +83,15 @@ impl<'tcx, Tag> Immediate<Tag> {\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n // as input for binary and cast operations.\n-#[derive(Copy, Clone)]\n-pub struct ImmTy<'tcx, Tag = AllocId> {\n+#[derive(Copy, Clone, Debug)]\n+pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n     imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n \n-impl<'tcx, Tag: Provenance> std::fmt::Debug for ImmTy<'tcx, Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let ImmTy { imm, layout } = self;\n-        f.debug_struct(\"ImmTy\").field(\"imm\", imm).field(\"layout\", layout).finish()\n-    }\n-}\n-\n impl<Tag: Provenance> std::fmt::Display for ImmTy<'tcx, Tag> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         /// Helper function for printing a scalar to a FmtPrinter\n@@ -156,7 +139,7 @@ impl<Tag: Provenance> std::fmt::Display for ImmTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag> std::ops::Deref for ImmTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for ImmTy<'tcx, Tag> {\n     type Target = Immediate<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Immediate<Tag> {\n@@ -167,68 +150,51 @@ impl<'tcx, Tag> std::ops::Deref for ImmTy<'tcx, Tag> {\n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n-#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash)]\n-pub enum Operand<Tag = AllocId> {\n+#[derive(Copy, Clone, PartialEq, Eq, HashStable, Hash, Debug)]\n+pub enum Operand<Tag: Provenance = AllocId> {\n     Immediate(Immediate<Tag>),\n     Indirect(MemPlace<Tag>),\n }\n \n-impl<Tag: Provenance> std::fmt::Debug for Operand<Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        use Operand::*;\n-        match self {\n-            Immediate(i) => f.debug_tuple(\"Immediate\").field(i).finish(),\n-            Indirect(p) => f.debug_tuple(\"Indirect\").field(p).finish(),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct OpTy<'tcx, Tag = AllocId> {\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct OpTy<'tcx, Tag: Provenance = AllocId> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(OpTy<'_, ()>, 80);\n-\n-impl<'tcx, Tag: Provenance> std::fmt::Debug for OpTy<'tcx, Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let OpTy { op, layout } = self;\n-        f.debug_struct(\"OpTy\").field(\"op\", op).field(\"layout\", layout).finish()\n-    }\n-}\n+rustc_data_structures::static_assert_size!(OpTy<'_>, 80);\n \n-impl<'tcx, Tag> std::ops::Deref for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for OpTy<'tcx, Tag> {\n     type Target = Operand<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Operand<Tag> {\n         &self.op\n     }\n }\n \n-impl<'tcx, Tag: Copy> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n         OpTy { op: Operand::Indirect(*mplace), layout: mplace.layout }\n     }\n }\n \n-impl<'tcx, Tag: Copy> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<&'_ MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: &MPlaceTy<'tcx, Tag>) -> Self {\n         OpTy { op: Operand::Indirect(**mplace), layout: mplace.layout }\n     }\n }\n \n-impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(val: ImmTy<'tcx, Tag>) -> Self {\n         OpTy { op: Operand::Immediate(val.imm), layout: val.layout }\n     }\n }\n \n-impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n         ImmTy { imm: val.into(), layout }\n@@ -259,10 +225,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub fn to_const_int(self) -> ConstInt\n-    where\n-        Tag: Provenance,\n-    {\n+    pub fn to_const_int(self) -> ConstInt {\n         assert!(self.layout.ty.is_integral());\n         let int = self.to_scalar().expect(\"to_const_int doesn't work on scalar pairs\").assert_int();\n         ConstInt::new(int, self.layout.ty.is_signed(), self.layout.ty.is_ptr_sized_integral())"}, {"sha": "91fcc3495b1c12abeaa3523d705462214f3db23d", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 19, "deletions": 73, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbee50600e63293608811d7ee200f12641f1958/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=efbee50600e63293608811d7ee200f12641f1958", "patch": "@@ -19,9 +19,9 @@ use super::{\n     Operand, Pointer, PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n };\n \n-#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n /// Information required for the sound usage of a `MemPlace`.\n-pub enum MemPlaceMeta<Tag = AllocId> {\n+pub enum MemPlaceMeta<Tag: Provenance = AllocId> {\n     /// The unsized payload (e.g. length for slices or vtable pointer for trait objects).\n     Meta(Scalar<Tag>),\n     /// `Sized` types or unsized `extern type`\n@@ -36,18 +36,7 @@ pub enum MemPlaceMeta<Tag = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MemPlaceMeta, 24);\n \n-impl<Tag: Provenance> std::fmt::Debug for MemPlaceMeta<Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        use MemPlaceMeta::*;\n-        match self {\n-            Meta(s) => f.debug_tuple(\"Meta\").field(s).finish(),\n-            None => f.debug_tuple(\"None\").finish(),\n-            Poison => f.debug_tuple(\"Poison\").finish(),\n-        }\n-    }\n-}\n-\n-impl<Tag> MemPlaceMeta<Tag> {\n+impl<Tag: Provenance> MemPlaceMeta<Tag> {\n     pub fn unwrap_meta(self) -> Scalar<Tag> {\n         match self {\n             Self::Meta(s) => s,\n@@ -64,8 +53,8 @@ impl<Tag> MemPlaceMeta<Tag> {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable)]\n-pub struct MemPlace<Tag = AllocId> {\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n+pub struct MemPlace<Tag: Provenance = AllocId> {\n     /// The pointer can be a pure integer, with the `None` tag.\n     pub ptr: Pointer<Option<Tag>>,\n     pub align: Align,\n@@ -78,19 +67,8 @@ pub struct MemPlace<Tag = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MemPlace, 48);\n \n-impl<Tag: Provenance> std::fmt::Debug for MemPlace<Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let MemPlace { ptr, align, meta } = self;\n-        f.debug_struct(\"MemPlace\")\n-            .field(\"ptr\", ptr)\n-            .field(\"align\", align)\n-            .field(\"meta\", meta)\n-            .finish()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable)]\n-pub enum Place<Tag = AllocId> {\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, HashStable, Debug)]\n+pub enum Place<Tag: Provenance = AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr(MemPlace<Tag>),\n \n@@ -102,35 +80,16 @@ pub enum Place<Tag = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Place, 56);\n \n-impl<Tag: Provenance> std::fmt::Debug for Place<Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        use Place::*;\n-        match self {\n-            Ptr(p) => f.debug_tuple(\"Ptr\").field(p).finish(),\n-            Local { frame, local } => {\n-                f.debug_struct(\"Local\").field(\"frame\", frame).field(\"local\", local).finish()\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct PlaceTy<'tcx, Tag = AllocId> {\n+#[derive(Copy, Clone, Debug)]\n+pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PlaceTy<'_>, 72);\n \n-impl<'tcx, Tag: Provenance> std::fmt::Debug for PlaceTy<'tcx, Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let PlaceTy { place, layout } = self;\n-        f.debug_struct(\"PlaceTy\").field(\"place\", place).field(\"layout\", layout).finish()\n-    }\n-}\n-\n-impl<'tcx, Tag> std::ops::Deref for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n     type Target = Place<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Place<Tag> {\n@@ -139,38 +98,31 @@ impl<'tcx, Tag> std::ops::Deref for PlaceTy<'tcx, Tag> {\n }\n \n /// A MemPlace with its layout. Constructing it is only possible in this module.\n-#[derive(Copy, Clone, Hash, Eq, PartialEq)]\n-pub struct MPlaceTy<'tcx, Tag = AllocId> {\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n+pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n     mplace: MemPlace<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n \n-impl<'tcx, Tag: Provenance> std::fmt::Debug for MPlaceTy<'tcx, Tag> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let MPlaceTy { mplace, layout } = self;\n-        f.debug_struct(\"MPlaceTy\").field(\"mplace\", mplace).field(\"layout\", layout).finish()\n-    }\n-}\n-\n-impl<'tcx, Tag> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     type Target = MemPlace<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &MemPlace<Tag> {\n         &self.mplace\n     }\n }\n \n-impl<'tcx, Tag> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n         PlaceTy { place: Place::Ptr(mplace.mplace), layout: mplace.layout }\n     }\n }\n \n-impl<Tag> MemPlace<Tag> {\n+impl<Tag: Provenance> MemPlace<Tag> {\n     #[inline(always)]\n     pub fn from_ptr(ptr: Pointer<Option<Tag>>, align: Align) -> Self {\n         MemPlace { ptr, align, meta: MemPlaceMeta::None }\n@@ -212,7 +164,7 @@ impl<Tag> MemPlace<Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n     pub fn dangling(layout: TyAndLayout<'tcx>) -> Self {\n@@ -239,10 +191,7 @@ impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64>\n-    where\n-        Tag: Provenance,\n-    {\n+    pub(super) fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n             match self.layout.ty.kind() {\n@@ -269,7 +218,7 @@ impl<'tcx, Tag: Copy> MPlaceTy<'tcx, Tag> {\n }\n \n // These are defined here because they produce a place.\n-impl<'tcx, Tag: Copy> OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n@@ -284,10 +233,7 @@ impl<'tcx, Tag: Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n-    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Tag>\n-    where\n-        Tag: Provenance,\n-    {\n+    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace().unwrap()\n     }\n }"}]}