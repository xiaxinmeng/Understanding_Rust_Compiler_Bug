{"sha": "993e7e2622da632705661007d5a3bce812cc6d3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5M2U3ZTI2MjJkYTYzMjcwNTY2MTAwN2Q1YTNiY2U4MTJjYzZkM2Q=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-08-26T13:36:50Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-08-26T15:24:51Z"}, "message": "fix `is_non_exhaustive` confusion between structs and enums\n\nStructs and enums can both be non-exhaustive, with a very different\nmeaning. This PR splits `is_non_exhaustive` to 2 separate functions - 1\nfor structs, and another for enums, and fixes the places that got the\nusage confused.\n\nFixes #53549.", "tree": {"sha": "aa4a3dfa5154c2dba716b6289c12d28f7e80bd1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa4a3dfa5154c2dba716b6289c12d28f7e80bd1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/993e7e2622da632705661007d5a3bce812cc6d3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/993e7e2622da632705661007d5a3bce812cc6d3d", "html_url": "https://github.com/rust-lang/rust/commit/993e7e2622da632705661007d5a3bce812cc6d3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/993e7e2622da632705661007d5a3bce812cc6d3d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d", "html_url": "https://github.com/rust-lang/rust/commit/caed80ba4ba8d9f4d3fa8aa9af6c4092d779cd9d"}], "stats": {"total": 111, "additions": 87, "deletions": 24}, "files": [{"sha": "c60de9c386e0800941a9d43774f1c8965297261e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=993e7e2622da632705661007d5a3bce812cc6d3d", "patch": "@@ -1981,10 +1981,30 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn is_non_exhaustive(&self) -> bool {\n+    fn is_non_exhaustive(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_NON_EXHAUSTIVE)\n     }\n \n+    #[inline]\n+    pub fn is_enum_non_exhaustive(&self) -> bool {\n+        match self.adt_kind() {\n+            AdtKind::Enum => self.is_non_exhaustive(),\n+            AdtKind::Struct | AdtKind::Union => {\n+                bug!(\"is_non_exhaustive_enum called on non-enum `{:?}`\", self);\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_univariant_non_exhaustive(&self) -> bool {\n+        match self.adt_kind() {\n+            AdtKind::Struct | AdtKind::Union => self.is_non_exhaustive(),\n+            AdtKind::Enum => {\n+                bug!(\"is_non_exhaustive_enum called on non-enum `{:?}`\", self);\n+            }\n+        }\n+    }\n+\n     /// Returns the kind of the ADT - Struct or Enum.\n     #[inline]\n     pub fn adt_kind(&self) -> AdtKind {\n@@ -1997,6 +2017,19 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n+    /// Return whether `variant` is non-exhaustive as a *struct* (i.e., whether\n+    /// it can have additional fields).\n+    pub fn is_variant_non_exhaustive(&self, _variant: &ty::VariantDef) -> bool {\n+        match self.adt_kind() {\n+            // A struct is non-exhaustive if it has a `#[non_exhaustive]` attribute.\n+            AdtKind::Struct => self.is_non_exhaustive(),\n+            // At this moment, all enum variants are exhaustive.\n+            AdtKind::Enum => false,\n+            // All unions are \"exhaustive\", as far as that makes sense.\n+            AdtKind::Union => false,\n+        }\n+    }\n+\n     pub fn descr(&self) -> &'static str {\n         match self.adt_kind() {\n             AdtKind::Struct => \"struct\","}, {"sha": "27f4577c442a6f970776980a6342d79c6ddb8a7a", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=993e7e2622da632705661007d5a3bce812cc6d3d", "patch": "@@ -740,7 +740,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         // If the structure is marked as non_exhaustive then lower the visibility\n         // to within the crate.\n-        if adt_def.is_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+        if adt_def.is_univariant_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n "}, {"sha": "4f14a45bfc835d75bd832f42a73f4c5f6add76d6", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=993e7e2622da632705661007d5a3bce812cc6d3d", "patch": "@@ -381,7 +381,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::Adt(adt_def, ..) => adt_def.is_enum() && adt_def.is_non_exhaustive(),\n+            ty::Adt(adt_def, ..) => adt_def.is_enum() && adt_def.is_enum_non_exhaustive(),\n             _ => false,\n         }\n     }"}, {"sha": "ea13a3d00331d43eff18ba0e27e6f30224e1ec76", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=993e7e2622da632705661007d5a3bce812cc6d3d", "patch": "@@ -684,7 +684,9 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n                         // visibility to within the crate.\n                         let struct_def_id = self.tcx.hir.get_parent_did(node_id);\n                         let adt_def = self.tcx.adt_def(struct_def_id);\n-                        if adt_def.is_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+                        if adt_def.is_univariant_non_exhaustive()\n+                            && ctor_vis == ty::Visibility::Public\n+                        {\n                             ctor_vis = ty::Visibility::Restricted(\n                                 DefId::local(CRATE_DEF_INDEX));\n                         }"}, {"sha": "b4dcea0eb329acfd76dac4951a9a3587900324de", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=993e7e2622da632705661007d5a3bce812cc6d3d", "patch": "@@ -948,7 +948,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n \n         // Require `..` if struct has non_exhaustive attribute.\n-        if adt.is_struct() && adt.is_non_exhaustive() && !adt.did.is_local() && !etc {\n+        if adt.is_variant_non_exhaustive(variant) && !adt.did.is_local() && !etc {\n             span_err!(tcx.sess, span, E0638,\n                       \"`..` required with {} marked as non-exhaustive\",\n                       kind_name);"}, {"sha": "d4013b10c319a2d51dd17ba07aea9a2955b97eb1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=993e7e2622da632705661007d5a3bce812cc6d3d", "patch": "@@ -3465,7 +3465,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // re-link the regions that EIfEO can erase.\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n-        let (substs, adt_kind, kind_name) = match &adt_ty.sty{\n+        let (substs, adt_kind, kind_name) = match &adt_ty.sty {\n             &ty::Adt(adt, substs) => {\n                 (substs, adt.adt_kind(), adt.variant_descr())\n             }\n@@ -3639,37 +3639,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, struct_ty) =\n-        if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n-            variant_ty\n-        } else {\n-            self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx.types.err;\n-        };\n+        let (variant, adt_ty) =\n+            if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n+                variant_ty\n+            } else {\n+                self.check_struct_fields_on_error(fields, base_expr);\n+                return self.tcx.types.err;\n+            };\n \n         let path_span = match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.span,\n             hir::QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n         // Prohibit struct expressions when non exhaustive flag is set.\n-        if let ty::Adt(adt, _) = struct_ty.sty {\n-            if !adt.did.is_local() && adt.is_non_exhaustive() {\n-                span_err!(self.tcx.sess, expr.span, E0639,\n-                          \"cannot create non-exhaustive {} using struct expression\",\n-                          adt.variant_descr());\n-            }\n+        let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n+        if !adt.did.is_local() && adt.is_variant_non_exhaustive(variant) {\n+            span_err!(self.tcx.sess, expr.span, E0639,\n+                      \"cannot create non-exhaustive {} using struct expression\",\n+                      adt.variant_descr());\n         }\n \n-        let error_happened = self.check_expr_struct_fields(struct_ty, expected, expr.id, path_span,\n+        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.id, path_span,\n                                                            variant, fields, base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             // If check_expr_struct_fields hit an error, do not attempt to populate\n             // the fields with the base_expr. This could cause us to hit errors later\n             // when certain fields are assumed to exist that in fact do not.\n             if !error_happened {\n-                self.check_expr_has_type_or_error(base_expr, struct_ty);\n-                match struct_ty.sty {\n+                self.check_expr_has_type_or_error(base_expr, adt_ty);\n+                match adt_ty.sty {\n                     ty::Adt(adt, substs) if adt.is_struct() => {\n                         let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n@@ -3687,8 +3686,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n-        self.require_type_is_sized(struct_ty, expr.span, traits::StructInitializerSized);\n-        struct_ty\n+        self.require_type_is_sized(adt_ty, expr.span, traits::StructInitializerSized);\n+        adt_ty\n     }\n \n "}, {"sha": "83fb24cda088cd1bdb7b600a6bcdfde6c9d67391", "filename": "src/test/run-pass/rfc-2008-non-exhaustive/enums.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Ftest%2Frun-pass%2Frfc-2008-non-exhaustive%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993e7e2622da632705661007d5a3bce812cc6d3d/src%2Ftest%2Frun-pass%2Frfc-2008-non-exhaustive%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2008-non-exhaustive%2Fenums.rs?ref=993e7e2622da632705661007d5a3bce812cc6d3d", "patch": "@@ -30,4 +30,33 @@ fn main() {\n     match enum_unit {\n         _ => \"no error with only wildcard\"\n     };\n+\n+\n+    // issue #53549 - check that variant constructors can still be called normally.\n+\n+    match NonExhaustiveEnum::Unit {\n+        NonExhaustiveEnum::Unit => {},\n+        _ => {}\n+    };\n+\n+    match NonExhaustiveEnum::Tuple(2) {\n+        NonExhaustiveEnum::Tuple(2) => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Unit {}) {\n+        NonExhaustiveEnum::Unit {} => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Tuple { 0: 2 }) {\n+        NonExhaustiveEnum::Tuple { 0: 2 } => {},\n+        _ => {}\n+    };\n+\n+    match (NonExhaustiveEnum::Struct { field: 2 }) {\n+        NonExhaustiveEnum::Struct { field: 2 } => {},\n+        _ => {}\n+    };\n+\n }"}]}