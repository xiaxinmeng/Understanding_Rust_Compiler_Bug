{"sha": "84196f33710e2797a576ddc5241e418b7a4f1f2c", "node_id": "C_kwDOAAsO6NoAKDg0MTk2ZjMzNzEwZTI3OTdhNTc2ZGRjNTI0MWU0MThiN2E0ZjFmMmM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-02T22:07:53Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-02T22:07:58Z"}, "message": "Elaborate comment, make sure we do normalizes-to hack eventually for IATs, don't partially support const projection for impls", "tree": {"sha": "d01fd0bd5cbe0d39f5511d2a908b8eb3f38de4f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d01fd0bd5cbe0d39f5511d2a908b8eb3f38de4f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84196f33710e2797a576ddc5241e418b7a4f1f2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84196f33710e2797a576ddc5241e418b7a4f1f2c", "html_url": "https://github.com/rust-lang/rust/commit/84196f33710e2797a576ddc5241e418b7a4f1f2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84196f33710e2797a576ddc5241e418b7a4f1f2c/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8912015f71a7013ad343fd7e29c355234f3540ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8912015f71a7013ad343fd7e29c355234f3540ac", "html_url": "https://github.com/rust-lang/rust/commit/8912015f71a7013ad343fd7e29c355234f3540ac"}], "stats": {"total": 55, "additions": 29, "deletions": 26}, "files": [{"sha": "23601f668ff057990414dc0de5234e15a0745d78", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/84196f33710e2797a576ddc5241e418b7a4f1f2c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84196f33710e2797a576ddc5241e418b7a4f1f2c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=84196f33710e2797a576ddc5241e418b7a4f1f2c", "patch": "@@ -25,29 +25,39 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let def_id = goal.predicate.def_id();\n         match self.tcx().def_kind(def_id) {\n             DefKind::AssocTy | DefKind::AssocConst => {\n-                match self.tcx().associated_item(def_id).container {\n-                    ty::AssocItemContainer::TraitContainer => {\n-                        // To only compute normalization once for each projection we only\n-                        // normalize if the expected term is an unconstrained inference variable.\n-                        //\n-                        // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n-                        // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n-                        // `U` and equate it with `u32`. This means that we don't need a separate\n-                        // projection cache in the solver.\n-                        if self.term_is_fully_unconstrained(goal) {\n+                // To only compute normalization once for each projection we only\n+                // assemble normalization candidates if the expected term is an\n+                // unconstrained inference variable.\n+                //\n+                // Why: For better cache hits, since if we have an unconstrained RHS then\n+                // there are only as many cache keys as there are (canonicalized) alias\n+                // types in each normalizes-to goal. This also weakens inference in a\n+                // forwards-compatible way so we don't use the value of the RHS term to\n+                // affect candidate assembly for projections.\n+                //\n+                // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n+                // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n+                // `U` and equate it with `u32`. This means that we don't need a separate\n+                // projection cache in the solver, since we're piggybacking off of regular\n+                // goal caching.\n+                if self.term_is_fully_unconstrained(goal) {\n+                    match self.tcx().associated_item(def_id).container {\n+                        ty::AssocItemContainer::TraitContainer => {\n                             let candidates = self.assemble_and_evaluate_candidates(goal);\n                             self.merge_candidates(candidates)\n-                        } else {\n-                            self.set_normalizes_to_hack_goal(goal);\n-                            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                        }\n+                        ty::AssocItemContainer::ImplContainer => {\n+                            bug!(\"IATs not supported here yet\")\n                         }\n                     }\n-                    ty::AssocItemContainer::ImplContainer => bug!(\"IATs not supported here yet\"),\n+                } else {\n+                    self.set_normalizes_to_hack_goal(goal);\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n             }\n             DefKind::AnonConst => self.normalize_anon_const(goal),\n             DefKind::OpaqueTy => self.normalize_opaque_type(goal),\n-            kind => bug!(\"uknown DefKind {} in projection goal: {goal:#?}\", kind.descr(def_id)),\n+            kind => bug!(\"unknown DefKind {} in projection goal: {goal:#?}\", kind.descr(def_id)),\n         }\n     }\n \n@@ -203,17 +213,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             );\n \n             // Finally we construct the actual value of the associated type.\n-            let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n-            let ty = tcx.type_of(assoc_def.item.def_id);\n-            let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n-                let identity_substs =\n-                    ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n-                let did = assoc_def.item.def_id;\n-                let kind =\n-                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n-                ty.map_bound(|ty| tcx.mk_const(kind, ty).into())\n-            } else {\n-                ty.map_bound(|ty| ty.into())\n+            let term = match assoc_def.item.kind {\n+                ty::AssocKind::Type => tcx.type_of(assoc_def.item.def_id).map_bound(|ty| ty.into()),\n+                ty::AssocKind::Const => bug!(\"associated const projection is not supported yet\"),\n+                ty::AssocKind::Fn => unreachable!(\"we should never project to a fn\"),\n             };\n \n             ecx.eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))"}]}