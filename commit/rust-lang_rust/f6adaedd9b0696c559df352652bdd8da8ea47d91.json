{"sha": "f6adaedd9b0696c559df352652bdd8da8ea47d91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YWRhZWRkOWIwNjk2YzU1OWRmMzUyNjUyYmRkOGRhOGVhNDdkOTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-18T15:44:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-06-18T15:44:56Z"}, "message": "add various coments to explain how the code works", "tree": {"sha": "0c506d3ef287d224ea75f30f0fbb7a805066375e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c506d3ef287d224ea75f30f0fbb7a805066375e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6adaedd9b0696c559df352652bdd8da8ea47d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6adaedd9b0696c559df352652bdd8da8ea47d91", "html_url": "https://github.com/rust-lang/rust/commit/f6adaedd9b0696c559df352652bdd8da8ea47d91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6adaedd9b0696c559df352652bdd8da8ea47d91/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1989b9a0b5f176d84cb736dbe5ba95787d5a9937", "url": "https://api.github.com/repos/rust-lang/rust/commits/1989b9a0b5f176d84cb736dbe5ba95787d5a9937", "html_url": "https://github.com/rust-lang/rust/commit/1989b9a0b5f176d84cb736dbe5ba95787d5a9937"}], "stats": {"total": 96, "additions": 85, "deletions": 11}, "files": [{"sha": "a74070100f413131b1cb2e9b4e34b96654110200", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f6adaedd9b0696c559df352652bdd8da8ea47d91/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6adaedd9b0696c559df352652bdd8da8ea47d91/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f6adaedd9b0696c559df352652bdd8da8ea47d91", "patch": "@@ -392,6 +392,34 @@ pub struct TypeckResults<'tcx> {\n     /// (including late-bound regions) are replaced with free\n     /// equivalents. This table is not used in codegen (since regions\n     /// are erased there) and hence is not serialized to metadata.\n+    ///\n+    /// This table also contains the \"revealed\" values for any `impl Trait`\n+    /// that appear in the signature and whose values are being inferred\n+    /// by this function.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// fn foo(x: &u32) -> impl Debug { *x }\n+    /// ```\n+    ///\n+    /// The function signature here would be:\n+    ///\n+    /// ```\n+    /// for<'a> fn(&'a u32) -> Foo\n+    /// ```\n+    ///\n+    /// where `Foo` is an opaque type created for this function.\n+    ///\n+    ///\n+    /// The *liberated* form of this would be\n+    ///\n+    /// ```\n+    /// fn(&'a u32) -> u32\n+    /// ```\n+    ///\n+    /// Note that `'a` is not bound (it would be an `ReFree`) and\n+    /// that the `Foo` opaque type is replaced by its hidden type.\n     liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n \n     /// For each FRU expression, record the normalized types of the fields"}, {"sha": "984a9a7f0539a279d3ff1e1c0734c82143391dea", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f6adaedd9b0696c559df352652bdd8da8ea47d91/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6adaedd9b0696c559df352652bdd8da8ea47d91/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=f6adaedd9b0696c559df352652bdd8da8ea47d91", "patch": "@@ -1206,6 +1206,35 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         Ok(())\n     }\n \n+    /// Equates a type `anon_ty` that may contain opaque types whose\n+    /// values are to be inferred by the MIR with def-id `anon_owner_def_id`.\n+    ///\n+    /// The type `revealed_ty` contains the same type as `anon_ty`, but with the\n+    /// hidden types for impl traits revealed.\n+    ///\n+    /// # Example\n+    ///\n+    /// Consider a piece of code like\n+    ///\n+    /// ```rust\n+    /// type Foo<U> = impl Debug;\n+    ///\n+    /// fn foo<T: Debug>(t: T) -> Box<Foo<T>> {\n+    ///      Box::new((t, 22_u32))\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, the function signature would be something like\n+    /// `fn(T) -> Box<impl Debug>`. The MIR return slot would have\n+    /// the type with the opaque type revealed, so `Box<(T, u32)>`.\n+    ///\n+    /// In terms of our function parameters:\n+    ///\n+    /// * `anon_ty` would be `Box<Foo<T>>` where `Foo` is an opaque type\n+    ///   scoped to this function (note that it is parameterized by the\n+    ///   generics of `foo`).\n+    /// * `revealed_ty` would be `Box<(Foo<T>, u32)>`\n+    /// * `anon_owner_def_id` would be the def-id of `foo`\n     fn eq_opaque_type_and_type(\n         &mut self,\n         revealed_ty: Ty<'tcx>,\n@@ -1240,6 +1269,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let body = self.body;\n+\n+        // the \"concrete opaque types\" maps\n         let concrete_opaque_types = &tcx.typeck(anon_owner_def_id).concrete_opaque_types;\n         let mut opaque_type_values = VecMap::new();\n \n@@ -1252,6 +1283,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     let mut obligations = ObligationAccumulator::default();\n \n                     let dummy_body_id = hir::CRATE_HIR_ID;\n+\n+                    // Replace the opaque types defined by this function with\n+                    // inference variables, creating a map. In our example above,\n+                    // this would transform the type `Box<Foo<T>>` (where `Foo` is an opaque type)\n+                    // to `Box<?T>`, returning an `opaque_type_map` mapping `{Foo<T> -> ?T}`.\n+                    // (Note that the key of the map is both the def-id of `Foo` along with\n+                    // any generic parameters.)\n                     let (output_ty, opaque_type_map) =\n                         obligations.add(infcx.instantiate_opaque_types(\n                             anon_owner_def_id,\n@@ -1267,6 +1305,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                          revealed_ty={:?}\",\n                         output_ty, opaque_type_map, revealed_ty\n                     );\n+\n                     // Make sure that the inferred types are well-formed. I'm\n                     // not entirely sure this is needed (the HIR type check\n                     // didn't do this) but it seems sensible to prevent opaque\n@@ -1282,6 +1321,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             .eq(output_ty, revealed_ty)?,\n                     );\n \n+                    // For each opaque type `Foo<T>` inferred by this value, we want to equate\n+                    // the inference variable `?T` with the revealed type that was computed\n+                    // earlier by type check.\n                     for &(opaque_type_key, opaque_decl) in &opaque_type_map {\n                         let resolved_ty = infcx.resolve_vars_if_possible(opaque_decl.concrete_ty);\n                         let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind() {\n@@ -1290,6 +1332,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             false\n                         };\n \n+                        // The revealed type computed by the earlier phase of type check.\n+                        // In our example, this would be `(U, u32)`. Note that this references\n+                        // the type parameter `U` from the definition of `Foo`.\n                         let concrete_ty = match concrete_opaque_types\n                             .get_by(|(key, _)| key.def_id == opaque_type_key.def_id)\n                         {\n@@ -1308,7 +1353,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             Some(concrete_ty) => concrete_ty,\n                         };\n                         debug!(\"concrete_ty = {:?}\", concrete_ty);\n+\n+                        // Apply the substitution, in this case `[U -> T]`, so that the\n+                        // concrete type becomes `Foo<(T, u32)>`\n                         let subst_opaque_defn_ty = concrete_ty.subst(tcx, opaque_type_key.substs);\n+\n+                        // \"Renumber\" this, meaning that we replace all the regions\n+                        // with fresh inference variables. Not relevant to our example.\n                         let renumbered_opaque_defn_ty =\n                             renumber::renumber_regions(infcx, subst_opaque_defn_ty);\n \n@@ -1318,8 +1369,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         );\n \n                         if !concrete_is_opaque {\n-                            // Equate concrete_ty (an inference variable) with\n-                            // the renumbered type from typeck.\n+                            // Equate the instantiated opaque type `opaque_decl.concrete_ty` (`?T`,\n+                            // in our example) with the renumbered version that we took from\n+                            // the type check results (`Foo<(T, u32)>`).\n                             obligations.add(\n                                 infcx\n                                     .at(&ObligationCause::dummy(), param_env)"}, {"sha": "0061ce4ed370959383c5880c719844d20b2dbd1d", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6adaedd9b0696c559df352652bdd8da8ea47d91/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6adaedd9b0696c559df352652bdd8da8ea47d91/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=f6adaedd9b0696c559df352652bdd8da8ea47d91", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -982,8 +981,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n                             parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n                         };\n-                        let (in_definition_scope, origin) = match tcx.hir().find(opaque_hir_id) {\n-                            Some(Node::Item(item)) => match item.kind {\n+                        let (in_definition_scope, origin) =\n+                            match tcx.hir().expect_item(opaque_hir_id).kind {\n                                 // Anonymous `impl Trait`\n                                 hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                                     impl_trait_fn: Some(parent),\n@@ -1000,12 +999,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     origin,\n                                 ),\n                                 _ => (def_scope_default(), hir::OpaqueTyOrigin::Misc),\n-                            },\n-                            _ => bug!(\n-                                \"expected item, found {}\",\n-                                tcx.hir().node_to_string(opaque_hir_id),\n-                            ),\n-                        };\n+                            };\n                         if in_definition_scope {\n                             let opaque_type_key =\n                                 OpaqueTypeKey { def_id: def_id.to_def_id(), substs };"}]}