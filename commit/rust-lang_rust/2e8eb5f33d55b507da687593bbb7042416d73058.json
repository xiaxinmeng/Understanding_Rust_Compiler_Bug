{"sha": "2e8eb5f33d55b507da687593bbb7042416d73058", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlOGViNWYzM2Q1NWI1MDdkYTY4NzU5M2JiYjcwNDI0MTZkNzMwNTg=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T08:01:22Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-24T15:28:08Z"}, "message": "Move thread parking to a seperate function", "tree": {"sha": "651e7748a76eae883c7aa4716b408f20b5b9133b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/651e7748a76eae883c7aa4716b408f20b5b9133b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e8eb5f33d55b507da687593bbb7042416d73058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e8eb5f33d55b507da687593bbb7042416d73058", "html_url": "https://github.com/rust-lang/rust/commit/2e8eb5f33d55b507da687593bbb7042416d73058", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e8eb5f33d55b507da687593bbb7042416d73058/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850", "html_url": "https://github.com/rust-lang/rust/commit/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850"}], "stats": {"total": 80, "additions": 42, "deletions": 38}, "files": [{"sha": "2c09fb3318b2bf91731b0db9e42b15a6350703f5", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2e8eb5f33d55b507da687593bbb7042416d73058/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e8eb5f33d55b507da687593bbb7042416d73058/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=2e8eb5f33d55b507da687593bbb7042416d73058", "patch": "@@ -401,51 +401,55 @@ impl Once {\n                 // not RUNNING.\n                 _ => {\n                     assert!(state_and_queue & STATE_MASK == RUNNING);\n-                    // Create the node for our current thread that we are going to try to slot\n-                    // in at the head of the linked list.\n-                    let mut node = Waiter {\n-                        thread: thread::current(),\n-                        signaled: AtomicBool::new(false),\n-                        next: ptr::null(),\n-                    };\n-                    let me = &node as *const Waiter as usize;\n-                    assert!(me & STATE_MASK == 0); // We assume pointers have 2 free bits that\n-                                                   // we can use for state.\n-\n-                    // Try to slide in the node at the head of the linked list.\n-                    // Run in a loop where we make sure the status is still RUNNING, and that\n-                    // another thread did not just replace the head of the linked list.\n-                    let mut old_head_and_status = state_and_queue;\n-                    loop {\n-                        if old_head_and_status & STATE_MASK != RUNNING {\n-                            return; // No need anymore to enqueue ourselves.\n-                        }\n-\n-                        node.next = (old_head_and_status & !STATE_MASK) as *const Waiter;\n-                        let old = self.state_and_queue.compare_and_swap(old_head_and_status,\n-                                                                        me | RUNNING,\n-                                                                        Ordering::Release);\n-                        if old == old_head_and_status {\n-                            break; // Success!\n-                        }\n-                        old_head_and_status = old;\n-                    }\n-\n-                    // We have enqueued ourselves, now lets wait.\n-                    // It is important not to return before being signaled, otherwise we would\n-                    // drop our `Waiter` node and leave a hole in the linked list (and a\n-                    // dangling reference). Guard against spurious wakeups by reparking\n-                    // ourselves until we are signaled.\n-                    while !node.signaled.load(Ordering::SeqCst) {\n-                        thread::park();\n-                    }\n+                    wait(&self.state_and_queue, state_and_queue);\n                     state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n                 }\n             }\n         }\n     }\n }\n \n+fn wait(state_and_queue: &AtomicUsize, current_state: usize) {\n+    // Create the node for our current thread that we are going to try to slot\n+    // in at the head of the linked list.\n+    let mut node = Waiter {\n+        thread: thread::current(),\n+        signaled: AtomicBool::new(false),\n+        next: ptr::null(),\n+    };\n+    let me = &node as *const Waiter as usize;\n+    assert!(me & STATE_MASK == 0); // We assume pointers have 2 free bits that\n+                                   // we can use for state.\n+\n+    // Try to slide in the node at the head of the linked list.\n+    // Run in a loop where we make sure the status is still RUNNING, and that\n+    // another thread did not just replace the head of the linked list.\n+    let mut old_head_and_status = current_state;\n+    loop {\n+        if old_head_and_status & STATE_MASK != RUNNING {\n+            return; // No need anymore to enqueue ourselves.\n+        }\n+\n+        node.next = (old_head_and_status & !STATE_MASK) as *const Waiter;\n+        let old = state_and_queue.compare_and_swap(old_head_and_status,\n+                                                   me | RUNNING,\n+                                                   Ordering::Release);\n+        if old == old_head_and_status {\n+            break; // Success!\n+        }\n+        old_head_and_status = old;\n+    }\n+\n+    // We have enqueued ourselves, now lets wait.\n+    // It is important not to return before being signaled, otherwise we would\n+    // drop our `Waiter` node and leave a hole in the linked list (and a\n+    // dangling reference). Guard against spurious wakeups by reparking\n+    // ourselves until we are signaled.\n+    while !node.signaled.load(Ordering::SeqCst) {\n+        thread::park();\n+    }\n+}\n+\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Once {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}]}