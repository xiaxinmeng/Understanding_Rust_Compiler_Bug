{"sha": "27822022016f0b701c4bfd851bf20ba29500ae1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ODIyMDIyMDE2ZjBiNzAxYzRiZmQ4NTFiZjIwYmEyOTUwMGFlMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T18:16:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T18:16:12Z"}, "message": "auto merge of #4891 : nikomatsakis/rust/region-syntax, r=nikomatsakis\n\nr? @graydon", "tree": {"sha": "59fee22941a7bdf6ffe5887f206498b2f5f3c05c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59fee22941a7bdf6ffe5887f206498b2f5f3c05c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27822022016f0b701c4bfd851bf20ba29500ae1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27822022016f0b701c4bfd851bf20ba29500ae1b", "html_url": "https://github.com/rust-lang/rust/commit/27822022016f0b701c4bfd851bf20ba29500ae1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27822022016f0b701c4bfd851bf20ba29500ae1b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad8a1f46566ddcd705cc918863cee2946d8b946", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad8a1f46566ddcd705cc918863cee2946d8b946", "html_url": "https://github.com/rust-lang/rust/commit/9ad8a1f46566ddcd705cc918863cee2946d8b946"}, {"sha": "d3f3d0731cb1c6050b540bc5542b575dd19844fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3f3d0731cb1c6050b540bc5542b575dd19844fa", "html_url": "https://github.com/rust-lang/rust/commit/d3f3d0731cb1c6050b540bc5542b575dd19844fa"}], "stats": {"total": 271, "additions": 203, "deletions": 68}, "files": [{"sha": "5fbd2ab67c29d45adfedf3dbcb63902b23889de8", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -7,7 +7,6 @@\n \n (require 'cm-mode)\n (require 'cc-mode)\n-(eval-when-compile (require 'cl))\n \n (defun rust-electric-brace (arg)\n   (interactive \"*P\")\n@@ -17,6 +16,12 @@\n                           '(font-lock-comment-face font-lock-string-face))))\n     (cm-indent)))\n \n+(defcustom rust-capitalized-idents-are-types t\n+  \"If non-nil, capitalized identifiers will be treated as types for the purposes of font-lock mode\"\n+  :type 'boolean\n+  :require 'rust-mode\n+  :group 'rust-mode)\n+\n (defvar rust-indent-unit 4)\n (defvar rust-syntax-table (let ((table (make-syntax-table)))\n                             (c-populate-syntax-table table)\n@@ -101,14 +106,7 @@\n            (rust-push-context st 'string (current-column) t)\n            (setf (rust-state-tokenize st) 'rust-token-string)\n            (rust-token-string st))\n-      (def ?\\' (forward-char)\n-           (setf rust-tcat 'atom)\n-           (let ((is-escape (eq (char-after) ?\\\\))\n-                 (start (point)))\n-             (if (not (rust-eat-until-unescaped ?\\'))\n-                 'font-lock-warning-face\n-               (if (or is-escape (= (point) (+ start 2)))\n-                   'font-lock-string-face 'font-lock-warning-face))))\n+      (def ?\\' (rust-single-quote))\n       (def ?/ (forward-char)\n            (case (char-after)\n              (?/ (end-of-line) 'font-lock-comment-face)\n@@ -122,12 +120,7 @@\n                  ((rust-eat-re \"[a-z_]+\") (setf rust-tcat 'macro)))\n            'font-lock-preprocessor-face)\n       (def ((?a . ?z) (?A . ?Z) ?_)\n-           (rust-eat-re \"[a-zA-Z_][a-zA-Z0-9_]*\")\n-           (setf rust-tcat 'ident)\n-           (if (and (eq (char-after) ?:) (eq (char-after (+ (point) 1)) ?:)\n-                    (not (eq (char-after (+ (point) 2)) ?:)))\n-               (progn (forward-char 2) 'font-lock-builtin-face)\n-             (match-string 0)))\n+           (rust-token-identifier))\n       (def ((?0 . ?9))\n            (rust-eat-re \"0x[0-9a-fA-F_]+\\\\|0b[01_]+\\\\|[0-9_]+\\\\(\\\\.[0-9_]+\\\\)?\\\\(e[+\\\\-]?[0-9_]+\\\\)?\")\n            (setf rust-tcat 'atom)\n@@ -150,6 +143,31 @@\n            (setf rust-tcat 'op) nil)\n       table)))\n \n+(defun rust-token-identifier ()\n+  (rust-eat-re \"[a-zA-Z_][a-zA-Z0-9_]*\")\n+  (setf rust-tcat 'ident)\n+  (if (and (eq (char-after) ?:) (eq (char-after (+ (point) 1)) ?:)\n+           (not (eq (char-after (+ (point) 2)) ?:)))\n+      (progn (forward-char 2) 'font-lock-builtin-face)\n+    (match-string 0)))\n+\n+(defun rust-single-quote ()\n+  (forward-char)\n+  (setf rust-tcat 'atom)\n+  ; Is this a lifetime?\n+  (if (or (looking-at \"[a-zA-Z_]$\")\n+          (looking-at \"[a-zA-Z_][^']\"))\n+      ; If what we see is 'abc, use font-lock-builtin-face:\n+      (progn (rust-eat-re \"[a-zA-Z_][a-zA-Z_0-9]*\")\n+             'font-lock-builtin-face)\n+    ; Otherwise, handle as a character constant:\n+    (let ((is-escape (eq (char-after) ?\\\\))\n+          (start (point)))\n+      (if (not (rust-eat-until-unescaped ?\\'))\n+          'font-lock-warning-face\n+        (if (or is-escape (= (point) (+ start 2)))\n+            'font-lock-string-face 'font-lock-warning-face)))))\n+\n (defun rust-token-base (st)\n   (funcall (char-table-range rust-char-table (char-after)) st))\n \n@@ -190,6 +208,10 @@\n   (dolist (cx (rust-state-context st))\n     (when (eq (rust-context-type cx) ?\\}) (return (rust-context-info cx)))))\n \n+(defun rust-is-capitalized (string)\n+  (let ((case-fold-search nil))\n+    (string-match-p \"[A-Z]\" string)))\n+\n (defun rust-token (st)\n   (let ((cx (car (rust-state-context st))))\n     (when (bolp)\n@@ -206,6 +228,8 @@\n         (setf tok (cond ((eq tok-id 'atom) 'font-lock-constant-face)\n                         (tok-id 'font-lock-keyword-face)\n                         ((equal (rust-state-last-token st) 'def) 'font-lock-function-name-face)\n+                        ((and rust-capitalized-idents-are-types\n+                              (rust-is-capitalized tok)) 'font-lock-type-face)\n                         (t nil))))\n       (when rust-tcat\n         (when (eq (rust-context-align cx) 'unset)"}, {"sha": "5fcc53a407bc9fa668334fffd8b8c5f44df57363", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -67,6 +67,12 @@ pub impl to_bytes::IterBytes for ident {\n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n \n+pub struct Lifetime {\n+    id: node_id,\n+    span: span,\n+    ident: ident\n+}\n+\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]"}, {"sha": "799f0d40a46171720fd070011ade8c43fd7ca452", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 128, "deletions": 28, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -307,12 +307,12 @@ pub impl Parser {\n     {\n         /*\n \n-        extern \"ABI\" [pure|unsafe] fn (S) -> T\n-               ^~~~^ ^~~~~~~~~~~~^    ^~^    ^\n-                 |     |               |     |\n-                 |     |               |   Return type\n-                 |     |             Argument types\n-                 |     |\n+        extern \"ABI\" [pure|unsafe] fn <'lt> (S) -> T\n+               ^~~~^ ^~~~~~~~~~~~^    ^~~~^ ^~^    ^\n+                 |     |                |    |     |\n+                 |     |                |    |   Return type\n+                 |     |                |  Argument types\n+                 |     |            Lifetimes\n                  |     |\n                  |   Purity\n                 ABI\n@@ -333,12 +333,12 @@ pub impl Parser {\n     {\n         /*\n \n-        (&|~|@) [r/] [pure|unsafe] [once] fn (S) -> T\n-        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~^    ^\n-           |     |     |             |        |     |\n-           |     |     |             |        |   Return type\n-           |     |     |             |      Argument types\n-           |     |     |             |\n+        (&|~|@) [r/] [pure|unsafe] [once] fn <'lt> (S) -> T\n+        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~~~^ ^~^    ^\n+           |     |     |             |         |    |     |\n+           |     |     |             |         |    |   Return type\n+           |     |     |             |         |  Argument types\n+           |     |     |             |     Lifetimes\n            |     |     |          Once-ness (a.k.a., affine)\n            |     |   Purity\n            | Lifetime bound\n@@ -394,12 +394,24 @@ pub impl Parser {\n     }\n \n     fn parse_ty_fn_decl() -> fn_decl {\n-        let inputs = do self.parse_unspanned_seq(\n-            token::LPAREN, token::RPAREN,\n-            seq_sep_trailing_disallowed(token::COMMA)) |p| {\n+        /*\n \n-            p.parse_arg_general(false)\n-        };\n+        (fn) <'lt> (S) -> T\n+             ^~~~^ ^~^    ^\n+               |    |     |\n+               |    |   Return type\n+               |  Argument types\n+           Lifetimes\n+\n+        */\n+        if self.eat(token::LT) {\n+            let _lifetimes = self.parse_lifetimes();\n+            self.expect(token::GT);\n+        }\n+        let inputs = self.parse_unspanned_seq(\n+            token::LPAREN, token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA),\n+            |p| p.parse_arg_general(false));\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ast::fn_decl { inputs: inputs, output: ret_ty, cf: ret_style }\n     }\n@@ -624,8 +636,13 @@ pub impl Parser {\n         sigil: ast::Sigil,\n         ctor: &fn(+v: mt) -> ty_) -> ty_\n     {\n-        // @foo/fn() or @fn() are parsed directly as fn types:\n+        // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match copy self.token {\n+            token::LIFETIME(rname) => {\n+                self.bump();\n+                return self.parse_ty_closure(Some(sigil), Some(rname));\n+            }\n+\n             token::IDENT(rname, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n                     self.token_is_closure_keyword(self.look_ahead(2u))\n@@ -648,8 +665,13 @@ pub impl Parser {\n     }\n \n     fn parse_borrowed_pointee() -> ty_ {\n-        // look for `&foo/` and interpret `foo` as the region name:\n-        let rname = match copy self.token {\n+        // look for `&'lt` or `&foo/` and interpret `foo` as the region name:\n+        let rname = match self.token {\n+            token::LIFETIME(sid) => {\n+                self.bump();\n+                Some(sid)\n+            }\n+\n             token::IDENT(sid, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.bump(); self.bump();\n@@ -658,6 +680,7 @@ pub impl Parser {\n                     None\n                 }\n             }\n+\n             _ => { None }\n         };\n \n@@ -890,22 +913,95 @@ pub impl Parser {\n             }\n         };\n \n-        // Parse any type parameters which may appear:\n+        // Parse any lifetime or type parameters which may appear:\n         let tps = {\n-            if self.token == token::LT {\n-                self.parse_seq_lt_gt(Some(token::COMMA),\n-                                     |p| p.parse_ty(false))\n+            if !self.eat(token::LT) {\n+                ~[]\n             } else {\n-                codemap::spanned {node: ~[], span: path.span}\n+                // First consume lifetimes.\n+                let _lifetimes = self.parse_lifetimes();\n+                let result = self.parse_seq_to_gt(\n+                    Some(token::COMMA),\n+                    |p| p.parse_ty(false));\n+                result\n             }\n         };\n \n-        @ast::path { span: mk_sp(lo, tps.span.hi),\n+        let hi = self.span.lo;\n+\n+        @ast::path { span: mk_sp(lo, hi),\n                      rp: rp,\n-                     types: tps.node,\n+                     types: tps,\n                      .. *path }\n     }\n \n+    fn parse_opt_lifetime() -> Option<ast::Lifetime> {\n+        /*!\n+         *\n+         * Parses 0 or 1 lifetime.\n+         */\n+\n+        match self.token {\n+            token::LIFETIME(_) => {\n+                Some(self.parse_lifetime())\n+            }\n+            _ => {\n+                None\n+            }\n+        }\n+    }\n+\n+    fn parse_lifetime() -> ast::Lifetime {\n+        /*!\n+         *\n+         * Parses a single lifetime.\n+         */\n+\n+        match self.token {\n+            token::LIFETIME(i) => {\n+                self.bump();\n+                return ast::Lifetime {\n+                    id: self.get_id(),\n+                    span: self.span,\n+                    ident: i\n+                };\n+            }\n+            _ => {\n+                self.fatal(fmt!(\"Expected a lifetime name\"));\n+            }\n+        }\n+    }\n+\n+    fn parse_lifetimes() -> ~[ast::Lifetime] {\n+        /*!\n+         *\n+         * Parses zero or more comma separated lifetimes.\n+         * Expects each lifetime to be followed by either\n+         * a comma or `>`.  Used when parsing type parameter\n+         * lists, where we expect something like `<'a, 'b, T>`.\n+         */\n+\n+        let mut res = ~[];\n+        loop {\n+            match self.token {\n+                token::LIFETIME(_) => {\n+                    res.push(self.parse_lifetime());\n+                }\n+                _ => {\n+                    return res;\n+                }\n+            }\n+\n+            match self.token {\n+                token::COMMA => { self.bump();}\n+                token::GT => { return res; }\n+                _ => {\n+                    self.fatal(~\"expected `,` or `>` after lifetime name\");\n+                }\n+            }\n+        }\n+    }\n+\n     fn parse_mutability() -> mutability {\n         if self.eat_keyword(~\"mut\") {\n             m_mutbl\n@@ -1424,6 +1520,7 @@ pub impl Parser {\n               }\n               token::AND => {\n                 self.bump();\n+                let _lt = self.parse_opt_lifetime();\n                 let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n@@ -2574,7 +2671,10 @@ pub impl Parser {\n \n     fn parse_ty_params() -> ~[ty_param] {\n         if self.eat(token::LT) {\n-            self.parse_seq_to_gt(Some(token::COMMA), |p| p.parse_ty_param())\n+            let _lifetimes = self.parse_lifetimes();\n+            self.parse_seq_to_gt(\n+                Some(token::COMMA),\n+                |p| p.parse_ty_param())\n         } else { ~[] }\n     }\n "}, {"sha": "7f2140d96e16c55b686730916fb781d17c3d41a6", "filename": "src/test/compile-fail/regions-addr-of-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n fn foo(a: int) {\n-    let _p: &static/int = &a; //~ ERROR illegal borrow\n+    let _p: &'static int = &a; //~ ERROR illegal borrow\n }\n \n fn bar(a: int) {\n-    let _q: &blk/int = &a;\n+    let _q: &'blk int = &a;\n }\n \n fn main() {"}, {"sha": "cf026785420d7a0c99d2f152a762b9e4a1478039", "filename": "src/test/compile-fail/regions-addr-of-upvar-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -15,7 +15,7 @@ struct dog {\n impl dog {\n     fn chase_cat() {\n         for uint::range(0u, 10u) |_i| {\n-            let p: &static/mut uint = &mut self.food; //~ ERROR illegal borrow\n+            let p: &'static mut uint = &mut self.food; //~ ERROR illegal borrow\n             *p = 3u;\n         }\n     }"}, {"sha": "47ddbf38e3de19b2782a2f981a53ed1b7305cc59", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -13,8 +13,10 @@\n // checked.\n \n enum an_enum = &int;\n-trait a_trait { fn foo() -> &self/int; }\n-struct a_class { x:&self/int }\n+trait a_trait {\n+    fn foo() -> &'self int;\n+}\n+struct a_class { x:&'self int }\n \n fn a_fn1(e: an_enum/&a) -> an_enum/&b {\n     return e; //~ ERROR mismatched types: expected `an_enum/&b` but found `an_enum/&a`"}, {"sha": "b399ef8a747f9a520ee8102af17532c807916805", "filename": "src/test/compile-fail/regions-in-enums.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -8,16 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum yes0 {\n-    x3(&uint)\n+enum yes0<'lt> {\n+    // This will eventually be legal (and in fact the only way):\n+    X3(&'lt uint) //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n }\n \n enum yes1 {\n-    x4(&self/uint)\n+    X4(&'self uint)\n }\n \n enum yes2 {\n-    x5(&foo/uint) //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n+    X5(&'foo uint) //~ ERROR named regions other than `self` are not allowed as part of a type declaration\n }\n \n fn main() {}"}, {"sha": "063bc32f7b446bb2005bc2e4cc0042426ed3dfe2", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -10,13 +10,13 @@\n \n fn with<T>(t: T, f: fn(T)) { f(t) }\n \n-fn nested(x: &x/int) {  // (1)\n+fn nested<'x>(x: &'x int) {  // (1)\n     do with(\n-        fn&(x: &x/int, // Refers to the region `x` at (1)\n-            y: &y/int, // A fresh region `y` (2)\n-            z: fn(x: &x/int, // Refers to `x` at (1)\n-                  y: &y/int, // Refers to `y` at (2)\n-                  z: &z/int) -> &z/int) // A fresh region `z` (3)\n+        fn&(x: &'x int, // Refers to the region `x` at (1)\n+            y: &'y int, // A fresh region `y` (2)\n+            z: fn<'z>(x: &'x int, // Refers to `x` at (1)\n+                      y: &'y int, // Refers to `y` at (2)\n+                      z: &'z int) -> &'z int) // A fresh region `z` (3)\n             -> &x/int {\n \n             if false { return z(x, y, x); }\n@@ -29,13 +29,13 @@ fn nested(x: &x/int) {  // (1)\n         }\n     ) |foo| {\n \n-        let a: &x/int = foo(x, x, |_x, _y, z| z );\n-        let b: &x/int = foo(x, a, |_x, _y, z| z );\n-        let c: &x/int = foo(a, a, |_x, _y, z| z );\n+        let a: &'x int = foo(x, x, |_x, _y, z| z );\n+        let b: &'x int = foo(x, a, |_x, _y, z| z );\n+        let c: &'x int = foo(a, a, |_x, _y, z| z );\n \n         let z = 3i;\n-        let d: &x/int = foo(x, x, |_x, _y, z| z );\n-        let e: &x/int = foo(x, &z, |_x, _y, z| z );\n+        let d: &'x int = foo(x, x, |_x, _y, z| z );\n+        let e: &'x int = foo(x, &z, |_x, _y, z| z );\n \n         // This would result in an error, but it is not reported by typeck\n         // anymore but rather borrowck. Therefore, it doesn't end up"}, {"sha": "22eec65b02a074c2c7213cddeb23b53c3ec39503", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27822022016f0b701c4bfd851bf20ba29500ae1b/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=27822022016f0b701c4bfd851bf20ba29500ae1b", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Clam { chowder: &int }\n+struct Clam<'self> {\n+    chowder: &'self int\n+}\n \n-trait get_chowder {\n-    fn get_chowder() -> &self/int;\n+trait get_chowder<'self> {\n+    fn get_chowder() -> &'self int;\n }\n \n-impl get_chowder for Clam {\n-    fn get_chowder() -> &self/int { return self.chowder; }\n+impl<'self> get_chowder<'self> for Clam<'self> {\n+    fn get_chowder() -> &'self int { return self.chowder; }\n }\n \n pub fn main() {"}]}