{"sha": "9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliM2Y5ZDk0NDQxMzQwZjBjZGY2ZWM1OWFhYjczOWJhZWYwZjFhYzA=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-25T17:07:37Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-07-02T16:27:12Z"}, "message": "Change exhaustiveness analysis to permit multiple constructors per pattern\n\nSlice patterns are different from the rest in that a single slice pattern\ndoes not have a distinct constructor if it contains a variable-length subslice\npattern. For example, the pattern [a, b, ..tail] can match a slice of length 2, 3, 4\nand so on.\n\nAs a result, the decision tree for exhaustiveness and redundancy analysis should\nexplore each of those constructors separately to determine if the pattern could be useful\nwhen specialized for any of them.", "tree": {"sha": "e8ba6e275bab9b3d873fc2b654111b5308a8d774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8ba6e275bab9b3d873fc2b654111b5308a8d774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "html_url": "https://github.com/rust-lang/rust/commit/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/comments", "author": null, "committer": null, "parents": [{"sha": "ca2778ede7c21efc3cf2e4e1152875ec09360770", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2778ede7c21efc3cf2e4e1152875ec09360770", "html_url": "https://github.com/rust-lang/rust/commit/ca2778ede7c21efc3cf2e4e1152875ec09360770"}], "stats": {"total": 617, "additions": 413, "deletions": 204}, "files": [{"sha": "1400e207ab1a8615f73416d3fd7a7227bea279a1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 290, "deletions": 198, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_camel_case_types)]\n-\n use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil, const_val};\n use middle::const_eval::{eval_const_expr, lookup_const_by_id};\n use middle::def::*;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n-\n+use std::fmt;\n use std::gc::{Gc, GC};\n-use std::iter;\n+use std::iter::AdditiveIterator;\n+use std::iter::range_inclusive;\n use syntax::ast::*;\n use syntax::ast_util::{is_unguarded, walk_pat};\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n@@ -28,7 +27,71 @@ use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use util::ppaux::ty_to_str;\n \n-type Matrix = Vec<Vec<Gc<Pat>>>;\n+struct Matrix(Vec<Vec<Gc<Pat>>>);\n+\n+/// Pretty-printer for matrices of patterns, example:\n+/// ++++++++++++++++++++++++++\n+/// + _     + []             +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [First]        +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [Second(true)] +\n+/// ++++++++++++++++++++++++++\n+/// + false + [_]            +\n+/// ++++++++++++++++++++++++++\n+/// + _     + [_, _, ..tail] +\n+/// ++++++++++++++++++++++++++\n+impl fmt::Show for Matrix {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"\\n\"));\n+\n+        let &Matrix(ref m) = self;\n+        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n+            row.iter().map(|&pat| pat_to_str(pat)).collect::<Vec<String>>()\n+        }).collect();\n+\n+        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n+        assert!(m.iter().all(|row| row.len() == column_count));\n+        let column_widths: Vec<uint> = range(0, column_count).map(|col| {\n+            pretty_printed_matrix.iter().map(|row| row.get(col).len()).max().unwrap_or(0u)\n+        }).collect();\n+\n+        let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n+        let br = String::from_char(total_width, '+');\n+        try!(write!(f, \"{}\\n\", br));\n+        for row in pretty_printed_matrix.move_iter() {\n+            try!(write!(f, \"+\"));\n+            for (column, pat_str) in row.move_iter().enumerate() {\n+                try!(write!(f, \" \"));\n+                f.width = Some(*column_widths.get(column));\n+                try!(f.pad(pat_str.as_slice()));\n+                try!(write!(f, \" +\"));\n+            }\n+            try!(write!(f, \"\\n\"));\n+            try!(write!(f, \"{}\\n\", br));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+struct MatchCheckCtxt<'a> {\n+    tcx: &'a ty::ctxt\n+}\n+\n+#[deriving(Clone, PartialEq)]\n+enum Constructor {\n+    /// The constructor of all patterns that don't vary by constructor,\n+    /// e.g. struct patterns and fixed-length arrays.\n+    Single,\n+    /// Enum variants.\n+    Variant(DefId),\n+    /// Literal values.\n+    ConstantValue(const_val),\n+    /// Ranges of literal values (2..5).\n+    ConstantRange(const_val, const_val),\n+    /// Array patterns of length n.\n+    Slice(uint)\n+}\n \n #[deriving(Clone)]\n enum Usefulness {\n@@ -50,22 +113,6 @@ impl Usefulness {\n     }\n }\n \n-fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n-    ty::with_path(tcx, id, |mut path| Path {\n-        global: false,\n-        segments: path.last().map(|elem| PathSegment {\n-            identifier: Ident::new(elem.name()),\n-            lifetimes: vec!(),\n-            types: OwnedSlice::empty()\n-        }).move_iter().collect(),\n-        span: DUMMY_SP,\n-    })\n-}\n-\n-struct MatchCheckCtxt<'a> {\n-    tcx: &'a ty::ctxt,\n-}\n-\n impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n@@ -78,11 +125,8 @@ impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &Crate) {\n-    let mut cx = MatchCheckCtxt {\n-        tcx: tcx,\n-    };\n+pub fn check_crate(tcx: &ty::ctxt, krate: &Crate) {\n+    let mut cx = MatchCheckCtxt { tcx: tcx, };\n \n     visit::walk_crate(&mut cx, krate, ());\n \n@@ -116,12 +160,12 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                // If the type *is* empty, it's vacuously exhaustive\n                return;\n             }\n-            let m: Matrix = arms\n+            let m: Matrix = Matrix(arms\n                 .iter()\n                 .filter(|&arm| is_unguarded(arm))\n                 .flat_map(|arm| arm.pats.iter())\n                 .map(|pat| vec!(pat.clone()))\n-                .collect();\n+                .collect());\n             check_exhaustive(cx, ex.span, &m);\n         },\n         _ => ()\n@@ -130,7 +174,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n \n // Check for unreachable patterns\n fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    let mut seen = Vec::new();\n+    let mut seen = Matrix(vec!());\n     for arm in arms.iter() {\n         for pat in arm.pats.iter() {\n             // Check that we do not match against a static NaN (#6804)\n@@ -161,7 +205,11 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 NotUseful => cx.tcx.sess.span_err(pat.span, \"unreachable pattern\"),\n                 _ => ()\n             }\n-            if arm.guard.is_none() { seen.push(v); }\n+            if arm.guard.is_none() {\n+                let Matrix(mut rows) = seen;\n+                rows.push(v);\n+                seen = Matrix(rows);\n+            }\n         }\n     }\n }\n@@ -175,10 +223,6 @@ fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n \n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n     match is_useful(cx, m, [wild()], ConstructWitness) {\n-        NotUseful => {\n-            // This is good, wildcard pattern isn't reachable\n-            return;\n-        }\n         Useful(pats) => {\n             let witness = match pats.as_slice() {\n                 [witness] => witness,\n@@ -188,38 +232,58 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n             let msg = format!(\"non-exhaustive patterns: `{0}` not covered\", pat_to_str(&*witness));\n             cx.tcx.sess.span_err(sp, msg.as_slice());\n         }\n+        NotUseful => {\n+            // This is good, wildcard pattern isn't reachable\n+        }\n     }\n }\n \n-#[deriving(Clone, PartialEq)]\n-enum ctor {\n-    single,\n-    variant(DefId),\n-    val(const_val),\n-    range(const_val, const_val),\n-    vec(uint)\n-}\n-\n fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n     let node = match value {\n         &const_bool(b) => LitBool(b),\n         &const_nil => LitNil,\n         _ => unreachable!()\n     };\n-    box(GC) Expr {\n+    box (GC) Expr {\n         id: 0,\n         node: ExprLit(box(GC) Spanned { node: node, span: DUMMY_SP }),\n         span: DUMMY_SP\n     }\n }\n \n-fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty: ty::t) -> Gc<Pat> {\n-    let pat = match ty::get(lty).sty {\n+fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n+    ty::with_path(tcx, id, |mut path| Path {\n+        global: false,\n+        segments: path.last().map(|elem| PathSegment {\n+            identifier: Ident::new(elem.name()),\n+            lifetimes: vec!(),\n+            types: OwnedSlice::empty()\n+        }).move_iter().collect(),\n+        span: DUMMY_SP,\n+    })\n+}\n+\n+/// Constructs a partial witness for a pattern given a list of\n+/// patterns expanded by the specialization step.\n+///\n+/// When a pattern P is discovered to be useful, this function is used bottom-up\n+/// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n+/// of values, V, where each value in that set is not covered by any previously\n+/// used patterns and is covered by the pattern P'. Examples:\n+///\n+/// left_ty: tuple of 3 elements\n+/// pats: [10, 20, _]           => (10, 20, _)\n+///\n+/// left_ty: struct X { a: (bool, &'static str), b: uint}\n+/// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n+                     pats: Vec<Gc<Pat>>, left_ty: ty::t) -> Gc<Pat> {\n+    let pat = match ty::get(left_ty).sty {\n         ty::ty_tup(_) => PatTup(pats),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n-                &variant(vid) => (vid,\n+                &Variant(vid) => (vid,\n                     ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n                 _ => (cid, true)\n             };\n@@ -235,103 +299,95 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty:\n             } else {\n                 PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n             }\n-        },\n+        }\n \n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => {\n             match ty::get(ty).sty {\n+               ty::ty_vec(_, Some(n)) => match ctor {\n+                    &Single => {\n+                        assert_eq!(pats.len(), n);\n+                        PatVec(pats, None, vec!())\n+                    },\n+                    _ => unreachable!()\n+                },\n                 ty::ty_vec(_, None) => match ctor {\n-                    &vec(_) => PatVec(pats, None, vec!()),\n+                    &Slice(n) => {\n+                        assert_eq!(pats.len(), n);\n+                        PatVec(pats, None, vec!())\n+                    },\n                     _ => unreachable!()\n                 },\n                 ty::ty_str => PatWild,\n+\n                 _ => {\n                     assert_eq!(pats.len(), 1);\n                     PatRegion(pats.get(0).clone())\n                 }\n             }\n-        },\n+        }\n \n         ty::ty_box(_) => {\n             assert_eq!(pats.len(), 1);\n             PatBox(pats.get(0).clone())\n-        },\n+        }\n+\n+        ty::ty_vec(_, Some(len)) => {\n+            assert_eq!(pats.len(), len);\n+            PatVec(pats, None, vec!())\n+        }\n \n         _ => {\n-            match ctor {\n-                &vec(_) => PatVec(pats, None, vec!()),\n-                &val(ref v) => PatLit(const_val_to_expr(v)),\n+            match *ctor {\n+                ConstantValue(ref v) => PatLit(const_val_to_expr(v)),\n                 _ => PatWild\n             }\n         }\n     };\n \n-    box(GC) Pat {\n+    box (GC) Pat {\n         id: 0,\n         node: pat,\n         span: DUMMY_SP\n     }\n }\n \n-fn missing_constructor(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Option<ctor> {\n-    let used_constructors: Vec<ctor> = m.iter()\n-        .filter_map(|r| pat_ctor_id(cx, left_ty, *r.get(0)))\n+fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n+                       left_ty: ty::t, max_slice_length: uint) -> Option<Constructor> {\n+    let used_constructors: Vec<Constructor> = rows.iter()\n+        .flat_map(|row| pat_constructors(cx, *row.get(0), left_ty, max_slice_length).move_iter())\n         .collect();\n-\n-    all_constructors(cx, m, left_ty)\n+    all_constructors(cx, left_ty, max_slice_length)\n         .move_iter()\n         .find(|c| !used_constructors.contains(c))\n }\n \n-fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor> {\n-    // This produces a list of all vector constructors that we would expect to appear\n-    // in an exhaustive set of patterns. Because such a list would normally be infinite,\n-    // we narrow it down to only those constructors that actually appear in the inspected\n-    // column, plus, any that are missing and not covered by a pattern with a destructured slice.\n-    fn vec_constructors(m: &Matrix) -> Vec<ctor> {\n-        let max_vec_len = m.iter().map(|r| match r.get(0).node {\n-            PatVec(ref before, _, ref after) => before.len() + after.len(),\n-            _ => 0u\n-        }).max().unwrap_or(0u);\n-        let min_vec_len_with_slice = m.iter().map(|r| match r.get(0).node {\n-            PatVec(ref before, Some(_), ref after) => before.len() + after.len(),\n-            _ => max_vec_len + 1\n-        }).min().unwrap_or(max_vec_len + 1);\n-        let other_lengths = m.iter().map(|r| match r.get(0).node {\n-            PatVec(ref before, _, ref after) => before.len() + after.len(),\n-            _ => 0u\n-        }).filter(|&len| len > min_vec_len_with_slice);\n-        iter::range_inclusive(0u, min_vec_len_with_slice)\n-            .chain(other_lengths)\n-            .map(|len| vec(len))\n-            .collect()\n-    }\n-\n+/// This determines the set of all possible constructors of a pattern matching\n+/// values of type `left_ty`. For vectors, this would normally be an infinite set\n+/// but is instead bounded by the maximum fixed length of slice patterns in\n+/// the column of patterns being analyzed.\n+fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n+                    max_slice_length: uint) -> Vec<Constructor> {\n     match ty::get(left_ty).sty {\n         ty::ty_bool =>\n-            [true, false].iter().map(|b| val(const_bool(*b))).collect(),\n+            [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n         ty::ty_nil =>\n-            vec!(val(const_nil)),\n+            vec!(ConstantValue(const_nil)),\n \n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n-            ty::ty_vec(_, None) => vec_constructors(m),\n-            _ => vec!(single)\n+            ty::ty_vec(_, None) =>\n+                range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n+            _ => vec!(Single)\n         },\n \n         ty::ty_enum(eid, _) =>\n             ty::enum_variants(cx.tcx, eid)\n                 .iter()\n-                .map(|va| variant(va.id))\n+                .map(|va| Variant(va.id))\n                 .collect(),\n \n-        ty::ty_vec(_, None) =>\n-            vec_constructors(m),\n-\n-        ty::ty_vec(_, Some(n)) =>\n-            vec!(vec(n)),\n-\n         _ =>\n-            vec!(single)\n+            vec!(Single)\n     }\n }\n \n@@ -348,15 +404,16 @@ fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n-             witness: WitnessPreference) -> Usefulness {\n-    if m.len() == 0u {\n+fn is_useful(cx: &MatchCheckCtxt, m @ &Matrix(ref rows): &Matrix,\n+             v: &[Gc<Pat>], witness: WitnessPreference) -> Usefulness {\n+    debug!(\"{:}\", m);\n+    if rows.len() == 0u {\n         return Useful(vec!());\n     }\n-    if m.get(0).len() == 0u {\n+    if rows.get(0).len() == 0u {\n         return NotUseful;\n     }\n-    let real_pat = match m.iter().find(|r| r.get(0).id != 0) {\n+    let real_pat = match rows.iter().find(|r| r.get(0).id != 0) {\n         Some(r) => {\n             match r.get(0).node {\n                 // An arm of the form `ref x @ sub_pat` has type\n@@ -374,10 +431,16 @@ fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n         ty::pat_ty(cx.tcx, &*real_pat)\n     };\n \n-    match pat_ctor_id(cx, left_ty, v[0]) {\n-        None => match missing_constructor(cx, m, left_ty) {\n+    let max_slice_length = rows.iter().filter_map(|row| match row.get(0).node {\n+        PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n+        _ => None\n+    }).max().map_or(0, |v| v + 1);\n+\n+    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n+    if constructors.is_empty() {\n+        match missing_constructor(cx, m, left_ty, max_slice_length) {\n             None => {\n-                all_constructors(cx, m, left_ty).move_iter().filter_map(|c| {\n+                all_constructors(cx, left_ty, max_slice_length).move_iter().filter_map(|c| {\n                     is_useful_specialized(cx, m, v, c.clone(),\n                                           left_ty, witness).useful().map(|pats| {\n                         Useful(match witness {\n@@ -400,79 +463,98 @@ fn is_useful(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n                 }).nth(0).unwrap_or(NotUseful)\n             },\n \n-            Some(ctor) => {\n-                let matrix = m.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n+            Some(constructor) => {\n+                let matrix = Matrix(rows.iter().filter_map(|r|\n+                    default(cx, r.as_slice())).collect());\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     Useful(pats) => Useful(match witness {\n                         ConstructWitness => {\n-                            let arity = constructor_arity(cx, &ctor, left_ty);\n+                            let arity = constructor_arity(cx, &constructor, left_ty);\n                             let wild_pats = Vec::from_elem(arity, wild());\n-                            let enum_pat = construct_witness(cx, &ctor, wild_pats, left_ty);\n+                            let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                             (vec!(enum_pat)).append(pats.as_slice())\n                         }\n                         LeaveOutWitness => vec!()\n                     }),\n                     result => result\n                 }\n             }\n-        },\n-\n-        Some(v0_ctor) => is_useful_specialized(cx, m, v, v0_ctor, left_ty, witness)\n+        }\n+    } else {\n+        constructors.move_iter().filter_map(|c| {\n+            is_useful_specialized(cx, m, v, c.clone(), left_ty, witness)\n+                .useful().map(|pats| Useful(pats))\n+        }).nth(0).unwrap_or(NotUseful)\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt, m: &Matrix, v: &[Gc<Pat>],\n-                         ctor: ctor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n+fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix, v: &[Gc<Pat>],\n+                         ctor: Constructor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n-    let matrix = m.iter().filter_map(|r| {\n+    let matrix = Matrix(m.iter().filter_map(|r| {\n         specialize(cx, r.as_slice(), &ctor, arity)\n-    }).collect();\n+    }).collect());\n     match specialize(cx, v, &ctor, arity) {\n         Some(v) => is_useful(cx, &matrix, v.as_slice(), witness),\n         None => NotUseful\n     }\n }\n \n-fn pat_ctor_id(cx: &MatchCheckCtxt, left_ty: ty::t, p: Gc<Pat>) -> Option<ctor> {\n+/// Determines the constructors that the given pattern can be specialized to.\n+///\n+/// In most cases, there's only one constructor that a specific pattern\n+/// represents, such as a specific enum variant or a specific literal value.\n+/// Slice patterns, however, can match slices of different lengths. For instance,\n+/// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n+///\n+/// On the other hand, a wild pattern and an identifier pattern cannot be\n+/// specialized in any way.\n+fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n+                    left_ty: ty::t, max_slice_length: uint) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n         PatIdent(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefStatic(did, false)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                    vec!(ConstantValue(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n-                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-                _ => None\n+                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                _ => vec!()\n             },\n         PatEnum(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefStatic(did, false)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n-                    Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n+                    vec!(ConstantValue(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n-                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-                _ => Some(single)\n+                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                _ => vec!(Single)\n             },\n         PatStruct(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n-                _ => Some(single)\n+                Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n+                _ => vec!(Single)\n             },\n         PatLit(expr) =>\n-            Some(val(eval_const_expr(cx.tcx, &*expr))),\n+            vec!(ConstantValue(eval_const_expr(cx.tcx, &*expr))),\n         PatRange(lo, hi) =>\n-            Some(range(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n-        PatVec(ref before, _, ref after) => match ty::get(left_ty).sty {\n-            ty::ty_vec(_, Some(n)) =>\n-                Some(vec(n)),\n-            _ =>\n-                Some(vec(before.len() + after.len()))\n-        },\n+            vec!(ConstantRange(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n+        PatVec(ref before, ref slice, ref after) =>\n+            match ty::get(left_ty).sty {\n+                ty::ty_vec(_, Some(_)) => vec!(Single),\n+                _                      => if slice.is_some() {\n+                    range_inclusive(before.len() + after.len(), max_slice_length)\n+                        .map(|length| Slice(length))\n+                        .collect()\n+                } else {\n+                    vec!(Slice(before.len() + after.len()))\n+                }\n+            },\n         PatBox(_) | PatTup(_) | PatRegion(..) =>\n-            Some(single),\n+            vec!(Single),\n         PatWild | PatWildMulti =>\n-            None,\n+            vec!(),\n         PatMac(_) =>\n             cx.tcx.sess.bug(\"unexpanded macro\")\n     }\n@@ -482,53 +564,53 @@ fn is_wild(cx: &MatchCheckCtxt, p: Gc<Pat>) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n         PatWild | PatWildMulti => true,\n-        PatIdent(_, _, _) => {\n+        PatIdent(_, _, _) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => false,\n                 _ => true\n-            }\n-        }\n+            },\n+        PatVec(ref before, Some(_), ref after) =>\n+            before.is_empty() && after.is_empty(),\n         _ => false\n     }\n }\n \n-fn constructor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n+/// This computes the arity of a constructor. The arity of a constructor\n+/// is how many subpattern patterns of that constructor should be expanded to.\n+///\n+/// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n+/// A struct pattern's arity is the number of fields it contains, etc.\n+fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_box(_) | ty::ty_uniq(_) => 1u,\n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) => match *ctor {\n-                vec(n) => n,\n-                _ => 0u\n+                Slice(length) => length,\n+                _ => unreachable!()\n             },\n             ty::ty_str => 0u,\n             _ => 1u\n         },\n         ty::ty_enum(eid, _) => {\n             match *ctor {\n-                variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                Variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n         ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-        ty::ty_vec(_, _) => match *ctor {\n-            vec(n) => n,\n-            _ => 0u\n-        },\n+        ty::ty_vec(_, Some(n)) => n,\n         _ => 0u\n     }\n }\n \n-fn wild() -> Gc<Pat> {\n-    box(GC) Pat {id: 0, node: PatWild, span: DUMMY_SP}\n-}\n-\n-fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val) -> Option<bool> {\n-    let (c_from, c_to) = match *ctor_id {\n-        val(ref value)          => (value, value),\n-        range(ref from, ref to) => (from, to),\n-        single                  => return Some(true),\n-        _                       => unreachable!()\n+fn range_covered_by_constructor(ctor: &Constructor,\n+                                from: &const_val,to: &const_val) -> Option<bool> {\n+    let (c_from, c_to) = match *ctor {\n+        ConstantValue(ref value)        => (value, value),\n+        ConstantRange(ref from, ref to) => (from, to),\n+        Single                          => return Some(true),\n+        _                               => unreachable!()\n     };\n     let cmp_from = compare_const_vals(c_from, from);\n     let cmp_to = compare_const_vals(c_to, to);\n@@ -538,34 +620,42 @@ fn range_covered_by_constructor(ctor_id: &ctor, from: &const_val, to: &const_val\n     }\n }\n \n+/// This is the main specialization step. It expands the first pattern in the given row\n+/// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n+/// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n+///\n+/// OTOH, slice patterns with a subslice pattern (..tail) can be expanded into multiple\n+/// different patterns.\n+/// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+/// fields filled with wild patterns.\n fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n-              ctor_id: &ctor, arity: uint) -> Option<Vec<Gc<Pat>>> {\n+              constructor: &Constructor, arity: uint) -> Option<Vec<Gc<Pat>>> {\n     let &Pat {\n-        id: ref pat_id, node: ref n, span: ref pat_span\n+        id: pat_id, node: ref node, span: pat_span\n     } = &(*raw_pat(r[0]));\n-    let head: Option<Vec<Gc<Pat>>> = match n {\n-        &PatWild => {\n-            Some(Vec::from_elem(arity, wild()))\n-        }\n-        &PatWildMulti => {\n-            Some(Vec::from_elem(arity, wild()))\n-        }\n+    let head: Option<Vec<Gc<Pat>>> = match node {\n+        &PatWild =>\n+            Some(Vec::from_elem(arity, wild())),\n+\n+        &PatWildMulti =>\n+            Some(Vec::from_elem(arity, wild())),\n+\n         &PatIdent(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n+            let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n             match opt_def {\n-                Some(DefVariant(_, id, _)) => if *ctor_id == variant(id) {\n+                Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n                     Some(vec!())\n                 } else {\n                     None\n                 },\n                 Some(DefStatic(did, _)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                    match range_covered_by_constructor(constructor, &e_v, &e_v) {\n                         Some(true) => Some(vec!()),\n                         Some(false) => None,\n                         None => {\n-                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                            cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                             None\n                         }\n                     }\n@@ -575,22 +665,23 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 }\n             }\n         }\n+\n         &PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             match def {\n                 DefStatic(did, _) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     let e_v = eval_const_expr(cx.tcx, &*const_expr);\n-                    match range_covered_by_constructor(ctor_id, &e_v, &e_v) {\n+                    match range_covered_by_constructor(constructor, &e_v, &e_v) {\n                         Some(true) => Some(vec!()),\n                         Some(false) => None,\n                         None => {\n-                            cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                            cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                             None\n                         }\n                     }\n                 }\n-                DefVariant(_, id, _) if *ctor_id != variant(id) => None,\n+                DefVariant(_, id, _) if *constructor != Variant(id) => None,\n                 DefVariant(..) | DefFn(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.clone(),\n@@ -603,9 +694,9 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n \n         &PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n+            let def = cx.tcx.def_map.borrow().get_copy(&pat_id);\n             let class_id = match def {\n-                DefVariant(_, variant_id, _) => if *ctor_id == variant(variant_id) {\n+                DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {\n                     Some(variant_id)\n                 } else {\n                     None\n@@ -633,11 +724,11 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n \n         &PatLit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &**expr);\n-            match range_covered_by_constructor(ctor_id, &expr_value, &expr_value) {\n+            match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec!()),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -646,41 +737,42 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n         &PatRange(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &**from);\n             let to_value = eval_const_expr(cx.tcx, &**to);\n-            match range_covered_by_constructor(ctor_id, &from_value, &to_value) {\n+            match range_covered_by_constructor(constructor, &from_value, &to_value) {\n                 Some(true) => Some(vec!()),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(*pat_span, \"mismatched types between arms\");\n+                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n                     None\n                 }\n             }\n         }\n \n         &PatVec(ref before, ref slice, ref after) => {\n-            match *ctor_id {\n-                vec(_) => {\n-                    let num_elements = before.len() + after.len();\n-                    if num_elements < arity && slice.is_some() {\n-                        let mut result = Vec::new();\n-                        result.push_all(before.as_slice());\n-                        result.grow_fn(arity - num_elements, |_| wild());\n-                        result.push_all(after.as_slice());\n-                        Some(result)\n-                    } else if num_elements == arity {\n-                        let mut result = Vec::new();\n-                        result.push_all(before.as_slice());\n-                        result.push_all(after.as_slice());\n-                        Some(result)\n-                    } else {\n-                        None\n-                    }\n-                }\n+            match *constructor {\n+                // Fixed-length vectors.\n+                Single => {\n+                    let mut pats = before.clone();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n+                    pats.push_all(after.as_slice());\n+                    Some(pats)\n+                },\n+                Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n+                    let mut pats = before.clone();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n+                    pats.push_all(after.as_slice());\n+                    Some(pats)\n+                },\n+                Slice(length) if before.len() + after.len() == length => {\n+                    let mut pats = before.clone();\n+                    pats.push_all(after.as_slice());\n+                    Some(pats)\n+                },\n                 _ => None\n             }\n         }\n \n         &PatMac(_) => {\n-            cx.tcx.sess.span_err(*pat_span, \"unexpanded macro\");\n+            cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n             None\n         }\n     };\n@@ -740,7 +832,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n }\n \n fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n-    let pats = vec!(vec!(pat));\n+    let pats = Matrix(vec!(vec!(pat)));\n     is_useful(cx, &pats, [wild()], ConstructWitness)\n         .useful()\n         .map(|pats| {"}, {"sha": "24d97f5aac354212171f61b1110cae7506c0fb96", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "patch": "@@ -12,9 +12,10 @@ use middle::def::*;\n use middle::resolve;\n \n use std::collections::HashMap;\n+use std::gc::{Gc, GC};\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n \n@@ -111,3 +112,7 @@ pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Path> {\n         }\n     }\n }\n+\n+pub fn wild() -> Gc<Pat> {\n+    box (GC) Pat { id: 0, node: PatWild, span: DUMMY_SP }\n+}"}, {"sha": "439c82a6df08b19f858cd68de06f24abe731a74d", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,10 +11,19 @@\n enum t { a(u), b }\n enum u { c, d }\n \n+fn match_nested_vecs<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n+    match (l1, l2) { //~ ERROR non-exhaustive patterns: `(Some([]), Err(_))` not covered\n+        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n+        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n+        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\"\n+    }\n+}\n+\n fn main() {\n-  let x = a(c);\n-  match x { //~ ERROR non-exhaustive patterns: `a(c)` not covered\n-      a(d) => { fail!(\"hello\"); }\n-      b => { fail!(\"goodbye\"); }\n+    let x = a(c);\n+    match x { //~ ERROR non-exhaustive patterns: `a(c)` not covered\n+        a(d) => { fail!(\"hello\"); }\n+        b => { fail!(\"goodbye\"); }\n     }\n }"}, {"sha": "d2711339ccbd41d10677c9e9b479d6fb074870d4", "filename": "src/test/run-pass/issue-15104.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15104.rs?ref=9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert_eq!(count_members(&[1, 2, 3, 4]), 4);\n+}\n+\n+fn count_members(v: &[uint]) -> uint {\n+    match v {\n+        []         => 0,\n+        [_]        => 1,\n+        [_x, ..xs] => 1 + count_members(xs)\n+    }\n+}"}, {"sha": "ffbc4e85cb685762e7bddf39dfb34facb4f1722e", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3f9d94441340f0cdf6ec59aab739baef0f1ac0/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=9b3f9d94441340f0cdf6ec59aab739baef0f1ac0", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n+    match (l1, l2) {\n+        ([], []) => \"both empty\",\n+        ([], [..]) | ([..], []) => \"one empty\",\n+        ([..], [..]) => \"both non-empty\"\n+    }\n+}\n+\n+fn match_vecs_cons<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n+    match (l1, l2) {\n+        ([], []) => \"both empty\",\n+        ([], [_, ..]) | ([_, ..], []) => \"one empty\",\n+        ([_, ..], [_, ..]) => \"both non-empty\"\n+    }\n+}\n+\n+fn match_vecs_snoc<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n+    match (l1, l2) {\n+        ([], []) => \"both empty\",\n+        ([], [.., _]) | ([.., _], []) => \"one empty\",\n+        ([.., _], [.., _]) => \"both non-empty\"\n+    }\n+}\n+\n+fn match_nested_vecs_cons<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n+    match (l1, l2) {\n+        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n+        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n+        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\",\n+        _ => \"other\"\n+    }\n+}\n+\n+fn match_nested_vecs_snoc<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n+    match (l1, l2) {\n+        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n+        (Some([.., _]), Ok(_)) | (Some([.., _]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n+        (None, Ok([.., _, _])) => \"None, Ok(at least two elements)\",\n+        _ => \"other\"\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(match_vecs(&[1i, 2], &[2i, 3]), \"both non-empty\");\n+    assert_eq!(match_vecs(&[], &[1i, 2, 3, 4]), \"one empty\");\n+    assert_eq!(match_vecs::<uint>(&[], &[]), \"both empty\");\n+    assert_eq!(match_vecs(&[1i, 2, 3], &[]), \"one empty\");\n+\n+    assert_eq!(match_vecs_cons(&[1i, 2], &[2i, 3]), \"both non-empty\");\n+    assert_eq!(match_vecs_cons(&[], &[1i, 2, 3, 4]), \"one empty\");\n+    assert_eq!(match_vecs_cons::<uint>(&[], &[]), \"both empty\");\n+    assert_eq!(match_vecs_cons(&[1i, 2, 3], &[]), \"one empty\");\n+\n+    assert_eq!(match_vecs_snoc(&[1i, 2], &[2i, 3]), \"both non-empty\");\n+    assert_eq!(match_vecs_snoc(&[], &[1i, 2, 3, 4]), \"one empty\");\n+    assert_eq!(match_vecs_snoc::<uint>(&[], &[]), \"both empty\");\n+    assert_eq!(match_vecs_snoc(&[1i, 2, 3], &[]), \"one empty\");\n+\n+    assert_eq!(match_nested_vecs_cons(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_cons::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n+    assert_eq!(match_nested_vecs_cons::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_cons(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_cons(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+\n+    assert_eq!(match_nested_vecs_snoc(None, Ok(&[4u, 2u])), \"None, Ok(at least two elements)\");\n+    assert_eq!(match_nested_vecs_snoc::<uint>(None, Err(())), \"None, Ok(less than one element)\");\n+    assert_eq!(match_nested_vecs_snoc::<bool>(Some(&[]), Ok(&[])), \"Some(empty), Ok(empty)\");\n+    assert_eq!(match_nested_vecs_snoc(Some(&[1i]), Err(())), \"Some(non-empty), any\");\n+    assert_eq!(match_nested_vecs_snoc(Some(&[(42i, ())]), Ok(&[(1i, ())])), \"Some(non-empty), any\");\n+}"}]}