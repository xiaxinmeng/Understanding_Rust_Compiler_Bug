{"sha": "4377802202d59eb5aeb36bb6b656d376bbdf67dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNzc4MDIyMDJkNTllYjVhZWIzNmJiNmI2NTZkMzc2YmJkZjY3ZGM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-14T23:17:59Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-14T23:32:52Z"}, "message": "De-mode task.rs and add some option::foo_ref() helpers", "tree": {"sha": "fddc8b08325332da6b2db0d4e6f3f7df1e9e9212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fddc8b08325332da6b2db0d4e6f3f7df1e9e9212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4377802202d59eb5aeb36bb6b656d376bbdf67dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4377802202d59eb5aeb36bb6b656d376bbdf67dc", "html_url": "https://github.com/rust-lang/rust/commit/4377802202d59eb5aeb36bb6b656d376bbdf67dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4377802202d59eb5aeb36bb6b656d376bbdf67dc/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "821fa337ffbc81fe5dad7dd1b3fa49dac84aa4ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/821fa337ffbc81fe5dad7dd1b3fa49dac84aa4ef", "html_url": "https://github.com/rust-lang/rust/commit/821fa337ffbc81fe5dad7dd1b3fa49dac84aa4ef"}], "stats": {"total": 81, "additions": 68, "deletions": 13}, "files": [{"sha": "2f86e1be49570c5b350efae1cefc33073139f449", "filename": "src/libcore/option.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4377802202d59eb5aeb36bb6b656d376bbdf67dc/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4377802202d59eb5aeb36bb6b656d376bbdf67dc/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4377802202d59eb5aeb36bb6b656d376bbdf67dc", "patch": "@@ -46,7 +46,13 @@ pure fn map<T, U>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n     match opt { some(x) => some(f(x)), none => none }\n }\n \n-pure fn map_consume<T, U>(-opt: option<T>, f: fn(-T) -> U) -> option<U> {\n+pure fn map_ref<T, U>(opt: &option<T>, f: fn(x: &T) -> U) -> option<U> {\n+    //! Maps a `some` value by reference from one type to another\n+\n+    match *opt { some(ref x) => some(f(x)), none => none }\n+}\n+\n+pure fn map_consume<T, U>(+opt: option<T>, f: fn(+T) -> U) -> option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n@@ -63,6 +69,16 @@ pure fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n     match opt { some(x) => f(x), none => none }\n }\n \n+pure fn chain_ref<T, U>(opt: &option<T>,\n+                        f: fn(x: &T) -> option<U>) -> option<U> {\n+    /*!\n+     * Update an optional value by optionally running its content by reference\n+     * through a function that returns an option.\n+     */\n+\n+    match *opt { some(ref x) => f(x), none => none }\n+}\n+\n #[inline(always)]\n pure fn while_some<T>(+x: option<T>, blk: fn(+T) -> option<T>) {\n     //! Applies a function zero or more times until the result is none.\n@@ -97,14 +113,28 @@ pure fn map_default<T, U>(opt: option<T>, +def: U, f: fn(T) -> U) -> U {\n     match opt { none => def, some(t) => f(t) }\n }\n \n+// This should replace map_default.\n+pure fn map_default_ref<T, U>(opt: &option<T>, +def: U,\n+                              f: fn(x: &T) -> U) -> U {\n+    //! Applies a function to the contained value or returns a default\n+\n+    match *opt { none => def, some(ref t) => f(t) }\n+}\n+\n+// This should change to by-copy mode; use iter_ref below for by reference\n pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     //! Performs an operation on the contained value or does nothing\n \n     match opt { none => (), some(t) => f(t) }\n }\n \n+pure fn iter_ref<T>(opt: &option<T>, f: fn(x: &T)) {\n+    //! Performs an operation on the contained value by reference\n+    match *opt { none => (), some(ref t) => f(t) }\n+}\n+\n #[inline(always)]\n-pure fn unwrap<T>(-opt: option<T>) -> T {\n+pure fn unwrap<T>(+opt: option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n@@ -130,12 +160,13 @@ fn swap_unwrap<T>(opt: &mut option<T>) -> T {\n     unwrap(util::replace(opt, none))\n }\n \n-pure fn unwrap_expect<T>(-opt: option<T>, reason: &str) -> T {\n+pure fn unwrap_expect<T>(+opt: option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n     unwrap(opt)\n }\n \n+// Some of these should change to be &option<T>, some should not. See below.\n impl<T> option<T> {\n     /**\n      * Update an optional value by optionally running its content through a\n@@ -155,6 +186,23 @@ impl<T> option<T> {\n     pure fn map<U>(f: fn(T) -> U) -> option<U> { map(self, f) }\n }\n \n+impl<T> &option<T> {\n+    /**\n+     * Update an optional value by optionally running its content by reference\n+     * through a function that returns an option.\n+     */\n+    pure fn chain_ref<U>(f: fn(x: &T) -> option<U>) -> option<U> {\n+        chain_ref(self, f)\n+    }\n+    /// Applies a function to the contained value or returns a default\n+    pure fn map_default_ref<U>(+def: U, f: fn(x: &T) -> U) -> U\n+        { map_default_ref(self, def, f) }\n+    /// Performs an operation on the contained value by reference\n+    pure fn iter_ref(f: fn(x: &T)) { iter_ref(self, f) }\n+    /// Maps a `some` value from one type to another by reference\n+    pure fn map_ref<U>(f: fn(x: &T) -> U) -> option<U> { map_ref(self, f) }\n+}\n+\n impl<T: copy> option<T> {\n     /**\n      * Gets the value out of an option"}, {"sha": "1a130e0e273c4778a5d11f3dae6bbcdbe4d54d0c", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4377802202d59eb5aeb36bb6b656d376bbdf67dc/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4377802202d59eb5aeb36bb6b656d376bbdf67dc/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=4377802202d59eb5aeb36bb6b656d376bbdf67dc", "patch": "@@ -237,11 +237,11 @@ mod linear {\n     }\n \n     impl<K,V> &const linear_map<K,V> {\n-        fn len() -> uint {\n+        pure fn len() -> uint {\n             self.size\n         }\n \n-        fn is_empty() -> bool {\n+        pure fn is_empty() -> bool {\n             self.len() == 0\n         }\n "}, {"sha": "62398a6b8c9f26119c9148703cf206d3798dcea9", "filename": "src/libcore/task.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4377802202d59eb5aeb36bb6b656d376bbdf67dc/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4377802202d59eb5aeb36bb6b656d376bbdf67dc/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=4377802202d59eb5aeb36bb6b656d376bbdf67dc", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n /*!\n  * Task management.\n  *\n@@ -730,8 +734,8 @@ type taskgroup_arc = unsafe::Exclusive<option<taskgroup_data>>;\n type taskgroup_inner = &mut option<taskgroup_data>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-fn taskgroup_is_dead(tg: taskgroup_data) -> bool {\n-    (&mut tg.members).is_empty()\n+pure fn taskgroup_is_dead(tg: &taskgroup_data) -> bool {\n+    (&tg.members).is_empty()\n }\n \n // A list-like structure by which taskgroups keep track of all ancestor groups\n@@ -841,8 +845,11 @@ fn each_ancestor(list:        &mut ancestor_list,\n                     do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n                         // Decide whether this group is dead. Note that the\n                         // group being *dead* is disjoint from it *failing*.\n-                        do tg_opt.iter |tg| {\n-                            nobe_is_dead = taskgroup_is_dead(tg);\n+                        match *tg_opt {\n+                            some(ref tg) => {\n+                                nobe_is_dead = taskgroup_is_dead(tg);\n+                            },\n+                            none => { }\n                         }\n                         // Call iterator block. (If the group is dead, it's\n                         // safe to skip it. This will leave our *rust_task\n@@ -1100,7 +1107,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-fn spawn_raw(opts: task_opts, +f: fn~()) {\n+fn spawn_raw(+opts: task_opts, +f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -1138,10 +1145,10 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n     // (3a) If any of those fails, it leaves all groups, and does nothing.\n     // (3b) Otherwise it builds a task control structure and puts it in TLS,\n     // (4) ...and runs the provided body function.\n-    fn make_child_wrapper(child: *rust_task, -child_arc: taskgroup_arc,\n-                          -ancestors: ancestor_list, is_main: bool,\n+    fn make_child_wrapper(child: *rust_task, +child_arc: taskgroup_arc,\n+                          +ancestors: ancestor_list, is_main: bool,\n                           notify_chan: option<comm::chan<notification>>,\n-                          -f: fn~()) -> fn~() {\n+                          +f: fn~()) -> fn~() {\n         let child_data = ~mut some((child_arc, ancestors));\n         return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)"}]}