{"sha": "0db8ca6ca2cc400e4cdd95a2cf8867766d376730", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYjhjYTZjYTJjYzQwMGU0Y2RkOTVhMmNmODg2Nzc2NmQzNzY3MzA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-29T17:52:56Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-01T19:10:05Z"}, "message": "nit: rename `module_` -> `module`", "tree": {"sha": "a6638caa17c5ded3cf254b9294c56c48eef383b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6638caa17c5ded3cf254b9294c56c48eef383b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0db8ca6ca2cc400e4cdd95a2cf8867766d376730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0db8ca6ca2cc400e4cdd95a2cf8867766d376730", "html_url": "https://github.com/rust-lang/rust/commit/0db8ca6ca2cc400e4cdd95a2cf8867766d376730", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0db8ca6ca2cc400e4cdd95a2cf8867766d376730/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6372a6d7c271c58bc56dd35a2f58599d5429b39a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6372a6d7c271c58bc56dd35a2f58599d5429b39a", "html_url": "https://github.com/rust-lang/rust/commit/6372a6d7c271c58bc56dd35a2f58599d5429b39a"}], "stats": {"total": 46, "additions": 22, "deletions": 24}, "files": [{"sha": "eb288b627f794d44482423df51227144f77bb04f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0db8ca6ca2cc400e4cdd95a2cf8867766d376730/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db8ca6ca2cc400e4cdd95a2cf8867766d376730/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0db8ca6ca2cc400e4cdd95a2cf8867766d376730", "patch": "@@ -1228,9 +1228,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    /// Resolves the given module path from the given root `module_`.\n+    /// Resolves the given module path from the given root `search_module`.\n     fn resolve_module_path_from_root(&mut self,\n-                                     module_: Module<'a>,\n+                                     mut search_module: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n                                      span: Span)\n@@ -1247,7 +1247,6 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = module_path.len();\n \n@@ -1444,31 +1443,30 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&self, module_: Module<'a>) -> Option<Module<'a>> {\n-        let mut module_ = module_;\n+    fn get_nearest_normal_module_parent(&self, mut module: Module<'a>) -> Option<Module<'a>> {\n         loop {\n-            match module_.parent_link {\n+            match module.parent_link {\n                 NoParentLink => return None,\n                 ModuleParentLink(new_module, _) |\n                 BlockParentLink(new_module, _) => {\n                     let new_module = new_module;\n                     if new_module.is_normal() {\n                         return Some(new_module);\n                     }\n-                    module_ = new_module;\n+                    module = new_module;\n                 }\n             }\n         }\n     }\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&self, module_: Module<'a>) -> Module<'a> {\n-        if module_.is_normal() {\n-            return module_;\n+    fn get_nearest_normal_module_parent_or_self(&self, module: Module<'a>) -> Module<'a> {\n+        if module.is_normal() {\n+            return module;\n         }\n-        match self.get_nearest_normal_module_parent(module_) {\n-            None => module_,\n+        match self.get_nearest_normal_module_parent(module) {\n+            None => module,\n             Some(new_module) => new_module,\n         }\n     }\n@@ -1485,8 +1483,8 @@ impl<'a> Resolver<'a> {\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n         };\n-        let module_ = self.current_module;\n-        let mut containing_module = self.get_nearest_normal_module_parent_or_self(module_);\n+        let mut containing_module =\n+            self.get_nearest_normal_module_parent_or_self(self.current_module);\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {"}, {"sha": "a2aab1ff815ac60297579beb6070f66dec8f9e24", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0db8ca6ca2cc400e4cdd95a2cf8867766d376730/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0db8ca6ca2cc400e4cdd95a2cf8867766d376730/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=0db8ca6ca2cc400e4cdd95a2cf8867766d376730", "patch": "@@ -490,14 +490,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let value_result = self.resolve_name_in_module(target_module, source, ValueNS, false, true);\n         let type_result = self.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n-        let module_ = self.current_module;\n+        let module = self.current_module;\n         let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n             match *result {\n                 Failed(..) if !determined.get() => {\n                     determined.set(true);\n-                    self.update_resolution(module_, target, ns, |_, resolution| {\n+                    self.update_resolution(module, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n@@ -506,17 +506,17 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     span_err!(self.session, directive.span, E0253, \"{}\", &msg);\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n-                    self.import_dummy_binding(module_, directive);\n+                    self.import_dummy_binding(module, directive);\n                     return Success(());\n                 }\n                 Success(binding) if !self.is_accessible(binding.vis) => {}\n                 Success(binding) if !determined.get() => {\n                     determined.set(true);\n                     let imported_binding = directive.import(binding);\n-                    let conflict = self.try_define(module_, target, ns, imported_binding);\n+                    let conflict = self.try_define(module, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n                         let binding = &directive.import(binding);\n-                        self.report_conflict(module_, target, ns, binding, old_binding);\n+                        self.report_conflict(module, target, ns, binding, old_binding);\n                     }\n                     privacy_error = false;\n                 }\n@@ -556,7 +556,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n                 let binding = match *result { Success(binding) => binding, _ => continue };\n                 self.privacy_errors.push(PrivacyError(directive.span, source, binding));\n-                let _ = self.try_define(module_, target, ns, directive.import(binding));\n+                let _ = self.try_define(module, target, ns, directive.import(binding));\n             }\n         }\n \n@@ -615,8 +615,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n         }\n \n-        let module_ = self.current_module;\n-        if module_.def_id() == target_module.def_id() {\n+        let module = self.current_module;\n+        if module.def_id() == target_module.def_id() {\n             // This means we are trying to glob import a module into itself, and it is a no-go\n             let msg = \"Cannot glob-import a module into itself.\".into();\n             return Failed(Some((directive.span, msg)));\n@@ -629,7 +629,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         // Add to target_module's glob_importers\n-        target_module.glob_importers.borrow_mut().push((module_, directive));\n+        target_module.glob_importers.borrow_mut().push((module, directive));\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n@@ -638,7 +638,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n-                let _ = self.try_define(module_, name, ns, directive.import(binding));\n+                let _ = self.try_define(module, name, ns, directive.import(binding));\n             }\n         }\n "}]}