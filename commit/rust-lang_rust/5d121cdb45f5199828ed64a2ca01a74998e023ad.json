{"sha": "5d121cdb45f5199828ed64a2ca01a74998e023ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMTIxY2RiNDVmNTE5OTgyOGVkNjRhMmNhMDFhNzQ5OThlMDIzYWQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-01T13:24:00Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-01T13:24:00Z"}, "message": "Introduce Ty::Alias", "tree": {"sha": "b2a941497dea3cc38adb6c55049668aa31b2554b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2a941497dea3cc38adb6c55049668aa31b2554b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d121cdb45f5199828ed64a2ca01a74998e023ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d121cdb45f5199828ed64a2ca01a74998e023ad", "html_url": "https://github.com/rust-lang/rust/commit/5d121cdb45f5199828ed64a2ca01a74998e023ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d121cdb45f5199828ed64a2ca01a74998e023ad/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cda13d54613006c7985da0489878605300ba05b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/cda13d54613006c7985da0489878605300ba05b8", "html_url": "https://github.com/rust-lang/rust/commit/cda13d54613006c7985da0489878605300ba05b8"}], "stats": {"total": 207, "additions": 109, "deletions": 98}, "files": [{"sha": "00b0dc08252876c25441c1948fa3013b4483a670", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -31,7 +31,7 @@ use hir_ty::{\n     display::{write_bounds_like_dyn_trait_with_prefix, HirDisplayError, HirFormatter},\n     method_resolution,\n     traits::{FnTrait, Solution, SolutionVariables},\n-    BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n+    AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n     InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment,\n     Ty, TyDefId, TyVariableKind,\n };\n@@ -1648,7 +1648,7 @@ impl Type {\n             .build();\n         let predicate = ProjectionPredicate {\n             projection_ty: ProjectionTy { associated_ty: alias.id, parameters: subst },\n-            ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)),\n+            ty: Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)),\n         };\n         let goal = Canonical {\n             value: InEnvironment::new(\n@@ -1709,7 +1709,7 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.value, Ty::RawPtr(..))\n+        matches!(&self.ty.value, Ty::Raw(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n@@ -1937,7 +1937,7 @@ impl Type {\n                         walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n                 }\n-                Ty::Opaque(opaque_ty) => {\n+                Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n                     if let Some(bounds) = ty.impl_trait_bounds(db) {\n                         walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }"}, {"sha": "be1fd1f13d616e7e04cc61c55306278780677b9b", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -81,7 +81,7 @@ fn deref_by_trait(\n \n     // Now do the assoc type projection\n     let projection = super::traits::ProjectionPredicate {\n-        ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len())),\n+        ty: Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len())),\n         projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n     };\n \n@@ -114,7 +114,8 @@ fn deref_by_trait(\n             // new variables in that case\n \n             for i in 1..vars.0.kinds.len() {\n-                if vars.0.value[i - 1] != Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n+                if vars.0.value[i - 1]\n+                    != Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.value, solution);\n                     return None;"}, {"sha": "e77a20fea14625feffaed2582982179d08529026", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -110,7 +110,7 @@ fn walk_unsafe(\n             }\n         }\n         Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n-            if let Ty::RawPtr(..) = &infer[*expr] {\n+            if let Ty::Raw(..) = &infer[*expr] {\n                 unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }"}, {"sha": "f3a4333cb74b23c3b45313f44920eaca80cdd634", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -3,8 +3,9 @@\n use std::{borrow::Cow, fmt};\n \n use crate::{\n-    db::HirDatabase, primitive, utils::generics, CallableDefId, CallableSig, GenericPredicate,\n-    Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar, Substs, TraitRef, Ty,\n+    db::HirDatabase, primitive, utils::generics, AliasTy, CallableDefId, CallableSig,\n+    GenericPredicate, Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar, Substs,\n+    TraitRef, Ty,\n };\n use arrayvec::ArrayVec;\n use hir_def::{\n@@ -284,12 +285,12 @@ impl HirDisplay for Ty {\n                 t.hir_fmt(f)?;\n                 write!(f, \"; _]\")?;\n             }\n-            Ty::RawPtr(m, parameters) | Ty::Ref(m, parameters) => {\n+            Ty::Raw(m, parameters) | Ty::Ref(m, parameters) => {\n                 let t = parameters.as_single();\n                 let ty_display =\n                     t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                if matches!(self, Ty::RawPtr(..)) {\n+                if matches!(self, Ty::Raw(..)) {\n                     write!(f, \"*{}\", m.as_keyword_for_ptr())?;\n                 } else {\n                     write!(f, \"&{}\", m.as_keyword_for_ref())?;\n@@ -300,10 +301,10 @@ impl HirDisplay for Ty {\n                     Ty::Dyn(predicates) if predicates.len() > 1 => {\n                         Cow::Borrowed(predicates.as_ref())\n                     }\n-                    &Ty::Opaque(OpaqueTy {\n+                    &Ty::Alias(AliasTy::Opaque(OpaqueTy {\n                         opaque_ty_id: OpaqueTyId::ReturnTypeImplTrait(func, idx),\n                         ref parameters,\n-                    }) => {\n+                    })) => {\n                         datas =\n                             f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n@@ -518,7 +519,6 @@ impl HirDisplay for Ty {\n                     write!(f, \"{{closure}}\")?;\n                 }\n             }\n-            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Placeholder(id) => {\n                 let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.types[id.local_id];\n@@ -537,11 +537,12 @@ impl HirDisplay for Ty {\n                     }\n                 }\n             }\n-            Ty::Bound(idx) => write!(f, \"?{}.{}\", idx.debruijn.depth(), idx.index)?,\n+            Ty::BoundVar(idx) => write!(f, \"?{}.{}\", idx.debruijn.depth(), idx.index)?,\n             Ty::Dyn(predicates) => {\n                 write_bounds_like_dyn_trait_with_prefix(\"dyn\", predicates, f)?;\n             }\n-            Ty::Opaque(opaque_ty) => {\n+            Ty::Alias(AliasTy::Projection(p_ty)) => p_ty.hir_fmt(f)?,\n+            Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n                 match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas ="}, {"sha": "18a4f5e8af7411c7b69672e5e7a221ca0475bd0a", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -40,7 +40,7 @@ use super::{\n     InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n use crate::{\n-    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n+    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode, AliasTy,\n };\n \n pub(crate) use unify::unify;\n@@ -395,7 +395,7 @@ impl<'a> InferenceContext<'a> {\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n         let ty = self.resolve_ty_as_possible(ty);\n         ty.fold(&mut |ty| match ty {\n-            Ty::Projection(proj_ty) => self.normalize_projection_ty(proj_ty),\n+            Ty::Alias(AliasTy::Projection(proj_ty)) => self.normalize_projection_ty(proj_ty),\n             _ => ty,\n         })\n     }"}, {"sha": "c33d8c61e4aa1dd0fd2808043abcd26fdd5c448f", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -73,19 +73,19 @@ impl<'a> InferenceContext<'a> {\n         match (&mut from_ty, to_ty) {\n             // `*mut T` -> `*const T`\n             // `&mut T` -> `&T`\n-            (Ty::RawPtr(m1, ..), Ty::RawPtr(m2 @ Mutability::Shared, ..))\n+            (Ty::Raw(m1, ..), Ty::Raw(m2 @ Mutability::Shared, ..))\n             | (Ty::Ref(m1, ..), Ty::Ref(m2 @ Mutability::Shared, ..)) => {\n                 *m1 = *m2;\n             }\n             // `&T` -> `*const T`\n             // `&mut T` -> `*mut T`/`*const T`\n-            (Ty::Ref(.., substs), &Ty::RawPtr(m2 @ Mutability::Shared, ..))\n-            | (Ty::Ref(Mutability::Mut, substs), &Ty::RawPtr(m2, ..)) => {\n-                from_ty = Ty::RawPtr(m2, substs.clone());\n+            (Ty::Ref(.., substs), &Ty::Raw(m2 @ Mutability::Shared, ..))\n+            | (Ty::Ref(Mutability::Mut, substs), &Ty::Raw(m2, ..)) => {\n+                from_ty = Ty::Raw(m2, substs.clone());\n             }\n \n             // Illegal mutability conversion\n-            (Ty::RawPtr(Mutability::Shared, ..), Ty::RawPtr(Mutability::Mut, ..))\n+            (Ty::Raw(Mutability::Shared, ..), Ty::Raw(Mutability::Mut, ..))\n             | (Ty::Ref(Mutability::Shared, ..), Ty::Ref(Mutability::Mut, ..)) => return false,\n \n             // `{function_type}` -> `fn()`"}, {"sha": "7852b3d23b17df15ee53479b462a194bbe44ec36", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -479,7 +479,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let inner_ty = self.infer_expr_inner(*expr, &expectation);\n                 match rawness {\n-                    Rawness::RawPtr => Ty::RawPtr(*mutability, Substs::single(inner_ty)),\n+                    Rawness::RawPtr => Ty::Raw(*mutability, Substs::single(inner_ty)),\n                     Rawness::Ref => Ty::Ref(*mutability, Substs::single(inner_ty)),\n                 }\n             }"}, {"sha": "99a89a7f3b4e6d31c1c0a384863bfacbaa263d7c", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n                     } else {\n                         let root = self.ctx.table.var_unification_table.find(inner);\n                         let position = self.add(InferenceVar::from_inner(root), kind);\n-                        Ty::Bound(BoundVar::new(binders, position))\n+                        Ty::BoundVar(BoundVar::new(binders, position))\n                     }\n                 }\n                 _ => ty,\n@@ -110,7 +110,7 @@ impl<T> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, mut ty: Ty) -> Ty {\n         ty.walk_mut_binders(\n             &mut |ty, binders| {\n-                if let &mut Ty::Bound(bound) = ty {\n+                if let &mut Ty::BoundVar(bound) = ty {\n                     if bound.debruijn >= binders {\n                         let (v, k) = self.free_vars[bound.index];\n                         *ty = Ty::InferenceVar(v, k);\n@@ -168,7 +168,7 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substs> {\n     // (kind of hacky)\n     for (i, var) in vars.iter().enumerate() {\n         if &*table.resolve_ty_shallow(var) == var {\n-            table.unify(var, &Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, i)));\n+            table.unify(var, &Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i)));\n         }\n     }\n     Some("}, {"sha": "9bcaf6fa72bd3e004467ea78b937c64d90833c6e", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -111,6 +111,19 @@ pub struct FnPointer {\n     pub substs: Substs,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum AliasTy {\n+    /// A \"projection\" type corresponds to an (unnormalized)\n+    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+    /// trait and all its parameters are fully known.\n+    Projection(ProjectionTy),\n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// This is currently only used for return type impl trait; each instance of\n+    /// `impl Trait` in a return type gets its own ID.\n+    Opaque(OpaqueTy),\n+}\n+\n /// A type.\n ///\n /// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n@@ -141,7 +154,7 @@ pub enum Ty {\n     Slice(Substs),\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(Mutability, Substs),\n+    Raw(Mutability, Substs),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n@@ -193,16 +206,11 @@ pub enum Ty {\n     /// ```\n     Function(FnPointer),\n \n-    /// A \"projection\" type corresponds to an (unnormalized)\n-    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n-    /// trait and all its parameters are fully known.\n-    Projection(ProjectionTy),\n-\n-    /// An opaque type (`impl Trait`).\n-    ///\n-    /// This is currently only used for return type impl trait; each instance of\n-    /// `impl Trait` in a return type gets its own ID.\n-    Opaque(OpaqueTy),\n+    /// An \"alias\" type represents some form of type alias, such as:\n+    /// - An associated type projection like `<T as Iterator>::Item`\n+    /// - `impl Trait` types\n+    /// - Named type aliases like `type Foo<X> = Vec<X>`\n+    Alias(AliasTy),\n \n     /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n     /// {}` when we're type-checking the body of that function. In this\n@@ -215,7 +223,7 @@ pub enum Ty {\n     /// parameters get turned into variables; during trait resolution, inference\n     /// variables get turned into bound variables and back; and in `Dyn` the\n     /// `Self` type is represented with a bound variable as well.\n-    Bound(BoundVar),\n+    BoundVar(BoundVar),\n \n     /// A type variable used during type checking.\n     InferenceVar(InferenceVar, TyVariableKind),\n@@ -299,7 +307,7 @@ impl Substs {\n             generic_params\n                 .iter()\n                 .enumerate()\n-                .map(|(idx, _)| Ty::Bound(BoundVar::new(debruijn, idx)))\n+                .map(|(idx, _)| Ty::BoundVar(BoundVar::new(debruijn, idx)))\n                 .collect(),\n         )\n     }\n@@ -347,7 +355,7 @@ impl SubstsBuilder {\n     }\n \n     pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n-        self.fill((starting_from..).map(|idx| Ty::Bound(BoundVar::new(debruijn, idx))))\n+        self.fill((starting_from..).map(|idx| Ty::BoundVar(BoundVar::new(debruijn, idx))))\n     }\n \n     pub fn fill_with_unknown(self) -> Self {\n@@ -627,7 +635,7 @@ impl Ty {\n             Ty::Ref(mutability, parameters) => {\n                 Some((parameters.as_single(), Rawness::Ref, *mutability))\n             }\n-            Ty::RawPtr(mutability, parameters) => {\n+            Ty::Raw(mutability, parameters) => {\n                 Some((parameters.as_single(), Rawness::RawPtr, *mutability))\n             }\n             _ => None,\n@@ -688,9 +696,7 @@ impl Ty {\n                 expr == expr2 && def == def2\n             }\n             (Ty::Ref(mutability, ..), Ty::Ref(mutability2, ..))\n-            | (Ty::RawPtr(mutability, ..), Ty::RawPtr(mutability2, ..)) => {\n-                mutability == mutability2\n-            }\n+            | (Ty::Raw(mutability, ..), Ty::Raw(mutability2, ..)) => mutability == mutability2,\n             (\n                 Ty::Function(FnPointer { num_args, sig, .. }),\n                 Ty::Function(FnPointer { num_args: num_args2, sig: sig2, .. }),\n@@ -721,7 +727,7 @@ impl Ty {\n     fn builtin_deref(&self) -> Option<Ty> {\n         match self {\n             Ty::Ref(.., parameters) => Some(Ty::clone(parameters.as_single())),\n-            Ty::RawPtr(.., parameters) => Some(Ty::clone(parameters.as_single())),\n+            Ty::Raw(.., parameters) => Some(Ty::clone(parameters.as_single())),\n             _ => None,\n         }\n     }\n@@ -757,7 +763,7 @@ impl Ty {\n             Ty::Adt(_, substs)\n             | Ty::Slice(substs)\n             | Ty::Array(substs)\n-            | Ty::RawPtr(_, substs)\n+            | Ty::Raw(_, substs)\n             | Ty::Ref(_, substs)\n             | Ty::FnDef(_, substs)\n             | Ty::Function(FnPointer { substs, .. })\n@@ -780,7 +786,7 @@ impl Ty {\n             Ty::Adt(_, substs)\n             | Ty::Slice(substs)\n             | Ty::Array(substs)\n-            | Ty::RawPtr(_, substs)\n+            | Ty::Raw(_, substs)\n             | Ty::Ref(_, substs)\n             | Ty::FnDef(_, substs)\n             | Ty::Function(FnPointer { substs, .. })\n@@ -797,7 +803,7 @@ impl Ty {\n             Ty::Adt(_, substs)\n             | Ty::Slice(substs)\n             | Ty::Array(substs)\n-            | Ty::RawPtr(_, substs)\n+            | Ty::Raw(_, substs)\n             | Ty::Ref(_, substs)\n             | Ty::FnDef(_, substs)\n             | Ty::Function(FnPointer { substs, .. })\n@@ -834,7 +840,7 @@ impl Ty {\n                     OpaqueTyId::ReturnTypeImplTrait(..) => None,\n                 }\n             }\n-            Ty::Opaque(opaque_ty) => {\n+            Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n                 let predicates = match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         db.return_type_impl_traits(func).map(|it| {\n@@ -878,7 +884,7 @@ impl Ty {\n                     _ => None,\n                 }\n             }\n-            Ty::Projection(projection_ty) => {\n+            Ty::Alias(AliasTy::Projection(projection_ty)) => {\n                 match projection_ty.associated_ty.lookup(db.upcast()).container {\n                     AssocContainerId::TraitId(trait_id) => Some(trait_id),\n                     _ => None,\n@@ -956,7 +962,7 @@ pub trait TypeWalk {\n     {\n         self.walk_mut_binders(\n             &mut |ty, binders| {\n-                if let &mut Ty::Bound(bound) = ty {\n+                if let &mut Ty::BoundVar(bound) = ty {\n                     if bound.debruijn >= binders {\n                         *ty = substs.0[bound.index].clone().shift_bound_vars(binders);\n                     }\n@@ -974,8 +980,8 @@ pub trait TypeWalk {\n     {\n         self.fold_binders(\n             &mut |ty, binders| match ty {\n-                Ty::Bound(bound) if bound.debruijn >= binders => {\n-                    Ty::Bound(bound.shifted_in_from(n))\n+                Ty::BoundVar(bound) if bound.debruijn >= binders => {\n+                    Ty::BoundVar(bound.shifted_in_from(n))\n                 }\n                 ty => ty,\n             },\n@@ -987,21 +993,21 @@ pub trait TypeWalk {\n impl TypeWalk for Ty {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n-            Ty::Projection(p_ty) => {\n+            Ty::Alias(AliasTy::Projection(p_ty)) => {\n                 for t in p_ty.parameters.iter() {\n                     t.walk(f);\n                 }\n             }\n+            Ty::Alias(AliasTy::Opaque(o_ty)) => {\n+                for t in o_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n             Ty::Dyn(predicates) => {\n                 for p in predicates.iter() {\n                     p.walk(f);\n                 }\n             }\n-            Ty::Opaque(o_ty) => {\n-                for t in o_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n             _ => {\n                 if let Some(substs) = self.substs() {\n                     for t in substs.iter() {\n@@ -1019,15 +1025,15 @@ impl TypeWalk for Ty {\n         binders: DebruijnIndex,\n     ) {\n         match self {\n-            Ty::Projection(p_ty) => {\n+            Ty::Alias(AliasTy::Projection(p_ty)) => {\n                 p_ty.parameters.walk_mut_binders(f, binders);\n             }\n             Ty::Dyn(predicates) => {\n                 for p in make_mut_slice(predicates) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n-            Ty::Opaque(o_ty) => {\n+            Ty::Alias(AliasTy::Opaque(o_ty)) => {\n                 o_ty.parameters.walk_mut_binders(f, binders);\n             }\n             _ => {"}, {"sha": "ca06c9fe2d360461cb2c8257bf240e1ab49a7335", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -31,8 +31,8 @@ use crate::{\n         all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n         make_mut_slice, variant_data,\n     },\n-    Binders, BoundVar, CallableSig, DebruijnIndex, FnPointer, FnSig, GenericPredicate, OpaqueTy,\n-    OpaqueTyId, PolyFnSig, ProjectionPredicate, ProjectionTy, ReturnTypeImplTrait,\n+    AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, FnPointer, FnSig, GenericPredicate,\n+    OpaqueTy, OpaqueTyId, PolyFnSig, ProjectionPredicate, ProjectionTy, ReturnTypeImplTrait,\n     ReturnTypeImplTraits, Substs, TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n \n@@ -157,7 +157,7 @@ impl Ty {\n             }\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::RawPtr(*mutability, Substs::single(inner_ty))\n+                Ty::Raw(*mutability, Substs::single(inner_ty))\n             }\n             TypeRef::Array(inner) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n@@ -181,7 +181,7 @@ impl Ty {\n                 })\n             }\n             TypeRef::DynTrait(bounds) => {\n-                let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n+                let self_ty = Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n                 let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n                     bounds\n                         .iter()\n@@ -225,7 +225,10 @@ impl Ty {\n                         let impl_trait_id = OpaqueTyId::ReturnTypeImplTrait(func, idx);\n                         let generics = generics(ctx.db.upcast(), func.into());\n                         let parameters = Substs::bound_vars(&generics, ctx.in_binders);\n-                        Ty::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters })\n+                        Ty::Alias(AliasTy::Opaque(OpaqueTy {\n+                            opaque_ty_id: impl_trait_id,\n+                            parameters,\n+                        }))\n                     }\n                     ImplTraitLoweringMode::Param => {\n                         let idx = ctx.impl_trait_counter.get();\n@@ -256,7 +259,7 @@ impl Ty {\n                             } else {\n                                 (0, 0, 0, 0)\n                             };\n-                        Ty::Bound(BoundVar::new(\n+                        Ty::BoundVar(BoundVar::new(\n                             ctx.in_binders,\n                             idx as usize + parent_params + self_params + list_params,\n                         ))\n@@ -328,7 +331,7 @@ impl Ty {\n             TypeNs::TraitId(trait_) => {\n                 // if this is a bare dyn Trait, we'll directly put the required ^0 for the self type in there\n                 let self_ty = if remaining_segments.len() == 0 {\n-                    Some(Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)))\n+                    Some(Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)))\n                 } else {\n                     None\n                 };\n@@ -344,10 +347,10 @@ impl Ty {\n                     match found {\n                         Some((super_trait_ref, associated_ty)) => {\n                             // FIXME handle type parameters on the segment\n-                            Ty::Projection(ProjectionTy {\n+                            Ty::Alias(AliasTy::Projection(ProjectionTy {\n                                 associated_ty,\n                                 parameters: super_trait_ref.substs,\n-                            })\n+                            }))\n                         }\n                         None => {\n                             // FIXME: report error (associated type not found)\n@@ -371,7 +374,7 @@ impl Ty {\n                     TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n                     TypeParamLoweringMode::Variable => {\n                         let idx = generics.param_idx(param_id).expect(\"matching generics\");\n-                        Ty::Bound(BoundVar::new(ctx.in_binders, idx))\n+                        Ty::BoundVar(BoundVar::new(ctx.in_binders, idx))\n                     }\n                 }\n             }\n@@ -469,10 +472,10 @@ impl Ty {\n                         // associated_type_shorthand_candidates does not do that\n                         let substs = substs.shift_bound_vars(ctx.in_binders);\n                         // FIXME handle type parameters on the segment\n-                        return Some(Ty::Projection(ProjectionTy {\n+                        return Some(Ty::Alias(AliasTy::Projection(ProjectionTy {\n                             associated_ty,\n                             parameters: substs,\n-                        }));\n+                        })));\n                     }\n \n                     None\n@@ -673,7 +676,7 @@ impl GenericPredicate {\n                             TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n                             TypeParamLoweringMode::Variable => {\n                                 let idx = generics.param_idx(param_id).expect(\"matching generics\");\n-                                Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n+                                Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n                             }\n                         }\n                     }\n@@ -747,7 +750,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n                 preds.extend(GenericPredicate::from_type_bound(\n                     ctx,\n                     bound,\n-                    Ty::Projection(projection_ty.clone()),\n+                    Ty::Alias(AliasTy::Projection(projection_ty.clone())),\n                 ));\n             }\n             preds\n@@ -757,7 +760,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n impl ReturnTypeImplTrait {\n     fn from_hir(ctx: &TyLoweringContext, bounds: &[TypeBound]) -> Self {\n         mark::hit!(lower_rpit);\n-        let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n+        let self_ty = Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n         let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             bounds\n                 .iter()\n@@ -981,7 +984,7 @@ pub(crate) fn generic_defaults_query(\n             // Each default can only refer to previous parameters.\n             ty.walk_mut_binders(\n                 &mut |ty, binders| match ty {\n-                    Ty::Bound(BoundVar { debruijn, index }) if *debruijn == binders => {\n+                    Ty::BoundVar(BoundVar { debruijn, index }) if *debruijn == binders => {\n                         if *index >= idx {\n                             // type variable default referring to parameter coming\n                             // after it. This is forbidden (FIXME: report"}, {"sha": "dd5109d4eec49f283c023aa91f1a60a0d8c05a36", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -51,7 +51,7 @@ impl TyFingerprint {\n             &Ty::Scalar(scalar) => TyFingerprint::Scalar(scalar),\n             &Ty::Adt(adt, _) => TyFingerprint::Adt(adt),\n             &Ty::Tuple(cardinality, _) => TyFingerprint::Tuple(cardinality),\n-            &Ty::RawPtr(mutability, ..) => TyFingerprint::RawPtr(mutability),\n+            &Ty::Raw(mutability, ..) => TyFingerprint::RawPtr(mutability),\n             &Ty::ForeignType(alias_id, ..) => TyFingerprint::ForeignType(alias_id),\n             &Ty::Function(FnPointer { num_args, sig, .. }) => TyFingerprint::FnPtr(num_args, sig),\n             Ty::Dyn(_) => ty.dyn_trait().map(|trait_| TyFingerprint::Dyn(trait_))?,\n@@ -251,8 +251,8 @@ impl Ty {\n             }\n             Ty::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n             Ty::Slice(_) => lang_item_crate!(\"slice_alloc\", \"slice\"),\n-            Ty::RawPtr(Mutability::Shared, _) => lang_item_crate!(\"const_ptr\"),\n-            Ty::RawPtr(Mutability::Mut, _) => lang_item_crate!(\"mut_ptr\"),\n+            Ty::Raw(Mutability::Shared, _) => lang_item_crate!(\"const_ptr\"),\n+            Ty::Raw(Mutability::Mut, _) => lang_item_crate!(\"mut_ptr\"),\n             Ty::Dyn(_) => {\n                 return self.dyn_trait().and_then(|trait_| {\n                     mod_to_crate_ids(GenericDefId::TraitId(trait_).module(db.upcast()))\n@@ -683,7 +683,7 @@ pub(crate) fn inherent_impl_substs(\n fn fallback_bound_vars(s: Substs, num_vars_to_keep: usize) -> Substs {\n     s.fold_binders(\n         &mut |ty, binders| {\n-            if let Ty::Bound(bound) = &ty {\n+            if let Ty::BoundVar(bound) = &ty {\n                 if bound.index >= num_vars_to_keep && bound.debruijn >= binders {\n                     Ty::Unknown\n                 } else {"}, {"sha": "e4cdb6d5343e101aeb7c18addb102f6075894bf0", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -129,7 +129,7 @@ pub(crate) fn trait_solve_query(\n     log::info!(\"trait_solve_query({})\", goal.value.value.display(db));\n \n     if let Obligation::Projection(pred) = &goal.value.value {\n-        if let Ty::Bound(_) = &pred.projection_ty.parameters[0] {\n+        if let Ty::BoundVar(_) = &pred.projection_ty.parameters[0] {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "e513fa8f4e7d0975a50344986e96c8db47468f89", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -90,7 +90,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             ty: &Ty,\n             binders: &CanonicalVarKinds<Interner>,\n         ) -> Option<chalk_ir::TyVariableKind> {\n-            if let Ty::Bound(bv) = ty {\n+            if let Ty::BoundVar(bv) = ty {\n                 let binders = binders.as_slice(&Interner);\n                 if bv.debruijn == DebruijnIndex::INNERMOST {\n                     if let chalk_ir::VariableKind::Ty(tk) = binders[bv.index].kind {\n@@ -220,18 +220,18 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     let impl_bound = GenericPredicate::Implemented(TraitRef {\n                         trait_: future_trait,\n                         // Self type as the first parameter.\n-                        substs: Substs::single(Ty::Bound(BoundVar {\n+                        substs: Substs::single(Ty::BoundVar(BoundVar {\n                             debruijn: DebruijnIndex::INNERMOST,\n                             index: 0,\n                         })),\n                     });\n                     let proj_bound = GenericPredicate::Projection(ProjectionPredicate {\n                         // The parameter of the opaque type.\n-                        ty: Ty::Bound(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 }),\n+                        ty: Ty::BoundVar(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 }),\n                         projection_ty: ProjectionTy {\n                             associated_ty: future_output,\n                             // Self type as the first parameter.\n-                            parameters: Substs::single(Ty::Bound(BoundVar::new(\n+                            parameters: Substs::single(Ty::BoundVar(BoundVar::new(\n                                 DebruijnIndex::INNERMOST,\n                                 0,\n                             ))),\n@@ -392,7 +392,7 @@ pub(crate) fn associated_ty_data_query(\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n-    let self_ty = Ty::Bound(crate::BoundVar::new(crate::DebruijnIndex::INNERMOST, 0));\n+    let self_ty = Ty::BoundVar(crate::BoundVar::new(crate::DebruijnIndex::INNERMOST, 0));\n     let bounds = type_alias_data\n         .bounds\n         .iter()"}, {"sha": "6e6055d809f8a49ca4e29b549f15f819b4a3c3b0", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d121cdb45f5199828ed64a2ca01a74998e023ad/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=5d121cdb45f5199828ed64a2ca01a74998e023ad", "patch": "@@ -16,8 +16,8 @@ use crate::{\n     db::HirDatabase,\n     primitive::UintTy,\n     traits::{Canonical, Obligation},\n-    CallableDefId, FnPointer, FnSig, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n-    ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty,\n+    AliasTy, CallableDefId, FnPointer, FnSig, GenericPredicate, InEnvironment, OpaqueTy,\n+    OpaqueTyId, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty,\n };\n \n use super::interner::*;\n@@ -63,7 +63,7 @@ impl ToChalk for Ty {\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::Tuple(cardinality.into(), substitution).intern(&Interner)\n             }\n-            Ty::RawPtr(mutability, substs) => {\n+            Ty::Raw(mutability, substs) => {\n                 let ty = substs[0].clone().to_chalk(db);\n                 chalk_ir::TyKind::Raw(mutability.to_chalk(db), ty).intern(&Interner)\n             }\n@@ -88,7 +88,7 @@ impl ToChalk for Ty {\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::Adt(chalk_ir::AdtId(adt_id), substitution).intern(&Interner)\n             }\n-            Ty::Projection(proj_ty) => {\n+            Ty::Alias(AliasTy::Projection(proj_ty)) => {\n                 let associated_ty_id = TypeAliasAsAssocType(proj_ty.associated_ty).to_chalk(db);\n                 let substitution = proj_ty.parameters.to_chalk(db);\n                 chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n@@ -106,7 +106,7 @@ impl ToChalk for Ty {\n                 }\n                 .to_ty::<Interner>(&Interner)\n             }\n-            Ty::Bound(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n+            Ty::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             Ty::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n             Ty::Dyn(predicates) => {\n                 let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n@@ -119,7 +119,7 @@ impl ToChalk for Ty {\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n             }\n-            Ty::Opaque(opaque_ty) => {\n+            Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n                 let opaque_ty_id = opaque_ty.opaque_ty_id.to_chalk(db);\n                 let substitution = opaque_ty.parameters.to_chalk(db);\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n@@ -146,12 +146,12 @@ impl ToChalk for Ty {\n                 let associated_ty =\n                     from_chalk::<TypeAliasAsAssocType, _>(db, proj.associated_ty_id).0;\n                 let parameters = from_chalk(db, proj.substitution);\n-                Ty::Projection(ProjectionTy { associated_ty, parameters })\n+                Ty::Alias(AliasTy::Projection(ProjectionTy { associated_ty, parameters }))\n             }\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n                 let impl_trait_id = from_chalk(db, opaque_ty.opaque_ty_id);\n                 let parameters = from_chalk(db, opaque_ty.substitution);\n-                Ty::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters })\n+                Ty::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters }))\n             }\n             chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                 num_binders,\n@@ -170,7 +170,7 @@ impl ToChalk for Ty {\n                     substs,\n                 })\n             }\n-            chalk_ir::TyKind::BoundVar(idx) => Ty::Bound(idx),\n+            chalk_ir::TyKind::BoundVar(idx) => Ty::BoundVar(idx),\n             chalk_ir::TyKind::InferenceVar(_iv, _kind) => Ty::Unknown,\n             chalk_ir::TyKind::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n@@ -198,7 +198,7 @@ impl ToChalk for Ty {\n                 Ty::Tuple(cardinality, from_chalk(db, subst))\n             }\n             chalk_ir::TyKind::Raw(mutability, ty) => {\n-                Ty::RawPtr(from_chalk(db, mutability), Substs::single(from_chalk(db, ty)))\n+                Ty::Raw(from_chalk(db, mutability), Substs::single(from_chalk(db, ty)))\n             }\n             chalk_ir::TyKind::Slice(ty) => Ty::Slice(Substs::single(from_chalk(db, ty))),\n             chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {"}]}