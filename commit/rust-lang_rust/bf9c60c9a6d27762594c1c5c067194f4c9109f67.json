{"sha": "bf9c60c9a6d27762594c1c5c067194f4c9109f67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmOWM2MGM5YTZkMjc3NjI1OTRjMWM1YzA2NzE5NGY0YzkxMDlmNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-30T04:28:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-30T04:28:50Z"}, "message": "Auto merge of #33929 - petrochenkov:pathir, r=eddyb\n\nSeparate bindings from other patterns in HIR\n\nNow when name resolution is done on AST, we can avoid dumping everything that looks like an identifier into `PatKind::Ident` in HIR.\n`hir::PatKind::Ident` is removed, fresh bindings are now called `hir::PatKind::Binding`, everything else goes to `hir::PatKind::Path`.\n\nI intend to do something with `PatKind::Path`/`PatKind::QPath` as well using resolution results, but it requires some audit and maybe some deeper refactoring of relevant resolution/type checking code to do it properly.\nI'm submitting this part of the patch earlier to notify interested parties that I'm working on this.\n\ncc @jseyfried\nr? @eddyb", "tree": {"sha": "70418c04e1f34cf63161a9d3bc680d19d3b6a2a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70418c04e1f34cf63161a9d3bc680d19d3b6a2a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf9c60c9a6d27762594c1c5c067194f4c9109f67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf9c60c9a6d27762594c1c5c067194f4c9109f67", "html_url": "https://github.com/rust-lang/rust/commit/bf9c60c9a6d27762594c1c5c067194f4c9109f67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf9c60c9a6d27762594c1c5c067194f4c9109f67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e00b55568c23e6270ae193a72256cc1c7c5f23a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e00b55568c23e6270ae193a72256cc1c7c5f23a", "html_url": "https://github.com/rust-lang/rust/commit/6e00b55568c23e6270ae193a72256cc1c7c5f23a"}, {"sha": "ae999e9c8f063eb62c867eafdd86729acd798044", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae999e9c8f063eb62c867eafdd86729acd798044", "html_url": "https://github.com/rust-lang/rust/commit/ae999e9c8f063eb62c867eafdd86729acd798044"}], "stats": {"total": 938, "additions": 390, "deletions": 548}, "files": [{"sha": "76b53094a722b491bdac0896c60e56ae19150605", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n-            PatKind::Ident(_, _, None) |\n+            PatKind::Binding(_, _, None) |\n             PatKind::Path(..) |\n             PatKind::QPath(..) |\n             PatKind::Lit(..) |\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             PatKind::Box(ref subpat) |\n             PatKind::Ref(ref subpat, _) |\n-            PatKind::Ident(_, _, Some(ref subpat)) => {\n+            PatKind::Binding(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n@@ -456,8 +456,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n-                        &self.tcx.def_map.borrow(), &pat);\n+                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(&pat);\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only"}, {"sha": "1e80bc3c54dd023767d9990a0b46afa26afd5dbc", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -914,8 +914,8 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n             id: folder.new_id(id),\n             node: match node {\n                 PatKind::Wild => PatKind::Wild,\n-                PatKind::Ident(binding_mode, pth1, sub) => {\n-                    PatKind::Ident(binding_mode,\n+                PatKind::Binding(binding_mode, pth1, sub) => {\n+                    PatKind::Binding(binding_mode,\n                              Spanned {\n                                  span: folder.new_span(pth1.span),\n                                  node: folder.fold_name(pth1.node),"}, {"sha": "84a666ebef1bfdc9c21fda93dcd01e1ea1906b1a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -478,7 +478,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Binding(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_name(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }"}, {"sha": "90dd2dad7203d3e1d7556e17bf9e8ea75010cb28", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -866,14 +866,16 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n-                        let name = match this.resolver.get_resolution(p.id).map(|d| d.full_def()) {\n-                            // Only pattern bindings are renamed\n-                            None | Some(Def::Local(..)) => this.lower_ident(pth1.node),\n-                            _ => pth1.node.name,\n-                        };\n-                        hir::PatKind::Ident(this.lower_binding_mode(binding_mode),\n-                                            respan(pth1.span, name),\n-                                            sub.as_ref().map(|x| this.lower_pat(x)))\n+                        match this.resolver.get_resolution(p.id).map(|d| d.full_def()) {\n+                            // `None` can occur in body-less function signatures\n+                            None | Some(Def::Local(..)) => {\n+                                hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n+                                                      respan(pth1.span,\n+                                                             this.lower_ident(pth1.node)),\n+                                                      sub.as_ref().map(|x| this.lower_pat(x)))\n+                            }\n+                            _ => hir::PatKind::Path(hir::Path::from_name(pth1.span, pth1.node.name))\n+                        }\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n@@ -1868,7 +1870,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n                               -> P<hir::Pat> {\n-        let pat_ident = hir::PatKind::Ident(bm,\n+        let pat_ident = hir::PatKind::Binding(bm,\n                                             Spanned {\n                                                 span: span,\n                                                 node: name,"}, {"sha": "692f56bde28f5e5481aec88a20b103dd27aa4e32", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -165,7 +165,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n-        let node = if let PatKind::Ident(..) = pat.node {\n+        let node = if let PatKind::Binding(..) = pat.node {\n             NodeLocal(pat)\n         } else {\n             NodePat(pat)"}, {"sha": "e3b6539b8ccab2f80e3de32a8d9f5627ba4fc62b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -396,7 +396,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n         let parent_def = self.parent_def;\n \n-        if let hir::PatKind::Ident(_, name, _) = pat.node {\n+        if let hir::PatKind::Binding(_, name, _) = pat.node {\n             let def = self.create_def(pat.id, DefPathData::Binding(name.node));\n             self.parent_def = Some(def);\n         }"}, {"sha": "41b72e569f475aae749be162c5b940b3d5e0b2d4", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -561,7 +561,7 @@ impl<'ast> Map<'ast> {\n             NodeVariant(v) => v.node.name,\n             NodeLifetime(lt) => lt.name,\n             NodeTyParam(tp) => tp.name,\n-            NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => l.node,\n+            NodeLocal(&Pat { node: PatKind::Binding(_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }"}, {"sha": "c36c88c7990d30abfb1746b70a59a7c3f120ef53", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -466,7 +466,7 @@ impl Pat {\n         }\n \n         match self.node {\n-            PatKind::Ident(_, _, Some(ref p)) => p.walk_(it),\n+            PatKind::Binding(_, _, Some(ref p)) => p.walk_(it),\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| field.node.pat.walk_(it))\n             }\n@@ -484,7 +484,7 @@ impl Pat {\n             PatKind::Wild |\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n-            PatKind::Ident(_, _, _) |\n+            PatKind::Binding(..) |\n             PatKind::Path(..) |\n             PatKind::QPath(_, _) => {\n                 true\n@@ -524,15 +524,8 @@ pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n     Wild,\n \n-    /// A `PatKind::Ident` may either be a new bound variable,\n-    /// or a unit struct/variant pattern, or a const pattern (in the last two cases\n-    /// the third field must be `None`).\n-    ///\n-    /// In the unit or const pattern case, the parser can't determine\n-    /// which it is. The resolver determines this, and\n-    /// records this pattern's `NodeId` in an auxiliary\n-    /// set (of \"PatIdents that refer to unit patterns or constants\").\n-    Ident(BindingMode, Spanned<Name>, Option<P<Pat>>),\n+    /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n+    Binding(BindingMode, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -1144,7 +1137,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindByValue(mutbl), name, _) = self.pat.node {\n+        if let PatKind::Binding(BindByValue(mutbl), name, _) = self.pat.node {\n             if name.node.unhygienize() == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -1160,7 +1153,7 @@ impl Arg {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Ident(_, name, _) = self.pat.node {\n+        if let PatKind::Binding(_, name, _) = self.pat.node {\n             name.node.unhygienize() == keywords::SelfValue.name()\n         } else {\n             false"}, {"sha": "27530d8c75d13a1b64b15e4807436c58fbb7a5d4", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 30, "deletions": 58, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -10,14 +10,12 @@\n \n use hir::def::*;\n use hir::def_id::DefId;\n+use hir::{self, PatKind};\n use ty::TyCtxt;\n use util::nodemap::FnvHashMap;\n-\n use syntax::ast;\n-use hir::{self, PatKind};\n-use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n+use syntax::codemap::{Span, Spanned, DUMMY_SP};\n \n-use std::cell::RefCell;\n use std::iter::{Enumerate, ExactSizeIterator};\n \n pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n@@ -57,9 +55,9 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n+pub fn pat_id_map(pat: &hir::Pat) -> PatIdMap {\n     let mut map = FnvHashMap();\n-    pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n+    pat_bindings(pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });\n     map\n@@ -70,7 +68,6 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n         PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,\n         PatKind::TupleStruct(..) |\n         PatKind::Path(..) |\n-        PatKind::Ident(_, _, None) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) => true,\n@@ -86,7 +83,6 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         PatKind::TupleStruct(..) |\n         PatKind::Path(..) |\n-        PatKind::Ident(_, _, None) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) | Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => true,\n@@ -99,7 +95,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -113,7 +109,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n // returned instead of a panic.\n pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n@@ -125,46 +121,25 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Ident(..) => {\n-            !pat_is_variant_or_struct(dm, pat) &&\n-            !pat_is_const(dm, pat)\n-        }\n-        _ => false\n-    }\n-}\n-\n-pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Ident(..) => pat_is_binding(dm, pat),\n-        PatKind::Wild => true,\n-        _ => false\n-    }\n-}\n-\n-/// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n+/// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n-    I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)\n+    where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n {\n     pat.walk(|p| {\n-        match p.node {\n-          PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n-            it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n-          }\n-          _ => {}\n+        if let PatKind::Binding(binding_mode, ref pth, _) = p.node {\n+            f(binding_mode, p.id, p.span, pth);\n         }\n         true\n     });\n }\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings(pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     pat.walk(|p| {\n-        if pat_is_binding(dm, p) {\n+        if let PatKind::Binding(..) = p.node {\n             contains_bindings = true;\n             false // there's at least one binding, can short circuit now.\n         } else {\n@@ -176,28 +151,25 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n /// and if yes whether its containing mutable ones or just immutables ones.\n-pub fn pat_contains_ref_binding(dm: &RefCell<DefMap>, pat: &hir::Pat) -> Option<hir::Mutability> {\n+pub fn pat_contains_ref_binding(pat: &hir::Pat) -> Option<hir::Mutability> {\n     let mut result = None;\n-    pat_bindings(dm, pat, |mode, _, _, _| {\n-        match mode {\n-            hir::BindingMode::BindByRef(m) => {\n-                // Pick Mutable as maximum\n-                match result {\n-                    None | Some(hir::MutImmutable) => result = Some(m),\n-                    _ => (),\n-                }\n+    pat_bindings(pat, |mode, _, _, _| {\n+        if let hir::BindingMode::BindByRef(m) = mode {\n+            // Pick Mutable as maximum\n+            match result {\n+                None | Some(hir::MutImmutable) => result = Some(m),\n+                _ => (),\n             }\n-            hir::BindingMode::BindByValue(_) => { }\n         }\n     });\n     result\n }\n \n /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<hir::Mutability> {\n+pub fn arm_contains_ref_binding(arm: &hir::Arm) -> Option<hir::Mutability> {\n     arm.pats.iter()\n-            .filter_map(|pat| pat_contains_ref_binding(dm, pat))\n+            .filter_map(|pat| pat_contains_ref_binding(pat))\n             .max_by_key(|m| match *m {\n                 hir::MutMutable => 1,\n                 hir::MutImmutable => 0,\n@@ -206,22 +178,23 @@ pub fn arm_contains_ref_binding(dm: &RefCell<DefMap>, arm: &hir::Arm) -> Option<\n \n /// Checks if the pattern contains any patterns that bind something to\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_contains_bindings_or_wild(pat: &hir::Pat) -> bool {\n     let mut contains_bindings = false;\n     pat.walk(|p| {\n-        if pat_is_binding_or_wild(dm, p) {\n-            contains_bindings = true;\n-            false // there's at least one binding/wildcard, can short circuit now.\n-        } else {\n-            true\n+        match p.node {\n+            PatKind::Binding(..) | PatKind::Wild => {\n+                contains_bindings = true;\n+                false // there's at least one binding/wildcard, can short circuit now.\n+            }\n+            _ => true\n         }\n     });\n     contains_bindings\n }\n \n pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Ident(hir::BindByValue(_), ref path1, None) => {\n+        PatKind::Binding(hir::BindByValue(..), ref path1, None) => {\n             Some(path1.node)\n         }\n         _ => {\n@@ -241,7 +214,6 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n         match p.node {\n             PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n-            PatKind::Ident(_, _, None) |\n             PatKind::Struct(..) => {\n                 match dm.get(&p.id) {\n                     Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {"}, {"sha": "ceaf348117e1711b5c8d5bef3c7ca049daa60969", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -1716,7 +1716,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => word(&mut self.s, \"_\")?,\n-            PatKind::Ident(binding_mode, ref path1, ref sub) => {\n+            PatKind::Binding(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n                         self.word_nbsp(\"ref\")?;\n@@ -2170,7 +2170,7 @@ impl<'a> State<'a> {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n-                    let invalid = if let PatKind::Ident(_, name, _) = input.pat.node {\n+                    let invalid = if let PatKind::Binding(_, name, _) = input.pat.node {\n                         name.node == keywords::Invalid.name()\n                     } else {\n                         false"}, {"sha": "48b5420dd6be7e7e4c8b113a5e24e87834bd7a97", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 76, "deletions": 105, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -612,8 +612,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.mc.infcx.tcx.def_map, &local.pat,\n-                                       |_, id, span, _| {\n+                pat_util::pat_bindings(&local.pat, |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n             }\n@@ -932,23 +931,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n-            let def_map = &self.tcx().def_map;\n-            if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n-                match pat.node {\n-                    PatKind::Ident(hir::BindByRef(_), _, _) =>\n-                        mode.lub(BorrowingMatch),\n-                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n-                        match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n-                            Copy => mode.lub(CopyingMatch),\n-                            Move(_) => mode.lub(MovingMatch),\n-                        }\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"binding pattern not an identifier\");\n+            match pat.node {\n+                PatKind::Binding(hir::BindByRef(..), _, _) =>\n+                    mode.lub(BorrowingMatch),\n+                PatKind::Binding(hir::BindByValue(..), _, _) => {\n+                    match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n+                        Copy => mode.lub(CopyingMatch),\n+                        Move(..) => mode.lub(MovingMatch),\n                     }\n                 }\n+                _ => {}\n             }\n         }));\n     }\n@@ -968,83 +960,74 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n-                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n-                       cmt_pat,\n-                       pat,\n-                       match_mode);\n-\n-                // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n-\n-                // Each match binding is effectively an assignment to the\n-                // binding being produced.\n-                let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n-                match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n-                    Ok(binding_cmt) => {\n+            match pat.node {\n+                PatKind::Binding(bmode, _, _) => {\n+                    debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n+                           cmt_pat,\n+                           pat,\n+                           match_mode);\n+\n+                    // pat_ty: the type of the binding being produced.\n+                    let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n+\n+                    // Each match binding is effectively an assignment to the\n+                    // binding being produced.\n+                    let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n+                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n-                    Err(_) => { }\n-                }\n \n-                // It is also a borrow or copy/move of the value being matched.\n-                match pat.node {\n-                    PatKind::Ident(hir::BindByRef(m), _, _) => {\n-                        if let ty::TyRef(&r, _) = pat_ty.sty {\n-                            let bk = ty::BorrowKind::from_mutbl(m);\n-                            delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                            r, bk, RefBinding);\n+                    // It is also a borrow or copy/move of the value being matched.\n+                    match bmode {\n+                        hir::BindByRef(m) => {\n+                            if let ty::TyRef(&r, _) = pat_ty.sty {\n+                                let bk = ty::BorrowKind::from_mutbl(m);\n+                                delegate.borrow(pat.id, pat.span, cmt_pat,\n+                                                r, bk, RefBinding);\n+                            }\n+                        }\n+                        hir::BindByValue(..) => {\n+                            let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n+                            debug!(\"walk_pat binding consuming pat\");\n+                            delegate.consume_pat(pat, cmt_pat, mode);\n                         }\n-                    }\n-                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n-                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n-                        debug!(\"walk_pat binding consuming pat\");\n-                        delegate.consume_pat(pat, cmt_pat, mode);\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"binding pattern not an identifier\");\n                     }\n                 }\n-            } else {\n-                match pat.node {\n-                    PatKind::Vec(_, Some(ref slice_pat), _) => {\n-                        // The `slice_pat` here creates a slice into\n-                        // the original vector.  This is effectively a\n-                        // borrow of the elements of the vector being\n-                        // matched.\n-\n-                        let (slice_cmt, slice_mutbl, slice_r) =\n-                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n-\n-                        // Note: We declare here that the borrow\n-                        // occurs upon entering the `[...]`\n-                        // pattern. This implies that something like\n-                        // `[a; b]` where `a` is a move is illegal,\n-                        // because the borrow is already in effect.\n-                        // In fact such a move would be safe-ish, but\n-                        // it effectively *requires* that we use the\n-                        // nulling out semantics to indicate when a\n-                        // value has been moved, which we are trying\n-                        // to move away from.  Otherwise, how can we\n-                        // indicate that the first element in the\n-                        // vector has been moved?  Eventually, we\n-                        // could perhaps modify this rule to permit\n-                        // `[..a, b]` where `b` is a move, because in\n-                        // that case we can adjust the length of the\n-                        // original vec accordingly, but we'd have to\n-                        // make trans do the right thing, and it would\n-                        // only work for `Box<[T]>`s. It seems simpler\n-                        // to just require that people call\n-                        // `vec.pop()` or `vec.unshift()`.\n-                        let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);\n-                        delegate.borrow(pat.id, pat.span,\n-                                        slice_cmt, slice_r,\n-                                        slice_bk, RefBinding);\n-                    }\n-                    _ => { }\n+                PatKind::Vec(_, Some(ref slice_pat), _) => {\n+                    // The `slice_pat` here creates a slice into\n+                    // the original vector.  This is effectively a\n+                    // borrow of the elements of the vector being\n+                    // matched.\n+\n+                    let (slice_cmt, slice_mutbl, slice_r) =\n+                        return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n+\n+                    // Note: We declare here that the borrow\n+                    // occurs upon entering the `[...]`\n+                    // pattern. This implies that something like\n+                    // `[a; b]` where `a` is a move is illegal,\n+                    // because the borrow is already in effect.\n+                    // In fact such a move would be safe-ish, but\n+                    // it effectively *requires* that we use the\n+                    // nulling out semantics to indicate when a\n+                    // value has been moved, which we are trying\n+                    // to move away from.  Otherwise, how can we\n+                    // indicate that the first element in the\n+                    // vector has been moved?  Eventually, we\n+                    // could perhaps modify this rule to permit\n+                    // `[..a, b]` where `b` is a move, because in\n+                    // that case we can adjust the length of the\n+                    // original vec accordingly, but we'd have to\n+                    // make trans do the right thing, and it would\n+                    // only work for `Box<[T]>`s. It seems simpler\n+                    // to just require that people call\n+                    // `vec.pop()` or `vec.unshift()`.\n+                    let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);\n+                    delegate.borrow(pat.id, pat.span,\n+                                    slice_cmt, slice_r,\n+                                    slice_bk, RefBinding);\n                 }\n+                _ => {}\n             }\n         }));\n \n@@ -1057,14 +1040,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             let tcx = infcx.tcx;\n \n             match pat.node {\n-                PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::QPath(..) |\n-                PatKind::Ident(_, _, None) | PatKind::Struct(..) => {\n+                PatKind::Struct(..) | PatKind::TupleStruct(..) |\n+                PatKind::Path(..) | PatKind::QPath(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n-                        None => {\n-                            // no definition found: pat is not a\n-                            // struct or enum pattern.\n-                        }\n-\n                         Some(Def::Variant(enum_did, variant_did)) => {\n                             let downcast_cmt =\n                                 if tcx.lookup_adt_def(enum_did).is_univariant() {\n@@ -1094,14 +1072,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n \n                         Some(Def::Const(..)) |\n-                        Some(Def::AssociatedConst(..)) |\n-                        Some(Def::Local(..)) => {\n+                        Some(Def::AssociatedConst(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no\n                             // `matched_pat` call.\n                         }\n \n-                        Some(def) => {\n+                        def => {\n                             // An enum type should never be in a pattern.\n                             // Remaining cases are e.g. Def::Fn, to\n                             // which identifiers within patterns\n@@ -1121,16 +1098,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                PatKind::Ident(_, _, Some(_)) => {\n-                    // Do nothing; this is a binding (not an enum\n-                    // variant or struct), and the cat_pattern call\n-                    // will visit the substructure recursively.\n-                }\n-\n                 PatKind::Wild | PatKind::Tuple(..) | PatKind::Box(..) |\n                 PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n-                PatKind::Vec(..) => {\n-                    // Similarly, each of these cases does not\n+                PatKind::Vec(..) | PatKind::Binding(..) => {\n+                    // Each of these cases does not\n                     // correspond to an enum variant or struct, so we\n                     // do not do any `matched_pat` calls for these\n                     // cases either."}, {"sha": "f6ea10a70eb2a7aa1fa911576a6989aa278dd7f8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -380,9 +380,7 @@ fn visit_fn(ir: &mut IrMaps,\n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     for arg in &decl.inputs {\n-        pat_util::pat_bindings(&ir.tcx.def_map,\n-                               &arg.pat,\n-                               |_bm, arg_id, _x, path1| {\n+        pat_util::pat_bindings(&arg.pat, |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n             fn_maps.add_variable(Arg(arg_id, name));\n@@ -415,7 +413,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, &local.pat, |_, p_id, sp, path1| {\n+    pat_util::pat_bindings(&local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -429,7 +427,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     for pat in &arm.pats {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &pat, |bm, p_id, sp, path1| {\n+        pat_util::pat_bindings(&pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n@@ -589,7 +587,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n-        pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n+        pat_util::pat_bindings(pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n@@ -1567,9 +1565,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n-            pat_util::pat_bindings(&self.ir.tcx.def_map,\n-                                   &arg.pat,\n-                                   |_bm, p_id, sp, path1| {\n+            pat_util::pat_bindings(&arg.pat, |_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;"}, {"sha": "31e3db51f55d859db24bb4a87ca3f068036f5778", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -306,7 +306,7 @@ impl MutabilityCategory {\n     fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n-                PatKind::Ident(bind_mode, _, _) => {\n+                PatKind::Binding(bind_mode, _, _) => {\n                     if bind_mode == hir::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n@@ -398,7 +398,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            PatKind::Ident(hir::BindByRef(_), _, _) => {\n+            PatKind::Binding(hir::BindByRef(_), _, _) => {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n@@ -1276,11 +1276,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Ident(_, _, None) => {\n+          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Binding(_, _, None) => {\n               // Lone constant, or unit variant or identifier: ignore\n           }\n \n-          PatKind::Ident(_, _, Some(ref subpat)) => {\n+          PatKind::Binding(_, _, Some(ref subpat)) => {\n               self.cat_pattern_(cmt, &subpat, op)?;\n           }\n "}, {"sha": "3efc584ae2b66df3f1a52480fdc021ce391575f4", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -752,13 +752,9 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n-    // If this is a binding (or maybe a binding, I'm too lazy to check\n-    // the def map) then record the lifetime of that binding.\n-    match pat.node {\n-        PatKind::Ident(..) => {\n-            record_var_lifetime(visitor, pat.id, pat.span);\n-        }\n-        _ => { }\n+    // If this is a binding then record the lifetime of that binding.\n+    if let PatKind::Binding(..) = pat.node {\n+        record_var_lifetime(visitor, pat.id, pat.span);\n     }\n \n     intravisit::walk_pat(visitor, pat);\n@@ -958,7 +954,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     ///        | box P&\n     fn is_binding_pat(pat: &hir::Pat) -> bool {\n         match pat.node {\n-            PatKind::Ident(hir::BindByRef(_), _, _) => true,\n+            PatKind::Binding(hir::BindByRef(_), _, _) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))"}, {"sha": "24f0671ce6184c2c03a396653ecb9a329df81421", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -2216,7 +2216,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    PatKind::Ident(_, ref path1, _) => path1.node.as_str(),\n+                    PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },"}, {"sha": "a4df02872166986c698ec10fae4477552ad147e1", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -173,11 +173,11 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n-        pat_util::pat_contains_ref_binding(&self.def_map, pat)\n+        pat_util::pat_contains_ref_binding(pat)\n     }\n \n     pub fn arm_contains_ref_binding(self, arm: &hir::Arm) -> Option<hir::Mutability> {\n-        pat_util::arm_contains_ref_binding(&self.def_map, arm)\n+        pat_util::arm_contains_ref_binding(arm)\n     }\n \n     /// Returns the type of element at index `i` in tuple or tuple-like type `t`."}, {"sha": "8682661d35a849053f5982581dd7b6f933c82bc8", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Ident(_, ref path1, _) => {\n+        PatKind::Binding(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  name: path1.node})\n         },"}, {"sha": "49fa1896ff8dd68cd8b9fbc589d89e43509a421b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 62, "deletions": 87, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -239,31 +239,28 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n     pat.walk(|p| {\n-        match p.node {\n-            PatKind::Ident(hir::BindByValue(hir::MutImmutable), name, None) => {\n-                let pat_ty = cx.tcx.pat_ty(p);\n-                if let ty::TyEnum(edef, _) = pat_ty.sty {\n-                    let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-                    if let Some(Def::Local(..)) = def {\n-                        if edef.variants.iter().any(|variant|\n-                            variant.name == name.node.unhygienize()\n-                                && variant.kind() == VariantKind::Unit\n-                        ) {\n-                            let ty_path = cx.tcx.item_path_str(edef.did);\n-                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                                \"pattern binding `{}` is named the same as one \\\n-                                 of the variants of the type `{}`\",\n-                                name.node, ty_path);\n-                            help!(err,\n-                                \"if you meant to match on a variant, \\\n-                                 consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_path, name.node);\n-                            err.emit();\n-                        }\n+        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n+            let pat_ty = cx.tcx.pat_ty(p);\n+            if let ty::TyEnum(edef, _) = pat_ty.sty {\n+                let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n+                if let Some(Def::Local(..)) = def {\n+                    if edef.variants.iter().any(|variant|\n+                        variant.name == name.node.unhygienize()\n+                            && variant.kind() == VariantKind::Unit\n+                    ) {\n+                        let ty_path = cx.tcx.item_path_str(edef.did);\n+                        let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                            \"pattern binding `{}` is named the same as one \\\n+                             of the variants of the type `{}`\",\n+                            name.node, ty_path);\n+                        help!(err,\n+                            \"if you meant to match on a variant, \\\n+                             consider making the path in the pattern qualified: `{}::{}`\",\n+                            ty_path, name.node);\n+                        err.emit();\n                     }\n                 }\n             }\n-            _ => ()\n         }\n         true\n     });\n@@ -371,8 +368,8 @@ fn check_arms(cx: &MatchCheckCtxt,\n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n     match p.node {\n-        PatKind::Ident(_, _, None) => pat_is_binding(dm, p),\n-        PatKind::Ident(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n+        PatKind::Binding(_, _, None) => true,\n+        PatKind::Binding(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n         PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n         PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n         _ => false\n@@ -381,7 +378,7 @@ fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n \n fn raw_pat(p: &Pat) -> &Pat {\n     match p.node {\n-        PatKind::Ident(_, _, Some(ref s)) => raw_pat(&s),\n+        PatKind::Binding(_, _, Some(ref s)) => raw_pat(&s),\n         _ => p\n     }\n }\n@@ -487,11 +484,10 @@ impl<'map> IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            PatKind::Ident(..) | PatKind::Path(..) | PatKind::QPath(..) => {\n+            PatKind::Path(..) | PatKind::QPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n-                    Some(Def::AssociatedConst(did)) |\n-                    Some(Def::Const(did)) => {\n+                    Some(Def::AssociatedConst(did)) | Some(Def::Const(did)) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n@@ -717,7 +713,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n         let left_ty = cx.tcx.pat_ty(&real_pat);\n \n         match real_pat.node {\n-            PatKind::Ident(hir::BindByRef(..), _, _) => {\n+            PatKind::Binding(hir::BindByRef(..), _, _) => {\n                 left_ty.builtin_deref(false, NoPreference).unwrap().ty\n             }\n             _ => left_ty,\n@@ -752,10 +748,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n             }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n-                if pat_is_binding_or_wild(&cx.tcx.def_map.borrow(), raw_pat(r[0])) {\n-                    Some(r[1..].to_vec())\n-                } else {\n-                    None\n+                match raw_pat(r[0]).node {\n+                    PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n+                    _ => None,\n                 }\n             }).collect();\n             match is_useful(cx, &matrix, &v[1..], witness) {\n@@ -804,38 +799,37 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::Ident(..) =>\n+        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat.span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n                 Def::Variant(_, id) => vec![Variant(id)],\n-                Def::Local(..) => vec![],\n                 def => span_bug!(pat.span, \"pat_constructors: unexpected \\\n                                             definition {:?}\", def),\n             },\n         PatKind::QPath(..) =>\n             span_bug!(pat.span, \"const pattern should've been rewritten\"),\n         PatKind::Lit(ref expr) =>\n-            vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n+            vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n         PatKind::Range(ref lo, ref hi) =>\n-            vec!(ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))),\n+            vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))],\n         PatKind::Vec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n-                ty::TyArray(_, _) => vec!(Single),\n+                ty::TyArray(_, _) => vec![Single],\n                 _                      => if slice.is_some() {\n                     (before.len() + after.len()..max_slice_length+1)\n                         .map(|length| Slice(length))\n                         .collect()\n                 } else {\n-                    vec!(Slice(before.len() + after.len()))\n+                    vec![Slice(before.len() + after.len())]\n                 }\n             },\n         PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n-            vec!(Single),\n-        PatKind::Wild =>\n-            vec!(),\n+            vec![Single],\n+        PatKind::Binding(..) | PatKind::Wild =>\n+            vec![],\n     }\n }\n \n@@ -897,18 +891,17 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n-        PatKind::Wild =>\n+        PatKind::Binding(..) | PatKind::Wild =>\n             Some(vec![DUMMY_WILD_PAT; arity]),\n \n-        PatKind::Path(..) | PatKind::Ident(..) => {\n+        PatKind::Path(..) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n-                Def::Local(..) => Some(vec![DUMMY_WILD_PAT; arity]),\n                 _ => span_bug!(pat_span, \"specialize: unexpected \\\n                                           definition {:?}\", def),\n             }\n@@ -1095,17 +1088,11 @@ fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A>\n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n                                    pats: &[P<Pat>]) {\n-    let tcx = cx.tcx;\n-    let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat_bindings(def_map, &pat, |bm, _, span, _path| {\n-            match bm {\n-                hir::BindByRef(_) => {\n-                    by_ref_span = Some(span);\n-                }\n-                hir::BindByValue(_) => {\n-                }\n+        pat_bindings(&pat, |bm, _, span, _path| {\n+            if let hir::BindByRef(..) = bm {\n+                by_ref_span = Some(span);\n             }\n         })\n     }\n@@ -1114,7 +1101,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(&def_map.borrow(), &p)) {\n+        if sub.map_or(false, |p| pat_contains_bindings(&p)) {\n             span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n             span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n@@ -1128,28 +1115,15 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if pat_is_binding(&def_map.borrow(), &p) {\n-                match p.node {\n-                    PatKind::Ident(hir::BindByValue(_), _, ref sub) => {\n-                        let pat_ty = tcx.node_id_to_type(p.id);\n-                        //FIXME: (@jroesch) this code should be floated up as well\n-                        cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                                          ProjectionMode::AnyFinal).enter(|infcx| {\n-                            if infcx.type_moves_by_default(pat_ty, pat.span) {\n-                                check_move(p, sub.as_ref().map(|p| &**p));\n-                            }\n-                        });\n-                    }\n-                    PatKind::Ident(hir::BindByRef(_), _, _) => {\n+            if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n+                let pat_ty = cx.tcx.node_id_to_type(p.id);\n+                //FIXME: (@jroesch) this code should be floated up as well\n+                cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n+                                  ProjectionMode::AnyFinal).enter(|infcx| {\n+                    if infcx.type_moves_by_default(pat_ty, pat.span) {\n+                        check_move(p, sub.as_ref().map(|p| &**p));\n                     }\n-                    _ => {\n-                        span_bug!(\n-                            p.span,\n-                            \"binding pattern {} is not an identifier: {:?}\",\n-                            p.id,\n-                            p.node);\n-                    }\n-                }\n+                });\n             }\n             true\n         });\n@@ -1218,18 +1192,19 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n-        if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) {\n-            span_err!(self.cx.tcx.sess, pat.span, E0303,\n-                                      \"pattern bindings are not allowed \\\n-                                       after an `@`\");\n-        }\n-\n         match pat.node {\n-            PatKind::Ident(_, _, Some(_)) => {\n-                let bindings_were_allowed = self.bindings_allowed;\n-                self.bindings_allowed = false;\n-                intravisit::walk_pat(self, pat);\n-                self.bindings_allowed = bindings_were_allowed;\n+            PatKind::Binding(_, _, ref subpat) => {\n+                if !self.bindings_allowed {\n+                    span_err!(self.cx.tcx.sess, pat.span, E0303,\n+                              \"pattern bindings are not allowed after an `@`\");\n+                }\n+\n+                if subpat.is_some() {\n+                    let bindings_were_allowed = self.bindings_allowed;\n+                    self.bindings_allowed = false;\n+                    intravisit::walk_pat(self, pat);\n+                    self.bindings_allowed = bindings_were_allowed;\n+                }\n             }\n             _ => intravisit::walk_pat(self, pat),\n         }"}, {"sha": "4c4dea406ba9e80cac255c0d07d9fe5a20c58057", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -274,9 +274,9 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &PatKind::Ident(_, ref path1, _) = &p.node {\n-            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-            if let Some(Def::Local(..)) = def {\n+        if let &PatKind::Binding(_, ref path1, _) = &p.node {\n+            // Exclude parameter names from foreign functions (they have no `Def`)\n+            if cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def()).is_some() {\n                 self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n             }\n         }\n@@ -360,12 +360,14 @@ impl LateLintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&PatKind::Ident(_, ref path1, _), Some(Def::Const(..))) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node, p.span);\n+        if let PatKind::Path(ref path) = p.node {\n+            if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n+                if let Some(Def::Const(..)) = cx.tcx.def_map.borrow().get(&p.id)\n+                                                                     .map(|d| d.full_def()) {\n+                    NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n+                                                          path.segments[0].name, path.span);\n+                }\n             }\n-            _ => {}\n         }\n     }\n }"}, {"sha": "3005f564ff41a4fb87b074db3c8ecbce9c714472", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -171,7 +171,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 }\n             });\n             for fieldpat in field_pats {\n-                if let PatKind::Ident(_, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.unhygienize() == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\"}, {"sha": "b765043da885363e23df9b2811a3dfb97ba18539", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -43,7 +43,7 @@ impl UnusedMut {\n \n         let mut mutables = FnvHashMap();\n         for p in pats {\n-            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n+            pat_util::pat_bindings(p, |mode, id, _, path1| {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {"}, {"sha": "e0c35a6fba84f3d253792f874918c57e65dbb27f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -744,7 +744,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n-        if let PatKind::Ident(_, ref path1, _) = arg.pat.node {\n+        if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n             let name = path1.node.as_str();\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {"}, {"sha": "9d7818a9ba4d67e0c8ea5bdac6a677e5b65cd78c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -14,7 +14,6 @@ use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n-use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n use syntax::abi::Abi;\n use syntax::ast;\n@@ -221,7 +220,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref: by_ref\n             };\n             if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n-                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }\n             }\n@@ -333,10 +332,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             let mut name = keywords::Invalid.name();\n             if let Some(pat) = pattern {\n-                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n-                    if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n-                        name = ident.node;\n-                    }\n+                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n+                    name = ident.node;\n                 }\n             }\n "}, {"sha": "1f560672b62a8e8a6a7754ec4d588be7f4a0117c", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -656,7 +656,7 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         None\n     } else {\n         map = FnvHashMap();\n-        pat_util::pat_bindings(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n+        pat_util::pat_bindings(&arm.pats[0], |_, p_id, _, path| {\n             map.insert(path.node, p_id);\n         });\n         Some(&map)"}, {"sha": "acde81979f92713fd97e35e891a5dfa94f5c373c", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -13,7 +13,7 @@ use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n-use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const, pat_is_binding};\n+use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n@@ -81,7 +81,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            PatKind::Path(..) | PatKind::Ident(..) | PatKind::QPath(..)\n+            PatKind::Path(..) | PatKind::QPath(..)\n                 if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n@@ -167,9 +167,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Ident(bm, ref ident, ref sub)\n-                if pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) =>\n-            {\n+            PatKind::Binding(bm, ref ident, ref sub) => {\n                 let id = match self.binding_map {\n                     None => pat.id,\n                     Some(ref map) => map[&ident.node],\n@@ -210,7 +208,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Ident(..) | PatKind::Path(..) => {\n+            PatKind::Path(..) => {\n                 self.variant_or_leaf(pat, vec![])\n             }\n "}, {"sha": "419e19532dd7c3e738360cc2d5dd7c4f703c8317", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 55, "deletions": 68, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -424,12 +424,11 @@ impl<'a, 'p, 'blk, 'tcx> fmt::Debug for Match<'a, 'p, 'blk, 'tcx> {\n \n fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     for br in m {\n-        match br.pats[col].node {\n-            PatKind::Ident(_, _, Some(_)) => return true,\n-            _ => ()\n+        if let PatKind::Binding(_, _, Some(..)) = br.pats[col].node {\n+            return true\n         }\n     }\n-    return false;\n+    false\n }\n \n // As noted in `fn match_datum`, we should eventually pass around a\n@@ -481,7 +480,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let mut pat = br.pats[col];\n         loop {\n             pat = match pat.node {\n-                PatKind::Ident(_, ref path, Some(ref inner)) => {\n+                PatKind::Binding(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node, val.val));\n                     &inner\n                 },\n@@ -501,7 +500,6 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                          dm: &RefCell<DefMap>,\n                                           m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                           col: usize,\n                                           val: MatchInput,\n@@ -518,13 +516,11 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n-                PatKind::Ident(_, ref path, None) => {\n-                    if pat_is_binding(&dm.borrow(), &this) {\n-                        bound_ptrs.push((path.node, val.val));\n-                    }\n+                PatKind::Binding(_, ref path, None) => {\n+                    bound_ptrs.push((path.node, val.val));\n                 }\n                 PatKind::Vec(ref before, Some(ref slice), ref after) => {\n-                    if let PatKind::Ident(_, ref path, None) = slice.node {\n+                    if let PatKind::Binding(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n@@ -544,7 +540,6 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n }\n \n fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     dm: &RefCell<DefMap>,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                      col: usize,\n                                      val: MatchInput)\n@@ -554,13 +549,14 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n-    enter_match(bcx, dm, m, col, val, |pats| {\n-        if pat_is_binding_or_wild(&dm.borrow(), &pats[col]) {\n-            let mut r = pats[..col].to_vec();\n-            r.extend_from_slice(&pats[col + 1..]);\n-            Some(r)\n-        } else {\n-            None\n+    enter_match(bcx, m, col, val, |pats| {\n+        match pats[col].node {\n+            PatKind::Binding(..) | PatKind::Wild => {\n+                let mut r = pats[..col].to_vec();\n+                r.extend_from_slice(&pats[col + 1..]);\n+                Some(r)\n+            }\n+            _ => None\n         }\n     })\n }\n@@ -596,7 +592,6 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              bcx: Block<'blk, 'tcx>,\n              _: ast::NodeId,\n-             dm: &RefCell<DefMap>,\n              m: &[Match<'a, 'p, 'blk, 'tcx>],\n              opt: &Opt,\n              col: usize,\n@@ -628,7 +623,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         tcx: bcx.tcx(),\n         param_env: param_env,\n     };\n-    enter_match(bcx, dm, m, col, val, |pats|\n+    enter_match(bcx, m, col, val, |pats|\n         check_match::specialize(&mcx, &pats[..], &ctor, col, variant_size)\n     )\n }\n@@ -659,9 +654,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             PatKind::Lit(ref l) => {\n                 ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n-            PatKind::Ident(..) | PatKind::Path(..) |\n-            PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n-                // This is either an enum variant or a variable binding.\n+            PatKind::Path(..) | PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(Def::Variant(enum_id, var_id)) => {\n@@ -793,8 +786,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n         let pat = br.pats[col];\n         match pat.node {\n             PatKind::Tuple(..) => true,\n-            PatKind::Struct(..) | PatKind::TupleStruct(..) |\n-            PatKind::Path(..) | PatKind::Ident(_, _, None) => {\n+            PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => {\n                 match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n                     Def::Struct(..) | Def::TyAlias(..) => true,\n                     _ => false,\n@@ -839,7 +831,7 @@ impl FailureHandler {\n fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n     fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n-            PatKind::Ident(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n+            PatKind::Binding(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n             _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n             _ => 0\n         }\n@@ -1153,7 +1145,6 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n-    let dm = &tcx.def_map;\n \n     let mut vals_left = vals[0..col].to_vec();\n     vals_left.extend_from_slice(&vals[col + 1..]);\n@@ -1226,7 +1217,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n     match adt_vals {\n         Some(field_vals) => {\n-            let pats = enter_match(bcx, dm, m, col, val, |pats|\n+            let pats = enter_match(bcx, m, col, val, |pats|\n                 check_match::specialize(&mcx, pats,\n                                         &Constructor::Single, col,\n                                         field_vals.len())\n@@ -1287,7 +1278,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n \n-    let defaults = enter_default(else_cx, dm, m, col, val);\n+    let defaults = enter_default(else_cx, m, col, val);\n     let exhaustive = chk.is_infallible() && defaults.is_empty();\n     let len = opts.len();\n \n@@ -1391,7 +1382,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             ConstantValue(..) | ConstantRange(..) => ()\n         }\n-        let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n+        let opt_ms = enter_opt(opt_cx, pat_id, m, opt, col, size, val);\n         let mut opt_vals: Vec<_> = unpacked.into_iter()\n             .map(|v|MatchInput::from_val(v))\n             .collect();\n@@ -1517,10 +1508,9 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n     // Note that we use the names because each binding will have many ids\n     // from the various alternatives.\n     let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = FnvHashMap();\n-    pat_bindings(&tcx.def_map, &pat, |bm, p_id, span, path1| {\n+    pat_bindings(&pat, |bm, p_id, span, path1| {\n         let name = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1663,7 +1653,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n+        pat_bindings(pat, |_, p_id, _, path1| {\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path1.node, scope, (),\n@@ -1796,38 +1786,35 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        PatKind::Ident(pat_binding_mode, ref path1, ref inner) => {\n-            if pat_is_binding(&tcx.def_map.borrow(), &pat) {\n-                // Allocate the stack slot where the value of this\n-                // binding will live and place it into the appropriate\n-                // map.\n-                bcx = mk_binding_alloca(\n-                    bcx, pat.id, path1.node, cleanup_scope, (),\n-                    \"_match::bind_irrefutable_pat\",\n-                    |(), bcx, Datum { val: llval, ty, kind: _ }| {\n-                        match pat_binding_mode {\n-                            hir::BindByValue(_) => {\n-                                // By value binding: move the value that `val`\n-                                // points at into the binding's stack slot.\n-                                let d = val.to_datum(ty);\n-                                d.store_to(bcx, llval)\n-                            }\n+        PatKind::Binding(pat_binding_mode, ref path1, ref inner) => {\n+            // Allocate the stack slot where the value of this\n+            // binding will live and place it into the appropriate\n+            // map.\n+            bcx = mk_binding_alloca(bcx, pat.id, path1.node, cleanup_scope, (),\n+                                    \"_match::bind_irrefutable_pat\",\n+                                    |(), bcx, Datum { val: llval, ty, kind: _ }| {\n+                match pat_binding_mode {\n+                    hir::BindByValue(_) => {\n+                        // By value binding: move the value that `val`\n+                        // points at into the binding's stack slot.\n+                        let d = val.to_datum(ty);\n+                        d.store_to(bcx, llval)\n+                    }\n \n-                            hir::BindByRef(_) => {\n-                                // By ref binding: the value of the variable\n-                                // is the pointer `val` itself or fat pointer referenced by `val`\n-                                if type_is_fat_ptr(bcx.tcx(), ty) {\n-                                    expr::copy_fat_ptr(bcx, val.val, llval);\n-                                }\n-                                else {\n-                                    Store(bcx, val.val, llval);\n-                                }\n-\n-                                bcx\n-                            }\n+                    hir::BindByRef(_) => {\n+                        // By ref binding: the value of the variable\n+                        // is the pointer `val` itself or fat pointer referenced by `val`\n+                        if type_is_fat_ptr(bcx.tcx(), ty) {\n+                            expr::copy_fat_ptr(bcx, val.val, llval);\n                         }\n-                    });\n-            }\n+                        else {\n+                            Store(bcx, val.val, llval);\n+                        }\n+\n+                        bcx\n+                    }\n+                }\n+            });\n \n             if let Some(ref inner_pat) = *inner {\n                 bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n@@ -1941,7 +1928,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Binding(hir::BindByRef(..),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -1960,7 +1947,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Binding(hir::BindByRef(..),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -2001,8 +1988,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         cleanup_scope)\n                 });\n         }\n-        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild | PatKind::Lit(_) |\n-        PatKind::Range(_, _) => ()\n+        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild |\n+        PatKind::Lit(..) | PatKind::Range(..) => ()\n     }\n     return bcx;\n }"}, {"sha": "bba0edd5f0496d283c7a5daaeae763a0a01907b6", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 57, "deletions": 70, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -42,16 +42,13 @@ pub fn create_scope_map(cx: &CrateContext,\n                         fn_ast_id: ast::NodeId)\n                         -> NodeMap<DIScope> {\n     let mut scope_map = NodeMap();\n-\n-    let def_map = &cx.tcx().def_map;\n-\n     let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n     scope_map.insert(fn_ast_id, fn_metadata);\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args {\n-        pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, _, path1| {\n+        pat_util::pat_bindings(&arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                name: Some(path1.node.unhygienize()) });\n             scope_map.insert(node_id, fn_metadata);\n@@ -235,76 +232,66 @@ fn walk_pattern(cx: &CrateContext,\n                 pat: &hir::Pat,\n                 scope_stack: &mut Vec<ScopeStackEntry> ,\n                 scope_map: &mut NodeMap<DIScope>) {\n-\n-    let def_map = &cx.tcx().def_map;\n-\n     // Unfortunately, we cannot just use pat_util::pat_bindings() or\n     // ast_util::walk_pat() here because we have to visit *all* nodes in\n     // order to put them into the scope map. The above functions don't do that.\n     match pat.node {\n-        PatKind::Ident(_, ref path1, ref sub_pat_opt) => {\n-\n-            // Check if this is a binding. If so we need to put it on the\n-            // scope stack and maybe introduce an artificial scope\n-            if pat_util::pat_is_binding(&def_map.borrow(), &pat) {\n-\n-                let name = path1.node.unhygienize();\n-\n-                // LLVM does not properly generate 'DW_AT_start_scope' fields\n-                // for variable DIEs. For this reason we have to introduce\n-                // an artificial scope at bindings whenever a variable with\n-                // the same name is declared in *any* parent scope.\n-                //\n-                // Otherwise the following error occurs:\n-                //\n-                // let x = 10;\n-                //\n-                // do_something(); // 'gdb print x' correctly prints 10\n-                //\n-                // {\n-                //     do_something(); // 'gdb print x' prints 0, because it\n-                //                     // already reads the uninitialized 'x'\n-                //                     // from the next line...\n-                //     let x = 100;\n-                //     do_something(); // 'gdb print x' correctly prints 100\n-                // }\n-\n-                // Is there already a binding with that name?\n-                // N.B.: this comparison must be UNhygienic... because\n-                // gdb knows nothing about the context, so any two\n-                // variables with the same name will cause the problem.\n-                let need_new_scope = scope_stack\n-                    .iter()\n-                    .any(|entry| entry.name == Some(name));\n-\n-                if need_new_scope {\n-                    // Create a new lexical scope and push it onto the stack\n-                    let loc = span_start(cx, pat.span);\n-                    let file_metadata = file_metadata(cx, &loc.file.name);\n-                    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-                    let scope_metadata = unsafe {\n-                        llvm::LLVMDIBuilderCreateLexicalBlock(\n-                            DIB(cx),\n-                            parent_scope,\n-                            file_metadata,\n-                            loc.line as c_uint,\n-                            loc.col.to_usize() as c_uint)\n-                    };\n-\n-                    scope_stack.push(ScopeStackEntry {\n-                        scope_metadata: scope_metadata,\n-                        name: Some(name)\n-                    });\n-\n-                } else {\n-                    // Push a new entry anyway so the name can be found\n-                    let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n-                    scope_stack.push(ScopeStackEntry {\n-                        scope_metadata: prev_metadata,\n-                        name: Some(name)\n-                    });\n-                }\n+        PatKind::Binding(_, ref path1, ref sub_pat_opt) => {\n+            // LLVM does not properly generate 'DW_AT_start_scope' fields\n+            // for variable DIEs. For this reason we have to introduce\n+            // an artificial scope at bindings whenever a variable with\n+            // the same name is declared in *any* parent scope.\n+            //\n+            // Otherwise the following error occurs:\n+            //\n+            // let x = 10;\n+            //\n+            // do_something(); // 'gdb print x' correctly prints 10\n+            //\n+            // {\n+            //     do_something(); // 'gdb print x' prints 0, because it\n+            //                     // already reads the uninitialized 'x'\n+            //                     // from the next line...\n+            //     let x = 100;\n+            //     do_something(); // 'gdb print x' correctly prints 100\n+            // }\n+\n+            // Is there already a binding with that name?\n+            // N.B.: this comparison must be UNhygienic... because\n+            // gdb knows nothing about the context, so any two\n+            // variables with the same name will cause the problem.\n+            let name = path1.node.unhygienize();\n+            let need_new_scope = scope_stack\n+                .iter()\n+                .any(|entry| entry.name == Some(name));\n+\n+            if need_new_scope {\n+                // Create a new lexical scope and push it onto the stack\n+                let loc = span_start(cx, pat.span);\n+                let file_metadata = file_metadata(cx, &loc.file.name);\n+                let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+                let scope_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateLexicalBlock(\n+                        DIB(cx),\n+                        parent_scope,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        loc.col.to_usize() as c_uint)\n+                };\n+\n+                scope_stack.push(ScopeStackEntry {\n+                    scope_metadata: scope_metadata,\n+                    name: Some(name)\n+                });\n+\n+            } else {\n+                // Push a new entry anyway so the name can be found\n+                let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n+                scope_stack.push(ScopeStackEntry {\n+                    scope_metadata: prev_metadata,\n+                    name: Some(name)\n+                });\n             }\n \n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);"}, {"sha": "ab4860dff1510ce414e376be32cccfd9f677c20b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -1889,11 +1889,8 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n         return;\n     }\n \n-    let cx = bcx.ccx();\n-    let def_map = &cx.tcx().def_map;\n     let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, &local.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(&local.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n@@ -1945,7 +1942,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(hir_map::NodeLocal(pat)) => {\n             match pat.node {\n-                PatKind::Ident(_, ref path1, _) => {\n+                PatKind::Binding(_, ref path1, _) => {\n                     path1.node\n                 }\n                 _ => {\n@@ -2062,15 +2059,14 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n         return;\n     }\n \n-    let def_map = &bcx.tcx().def_map;\n     let scope_metadata = bcx\n                          .fcx\n                          .debug_context\n                          .get_ref(arg.pat.span)\n                          .fn_metadata;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(&arg.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {"}, {"sha": "99b443e292491fed7164c2950f2ff1c1704a001f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def::{self, Def};\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n+use hir::pat_util::{PatIdMap, pat_id_map};\n use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n@@ -149,8 +149,7 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n-            PatKind::Path(..) | PatKind::Ident(..)\n-                    if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n+            PatKind::Path(..) if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n                 if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n                     let const_did = pat_def.def_id();\n                     let const_scheme = tcx.lookup_item_type(const_did);\n@@ -170,8 +169,7 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                     self.write_error(pat.id);\n                 }\n             }\n-            PatKind::Ident(bm, ref path, ref sub)\n-                    if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n+            PatKind::Binding(bm, ref path, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     hir::BindByRef(mutbl) => {\n@@ -211,10 +209,6 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            PatKind::Ident(_, ref path, _) => {\n-                let path = hir::Path::from_name(path.span, path.node);\n-                self.check_pat_enum(pat, &path, &[], None, expected, false);\n-            }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n                 self.check_pat_enum(pat, path, &subpats, ddpos, expected, true);\n             }\n@@ -442,23 +436,19 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n-        let tcx = self.tcx;\n-        if pat_is_binding(&tcx.def_map.borrow(), inner) {\n-            let expected = self.shallow_resolve(expected);\n-            expected.builtin_deref(true, ty::NoPreference).map_or(true, |mt| match mt.ty.sty {\n-                ty::TyTrait(_) => {\n+        if let PatKind::Binding(..) = inner.node {\n+            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n+                if let ty::TyTrait(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    span_err!(tcx.sess, span, E0033,\n+                    span_err!(self.tcx.sess, span, E0033,\n                               \"type `{}` cannot be dereferenced\",\n                               self.ty_to_string(expected));\n-                    false\n+                    return false\n                 }\n-                _ => true\n-            })\n-        } else {\n-            true\n+            }\n         }\n+        true\n     }\n }\n \n@@ -497,7 +487,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for arm in arms {\n             let pcx = PatCtxt {\n                 fcx: self,\n-                map: pat_id_map(&tcx.def_map, &arm.pats[0]),\n+                map: pat_id_map(&arm.pats[0]),\n             };\n             for p in &arm.pats {\n                 pcx.check_pat(&p, discrim_ty);"}, {"sha": "de45883c872a56906bb830b7c3dd2381ecf1bece", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -573,19 +573,17 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if let PatKind::Ident(_, ref path1, _) = p.node {\n-            if pat_util::pat_is_binding(&self.fcx.tcx.def_map.borrow(), p) {\n-                let var_ty = self.assign(p.span, p.id, None);\n-\n-                self.fcx.require_type_is_sized(var_ty, p.span,\n-                                               traits::VariableType(p.id));\n-\n-                debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n-                       path1.node,\n-                       self.fcx.ty_to_string(\n-                           self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n-                       var_ty);\n-            }\n+        if let PatKind::Binding(_, ref path1, _) = p.node {\n+            let var_ty = self.assign(p.span, p.id, None);\n+\n+            self.fcx.require_type_is_sized(var_ty, p.span,\n+                                           traits::VariableType(p.id));\n+\n+            debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n+                   path1.node,\n+                   self.fcx.ty_to_string(\n+                       self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n+                   var_ty);\n         }\n         intravisit::walk_pat(self, p);\n     }\n@@ -633,8 +631,6 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             body: &'gcx hir::Block)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n-    let tcx = inherited.tcx;\n-\n     let arg_tys = &fn_sig.inputs;\n     let ret_ty = fn_sig.output;\n \n@@ -670,19 +666,15 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n \n             // Create type variables for each argument.\n-            pat_util::pat_bindings(\n-                &tcx.def_map,\n-                &input.pat,\n-                |_bm, pat_id, sp, _path| {\n-                    let var_ty = visit.assign(sp, pat_id, None);\n-                    fcx.require_type_is_sized(var_ty, sp,\n-                                              traits::VariableType(pat_id));\n-                });\n+            pat_util::pat_bindings(&input.pat, |_bm, pat_id, sp, _path| {\n+                let var_ty = visit.assign(sp, pat_id, None);\n+                fcx.require_type_is_sized(var_ty, sp, traits::VariableType(pat_id));\n+            });\n \n             // Check the pattern.\n             let pcx = PatCtxt {\n                 fcx: &fcx,\n-                map: pat_id_map(&tcx.def_map, &input.pat),\n+                map: pat_id_map(&input.pat),\n             };\n             pcx.check_pat(&input.pat, *arg_ty);\n         }\n@@ -3797,8 +3789,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n-        let tcx = self.tcx;\n-\n         let t = self.local_ty(local.span, local.id);\n         self.write_ty(local.id, t);\n \n@@ -3812,7 +3802,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let pcx = PatCtxt {\n             fcx: self,\n-            map: pat_id_map(&tcx.def_map, &local.pat),\n+            map: pat_id_map(&local.pat),\n         };\n         pcx.check_pat(&local.pat, t);\n         let pat_ty = self.node_ty(local.pat.id);"}, {"sha": "fd1b60551734cffcb1bc576f418b02203a5c7469", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -452,7 +452,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n         let tcx = self.tcx;\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n-        pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n+        pat_util::pat_bindings(pat, |_, id, span, _| {\n             // If we have a variable that contains region'd data, that\n             // data will be accessible from anywhere that the variable is\n             // accessed. We must be wary of loops like this:\n@@ -1160,7 +1160,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n-                    PatKind::Ident(hir::BindByRef(mutbl), _, _) => {\n+                    PatKind::Binding(hir::BindByRef(mutbl), _, _) => {\n                         self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n                                                         mutbl, sub_cmt);\n                     }"}, {"sha": "205eaf1a38e1494dc9ae2ce2ecb298d97cfc4a05", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -15,7 +15,6 @@ use self::ResolveReason::*;\n \n use check::FnCtxt;\n use hir::def_id::DefId;\n-use hir::pat_util;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n@@ -29,7 +28,7 @@ use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir;\n+use rustc::hir::{self, PatKind};\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point functions\n@@ -54,9 +53,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             wbcx.visit_pat(&arg.pat);\n \n             // Privacy needs the type for the whole pattern, not just each binding\n-            if !pat_util::pat_is_binding(&self.tcx.def_map.borrow(), &arg.pat) {\n-                wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n-                                   arg.pat.id);\n+            if let PatKind::Binding(..) = arg.pat.node {} else {\n+                wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.pat.id);\n             }\n         }\n         wbcx.visit_upvar_borrow_map();"}, {"sha": "92027a56ec1b0ac814a1d141c420f0b7680fcbf8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -2152,12 +2152,9 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n {\n     for i in &decl.inputs {\n         match i.pat.node {\n-            PatKind::Ident(_, _, _) => (),\n-            PatKind::Wild => (),\n-            _ => {\n-                span_err!(ccx.tcx.sess, i.pat.span, E0130,\n-                          \"patterns aren't allowed in foreign function declarations\");\n-            }\n+            PatKind::Binding(..) | PatKind::Wild => {}\n+            _ => span_err!(ccx.tcx.sess, i.pat.span, E0130,\n+                           \"patterns aren't allowed in foreign function declarations\")\n         }\n     }\n "}, {"sha": "bf503141ff642c09e5cdbb36207759788e578f29", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -2578,7 +2578,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n \n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n-        PatKind::Ident(_, ref p, _) => p.node.to_string(),\n+        PatKind::Binding(_, ref p, _) => p.node.to_string(),\n         PatKind::TupleStruct(ref p, _, _) | PatKind::Path(ref p) => path_to_string(p),\n         PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n                                 which is not allowed in function arguments\"),"}, {"sha": "741feb4ba3dd465859da7f66fba5a71ee6a70ca2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf9c60c9a6d27762594c1c5c067194f4c9109f67/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bf9c60c9a6d27762594c1c5c067194f4c9109f67", "patch": "@@ -616,14 +616,10 @@ pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n     Wild,\n \n-    /// A `PatKind::Ident` may either be a new bound variable,\n-    /// or a unit struct/variant pattern, or a const pattern (in the last two cases\n-    /// the third field must be `None`).\n-    ///\n-    /// In the unit or const pattern case, the parser can't determine\n-    /// which it is. The resolver determines this, and\n-    /// records this pattern's `NodeId` in an auxiliary\n-    /// set (of \"PatIdents that refer to unit patterns or constants\").\n+    /// A `PatKind::Ident` may either be a new bound variable (`ref mut binding @ OPT_SUBPATTERN`),\n+    /// or a unit struct/variant pattern, or a const pattern (in the last two cases the third\n+    /// field must be `None`). Disambiguation cannot be done with parser alone, so it happens\n+    /// during name resolution.\n     Ident(BindingMode, SpannedIdent, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`."}]}