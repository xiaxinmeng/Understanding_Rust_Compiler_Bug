{"sha": "2ed1aca101d449bb24d607ffbe436511e999573d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZDFhY2ExMDFkNDQ5YmIyNGQ2MDdmZmJlNDM2NTExZTk5OTU3M2Q=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T08:46:27Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-18T08:53:08Z"}, "message": "Only check existential types, not the desugared impl Trait", "tree": {"sha": "9681f4d6cffc71b3e7dd5394a2d08d70a1b2287e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9681f4d6cffc71b3e7dd5394a2d08d70a1b2287e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ed1aca101d449bb24d607ffbe436511e999573d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed1aca101d449bb24d607ffbe436511e999573d", "html_url": "https://github.com/rust-lang/rust/commit/2ed1aca101d449bb24d607ffbe436511e999573d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ed1aca101d449bb24d607ffbe436511e999573d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e215a3c87362d386206d8cca55710d2d5032e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e215a3c87362d386206d8cca55710d2d5032e18", "html_url": "https://github.com/rust-lang/rust/commit/3e215a3c87362d386206d8cca55710d2d5032e18"}], "stats": {"total": 108, "additions": 58, "deletions": 50}, "files": [{"sha": "d2c96221991600637b337d26bfd21afd85cc1eda", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 58, "deletions": 50, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/2ed1aca101d449bb24d607ffbe436511e999573d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ed1aca101d449bb24d607ffbe436511e999573d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=2ed1aca101d449bb24d607ffbe436511e999573d", "patch": "@@ -549,57 +549,65 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n         fldop: |ty| {\n             if let ty::TyAnon(def_id, substs) = ty.sty {\n                 trace!(\"check_existential_types: anon_ty, {:?}, {:?}\", def_id, substs);\n-                let anon_node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                if may_define_existential_type(tcx, fn_def_id, anon_node_id) {\n-                    let generics = tcx.generics_of(def_id);\n-                    trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n-                    for (subst, param) in substs.iter().zip(&generics.params) {\n-                        if let ty::subst::UnpackedKind::Type(ty) = subst.unpack() {\n-                            match ty.sty {\n-                                ty::TyParam(..) => {},\n-                                // prevent `fn foo() -> Foo<u32>` from being defining\n-                                _ => {\n-                                    tcx\n-                                        .sess\n-                                        .struct_span_err(\n-                                            span,\n-                                            \"non-defining existential type use in defining scope\",\n-                                        )\n-                                        .span_note(\n-                                            tcx.def_span(param.def_id),\n-                                            &format!(\n-                                                \"used non-generic type {} for generic parameter\",\n-                                                ty,\n-                                            ),\n-                                        )\n-                                        .emit();\n-                                    return tcx.types.err;\n-                                },\n-                            } // match ty\n-                        } // if let Type = subst\n-                    } // for (subst, param)\n-                } // if may_define_existential_type\n-\n-                // now register the bounds on the parameters of the existential type\n-                // so the parameters given by the function need to fulfil them\n-                // ```rust\n-                // existential type Foo<T: Bar>: 'static;\n-                // fn foo<U>() -> Foo<U> { .. *}\n-                // ```\n-                // becomes\n-                // ```rust\n-                // existential type Foo<T: Bar>: 'static;\n-                // fn foo<U: Bar>() -> Foo<U> { .. *}\n-                // ```\n-                let predicates = tcx.predicates_of(def_id);\n-                trace!(\"check_existential_types may define. adding predicates: {:#?}\", predicates);\n-                for &pred in predicates.predicates.iter() {\n-                    let substituted_pred = pred.subst(fcx.tcx, substs);\n-                    // Avoid duplication of predicates that contain no parameters, for example.\n-                    if !predicates.predicates.contains(&substituted_pred) {\n-                        substituted_predicates.push(substituted_pred);\n+                let generics = tcx.generics_of(def_id);\n+                // only check named existential types\n+                if generics.parent.is_none() {\n+                    let anon_node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                    if may_define_existential_type(tcx, fn_def_id, anon_node_id) {\n+                        trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n+                        for (subst, param) in substs.iter().zip(&generics.params) {\n+                            if let ty::subst::UnpackedKind::Type(ty) = subst.unpack() {\n+                                match ty.sty {\n+                                    ty::TyParam(..) => {},\n+                                    // prevent `fn foo() -> Foo<u32>` from being defining\n+                                    _ => {\n+                                        tcx\n+                                            .sess\n+                                            .struct_span_err(\n+                                                span,\n+                                                \"non-defining existential type use \\\n+                                                 in defining scope\",\n+                                            )\n+                                            .span_note(\n+                                                tcx.def_span(param.def_id),\n+                                                &format!(\n+                                                    \"used non-generic type {} for \\\n+                                                     generic parameter\",\n+                                                    ty,\n+                                                ),\n+                                            )\n+                                            .emit();\n+                                        return tcx.types.err;\n+                                    },\n+                                } // match ty\n+                            } // if let Type = subst\n+                        } // for (subst, param)\n+                    } // if may_define_existential_type\n+\n+                    // now register the bounds on the parameters of the existential type\n+                    // so the parameters given by the function need to fulfil them\n+                    // ```rust\n+                    // existential type Foo<T: Bar>: 'static;\n+                    // fn foo<U>() -> Foo<U> { .. *}\n+                    // ```\n+                    // becomes\n+                    // ```rust\n+                    // existential type Foo<T: Bar>: 'static;\n+                    // fn foo<U: Bar>() -> Foo<U> { .. *}\n+                    // ```\n+                    let predicates = tcx.predicates_of(def_id);\n+                    trace!(\n+                        \"check_existential_types may define. adding predicates: {:#?}\",\n+                        predicates,\n+                    );\n+                    for &pred in predicates.predicates.iter() {\n+                        let substituted_pred = pred.subst(fcx.tcx, substs);\n+                        // Avoid duplication of predicates that contain no parameters, for example.\n+                        if !predicates.predicates.contains(&substituted_pred) {\n+                            substituted_predicates.push(substituted_pred);\n+                        }\n                     }\n-                }\n+                } // if is_named_existential_type\n             } // if let TyAnon\n             ty\n         },"}]}