{"sha": "904f443fa99a6349a09441c645aa8f5e4d86fd25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNGY0NDNmYTk5YTYzNDlhMDk0NDFjNjQ1YWE4ZjVlNGQ4NmZkMjU=", "commit": {"author": {"name": "Rob Arnold", "email": "robarnold@68-26-94-7.pools.spcsdns.net", "date": "2011-06-14T15:25:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-05T18:57:06Z"}, "message": "Drop in libuv rev 2b5707d834a6b85b8e589ac04cb61a6db2dab94b", "tree": {"sha": "bf4b64d14c3081343f7740b735b878c91f42b7d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf4b64d14c3081343f7740b735b878c91f42b7d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/904f443fa99a6349a09441c645aa8f5e4d86fd25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/904f443fa99a6349a09441c645aa8f5e4d86fd25", "html_url": "https://github.com/rust-lang/rust/commit/904f443fa99a6349a09441c645aa8f5e4d86fd25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/904f443fa99a6349a09441c645aa8f5e4d86fd25/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6be83885f26c02888b17cdca78edb8d125e36cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6be83885f26c02888b17cdca78edb8d125e36cb", "html_url": "https://github.com/rust-lang/rust/commit/b6be83885f26c02888b17cdca78edb8d125e36cb"}], "stats": {"total": 64837, "additions": 64837, "deletions": 0}, "files": [{"sha": "333349590e627a3fdc1a55a8b539eadff55a371a", "filename": "src/rt/libuv/.gitignore", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2F.gitignore?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,28 @@\n+*.swp\n+*.o\n+*.lo\n+*.la\n+*.a\n+*.opensdf\n+*.orig\n+*.sdf\n+*.suo\n+*.vcxproj.filters\n+*.vcxproj.user\n+ev/.deps/\n+ev/.libs/\n+ev/Makefile\n+ev/config.h\n+ev/config.log\n+ev/config.status\n+ev/libtool\n+ev/stamp-h1\n+ev/autom4te.cache\n+/msvs/ipch/\n+/build/\n+test/run-tests\n+test/run-benchmarks\n+test/run-tests.exe\n+test/run-benchmarks.exe\n+test/run-benchmarks.dSYM/\n+test/run-tests.dSYM/"}, {"sha": "47b47d29aadb2755d81b0f42591a32b1683d5053", "filename": "src/rt/libuv/AUTHORS", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2FAUTHORS", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2FAUTHORS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FAUTHORS?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,6 @@\n+# Authors ordered by first contribution.\n+Ryan Dahl <ryan@joyent.com>\n+Bert Belder <bertbelder@gmail.com>\n+Josh Roesslein <jroesslein@gmail.com>\n+Alan Gutierrez <alan@prettyrobots.com>\n+Vanilla Hsu <vanilla@fatpipi.com>"}, {"sha": "3ed5bc5ed0db3b2f8fafe0347a89fd39329986ae", "filename": "src/rt/libuv/LICENSE", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FLICENSE?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,37 @@\n+libuv is part of the Node project: http://nodejs.org/\n+libuv may be distributed alone under Node's license:\n+\n+====\n+\n+Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to\n+deal in the Software without restriction, including without limitation the\n+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+sell copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+IN THE SOFTWARE.\n+\n+====\n+\n+This license applies to all parts of libuv that are not externally\n+maintained libraries.\n+\n+The externally maintained libraries used by libuv are:\n+\n+  - tree.h (from FreeBSD), copyright Niels Provos. Two clause BSD license.\n+\n+  - ngx_queue.h (from Nginx), copyright Igor Sysoev. Two clause BSD license.\n+\n+  - libev, located at ev/ is copyright Marc Alexander Lehmann, and\n+    dual-licensed under the MIT license and GPL2."}, {"sha": "4e2c2cd2614e160eed5ebe4ea31d6b8e9d843b3d", "filename": "src/rt/libuv/README", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FREADME?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,16 @@\n+This is the new networking layer for Node. Its purpose is to abstract\n+IOCP on windows and libev on Unix systems. We intend to eventually contain\n+all platform differences in this library.\n+\n+http://nodejs.org/\n+\n+(This was previously called liboio)\n+\n+Supported Platforms:\n+\n+Microsoft Windows operating systems since Windows XP sp2. It can be built\n+with either Visual Studio or MinGW.\n+\n+Linux 2.6 and MacOS using the GCC toolchain.\n+\n+Solaris 121 and later using GCC toolchain."}, {"sha": "cd6e159d50623dd8b27c06f3e02f6e7ea6fd1342", "filename": "src/rt/libuv/config-mingw.mk", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-mingw.mk?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,45 @@\n+# Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+#\n+# Permission is hereby granted, free of charge, to any person obtaining a copy\n+# of this software and associated documentation files (the \"Software\"), to\n+# deal in the Software without restriction, including without limitation the\n+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+# sell copies of the Software, and to permit persons to whom the Software is\n+# furnished to do so, subject to the following conditions:\n+#\n+# The above copyright notice and this permission notice shall be included in\n+# all copies or substantial portions of the Software.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+# IN THE SOFTWARE.\n+\n+# Use make -f Makefile.gcc PREFIX=i686-w64-mingw32-\n+# for cross compilation\n+CC = $(PREFIX)gcc\n+AR = $(PREFIX)ar\n+E=.exe\n+\n+CFLAGS=-g --std=gnu89 -Wno-variadic-macros\n+LINKFLAGS=-lm\n+\n+RUNNER_CFLAGS=$(CFLAGS) -D_GNU_SOURCE # Need _GNU_SOURCE for strdup?\n+RUNNER_LINKFLAGS=$(LINKFLAGS)\n+RUNNER_LIBS=-lws2_32\n+RUNNER_SRC=test/runner-win.c\n+\n+uv.a: uv-win.o uv-common.o\n+\t$(AR) rcs uv.a uv-win.o uv-common.o\n+\n+uv-win.o: uv-win.c uv.h uv-win.h\n+\t$(CC) $(CFLAGS) -c uv-win.c -o uv-win.o\n+\n+uv-common.o: uv-common.c uv.h uv-win.h\n+\t$(CC) $(CFLAGS) -c uv-common.c -o uv-common.o\n+\n+distclean-platform:\n+clean-platform:"}, {"sha": "3f9bc2f8d0ef10182442d41395e2586c61824ab6", "filename": "src/rt/libuv/config-unix.mk", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fconfig-unix.mk", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fconfig-unix.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-unix.mk?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,57 @@\n+# Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+#\n+# Permission is hereby granted, free of charge, to any person obtaining a copy\n+# of this software and associated documentation files (the \"Software\"), to\n+# deal in the Software without restriction, including without limitation the\n+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+# sell copies of the Software, and to permit persons to whom the Software is\n+# furnished to do so, subject to the following conditions:\n+#\n+# The above copyright notice and this permission notice shall be included in\n+# all copies or substantial portions of the Software.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+# IN THE SOFTWARE.\n+\n+CC = $(PREFIX)gcc\n+AR = $(PREFIX)ar\n+E=\n+CFLAGS=--std=gnu89 -Wno-variadic-macros -g\n+LINKFLAGS=-lm\n+\n+ifeq (SunOS,$(uname_S))\n+LINKFLAGS+=-lsocket -lnsl\n+endif\n+\n+# Need _GNU_SOURCE for strdup?\n+RUNNER_CFLAGS=$(CFLAGS) -D_GNU_SOURCE\n+\n+RUNNER_LINKFLAGS=$(LINKFLAGS) -pthread\n+RUNNER_LIBS=\n+RUNNER_SRC=test/runner-unix.c\n+\n+uv.a: uv-unix.o uv-common.o ev/ev.o\n+\t$(AR) rcs uv.a uv-unix.o uv-common.o ev/ev.o\n+\n+uv-unix.o: uv-unix.c uv.h uv-unix.h\n+\t$(CC) $(CFLAGS) -c uv-unix.c -o uv-unix.o\n+\n+uv-common.o: uv-common.c uv.h uv-unix.h\n+\t$(CC) $(CFLAGS) -c uv-common.c -o uv-common.o\n+\n+ev/ev.o: ev/config.h ev/ev.c\n+\t$(MAKE) -C ev\n+\n+ev/config.h:\n+\tcd ev && ./configure\n+\n+clean-platform:\n+\t$(MAKE) -C ev clean\n+\n+distclean-platform:\n+\t$(MAKE) -C ev distclean"}, {"sha": "9faa57591e943b2b9e58371f6147af5a0986a0f9", "filename": "src/rt/libuv/desired-api.md", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fdesired-api.md", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fdesired-api.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fdesired-api.md?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,159 @@\n+Warning: this is not actual API but desired API.\n+\n+# `uv_handle_t`\n+\n+This is the abstract base class of all types of handles. All handles have in\n+common:\n+\n+* When handles are initialized, the reference count to the event loop is\n+  increased by one.\n+\n+* The user owns the `uv_handle_t` memory and is in charge of freeing it.\n+\n+* In order to free resources associated with a handle, one must `uv_close()`\n+  and wait for the `uv_close_cb` callback. After the close callback has been\n+  made, the user is allowed to the `uv_handle_t` object.\n+\n+* The `uv_close_cb` is always made directly off the event loop. That is, it\n+  is not called from `uv_close()`.\n+\n+\n+\n+# `uv_tcp_server_t`\n+\n+A TCP server class that is a subclass of `uv_handle_t`. This can be bound to\n+an address and begin accepting new TCP sockets.\n+\n+    int uv_bind4(uv_tcp_server_t* tcp_server, struct sockaddr_in* address);\n+    int uv_bind6(uv_tcp_server_t* tcp_server, struct sockaddr_in6* address);\n+\n+Binds the TCP server to an address. The `address` can be created with\n+`uv_ip4_addr()`. Call this before `uv_listen()`\n+\n+Returns zero on success, -1 on failure. Errors in order of least-seriousness:\n+\n+* `UV_EADDRINUSE` There is already another socket bound to the specified\n+  address.\n+\n+* `UV_EADDRNOTAVAIL` The `address` parameter is an IP address that is not \n+\n+* `UV_EINVAL` The server is already bound to an address.\n+\n+* `UV_EFAULT` Memory of `address` parameter is unintelligible.\n+\n+\n+    int uv_listen(uv_tcp_server_t*, int backlog, uv_connection_cb cb);\n+\n+Begins listening for connections. The accept callback is level-triggered.\n+\n+\n+    int uv_accept(uv_tcp_server_t* server,\n+                  uv_tcp_t* client);\n+\n+Accepts a connection. This should be called after the accept callback is\n+made. The `client` parameter should be uninitialized memory; `uv_accept` is\n+used instead of `uv_tcp_init` for server-side `uv_tcp_t` initialization.\n+\n+Return value 0 indicates success, -1 failure. Possible errors:\n+\n+* `UV_EAGAIN` There are no connections. Wait for the `uv_connection_cb` callback\n+  to be called again.\n+\n+* `UV_EFAULT` The memory of either `server` is unintelligible.\n+\n+\n+\n+# `uv_stream_t`\n+\n+An abstract subclass of `uv_handle_t`. Streams represent something that\n+reads and/or writes data. Streams can be half or full-duplex. TCP sockets\n+are streams, files are streams with offsets.\n+\n+    int uv_read_start(uv_stream_t* stream,\n+                      uv_alloc_cb alloc_cb,\n+                      uv_read_cb read_cb);\n+\n+Starts the stream reading continuously. The `alloc_cb` is used to allow the\n+user to implement various means of supplying the stream with buffers to\n+fill. The `read_cb` returns buffers to the user filled with data.\n+\n+Sometimes the buffers returned to the user do not contain data. This does\n+not indicate EOF as in other systems. EOF is made via the `uv_eof_cb` which\n+can be set like this `uv_set_eof_cb(stream, eof_cb);`\n+\n+\n+    int uv_read_stop(uv_stream_t* stream);\n+\n+Stops reading from the stream.\n+\n+    int uv_write_req_init(uv_write_req_t*,\n+                          uv_stream_t*,\n+                          uv_buf_t bufs[],\n+                          int butcnf);\n+\n+Initiates a write request on a stream.\n+\n+    int uv_shutdown_req_init(uv_shutdown_req_t*, uv_stream_t*)\n+\n+Initiates a shutdown of outgoing data once the write queue drains.\n+\n+\n+\n+# `uv_tcp_t`\n+\n+The TCP handle class represents one endpoint of a duplex TCP stream.\n+`uv_tcp_t` is a subclass of `uv_stream_t`. A TCP handle can represent a\n+client side connection (one that has been used with uv_connect_req_init`)\n+or a server-side connection (one that was initialized with `uv_accept`)\n+\n+    int uv_connect_req_init(uv_connect_req_t* req,\n+                            uv_tcp_t* socket,\n+                            struct sockaddr* addr);\n+\n+Initiates a request to open a connection.\n+\n+\n+\n+# `uv_req_t`\n+\n+Abstract class represents an asynchronous request. This is a subclass of `uv_handle_t`.\n+\n+\n+# `uv_connect_req_t`\n+\n+Subclass of `uv_req_t`. Represents a request for a TCP connection. Operates\n+on `uv_tcp_t` handles. Like other types of requests the `close_cb` indicates\n+completion of the request.\n+\n+    int uv_connect_req_init(uv_connect_req_t* req,\n+                            uv_tcp_t* socket,\n+                            struct sockaddr* addr);\n+\n+Initializes the connection request. Returning 0 indicates success, -1 if\n+there was an error. The following values can be retrieved from\n+`uv_last_error` in the case of an error:\n+\n+* ???\n+\n+\n+# `uv_shutdown_req_t`\n+\n+Subclass of `uv_req_t`. Represents an ongoing shutdown request. Once the\n+write queue of the parent `uv_stream_t` is drained, the outbound data\n+channel is shutdown. Once a shutdown request is initiated on a stream, the\n+stream will allow no more writes.\n+\n+    int uv_shutdown_req_init(uv_shutdown_req_t*,\n+                             uv_stream_t* parent);\n+\n+Initializes the shutdown request.\n+\n+\n+# `uv_write_req_t`\n+\n+    int uv_write_req_init(uv_write_req_t*,\n+                          uv_stream_t*,\n+                          uv_buf_t bufs[],\n+                          int butcnf);\n+\n+Initiates a write request on a stream."}, {"sha": "d6fca2f67cde91d0c45c9d2e4fbf450d7fb95c6c", "filename": "src/rt/libuv/ev/Changes", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2FChanges?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,388 @@\n+Revision history for libev, a high-performance and full-featured event loop.\n+\n+4.04 Wed Feb 16 09:01:51 CET 2011\n+\t- fix two problems in the native win32 backend, where reuse of fd's\n+          with different underlying handles caused handles not to be removed\n+          or added to the select set (analyzed and tested by Bert Belder).\n+\t- do no rely on ceil() in ev_e?poll.c.\n+        - backport libev to HP-UX versions before 11 v3.\n+        - configure did not detect nanosleep and clock_gettime properly when\n+          they are available in the libc (as opposed to -lrt).\n+\n+4.03 Tue Jan 11 14:37:25 CET 2011\n+\t- officially support polling files with all backends.\n+\t- support files, /dev/zero etc. the same way as select in the epoll\n+          backend, by generating events on our own.\n+        - ports backend: work around solaris bug 6874410 and many related ones\n+          (EINTR, maybe more), with no performance loss (note that the solaris\n+          bug report is actually wrong, reality is far more bizarre and broken\n+          than that).\n+\t- define EV_READ/EV_WRITE as macros in event.h, as some programs use\n+          #ifdef to test for them.\n+        - new (experimental) function: ev_feed_signal.\n+        - new (to become default) EVFLAG_NOSIGMASK flag.\n+        - new EVBACKEND_MASK symbol.\n+        - updated COMMON IDIOMS SECTION.\n+\n+4.01 Fri Nov  5 21:51:29 CET 2010\n+        - automake fucked it up, apparently, --add-missing -f is not quite enough\n+          to make it update its files, so 4.00 didn't install ev++.h and\n+          event.h on make install. grrr.\n+        - ev_loop(count|depth) didn't return anything (Robin Haberkorn).\n+        - change EV_UNDEF to 0xffffffff to silence some overzealous compilers.\n+        - use \"(libev) \" prefix for all libev error messages now.\n+\n+4.00 Mon Oct 25 12:32:12 CEST 2010\n+\t- \"PORTING FROM LIBEV 3.X TO 4.X\" (in ev.pod) is recommended reading.\n+\t- ev_embed_stop did not correctly stop the watcher (very good\n+          testcase by Vladimir Timofeev).\n+        - ev_run will now always update the current loop time - it erroneously\n+          didn't when idle watchers were active, causing timers not to fire.\n+        - fix a bug where a timeout of zero caused the timer not to fire\n+          in the libevent emulation (testcase by P\u00e9ter Szab\u00f3).\n+\t- applied win32 fixes by Michael Lenaghan (also James Mansion).\n+\t- replace EV_MINIMAL by EV_FEATURES.\n+        - prefer EPOLL_CTL_ADD over EPOLL_CTL_MOD in some more cases, as it\n+          seems the former is *much* faster than the latter.\n+        - linux kernel version detection (for inotify bug workarounds)\n+          did not work properly.\n+        - reduce the number of spurious wake-ups with the ports backend.\n+        - remove dependency on sys/queue.h on freebsd (patch by Vanilla Hsu).\n+        - do async init within ev_async_start, not ev_async_set, which avoids\n+          an API quirk where the set function must be called in the C++ API\n+          even when there is nothing to set.\n+        - add (undocumented) EV_ENABLE when adding events with kqueue,\n+          this might help with OS X, which seems to need it despite documenting\n+          not to need it (helpfully pointed out by Tilghman Lesher).\n+        - do not use poll by default on freebsd, it's broken (what isn't\n+          on freebsd...).\n+        - allow to embed epoll on kernels >= 2.6.32.\n+        - configure now prepends -O3, not appends it, so one can still\n+          override it.\n+        - ev.pod: greatly expanded the portability section, added a porting\n+          section, a description of watcher states and made lots of minor fixes.\n+        - disable poll backend on AIX, the poll header spams the namespace\n+          and it's not worth working around dead platforms (reported\n+          and analyzed by Aivars Kalvans).\n+        - improve header file compatibility of the standalone eventfd code\n+          in an obscure case.\n+        - implement EV_AVOID_STDIO option.\n+        - do not use sscanf to parse linux version number (smaller, faster,\n+          no sscanf dependency).\n+        - new EV_CHILD_ENABLE and EV_SIGNAL_ENABLE configurable settings.\n+        - update libev.m4 HAVE_CLOCK_SYSCALL test for newer glibcs.\n+        - add section on accept() problems to the manpage.\n+        - rename EV_TIMEOUT to EV_TIMER.\n+        - rename ev_loop_count/depth/verify/loop/unloop.\n+        - remove ev_default_destroy and ev_default_fork.\n+        - switch to two-digit minor version.\n+        - work around an apparent gentoo compiler bug.\n+        - define _DARWIN_UNLIMITED_SELECT. just so.\n+        - use enum instead of #define for most constants.\n+        - improve compatibility to older C++ compilers.\n+        - (experimental) ev_run/ev_default_loop/ev_break/ev_loop_new have now\n+          default arguments when compiled as C++.\n+        - enable automake dependency tracking.\n+        - ev_loop_new no longer leaks memory when loop creation failed.\n+        - new ev_cleanup watcher type.\n+\n+3.9  Thu Dec 31 07:59:59 CET 2009\n+\t- signalfd is no longer used by default and has to be requested\n+          explicitly - this means that easy to catch bugs become hard to\n+          catch race conditions, but the users have spoken.\n+        - point out the unspecified signal mask in the documentation, and\n+          that this is a race condition regardless of EV_SIGNALFD.\n+\t- backport inotify code to C89.\n+        - inotify file descriptors could leak into child processes.\n+        - ev_stat watchers could keep an errornous extra ref on the loop,\n+          preventing exit when unregistering all watchers (testcases\n+          provided by ry@tinyclouds.org).\n+        - implement EV_WIN32_HANDLE_TO_FD and EV_WIN32_CLOSE_FD configuration\n+          symbols to make it easier for apps to do their own fd management.\n+        - support EV_IDLE_ENABLE being disabled in ev++.h\n+          (patch by Didier Spezia).\n+        - take advantage of inotify_init1, if available, to set cloexec/nonblock\n+          on fd creation, to avoid races.\n+        - the signal handling pipe wasn't always initialised under windows\n+          (analysed by lekma).\n+        - changed minimum glibc requirement from glibc 2.9 to 2.7, for\n+          signalfd.\n+        - add missing string.h include (Denis F. Latypoff).\n+        - only replace ev_stat.prev when we detect an actual difference,\n+          so prev is (almost) always different to attr. this might\n+          have caused the problems with 04_stat.t.\n+        - add ev::timer->remaining () method to C++ API.\n+\n+3.8  Sun Aug  9 14:30:45 CEST 2009\n+\t- incompatible change: do not necessarily reset signal handler\n+          to SIG_DFL when a sighandler is stopped.\n+        - ev_default_destroy did not properly free or zero some members,\n+          potentially causing crashes and memory corruption on repeated\n+          ev_default_destroy/ev_default_loop calls.\n+\t- take advantage of signalfd on GNU/Linux systems.\n+\t- document that the signal mask might be in an unspecified\n+          state when using libev's signal handling.\n+        - take advantage of some GNU/Linux calls to set cloexec/nonblock\n+          on fd creation, to avoid race conditions.\n+\n+3.7  Fri Jul 17 16:36:32 CEST 2009\n+\t- ev_unloop and ev_loop wrongly used a global variable to exit loops,\n+          instead of using a per-loop variable (bug caught by accident...).\n+\t- the ev_set_io_collect_interval interpretation has changed.\n+        - add new functionality: ev_set_userdata, ev_userdata,\n+          ev_set_invoke_pending_cb, ev_set_loop_release_cb,\n+          ev_invoke_pending, ev_pending_count, together with a long example\n+          about thread locking.\n+        - add ev_timer_remaining (as requested by Denis F. Latypoff).\n+        - add ev_loop_depth.\n+        - calling ev_unloop in fork/prepare watchers will no longer poll\n+          for new events.\n+\t- Denis F. Latypoff corrected many typos in example code snippets.\n+        - honor autoconf detection of EV_USE_CLOCK_SYSCALL, also double-\n+          check that the syscall number is available before trying to\n+          use it (reported by ry@tinyclouds).\n+        - use GetSystemTimeAsFileTime instead of _timeb on windows, for\n+          slightly higher accuracy.\n+        - properly declare ev_loop_verify and ev_now_update even when\n+          !EV_MULTIPLICITY.\n+        - do not compile in any priority code when EV_MAXPRI == EV_MINPRI.\n+        - support EV_MINIMAL==2 for a reduced API.\n+        - actually 0-initialise struct sigaction when installing signals.\n+        - add section on hibernate and stopped processes to ev_timer docs.\n+\n+3.6  Tue Apr 28 02:49:30 CEST 2009\n+\t- multiple timers becoming ready within an event loop iteration\n+          will be invoked in the \"correct\" order now.\n+\t- do not leave the event loop early just because we have no active\n+          watchers, fixing a problem when embedding a kqueue loop\n+          that has active kernel events but no registered watchers\n+          (reported by blacksand blacksand).\n+\t- correctly zero the idx values for arrays, so destroying and\n+          reinitialising the default loop actually works (patch by\n+          Malek Hadj-Ali).\n+        - implement ev_suspend and ev_resume.\n+        - new EV_CUSTOM revents flag for use by applications.\n+        - add documentation section about priorites.\n+        - add a glossary to the dcoumentation.\n+        - extend the ev_fork description slightly.\n+        - optimize a jump out of call_pending.\n+\n+3.53 Sun Feb 15 02:38:20 CET 2009\n+\t- fix a bug in event pipe creation on win32 that would cause a\n+          failed assertion on event loop creation (patch by Malek Hadj-Ali).\n+\t- probe for CLOCK_REALTIME support at runtime as well and fall\n+          back to gettimeofday if there is an error, to support older\n+          operating systems with newer header files/libraries.\n+        - prefer gettimeofday over clock_gettime with USE_CLOCK_SYSCALL\n+          (default most everywhere), otherwise not.\n+\n+3.52 Wed Jan  7 21:43:02 CET 2009\n+\t- fix compilation of select backend in fd_set mode when NFDBITS is\n+          missing (to get it to compile on QNX, reported by Rodrigo Campos).\n+        - better select-nfds handling when select backend is in fd_set mode.\n+        - diagnose fd_set overruns when select backend is in fd_set mode.\n+        - due to a thinko, instead of disabling everything but\n+          select on the borked OS X platform, everything but select was\n+          allowed (reported by Emanuele Giaquinta).\n+        - actually verify that local and remote port are matching in\n+          libev's socketpair emulation, which makes denial-of-service\n+          attacks harder (but not impossible - it's windows). Make sure\n+          it even works under vista, which thinks that getpeer/sockname\n+          should return fantasy port numbers.\n+        - include \"libev\" in all assertion messages for potentially\n+          clearer diagnostics.\n+        - event_get_version (libevent compatibility) returned\n+          a useless string instead of the expected version string\n+          (patch by W.C.A. Wijngaards).\n+\n+3.51 Wed Dec 24 23:00:11 CET 2008\n+        - fix a bug where an inotify watcher was added twice, causing\n+          freezes on hash collisions (reported and analysed by Graham Leggett).\n+\t- new config symbol, EV_USE_CLOCK_SYSCALL, to make libev use\n+          a direct syscall - slower, but no dependency on librt et al.\n+        - assume negative return values != -1 signals success of port_getn\n+          (http://cvs.epicsol.org/cgi/viewcvs.cgi/epic5/source/newio.c?rev=1.52)\n+          (no known failure reports, but it doesn't hurt).\n+        - fork detection in ev_embed now stops and restarts the watcher\n+          automatically.\n+        - EXPERIMENTAL: default the method to operator () in ev++.h,\n+          to make it nicer to use functors (requested by Benedek L\u00e1szl\u00f3).\n+        - fixed const object callbacks in ev++.h.\n+        - replaced loop_ref argument of watcher.set (loop) by a direct\n+          ev_loop * in ev++.h, to avoid clashes with functor patch.\n+        - do not try to watch the empty string via inotify.\n+        - inotify watchers could be leaked under certain circumstances.\n+        - OS X 10.5 is actually even more broken than earlier versions,\n+          so fall back to select on that piece of garbage.\n+        - fixed some weirdness in the ev_embed documentation.\n+\n+3.49 Wed Nov 19 11:26:53 CET 2008\n+\t- ev_stat watchers will now use inotify as a mere hint on\n+          kernels <2.6.25, or if the filesystem is not in the\n+          \"known to be good\" list.\n+        - better mingw32 compatibility (it's not as borked as native win32)\n+          (analysed by Roger Pack).\n+        - include stdio.h in the example program, as too many people are\n+          confused by the weird C language otherwise. I guess the next thing\n+          I get told is that the \"...\" ellipses in the examples don't compile\n+          with their C compiler.\n+\n+3.48 Thu Oct 30 09:02:37 CET 2008\n+\t- further optimise away the EPOLL_CTL_ADD/MOD combo in the epoll\n+          backend by assuming the kernel event mask hasn't changed if\n+          ADD fails with EEXIST.\n+        - work around spurious event notification bugs in epoll by using\n+          a 32-bit generation counter. recreate kernel state if we receive\n+          spurious notifications or unwanted events. this is very costly,\n+          but I didn't come up with this horrible design.\n+        - use memset to initialise most arrays now and do away with the\n+          init functions.\n+        - expand time-out strategies into a \"Be smart about timeouts\" section.\n+        - drop the \"struct\" from all ev_watcher declarations in the\n+          documentation and did other clarifications (yeah, it was a mistake\n+          to have a struct AND a function called ev_loop).\n+\t- fix a bug where ev_default would not initialise the default\n+          loop again after it was destroyed with ev_default_destroy.\n+        - rename syserr to ev_syserr to avoid name clashes when embedding,\n+          do similar changes for event.c.\n+\n+3.45 Tue Oct 21 21:59:26 CEST 2008\n+\t- disable inotify usage on linux <2.6.25, as it is broken\n+          (reported by Yoann Vandoorselaere).\n+        - ev_stat erroneously would try to add inotify watchers\n+          even when inotify wasn't available (this should only\n+          have a performance impact).\n+\t- ev_once now passes both timeout and io to the callback if both\n+          occur concurrently, instead of giving timeouts precedence.\n+\t- disable EV_USE_INOTIFY when sys/inotify.h is too old.\n+\n+3.44 Mon Sep 29 05:18:39 CEST 2008\n+\t- embed watchers now automatically invoke ev_loop_fork on the\n+          embedded loop when the parent loop forks.\n+\t- new function: ev_now_update (loop).\n+\t- verify_watcher was not marked static.\n+        - improve the \"associating...\" manpage section.\n+        - documentation tweaks here and there.\n+\n+3.43 Sun Jul  6 05:34:41 CEST 2008\n+\t- include more include files on windows to get struct _stati64\n+          (reported by Chris Hulbert, but doesn't quite fix his issue).\n+\t- add missing #include <io.h> in ev.c on windows (reported by\n+          Matt Tolton).\n+\n+3.42 Tue Jun 17 12:12:07 CEST 2008\n+\t- work around yet another windows bug: FD_SET actually adds fd's\n+          multiple times to the fd_*SET*, despite official MSN docs claiming\n+          otherwise. Reported and well-analysed by Matt Tolton.\n+\t- define NFDBITS to 0 when EV_SELECT_IS_WINSOCKET to make it compile\n+          (reported any analysed by Chris Hulbert).\n+        - fix a bug in ev_ebadf (this function is only used to catch\n+          programming errors in the libev user). reported by Matt Tolton.\n+        - fix a bug in fd_intern on win32 (could lead to compile errors\n+          under some circumstances, but would work correctly if it compiles).\n+          reported by Matt Tolton.\n+        - (try to) work around missing lstat on windows.\n+\t- pass in the write fd set as except fd set under windows. windows\n+          is so uncontrollably lame that it requires this. this means that\n+          switching off oobinline is not supported (but tcp/ip doesn't\n+          have oob, so that would be stupid anyways.\n+        - use posix module symbol to auto-detect monotonic clock presence\n+          and some other default values.\n+\n+3.41 Fri May 23 18:42:54 CEST 2008\n+\t- work around an obscure bug in winsocket select: if you\n+          provide only empty fd sets then select returns WSAEINVAL. how sucky.\n+        - improve timer scheduling stability and reduce use of time_epsilon.\n+        - use 1-based 2-heap for EV_MINIMAL, simplifies code, reduces\n+          codesize and makes for better cache-efficiency.\n+        - use 3-based 4-heap for !EV_MINIMAL. this makes better use\n+          of cpu cache lines and gives better growth behaviour than\n+          2-based heaps.\n+        - cache timestamp within heap for !EV_MINIMAL, to avoid random\n+          memory accesses.\n+        - document/add EV_USE_4HEAP and EV_HEAP_CACHE_AT.\n+        - fix a potential aliasing issue in ev_timer_again.\n+        - add/document ev_periodic_at, retract direct access to ->at.\n+        - improve ev_stat docs.\n+        - add portability requirements section.\n+\t- fix manpage headers etc.\n+        - normalise WSA error codes to lower range on windows.\n+        - add consistency check code that can be called automatically\n+          or on demand to check for internal structures (ev_loop_verify).\n+\n+3.31 Wed Apr 16 20:45:04 CEST 2008\n+\t- added last minute fix for ev_poll.c by Brandon Black.\n+\n+3.3  Wed Apr 16 19:04:10 CEST 2008\n+        - event_base_loopexit should return 0 on success\n+          (W.C.A. Wijngaards).\n+\t- added linux eventfd support.\n+        - try to autodetect epoll and inotify support\n+          by libc header version if not using autoconf.\n+        - new symbols: EV_DEFAULT_UC and EV_DEFAULT_UC_.\n+        - declare functions defined in ev.h as inline if\n+          C99 or gcc are available.\n+        - enable inlining with gcc versions 2 and 3.\n+        - work around broken poll implementations potentially\n+          not clearing revents field in ev_poll (Brandon Black)\n+          (no such systems are known at this time).\n+        - work around a bug in realloc on openbsd and darwin,\n+          also makes the erroneous valgrind complaints\n+          go away (noted by various people).\n+        - fix ev_async_pending, add c++ wrapper for ev_async\n+          (based on patch sent by Johannes Deisenhofer).\n+        - add sensible set method to ev::embed.\n+        - made integer constants type int in ev.h.\n+\n+3.2  Wed Apr  2 17:11:19 CEST 2008\n+\t- fix a 64 bit overflow issue in the select backend,\n+          by using fd_mask instead of int for the mask.\n+        - rename internal sighandler to avoid clash with very old perls.\n+        - entering ev_loop will not clear the ONESHOT or NONBLOCKING\n+          flags of any outer loops anymore.\n+        - add ev_async_pending.\n+\n+3.1  Thu Mar 13 13:45:22 CET 2008\n+\t- implement ev_async watchers.\n+        - only initialise signal pipe on demand.\n+\t- make use of sig_atomic_t configurable.\n+        - improved documentation.\n+\n+3.0  Mon Jan 28 13:14:47 CET 2008\n+\t- API/ABI bump to version 3.0.\n+\t- ev++.h includes \"ev.h\" by default now, not <ev.h>.\n+\t- slightly improved documentation.\n+\t- speed up signal detection after a fork.\n+        - only optionally return trace status changed in ev_child\n+          watchers.\n+        - experimental (and undocumented) loop wrappers for ev++.h.\n+\n+2.01 Tue Dec 25 08:04:41 CET 2007\n+\t- separate Changes file.\n+\t- fix ev_path_set => ev_stat_set typo.\n+        - remove event_compat.h from the libev tarball.\n+        - change how include files are found.\n+        - doc updates.\n+        - update licenses, explicitly allow for GPL relicensing.\n+\n+2.0  Sat Dec 22 17:47:03 CET 2007\n+        - new ev_sleep, ev_set_(io|timeout)_collect_interval.\n+        - removed epoll from embeddable fd set.\n+        - fix embed watchers.\n+\t- renamed ev_embed.loop to other.\n+\t- added exported Symbol tables.\n+        - undefine member wrapper macros at the end of ev.c.\n+        - respect EV_H in ev++.h.\n+\n+1.86 Tue Dec 18 02:36:57 CET 2007\n+\t- fix memleak on loop destroy (not relevant for perl).\n+\n+1.85 Fri Dec 14 20:32:40 CET 2007\n+        - fix some aliasing issues w.r.t. timers and periodics\n+          (not relevant for perl).\n+\n+(for historic versions refer to EV/Changes, found in the Perl interface)\n+\n+0.1  Wed Oct 31 21:31:48 CET 2007\n+\t- original version; hacked together in <24h.\n+"}, {"sha": "7fa0e9f844f0bcc1f34a48c63b2388b02ac5d9e6", "filename": "src/rt/libuv/ev/LICENSE", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2FLICENSE?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,36 @@\n+All files in libev are Copyright (C)2007,2008,2009 Marc Alexander Lehmann.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    * Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+\n+    * Redistributions in binary form must reproduce the above\n+      copyright notice, this list of conditions and the following\n+      disclaimer in the documentation and/or other materials provided\n+      with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+Alternatively, the contents of this package may be used under the terms\n+of the GNU General Public License (\"GPL\") version 2 or any later version,\n+in which case the provisions of the GPL are applicable instead of the\n+above. If you wish to allow the use of your version of this package only\n+under the terms of the GPL and not to allow others to use your version of\n+this file under the BSD license, indicate your decision by deleting the\n+provisions above and replace them with the notice and other provisions\n+required by the GPL in this and the other files of this package. If you do\n+not delete the provisions above, a recipient may use your version of this\n+file under either the BSD or the GPL."}, {"sha": "058c2cb0c1efc542c9539bcde4499524d6eaa102", "filename": "src/rt/libuv/ev/Makefile.am", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2FMakefile.am?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,18 @@\n+AUTOMAKE_OPTIONS = foreign\n+\n+VERSION_INFO = 4:0:0\n+\n+EXTRA_DIST = LICENSE Changes libev.m4 autogen.sh \\\n+\t     ev_vars.h ev_wrap.h \\\n+\t     ev_epoll.c ev_select.c ev_poll.c ev_kqueue.c ev_port.c ev_win32.c \\\n+\t     ev.3 ev.pod\n+\n+man_MANS = ev.3\n+\n+include_HEADERS = ev.h ev++.h event.h\n+\n+lib_LTLIBRARIES = libev.la\n+\n+libev_la_SOURCES = ev.c event.c\n+libev_la_LDFLAGS = -version-info $(VERSION_INFO)\n+"}, {"sha": "9817a7ebd7f4331b09a5fff5dc5b40dd35c1d778", "filename": "src/rt/libuv/ev/Makefile.in", "status": "added", "additions": 771, "deletions": 0, "changes": 771, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2FMakefile.in?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,771 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+subdir = .\n+DIST_COMMON = README $(am__configure_deps) $(include_HEADERS) \\\n+\t$(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n+\t$(srcdir)/config.h.in $(top_srcdir)/configure config.guess \\\n+\tconfig.sub depcomp install-sh ltmain.sh missing mkinstalldirs\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/libev.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n+CONFIG_HEADER = config.h\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(libdir)\" \"$(DESTDIR)$(man3dir)\" \\\n+\t\"$(DESTDIR)$(includedir)\"\n+LTLIBRARIES = $(lib_LTLIBRARIES)\n+libev_la_LIBADD =\n+am_libev_la_OBJECTS = ev.lo event.lo\n+libev_la_OBJECTS = $(am_libev_la_OBJECTS)\n+libev_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(libev_la_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libev_la_SOURCES)\n+DIST_SOURCES = $(libev_la_SOURCES)\n+man3dir = $(mandir)/man3\n+NROFF = nroff\n+MANS = $(man_MANS)\n+HEADERS = $(include_HEADERS)\n+ETAGS = etags\n+CTAGS = ctags\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+distdir = $(PACKAGE)-$(VERSION)\n+top_distdir = $(distdir)\n+am__remove_distdir = \\\n+  { test ! -d \"$(distdir)\" \\\n+    || { find \"$(distdir)\" -type d ! -perm -200 -exec chmod u+w {} ';' \\\n+         && rm -fr \"$(distdir)\"; }; }\n+DIST_ARCHIVES = $(distdir).tar.gz\n+GZIP_ENV = --best\n+distuninstallcheck_listfiles = find . -type f -print\n+distcleancheck_listfiles = find . -type f -print\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+lt_ECHO = @lt_ECHO@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target_alias = @target_alias@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AUTOMAKE_OPTIONS = foreign\n+VERSION_INFO = 4:0:0\n+EXTRA_DIST = LICENSE Changes libev.m4 autogen.sh \\\n+\t     ev_vars.h ev_wrap.h \\\n+\t     ev_epoll.c ev_select.c ev_poll.c ev_kqueue.c ev_port.c ev_win32.c \\\n+\t     ev.3 ev.pod\n+\n+man_MANS = ev.3\n+include_HEADERS = ev.h ev++.h event.h\n+lib_LTLIBRARIES = libev.la\n+libev_la_SOURCES = ev.c event.c\n+libev_la_LDFLAGS = -version-info $(VERSION_INFO)\n+all: config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+\n+config.h: stamp-h1\n+\t@if test ! -f $@; then \\\n+\t  rm -f stamp-h1; \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n+\telse :; fi\n+\n+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n+\t@rm -f stamp-h1\n+\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n+\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n+\trm -f stamp-h1\n+\ttouch $@\n+\n+distclean-hdr:\n+\t-rm -f config.h stamp-h1\n+install-libLTLIBRARIES: $(lib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(libdir)\" || $(MKDIR_P) \"$(DESTDIR)$(libdir)\"\n+\t@list='$(lib_LTLIBRARIES)'; test -n \"$(libdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(libdir)\"; \\\n+\t}\n+\n+uninstall-libLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(lib_LTLIBRARIES)'; test -n \"$(libdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(libdir)/$$f\"; \\\n+\tdone\n+\n+clean-libLTLIBRARIES:\n+\t-test -z \"$(lib_LTLIBRARIES)\" || rm -f $(lib_LTLIBRARIES)\n+\t@list='$(lib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libev.la: $(libev_la_OBJECTS) $(libev_la_DEPENDENCIES) \n+\t$(libev_la_LINK) -rpath $(libdir) $(libev_la_OBJECTS) $(libev_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/event.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+install-man3: $(man_MANS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(man3dir)\" || $(MKDIR_P) \"$(DESTDIR)$(man3dir)\"\n+\t@list=''; test -n \"$(man3dir)\" || exit 0; \\\n+\t{ for i in $$list; do echo \"$$i\"; done; \\\n+\tl2='$(man_MANS)'; for i in $$l2; do echo \"$$i\"; done | \\\n+\t  sed -n '/\\.3[a-z]*$$/p'; \\\n+\t} | while read p; do \\\n+\t  if test -f $$p; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; echo \"$$p\"; \\\n+\tdone | \\\n+\tsed -e 'n;s,.*/,,;p;h;s,.*\\.,,;s,^[^3][0-9a-z]*$$,3,;x' \\\n+\t      -e 's,\\.[0-9a-z]*$$,,;$(transform);G;s,\\n,.,' | \\\n+\tsed 'N;N;s,\\n, ,g' | { \\\n+\tlist=; while read file base inst; do \\\n+\t  if test \"$$base\" = \"$$inst\"; then list=\"$$list $$file\"; else \\\n+\t    echo \" $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man3dir)/$$inst'\"; \\\n+\t    $(INSTALL_DATA) \"$$file\" \"$(DESTDIR)$(man3dir)/$$inst\" || exit $$?; \\\n+\t  fi; \\\n+\tdone; \\\n+\tfor i in $$list; do echo \"$$i\"; done | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  test -z \"$$files\" || { \\\n+\t    echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(man3dir)'\"; \\\n+\t    $(INSTALL_DATA) $$files \"$(DESTDIR)$(man3dir)\" || exit $$?; }; \\\n+\tdone; }\n+\n+uninstall-man3:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list=''; test -n \"$(man3dir)\" || exit 0; \\\n+\tfiles=`{ for i in $$list; do echo \"$$i\"; done; \\\n+\tl2='$(man_MANS)'; for i in $$l2; do echo \"$$i\"; done | \\\n+\t  sed -n '/\\.3[a-z]*$$/p'; \\\n+\t} | sed -e 's,.*/,,;h;s,.*\\.,,;s,^[^3][0-9a-z]*$$,3,;x' \\\n+\t      -e 's,\\.[0-9a-z]*$$,,;$(transform);G;s,\\n,.,'`; \\\n+\ttest -z \"$$files\" || { \\\n+\t  echo \" ( cd '$(DESTDIR)$(man3dir)' && rm -f\" $$files \")\"; \\\n+\t  cd \"$(DESTDIR)$(man3dir)\" && rm -f $$files; }\n+install-includeHEADERS: $(include_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(includedir)\" || $(MKDIR_P) \"$(DESTDIR)$(includedir)\"\n+\t@list='$(include_HEADERS)'; test -n \"$(includedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(includedir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(includedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-includeHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(include_HEADERS)'; test -n \"$(includedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(includedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(includedir)\" && rm -f $$files\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t@list='$(MANS)'; if test -n \"$$list\"; then \\\n+\t  list=`for p in $$list; do \\\n+\t    if test -f $$p; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t    if test -f \"$$d$$p\"; then echo \"$$d$$p\"; else :; fi; done`; \\\n+\t  if test -n \"$$list\" && \\\n+\t    grep 'ab help2man is required to generate this page' $$list >/dev/null; then \\\n+\t    echo \"error: found man pages containing the \\`missing help2man' replacement text:\" >&2; \\\n+\t    grep -l 'ab help2man is required to generate this page' $$list | sed 's/^/         /' >&2; \\\n+\t    echo \"       to fix them, install help2man, remove and regenerate the man pages;\" >&2; \\\n+\t    echo \"       typically \\`make maintainer-clean' will remove them\" >&2; \\\n+\t    exit 1; \\\n+\t  else :; fi; \\\n+\telse :; fi\n+\t$(am__remove_distdir)\n+\ttest -d \"$(distdir)\" || mkdir \"$(distdir)\"\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t-test -n \"$(am__skip_mode_fix)\" \\\n+\t|| find \"$(distdir)\" -type d ! -perm -755 \\\n+\t\t-exec chmod u+rwx,go+rx {} \\; -o \\\n+\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \\; \\\n+\t|| chmod -R a+r \"$(distdir)\"\n+dist-gzip: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+dist-bzip2: distdir\n+\ttardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2\n+\t$(am__remove_distdir)\n+\n+dist-lzma: distdir\n+\ttardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma\n+\t$(am__remove_distdir)\n+\n+dist-xz: distdir\n+\ttardir=$(distdir) && $(am__tar) | xz -c >$(distdir).tar.xz\n+\t$(am__remove_distdir)\n+\n+dist-tarZ: distdir\n+\ttardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z\n+\t$(am__remove_distdir)\n+\n+dist-shar: distdir\n+\tshar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz\n+\t$(am__remove_distdir)\n+\n+dist-zip: distdir\n+\t-rm -f $(distdir).zip\n+\tzip -rq $(distdir).zip $(distdir)\n+\t$(am__remove_distdir)\n+\n+dist dist-all: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+# This target untars the dist file and tries a VPATH configuration.  Then\n+# it guarantees that the distribution is self-contained by making another\n+# tarfile.\n+distcheck: dist\n+\tcase '$(DIST_ARCHIVES)' in \\\n+\t*.tar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\\\n+\t*.tar.bz2*) \\\n+\t  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\\\n+\t*.tar.lzma*) \\\n+\t  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\\\n+\t*.tar.xz*) \\\n+\t  xz -dc $(distdir).tar.xz | $(am__untar) ;;\\\n+\t*.tar.Z*) \\\n+\t  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\\\n+\t*.shar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\\\n+\t*.zip*) \\\n+\t  unzip $(distdir).zip ;;\\\n+\tesac\n+\tchmod -R a-w $(distdir); chmod a+w $(distdir)\n+\tmkdir $(distdir)/_build\n+\tmkdir $(distdir)/_inst\n+\tchmod a-w $(distdir)\n+\ttest -d $(distdir)/_build || exit 0; \\\n+\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n+\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n+\t  && am__cwd=`pwd` \\\n+\t  && $(am__cd) $(distdir)/_build \\\n+\t  && ../configure --srcdir=.. --prefix=\"$$dc_install_base\" \\\n+\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n+\t        distuninstallcheck \\\n+\t  && chmod -R a-w \"$$dc_install_base\" \\\n+\t  && ({ \\\n+\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n+\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n+\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n+\t  && rm -rf \"$$dc_destdir\" \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n+\t  && rm -rf $(DIST_ARCHIVES) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \\\n+\t  && cd \"$$am__cwd\" \\\n+\t  || exit 1\n+\t$(am__remove_distdir)\n+\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n+\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n+\t  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'\n+distuninstallcheck:\n+\t@$(am__cd) '$(distuninstallcheck_dir)' \\\n+\t&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \\\n+\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n+\t        if test -n \"$(DESTDIR)\"; then \\\n+\t          echo \"  (check DESTDIR support)\"; \\\n+\t        fi ; \\\n+\t        $(distuninstallcheck_listfiles) ; \\\n+\t        exit 1; } >&2\n+distcleancheck: distclean\n+\t@if test '$(srcdir)' = . ; then \\\n+\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n+\t  exit 1 ; \\\n+\tfi\n+\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n+\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n+\t       $(distcleancheck_listfiles) ; \\\n+\t       exit 1; } >&2\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES) $(MANS) $(HEADERS) config.h\n+installdirs:\n+\tfor dir in \"$(DESTDIR)$(libdir)\" \"$(DESTDIR)$(man3dir)\" \"$(DESTDIR)$(includedir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am: install-includeHEADERS install-man\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-libLTLIBRARIES\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man: install-man3\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am: uninstall-includeHEADERS uninstall-libLTLIBRARIES \\\n+\tuninstall-man\n+\n+uninstall-man: uninstall-man3\n+\n+.MAKE: all install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \\\n+\tclean-generic clean-libLTLIBRARIES clean-libtool ctags dist \\\n+\tdist-all dist-bzip2 dist-gzip dist-lzma dist-shar dist-tarZ \\\n+\tdist-xz dist-zip distcheck distclean distclean-compile \\\n+\tdistclean-generic distclean-hdr distclean-libtool \\\n+\tdistclean-tags distcleancheck distdir distuninstallcheck dvi \\\n+\tdvi-am html html-am info info-am install install-am \\\n+\tinstall-data install-data-am install-dvi install-dvi-am \\\n+\tinstall-exec install-exec-am install-html install-html-am \\\n+\tinstall-includeHEADERS install-info install-info-am \\\n+\tinstall-libLTLIBRARIES install-man install-man3 install-pdf \\\n+\tinstall-pdf-am install-ps install-ps-am install-strip \\\n+\tinstallcheck installcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags uninstall uninstall-am uninstall-includeHEADERS \\\n+\tuninstall-libLTLIBRARIES uninstall-man uninstall-man3\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "ca403c6f470494320d5de96f75f16f99946c68ac", "filename": "src/rt/libuv/ev/README", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2FREADME?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,58 @@\n+libev is a high-performance event loop/event model with lots of features.\n+(see benchmark at http://libev.schmorp.de/bench.html)\n+\n+\n+ABOUT\n+\n+   Homepage: http://software.schmorp.de/pkg/libev\n+   Mailinglist: libev@lists.schmorp.de\n+                http://lists.schmorp.de/cgi-bin/mailman/listinfo/libev\n+   Library Documentation: http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod\n+\n+   Libev is modelled (very losely) after libevent and the Event perl\n+   module, but is faster, scales better and is more correct, and also more\n+   featureful. And also smaller. Yay.\n+\n+   Some of the specialties of libev not commonly found elsewhere are:\n+   \n+   - extensive and detailed, readable documentation (not doxygen garbage).\n+   - fully supports fork, can detect fork in various ways and automatically\n+     re-arms kernel mechanisms that do not support fork.\n+   - highly optimised select, poll, epoll, kqueue and event ports backends.\n+   - filesystem object (path) watching (with optional linux inotify support).\n+   - wallclock-based times (using absolute time, cron-like).\n+   - relative timers/timeouts (handle time jumps).\n+   - fast intra-thread communication between multiple\n+     event loops (with optional fast linux eventfd backend).\n+   - extremely easy to embed.\n+   - very small codebase, no bloated library.\n+   - fully extensible by being able to plug into the event loop,\n+     integrate other event loops, integrate other event loop users.\n+   - very little memory use (small watchers, small event loop data).\n+   - optional C++ interface allowing method and function callbacks\n+     at no extra memory or runtime overhead.\n+   - optional Perl interface with similar characteristics (capable\n+     of running Glib/Gtk2 on libev, interfaces with Net::SNMP and\n+     libadns).\n+   - support for other languages (multiple C++ interfaces, D, Ruby,\n+     Python) available from third-parties.\n+\n+   Examples of programs that embed libev: the EV perl module,\n+   rxvt-unicode, gvpe (GNU Virtual Private Ethernet), the Deliantra MMORPG\n+   server (http://www.deliantra.net/), Rubinius (a next-generation Ruby\n+   VM), the Ebb web server, the Rev event toolkit.\n+\n+\n+CONTRIBUTORS\n+\n+   libev was written and designed by Marc Lehmann and Emanuele Giaquinta.\n+\n+   The following people sent in patches or made other noteworthy\n+   contributions to the design (for minor patches, see the Changes\n+   file. If I forgot to include you, please shout at me, it was an\n+   accident):\n+\n+   W.C.A. Wijngaards\n+   Christopher Layne\n+   Chris Brody\n+"}, {"sha": "18abb73686c0dfdbc293e38d58bb25852c698ee1", "filename": "src/rt/libuv/ev/aclocal.m4", "status": "added", "additions": 8957, "deletions": 0, "changes": 8957, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Faclocal.m4?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25"}, {"sha": "087d2aa4e963b767adc7a08d828852875e436686", "filename": "src/rt/libuv/ev/autogen.sh", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fautogen.sh?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,6 @@\n+#!/bin/sh\n+\n+libtoolize --force\n+automake --add-missing --force-missing\n+autoreconf\n+"}, {"sha": "f32079abda668e5fc8f8de6f226e7b26384e8a03", "filename": "src/rt/libuv/ev/config.guess", "status": "added", "additions": 1526, "deletions": 0, "changes": 1526, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfig.guess", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfig.guess", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fconfig.guess?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,1526 @@\n+#! /bin/sh\n+# Attempt to guess a canonical system name.\n+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+#   Free Software Foundation, Inc.\n+\n+timestamp='2008-01-23'\n+\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+#\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+\n+# Originally written by Per Bothner <per@bothner.com>.\n+# Please send patches to <config-patches@gnu.org>.  Submit a context\n+# diff and a properly formatted ChangeLog entry.\n+#\n+# This script attempts to guess a canonical system name similar to\n+# config.sub.  If it succeeds, it prints the system name on stdout, and\n+# exits with 0.  Otherwise, it exits with 1.\n+#\n+# The plan is that this can be called by configure scripts if you\n+# don't specify an explicit build system type.\n+\n+me=`echo \"$0\" | sed -e 's,.*/,,'`\n+\n+usage=\"\\\n+Usage: $0 [OPTION]\n+\n+Output the configuration name of the system \\`$me' is run on.\n+\n+Operation modes:\n+  -h, --help         print this help, then exit\n+  -t, --time-stamp   print date of last modification, then exit\n+  -v, --version      print version number, then exit\n+\n+Report bugs and patches to <config-patches@gnu.org>.\"\n+\n+version=\"\\\n+GNU config.guess ($timestamp)\n+\n+Originally written by Per Bothner.\n+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+\n+This is free software; see the source for copying conditions.  There is NO\n+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n+\n+help=\"\n+Try \\`$me --help' for more information.\"\n+\n+# Parse command line\n+while test $# -gt 0 ; do\n+  case $1 in\n+    --time-stamp | --time* | -t )\n+       echo \"$timestamp\" ; exit ;;\n+    --version | -v )\n+       echo \"$version\" ; exit ;;\n+    --help | --h* | -h )\n+       echo \"$usage\"; exit ;;\n+    -- )     # Stop option processing\n+       shift; break ;;\n+    - )\t# Use stdin as input.\n+       break ;;\n+    -* )\n+       echo \"$me: invalid option $1$help\" >&2\n+       exit 1 ;;\n+    * )\n+       break ;;\n+  esac\n+done\n+\n+if test $# != 0; then\n+  echo \"$me: too many arguments$help\" >&2\n+  exit 1\n+fi\n+\n+trap 'exit 1' 1 2 15\n+\n+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a\n+# compiler to aid in system detection is discouraged as it requires\n+# temporary files to be created and, as you can see below, it is a\n+# headache to deal with in a portable fashion.\n+\n+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still\n+# use `HOST_CC' if defined, but it is deprecated.\n+\n+# Portable tmp directory creation inspired by the Autoconf team.\n+\n+set_cc_for_build='\n+trap \"exitcode=\\$?; (rm -f \\$tmpfiles 2>/dev/null; rmdir \\$tmp 2>/dev/null) && exit \\$exitcode\" 0 ;\n+trap \"rm -f \\$tmpfiles 2>/dev/null; rmdir \\$tmp 2>/dev/null; exit 1\" 1 2 13 15 ;\n+: ${TMPDIR=/tmp} ;\n+ { tmp=`(umask 077 && mktemp -d \"$TMPDIR/cgXXXXXX\") 2>/dev/null` && test -n \"$tmp\" && test -d \"$tmp\" ; } ||\n+ { test -n \"$RANDOM\" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||\n+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo \"Warning: creating insecure temp directory\" >&2 ; } ||\n+ { echo \"$me: cannot create a temporary directory in $TMPDIR\" >&2 ; exit 1 ; } ;\n+dummy=$tmp/dummy ;\n+tmpfiles=\"$dummy.c $dummy.o $dummy.rel $dummy\" ;\n+case $CC_FOR_BUILD,$HOST_CC,$CC in\n+ ,,)    echo \"int x;\" > $dummy.c ;\n+\tfor c in cc gcc c89 c99 ; do\n+\t  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then\n+\t     CC_FOR_BUILD=\"$c\"; break ;\n+\t  fi ;\n+\tdone ;\n+\tif test x\"$CC_FOR_BUILD\" = x ; then\n+\t  CC_FOR_BUILD=no_compiler_found ;\n+\tfi\n+\t;;\n+ ,,*)   CC_FOR_BUILD=$CC ;;\n+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;\n+esac ; set_cc_for_build= ;'\n+\n+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.\n+# (ghazi@noc.rutgers.edu 1994-08-24)\n+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then\n+\tPATH=$PATH:/.attbin ; export PATH\n+fi\n+\n+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown\n+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown\n+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown\n+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown\n+\n+# Note: order is significant - the case branches are not exclusive.\n+\n+case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n+    *:NetBSD:*:*)\n+\t# NetBSD (nbsd) targets should (where applicable) match one or\n+\t# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,\n+\t# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently\n+\t# switched to ELF, *-*-netbsd* would select the old\n+\t# object file format.  This provides both forward\n+\t# compatibility and a consistent mechanism for selecting the\n+\t# object file format.\n+\t#\n+\t# Note: NetBSD doesn't particularly care about the vendor\n+\t# portion of the name.  We always set it to \"unknown\".\n+\tsysctl=\"sysctl -n hw.machine_arch\"\n+\tUNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \\\n+\t    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    armeb) machine=armeb-unknown ;;\n+\t    arm*) machine=arm-unknown ;;\n+\t    sh3el) machine=shl-unknown ;;\n+\t    sh3eb) machine=sh-unknown ;;\n+\t    sh5el) machine=sh5le-unknown ;;\n+\t    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;\n+\tesac\n+\t# The Operating System including object format, if it has switched\n+\t# to ELF recently, or will in the future.\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n+\t\teval $set_cc_for_build\n+\t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t\t\t| grep __ELF__ >/dev/null\n+\t\tthen\n+\t\t    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).\n+\t\t    # Return netbsd for either.  FIX?\n+\t\t    os=netbsd\n+\t\telse\n+\t\t    os=netbsdelf\n+\t\tfi\n+\t\t;;\n+\t    *)\n+\t        os=netbsd\n+\t\t;;\n+\tesac\n+\t# The OS release\n+\t# Debian GNU/NetBSD machines have a different userland, and\n+\t# thus, need a distinct triplet. However, they do not need\n+\t# kernel version information, so it can be replaced with a\n+\t# suitable tag, in the style of linux-gnu.\n+\tcase \"${UNAME_VERSION}\" in\n+\t    Debian*)\n+\t\trelease='-gnu'\n+\t\t;;\n+\t    *)\n+\t\trelease=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\\./'`\n+\t\t;;\n+\tesac\n+\t# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:\n+\t# contains redundant information, the shorter form:\n+\t# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.\n+\techo \"${machine}-${os}${release}\"\n+\texit ;;\n+    *:OpenBSD:*:*)\n+\tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n+\techo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}\n+\texit ;;\n+    *:ekkoBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}\n+\texit ;;\n+    *:SolidBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}\n+\texit ;;\n+    macppc:MirBSD:*:*)\n+\techo powerpc-unknown-mirbsd${UNAME_RELEASE}\n+\texit ;;\n+    *:MirBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}\n+\texit ;;\n+    alpha:OSF1:*:*)\n+\tcase $UNAME_RELEASE in\n+\t*4.0)\n+\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`\n+\t\t;;\n+\t*5.*)\n+\t        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`\n+\t\t;;\n+\tesac\n+\t# According to Compaq, /usr/sbin/psrinfo has been available on\n+\t# OSF/1 and Tru64 systems produced since 1995.  I hope that\n+\t# covers most systems running today.  This code pipes the CPU\n+\t# types through head -n 1, so we only detect the type of CPU 0.\n+\tALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \\(.*\\) processor.*$/\\1/p' | head -n 1`\n+\tcase \"$ALPHA_CPU_TYPE\" in\n+\t    \"EV4 (21064)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"EV4.5 (21064)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"LCA4 (21066/21068)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"EV5 (21164)\")\n+\t\tUNAME_MACHINE=\"alphaev5\" ;;\n+\t    \"EV5.6 (21164A)\")\n+\t\tUNAME_MACHINE=\"alphaev56\" ;;\n+\t    \"EV5.6 (21164PC)\")\n+\t\tUNAME_MACHINE=\"alphapca56\" ;;\n+\t    \"EV5.7 (21164PC)\")\n+\t\tUNAME_MACHINE=\"alphapca57\" ;;\n+\t    \"EV6 (21264)\")\n+\t\tUNAME_MACHINE=\"alphaev6\" ;;\n+\t    \"EV6.7 (21264A)\")\n+\t\tUNAME_MACHINE=\"alphaev67\" ;;\n+\t    \"EV6.8CB (21264C)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.8AL (21264B)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.8CX (21264D)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.9A (21264/EV69A)\")\n+\t\tUNAME_MACHINE=\"alphaev69\" ;;\n+\t    \"EV7 (21364)\")\n+\t\tUNAME_MACHINE=\"alphaev7\" ;;\n+\t    \"EV7.9 (21364A)\")\n+\t\tUNAME_MACHINE=\"alphaev79\" ;;\n+\tesac\n+\t# A Pn.n version is a patched version.\n+\t# A Vn.n version is a released version.\n+\t# A Tn.n version is a released field test version.\n+\t# A Xn.n version is an unreleased experimental baselevel.\n+\t# 1.2 uses \"1.2\" for uname -r.\n+\techo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+\texit ;;\n+    Alpha\\ *:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# Should we change UNAME_MACHINE based on the output of uname instead\n+\t# of the specific Alpha model?\n+\techo alpha-pc-interix\n+\texit ;;\n+    21064:Windows_NT:50:3)\n+\techo alpha-dec-winnt3.5\n+\texit ;;\n+    Amiga*:UNIX_System_V:4.0:*)\n+\techo m68k-unknown-sysv4\n+\texit ;;\n+    *:[Aa]miga[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-amigaos\n+\texit ;;\n+    *:[Mm]orph[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-morphos\n+\texit ;;\n+    *:OS/390:*:*)\n+\techo i370-ibm-openedition\n+\texit ;;\n+    *:z/VM:*:*)\n+\techo s390-ibm-zvmoe\n+\texit ;;\n+    *:OS400:*:*)\n+        echo powerpc-ibm-os400\n+\texit ;;\n+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)\n+\techo arm-acorn-riscix${UNAME_RELEASE}\n+\texit ;;\n+    arm:riscos:*:*|arm:RISCOS:*:*)\n+\techo arm-unknown-riscos\n+\texit ;;\n+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)\n+\techo hppa1.1-hitachi-hiuxmpp\n+\texit ;;\n+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)\n+\t# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.\n+\tif test \"`(/bin/universe) 2>/dev/null`\" = att ; then\n+\t\techo pyramid-pyramid-sysv3\n+\telse\n+\t\techo pyramid-pyramid-bsd\n+\tfi\n+\texit ;;\n+    NILE*:*:*:dcosx)\n+\techo pyramid-pyramid-svr4\n+\texit ;;\n+    DRS?6000:unix:4.0:6*)\n+\techo sparc-icl-nx6\n+\texit ;;\n+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)\n+\tcase `/usr/bin/uname -p` in\n+\t    sparc) echo sparc-icl-nx7; exit ;;\n+\tesac ;;\n+    sun4H:SunOS:5.*:*)\n+\techo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)\n+\techo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n+\techo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:6*:*)\n+\t# According to config.sub, this is the proper way to canonicalize\n+\t# SunOS6.  Hard to guess exactly what SunOS6 will be like, but\n+\t# it's likely to be more like Solaris than SunOS4.\n+\techo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:*:*)\n+\tcase \"`/usr/bin/arch -k`\" in\n+\t    Series*|S4*)\n+\t\tUNAME_RELEASE=`uname -v`\n+\t\t;;\n+\tesac\n+\t# Japanese Language versions have a version number like `4.1.3-JL'.\n+\techo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`\n+\texit ;;\n+    sun3*:SunOS:*:*)\n+\techo m68k-sun-sunos${UNAME_RELEASE}\n+\texit ;;\n+    sun*:*:4.2BSD:*)\n+\tUNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`\n+\ttest \"x${UNAME_RELEASE}\" = \"x\" && UNAME_RELEASE=3\n+\tcase \"`/bin/arch`\" in\n+\t    sun3)\n+\t\techo m68k-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\t    sun4)\n+\t\techo sparc-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\tesac\n+\texit ;;\n+    aushp:SunOS:*:*)\n+\techo sparc-auspex-sunos${UNAME_RELEASE}\n+\texit ;;\n+    # The situation for MiNT is a little confusing.  The machine name\n+    # can be virtually everything (everything which is not\n+    # \"atarist\" or \"atariste\" at least should have a processor\n+    # > m68000).  The system name ranges from \"MiNT\" over \"FreeMiNT\"\n+    # to the lowercase version \"mint\" (or \"freemint\").  Finally\n+    # the system name \"TOS\" denotes a system which is actually not\n+    # MiNT.  But MiNT is downward compatible to TOS, so this should\n+    # be no problem.\n+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)\n+        echo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+        exit ;;\n+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)\n+        echo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)\n+        echo m68k-milan-mint${UNAME_RELEASE}\n+        exit ;;\n+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)\n+        echo m68k-hades-mint${UNAME_RELEASE}\n+        exit ;;\n+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)\n+        echo m68k-unknown-mint${UNAME_RELEASE}\n+        exit ;;\n+    m68k:machten:*:*)\n+\techo m68k-apple-machten${UNAME_RELEASE}\n+\texit ;;\n+    powerpc:machten:*:*)\n+\techo powerpc-apple-machten${UNAME_RELEASE}\n+\texit ;;\n+    RISC*:Mach:*:*)\n+\techo mips-dec-mach_bsd4.3\n+\texit ;;\n+    RISC*:ULTRIX:*:*)\n+\techo mips-dec-ultrix${UNAME_RELEASE}\n+\texit ;;\n+    VAX*:ULTRIX*:*:*)\n+\techo vax-dec-ultrix${UNAME_RELEASE}\n+\texit ;;\n+    2020:CLIX:*:* | 2430:CLIX:*:*)\n+\techo clipper-intergraph-clix${UNAME_RELEASE}\n+\texit ;;\n+    mips:*:*:UMIPS | mips:*:*:RISCos)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+#ifdef __cplusplus\n+#include <stdio.h>  /* for printf() prototype */\n+\tint main (int argc, char *argv[]) {\n+#else\n+\tint main (argc, argv) int argc; char *argv[]; {\n+#endif\n+\t#if defined (host_mips) && defined (MIPSEB)\n+\t#if defined (SYSTYPE_SYSV)\n+\t  printf (\"mips-mips-riscos%ssysv\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_SVR4)\n+\t  printf (\"mips-mips-riscos%ssvr4\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)\n+\t  printf (\"mips-mips-riscos%sbsd\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#endif\n+\t  exit (-1);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD -o $dummy $dummy.c &&\n+\t  dummyarg=`echo \"${UNAME_RELEASE}\" | sed -n 's/\\([0-9]*\\).*/\\1/p'` &&\n+\t  SYSTEM_NAME=`$dummy $dummyarg` &&\n+\t    { echo \"$SYSTEM_NAME\"; exit; }\n+\techo mips-mips-riscos${UNAME_RELEASE}\n+\texit ;;\n+    Motorola:PowerMAX_OS:*:*)\n+\techo powerpc-motorola-powermax\n+\texit ;;\n+    Motorola:*:4.3:PL8-*)\n+\techo powerpc-harris-powermax\n+\texit ;;\n+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)\n+\techo powerpc-harris-powermax\n+\texit ;;\n+    Night_Hawk:Power_UNIX:*:*)\n+\techo powerpc-harris-powerunix\n+\texit ;;\n+    m88k:CX/UX:7*:*)\n+\techo m88k-harris-cxux7\n+\texit ;;\n+    m88k:*:4*:R4*)\n+\techo m88k-motorola-sysv4\n+\texit ;;\n+    m88k:*:3*:R3*)\n+\techo m88k-motorola-sysv3\n+\texit ;;\n+    AViiON:dgux:*:*)\n+        # DG/UX returns AViiON for all architectures\n+        UNAME_PROCESSOR=`/usr/bin/uname -p`\n+\tif [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]\n+\tthen\n+\t    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \\\n+\t       [ ${TARGET_BINARY_INTERFACE}x = x ]\n+\t    then\n+\t\techo m88k-dg-dgux${UNAME_RELEASE}\n+\t    else\n+\t\techo m88k-dg-dguxbcs${UNAME_RELEASE}\n+\t    fi\n+\telse\n+\t    echo i586-dg-dgux${UNAME_RELEASE}\n+\tfi\n+ \texit ;;\n+    M88*:DolphinOS:*:*)\t# DolphinOS (SVR3)\n+\techo m88k-dolphin-sysv3\n+\texit ;;\n+    M88*:*:R3*:*)\n+\t# Delta 88k system running SVR3\n+\techo m88k-motorola-sysv3\n+\texit ;;\n+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)\n+\techo m88k-tektronix-sysv3\n+\texit ;;\n+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)\n+\techo m68k-tektronix-bsd\n+\texit ;;\n+    *:IRIX*:*:*)\n+\techo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`\n+\texit ;;\n+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.\n+\techo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id\n+\texit ;;               # Note that: echo \"'`uname -s`'\" gives 'AIX '\n+    i*86:AIX:*:*)\n+\techo i386-ibm-aix\n+\texit ;;\n+    ia64:AIX:*:*)\n+\tif [ -x /usr/bin/oslevel ] ; then\n+\t\tIBM_REV=`/usr/bin/oslevel`\n+\telse\n+\t\tIBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}\n+\tfi\n+\techo ${UNAME_MACHINE}-ibm-aix${IBM_REV}\n+\texit ;;\n+    *:AIX:2:3)\n+\tif grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\teval $set_cc_for_build\n+\t\tsed 's/^\t\t//' << EOF >$dummy.c\n+\t\t#include <sys/systemcfg.h>\n+\n+\t\tmain()\n+\t\t\t{\n+\t\t\tif (!__power_pc())\n+\t\t\t\texit(1);\n+\t\t\tputs(\"powerpc-ibm-aix3.2.5\");\n+\t\t\texit(0);\n+\t\t\t}\n+EOF\n+\t\tif $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`\n+\t\tthen\n+\t\t\techo \"$SYSTEM_NAME\"\n+\t\telse\n+\t\t\techo rs6000-ibm-aix3.2.5\n+\t\tfi\n+\telif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\techo rs6000-ibm-aix3.2.4\n+\telse\n+\t\techo rs6000-ibm-aix3.2\n+\tfi\n+\texit ;;\n+    *:AIX:*:[456])\n+\tIBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`\n+\tif /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then\n+\t\tIBM_ARCH=rs6000\n+\telse\n+\t\tIBM_ARCH=powerpc\n+\tfi\n+\tif [ -x /usr/bin/oslevel ] ; then\n+\t\tIBM_REV=`/usr/bin/oslevel`\n+\telse\n+\t\tIBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}\n+\tfi\n+\techo ${IBM_ARCH}-ibm-aix${IBM_REV}\n+\texit ;;\n+    *:AIX:*:*)\n+\techo rs6000-ibm-aix\n+\texit ;;\n+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)\n+\techo romp-ibm-bsd4.4\n+\texit ;;\n+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and\n+\techo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to\n+\texit ;;                             # report: romp-ibm BSD 4.3\n+    *:BOSX:*:*)\n+\techo rs6000-bull-bosx\n+\texit ;;\n+    DPX/2?00:B.O.S.:*:*)\n+\techo m68k-bull-sysv3\n+\texit ;;\n+    9000/[34]??:4.3bsd:1.*:*)\n+\techo m68k-hp-bsd\n+\texit ;;\n+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)\n+\techo m68k-hp-bsd4.4\n+\texit ;;\n+    9000/[34678]??:HP-UX:*:*)\n+\tHPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`\n+\tcase \"${UNAME_MACHINE}\" in\n+\t    9000/31? )            HP_ARCH=m68000 ;;\n+\t    9000/[34]?? )         HP_ARCH=m68k ;;\n+\t    9000/[678][0-9][0-9])\n+\t\tif [ -x /usr/bin/getconf ]; then\n+\t\t    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`\n+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`\n+                    case \"${sc_cpu_version}\" in\n+                      523) HP_ARCH=\"hppa1.0\" ;; # CPU_PA_RISC1_0\n+                      528) HP_ARCH=\"hppa1.1\" ;; # CPU_PA_RISC1_1\n+                      532)                      # CPU_PA_RISC2_0\n+                        case \"${sc_kernel_bits}\" in\n+                          32) HP_ARCH=\"hppa2.0n\" ;;\n+                          64) HP_ARCH=\"hppa2.0w\" ;;\n+\t\t\t  '') HP_ARCH=\"hppa2.0\" ;;   # HP-UX 10.20\n+                        esac ;;\n+                    esac\n+\t\tfi\n+\t\tif [ \"${HP_ARCH}\" = \"\" ]; then\n+\t\t    eval $set_cc_for_build\n+\t\t    sed 's/^              //' << EOF >$dummy.c\n+\n+              #define _HPUX_SOURCE\n+              #include <stdlib.h>\n+              #include <unistd.h>\n+\n+              int main ()\n+              {\n+              #if defined(_SC_KERNEL_BITS)\n+                  long bits = sysconf(_SC_KERNEL_BITS);\n+              #endif\n+                  long cpu  = sysconf (_SC_CPU_VERSION);\n+\n+                  switch (cpu)\n+              \t{\n+              \tcase CPU_PA_RISC1_0: puts (\"hppa1.0\"); break;\n+              \tcase CPU_PA_RISC1_1: puts (\"hppa1.1\"); break;\n+              \tcase CPU_PA_RISC2_0:\n+              #if defined(_SC_KERNEL_BITS)\n+              \t    switch (bits)\n+              \t\t{\n+              \t\tcase 64: puts (\"hppa2.0w\"); break;\n+              \t\tcase 32: puts (\"hppa2.0n\"); break;\n+              \t\tdefault: puts (\"hppa2.0\"); break;\n+              \t\t} break;\n+              #else  /* !defined(_SC_KERNEL_BITS) */\n+              \t    puts (\"hppa2.0\"); break;\n+              #endif\n+              \tdefault: puts (\"hppa1.0\"); break;\n+              \t}\n+                  exit (0);\n+              }\n+EOF\n+\t\t    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`\n+\t\t    test -z \"$HP_ARCH\" && HP_ARCH=hppa\n+\t\tfi ;;\n+\tesac\n+\tif [ ${HP_ARCH} = \"hppa2.0w\" ]\n+\tthen\n+\t    eval $set_cc_for_build\n+\n+\t    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating\n+\t    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler\n+\t    # generating 64-bit code.  GNU and HP use different nomenclature:\n+\t    #\n+\t    # $ CC_FOR_BUILD=cc ./config.guess\n+\t    # => hppa2.0w-hp-hpux11.23\n+\t    # $ CC_FOR_BUILD=\"cc +DA2.0w\" ./config.guess\n+\t    # => hppa64-hp-hpux11.23\n+\n+\t    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |\n+\t\tgrep __LP64__ >/dev/null\n+\t    then\n+\t\tHP_ARCH=\"hppa2.0w\"\n+\t    else\n+\t\tHP_ARCH=\"hppa64\"\n+\t    fi\n+\tfi\n+\techo ${HP_ARCH}-hp-hpux${HPUX_REV}\n+\texit ;;\n+    ia64:HP-UX:*:*)\n+\tHPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`\n+\techo ia64-hp-hpux${HPUX_REV}\n+\texit ;;\n+    3050*:HI-UX:*:*)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#include <unistd.h>\n+\tint\n+\tmain ()\n+\t{\n+\t  long cpu = sysconf (_SC_CPU_VERSION);\n+\t  /* The order matters, because CPU_IS_HP_MC68K erroneously returns\n+\t     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct\n+\t     results, however.  */\n+\t  if (CPU_IS_PA_RISC (cpu))\n+\t    {\n+\t      switch (cpu)\n+\t\t{\n+\t\t  case CPU_PA_RISC1_0: puts (\"hppa1.0-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC1_1: puts (\"hppa1.1-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC2_0: puts (\"hppa2.0-hitachi-hiuxwe2\"); break;\n+\t\t  default: puts (\"hppa-hitachi-hiuxwe2\"); break;\n+\t\t}\n+\t    }\n+\t  else if (CPU_IS_HP_MC68K (cpu))\n+\t    puts (\"m68k-hitachi-hiuxwe2\");\n+\t  else puts (\"unknown-hitachi-hiuxwe2\");\n+\t  exit (0);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&\n+\t\t{ echo \"$SYSTEM_NAME\"; exit; }\n+\techo unknown-hitachi-hiuxwe2\n+\texit ;;\n+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )\n+\techo hppa1.1-hp-bsd\n+\texit ;;\n+    9000/8??:4.3bsd:*:*)\n+\techo hppa1.0-hp-bsd\n+\texit ;;\n+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)\n+\techo hppa1.0-hp-mpeix\n+\texit ;;\n+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )\n+\techo hppa1.1-hp-osf\n+\texit ;;\n+    hp8??:OSF1:*:*)\n+\techo hppa1.0-hp-osf\n+\texit ;;\n+    i*86:OSF1:*:*)\n+\tif [ -x /usr/sbin/sysversion ] ; then\n+\t    echo ${UNAME_MACHINE}-unknown-osf1mk\n+\telse\n+\t    echo ${UNAME_MACHINE}-unknown-osf1\n+\tfi\n+\texit ;;\n+    parisc*:Lites*:*:*)\n+\techo hppa1.1-hp-lites\n+\texit ;;\n+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)\n+\techo c1-convex-bsd\n+        exit ;;\n+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+        exit ;;\n+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)\n+\techo c34-convex-bsd\n+        exit ;;\n+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)\n+\techo c38-convex-bsd\n+        exit ;;\n+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)\n+\techo c4-convex-bsd\n+        exit ;;\n+    CRAY*Y-MP:*:*:*)\n+\techo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*[A-Z]90:*:*:*)\n+\techo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \\\n+\t| sed -e 's/CRAY.*\\([A-Z]90\\)/\\1/' \\\n+\t      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \\\n+\t      -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*TS:*:*:*)\n+\techo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*T3E:*:*:*)\n+\techo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*SV1:*:*:*)\n+\techo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    *:UNICOS/mp:*:*)\n+\techo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)\n+\tFUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\\///'`\n+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`\n+        echo \"${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\"\n+        exit ;;\n+    5000:UNIX_System_V:4.*:*)\n+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\\///'`\n+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`\n+        echo \"sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\"\n+\texit ;;\n+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\\ Embedded/OS:*:*)\n+\techo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    sparc*:BSD/OS:*:*)\n+\techo sparc-unknown-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    *:BSD/OS:*:*)\n+\techo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    *:FreeBSD:*:*)\n+\tcase ${UNAME_MACHINE} in\n+\t    pc98)\n+\t\techo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\t    amd64)\n+\t\techo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\t    *)\n+\t\techo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\tesac\n+\texit ;;\n+    i*:CYGWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-cygwin\n+\texit ;;\n+    *:MINGW*:*)\n+\techo ${UNAME_MACHINE}-pc-mingw32\n+\texit ;;\n+    i*:windows32*:*)\n+    \t# uname -m includes \"-pc\" on this system.\n+    \techo ${UNAME_MACHINE}-mingw32\n+\texit ;;\n+    i*:PW*:*)\n+\techo ${UNAME_MACHINE}-pc-pw32\n+\texit ;;\n+    *:Interix*:[3456]*)\n+    \tcase ${UNAME_MACHINE} in\n+\t    x86)\n+\t\techo i586-pc-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\t    EM64T | authenticamd)\n+\t\techo x86_64-unknown-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\t    IA64)\n+\t\techo ia64-unknown-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\tesac ;;\n+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)\n+\techo i${UNAME_MACHINE}-pc-mks\n+\texit ;;\n+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we\n+\t# UNAME_MACHINE based on the output of uname instead of i386?\n+\techo i586-pc-interix\n+\texit ;;\n+    i*:UWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-uwin\n+\texit ;;\n+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)\n+\techo x86_64-unknown-cygwin\n+\texit ;;\n+    p*:CYGWIN*:*)\n+\techo powerpcle-unknown-cygwin\n+\texit ;;\n+    prep*:SunOS:5.*:*)\n+\techo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    *:GNU:*:*)\n+\t# the GNU system\n+\techo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`\n+\texit ;;\n+    *:GNU/*:*:*)\n+\t# other systems with GNU libc and userland\n+\techo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu\n+\texit ;;\n+    i*86:Minix:*:*)\n+\techo ${UNAME_MACHINE}-pc-minix\n+\texit ;;\n+    arm*:Linux:*:*)\n+\teval $set_cc_for_build\n+\tif echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t    | grep -q __ARM_EABI__\n+\tthen\n+\t    echo ${UNAME_MACHINE}-unknown-linux-gnu\n+\telse\n+\t    echo ${UNAME_MACHINE}-unknown-linux-gnueabi\n+\tfi\n+\texit ;;\n+    avr32*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    cris:Linux:*:*)\n+\techo cris-axis-linux-gnu\n+\texit ;;\n+    crisv32:Linux:*:*)\n+\techo crisv32-axis-linux-gnu\n+\texit ;;\n+    frv:Linux:*:*)\n+    \techo frv-unknown-linux-gnu\n+\texit ;;\n+    ia64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    m32r*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    m68*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    mips:Linux:*:*)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#undef CPU\n+\t#undef mips\n+\t#undef mipsel\n+\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)\n+\tCPU=mipsel\n+\t#else\n+\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)\n+\tCPU=mips\n+\t#else\n+\tCPU=\n+\t#endif\n+\t#endif\n+EOF\n+\teval \"`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '\n+\t    /^CPU/{\n+\t\ts: ::g\n+\t\tp\n+\t    }'`\"\n+\ttest x\"${CPU}\" != x && { echo \"${CPU}-unknown-linux-gnu\"; exit; }\n+\t;;\n+    mips64:Linux:*:*)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#undef CPU\n+\t#undef mips64\n+\t#undef mips64el\n+\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)\n+\tCPU=mips64el\n+\t#else\n+\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)\n+\tCPU=mips64\n+\t#else\n+\tCPU=\n+\t#endif\n+\t#endif\n+EOF\n+\teval \"`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '\n+\t    /^CPU/{\n+\t\ts: ::g\n+\t\tp\n+\t    }'`\"\n+\ttest x\"${CPU}\" != x && { echo \"${CPU}-unknown-linux-gnu\"; exit; }\n+\t;;\n+    or32:Linux:*:*)\n+\techo or32-unknown-linux-gnu\n+\texit ;;\n+    ppc:Linux:*:*)\n+\techo powerpc-unknown-linux-gnu\n+\texit ;;\n+    ppc64:Linux:*:*)\n+\techo powerpc64-unknown-linux-gnu\n+\texit ;;\n+    alpha:Linux:*:*)\n+\tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' < /proc/cpuinfo` in\n+\t  EV5)   UNAME_MACHINE=alphaev5 ;;\n+\t  EV56)  UNAME_MACHINE=alphaev56 ;;\n+\t  PCA56) UNAME_MACHINE=alphapca56 ;;\n+\t  PCA57) UNAME_MACHINE=alphapca56 ;;\n+\t  EV6)   UNAME_MACHINE=alphaev6 ;;\n+\t  EV67)  UNAME_MACHINE=alphaev67 ;;\n+\t  EV68*) UNAME_MACHINE=alphaev68 ;;\n+        esac\n+\tobjdump --private-headers /bin/sh | grep ld.so.1 >/dev/null\n+\tif test \"$?\" = 0 ; then LIBC=\"libc1\" ; else LIBC=\"\" ; fi\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}\n+\texit ;;\n+    parisc:Linux:*:* | hppa:Linux:*:*)\n+\t# Look for CPU level\n+\tcase `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in\n+\t  PA7*) echo hppa1.1-unknown-linux-gnu ;;\n+\t  PA8*) echo hppa2.0-unknown-linux-gnu ;;\n+\t  *)    echo hppa-unknown-linux-gnu ;;\n+\tesac\n+\texit ;;\n+    parisc64:Linux:*:* | hppa64:Linux:*:*)\n+\techo hppa64-unknown-linux-gnu\n+\texit ;;\n+    s390:Linux:*:* | s390x:Linux:*:*)\n+\techo ${UNAME_MACHINE}-ibm-linux\n+\texit ;;\n+    sh64*:Linux:*:*)\n+    \techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    sh*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    sparc:Linux:*:* | sparc64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    vax:Linux:*:*)\n+\techo ${UNAME_MACHINE}-dec-linux-gnu\n+\texit ;;\n+    x86_64:Linux:*:*)\n+\techo x86_64-unknown-linux-gnu\n+\texit ;;\n+    xtensa*:Linux:*:*)\n+    \techo ${UNAME_MACHINE}-unknown-linux-gnu\n+\texit ;;\n+    i*86:Linux:*:*)\n+\t# The BFD linker knows what the default object file format is, so\n+\t# first see if it will tell us. cd to the root directory to prevent\n+\t# problems with other programs or directories called `ld' in the path.\n+\t# Set LC_ALL=C to ensure ld outputs messages in English.\n+\tld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \\\n+\t\t\t | sed -ne '/supported targets:/!d\n+\t\t\t\t    s/[ \t][ \t]*/ /g\n+\t\t\t\t    s/.*supported targets: *//\n+\t\t\t\t    s/ .*//\n+\t\t\t\t    p'`\n+        case \"$ld_supported_targets\" in\n+\t  elf32-i386)\n+\t\tTENTATIVE=\"${UNAME_MACHINE}-pc-linux-gnu\"\n+\t\t;;\n+\t  a.out-i386-linux)\n+\t\techo \"${UNAME_MACHINE}-pc-linux-gnuaout\"\n+\t\texit ;;\n+\t  coff-i386)\n+\t\techo \"${UNAME_MACHINE}-pc-linux-gnucoff\"\n+\t\texit ;;\n+\t  \"\")\n+\t\t# Either a pre-BFD a.out linker (linux-gnuoldld) or\n+\t\t# one that does not give us useful --help.\n+\t\techo \"${UNAME_MACHINE}-pc-linux-gnuoldld\"\n+\t\texit ;;\n+\tesac\n+\t# Determine whether the default compiler is a.out or elf\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#include <features.h>\n+\t#ifdef __ELF__\n+\t# ifdef __GLIBC__\n+\t#  if __GLIBC__ >= 2\n+\tLIBC=gnu\n+\t#  else\n+\tLIBC=gnulibc1\n+\t#  endif\n+\t# else\n+\tLIBC=gnulibc1\n+\t# endif\n+\t#else\n+\t#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)\n+\tLIBC=gnu\n+\t#else\n+\tLIBC=gnuaout\n+\t#endif\n+\t#endif\n+\t#ifdef __dietlibc__\n+\tLIBC=dietlibc\n+\t#endif\n+EOF\n+\teval \"`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '\n+\t    /^LIBC/{\n+\t\ts: ::g\n+\t\tp\n+\t    }'`\"\n+\ttest x\"${LIBC}\" != x && {\n+\t\techo \"${UNAME_MACHINE}-pc-linux-${LIBC}\"\n+\t\texit\n+\t}\n+\ttest x\"${TENTATIVE}\" != x && { echo \"${TENTATIVE}\"; exit; }\n+\t;;\n+    i*86:DYNIX/ptx:4*:*)\n+\t# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.\n+\t# earlier versions are messed up and put the nodename in both\n+\t# sysname and nodename.\n+\techo i386-sequent-sysv4\n+\texit ;;\n+    i*86:UNIX_SV:4.2MP:2.*)\n+        # Unixware is an offshoot of SVR4, but it has its own version\n+        # number series starting with 2...\n+        # I am not positive that other SVR4 systems won't match this,\n+\t# I just have to hope.  -- rms.\n+        # Use sysv4.2uw... so that sysv4* matches it.\n+\techo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}\n+\texit ;;\n+    i*86:OS/2:*:*)\n+\t# If we were able to find `uname', then EMX Unix compatibility\n+\t# is probably installed.\n+\techo ${UNAME_MACHINE}-pc-os2-emx\n+\texit ;;\n+    i*86:XTS-300:*:STOP)\n+\techo ${UNAME_MACHINE}-unknown-stop\n+\texit ;;\n+    i*86:atheos:*:*)\n+\techo ${UNAME_MACHINE}-unknown-atheos\n+\texit ;;\n+    i*86:syllable:*:*)\n+\techo ${UNAME_MACHINE}-pc-syllable\n+\texit ;;\n+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)\n+\techo i386-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    i*86:*DOS:*:*)\n+\techo ${UNAME_MACHINE}-pc-msdosdjgpp\n+\texit ;;\n+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)\n+\tUNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\\/MP$//'`\n+\tif grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then\n+\t\techo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}\n+\tfi\n+\texit ;;\n+    i*86:*:5:[678]*)\n+    \t# UnixWare 7.x, OpenUNIX and OpenServer 6.\n+\tcase `/bin/uname -X | grep \"^Machine\"` in\n+\t    *486*)\t     UNAME_MACHINE=i486 ;;\n+\t    *Pentium)\t     UNAME_MACHINE=i586 ;;\n+\t    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;\n+\tesac\n+\techo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}\n+\texit ;;\n+    i*86:*:3.2:*)\n+\tif test -f /usr/options/cb.name; then\n+\t\tUNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`\n+\t\techo ${UNAME_MACHINE}-pc-isc$UNAME_REL\n+\telif /bin/uname -X 2>/dev/null >/dev/null ; then\n+\t\tUNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`\n+\t\t(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486\n+\t\t(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i586\n+\t\t(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\t(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\techo ${UNAME_MACHINE}-pc-sco$UNAME_REL\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv32\n+\tfi\n+\texit ;;\n+    pc:*:*:*)\n+\t# Left here for compatibility:\n+        # uname -m prints for DJGPP always 'pc', but it prints nothing about\n+        # the processor, so we play safe by assuming i386.\n+\techo i386-pc-msdosdjgpp\n+        exit ;;\n+    Intel:Mach:3*:*)\n+\techo i386-pc-mach3\n+\texit ;;\n+    paragon:*:*:*)\n+\techo i860-intel-osf1\n+\texit ;;\n+    i860:*:4.*:*) # i860-SVR4\n+\tif grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then\n+\t  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4\n+\telse # Add other i860-SVR4 vendors below as they are discovered.\n+\t  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4\n+\tfi\n+\texit ;;\n+    mini*:CTIX:SYS*5:*)\n+\t# \"miniframe\"\n+\techo m68010-convergent-sysv\n+\texit ;;\n+    mc68k:UNIX:SYSTEM5:3.51m)\n+\techo m68k-convergent-sysv\n+\texit ;;\n+    M680?0:D-NIX:5.3:*)\n+\techo m68k-diab-dnix\n+\texit ;;\n+    M68*:*:R3V[5678]*:*)\n+\ttest -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;\n+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)\n+\tOS_REL=''\n+\ttest -r /etc/.relid \\\n+\t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }\n+\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n+\t  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;\n+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)\n+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+          && { echo i486-ncr-sysv4; exit; } ;;\n+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)\n+\techo m68k-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    mc68030:UNIX_System_V:4.*:*)\n+\techo m68k-atari-sysv4\n+\texit ;;\n+    TSUNAMI:LynxOS:2.*:*)\n+\techo sparc-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    rs6000:LynxOS:2.*:*)\n+\techo rs6000-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)\n+\techo powerpc-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    SM[BE]S:UNIX_SV:*:*)\n+\techo mips-dde-sysv${UNAME_RELEASE}\n+\texit ;;\n+    RM*:ReliantUNIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit ;;\n+    RM*:SINIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit ;;\n+    *:SINIX-*:*:*)\n+\tif uname -p 2>/dev/null >/dev/null ; then\n+\t\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n+\t\techo ${UNAME_MACHINE}-sni-sysv4\n+\telse\n+\t\techo ns32k-sni-sysv\n+\tfi\n+\texit ;;\n+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort\n+                      # says <Richard.M.Bartel@ccMail.Census.GOV>\n+        echo i586-unisys-sysv4\n+        exit ;;\n+    *:UNIX_System_V:4*:FTX*)\n+\t# From Gerald Hewes <hewes@openmarket.com>.\n+\t# How about differentiating between stratus architectures? -djm\n+\techo hppa1.1-stratus-sysv4\n+\texit ;;\n+    *:*:*:FTX*)\n+\t# From seanf@swdc.stratus.com.\n+\techo i860-stratus-sysv4\n+\texit ;;\n+    i*86:VOS:*:*)\n+\t# From Paul.Green@stratus.com.\n+\techo ${UNAME_MACHINE}-stratus-vos\n+\texit ;;\n+    *:VOS:*:*)\n+\t# From Paul.Green@stratus.com.\n+\techo hppa1.1-stratus-vos\n+\texit ;;\n+    mc68*:A/UX:*:*)\n+\techo m68k-apple-aux${UNAME_RELEASE}\n+\texit ;;\n+    news*:NEWS-OS:6*:*)\n+\techo mips-sony-newsos6\n+\texit ;;\n+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)\n+\tif [ -d /usr/nec ]; then\n+\t        echo mips-nec-sysv${UNAME_RELEASE}\n+\telse\n+\t        echo mips-unknown-sysv${UNAME_RELEASE}\n+\tfi\n+        exit ;;\n+    BeBox:BeOS:*:*)\t# BeOS running on hardware made by Be, PPC only.\n+\techo powerpc-be-beos\n+\texit ;;\n+    BeMac:BeOS:*:*)\t# BeOS running on Mac or Mac clone, PPC only.\n+\techo powerpc-apple-beos\n+\texit ;;\n+    BePC:BeOS:*:*)\t# BeOS running on Intel PC compatible.\n+\techo i586-pc-beos\n+\texit ;;\n+    SX-4:SUPER-UX:*:*)\n+\techo sx4-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-5:SUPER-UX:*:*)\n+\techo sx5-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-6:SUPER-UX:*:*)\n+\techo sx6-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-7:SUPER-UX:*:*)\n+\techo sx7-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-8:SUPER-UX:*:*)\n+\techo sx8-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-8R:SUPER-UX:*:*)\n+\techo sx8r-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    Power*:Rhapsody:*:*)\n+\techo powerpc-apple-rhapsody${UNAME_RELEASE}\n+\texit ;;\n+    *:Rhapsody:*:*)\n+\techo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}\n+\texit ;;\n+    *:Darwin:*:*)\n+\tUNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown\n+\tcase $UNAME_PROCESSOR in\n+\t    unknown) UNAME_PROCESSOR=powerpc ;;\n+\tesac\n+\techo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}\n+\texit ;;\n+    *:procnto*:*:* | *:QNX:[0123456789]*:*)\n+\tUNAME_PROCESSOR=`uname -p`\n+\tif test \"$UNAME_PROCESSOR\" = \"x86\"; then\n+\t\tUNAME_PROCESSOR=i386\n+\t\tUNAME_MACHINE=pc\n+\tfi\n+\techo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}\n+\texit ;;\n+    *:QNX:*:4*)\n+\techo i386-pc-qnx\n+\texit ;;\n+    NSE-?:NONSTOP_KERNEL:*:*)\n+\techo nse-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    NSR-?:NONSTOP_KERNEL:*:*)\n+\techo nsr-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    *:NonStop-UX:*:*)\n+\techo mips-compaq-nonstopux\n+\texit ;;\n+    BS2000:POSIX*:*:*)\n+\techo bs2000-siemens-sysv\n+\texit ;;\n+    DS/*:UNIX_System_V:*:*)\n+\techo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}\n+\texit ;;\n+    *:Plan9:*:*)\n+\t# \"uname -m\" is not consistent, so use $cputype instead. 386\n+\t# is converted to i386 for consistency with other x86\n+\t# operating systems.\n+\tif test \"$cputype\" = \"386\"; then\n+\t    UNAME_MACHINE=i386\n+\telse\n+\t    UNAME_MACHINE=\"$cputype\"\n+\tfi\n+\techo ${UNAME_MACHINE}-unknown-plan9\n+\texit ;;\n+    *:TOPS-10:*:*)\n+\techo pdp10-unknown-tops10\n+\texit ;;\n+    *:TENEX:*:*)\n+\techo pdp10-unknown-tenex\n+\texit ;;\n+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)\n+\techo pdp10-dec-tops20\n+\texit ;;\n+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)\n+\techo pdp10-xkl-tops20\n+\texit ;;\n+    *:TOPS-20:*:*)\n+\techo pdp10-unknown-tops20\n+\texit ;;\n+    *:ITS:*:*)\n+\techo pdp10-unknown-its\n+\texit ;;\n+    SEI:*:*:SEIUX)\n+        echo mips-sei-seiux${UNAME_RELEASE}\n+\texit ;;\n+    *:DragonFly:*:*)\n+\techo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`\n+\texit ;;\n+    *:*VMS:*:*)\n+    \tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n+\tcase \"${UNAME_MACHINE}\" in\n+\t    A*) echo alpha-dec-vms ; exit ;;\n+\t    I*) echo ia64-dec-vms ; exit ;;\n+\t    V*) echo vax-dec-vms ; exit ;;\n+\tesac ;;\n+    *:XENIX:*:SysV)\n+\techo i386-pc-xenix\n+\texit ;;\n+    i*86:skyos:*:*)\n+\techo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'\n+\texit ;;\n+    i*86:rdos:*:*)\n+\techo ${UNAME_MACHINE}-pc-rdos\n+\texit ;;\n+esac\n+\n+#echo '(No uname command or uname output not recognized.)' 1>&2\n+#echo \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" 1>&2\n+\n+eval $set_cc_for_build\n+cat >$dummy.c <<EOF\n+#ifdef _SEQUENT_\n+# include <sys/types.h>\n+# include <sys/utsname.h>\n+#endif\n+main ()\n+{\n+#if defined (sony)\n+#if defined (MIPSEB)\n+  /* BFD wants \"bsd\" instead of \"newsos\".  Perhaps BFD should be changed,\n+     I don't know....  */\n+  printf (\"mips-sony-bsd\\n\"); exit (0);\n+#else\n+#include <sys/param.h>\n+  printf (\"m68k-sony-newsos%s\\n\",\n+#ifdef NEWSOS4\n+          \"4\"\n+#else\n+\t  \"\"\n+#endif\n+         ); exit (0);\n+#endif\n+#endif\n+\n+#if defined (__arm) && defined (__acorn) && defined (__unix)\n+  printf (\"arm-acorn-riscix\\n\"); exit (0);\n+#endif\n+\n+#if defined (hp300) && !defined (hpux)\n+  printf (\"m68k-hp-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (NeXT)\n+#if !defined (__ARCHITECTURE__)\n+#define __ARCHITECTURE__ \"m68k\"\n+#endif\n+  int version;\n+  version=`(hostinfo | sed -n 's/.*NeXT Mach \\([0-9]*\\).*/\\1/p') 2>/dev/null`;\n+  if (version < 4)\n+    printf (\"%s-next-nextstep%d\\n\", __ARCHITECTURE__, version);\n+  else\n+    printf (\"%s-next-openstep%d\\n\", __ARCHITECTURE__, version);\n+  exit (0);\n+#endif\n+\n+#if defined (MULTIMAX) || defined (n16)\n+#if defined (UMAXV)\n+  printf (\"ns32k-encore-sysv\\n\"); exit (0);\n+#else\n+#if defined (CMU)\n+  printf (\"ns32k-encore-mach\\n\"); exit (0);\n+#else\n+  printf (\"ns32k-encore-bsd\\n\"); exit (0);\n+#endif\n+#endif\n+#endif\n+\n+#if defined (__386BSD__)\n+  printf (\"i386-pc-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (sequent)\n+#if defined (i386)\n+  printf (\"i386-sequent-dynix\\n\"); exit (0);\n+#endif\n+#if defined (ns32000)\n+  printf (\"ns32k-sequent-dynix\\n\"); exit (0);\n+#endif\n+#endif\n+\n+#if defined (_SEQUENT_)\n+    struct utsname un;\n+\n+    uname(&un);\n+\n+    if (strncmp(un.version, \"V2\", 2) == 0) {\n+\tprintf (\"i386-sequent-ptx2\\n\"); exit (0);\n+    }\n+    if (strncmp(un.version, \"V1\", 2) == 0) { /* XXX is V1 correct? */\n+\tprintf (\"i386-sequent-ptx1\\n\"); exit (0);\n+    }\n+    printf (\"i386-sequent-ptx\\n\"); exit (0);\n+\n+#endif\n+\n+#if defined (vax)\n+# if !defined (ultrix)\n+#  include <sys/param.h>\n+#  if defined (BSD)\n+#   if BSD == 43\n+      printf (\"vax-dec-bsd4.3\\n\"); exit (0);\n+#   else\n+#    if BSD == 199006\n+      printf (\"vax-dec-bsd4.3reno\\n\"); exit (0);\n+#    else\n+      printf (\"vax-dec-bsd\\n\"); exit (0);\n+#    endif\n+#   endif\n+#  else\n+    printf (\"vax-dec-bsd\\n\"); exit (0);\n+#  endif\n+# else\n+    printf (\"vax-dec-ultrix\\n\"); exit (0);\n+# endif\n+#endif\n+\n+#if defined (alliant) && defined (i860)\n+  printf (\"i860-alliant-bsd\\n\"); exit (0);\n+#endif\n+\n+  exit (1);\n+}\n+EOF\n+\n+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&\n+\t{ echo \"$SYSTEM_NAME\"; exit; }\n+\n+# Apollos put the system type in the environment.\n+\n+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }\n+\n+# Convex versions that predate uname can use getsysinfo(1)\n+\n+if [ -x /usr/convex/getsysinfo ]\n+then\n+    case `getsysinfo -f cpu_type` in\n+    c1*)\n+\techo c1-convex-bsd\n+\texit ;;\n+    c2*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+\texit ;;\n+    c34*)\n+\techo c34-convex-bsd\n+\texit ;;\n+    c38*)\n+\techo c38-convex-bsd\n+\texit ;;\n+    c4*)\n+\techo c4-convex-bsd\n+\texit ;;\n+    esac\n+fi\n+\n+cat >&2 <<EOF\n+$0: unable to guess system type\n+\n+This script, last modified $timestamp, has failed to recognize\n+the operating system you are using. It is advised that you\n+download the most up to date version of the config scripts from\n+\n+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD\n+and\n+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD\n+\n+If the version you run ($0) is already up to date, please\n+send the following data and any information you think might be\n+pertinent to <config-patches@gnu.org> in order to provide the needed\n+information to handle your system.\n+\n+config.guess timestamp = $timestamp\n+\n+uname -m = `(uname -m) 2>/dev/null || echo unknown`\n+uname -r = `(uname -r) 2>/dev/null || echo unknown`\n+uname -s = `(uname -s) 2>/dev/null || echo unknown`\n+uname -v = `(uname -v) 2>/dev/null || echo unknown`\n+\n+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`\n+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`\n+\n+hostinfo               = `(hostinfo) 2>/dev/null`\n+/bin/universe          = `(/bin/universe) 2>/dev/null`\n+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`\n+/bin/arch              = `(/bin/arch) 2>/dev/null`\n+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`\n+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`\n+\n+UNAME_MACHINE = ${UNAME_MACHINE}\n+UNAME_RELEASE = ${UNAME_RELEASE}\n+UNAME_SYSTEM  = ${UNAME_SYSTEM}\n+UNAME_VERSION = ${UNAME_VERSION}\n+EOF\n+\n+exit 1\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"timestamp='\"\n+# time-stamp-format: \"%:y-%02m-%02d\"\n+# time-stamp-end: \"'\"\n+# End:"}, {"sha": "75da15cce7e7552e5770d1a1ca44f42762c9587b", "filename": "src/rt/libuv/ev/config.h.in", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fconfig.h.in?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,125 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the `clock_gettime' function. */\n+#undef HAVE_CLOCK_GETTIME\n+\n+/* \"use syscall interface for clock_gettime\" */\n+#undef HAVE_CLOCK_SYSCALL\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if you have the `epoll_ctl' function. */\n+#undef HAVE_EPOLL_CTL\n+\n+/* Define to 1 if you have the `eventfd' function. */\n+#undef HAVE_EVENTFD\n+\n+/* Define to 1 if you have the `inotify_init' function. */\n+#undef HAVE_INOTIFY_INIT\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the `kqueue' function. */\n+#undef HAVE_KQUEUE\n+\n+/* Define to 1 if you have the `m' library (-lm). */\n+#undef HAVE_LIBM\n+\n+/* Define to 1 if you have the `rt' library (-lrt). */\n+#undef HAVE_LIBRT\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the `nanosleep' function. */\n+#undef HAVE_NANOSLEEP\n+\n+/* Define to 1 if you have the `poll' function. */\n+#undef HAVE_POLL\n+\n+/* Define to 1 if you have the <poll.h> header file. */\n+#undef HAVE_POLL_H\n+\n+/* Define to 1 if you have the `port_create' function. */\n+#undef HAVE_PORT_CREATE\n+\n+/* Define to 1 if you have the <port.h> header file. */\n+#undef HAVE_PORT_H\n+\n+/* Define to 1 if you have the `select' function. */\n+#undef HAVE_SELECT\n+\n+/* Define to 1 if you have the `signalfd' function. */\n+#undef HAVE_SIGNALFD\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the <sys/epoll.h> header file. */\n+#undef HAVE_SYS_EPOLL_H\n+\n+/* Define to 1 if you have the <sys/eventfd.h> header file. */\n+#undef HAVE_SYS_EVENTFD_H\n+\n+/* Define to 1 if you have the <sys/event.h> header file. */\n+#undef HAVE_SYS_EVENT_H\n+\n+/* Define to 1 if you have the <sys/inotify.h> header file. */\n+#undef HAVE_SYS_INOTIFY_H\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#undef HAVE_SYS_SELECT_H\n+\n+/* Define to 1 if you have the <sys/signalfd.h> header file. */\n+#undef HAVE_SYS_SIGNALFD_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Version number of package */\n+#undef VERSION"}, {"sha": "6759825a5b7fcf64476b4398dc0e30b3090b925c", "filename": "src/rt/libuv/ev/config.sub", "status": "added", "additions": 1658, "deletions": 0, "changes": 1658, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fconfig.sub?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,1658 @@\n+#! /bin/sh\n+# Configuration validation subroutine script.\n+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+#   Free Software Foundation, Inc.\n+\n+timestamp='2008-01-16'\n+\n+# This file is (in principle) common to ALL GNU software.\n+# The presence of a machine in this file suggests that SOME GNU software\n+# can handle that machine.  It does not imply ALL GNU software can.\n+#\n+# This file is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+#\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+\n+# Please send patches to <config-patches@gnu.org>.  Submit a context\n+# diff and a properly formatted ChangeLog entry.\n+#\n+# Configuration subroutine to validate and canonicalize a configuration type.\n+# Supply the specified configuration type as an argument.\n+# If it is invalid, we print an error message on stderr and exit with code 1.\n+# Otherwise, we print the canonical config type on stdout and succeed.\n+\n+# This file is supposed to be the same for all GNU packages\n+# and recognize all the CPU types, system types and aliases\n+# that are meaningful with *any* GNU software.\n+# Each package is responsible for reporting which valid configurations\n+# it does not support.  The user should be able to distinguish\n+# a failure to support a valid configuration from a meaningless\n+# configuration.\n+\n+# The goal of this file is to map all the various variations of a given\n+# machine specification into a single specification in the form:\n+#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n+# or in some cases, the newer four-part form:\n+#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n+# It is wrong to echo any other type of specification.\n+\n+me=`echo \"$0\" | sed -e 's,.*/,,'`\n+\n+usage=\"\\\n+Usage: $0 [OPTION] CPU-MFR-OPSYS\n+       $0 [OPTION] ALIAS\n+\n+Canonicalize a configuration name.\n+\n+Operation modes:\n+  -h, --help         print this help, then exit\n+  -t, --time-stamp   print date of last modification, then exit\n+  -v, --version      print version number, then exit\n+\n+Report bugs and patches to <config-patches@gnu.org>.\"\n+\n+version=\"\\\n+GNU config.sub ($timestamp)\n+\n+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+\n+This is free software; see the source for copying conditions.  There is NO\n+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n+\n+help=\"\n+Try \\`$me --help' for more information.\"\n+\n+# Parse command line\n+while test $# -gt 0 ; do\n+  case $1 in\n+    --time-stamp | --time* | -t )\n+       echo \"$timestamp\" ; exit ;;\n+    --version | -v )\n+       echo \"$version\" ; exit ;;\n+    --help | --h* | -h )\n+       echo \"$usage\"; exit ;;\n+    -- )     # Stop option processing\n+       shift; break ;;\n+    - )\t# Use stdin as input.\n+       break ;;\n+    -* )\n+       echo \"$me: invalid option $1$help\"\n+       exit 1 ;;\n+\n+    *local*)\n+       # First pass through any local machine types.\n+       echo $1\n+       exit ;;\n+\n+    * )\n+       break ;;\n+  esac\n+done\n+\n+case $# in\n+ 0) echo \"$me: missing argument$help\" >&2\n+    exit 1;;\n+ 1) ;;\n+ *) echo \"$me: too many arguments$help\" >&2\n+    exit 1;;\n+esac\n+\n+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).\n+# Here we must recognize all the valid KERNEL-OS combinations.\n+maybe_os=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\2/'`\n+case $maybe_os in\n+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \\\n+  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \\\n+  storm-chaos* | os2-emx* | rtmk-nova*)\n+    os=-$maybe_os\n+    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`\n+    ;;\n+  *)\n+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`\n+    if [ $basic_machine != $1 ]\n+    then os=`echo $1 | sed 's/.*-/-/'`\n+    else os=; fi\n+    ;;\n+esac\n+\n+### Let's recognize common machines as not being operating systems so\n+### that things like config.sub decstation-3100 work.  We also\n+### recognize some manufacturers as not being operating systems, so we\n+### can provide default operating systems below.\n+case $os in\n+\t-sun*os*)\n+\t\t# Prevent following clause from handling this invalid input.\n+\t\t;;\n+\t-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \\\n+\t-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \\\n+\t-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \\\n+\t-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\\\n+\t-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \\\n+\t-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \\\n+\t-apple | -axis | -knuth | -cray)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-sim | -cisco | -oki | -wec | -winbond)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-scout)\n+\t\t;;\n+\t-wrs)\n+\t\tos=-vxworks\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-chorusos*)\n+\t\tos=-chorusos\n+\t\tbasic_machine=$1\n+\t\t;;\n+ \t-chorusrdb)\n+ \t\tos=-chorusrdb\n+\t\tbasic_machine=$1\n+ \t\t;;\n+\t-hiux*)\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\t-sco6)\n+\t\tos=-sco5v6\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco5)\n+\t\tos=-sco3.2v5\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco4)\n+\t\tos=-sco3.2v4\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2.[4-9]*)\n+\t\tos=`echo $os | sed -e 's/sco3.2./sco3.2v/'`\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2v[4-9]*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco5v6*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco*)\n+\t\tos=-sco3.2v2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-udk*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-isc)\n+\t\tos=-isc2.2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-clix*)\n+\t\tbasic_machine=clipper-intergraph\n+\t\t;;\n+\t-isc*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-lynx*)\n+\t\tos=-lynxos\n+\t\t;;\n+\t-ptx*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`\n+\t\t;;\n+\t-windowsnt*)\n+\t\tos=`echo $os | sed -e 's/windowsnt/winnt/'`\n+\t\t;;\n+\t-psos*)\n+\t\tos=-psos\n+\t\t;;\n+\t-mint | -mint[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+esac\n+\n+# Decode aliases for certain CPU-COMPANY combinations.\n+case $basic_machine in\n+\t# Recognize the basic CPU types without company name.\n+\t# Some are omitted here because they have special meanings below.\n+\t1750a | 580 \\\n+\t| a29k \\\n+\t| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \\\n+\t| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \\\n+\t| am33_2.0 \\\n+\t| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \\\n+\t| bfin \\\n+\t| c4x | clipper \\\n+\t| d10v | d30v | dlx | dsp16xx \\\n+\t| fido | fr30 | frv \\\n+\t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n+\t| i370 | i860 | i960 | ia64 \\\n+\t| ip2k | iq2000 \\\n+\t| m32c | m32r | m32rle | m68000 | m68k | m88k \\\n+\t| maxq | mb | microblaze | mcore | mep \\\n+\t| mips | mipsbe | mipseb | mipsel | mipsle \\\n+\t| mips16 \\\n+\t| mips64 | mips64el \\\n+\t| mips64vr | mips64vrel \\\n+\t| mips64orion | mips64orionel \\\n+\t| mips64vr4100 | mips64vr4100el \\\n+\t| mips64vr4300 | mips64vr4300el \\\n+\t| mips64vr5000 | mips64vr5000el \\\n+\t| mips64vr5900 | mips64vr5900el \\\n+\t| mipsisa32 | mipsisa32el \\\n+\t| mipsisa32r2 | mipsisa32r2el \\\n+\t| mipsisa64 | mipsisa64el \\\n+\t| mipsisa64r2 | mipsisa64r2el \\\n+\t| mipsisa64sb1 | mipsisa64sb1el \\\n+\t| mipsisa64sr71k | mipsisa64sr71kel \\\n+\t| mipstx39 | mipstx39el \\\n+\t| mn10200 | mn10300 \\\n+\t| mt \\\n+\t| msp430 \\\n+\t| nios | nios2 \\\n+\t| ns16k | ns32k \\\n+\t| or32 \\\n+\t| pdp10 | pdp11 | pj | pjl \\\n+\t| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \\\n+\t| pyramid \\\n+\t| score \\\n+\t| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \\\n+\t| sh64 | sh64le \\\n+\t| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \\\n+\t| sparcv8 | sparcv9 | sparcv9b | sparcv9v \\\n+\t| spu | strongarm \\\n+\t| tahoe | thumb | tic4x | tic80 | tron \\\n+\t| v850 | v850e \\\n+\t| we32k \\\n+\t| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \\\n+\t| z8k)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\tm6811 | m68hc11 | m6812 | m68hc12)\n+\t\t# Motorola 68HC11/12.\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-none\n+\t\t;;\n+\tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)\n+\t\t;;\n+\tms1)\n+\t\tbasic_machine=mt-unknown\n+\t\t;;\n+\n+\t# We use `pc' rather than `unknown'\n+\t# because (1) that's what they normally are, and\n+\t# (2) the word \"unknown\" tends to confuse beginning users.\n+\ti*86 | x86_64)\n+\t  basic_machine=$basic_machine-pc\n+\t  ;;\n+\t# Object if more than one company name word.\n+\t*-*-*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+\t# Recognize the basic CPU types with company name.\n+\t580-* \\\n+\t| a29k-* \\\n+\t| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \\\n+\t| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \\\n+\t| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \\\n+\t| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \\\n+\t| avr-* | avr32-* \\\n+\t| bfin-* | bs2000-* \\\n+\t| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \\\n+\t| clipper-* | craynv-* | cydra-* \\\n+\t| d10v-* | d30v-* | dlx-* \\\n+\t| elxsi-* \\\n+\t| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \\\n+\t| h8300-* | h8500-* \\\n+\t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n+\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| ip2k-* | iq2000-* \\\n+\t| m32c-* | m32r-* | m32rle-* \\\n+\t| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \\\n+\t| m88110-* | m88k-* | maxq-* | mcore-* \\\n+\t| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \\\n+\t| mips16-* \\\n+\t| mips64-* | mips64el-* \\\n+\t| mips64vr-* | mips64vrel-* \\\n+\t| mips64orion-* | mips64orionel-* \\\n+\t| mips64vr4100-* | mips64vr4100el-* \\\n+\t| mips64vr4300-* | mips64vr4300el-* \\\n+\t| mips64vr5000-* | mips64vr5000el-* \\\n+\t| mips64vr5900-* | mips64vr5900el-* \\\n+\t| mipsisa32-* | mipsisa32el-* \\\n+\t| mipsisa32r2-* | mipsisa32r2el-* \\\n+\t| mipsisa64-* | mipsisa64el-* \\\n+\t| mipsisa64r2-* | mipsisa64r2el-* \\\n+\t| mipsisa64sb1-* | mipsisa64sb1el-* \\\n+\t| mipsisa64sr71k-* | mipsisa64sr71kel-* \\\n+\t| mipstx39-* | mipstx39el-* \\\n+\t| mmix-* \\\n+\t| mt-* \\\n+\t| msp430-* \\\n+\t| nios-* | nios2-* \\\n+\t| none-* | np1-* | ns16k-* | ns32k-* \\\n+\t| orion-* \\\n+\t| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \\\n+\t| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \\\n+\t| pyramid-* \\\n+\t| romp-* | rs6000-* \\\n+\t| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \\\n+\t| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \\\n+\t| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \\\n+\t| sparclite-* \\\n+\t| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \\\n+\t| tahoe-* | thumb-* \\\n+\t| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \\\n+\t| tron-* \\\n+\t| v850-* | v850e-* | vax-* \\\n+\t| we32k-* \\\n+\t| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \\\n+\t| xstormy16-* | xtensa*-* \\\n+\t| ymp-* \\\n+\t| z8k-*)\n+\t\t;;\n+\t# Recognize the basic CPU types without company name, with glob match.\n+\txtensa*)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\t# Recognize the various machine names and aliases which stand\n+\t# for a CPU type and a company and sometimes even an OS.\n+\t386bsd)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-bsd\n+\t\t;;\n+\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n+\t\tbasic_machine=m68000-att\n+\t\t;;\n+\t3b*)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\ta29khif)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+    \tabacus)\n+\t\tbasic_machine=abacus-unknown\n+\t\t;;\n+\tadobe68k)\n+\t\tbasic_machine=m68010-adobe\n+\t\tos=-scout\n+\t\t;;\n+\talliant | fx80)\n+\t\tbasic_machine=fx80-alliant\n+\t\t;;\n+\taltos | altos3068)\n+\t\tbasic_machine=m68k-altos\n+\t\t;;\n+\tam29k)\n+\t\tbasic_machine=a29k-none\n+\t\tos=-bsd\n+\t\t;;\n+\tamd64)\n+\t\tbasic_machine=x86_64-pc\n+\t\t;;\n+\tamd64-*)\n+\t\tbasic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tamdahl)\n+\t\tbasic_machine=580-amdahl\n+\t\tos=-sysv\n+\t\t;;\n+\tamiga | amiga-*)\n+\t\tbasic_machine=m68k-unknown\n+\t\t;;\n+\tamigaos | amigados)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-amigaos\n+\t\t;;\n+\tamigaunix | amix)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-sysv4\n+\t\t;;\n+\tapollo68)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-sysv\n+\t\t;;\n+\tapollo68bsd)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-bsd\n+\t\t;;\n+\taux)\n+\t\tbasic_machine=m68k-apple\n+\t\tos=-aux\n+\t\t;;\n+\tbalance)\n+\t\tbasic_machine=ns32k-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tblackfin)\n+\t\tbasic_machine=bfin-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tblackfin-*)\n+\t\tbasic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tc90)\n+\t\tbasic_machine=c90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tconvex-c1)\n+\t\tbasic_machine=c1-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c2)\n+\t\tbasic_machine=c2-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c32)\n+\t\tbasic_machine=c32-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c34)\n+\t\tbasic_machine=c34-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c38)\n+\t\tbasic_machine=c38-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tcray | j90)\n+\t\tbasic_machine=j90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tcraynv)\n+\t\tbasic_machine=craynv-cray\n+\t\tos=-unicosmp\n+\t\t;;\n+\tcr16)\n+\t\tbasic_machine=cr16-unknown\n+\t\tos=-elf\n+\t\t;;\n+\tcrds | unos)\n+\t\tbasic_machine=m68k-crds\n+\t\t;;\n+\tcrisv32 | crisv32-* | etraxfs*)\n+\t\tbasic_machine=crisv32-axis\n+\t\t;;\n+\tcris | cris-* | etrax*)\n+\t\tbasic_machine=cris-axis\n+\t\t;;\n+\tcrx)\n+\t\tbasic_machine=crx-unknown\n+\t\tos=-elf\n+\t\t;;\n+\tda30 | da30-*)\n+\t\tbasic_machine=m68k-da30\n+\t\t;;\n+\tdecstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)\n+\t\tbasic_machine=mips-dec\n+\t\t;;\n+\tdecsystem10* | dec10*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops10\n+\t\t;;\n+\tdecsystem20* | dec20*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops20\n+\t\t;;\n+\tdelta | 3300 | motorola-3300 | motorola-delta \\\n+\t      | 3300-motorola | delta-motorola)\n+\t\tbasic_machine=m68k-motorola\n+\t\t;;\n+\tdelta88)\n+\t\tbasic_machine=m88k-motorola\n+\t\tos=-sysv3\n+\t\t;;\n+\tdjgpp)\n+\t\tbasic_machine=i586-pc\n+\t\tos=-msdosdjgpp\n+\t\t;;\n+\tdpx20 | dpx20-*)\n+\t\tbasic_machine=rs6000-bull\n+\t\tos=-bosx\n+\t\t;;\n+\tdpx2* | dpx2*-bull)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv3\n+\t\t;;\n+\tebmon29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-ebmon\n+\t\t;;\n+\telxsi)\n+\t\tbasic_machine=elxsi-elxsi\n+\t\tos=-bsd\n+\t\t;;\n+\tencore | umax | mmax)\n+\t\tbasic_machine=ns32k-encore\n+\t\t;;\n+\tes1800 | OSE68k | ose68k | ose | OSE)\n+\t\tbasic_machine=m68k-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tfx2800)\n+\t\tbasic_machine=i860-alliant\n+\t\t;;\n+\tgenix)\n+\t\tbasic_machine=ns32k-ns\n+\t\t;;\n+\tgmicro)\n+\t\tbasic_machine=tron-gmicro\n+\t\tos=-sysv\n+\t\t;;\n+\tgo32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-go32\n+\t\t;;\n+\th3050r* | hiux*)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\th8300hms)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\th8300xray)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-xray\n+\t\t;;\n+\th8500hms)\n+\t\tbasic_machine=h8500-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tharris)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-sysv3\n+\t\t;;\n+\thp300-*)\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp300bsd)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-bsd\n+\t\t;;\n+\thp300hpux)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-hpux\n+\t\t;;\n+\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k2[0-9][0-9] | hp9k31[0-9])\n+\t\tbasic_machine=m68000-hp\n+\t\t;;\n+\thp9k3[2-9][0-9])\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k78[0-9] | hp78[0-9])\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][13679] | hp8[0-9][13679])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thppa-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+\thppaosf)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-osf\n+\t\t;;\n+\thppro)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-proelf\n+\t\t;;\n+\ti370-ibm* | ibm*)\n+\t\tbasic_machine=i370-ibm\n+\t\t;;\n+# I'm not sure what \"Sysv32\" means.  Should this be sysv3.2?\n+\ti*86v32)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv32\n+\t\t;;\n+\ti*86v4*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv4\n+\t\t;;\n+\ti*86v)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv\n+\t\t;;\n+\ti*86sol2)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-solaris2\n+\t\t;;\n+\ti386mach)\n+\t\tbasic_machine=i386-mach\n+\t\tos=-mach\n+\t\t;;\n+\ti386-vsta | vsta)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-vsta\n+\t\t;;\n+\tiris | iris4d)\n+\t\tbasic_machine=mips-sgi\n+\t\tcase $os in\n+\t\t    -irix*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-irix4\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tisi68 | isi)\n+\t\tbasic_machine=m68k-isi\n+\t\tos=-sysv\n+\t\t;;\n+\tm68knommu)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tm68knommu-*)\n+\t\tbasic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tm88k-omron*)\n+\t\tbasic_machine=m88k-omron\n+\t\t;;\n+\tmagnum | m3230)\n+\t\tbasic_machine=mips-mips\n+\t\tos=-sysv\n+\t\t;;\n+\tmerlin)\n+\t\tbasic_machine=ns32k-utek\n+\t\tos=-sysv\n+\t\t;;\n+\tmingw32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-mingw32\n+\t\t;;\n+\tmingw32ce)\n+\t\tbasic_machine=arm-unknown\n+\t\tos=-mingw32ce\n+\t\t;;\n+\tminiframe)\n+\t\tbasic_machine=m68000-convergent\n+\t\t;;\n+\t*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+\tmips3*-*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`\n+\t\t;;\n+\tmips3*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown\n+\t\t;;\n+\tmonitor)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\tmorphos)\n+\t\tbasic_machine=powerpc-unknown\n+\t\tos=-morphos\n+\t\t;;\n+\tmsdos)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-msdos\n+\t\t;;\n+\tms1-*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`\n+\t\t;;\n+\tmvs)\n+\t\tbasic_machine=i370-ibm\n+\t\tos=-mvs\n+\t\t;;\n+\tncr3000)\n+\t\tbasic_machine=i486-ncr\n+\t\tos=-sysv4\n+\t\t;;\n+\tnetbsd386)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-netbsd\n+\t\t;;\n+\tnetwinder)\n+\t\tbasic_machine=armv4l-rebel\n+\t\tos=-linux\n+\t\t;;\n+\tnews | news700 | news800 | news900)\n+\t\tbasic_machine=m68k-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews1000)\n+\t\tbasic_machine=m68030-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews-3600 | risc-news)\n+\t\tbasic_machine=mips-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnecv70)\n+\t\tbasic_machine=v70-nec\n+\t\tos=-sysv\n+\t\t;;\n+\tnext | m*-next )\n+\t\tbasic_machine=m68k-next\n+\t\tcase $os in\n+\t\t    -nextstep* )\n+\t\t\t;;\n+\t\t    -ns2*)\n+\t\t      os=-nextstep2\n+\t\t\t;;\n+\t\t    *)\n+\t\t      os=-nextstep3\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tnh3000)\n+\t\tbasic_machine=m68k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnh[45]000)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnindy960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-nindy\n+\t\t;;\n+\tmon960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-mon960\n+\t\t;;\n+\tnonstopux)\n+\t\tbasic_machine=mips-compaq\n+\t\tos=-nonstopux\n+\t\t;;\n+\tnp1)\n+\t\tbasic_machine=np1-gould\n+\t\t;;\n+\tnsr-tandem)\n+\t\tbasic_machine=nsr-tandem\n+\t\t;;\n+\top50n-* | op60c-*)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\tos=-proelf\n+\t\t;;\n+\topenrisc | openrisc-*)\n+\t\tbasic_machine=or32-unknown\n+\t\t;;\n+\tos400)\n+\t\tbasic_machine=powerpc-ibm\n+\t\tos=-os400\n+\t\t;;\n+\tOSE68000 | ose68000)\n+\t\tbasic_machine=m68000-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tos68k)\n+\t\tbasic_machine=m68k-none\n+\t\tos=-os68k\n+\t\t;;\n+\tpa-hitachi)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\tparagon)\n+\t\tbasic_machine=i860-intel\n+\t\tos=-osf\n+\t\t;;\n+\tparisc)\n+\t\tbasic_machine=hppa-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tparisc-*)\n+\t\tbasic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tpbd)\n+\t\tbasic_machine=sparc-tti\n+\t\t;;\n+\tpbb)\n+\t\tbasic_machine=m68k-tti\n+\t\t;;\n+\tpc532 | pc532-*)\n+\t\tbasic_machine=ns32k-pc532\n+\t\t;;\n+\tpc98)\n+\t\tbasic_machine=i386-pc\n+\t\t;;\n+\tpc98-*)\n+\t\tbasic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentium | p5 | k5 | k6 | nexgen | viac3)\n+\t\tbasic_machine=i586-pc\n+\t\t;;\n+\tpentiumpro | p6 | 6x86 | athlon | athlon_*)\n+\t\tbasic_machine=i686-pc\n+\t\t;;\n+\tpentiumii | pentium2 | pentiumiii | pentium3)\n+\t\tbasic_machine=i686-pc\n+\t\t;;\n+\tpentium4)\n+\t\tbasic_machine=i786-pc\n+\t\t;;\n+\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n+\t\tbasic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumpro-* | p6-* | 6x86-* | athlon-*)\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentium4-*)\n+\t\tbasic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpn)\n+\t\tbasic_machine=pn-gould\n+\t\t;;\n+\tpower)\tbasic_machine=power-ibm\n+\t\t;;\n+\tppc)\tbasic_machine=powerpc-unknown\n+\t\t;;\n+\tppc-*)\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppcle | powerpclittle | ppc-le | powerpc-little)\n+\t\tbasic_machine=powerpcle-unknown\n+\t\t;;\n+\tppcle-* | powerpclittle-*)\n+\t\tbasic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppc64)\tbasic_machine=powerpc64-unknown\n+\t\t;;\n+\tppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppc64le | powerpc64little | ppc64-le | powerpc64-little)\n+\t\tbasic_machine=powerpc64le-unknown\n+\t\t;;\n+\tppc64le-* | powerpc64little-*)\n+\t\tbasic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tps2)\n+\t\tbasic_machine=i386-ibm\n+\t\t;;\n+\tpw32)\n+\t\tbasic_machine=i586-unknown\n+\t\tos=-pw32\n+\t\t;;\n+\trdos)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-rdos\n+\t\t;;\n+\trom68k)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\trm[46]00)\n+\t\tbasic_machine=mips-siemens\n+\t\t;;\n+\trtpc | rtpc-*)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\ts390 | s390-*)\n+\t\tbasic_machine=s390-ibm\n+\t\t;;\n+\ts390x | s390x-*)\n+\t\tbasic_machine=s390x-ibm\n+\t\t;;\n+\tsa29200)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tsb1)\n+\t\tbasic_machine=mipsisa64sb1-unknown\n+\t\t;;\n+\tsb1el)\n+\t\tbasic_machine=mipsisa64sb1el-unknown\n+\t\t;;\n+\tsde)\n+\t\tbasic_machine=mipsisa32-sde\n+\t\tos=-elf\n+\t\t;;\n+\tsei)\n+\t\tbasic_machine=mips-sei\n+\t\tos=-seiux\n+\t\t;;\n+\tsequent)\n+\t\tbasic_machine=i386-sequent\n+\t\t;;\n+\tsh)\n+\t\tbasic_machine=sh-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tsh5el)\n+\t\tbasic_machine=sh5le-unknown\n+\t\t;;\n+\tsh64)\n+\t\tbasic_machine=sh64-unknown\n+\t\t;;\n+\tsparclite-wrs | simso-wrs)\n+\t\tbasic_machine=sparclite-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tsps7)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv2\n+\t\t;;\n+\tspur)\n+\t\tbasic_machine=spur-unknown\n+\t\t;;\n+\tst2000)\n+\t\tbasic_machine=m68k-tandem\n+\t\t;;\n+\tstratus)\n+\t\tbasic_machine=i860-stratus\n+\t\tos=-sysv4\n+\t\t;;\n+\tsun2)\n+\t\tbasic_machine=m68000-sun\n+\t\t;;\n+\tsun2os3)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun2os4)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun3os3)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun3os4)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4os3)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun4os4)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4sol2)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-solaris2\n+\t\t;;\n+\tsun3 | sun3-*)\n+\t\tbasic_machine=m68k-sun\n+\t\t;;\n+\tsun4)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+\tsun386 | sun386i | roadrunner)\n+\t\tbasic_machine=i386-sun\n+\t\t;;\n+\tsv1)\n+\t\tbasic_machine=sv1-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tsymmetry)\n+\t\tbasic_machine=i386-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tt3e)\n+\t\tbasic_machine=alphaev5-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tt90)\n+\t\tbasic_machine=t90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\ttic54x | c54x*)\n+\t\tbasic_machine=tic54x-unknown\n+\t\tos=-coff\n+\t\t;;\n+\ttic55x | c55x*)\n+\t\tbasic_machine=tic55x-unknown\n+\t\tos=-coff\n+\t\t;;\n+\ttic6x | c6x*)\n+\t\tbasic_machine=tic6x-unknown\n+\t\tos=-coff\n+\t\t;;\n+\ttile*)\n+\t\tbasic_machine=tile-unknown\n+\t\tos=-linux-gnu\n+\t\t;;\n+\ttx39)\n+\t\tbasic_machine=mipstx39-unknown\n+\t\t;;\n+\ttx39el)\n+\t\tbasic_machine=mipstx39el-unknown\n+\t\t;;\n+\ttoad1)\n+\t\tbasic_machine=pdp10-xkl\n+\t\tos=-tops20\n+\t\t;;\n+\ttower | tower-32)\n+\t\tbasic_machine=m68k-ncr\n+\t\t;;\n+\ttpf)\n+\t\tbasic_machine=s390x-ibm\n+\t\tos=-tpf\n+\t\t;;\n+\tudi29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tultra3)\n+\t\tbasic_machine=a29k-nyu\n+\t\tos=-sym1\n+\t\t;;\n+\tv810 | necv810)\n+\t\tbasic_machine=v810-nec\n+\t\tos=-none\n+\t\t;;\n+\tvaxv)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-sysv\n+\t\t;;\n+\tvms)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-vms\n+\t\t;;\n+\tvpp*|vx|vx-*)\n+\t\tbasic_machine=f301-fujitsu\n+\t\t;;\n+\tvxworks960)\n+\t\tbasic_machine=i960-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks68)\n+\t\tbasic_machine=m68k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks29k)\n+\t\tbasic_machine=a29k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tw65*)\n+\t\tbasic_machine=w65-wdc\n+\t\tos=-none\n+\t\t;;\n+\tw89k-*)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\tos=-proelf\n+\t\t;;\n+\txbox)\n+\t\tbasic_machine=i686-pc\n+\t\tos=-mingw32\n+\t\t;;\n+\txps | xps100)\n+\t\tbasic_machine=xps100-honeywell\n+\t\t;;\n+\tymp)\n+\t\tbasic_machine=ymp-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tz8k-*-coff)\n+\t\tbasic_machine=z8k-unknown\n+\t\tos=-sim\n+\t\t;;\n+\tnone)\n+\t\tbasic_machine=none-none\n+\t\tos=-none\n+\t\t;;\n+\n+# Here we handle the default manufacturer of certain CPU types.  It is in\n+# some cases the only manufacturer, in others, it is the most popular.\n+\tw89k)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\t;;\n+\top50n)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\top60c)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\tromp)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\tmmix)\n+\t\tbasic_machine=mmix-knuth\n+\t\t;;\n+\trs6000)\n+\t\tbasic_machine=rs6000-ibm\n+\t\t;;\n+\tvax)\n+\t\tbasic_machine=vax-dec\n+\t\t;;\n+\tpdp10)\n+\t\t# there are many clones, so DEC is not a safe bet\n+\t\tbasic_machine=pdp10-unknown\n+\t\t;;\n+\tpdp11)\n+\t\tbasic_machine=pdp11-dec\n+\t\t;;\n+\twe32k)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\tsh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)\n+\t\tbasic_machine=sh-unknown\n+\t\t;;\n+\tsparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+\tcydra)\n+\t\tbasic_machine=cydra-cydrome\n+\t\t;;\n+\torion)\n+\t\tbasic_machine=orion-highlevel\n+\t\t;;\n+\torion105)\n+\t\tbasic_machine=clipper-highlevel\n+\t\t;;\n+\tmac | mpw | mac-mpw)\n+\t\tbasic_machine=m68k-apple\n+\t\t;;\n+\tpmac | pmac-mpw)\n+\t\tbasic_machine=powerpc-apple\n+\t\t;;\n+\t*-unknown)\n+\t\t# Make sure to match an already-canonicalized machine name.\n+\t\t;;\n+\t*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+\n+# Here we canonicalize certain aliases for manufacturers.\n+case $basic_machine in\n+\t*-digital*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`\n+\t\t;;\n+\t*-commodore*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`\n+\t\t;;\n+\t*)\n+\t\t;;\n+esac\n+\n+# Decode manufacturer-specific aliases for certain operating systems.\n+\n+if [ x\"$os\" != x\"\" ]\n+then\n+case $os in\n+        # First match some system type aliases\n+        # that might get confused with valid system types.\n+\t# -solaris* is a basic system type, with this one exception.\n+\t-solaris1 | -solaris1.*)\n+\t\tos=`echo $os | sed -e 's|solaris1|sunos4|'`\n+\t\t;;\n+\t-solaris)\n+\t\tos=-solaris2\n+\t\t;;\n+\t-svr4*)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-unixware*)\n+\t\tos=-sysv4.2uw\n+\t\t;;\n+\t-gnu/linux*)\n+\t\tos=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`\n+\t\t;;\n+\t# First accept the basic system types.\n+\t# The portable systems comes first.\n+\t# Each alternative MUST END IN A *, to match a version number.\n+\t# -sysv* is not here because it comes later, after sysvr4.\n+\t-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \\\n+\t      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\\\n+\t      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \\\n+\t      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \\\n+\t      | -aos* \\\n+\t      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \\\n+\t      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \\\n+\t      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \\\n+\t      | -openbsd* | -solidbsd* \\\n+\t      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \\\n+\t      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \\\n+\t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n+\t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n+\t      | -chorusos* | -chorusrdb* \\\n+\t      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n+\t      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \\\n+\t      | -uxpv* | -beos* | -mpeix* | -udk* \\\n+\t      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \\\n+\t      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \\\n+\t      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \\\n+\t      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \\\n+\t      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \\\n+\t      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \\\n+\t      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)\n+\t# Remember, each alternative MUST END IN *, to match a version number.\n+\t\t;;\n+\t-qnx*)\n+\t\tcase $basic_machine in\n+\t\t    x86-* | i*86-*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-nto$os\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\t-nto-qnx*)\n+\t\t;;\n+\t-nto*)\n+\t\tos=`echo $os | sed -e 's|nto|nto-qnx|'`\n+\t\t;;\n+\t-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \\\n+\t      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \\\n+\t      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)\n+\t\t;;\n+\t-mac*)\n+\t\tos=`echo $os | sed -e 's|mac|macos|'`\n+\t\t;;\n+\t-linux-dietlibc)\n+\t\tos=-linux-dietlibc\n+\t\t;;\n+\t-linux*)\n+\t\tos=`echo $os | sed -e 's|linux|linux-gnu|'`\n+\t\t;;\n+\t-sunos5*)\n+\t\tos=`echo $os | sed -e 's|sunos5|solaris2|'`\n+\t\t;;\n+\t-sunos6*)\n+\t\tos=`echo $os | sed -e 's|sunos6|solaris3|'`\n+\t\t;;\n+\t-opened*)\n+\t\tos=-openedition\n+\t\t;;\n+        -os400*)\n+\t\tos=-os400\n+\t\t;;\n+\t-wince*)\n+\t\tos=-wince\n+\t\t;;\n+\t-osfrose*)\n+\t\tos=-osfrose\n+\t\t;;\n+\t-osf*)\n+\t\tos=-osf\n+\t\t;;\n+\t-utek*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-dynix*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-acis*)\n+\t\tos=-aos\n+\t\t;;\n+\t-atheos*)\n+\t\tos=-atheos\n+\t\t;;\n+\t-syllable*)\n+\t\tos=-syllable\n+\t\t;;\n+\t-386bsd)\n+\t\tos=-bsd\n+\t\t;;\n+\t-ctix* | -uts*)\n+\t\tos=-sysv\n+\t\t;;\n+\t-nova*)\n+\t\tos=-rtmk-nova\n+\t\t;;\n+\t-ns2 )\n+\t\tos=-nextstep2\n+\t\t;;\n+\t-nsk*)\n+\t\tos=-nsk\n+\t\t;;\n+\t# Preserve the version number of sinix5.\n+\t-sinix5.*)\n+\t\tos=`echo $os | sed -e 's|sinix|sysv|'`\n+\t\t;;\n+\t-sinix*)\n+\t\tos=-sysv4\n+\t\t;;\n+        -tpf*)\n+\t\tos=-tpf\n+\t\t;;\n+\t-triton*)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-oss*)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-svr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-svr3)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-sysvr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t# This must come after -sysvr4.\n+\t-sysv*)\n+\t\t;;\n+\t-ose*)\n+\t\tos=-ose\n+\t\t;;\n+\t-es1800*)\n+\t\tos=-ose\n+\t\t;;\n+\t-xenix)\n+\t\tos=-xenix\n+\t\t;;\n+\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n+\t\tos=-mint\n+\t\t;;\n+\t-aros*)\n+\t\tos=-aros\n+\t\t;;\n+\t-kaos*)\n+\t\tos=-kaos\n+\t\t;;\n+\t-zvmoe)\n+\t\tos=-zvmoe\n+\t\t;;\n+\t-none)\n+\t\t;;\n+\t*)\n+\t\t# Get rid of the `-' at the beginning of $os.\n+\t\tos=`echo $os | sed 's/[^-]*-//'`\n+\t\techo Invalid configuration \\`$1\\': system \\`$os\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+else\n+\n+# Here we handle the default operating systems that come with various machines.\n+# The value should be what the vendor currently ships out the door with their\n+# machine or put another way, the most popular os provided with the machine.\n+\n+# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n+# \"-sun\"), then you have to tell the case statement up towards the top\n+# that MANUFACTURER isn't an operating system.  Otherwise, code above\n+# will signal an error saying that MANUFACTURER isn't an operating\n+# system, and we'll never get to this point.\n+\n+case $basic_machine in\n+        score-*)\n+\t\tos=-elf\n+\t\t;;\n+        spu-*)\n+\t\tos=-elf\n+\t\t;;\n+\t*-acorn)\n+\t\tos=-riscix1.2\n+\t\t;;\n+\tarm*-rebel)\n+\t\tos=-linux\n+\t\t;;\n+\tarm*-semi)\n+\t\tos=-aout\n+\t\t;;\n+        c4x-* | tic4x-*)\n+        \tos=-coff\n+\t\t;;\n+\t# This must come before the *-dec entry.\n+\tpdp10-*)\n+\t\tos=-tops20\n+\t\t;;\n+\tpdp11-*)\n+\t\tos=-none\n+\t\t;;\n+\t*-dec | vax-*)\n+\t\tos=-ultrix4.2\n+\t\t;;\n+\tm68*-apollo)\n+\t\tos=-domain\n+\t\t;;\n+\ti386-sun)\n+\t\tos=-sunos4.0.2\n+\t\t;;\n+\tm68000-sun)\n+\t\tos=-sunos3\n+\t\t# This also exists in the configure program, but was not the\n+\t\t# default.\n+\t\t# os=-sunos4\n+\t\t;;\n+\tm68*-cisco)\n+\t\tos=-aout\n+\t\t;;\n+        mep-*)\n+\t\tos=-elf\n+\t\t;;\n+\tmips*-cisco)\n+\t\tos=-elf\n+\t\t;;\n+\tmips*-*)\n+\t\tos=-elf\n+\t\t;;\n+\tor32-*)\n+\t\tos=-coff\n+\t\t;;\n+\t*-tti)\t# must be before sparc entry or we get the wrong os.\n+\t\tos=-sysv3\n+\t\t;;\n+\tsparc-* | *-sun)\n+\t\tos=-sunos4.1.1\n+\t\t;;\n+\t*-be)\n+\t\tos=-beos\n+\t\t;;\n+\t*-haiku)\n+\t\tos=-haiku\n+\t\t;;\n+\t*-ibm)\n+\t\tos=-aix\n+\t\t;;\n+    \t*-knuth)\n+\t\tos=-mmixware\n+\t\t;;\n+\t*-wec)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-winbond)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-oki)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-hp)\n+\t\tos=-hpux\n+\t\t;;\n+\t*-hitachi)\n+\t\tos=-hiux\n+\t\t;;\n+\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n+\t\tos=-sysv\n+\t\t;;\n+\t*-cbm)\n+\t\tos=-amigaos\n+\t\t;;\n+\t*-dg)\n+\t\tos=-dgux\n+\t\t;;\n+\t*-dolphin)\n+\t\tos=-sysv3\n+\t\t;;\n+\tm68k-ccur)\n+\t\tos=-rtu\n+\t\t;;\n+\tm88k-omron*)\n+\t\tos=-luna\n+\t\t;;\n+\t*-next )\n+\t\tos=-nextstep\n+\t\t;;\n+\t*-sequent)\n+\t\tos=-ptx\n+\t\t;;\n+\t*-crds)\n+\t\tos=-unos\n+\t\t;;\n+\t*-ns)\n+\t\tos=-genix\n+\t\t;;\n+\ti370-*)\n+\t\tos=-mvs\n+\t\t;;\n+\t*-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+\t*-gould)\n+\t\tos=-sysv\n+\t\t;;\n+\t*-highlevel)\n+\t\tos=-bsd\n+\t\t;;\n+\t*-encore)\n+\t\tos=-bsd\n+\t\t;;\n+\t*-sgi)\n+\t\tos=-irix\n+\t\t;;\n+\t*-siemens)\n+\t\tos=-sysv4\n+\t\t;;\n+\t*-masscomp)\n+\t\tos=-rtu\n+\t\t;;\n+\tf30[01]-fujitsu | f700-fujitsu)\n+\t\tos=-uxpv\n+\t\t;;\n+\t*-rom68k)\n+\t\tos=-coff\n+\t\t;;\n+\t*-*bug)\n+\t\tos=-coff\n+\t\t;;\n+\t*-apple)\n+\t\tos=-macos\n+\t\t;;\n+\t*-atari*)\n+\t\tos=-mint\n+\t\t;;\n+\t*)\n+\t\tos=-none\n+\t\t;;\n+esac\n+fi\n+\n+# Here we handle the case where we know the os, and the CPU type, but not the\n+# manufacturer.  We pick the logical manufacturer.\n+vendor=unknown\n+case $basic_machine in\n+\t*-unknown)\n+\t\tcase $os in\n+\t\t\t-riscix*)\n+\t\t\t\tvendor=acorn\n+\t\t\t\t;;\n+\t\t\t-sunos*)\n+\t\t\t\tvendor=sun\n+\t\t\t\t;;\n+\t\t\t-aix*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-beos*)\n+\t\t\t\tvendor=be\n+\t\t\t\t;;\n+\t\t\t-hpux*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-mpeix*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-hiux*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-unos*)\n+\t\t\t\tvendor=crds\n+\t\t\t\t;;\n+\t\t\t-dgux*)\n+\t\t\t\tvendor=dg\n+\t\t\t\t;;\n+\t\t\t-luna*)\n+\t\t\t\tvendor=omron\n+\t\t\t\t;;\n+\t\t\t-genix*)\n+\t\t\t\tvendor=ns\n+\t\t\t\t;;\n+\t\t\t-mvs* | -opened*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-os400*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-ptx*)\n+\t\t\t\tvendor=sequent\n+\t\t\t\t;;\n+\t\t\t-tpf*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-vxsim* | -vxworks* | -windiss*)\n+\t\t\t\tvendor=wrs\n+\t\t\t\t;;\n+\t\t\t-aux*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-hms*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-mpw* | -macos*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n+\t\t\t\tvendor=atari\n+\t\t\t\t;;\n+\t\t\t-vos*)\n+\t\t\t\tvendor=stratus\n+\t\t\t\t;;\n+\t\tesac\n+\t\tbasic_machine=`echo $basic_machine | sed \"s/unknown/$vendor/\"`\n+\t\t;;\n+esac\n+\n+echo $basic_machine$os\n+exit\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"timestamp='\"\n+# time-stamp-format: \"%:y-%02m-%02d\"\n+# time-stamp-end: \"'\"\n+# End:"}, {"sha": "98f102f1e42ed1f005a751278302ff5ea66e95d9", "filename": "src/rt/libuv/ev/configure", "status": "added", "additions": 13037, "deletions": 0, "changes": 13037, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fconfigure?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25"}, {"sha": "03a784f2eba9bcc262637747cc3984b3d4eb2c8f", "filename": "src/rt/libuv/ev/configure.ac", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fconfigure.ac?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,18 @@\n+AC_INIT\n+AC_CONFIG_SRCDIR([ev_epoll.c])\n+\n+AM_INIT_AUTOMAKE(libev,4.04) dnl also update ev.h!\n+AC_CONFIG_HEADERS([config.h])\n+AM_MAINTAINER_MODE\n+\n+AC_PROG_INSTALL\n+AC_PROG_LIBTOOL\n+\n+if test \"x$GCC\" = xyes ; then\n+  CFLAGS=\"-O3 $CFLAGS\"\n+fi\n+\n+m4_include([libev.m4])\n+\n+AC_CONFIG_FILES([Makefile])\n+AC_OUTPUT"}, {"sha": "df8eea7e4ce8862105fcd7929b20bdb45488048b", "filename": "src/rt/libuv/ev/depcomp", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fdepcomp", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fdepcomp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fdepcomp?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,630 @@\n+#! /bin/sh\n+# depcomp - compile a program generating dependencies as side-effects\n+\n+scriptversion=2009-04-28.21; # UTC\n+\n+# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007, 2009 Free\n+# Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.\n+\n+case $1 in\n+  '')\n+     echo \"$0: No command.  Try \\`$0 --help' for more information.\" 1>&2\n+     exit 1;\n+     ;;\n+  -h | --h*)\n+    cat <<\\EOF\n+Usage: depcomp [--help] [--version] PROGRAM [ARGS]\n+\n+Run PROGRAMS ARGS to compile a file, generating dependencies\n+as side-effects.\n+\n+Environment variables:\n+  depmode     Dependency tracking mode.\n+  source      Source file read by `PROGRAMS ARGS'.\n+  object      Object file output by `PROGRAMS ARGS'.\n+  DEPDIR      directory where to store dependencies.\n+  depfile     Dependency file to output.\n+  tmpdepfile  Temporary file to use when outputing dependencies.\n+  libtool     Whether libtool is used (yes/no).\n+\n+Report bugs to <bug-automake@gnu.org>.\n+EOF\n+    exit $?\n+    ;;\n+  -v | --v*)\n+    echo \"depcomp $scriptversion\"\n+    exit $?\n+    ;;\n+esac\n+\n+if test -z \"$depmode\" || test -z \"$source\" || test -z \"$object\"; then\n+  echo \"depcomp: Variables source, object and depmode must be set\" 1>&2\n+  exit 1\n+fi\n+\n+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.\n+depfile=${depfile-`echo \"$object\" |\n+  sed 's|[^\\\\/]*$|'${DEPDIR-.deps}'/&|;s|\\.\\([^.]*\\)$|.P\\1|;s|Pobj$|Po|'`}\n+tmpdepfile=${tmpdepfile-`echo \"$depfile\" | sed 's/\\.\\([^.]*\\)$/.T\\1/'`}\n+\n+rm -f \"$tmpdepfile\"\n+\n+# Some modes work just like other modes, but use different flags.  We\n+# parameterize here, but still list the modes in the big case below,\n+# to make depend.m4 easier to write.  Note that we *cannot* use a case\n+# here, because this file can only contain one case statement.\n+if test \"$depmode\" = hp; then\n+  # HP compiler uses -M and no extra arg.\n+  gccflag=-M\n+  depmode=gcc\n+fi\n+\n+if test \"$depmode\" = dashXmstdout; then\n+   # This is just like dashmstdout with a different argument.\n+   dashmflag=-xM\n+   depmode=dashmstdout\n+fi\n+\n+cygpath_u=\"cygpath -u -f -\"\n+if test \"$depmode\" = msvcmsys; then\n+   # This is just like msvisualcpp but w/o cygpath translation.\n+   # Just convert the backslash-escaped backslashes to single forward\n+   # slashes to satisfy depend.m4\n+   cygpath_u=\"sed s,\\\\\\\\\\\\\\\\,/,g\"\n+   depmode=msvisualcpp\n+fi\n+\n+case \"$depmode\" in\n+gcc3)\n+## gcc 3 implements dependency tracking that does exactly what\n+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like\n+## it if -MD -MP comes after the -MF stuff.  Hmm.\n+## Unfortunately, FreeBSD c89 acceptance of flags depends upon\n+## the command line argument order; so add the flags where they\n+## appear in depend2.am.  Note that the slowdown incurred here\n+## affects only configure: in makefiles, %FASTDEP% shortcuts this.\n+  for arg\n+  do\n+    case $arg in\n+    -c) set fnord \"$@\" -MT \"$object\" -MD -MP -MF \"$tmpdepfile\" \"$arg\" ;;\n+    *)  set fnord \"$@\" \"$arg\" ;;\n+    esac\n+    shift # fnord\n+    shift # $arg\n+  done\n+  \"$@\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  mv \"$tmpdepfile\" \"$depfile\"\n+  ;;\n+\n+gcc)\n+## There are various ways to get dependency output from gcc.  Here's\n+## why we pick this rather obscure method:\n+## - Don't want to use -MD because we'd like the dependencies to end\n+##   up in a subdir.  Having to rename by hand is ugly.\n+##   (We might end up doing this anyway to support other compilers.)\n+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like\n+##   -MM, not -M (despite what the docs say).\n+## - Using -M directly means running the compiler twice (even worse\n+##   than renaming).\n+  if test -z \"$gccflag\"; then\n+    gccflag=-MD,\n+  fi\n+  \"$@\" -Wp,\"$gccflag$tmpdepfile\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n+## The second -e expression handles DOS-style file names with drive letters.\n+  sed -e 's/^[^:]*: / /' \\\n+      -e 's/^['$alpha']:\\/[^:]*: / /' < \"$tmpdepfile\" >> \"$depfile\"\n+## This next piece of magic avoids the `deleted header file' problem.\n+## The problem is that when a header file which appears in a .P file\n+## is deleted, the dependency causes make to die (because there is\n+## typically no way to rebuild the header).  We avoid this by adding\n+## dummy dependencies for each header file.  Too bad gcc doesn't do\n+## this for us directly.\n+  tr ' ' '\n+' < \"$tmpdepfile\" |\n+## Some versions of gcc put a space before the `:'.  On the theory\n+## that the space means something, we add a space to the output as\n+## well.\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+hp)\n+  # This case exists only to let depend.m4 do its work.  It works by\n+  # looking at the text of this script.  This case will never be run,\n+  # since it is checked for above.\n+  exit 1\n+  ;;\n+\n+sgi)\n+  if test \"$libtool\" = yes; then\n+    \"$@\" \"-Wp,-MDupdate,$tmpdepfile\"\n+  else\n+    \"$@\" -MDupdate \"$tmpdepfile\"\n+  fi\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+\n+  if test -f \"$tmpdepfile\"; then  # yes, the sourcefile depend on other files\n+    echo \"$object : \\\\\" > \"$depfile\"\n+\n+    # Clip off the initial element (the dependent).  Don't try to be\n+    # clever and replace this with sed code, as IRIX sed won't handle\n+    # lines with more than a fixed number of characters (4096 in\n+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;\n+    # the IRIX cc adds comments like `#:fec' to the end of the\n+    # dependency line.\n+    tr ' ' '\n+' < \"$tmpdepfile\" \\\n+    | sed -e 's/^.*\\.o://' -e 's/#.*$//' -e '/^$/ d' | \\\n+    tr '\n+' ' ' >> \"$depfile\"\n+    echo >> \"$depfile\"\n+\n+    # The second pass generates a dummy entry for each header file.\n+    tr ' ' '\n+' < \"$tmpdepfile\" \\\n+   | sed -e 's/^.*\\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \\\n+   >> \"$depfile\"\n+  else\n+    # The sourcefile does not contain any dependencies, so just\n+    # store a dummy comment line, to avoid errors with the Makefile\n+    # \"include basename.Plo\" scheme.\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+aix)\n+  # The C for AIX Compiler uses -M and outputs the dependencies\n+  # in a .u file.  In older versions, this file always lives in the\n+  # current directory.  Also, the AIX compiler puts `$object:' at the\n+  # start of each line; $object doesn't have directory information.\n+  # Version 6 uses the directory in both cases.\n+  dir=`echo \"$object\" | sed -e 's|/[^/]*$|/|'`\n+  test \"x$dir\" = \"x$object\" && dir=\n+  base=`echo \"$object\" | sed -e 's|^.*/||' -e 's/\\.o$//' -e 's/\\.lo$//'`\n+  if test \"$libtool\" = yes; then\n+    tmpdepfile1=$dir$base.u\n+    tmpdepfile2=$base.u\n+    tmpdepfile3=$dir.libs/$base.u\n+    \"$@\" -Wc,-M\n+  else\n+    tmpdepfile1=$dir$base.u\n+    tmpdepfile2=$dir$base.u\n+    tmpdepfile3=$dir$base.u\n+    \"$@\" -M\n+  fi\n+  stat=$?\n+\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\"\n+    exit $stat\n+  fi\n+\n+  for tmpdepfile in \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\"\n+  do\n+    test -f \"$tmpdepfile\" && break\n+  done\n+  if test -f \"$tmpdepfile\"; then\n+    # Each line is of the form `foo.o: dependent.h'.\n+    # Do two passes, one to just change these to\n+    # `$object: dependent.h' and one to simply `dependent.h:'.\n+    sed -e \"s,^.*\\.[a-z]*:,$object:,\" < \"$tmpdepfile\" > \"$depfile\"\n+    # That's a tab and a space in the [].\n+    sed -e 's,^.*\\.[a-z]*:[\t ]*,,' -e 's,$,:,' < \"$tmpdepfile\" >> \"$depfile\"\n+  else\n+    # The sourcefile does not contain any dependencies, so just\n+    # store a dummy comment line, to avoid errors with the Makefile\n+    # \"include basename.Plo\" scheme.\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+icc)\n+  # Intel's C compiler understands `-MD -MF file'.  However on\n+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c\n+  # ICC 7.0 will fill foo.d with something like\n+  #    foo.o: sub/foo.c\n+  #    foo.o: sub/foo.h\n+  # which is wrong.  We want:\n+  #    sub/foo.o: sub/foo.c\n+  #    sub/foo.o: sub/foo.h\n+  #    sub/foo.c:\n+  #    sub/foo.h:\n+  # ICC 7.1 will output\n+  #    foo.o: sub/foo.c sub/foo.h\n+  # and will wrap long lines using \\ :\n+  #    foo.o: sub/foo.c ... \\\n+  #     sub/foo.h ... \\\n+  #     ...\n+\n+  \"$@\" -MD -MF \"$tmpdepfile\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+  # Each line is of the form `foo.o: dependent.h',\n+  # or `foo.o: dep1.h dep2.h \\', or ` dep3.h dep4.h \\'.\n+  # Do two passes, one to just change these to\n+  # `$object: dependent.h' and one to simply `dependent.h:'.\n+  sed \"s,^[^:]*:,$object :,\" < \"$tmpdepfile\" > \"$depfile\"\n+  # Some versions of the HPUX 10.20 sed can't process this invocation\n+  # correctly.  Breaking it into two sed invocations is a workaround.\n+  sed 's,^[^:]*: \\(.*\\)$,\\1,;s/^\\\\$//;/^$/d;/:$/d' < \"$tmpdepfile\" |\n+    sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+hp2)\n+  # The \"hp\" stanza above does not work with aCC (C++) and HP's ia64\n+  # compilers, which have integrated preprocessors.  The correct option\n+  # to use with these is +Maked; it writes dependencies to a file named\n+  # 'foo.d', which lands next to the object file, wherever that\n+  # happens to be.\n+  # Much of this is similar to the tru64 case; see comments there.\n+  dir=`echo \"$object\" | sed -e 's|/[^/]*$|/|'`\n+  test \"x$dir\" = \"x$object\" && dir=\n+  base=`echo \"$object\" | sed -e 's|^.*/||' -e 's/\\.o$//' -e 's/\\.lo$//'`\n+  if test \"$libtool\" = yes; then\n+    tmpdepfile1=$dir$base.d\n+    tmpdepfile2=$dir.libs/$base.d\n+    \"$@\" -Wc,+Maked\n+  else\n+    tmpdepfile1=$dir$base.d\n+    tmpdepfile2=$dir$base.d\n+    \"$@\" +Maked\n+  fi\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+     rm -f \"$tmpdepfile1\" \"$tmpdepfile2\"\n+     exit $stat\n+  fi\n+\n+  for tmpdepfile in \"$tmpdepfile1\" \"$tmpdepfile2\"\n+  do\n+    test -f \"$tmpdepfile\" && break\n+  done\n+  if test -f \"$tmpdepfile\"; then\n+    sed -e \"s,^.*\\.[a-z]*:,$object:,\" \"$tmpdepfile\" > \"$depfile\"\n+    # Add `dependent.h:' lines.\n+    sed -ne '2,${\n+\t       s/^ *//\n+\t       s/ \\\\*$//\n+\t       s/$/:/\n+\t       p\n+\t     }' \"$tmpdepfile\" >> \"$depfile\"\n+  else\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\" \"$tmpdepfile2\"\n+  ;;\n+\n+tru64)\n+   # The Tru64 compiler uses -MD to generate dependencies as a side\n+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.\n+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put\n+   # dependencies in `foo.d' instead, so we check for that too.\n+   # Subdirectories are respected.\n+   dir=`echo \"$object\" | sed -e 's|/[^/]*$|/|'`\n+   test \"x$dir\" = \"x$object\" && dir=\n+   base=`echo \"$object\" | sed -e 's|^.*/||' -e 's/\\.o$//' -e 's/\\.lo$//'`\n+\n+   if test \"$libtool\" = yes; then\n+      # With Tru64 cc, shared objects can also be used to make a\n+      # static library.  This mechanism is used in libtool 1.4 series to\n+      # handle both shared and static libraries in a single compilation.\n+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.\n+      #\n+      # With libtool 1.5 this exception was removed, and libtool now\n+      # generates 2 separate objects for the 2 libraries.  These two\n+      # compilations output dependencies in $dir.libs/$base.o.d and\n+      # in $dir$base.o.d.  We have to check for both files, because\n+      # one of the two compilations can be disabled.  We should prefer\n+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is\n+      # automatically cleaned when .libs/ is deleted, while ignoring\n+      # the former would cause a distcleancheck panic.\n+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4\n+      tmpdepfile2=$dir$base.o.d          # libtool 1.5\n+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5\n+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504\n+      \"$@\" -Wc,-MD\n+   else\n+      tmpdepfile1=$dir$base.o.d\n+      tmpdepfile2=$dir$base.d\n+      tmpdepfile3=$dir$base.d\n+      tmpdepfile4=$dir$base.d\n+      \"$@\" -MD\n+   fi\n+\n+   stat=$?\n+   if test $stat -eq 0; then :\n+   else\n+      rm -f \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\" \"$tmpdepfile4\"\n+      exit $stat\n+   fi\n+\n+   for tmpdepfile in \"$tmpdepfile1\" \"$tmpdepfile2\" \"$tmpdepfile3\" \"$tmpdepfile4\"\n+   do\n+     test -f \"$tmpdepfile\" && break\n+   done\n+   if test -f \"$tmpdepfile\"; then\n+      sed -e \"s,^.*\\.[a-z]*:,$object:,\" < \"$tmpdepfile\" > \"$depfile\"\n+      # That's a tab and a space in the [].\n+      sed -e 's,^.*\\.[a-z]*:[\t ]*,,' -e 's,$,:,' < \"$tmpdepfile\" >> \"$depfile\"\n+   else\n+      echo \"#dummy\" > \"$depfile\"\n+   fi\n+   rm -f \"$tmpdepfile\"\n+   ;;\n+\n+#nosideeffect)\n+  # This comment above is used by automake to tell side-effect\n+  # dependency tracking mechanisms from slower ones.\n+\n+dashmstdout)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the preprocessed file to stdout, regardless of -o.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  # Remove `-o $object'.\n+  IFS=\" \"\n+  for arg\n+  do\n+    case $arg in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"\n+      shift # fnord\n+      shift # $arg\n+      ;;\n+    esac\n+  done\n+\n+  test -z \"$dashmflag\" && dashmflag=-M\n+  # Require at least two characters before searching for `:'\n+  # in the target name.  This is to cope with DOS-style filenames:\n+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.\n+  \"$@\" $dashmflag |\n+    sed 's:^[  ]*[^: ][^:][^:]*\\:[    ]*:'\"$object\"'\\: :' > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  cat < \"$tmpdepfile\" > \"$depfile\"\n+  tr ' ' '\n+' < \"$tmpdepfile\" | \\\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+dashXmstdout)\n+  # This case only exists to satisfy depend.m4.  It is never actually\n+  # run, as this mode is specially recognized in the preamble.\n+  exit 1\n+  ;;\n+\n+makedepend)\n+  \"$@\" || exit $?\n+  # Remove any Libtool call\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+  # X makedepend\n+  shift\n+  cleared=no eat=no\n+  for arg\n+  do\n+    case $cleared in\n+    no)\n+      set \"\"; shift\n+      cleared=yes ;;\n+    esac\n+    if test $eat = yes; then\n+      eat=no\n+      continue\n+    fi\n+    case \"$arg\" in\n+    -D*|-I*)\n+      set fnord \"$@\" \"$arg\"; shift ;;\n+    # Strip any option that makedepend may not understand.  Remove\n+    # the object too, otherwise makedepend will parse it as a source file.\n+    -arch)\n+      eat=yes ;;\n+    -*|$object)\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"; shift ;;\n+    esac\n+  done\n+  obj_suffix=`echo \"$object\" | sed 's/^.*\\././'`\n+  touch \"$tmpdepfile\"\n+  ${MAKEDEPEND-makedepend} -o\"$obj_suffix\" -f\"$tmpdepfile\" \"$@\"\n+  rm -f \"$depfile\"\n+  cat < \"$tmpdepfile\" > \"$depfile\"\n+  sed '1,2d' \"$tmpdepfile\" | tr ' ' '\n+' | \\\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\" \"$tmpdepfile\".bak\n+  ;;\n+\n+cpp)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the preprocessed file to stdout.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  # Remove `-o $object'.\n+  IFS=\" \"\n+  for arg\n+  do\n+    case $arg in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"\n+      shift # fnord\n+      shift # $arg\n+      ;;\n+    esac\n+  done\n+\n+  \"$@\" -E |\n+    sed -n -e '/^# [0-9][0-9]* \"\\([^\"]*\\)\".*/ s:: \\1 \\\\:p' \\\n+       -e '/^#line [0-9][0-9]* \"\\([^\"]*\\)\".*/ s:: \\1 \\\\:p' |\n+    sed '$ s: \\\\$::' > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  cat < \"$tmpdepfile\" >> \"$depfile\"\n+  sed < \"$tmpdepfile\" '/^$/d;s/^ //;s/ \\\\$//;s/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+msvisualcpp)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the preprocessed file to stdout.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test \"X$1\" != 'X--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  IFS=\" \"\n+  for arg\n+  do\n+    case \"$arg\" in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    \"-Gm\"|\"/Gm\"|\"-Gi\"|\"/Gi\"|\"-ZI\"|\"/ZI\")\n+\tset fnord \"$@\"\n+\tshift\n+\tshift\n+\t;;\n+    *)\n+\tset fnord \"$@\" \"$arg\"\n+\tshift\n+\tshift\n+\t;;\n+    esac\n+  done\n+  \"$@\" -E 2>/dev/null |\n+  sed -n '/^#line [0-9][0-9]* \"\\([^\"]*\\)\"/ s::\\1:p' | $cygpath_u | sort -u > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  sed < \"$tmpdepfile\" -n -e 's% %\\\\ %g' -e '/^\\(.*\\)$/ s::\t\\1 \\\\:p' >> \"$depfile\"\n+  echo \"\t\" >> \"$depfile\"\n+  sed < \"$tmpdepfile\" -n -e 's% %\\\\ %g' -e '/^\\(.*\\)$/ s::\\1\\::p' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+msvcmsys)\n+  # This case exists only to let depend.m4 do its work.  It works by\n+  # looking at the text of this script.  This case will never be run,\n+  # since it is checked for above.\n+  exit 1\n+  ;;\n+\n+none)\n+  exec \"$@\"\n+  ;;\n+\n+*)\n+  echo \"Unknown depmode $depmode\" 1>&2\n+  exit 1\n+  ;;\n+esac\n+\n+exit 0\n+\n+# Local Variables:\n+# mode: shell-script\n+# sh-indentation: 2\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"scriptversion=\"\n+# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n+# time-stamp-time-zone: \"UTC\"\n+# time-stamp-end: \"; # UTC\"\n+# End:"}, {"sha": "ce42b5f2de0ef0241d258db609f26eab72f4b2eb", "filename": "src/rt/libuv/ev/ev++.h", "status": "added", "additions": 816, "deletions": 0, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev%2B%2B.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev%2B%2B.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev%2B%2B.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,816 @@\n+/*\n+ * libev simple C++ wrapper classes\n+ *\n+ * Copyright (c) 2007,2008,2010 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#ifndef EVPP_H__\n+#define EVPP_H__\n+\n+#ifdef EV_H\n+# include EV_H\n+#else\n+# include \"ev.h\"\n+#endif\n+\n+#ifndef EV_USE_STDEXCEPT\n+# define EV_USE_STDEXCEPT 1\n+#endif\n+\n+#if EV_USE_STDEXCEPT\n+# include <stdexcept>\n+#endif\n+\n+namespace ev {\n+\n+  typedef ev_tstamp tstamp;\n+\n+  enum {\n+    UNDEF    = EV_UNDEF,\n+    NONE     = EV_NONE,\n+    READ     = EV_READ,\n+    WRITE    = EV_WRITE,\n+#if EV_COMPAT3\n+    TIMEOUT  = EV_TIMEOUT,\n+#endif\n+    TIMER    = EV_TIMER,\n+    PERIODIC = EV_PERIODIC,\n+    SIGNAL   = EV_SIGNAL,\n+    CHILD    = EV_CHILD,\n+    STAT     = EV_STAT,\n+    IDLE     = EV_IDLE,\n+    CHECK    = EV_CHECK,\n+    PREPARE  = EV_PREPARE,\n+    FORK     = EV_FORK,\n+    ASYNC    = EV_ASYNC,\n+    EMBED    = EV_EMBED,\n+#   undef ERROR // some systems stupidly #define ERROR\n+    ERROR    = EV_ERROR\n+  };\n+\n+  enum\n+  {\n+    AUTO      = EVFLAG_AUTO,\n+    NOENV     = EVFLAG_NOENV,\n+    FORKCHECK = EVFLAG_FORKCHECK,\n+\n+    SELECT    = EVBACKEND_SELECT,\n+    POLL      = EVBACKEND_POLL,\n+    EPOLL     = EVBACKEND_EPOLL,\n+    KQUEUE    = EVBACKEND_KQUEUE,\n+    DEVPOLL   = EVBACKEND_DEVPOLL,\n+    PORT      = EVBACKEND_PORT\n+  };\n+\n+  enum\n+  {\n+#if EV_COMPAT3\n+    NONBLOCK = EVLOOP_NONBLOCK,\n+    ONESHOT  = EVLOOP_ONESHOT,\n+#endif\n+    NOWAIT   = EVRUN_NOWAIT,\n+    ONCE     = EVRUN_ONCE\n+  };\n+\n+  enum how_t\n+  {\n+    ONE = EVBREAK_ONE,\n+    ALL = EVBREAK_ALL\n+  };\n+\n+  struct bad_loop\n+#if EV_USE_STDEXCEPT\n+  : std::runtime_error\n+#endif\n+  {\n+#if EV_USE_STDEXCEPT\n+    bad_loop ()\n+    : std::runtime_error (\"libev event loop cannot be initialized, bad value of LIBEV_FLAGS?\")\n+    {\n+    }\n+#endif\n+  };\n+\n+#ifdef EV_AX\n+#  undef EV_AX\n+#endif\n+\n+#ifdef EV_AX_\n+#  undef EV_AX_\n+#endif\n+\n+#if EV_MULTIPLICITY\n+#  define EV_AX  raw_loop\n+#  define EV_AX_ raw_loop,\n+#else\n+#  define EV_AX\n+#  define EV_AX_\n+#endif\n+\n+  struct loop_ref\n+  {\n+    loop_ref (EV_P) throw ()\n+#if EV_MULTIPLICITY\n+    : EV_AX (EV_A)\n+#endif\n+    {\n+    }\n+\n+    bool operator == (const loop_ref &other) const throw ()\n+    {\n+#if EV_MULTIPLICITY\n+      return EV_AX == other.EV_AX;\n+#else\n+      return true;\n+#endif\n+    }\n+\n+    bool operator != (const loop_ref &other) const throw ()\n+    {\n+#if EV_MULTIPLICITY\n+      return ! (*this == other);\n+#else\n+      return false;\n+#endif\n+    }\n+\n+#if EV_MULTIPLICITY\n+    bool operator == (const EV_P) const throw ()\n+    {\n+      return this->EV_AX == EV_A;\n+    }\n+\n+    bool operator != (const EV_P) const throw ()\n+    {\n+      return (*this == EV_A);\n+    }\n+\n+    operator struct ev_loop * () const throw ()\n+    {\n+      return EV_AX;\n+    }\n+\n+    operator const struct ev_loop * () const throw ()\n+    {\n+      return EV_AX;\n+    }\n+\n+    bool is_default () const throw ()\n+    {\n+      return EV_AX == ev_default_loop (0);\n+    }\n+#endif\n+\n+#if EV_COMPAT3\n+    void loop (int flags = 0)\n+    {\n+      ev_run (EV_AX_ flags);\n+    }\n+\n+    void unloop (how_t how = ONE) throw ()\n+    {\n+      ev_break (EV_AX_ how);\n+    }\n+#endif\n+\n+    void run (int flags = 0)\n+    {\n+      ev_run (EV_AX_ flags);\n+    }\n+\n+    void break_loop (how_t how = ONE) throw ()\n+    {\n+      ev_break (EV_AX_ how);\n+    }\n+\n+    void post_fork () throw ()\n+    {\n+      ev_loop_fork (EV_AX);\n+    }\n+\n+    unsigned int backend () const throw ()\n+    {\n+      return ev_backend (EV_AX);\n+    }\n+\n+    tstamp now () const throw ()\n+    {\n+      return ev_now (EV_AX);\n+    }\n+\n+    void ref () throw ()\n+    {\n+      ev_ref (EV_AX);\n+    }\n+\n+    void unref () throw ()\n+    {\n+      ev_unref (EV_AX);\n+    }\n+\n+#if EV_FEATURE_API\n+    unsigned int iteration () const throw ()\n+    {\n+      return ev_iteration (EV_AX);\n+    }\n+\n+    unsigned int depth () const throw ()\n+    {\n+      return ev_depth (EV_AX);\n+    }\n+\n+    void set_io_collect_interval (tstamp interval) throw ()\n+    {\n+      ev_set_io_collect_interval (EV_AX_ interval);\n+    }\n+\n+    void set_timeout_collect_interval (tstamp interval) throw ()\n+    {\n+      ev_set_timeout_collect_interval (EV_AX_ interval);\n+    }\n+#endif\n+\n+    // function callback\n+    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) throw ()\n+    {\n+      ev_once (EV_AX_ fd, events, timeout, cb, arg);\n+    }\n+\n+    // method callback\n+    template<class K, void (K::*method)(int)>\n+    void once (int fd, int events, tstamp timeout, K *object) throw ()\n+    {\n+      once (fd, events, timeout, method_thunk<K, method>, object);\n+    }\n+\n+    // default method == operator ()\n+    template<class K>\n+    void once (int fd, int events, tstamp timeout, K *object) throw ()\n+    {\n+      once (fd, events, timeout, method_thunk<K, &K::operator ()>, object);\n+    }\n+\n+    template<class K, void (K::*method)(int)>\n+    static void method_thunk (int revents, void *arg)\n+    {\n+      static_cast<K *>(arg)->*method\n+        (revents);\n+    }\n+\n+    // no-argument method callback\n+    template<class K, void (K::*method)()>\n+    void once (int fd, int events, tstamp timeout, K *object) throw ()\n+    {\n+      once (fd, events, timeout, method_noargs_thunk<K, method>, object);\n+    }\n+\n+    template<class K, void (K::*method)()>\n+    static void method_noargs_thunk (int revents, void *arg)\n+    {\n+      static_cast<K *>(arg)->*method\n+        ();\n+    }\n+\n+    // simpler function callback\n+    template<void (*cb)(int)>\n+    void once (int fd, int events, tstamp timeout) throw ()\n+    {\n+      once (fd, events, timeout, simpler_func_thunk<cb>);\n+    }\n+\n+    template<void (*cb)(int)>\n+    static void simpler_func_thunk (int revents, void *arg)\n+    {\n+      (*cb)\n+        (revents);\n+    }\n+\n+    // simplest function callback\n+    template<void (*cb)()>\n+    void once (int fd, int events, tstamp timeout) throw ()\n+    {\n+      once (fd, events, timeout, simplest_func_thunk<cb>);\n+    }\n+\n+    template<void (*cb)()>\n+    static void simplest_func_thunk (int revents, void *arg)\n+    {\n+      (*cb)\n+        ();\n+    }\n+\n+    void feed_fd_event (int fd, int revents) throw ()\n+    {\n+      ev_feed_fd_event (EV_AX_ fd, revents);\n+    }\n+\n+    void feed_signal_event (int signum) throw ()\n+    {\n+      ev_feed_signal_event (EV_AX_ signum);\n+    }\n+\n+#if EV_MULTIPLICITY\n+    struct ev_loop* EV_AX;\n+#endif\n+\n+  };\n+\n+#if EV_MULTIPLICITY\n+  struct dynamic_loop : loop_ref\n+  {\n+\n+    dynamic_loop (unsigned int flags = AUTO) throw (bad_loop)\n+    : loop_ref (ev_loop_new (flags))\n+    {\n+      if (!EV_AX)\n+        throw bad_loop ();\n+    }\n+\n+    ~dynamic_loop () throw ()\n+    {\n+      ev_loop_destroy (EV_AX);\n+      EV_AX = 0;\n+    }\n+\n+  private:\n+\n+    dynamic_loop (const dynamic_loop &);\n+\n+    dynamic_loop & operator= (const dynamic_loop &);\n+\n+  };\n+#endif\n+\n+  struct default_loop : loop_ref\n+  {\n+    default_loop (unsigned int flags = AUTO) throw (bad_loop)\n+#if EV_MULTIPLICITY\n+    : loop_ref (ev_default_loop (flags))\n+#endif\n+    {\n+      if (\n+#if EV_MULTIPLICITY\n+          !EV_AX\n+#else\n+          !ev_default_loop (flags)\n+#endif\n+      )\n+        throw bad_loop ();\n+    }\n+\n+  private:\n+    default_loop (const default_loop &);\n+    default_loop &operator = (const default_loop &);\n+  };\n+\n+  inline loop_ref get_default_loop () throw ()\n+  {\n+#if EV_MULTIPLICITY\n+    return ev_default_loop (0);\n+#else\n+    return loop_ref ();\n+#endif\n+  }\n+\n+#undef EV_AX\n+#undef EV_AX_\n+\n+#undef EV_PX\n+#undef EV_PX_\n+#if EV_MULTIPLICITY\n+#  define EV_PX  loop_ref EV_A\n+#  define EV_PX_ loop_ref EV_A_\n+#else\n+#  define EV_PX\n+#  define EV_PX_\n+#endif\n+\n+  template<class ev_watcher, class watcher>\n+  struct base : ev_watcher\n+  {\n+    #if EV_MULTIPLICITY\n+      EV_PX;\n+\n+      // loop set\n+      void set (EV_P) throw ()\n+      {\n+        this->EV_A = EV_A;\n+      }\n+    #endif\n+\n+    base (EV_PX) throw ()\n+    #if EV_MULTIPLICITY\n+      : EV_A (EV_A)\n+    #endif\n+    {\n+      ev_init (this, 0);\n+    }\n+\n+    void set_ (const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents)) throw ()\n+    {\n+      this->data = (void *)data;\n+      ev_set_cb (static_cast<ev_watcher *>(this), cb);\n+    }\n+\n+    // function callback\n+    template<void (*function)(watcher &w, int)>\n+    void set (void *data = 0) throw ()\n+    {\n+      set_ (data, function_thunk<function>);\n+    }\n+\n+    template<void (*function)(watcher &w, int)>\n+    static void function_thunk (EV_P_ ev_watcher *w, int revents)\n+    {\n+      function\n+        (*static_cast<watcher *>(w), revents);\n+    }\n+\n+    // method callback\n+    template<class K, void (K::*method)(watcher &w, int)>\n+    void set (K *object) throw ()\n+    {\n+      set_ (object, method_thunk<K, method>);\n+    }\n+\n+    // default method == operator ()\n+    template<class K>\n+    void set (K *object) throw ()\n+    {\n+      set_ (object, method_thunk<K, &K::operator ()>);\n+    }\n+\n+    template<class K, void (K::*method)(watcher &w, int)>\n+    static void method_thunk (EV_P_ ev_watcher *w, int revents)\n+    {\n+      (static_cast<K *>(w->data)->*method)\n+        (*static_cast<watcher *>(w), revents);\n+    }\n+\n+    // no-argument callback\n+    template<class K, void (K::*method)()>\n+    void set (K *object) throw ()\n+    {\n+      set_ (object, method_noargs_thunk<K, method>);\n+    }\n+\n+    template<class K, void (K::*method)()>\n+    static void method_noargs_thunk (EV_P_ ev_watcher *w, int revents)\n+    {\n+      (static_cast<K *>(w->data)->*method)\n+        ();\n+    }\n+\n+    void operator ()(int events = EV_UNDEF)\n+    {\n+      return\n+        ev_cb (static_cast<ev_watcher *>(this))\n+          (static_cast<ev_watcher *>(this), events);\n+    }\n+\n+    bool is_active () const throw ()\n+    {\n+      return ev_is_active (static_cast<const ev_watcher *>(this));\n+    }\n+\n+    bool is_pending () const throw ()\n+    {\n+      return ev_is_pending (static_cast<const ev_watcher *>(this));\n+    }\n+\n+    void feed_event (int revents) throw ()\n+    {\n+      ev_feed_event (EV_A_ static_cast<const ev_watcher *>(this), revents);\n+    }\n+  };\n+\n+  inline tstamp now () throw ()\n+  {\n+    return ev_time ();\n+  }\n+\n+  inline void delay (tstamp interval) throw ()\n+  {\n+    ev_sleep (interval);\n+  }\n+\n+  inline int version_major () throw ()\n+  {\n+    return ev_version_major ();\n+  }\n+\n+  inline int version_minor () throw ()\n+  {\n+    return ev_version_minor ();\n+  }\n+\n+  inline unsigned int supported_backends () throw ()\n+  {\n+    return ev_supported_backends ();\n+  }\n+\n+  inline unsigned int recommended_backends () throw ()\n+  {\n+    return ev_recommended_backends ();\n+  }\n+\n+  inline unsigned int embeddable_backends () throw ()\n+  {\n+    return ev_embeddable_backends ();\n+  }\n+\n+  inline void set_allocator (void *(*cb)(void *ptr, long size)) throw ()\n+  {\n+    ev_set_allocator (cb);\n+  }\n+\n+  inline void set_syserr_cb (void (*cb)(const char *msg)) throw ()\n+  {\n+    ev_set_syserr_cb (cb);\n+  }\n+\n+  #if EV_MULTIPLICITY\n+    #define EV_CONSTRUCT(cppstem,cstem)\t                                                \\\n+      (EV_PX = get_default_loop ()) throw ()                                            \\\n+        : base<ev_ ## cstem, cppstem> (EV_A)                                            \\\n+      {                                                                                 \\\n+      }\n+  #else\n+    #define EV_CONSTRUCT(cppstem,cstem)                                                 \\\n+      () throw ()                                                                       \\\n+      {                                                                                 \\\n+      }\n+  #endif\n+\n+  /* using a template here would require quite a bit more lines,\n+   * so a macro solution was chosen */\n+  #define EV_BEGIN_WATCHER(cppstem,cstem)\t                                        \\\n+                                                                                        \\\n+  struct cppstem : base<ev_ ## cstem, cppstem>                                          \\\n+  {                                                                                     \\\n+    void start () throw ()                                                              \\\n+    {                                                                                   \\\n+      ev_ ## cstem ## _start (EV_A_ static_cast<ev_ ## cstem *>(this));                 \\\n+    }                                                                                   \\\n+                                                                                        \\\n+    void stop () throw ()                                                               \\\n+    {                                                                                   \\\n+      ev_ ## cstem ## _stop (EV_A_ static_cast<ev_ ## cstem *>(this));                  \\\n+    }                                                                                   \\\n+                                                                                        \\\n+    cppstem EV_CONSTRUCT(cppstem,cstem)                                                 \\\n+                                                                                        \\\n+    ~cppstem () throw ()                                                                \\\n+    {                                                                                   \\\n+      stop ();                                                                          \\\n+    }                                                                                   \\\n+                                                                                        \\\n+    using base<ev_ ## cstem, cppstem>::set;                                             \\\n+                                                                                        \\\n+  private:                                                                              \\\n+                                                                                        \\\n+    cppstem (const cppstem &o);                                                         \\\n+                                                                                        \\\n+    cppstem &operator =(const cppstem &o);                                              \\\n+                                                                                        \\\n+  public:\n+\n+  #define EV_END_WATCHER(cppstem,cstem)\t                                                \\\n+  };\n+\n+  EV_BEGIN_WATCHER (io, io)\n+    void set (int fd, int events) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_io_set (static_cast<ev_io *>(this), fd, events);\n+      if (active) start ();\n+    }\n+\n+    void set (int events) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_io_set (static_cast<ev_io *>(this), fd, events);\n+      if (active) start ();\n+    }\n+\n+    void start (int fd, int events) throw ()\n+    {\n+      set (fd, events);\n+      start ();\n+    }\n+  EV_END_WATCHER (io, io)\n+\n+  EV_BEGIN_WATCHER (timer, timer)\n+    void set (ev_tstamp after, ev_tstamp repeat = 0.) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_timer_set (static_cast<ev_timer *>(this), after, repeat);\n+      if (active) start ();\n+    }\n+\n+    void start (ev_tstamp after, ev_tstamp repeat = 0.) throw ()\n+    {\n+      set (after, repeat);\n+      start ();\n+    }\n+\n+    void again () throw ()\n+    {\n+      ev_timer_again (EV_A_ static_cast<ev_timer *>(this));\n+    }\n+\n+    ev_tstamp remaining ()\n+    {\n+      return ev_timer_remaining (EV_A_ static_cast<ev_timer *>(this));\n+    }\n+  EV_END_WATCHER (timer, timer)\n+\n+  #if EV_PERIODIC_ENABLE\n+  EV_BEGIN_WATCHER (periodic, periodic)\n+    void set (ev_tstamp at, ev_tstamp interval = 0.) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_periodic_set (static_cast<ev_periodic *>(this), at, interval, 0);\n+      if (active) start ();\n+    }\n+\n+    void start (ev_tstamp at, ev_tstamp interval = 0.) throw ()\n+    {\n+      set (at, interval);\n+      start ();\n+    }\n+\n+    void again () throw ()\n+    {\n+      ev_periodic_again (EV_A_ static_cast<ev_periodic *>(this));\n+    }\n+  EV_END_WATCHER (periodic, periodic)\n+  #endif\n+\n+  #if EV_SIGNAL_ENABLE\n+  EV_BEGIN_WATCHER (sig, signal)\n+    void set (int signum) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_signal_set (static_cast<ev_signal *>(this), signum);\n+      if (active) start ();\n+    }\n+\n+    void start (int signum) throw ()\n+    {\n+      set (signum);\n+      start ();\n+    }\n+  EV_END_WATCHER (sig, signal)\n+  #endif\n+\n+  #if EV_CHILD_ENABLE\n+  EV_BEGIN_WATCHER (child, child)\n+    void set (int pid, int trace = 0) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_child_set (static_cast<ev_child *>(this), pid, trace);\n+      if (active) start ();\n+    }\n+\n+    void start (int pid, int trace = 0) throw ()\n+    {\n+      set (pid, trace);\n+      start ();\n+    }\n+  EV_END_WATCHER (child, child)\n+  #endif\n+\n+  #if EV_STAT_ENABLE\n+  EV_BEGIN_WATCHER (stat, stat)\n+    void set (const char *path, ev_tstamp interval = 0.) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_stat_set (static_cast<ev_stat *>(this), path, interval);\n+      if (active) start ();\n+    }\n+\n+    void start (const char *path, ev_tstamp interval = 0.) throw ()\n+    {\n+      stop ();\n+      set (path, interval);\n+      start ();\n+    }\n+\n+    void update () throw ()\n+    {\n+      ev_stat_stat (EV_A_ static_cast<ev_stat *>(this));\n+    }\n+  EV_END_WATCHER (stat, stat)\n+  #endif\n+\n+  #if EV_IDLE_ENABLE\n+  EV_BEGIN_WATCHER (idle, idle)\n+    void set () throw () { }\n+  EV_END_WATCHER (idle, idle)\n+  #endif\n+\n+  #if EV_PREPARE_ENABLE\n+  EV_BEGIN_WATCHER (prepare, prepare)\n+    void set () throw () { }\n+  EV_END_WATCHER (prepare, prepare)\n+  #endif\n+\n+  #if EV_CHECK_ENABLE\n+  EV_BEGIN_WATCHER (check, check)\n+    void set () throw () { }\n+  EV_END_WATCHER (check, check)\n+  #endif\n+\n+  #if EV_EMBED_ENABLE\n+  EV_BEGIN_WATCHER (embed, embed)\n+    void set (struct ev_loop *embedded_loop) throw ()\n+    {\n+      int active = is_active ();\n+      if (active) stop ();\n+      ev_embed_set (static_cast<ev_embed *>(this), embedded_loop);\n+      if (active) start ();\n+    }\n+\n+    void start (struct ev_loop *embedded_loop) throw ()\n+    {\n+      set (embedded_loop);\n+      start ();\n+    }\n+\n+    void sweep ()\n+    {\n+      ev_embed_sweep (EV_A_ static_cast<ev_embed *>(this));\n+    }\n+  EV_END_WATCHER (embed, embed)\n+  #endif\n+\n+  #if EV_FORK_ENABLE\n+  EV_BEGIN_WATCHER (fork, fork)\n+    void set () throw () { }\n+  EV_END_WATCHER (fork, fork)\n+  #endif\n+\n+  #if EV_ASYNC_ENABLE\n+  EV_BEGIN_WATCHER (async, async)\n+    void send () throw ()\n+    {\n+      ev_async_send (EV_A_ static_cast<ev_async *>(this));\n+    }\n+\n+    bool async_pending () throw ()\n+    {\n+      return ev_async_pending (static_cast<ev_async *>(this));\n+    }\n+  EV_END_WATCHER (async, async)\n+  #endif\n+\n+  #undef EV_PX\n+  #undef EV_PX_\n+  #undef EV_CONSTRUCT\n+  #undef EV_BEGIN_WATCHER\n+  #undef EV_END_WATCHER\n+}\n+\n+#endif\n+"}, {"sha": "f2a4514582eb89bd724adb6e3dae9e0d49006f44", "filename": "src/rt/libuv/ev/ev.3", "status": "added", "additions": 5311, "deletions": 0, "changes": 5311, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.3", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev.3?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25"}, {"sha": "4187b18af730dd72179d902f3cc6d0ac2637ce41", "filename": "src/rt/libuv/ev/ev.c", "status": "added", "additions": 3913, "deletions": 0, "changes": 3913, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25"}, {"sha": "6fb8083413a3e599509affe0863f5df589bce7a7", "filename": "src/rt/libuv/ev/ev.h", "status": "added", "additions": 829, "deletions": 0, "changes": 829, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,829 @@\n+/*\n+ * libev native API header\n+ *\n+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#ifndef EV_H_\n+#define EV_H_\n+\n+#ifdef __cplusplus\n+# define EV_CPP(x) x\n+#else\n+# define EV_CPP(x)\n+#endif\n+\n+EV_CPP(extern \"C\" {)\n+\n+/*****************************************************************************/\n+\n+/* pre-4.0 compatibility */\n+#ifndef EV_COMPAT3\n+# define EV_COMPAT3 1\n+#endif\n+\n+#ifndef EV_FEATURES\n+# define EV_FEATURES 0x7f\n+#endif\n+\n+#define EV_FEATURE_CODE     ((EV_FEATURES) &  1)\n+#define EV_FEATURE_DATA     ((EV_FEATURES) &  2)\n+#define EV_FEATURE_CONFIG   ((EV_FEATURES) &  4)\n+#define EV_FEATURE_API      ((EV_FEATURES) &  8)\n+#define EV_FEATURE_WATCHERS ((EV_FEATURES) & 16)\n+#define EV_FEATURE_BACKENDS ((EV_FEATURES) & 32)\n+#define EV_FEATURE_OS       ((EV_FEATURES) & 64)\n+\n+/* these priorities are inclusive, higher priorities will be invoked earlier */\n+#ifndef EV_MINPRI\n+# define EV_MINPRI (EV_FEATURE_CONFIG ? -2 : 0)\n+#endif\n+#ifndef EV_MAXPRI\n+# define EV_MAXPRI (EV_FEATURE_CONFIG ? +2 : 0)\n+#endif\n+\n+#ifndef EV_MULTIPLICITY\n+# define EV_MULTIPLICITY EV_FEATURE_CONFIG\n+#endif\n+\n+#ifndef EV_PERIODIC_ENABLE\n+# define EV_PERIODIC_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_STAT_ENABLE\n+# define EV_STAT_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_PREPARE_ENABLE\n+# define EV_PREPARE_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_CHECK_ENABLE\n+# define EV_CHECK_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_IDLE_ENABLE\n+# define EV_IDLE_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_FORK_ENABLE\n+# define EV_FORK_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_CLEANUP_ENABLE\n+# define EV_CLEANUP_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_SIGNAL_ENABLE\n+# define EV_SIGNAL_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_CHILD_ENABLE\n+# ifdef _WIN32\n+#  define EV_CHILD_ENABLE 0\n+# else\n+#  define EV_CHILD_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+#endif\n+\n+#ifndef EV_ASYNC_ENABLE\n+# define EV_ASYNC_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_EMBED_ENABLE\n+# define EV_EMBED_ENABLE EV_FEATURE_WATCHERS\n+#endif\n+\n+#ifndef EV_WALK_ENABLE\n+# define EV_WALK_ENABLE 0 /* not yet */\n+#endif\n+\n+/*****************************************************************************/\n+\n+#if EV_CHILD_ENABLE && !EV_SIGNAL_ENABLE\n+# undef EV_SIGNAL_ENABLE\n+# define EV_SIGNAL_ENABLE 1\n+#endif\n+\n+/*****************************************************************************/\n+\n+typedef double ev_tstamp;\n+\n+#ifndef EV_ATOMIC_T\n+# include <signal.h>\n+# define EV_ATOMIC_T sig_atomic_t volatile\n+#endif\n+\n+#if EV_STAT_ENABLE\n+# ifdef _WIN32\n+#  include <time.h>\n+#  include <sys/types.h>\n+# endif\n+# include <sys/stat.h>\n+#endif\n+\n+/* support multiple event loops? */\n+#if EV_MULTIPLICITY\n+struct ev_loop;\n+# define EV_P  struct ev_loop *loop               /* a loop as sole parameter in a declaration */\n+# define EV_P_ EV_P,                              /* a loop as first of multiple parameters */\n+# define EV_A  loop                               /* a loop as sole argument to a function call */\n+# define EV_A_ EV_A,                              /* a loop as first of multiple arguments */\n+# define EV_DEFAULT_UC  ev_default_loop_uc_ ()    /* the default loop, if initialised, as sole arg */\n+# define EV_DEFAULT_UC_ EV_DEFAULT_UC,            /* the default loop as first of multiple arguments */\n+# define EV_DEFAULT  ev_default_loop (0)          /* the default loop as sole arg */\n+# define EV_DEFAULT_ EV_DEFAULT,                  /* the default loop as first of multiple arguments */\n+#else\n+# define EV_P void\n+# define EV_P_\n+# define EV_A\n+# define EV_A_\n+# define EV_DEFAULT\n+# define EV_DEFAULT_\n+# define EV_DEFAULT_UC\n+# define EV_DEFAULT_UC_\n+# undef EV_EMBED_ENABLE\n+#endif\n+\n+/* EV_INLINE is used for functions in header files */\n+#if __STDC_VERSION__ >= 199901L && __GNUC__ >= 3\n+# define EV_INLINE static inline\n+#else\n+# define EV_INLINE static\n+#endif\n+\n+/* EV_PROTOTYPES can be used to switch of prototype declarations */\n+#ifndef EV_PROTOTYPES\n+# define EV_PROTOTYPES 1\n+#endif\n+\n+/*****************************************************************************/\n+\n+#define EV_VERSION_MAJOR 4\n+#define EV_VERSION_MINOR 4\n+\n+/* eventmask, revents, events... */\n+enum {\n+  EV_UNDEF    = 0xFFFFFFFF, /* guaranteed to be invalid */\n+  EV_NONE     =       0x00, /* no events */\n+  EV_READ     =       0x01, /* ev_io detected read will not block */\n+  EV_WRITE    =       0x02, /* ev_io detected write will not block */\n+  EV__IOFDSET =       0x80, /* internal use only */\n+  EV_IO       =    EV_READ, /* alias for type-detection */\n+  EV_TIMER    = 0x00000100, /* timer timed out */\n+#if EV_COMPAT3\n+  EV_TIMEOUT  =   EV_TIMER, /* pre 4.0 API compatibility */\n+#endif\n+  EV_PERIODIC = 0x00000200, /* periodic timer timed out */\n+  EV_SIGNAL   = 0x00000400, /* signal was received */\n+  EV_CHILD    = 0x00000800, /* child/pid had status change */\n+  EV_STAT     = 0x00001000, /* stat data changed */\n+  EV_IDLE     = 0x00002000, /* event loop is idling */\n+  EV_PREPARE  = 0x00004000, /* event loop about to poll */\n+  EV_CHECK    = 0x00008000, /* event loop finished poll */\n+  EV_EMBED    = 0x00010000, /* embedded event loop needs sweep */\n+  EV_FORK     = 0x00020000, /* event loop resumed in child */\n+  EV_CLEANUP  = 0x00040000, /* event loop resumed in child */\n+  EV_ASYNC    = 0x00080000, /* async intra-loop signal */\n+  EV_CUSTOM   = 0x01000000, /* for use by user code */\n+  EV_ERROR    = 0x80000000  /* sent when an error occurs */\n+};\n+\n+/* can be used to add custom fields to all watchers, while losing binary compatibility */\n+#ifndef EV_COMMON\n+# define EV_COMMON void *data;\n+#endif\n+\n+#ifndef EV_CB_DECLARE\n+# define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents);\n+#endif\n+#ifndef EV_CB_INVOKE\n+# define EV_CB_INVOKE(watcher,revents) (watcher)->cb (EV_A_ (watcher), (revents))\n+#endif\n+\n+/* not official, do not use */\n+#define EV_CB(type,name) void name (EV_P_ struct ev_ ## type *w, int revents)\n+\n+/*\n+ * struct member types:\n+ * private: you may look at them, but not change them,\n+ *          and they might not mean anything to you.\n+ * ro: can be read anytime, but only changed when the watcher isn't active.\n+ * rw: can be read and modified anytime, even when the watcher is active.\n+ *\n+ * some internal details that might be helpful for debugging:\n+ *\n+ * active is either 0, which means the watcher is not active,\n+ *           or the array index of the watcher (periodics, timers)\n+ *           or the array index + 1 (most other watchers)\n+ *           or simply 1 for watchers that aren't in some array.\n+ * pending is either 0, in which case the watcher isn't,\n+ *           or the array index + 1 in the pendings array.\n+ */\n+\n+#if EV_MINPRI == EV_MAXPRI\n+# define EV_DECL_PRIORITY\n+#elif !defined (EV_DECL_PRIORITY)\n+# define EV_DECL_PRIORITY int priority;\n+#endif\n+\n+/* shared by all watchers */\n+#define EV_WATCHER(type)\t\t\t\\\n+  int active; /* private */\t\t\t\\\n+  int pending; /* private */\t\t\t\\\n+  EV_DECL_PRIORITY /* private */\t\t\\\n+  EV_COMMON /* rw */\t\t\t\t\\\n+  EV_CB_DECLARE (type) /* private */\n+\n+#define EV_WATCHER_LIST(type)\t\t\t\\\n+  EV_WATCHER (type)\t\t\t\t\\\n+  struct ev_watcher_list *next; /* private */\n+\n+#define EV_WATCHER_TIME(type)\t\t\t\\\n+  EV_WATCHER (type)\t\t\t\t\\\n+  ev_tstamp at;     /* private */\n+\n+/* base class, nothing to see here unless you subclass */\n+typedef struct ev_watcher\n+{\n+  EV_WATCHER (ev_watcher)\n+} ev_watcher;\n+\n+/* base class, nothing to see here unless you subclass */\n+typedef struct ev_watcher_list\n+{\n+  EV_WATCHER_LIST (ev_watcher_list)\n+} ev_watcher_list;\n+\n+/* base class, nothing to see here unless you subclass */\n+typedef struct ev_watcher_time\n+{\n+  EV_WATCHER_TIME (ev_watcher_time)\n+} ev_watcher_time;\n+\n+/* invoked when fd is either EV_READable or EV_WRITEable */\n+/* revent EV_READ, EV_WRITE */\n+typedef struct ev_io\n+{\n+  EV_WATCHER_LIST (ev_io)\n+\n+  int fd;     /* ro */\n+  int events; /* ro */\n+} ev_io;\n+\n+/* invoked after a specific time, repeatable (based on monotonic clock) */\n+/* revent EV_TIMEOUT */\n+typedef struct ev_timer\n+{\n+  EV_WATCHER_TIME (ev_timer)\n+\n+  ev_tstamp repeat; /* rw */\n+} ev_timer;\n+\n+/* invoked at some specific time, possibly repeating at regular intervals (based on UTC) */\n+/* revent EV_PERIODIC */\n+typedef struct ev_periodic\n+{\n+  EV_WATCHER_TIME (ev_periodic)\n+\n+  ev_tstamp offset; /* rw */\n+  ev_tstamp interval; /* rw */\n+  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now); /* rw */\n+} ev_periodic;\n+\n+/* invoked when the given signal has been received */\n+/* revent EV_SIGNAL */\n+typedef struct ev_signal\n+{\n+  EV_WATCHER_LIST (ev_signal)\n+\n+  int signum; /* ro */\n+} ev_signal;\n+\n+/* invoked when sigchld is received and waitpid indicates the given pid */\n+/* revent EV_CHILD */\n+/* does not support priorities */\n+typedef struct ev_child\n+{\n+  EV_WATCHER_LIST (ev_child)\n+\n+  int flags;   /* private */\n+  int pid;     /* ro */\n+  int rpid;    /* rw, holds the received pid */\n+  int rstatus; /* rw, holds the exit status, use the macros from sys/wait.h */\n+} ev_child;\n+\n+#if EV_STAT_ENABLE\n+/* st_nlink = 0 means missing file or other error */\n+# ifdef _WIN32\n+typedef struct _stati64 ev_statdata;\n+# else\n+typedef struct stat ev_statdata;\n+# endif\n+\n+/* invoked each time the stat data changes for a given path */\n+/* revent EV_STAT */\n+typedef struct ev_stat\n+{\n+  EV_WATCHER_LIST (ev_stat)\n+\n+  ev_timer timer;     /* private */\n+  ev_tstamp interval; /* ro */\n+  const char *path;   /* ro */\n+  ev_statdata prev;   /* ro */\n+  ev_statdata attr;   /* ro */\n+\n+  int wd; /* wd for inotify, fd for kqueue */\n+} ev_stat;\n+#endif\n+\n+#if EV_IDLE_ENABLE\n+/* invoked when the nothing else needs to be done, keeps the process from blocking */\n+/* revent EV_IDLE */\n+typedef struct ev_idle\n+{\n+  EV_WATCHER (ev_idle)\n+} ev_idle;\n+#endif\n+\n+/* invoked for each run of the mainloop, just before the blocking call */\n+/* you can still change events in any way you like */\n+/* revent EV_PREPARE */\n+typedef struct ev_prepare\n+{\n+  EV_WATCHER (ev_prepare)\n+} ev_prepare;\n+\n+/* invoked for each run of the mainloop, just after the blocking call */\n+/* revent EV_CHECK */\n+typedef struct ev_check\n+{\n+  EV_WATCHER (ev_check)\n+} ev_check;\n+\n+#if EV_FORK_ENABLE\n+/* the callback gets invoked before check in the child process when a fork was detected */\n+/* revent EV_FORK */\n+typedef struct ev_fork\n+{\n+  EV_WATCHER (ev_fork)\n+} ev_fork;\n+#endif\n+\n+#if EV_CLEANUP_ENABLE\n+/* is invoked just before the loop gets destroyed */\n+/* revent EV_CLEANUP */\n+typedef struct ev_cleanup\n+{\n+  EV_WATCHER (ev_cleanup)\n+} ev_cleanup;\n+#endif\n+\n+#if EV_EMBED_ENABLE\n+/* used to embed an event loop inside another */\n+/* the callback gets invoked when the event loop has handled events, and can be 0 */\n+typedef struct ev_embed\n+{\n+  EV_WATCHER (ev_embed)\n+\n+  struct ev_loop *other; /* ro */\n+  ev_io io;              /* private */\n+  ev_prepare prepare;    /* private */\n+  ev_check check;        /* unused */\n+  ev_timer timer;        /* unused */\n+  ev_periodic periodic;  /* unused */\n+  ev_idle idle;          /* unused */\n+  ev_fork fork;          /* private */\n+#if EV_CLEANUP_ENABLE\n+  ev_cleanup cleanup;    /* unused */\n+#endif\n+} ev_embed;\n+#endif\n+\n+#if EV_ASYNC_ENABLE\n+/* invoked when somebody calls ev_async_send on the watcher */\n+/* revent EV_ASYNC */\n+typedef struct ev_async\n+{\n+  EV_WATCHER (ev_async)\n+\n+  EV_ATOMIC_T sent; /* private */\n+} ev_async;\n+\n+# define ev_async_pending(w) (+(w)->sent)\n+#endif\n+\n+/* the presence of this union forces similar struct layout */\n+union ev_any_watcher\n+{\n+  struct ev_watcher w;\n+  struct ev_watcher_list wl;\n+\n+  struct ev_io io;\n+  struct ev_timer timer;\n+  struct ev_periodic periodic;\n+  struct ev_signal signal;\n+  struct ev_child child;\n+#if EV_STAT_ENABLE\n+  struct ev_stat stat;\n+#endif\n+#if EV_IDLE_ENABLE\n+  struct ev_idle idle;\n+#endif\n+  struct ev_prepare prepare;\n+  struct ev_check check;\n+#if EV_FORK_ENABLE\n+  struct ev_fork fork;\n+#endif\n+#if EV_CLEANUP_ENABLE\n+  struct ev_cleanup cleanup;\n+#endif\n+#if EV_EMBED_ENABLE\n+  struct ev_embed embed;\n+#endif\n+#if EV_ASYNC_ENABLE\n+  struct ev_async async;\n+#endif\n+};\n+\n+/* flag bits for ev_default_loop and ev_loop_new */\n+enum {\n+  /* the default */\n+  EVFLAG_AUTO      = 0x00000000U, /* not quite a mask */\n+  /* flag bits */\n+  EVFLAG_NOENV     = 0x01000000U, /* do NOT consult environment */\n+  EVFLAG_FORKCHECK = 0x02000000U, /* check for a fork in each iteration */\n+  /* debugging/feature disable */\n+  EVFLAG_NOINOTIFY = 0x00100000U, /* do not attempt to use inotify */\n+#if EV_COMPAT3\n+  EVFLAG_NOSIGFD   = 0, /* compatibility to pre-3.9 */\n+#endif\n+  EVFLAG_SIGNALFD  = 0x00200000U, /* attempt to use signalfd */\n+  EVFLAG_NOSIGMASK = 0x00400000U  /* avoid modifying the signal mask */\n+};\n+\n+/* method bits to be ored together */\n+enum {\n+  EVBACKEND_SELECT  = 0x00000001U, /* about anywhere */\n+  EVBACKEND_POLL    = 0x00000002U, /* !win */\n+  EVBACKEND_EPOLL   = 0x00000004U, /* linux */\n+  EVBACKEND_KQUEUE  = 0x00000008U, /* bsd */\n+  EVBACKEND_DEVPOLL = 0x00000010U, /* solaris 8 */ /* NYI */\n+  EVBACKEND_PORT    = 0x00000020U, /* solaris 10 */\n+  EVBACKEND_ALL     = 0x0000003FU, /* all known backends */\n+  EVBACKEND_MASK    = 0x0000FFFFU  /* all future backends */\n+};\n+\n+#if EV_PROTOTYPES\n+int ev_version_major (void);\n+int ev_version_minor (void);\n+\n+unsigned int ev_supported_backends (void);\n+unsigned int ev_recommended_backends (void);\n+unsigned int ev_embeddable_backends (void);\n+\n+ev_tstamp ev_time (void);\n+void ev_sleep (ev_tstamp delay); /* sleep for a while */\n+\n+/* Sets the allocation function to use, works like realloc.\n+ * It is used to allocate and free memory.\n+ * If it returns zero when memory needs to be allocated, the library might abort\n+ * or take some potentially destructive action.\n+ * The default is your system realloc function.\n+ */\n+void ev_set_allocator (void *(*cb)(void *ptr, long size));\n+\n+/* set the callback function to call on a\n+ * retryable syscall error\n+ * (such as failed select, poll, epoll_wait)\n+ */\n+void ev_set_syserr_cb (void (*cb)(const char *msg));\n+\n+#if EV_MULTIPLICITY\n+\n+/* the default loop is the only one that handles signals and child watchers */\n+/* you can call this as often as you like */\n+struct ev_loop *ev_default_loop (unsigned int flags EV_CPP (= 0));\n+\n+EV_INLINE struct ev_loop *\n+ev_default_loop_uc_ (void)\n+{\n+  extern struct ev_loop *ev_default_loop_ptr;\n+\n+  return ev_default_loop_ptr;\n+}\n+\n+EV_INLINE int\n+ev_is_default_loop (EV_P)\n+{\n+  return EV_A == EV_DEFAULT_UC;\n+}\n+\n+/* create and destroy alternative loops that don't handle signals */\n+struct ev_loop *ev_loop_new (unsigned int flags EV_CPP (= 0));\n+\n+ev_tstamp ev_now (EV_P); /* time w.r.t. timers and the eventloop, updated after each poll */\n+\n+#else\n+\n+int ev_default_loop (unsigned int flags EV_CPP (= 0)); /* returns true when successful */\n+\n+EV_INLINE ev_tstamp\n+ev_now (void)\n+{\n+  extern ev_tstamp ev_rt_now;\n+\n+  return ev_rt_now;\n+}\n+\n+/* looks weird, but ev_is_default_loop (EV_A) still works if this exists */\n+EV_INLINE int\n+ev_is_default_loop (void)\n+{\n+  return 1;\n+}\n+\n+#endif /* multiplicity */\n+\n+/* destroy event loops, also works for the default loop */\n+void ev_loop_destroy (EV_P);\n+\n+/* this needs to be called after fork, to duplicate the loop */\n+/* when you want to re-use it in the child */\n+/* you can call it in either the parent or the child */\n+/* you can actually call it at any time, anywhere :) */\n+void ev_loop_fork (EV_P);\n+\n+unsigned int ev_backend (EV_P); /* backend in use by loop */\n+\n+void ev_now_update (EV_P); /* update event loop time */\n+\n+#if EV_WALK_ENABLE\n+/* walk (almost) all watchers in the loop of a given type, invoking the */\n+/* callback on every such watcher. The callback might stop the watcher, */\n+/* but do nothing else with the loop */\n+void ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w));\n+#endif\n+\n+#endif /* prototypes */\n+\n+/* ev_run flags values */\n+enum {\n+  EVRUN_NOWAIT = 1, /* do not block/wait */\n+  EVRUN_ONCE   = 2  /* block *once* only */\n+};\n+\n+/* ev_break how values */\n+enum {\n+  EVBREAK_CANCEL = 0, /* undo unloop */\n+  EVBREAK_ONE    = 1, /* unloop once */\n+  EVBREAK_ALL    = 2  /* unloop all loops */\n+};\n+\n+#if EV_PROTOTYPES\n+void ev_run (EV_P_ int flags EV_CPP (= 0));\n+void ev_break (EV_P_ int how EV_CPP (= EVBREAK_ONE)); /* break out of the loop */\n+\n+/*\n+ * ref/unref can be used to add or remove a refcount on the mainloop. every watcher\n+ * keeps one reference. if you have a long-running watcher you never unregister that\n+ * should not keep ev_loop from running, unref() after starting, and ref() before stopping.\n+ */\n+void ev_ref   (EV_P);\n+void ev_unref (EV_P);\n+\n+/*\n+ * convenience function, wait for a single event, without registering an event watcher\n+ * if timeout is < 0, do wait indefinitely\n+ */\n+void ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg);\n+\n+# if EV_FEATURE_API\n+unsigned int ev_iteration (EV_P); /* number of loop iterations */\n+unsigned int ev_depth     (EV_P); /* #ev_loop enters - #ev_loop leaves */\n+void         ev_verify    (EV_P); /* abort if loop data corrupted */\n+\n+void ev_set_io_collect_interval (EV_P_ ev_tstamp interval); /* sleep at least this time, default 0 */\n+void ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval); /* sleep at least this time, default 0 */\n+\n+/* advanced stuff for threading etc. support, see docs */\n+void ev_set_userdata (EV_P_ void *data);\n+void *ev_userdata (EV_P);\n+void ev_set_invoke_pending_cb (EV_P_ void (*invoke_pending_cb)(EV_P));\n+void ev_set_loop_release_cb (EV_P_ void (*release)(EV_P), void (*acquire)(EV_P));\n+\n+unsigned int ev_pending_count (EV_P); /* number of pending events, if any */\n+void ev_invoke_pending (EV_P); /* invoke all pending watchers */\n+\n+/*\n+ * stop/start the timer handling.\n+ */\n+void ev_suspend (EV_P);\n+void ev_resume  (EV_P);\n+#endif\n+\n+#endif\n+\n+/* these may evaluate ev multiple times, and the other arguments at most once */\n+/* either use ev_init + ev_TYPE_set, or the ev_TYPE_init macro, below, to first initialise a watcher */\n+#define ev_init(ev,cb_) do {\t\t\t\\\n+  ((ev_watcher *)(void *)(ev))->active  =\t\\\n+  ((ev_watcher *)(void *)(ev))->pending = 0;\t\\\n+  ev_set_priority ((ev), 0);\t\t\t\\\n+  ev_set_cb ((ev), cb_);\t\t\t\\\n+} while (0)\n+\n+#define ev_io_set(ev,fd_,events_)            do { (ev)->fd = (fd_); (ev)->events = (events_) | EV__IOFDSET; } while (0)\n+#define ev_timer_set(ev,after_,repeat_)      do { ((ev_watcher_time *)(ev))->at = (after_); (ev)->repeat = (repeat_); } while (0)\n+#define ev_periodic_set(ev,ofs_,ival_,rcb_)  do { (ev)->offset = (ofs_); (ev)->interval = (ival_); (ev)->reschedule_cb = (rcb_); } while (0)\n+#define ev_signal_set(ev,signum_)            do { (ev)->signum = (signum_); } while (0)\n+#define ev_child_set(ev,pid_,trace_)         do { (ev)->pid = (pid_); (ev)->flags = !!(trace_); } while (0)\n+#define ev_stat_set(ev,path_,interval_)      do { (ev)->path = (path_); (ev)->interval = (interval_); (ev)->wd = -2; } while (0)\n+#define ev_idle_set(ev)                      /* nop, yes, this is a serious in-joke */\n+#define ev_prepare_set(ev)                   /* nop, yes, this is a serious in-joke */\n+#define ev_check_set(ev)                     /* nop, yes, this is a serious in-joke */\n+#define ev_embed_set(ev,other_)              do { (ev)->other = (other_); } while (0)\n+#define ev_fork_set(ev)                      /* nop, yes, this is a serious in-joke */\n+#define ev_cleanup_set(ev)                   /* nop, yes, this is a serious in-joke */\n+#define ev_async_set(ev)                     /* nop, yes, this is a serious in-joke */\n+\n+#define ev_io_init(ev,cb,fd,events)          do { ev_init ((ev), (cb)); ev_io_set ((ev),(fd),(events)); } while (0)\n+#define ev_timer_init(ev,cb,after,repeat)    do { ev_init ((ev), (cb)); ev_timer_set ((ev),(after),(repeat)); } while (0)\n+#define ev_periodic_init(ev,cb,ofs,ival,rcb) do { ev_init ((ev), (cb)); ev_periodic_set ((ev),(ofs),(ival),(rcb)); } while (0)\n+#define ev_signal_init(ev,cb,signum)         do { ev_init ((ev), (cb)); ev_signal_set ((ev), (signum)); } while (0)\n+#define ev_child_init(ev,cb,pid,trace)       do { ev_init ((ev), (cb)); ev_child_set ((ev),(pid),(trace)); } while (0)\n+#define ev_stat_init(ev,cb,path,interval)    do { ev_init ((ev), (cb)); ev_stat_set ((ev),(path),(interval)); } while (0)\n+#define ev_idle_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_idle_set ((ev)); } while (0)\n+#define ev_prepare_init(ev,cb)               do { ev_init ((ev), (cb)); ev_prepare_set ((ev)); } while (0)\n+#define ev_check_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_check_set ((ev)); } while (0)\n+#define ev_embed_init(ev,cb,other)           do { ev_init ((ev), (cb)); ev_embed_set ((ev),(other)); } while (0)\n+#define ev_fork_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_fork_set ((ev)); } while (0)\n+#define ev_cleanup_init(ev,cb)               do { ev_init ((ev), (cb)); ev_cleanup_set ((ev)); } while (0)\n+#define ev_async_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_async_set ((ev)); } while (0)\n+\n+#define ev_is_pending(ev)                    (0 + ((ev_watcher *)(void *)(ev))->pending) /* ro, true when watcher is waiting for callback invocation */\n+#define ev_is_active(ev)                     (0 + ((ev_watcher *)(void *)(ev))->active) /* ro, true when the watcher has been started */\n+\n+#define ev_cb(ev)                            (ev)->cb /* rw */\n+\n+#if EV_MINPRI == EV_MAXPRI\n+# define ev_priority(ev)                     ((ev), EV_MINPRI)\n+# define ev_set_priority(ev,pri)             ((ev), (pri))\n+#else\n+# define ev_priority(ev)                     (+(((ev_watcher *)(void *)(ev))->priority))\n+# define ev_set_priority(ev,pri)             (   (ev_watcher *)(void *)(ev))->priority = (pri)\n+#endif\n+\n+#define ev_periodic_at(ev)                   (+((ev_watcher_time *)(ev))->at)\n+\n+#ifndef ev_set_cb\n+# define ev_set_cb(ev,cb_)                   ev_cb (ev) = (cb_)\n+#endif\n+\n+/* stopping (enabling, adding) a watcher does nothing if it is already running */\n+/* stopping (disabling, deleting) a watcher does nothing unless its already running */\n+#if EV_PROTOTYPES\n+\n+/* feeds an event into a watcher as if the event actually occured */\n+/* accepts any ev_watcher type */\n+void ev_feed_event     (EV_P_ void *w, int revents);\n+void ev_feed_fd_event  (EV_P_ int fd, int revents);\n+#if EV_SIGNAL_ENABLE\n+void ev_feed_signal    (int signum);\n+void ev_feed_signal_event (EV_P_ int signum);\n+#endif\n+void ev_invoke         (EV_P_ void *w, int revents);\n+int  ev_clear_pending  (EV_P_ void *w);\n+\n+void ev_io_start       (EV_P_ ev_io *w);\n+void ev_io_stop        (EV_P_ ev_io *w);\n+\n+void ev_timer_start    (EV_P_ ev_timer *w);\n+void ev_timer_stop     (EV_P_ ev_timer *w);\n+/* stops if active and no repeat, restarts if active and repeating, starts if inactive and repeating */\n+void ev_timer_again    (EV_P_ ev_timer *w);\n+/* return remaining time */\n+ev_tstamp ev_timer_remaining (EV_P_ ev_timer *w);\n+\n+#if EV_PERIODIC_ENABLE\n+void ev_periodic_start (EV_P_ ev_periodic *w);\n+void ev_periodic_stop  (EV_P_ ev_periodic *w);\n+void ev_periodic_again (EV_P_ ev_periodic *w);\n+#endif\n+\n+/* only supported in the default loop */\n+#if EV_SIGNAL_ENABLE\n+void ev_signal_start   (EV_P_ ev_signal *w);\n+void ev_signal_stop    (EV_P_ ev_signal *w);\n+#endif\n+\n+/* only supported in the default loop */\n+# if EV_CHILD_ENABLE\n+void ev_child_start    (EV_P_ ev_child *w);\n+void ev_child_stop     (EV_P_ ev_child *w);\n+# endif\n+\n+# if EV_STAT_ENABLE\n+void ev_stat_start     (EV_P_ ev_stat *w);\n+void ev_stat_stop      (EV_P_ ev_stat *w);\n+void ev_stat_stat      (EV_P_ ev_stat *w);\n+# endif\n+\n+# if EV_IDLE_ENABLE\n+void ev_idle_start     (EV_P_ ev_idle *w);\n+void ev_idle_stop      (EV_P_ ev_idle *w);\n+# endif\n+\n+#if EV_PREPARE_ENABLE\n+void ev_prepare_start  (EV_P_ ev_prepare *w);\n+void ev_prepare_stop   (EV_P_ ev_prepare *w);\n+#endif\n+\n+#if EV_CHECK_ENABLE\n+void ev_check_start    (EV_P_ ev_check *w);\n+void ev_check_stop     (EV_P_ ev_check *w);\n+#endif\n+\n+# if EV_FORK_ENABLE\n+void ev_fork_start     (EV_P_ ev_fork *w);\n+void ev_fork_stop      (EV_P_ ev_fork *w);\n+# endif\n+\n+# if EV_CLEANUP_ENABLE\n+void ev_cleanup_start  (EV_P_ ev_cleanup *w);\n+void ev_cleanup_stop   (EV_P_ ev_cleanup *w);\n+# endif\n+\n+# if EV_EMBED_ENABLE\n+/* only supported when loop to be embedded is in fact embeddable */\n+void ev_embed_start    (EV_P_ ev_embed *w);\n+void ev_embed_stop     (EV_P_ ev_embed *w);\n+void ev_embed_sweep    (EV_P_ ev_embed *w);\n+# endif\n+\n+# if EV_ASYNC_ENABLE\n+void ev_async_start    (EV_P_ ev_async *w);\n+void ev_async_stop     (EV_P_ ev_async *w);\n+void ev_async_send     (EV_P_ ev_async *w);\n+# endif\n+\n+#if EV_COMPAT3\n+  #define EVLOOP_NONBLOCK EVRUN_NOWAIT\n+  #define EVLOOP_ONESHOT  EVRUN_ONCE\n+  #define EVUNLOOP_CANCEL EVBREAK_CANCEL\n+  #define EVUNLOOP_ONE    EVBREAK_ONE\n+  #define EVUNLOOP_ALL    EVBREAK_ALL\n+  #if EV_PROTOTYPES\n+    EV_INLINE void ev_loop   (EV_P_ int flags) { ev_run   (EV_A_ flags); }\n+    EV_INLINE void ev_unloop (EV_P_ int how  ) { ev_break (EV_A_ how  ); }\n+    EV_INLINE void ev_default_destroy (void) { ev_loop_destroy (EV_DEFAULT); }\n+    EV_INLINE void ev_default_fork    (void) { ev_loop_fork    (EV_DEFAULT); }\n+    #if EV_FEATURE_API\n+      EV_INLINE unsigned int ev_loop_count  (EV_P) { return ev_iteration  (EV_A); }\n+      EV_INLINE unsigned int ev_loop_depth  (EV_P) { return ev_depth      (EV_A); }\n+      EV_INLINE void         ev_loop_verify (EV_P) {        ev_verify     (EV_A); }\n+    #endif\n+  #endif\n+#else\n+  typedef struct ev_loop ev_loop;\n+#endif\n+\n+#endif\n+\n+EV_CPP(})\n+\n+#endif\n+"}, {"sha": "4bbef1fcf25b3deb62c8a31bb4fddd2b844c598b", "filename": "src/rt/libuv/ev/ev.pod", "status": "added", "additions": 5243, "deletions": 0, "changes": 5243, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.pod", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev.pod?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25"}, {"sha": "5deb65211181541bbac3f7082856ccdeef3beeba", "filename": "src/rt/libuv/ev/ev_epoll.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_epoll.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_epoll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_epoll.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,266 @@\n+/*\n+ * libev epoll fd activity backend\n+ *\n+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+/*\n+ * general notes about epoll:\n+ *\n+ * a) epoll silently removes fds from the fd set. as nothing tells us\n+ *    that an fd has been removed otherwise, we have to continually\n+ *    \"rearm\" fds that we suspect *might* have changed (same\n+ *    problem with kqueue, but much less costly there).\n+ * b) the fact that ADD != MOD creates a lot of extra syscalls due to a)\n+ *    and seems not to have any advantage.\n+ * c) the inability to handle fork or file descriptors (think dup)\n+ *    limits the applicability over poll, so this is not a generic\n+ *    poll replacement.\n+ * d) epoll doesn't work the same as select with many file descriptors\n+ *    (such as files). while not critical, no other advanced interface\n+ *    seems to share this (rather non-unixy) limitation.\n+ * e) epoll claims to be embeddable, but in practise you never get\n+ *    a ready event for the epoll fd (broken: <=2.6.26, working: >=2.6.32).\n+ * f) epoll_ctl returning EPERM means the fd is always ready.\n+ *\n+ * lots of \"weird code\" and complication handling in this file is due\n+ * to these design problems with epoll, as we try very hard to avoid\n+ * epoll_ctl syscalls for common usage patterns and handle the breakage\n+ * ensuing from receiving events for closed and otherwise long gone\n+ * file descriptors.\n+ */\n+\n+#include <sys/epoll.h>\n+\n+#define EV_EMASK_EPERM 0x80\n+\n+static void\n+epoll_modify (EV_P_ int fd, int oev, int nev)\n+{\n+  struct epoll_event ev;\n+  unsigned char oldmask;\n+\n+  /*\n+   * we handle EPOLL_CTL_DEL by ignoring it here\n+   * on the assumption that the fd is gone anyways\n+   * if that is wrong, we have to handle the spurious\n+   * event in epoll_poll.\n+   * if the fd is added again, we try to ADD it, and, if that\n+   * fails, we assume it still has the same eventmask.\n+   */\n+  if (!nev)\n+    return;\n+\n+  oldmask = anfds [fd].emask;\n+  anfds [fd].emask = nev;\n+\n+  /* store the generation counter in the upper 32 bits, the fd in the lower 32 bits */\n+  ev.data.u64 = (uint64_t)(uint32_t)fd\n+              | ((uint64_t)(uint32_t)++anfds [fd].egen << 32);\n+  ev.events   = (nev & EV_READ  ? EPOLLIN  : 0)\n+              | (nev & EV_WRITE ? EPOLLOUT : 0);\n+\n+  if (expect_true (!epoll_ctl (backend_fd, oev && oldmask != nev ? EPOLL_CTL_MOD : EPOLL_CTL_ADD, fd, &ev)))\n+    return;\n+\n+  if (expect_true (errno == ENOENT))\n+    {\n+      /* if ENOENT then the fd went away, so try to do the right thing */\n+      if (!nev)\n+        goto dec_egen;\n+\n+      if (!epoll_ctl (backend_fd, EPOLL_CTL_ADD, fd, &ev))\n+        return;\n+    }\n+  else if (expect_true (errno == EEXIST))\n+    {\n+      /* EEXIST means we ignored a previous DEL, but the fd is still active */\n+      /* if the kernel mask is the same as the new mask, we assume it hasn't changed */\n+      if (oldmask == nev)\n+        goto dec_egen;\n+\n+      if (!epoll_ctl (backend_fd, EPOLL_CTL_MOD, fd, &ev))\n+        return;\n+    }\n+  else if (expect_true (errno == EPERM))\n+    {\n+      /* EPERM means the fd is always ready, but epoll is too snobbish */\n+      /* to handle it, unlike select or poll. */\n+      anfds [fd].emask = EV_EMASK_EPERM;\n+\n+      /* add fd to epoll_eperms, if not already inside */\n+      if (!(oldmask & EV_EMASK_EPERM))\n+        {\n+          array_needsize (int, epoll_eperms, epoll_epermmax, epoll_epermcnt + 1, EMPTY2);\n+          epoll_eperms [epoll_epermcnt++] = fd;\n+        }\n+\n+      return;\n+    }\n+\n+  fd_kill (EV_A_ fd);\n+\n+dec_egen:\n+  /* we didn't successfully call epoll_ctl, so decrement the generation counter again */\n+  --anfds [fd].egen;\n+}\n+\n+static void\n+epoll_poll (EV_P_ ev_tstamp timeout)\n+{\n+  int i;\n+  int eventcnt;\n+\n+  /* epoll wait times cannot be larger than (LONG_MAX - 999UL) / HZ msecs, which is below */\n+  /* the default libev max wait time, however. */\n+  EV_RELEASE_CB;\n+  eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax,\n+                         epoll_epermcnt ? 0 : ev_timeout_to_ms (timeout));\n+  EV_ACQUIRE_CB;\n+\n+  if (expect_false (eventcnt < 0))\n+    {\n+      if (errno != EINTR)\n+        ev_syserr (\"(libev) epoll_wait\");\n+\n+      return;\n+    }\n+\n+  for (i = 0; i < eventcnt; ++i)\n+    {\n+      struct epoll_event *ev = epoll_events + i;\n+\n+      int fd = (uint32_t)ev->data.u64; /* mask out the lower 32 bits */\n+      int want = anfds [fd].events;\n+      int got  = (ev->events & (EPOLLOUT | EPOLLERR | EPOLLHUP) ? EV_WRITE : 0)\n+               | (ev->events & (EPOLLIN  | EPOLLERR | EPOLLHUP) ? EV_READ  : 0);\n+\n+      /* check for spurious notification */\n+      /* we assume that fd is always in range, as we never shrink the anfds array */\n+      if (expect_false ((uint32_t)anfds [fd].egen != (uint32_t)(ev->data.u64 >> 32)))\n+        {\n+          /* recreate kernel state */\n+          postfork = 1;\n+          continue;\n+        }\n+\n+      if (expect_false (got & ~want))\n+        {\n+          anfds [fd].emask = want;\n+\n+          /* we received an event but are not interested in it, try mod or del */\n+          /* I don't think we ever need MOD, but let's handle it anyways */\n+          ev->events = (want & EV_READ  ? EPOLLIN  : 0)\n+                     | (want & EV_WRITE ? EPOLLOUT : 0);\n+\n+          /* pre-2.6.9 kernels require a non-null pointer with EPOLL_CTL_DEL, */\n+          /* which is fortunately easy to do for us. */\n+          if (epoll_ctl (backend_fd, want ? EPOLL_CTL_MOD : EPOLL_CTL_DEL, fd, ev))\n+            {\n+              postfork = 1; /* an error occurred, recreate kernel state */\n+              continue;\n+            }\n+        }\n+\n+      fd_event (EV_A_ fd, got);\n+    }\n+\n+  /* if the receive array was full, increase its size */\n+  if (expect_false (eventcnt == epoll_eventmax))\n+    {\n+      ev_free (epoll_events);\n+      epoll_eventmax = array_nextsize (sizeof (struct epoll_event), epoll_eventmax, epoll_eventmax + 1);\n+      epoll_events = (struct epoll_event *)ev_malloc (sizeof (struct epoll_event) * epoll_eventmax);\n+    }\n+\n+  /* now synthesize events for all fds where epoll fails, while select works... */\n+  for (i = epoll_epermcnt; i--; )\n+    {\n+      int fd = epoll_eperms [i];\n+      unsigned char events = anfds [fd].events & (EV_READ | EV_WRITE);\n+\n+      if (anfds [fd].emask & EV_EMASK_EPERM && events)\n+        fd_event (EV_A_ fd, events);\n+      else\n+        epoll_eperms [i] = epoll_eperms [--epoll_epermcnt];\n+    }\n+}\n+\n+int inline_size\n+epoll_init (EV_P_ int flags)\n+{\n+#ifdef EPOLL_CLOEXEC\n+  backend_fd = epoll_create1 (EPOLL_CLOEXEC);\n+\n+  if (backend_fd <= 0)\n+#endif\n+    backend_fd = epoll_create (256);\n+\n+  if (backend_fd < 0)\n+    return 0;\n+\n+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);\n+\n+  backend_fudge  = 0.; /* kernel sources seem to indicate this to be zero */\n+  backend_modify = epoll_modify;\n+  backend_poll   = epoll_poll;\n+\n+  epoll_eventmax = 64; /* initial number of events receivable per poll */\n+  epoll_events = (struct epoll_event *)ev_malloc (sizeof (struct epoll_event) * epoll_eventmax);\n+\n+  return EVBACKEND_EPOLL;\n+}\n+\n+void inline_size\n+epoll_destroy (EV_P)\n+{\n+  ev_free (epoll_events);\n+  array_free (epoll_eperm, EMPTY);\n+}\n+\n+void inline_size\n+epoll_fork (EV_P)\n+{\n+  close (backend_fd);\n+\n+  while ((backend_fd = epoll_create (256)) < 0)\n+    ev_syserr (\"(libev) epoll_create\");\n+\n+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);\n+\n+  fd_rearm_all (EV_A);\n+}\n+"}, {"sha": "1b526d1c7bc0ded3fb3cc8e0124ec9f85b50ebc5", "filename": "src/rt/libuv/ev/ev_kqueue.c", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_kqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_kqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_kqueue.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,198 @@\n+/*\n+ * libev kqueue backend\n+ *\n+ * Copyright (c) 2007,2008,2009,2010 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#include <sys/event.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+void inline_speed\n+kqueue_change (EV_P_ int fd, int filter, int flags, int fflags)\n+{\n+  ++kqueue_changecnt;\n+  array_needsize (struct kevent, kqueue_changes, kqueue_changemax, kqueue_changecnt, EMPTY2);\n+\n+  EV_SET (&kqueue_changes [kqueue_changecnt - 1], fd, filter, flags, fflags, 0, 0);\n+}\n+\n+/* OS X at least needs this */\n+#ifndef EV_ENABLE\n+# define EV_ENABLE 0\n+#endif\n+#ifndef NOTE_EOF\n+# define NOTE_EOF 0\n+#endif\n+\n+static void\n+kqueue_modify (EV_P_ int fd, int oev, int nev)\n+{\n+  if (oev != nev)\n+    {\n+      if (oev & EV_READ)\n+        kqueue_change (EV_A_ fd, EVFILT_READ , EV_DELETE, 0);\n+\n+      if (oev & EV_WRITE)\n+        kqueue_change (EV_A_ fd, EVFILT_WRITE, EV_DELETE, 0);\n+    }\n+\n+  /* to detect close/reopen reliably, we have to re-add */\n+  /* event requests even when oev == nev */\n+\n+  if (nev & EV_READ)\n+    kqueue_change (EV_A_ fd, EVFILT_READ , EV_ADD | EV_ENABLE, NOTE_EOF);\n+\n+  if (nev & EV_WRITE)\n+    kqueue_change (EV_A_ fd, EVFILT_WRITE, EV_ADD | EV_ENABLE, NOTE_EOF);\n+}\n+\n+static void\n+kqueue_poll (EV_P_ ev_tstamp timeout)\n+{\n+  int res, i;\n+  struct timespec ts;\n+\n+  /* need to resize so there is enough space for errors */\n+  if (kqueue_changecnt > kqueue_eventmax)\n+    {\n+      ev_free (kqueue_events);\n+      kqueue_eventmax = array_nextsize (sizeof (struct kevent), kqueue_eventmax, kqueue_changecnt);\n+      kqueue_events = (struct kevent *)ev_malloc (sizeof (struct kevent) * kqueue_eventmax);\n+    }\n+\n+  EV_RELEASE_CB;\n+  EV_TS_SET (ts, timeout);\n+  res = kevent (backend_fd, kqueue_changes, kqueue_changecnt, kqueue_events, kqueue_eventmax, &ts);\n+  EV_ACQUIRE_CB;\n+  kqueue_changecnt = 0;\n+\n+  if (expect_false (res < 0))\n+    {\n+      if (errno != EINTR)\n+        ev_syserr (\"(libev) kevent\");\n+\n+      return;\n+    }\n+\n+  for (i = 0; i < res; ++i)\n+    {\n+      int fd = kqueue_events [i].ident;\n+\n+      if (expect_false (kqueue_events [i].flags & EV_ERROR))\n+        {\n+          int err = kqueue_events [i].data;\n+\n+          /* we are only interested in errors for fds that we are interested in :) */\n+          if (anfds [fd].events)\n+            {\n+              if (err == ENOENT) /* resubmit changes on ENOENT */\n+                kqueue_modify (EV_A_ fd, 0, anfds [fd].events);\n+              else if (err == EBADF) /* on EBADF, we re-check the fd */\n+                {\n+                  if (fd_valid (fd))\n+                    kqueue_modify (EV_A_ fd, 0, anfds [fd].events);\n+                  else\n+                    fd_kill (EV_A_ fd);\n+                }\n+              else /* on all other errors, we error out on the fd */\n+                fd_kill (EV_A_ fd);\n+            }\n+        }\n+      else\n+        fd_event (\n+          EV_A_\n+          fd,\n+          kqueue_events [i].filter == EVFILT_READ ? EV_READ\n+          : kqueue_events [i].filter == EVFILT_WRITE ? EV_WRITE\n+          : 0\n+        );\n+    }\n+\n+  if (expect_false (res == kqueue_eventmax))\n+    {\n+      ev_free (kqueue_events);\n+      kqueue_eventmax = array_nextsize (sizeof (struct kevent), kqueue_eventmax, kqueue_eventmax + 1);\n+      kqueue_events = (struct kevent *)ev_malloc (sizeof (struct kevent) * kqueue_eventmax);\n+    }\n+}\n+\n+int inline_size\n+kqueue_init (EV_P_ int flags)\n+{\n+  /* Initialize the kernel queue */\n+  if ((backend_fd = kqueue ()) < 0)\n+    return 0;\n+\n+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC); /* not sure if necessary, hopefully doesn't hurt */\n+\n+  backend_fudge  = 0.;\n+  backend_modify = kqueue_modify;\n+  backend_poll   = kqueue_poll;\n+\n+  kqueue_eventmax = 64; /* initial number of events receivable per poll */\n+  kqueue_events = (struct kevent *)ev_malloc (sizeof (struct kevent) * kqueue_eventmax);\n+\n+  kqueue_changes   = 0;\n+  kqueue_changemax = 0;\n+  kqueue_changecnt = 0;\n+\n+  return EVBACKEND_KQUEUE;\n+}\n+\n+void inline_size\n+kqueue_destroy (EV_P)\n+{\n+  ev_free (kqueue_events);\n+  ev_free (kqueue_changes);\n+}\n+\n+void inline_size\n+kqueue_fork (EV_P)\n+{\n+  close (backend_fd);\n+\n+  while ((backend_fd = kqueue ()) < 0)\n+    ev_syserr (\"(libev) kqueue\");\n+\n+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);\n+\n+  /* re-register interest in fds */\n+  fd_rearm_all (EV_A);\n+}\n+"}, {"sha": "e53ae0de93c6055e2346e1a5d02afab295ea3e20", "filename": "src/rt/libuv/ev/ev_poll.c", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_poll.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_poll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_poll.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,148 @@\n+/*\n+ * libev poll fd activity backend\n+ *\n+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#include <poll.h>\n+\n+void inline_size\n+pollidx_init (int *base, int count)\n+{\n+  /* consider using memset (.., -1, ...), which is practically guaranteed\n+   * to work on all systems implementing poll */\n+  while (count--)\n+    *base++ = -1;\n+}\n+\n+static void\n+poll_modify (EV_P_ int fd, int oev, int nev)\n+{\n+  int idx;\n+\n+  if (oev == nev)\n+    return;\n+\n+  array_needsize (int, pollidxs, pollidxmax, fd + 1, pollidx_init);\n+\n+  idx = pollidxs [fd];\n+\n+  if (idx < 0) /* need to allocate a new pollfd */\n+    {\n+      pollidxs [fd] = idx = pollcnt++;\n+      array_needsize (struct pollfd, polls, pollmax, pollcnt, EMPTY2);\n+      polls [idx].fd = fd;\n+    }\n+\n+  assert (polls [idx].fd == fd);\n+\n+  if (nev)\n+    polls [idx].events =\n+        (nev & EV_READ ? POLLIN : 0)\n+        | (nev & EV_WRITE ? POLLOUT : 0);\n+  else /* remove pollfd */\n+    {\n+      pollidxs [fd] = -1;\n+\n+      if (expect_true (idx < --pollcnt))\n+        {\n+          polls [idx] = polls [pollcnt];\n+          pollidxs [polls [idx].fd] = idx;\n+        }\n+    }\n+}\n+\n+static void\n+poll_poll (EV_P_ ev_tstamp timeout)\n+{\n+  struct pollfd *p;\n+  int res;\n+  \n+  EV_RELEASE_CB;\n+  res = poll (polls, pollcnt, ev_timeout_to_ms (timeout));\n+  EV_ACQUIRE_CB;\n+\n+  if (expect_false (res < 0))\n+    {\n+      if (errno == EBADF)\n+        fd_ebadf (EV_A);\n+      else if (errno == ENOMEM && !syserr_cb)\n+        fd_enomem (EV_A);\n+      else if (errno != EINTR)\n+        ev_syserr (\"(libev) poll\");\n+    }\n+  else\n+    for (p = polls; res; ++p)\n+      {\n+        assert ((\"libev: poll() returned illegal result, broken BSD kernel?\", p < polls + pollcnt));\n+\n+        if (expect_false (p->revents)) /* this expect is debatable */\n+          {\n+            --res;\n+\n+            if (expect_false (p->revents & POLLNVAL))\n+              fd_kill (EV_A_ p->fd);\n+            else\n+              fd_event (\n+                EV_A_\n+                p->fd,\n+                (p->revents & (POLLOUT | POLLERR | POLLHUP) ? EV_WRITE : 0)\n+                | (p->revents & (POLLIN | POLLERR | POLLHUP) ? EV_READ : 0)\n+              );\n+          }\n+      }\n+}\n+\n+int inline_size\n+poll_init (EV_P_ int flags)\n+{\n+  backend_fudge  = 0.; /* posix says this is zero */\n+  backend_modify = poll_modify;\n+  backend_poll   = poll_poll;\n+\n+  pollidxs = 0; pollidxmax = 0;\n+  polls    = 0; pollmax    = 0; pollcnt = 0;\n+\n+  return EVBACKEND_POLL;\n+}\n+\n+void inline_size\n+poll_destroy (EV_P)\n+{\n+  ev_free (pollidxs);\n+  ev_free (polls);\n+}\n+"}, {"sha": "0ffebc372672866e3bfde9abe18cbf717b32a24f", "filename": "src/rt/libuv/ev/ev_port.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_port.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_port.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_port.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,179 @@\n+/*\n+ * libev solaris event port backend\n+ *\n+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+/* useful reading:\n+ *\n+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6268715 (random results)\n+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6455223 (just totally broken)\n+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6873782 (manpage ETIME)\n+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6874410 (implementation ETIME)\n+ * http://www.mail-archive.com/networking-discuss@opensolaris.org/msg11898.html ETIME vs. nget\n+ * http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libc/port/gen/event_port.c (libc)\n+ * http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/fs/portfs/port.c#1325 (kernel)\n+ */\n+\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#include <poll.h>\n+#include <port.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+void inline_speed\n+port_associate_and_check (EV_P_ int fd, int ev)\n+{\n+  if (0 >\n+      port_associate (\n+         backend_fd, PORT_SOURCE_FD, fd,\n+         (ev & EV_READ ? POLLIN : 0)\n+         | (ev & EV_WRITE ? POLLOUT : 0),\n+         0\n+      )\n+  )\n+    {\n+      if (errno == EBADFD)\n+        fd_kill (EV_A_ fd);\n+      else\n+        ev_syserr (\"(libev) port_associate\");\n+    }\n+}\n+\n+static void\n+port_modify (EV_P_ int fd, int oev, int nev)\n+{\n+  /* we need to reassociate no matter what, as closes are\n+   * once more silently being discarded.\n+   */\n+  if (!nev)\n+    {\n+      if (oev)\n+        port_dissociate (backend_fd, PORT_SOURCE_FD, fd);\n+    }\n+  else\n+    port_associate_and_check (EV_A_ fd, nev);\n+}\n+\n+static void\n+port_poll (EV_P_ ev_tstamp timeout)\n+{\n+  int res, i;\n+  struct timespec ts;\n+  uint_t nget = 1;\n+\n+  /* we initialise this to something we will skip in the loop, as */\n+  /* port_getn can return with nget unchanged, but no indication */\n+  /* whether it was the original value or has been updated :/ */\n+  port_events [0].portev_source = 0;\n+\n+  EV_RELEASE_CB;\n+  EV_TS_SET (ts, timeout);\n+  res = port_getn (backend_fd, port_events, port_eventmax, &nget, &ts);\n+  EV_ACQUIRE_CB;\n+\n+  /* port_getn may or may not set nget on error */\n+  /* so we rely on port_events [0].portev_source not being updated */\n+  if (res == -1 && errno != ETIME && errno != EINTR)\n+    ev_syserr (\"(libev) port_getn (see http://bugs.opensolaris.org/view_bug.do?bug_id=6268715, try LIBEV_FLAGS=3 env variable)\");\n+\n+  for (i = 0; i < nget; ++i)\n+    {\n+      if (port_events [i].portev_source == PORT_SOURCE_FD)\n+        {\n+          int fd = port_events [i].portev_object;\n+\n+          fd_event (\n+            EV_A_\n+            fd,\n+            (port_events [i].portev_events & (POLLOUT | POLLERR | POLLHUP) ? EV_WRITE : 0)\n+            | (port_events [i].portev_events & (POLLIN | POLLERR | POLLHUP) ? EV_READ : 0)\n+          );\n+\n+          fd_change (EV_A_ fd, EV__IOFDSET);\n+        }\n+    }\n+\n+  if (expect_false (nget == port_eventmax))\n+    {\n+      ev_free (port_events);\n+      port_eventmax = array_nextsize (sizeof (port_event_t), port_eventmax, port_eventmax + 1);\n+      port_events = (port_event_t *)ev_malloc (sizeof (port_event_t) * port_eventmax);\n+    }\n+}\n+\n+int inline_size\n+port_init (EV_P_ int flags)\n+{\n+  /* Initialize the kernel queue */\n+  if ((backend_fd = port_create ()) < 0)\n+    return 0;\n+\n+  assert ((\"libev: PORT_SOURCE_FD must not be zero\", PORT_SOURCE_FD));\n+\n+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC); /* not sure if necessary, hopefully doesn't hurt */\n+\n+  backend_fudge  = 1e-3; /* needed to compensate for port_getn returning early */\n+  backend_modify = port_modify;\n+  backend_poll   = port_poll;\n+\n+  port_eventmax = 64; /* initial number of events receivable per poll */\n+  port_events = (port_event_t *)ev_malloc (sizeof (port_event_t) * port_eventmax);\n+\n+  return EVBACKEND_PORT;\n+}\n+\n+void inline_size\n+port_destroy (EV_P)\n+{\n+  ev_free (port_events);\n+}\n+\n+void inline_size\n+port_fork (EV_P)\n+{\n+  close (backend_fd);\n+\n+  while ((backend_fd = port_create ()) < 0)\n+    ev_syserr (\"(libev) port\");\n+\n+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);\n+\n+  /* re-register interest in fds */\n+  fd_rearm_all (EV_A);\n+}\n+"}, {"sha": "0ea9467e4015a5df7fcf1de9536f8f8d803cdaf6", "filename": "src/rt/libuv/ev/ev_select.c", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_select.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_select.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_select.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,310 @@\n+/*\n+ * libev select fd activity backend\n+ *\n+ * Copyright (c) 2007,2008,2009,2010 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#ifndef _WIN32\n+/* for unix systems */\n+# include <inttypes.h>\n+# ifndef __hpux\n+/* for REAL unix systems */\n+#  include <sys/select.h>\n+# endif\n+#endif\n+\n+#ifndef EV_SELECT_USE_FD_SET\n+# ifdef NFDBITS\n+#  define EV_SELECT_USE_FD_SET 0\n+# else\n+#  define EV_SELECT_USE_FD_SET 1\n+# endif\n+#endif\n+\n+#if EV_SELECT_IS_WINSOCKET\n+# undef EV_SELECT_USE_FD_SET\n+# define EV_SELECT_USE_FD_SET 1\n+# undef NFDBITS\n+# define NFDBITS 0\n+#endif\n+\n+#if !EV_SELECT_USE_FD_SET\n+# define NFDBYTES (NFDBITS / 8)\n+#endif\n+\n+#include <string.h>\n+\n+static void\n+select_modify (EV_P_ int fd, int oev, int nev)\n+{\n+  if (oev == nev)\n+    return;\n+\n+  {\n+#if EV_SELECT_USE_FD_SET\n+\n+    #if EV_SELECT_IS_WINSOCKET\n+    SOCKET handle = anfds [fd].handle;\n+    #else\n+    int handle = fd;\n+    #endif\n+\n+    assert ((\"libev: fd >= FD_SETSIZE passed to fd_set-based select backend\", fd < FD_SETSIZE));\n+\n+    /* FD_SET is broken on windows (it adds the fd to a set twice or more,\n+     * which eventually leads to overflows). Need to call it only on changes.\n+     */\n+    #if EV_SELECT_IS_WINSOCKET\n+    if ((oev ^ nev) & EV_READ)\n+    #endif\n+      if (nev & EV_READ)\n+        FD_SET (handle, (fd_set *)vec_ri);\n+      else\n+        FD_CLR (handle, (fd_set *)vec_ri);\n+\n+    #if EV_SELECT_IS_WINSOCKET\n+    if ((oev ^ nev) & EV_WRITE)\n+    #endif\n+      if (nev & EV_WRITE)\n+        FD_SET (handle, (fd_set *)vec_wi);\n+      else\n+        FD_CLR (handle, (fd_set *)vec_wi);\n+\n+#else\n+\n+    int     word = fd / NFDBITS;\n+    fd_mask mask = 1UL << (fd % NFDBITS);\n+\n+    if (expect_false (vec_max <= word))\n+      {\n+        int new_max = word + 1;\n+\n+        vec_ri = ev_realloc (vec_ri, new_max * NFDBYTES);\n+        vec_ro = ev_realloc (vec_ro, new_max * NFDBYTES); /* could free/malloc */\n+        vec_wi = ev_realloc (vec_wi, new_max * NFDBYTES);\n+        vec_wo = ev_realloc (vec_wo, new_max * NFDBYTES); /* could free/malloc */\n+        #ifdef _WIN32\n+        vec_eo = ev_realloc (vec_eo, new_max * NFDBYTES); /* could free/malloc */\n+        #endif\n+\n+        for (; vec_max < new_max; ++vec_max)\n+          ((fd_mask *)vec_ri) [vec_max] =\n+          ((fd_mask *)vec_wi) [vec_max] = 0;\n+      }\n+\n+    ((fd_mask *)vec_ri) [word] |= mask;\n+    if (!(nev & EV_READ))\n+      ((fd_mask *)vec_ri) [word] &= ~mask;\n+\n+    ((fd_mask *)vec_wi) [word] |= mask;\n+    if (!(nev & EV_WRITE))\n+      ((fd_mask *)vec_wi) [word] &= ~mask;\n+#endif\n+  }\n+}\n+\n+static void\n+select_poll (EV_P_ ev_tstamp timeout)\n+{\n+  struct timeval tv;\n+  int res;\n+  int fd_setsize;\n+\n+  EV_RELEASE_CB;\n+  EV_TV_SET (tv, timeout);\n+\n+#if EV_SELECT_USE_FD_SET\n+  fd_setsize = sizeof (fd_set);\n+#else\n+  fd_setsize = vec_max * NFDBYTES;\n+#endif\n+\n+  memcpy (vec_ro, vec_ri, fd_setsize);\n+  memcpy (vec_wo, vec_wi, fd_setsize);\n+\n+#ifdef _WIN32\n+  /* pass in the write set as except set.\n+   * the idea behind this is to work around a windows bug that causes\n+   * errors to be reported as an exception and not by setting\n+   * the writable bit. this is so uncontrollably lame.\n+   */\n+  memcpy (vec_eo, vec_wi, fd_setsize);\n+  res = select (vec_max * NFDBITS, (fd_set *)vec_ro, (fd_set *)vec_wo, (fd_set *)vec_eo, &tv);\n+#elif EV_SELECT_USE_FD_SET\n+  fd_setsize = anfdmax < FD_SETSIZE ? anfdmax : FD_SETSIZE;\n+  res = select (fd_setsize, (fd_set *)vec_ro, (fd_set *)vec_wo, 0, &tv);\n+#else\n+  res = select (vec_max * NFDBITS, (fd_set *)vec_ro, (fd_set *)vec_wo, 0, &tv);\n+#endif\n+  EV_ACQUIRE_CB;\n+\n+  if (expect_false (res < 0))\n+    {\n+      #if EV_SELECT_IS_WINSOCKET\n+      errno = WSAGetLastError ();\n+      #endif\n+      #ifdef WSABASEERR\n+      /* on windows, select returns incompatible error codes, fix this */\n+      if (errno >= WSABASEERR && errno < WSABASEERR + 1000)\n+        if (errno == WSAENOTSOCK)\n+          errno = EBADF;\n+        else\n+          errno -= WSABASEERR;\n+      #endif\n+\n+      #ifdef _WIN32\n+      /* select on windows erroneously returns EINVAL when no fd sets have been\n+       * provided (this is documented). what microsoft doesn't tell you that this bug\n+       * exists even when the fd sets _are_ provided, so we have to check for this bug\n+       * here and emulate by sleeping manually.\n+       * we also get EINVAL when the timeout is invalid, but we ignore this case here\n+       * and assume that EINVAL always means: you have to wait manually.\n+       */\n+      if (errno == EINVAL)\n+        {\n+          ev_sleep (timeout);\n+          return;\n+        }\n+      #endif\n+\n+      if (errno == EBADF)\n+        fd_ebadf (EV_A);\n+      else if (errno == ENOMEM && !syserr_cb)\n+        fd_enomem (EV_A);\n+      else if (errno != EINTR)\n+        ev_syserr (\"(libev) select\");\n+\n+      return;\n+    }\n+\n+#if EV_SELECT_USE_FD_SET\n+\n+  {\n+    int fd;\n+\n+    for (fd = 0; fd < anfdmax; ++fd)\n+      if (anfds [fd].events)\n+        {\n+          int events = 0;\n+          #if EV_SELECT_IS_WINSOCKET\n+          SOCKET handle = anfds [fd].handle;\n+          #else\n+          int handle = fd;\n+          #endif\n+\n+          if (FD_ISSET (handle, (fd_set *)vec_ro)) events |= EV_READ;\n+          if (FD_ISSET (handle, (fd_set *)vec_wo)) events |= EV_WRITE;\n+          #ifdef _WIN32\n+          if (FD_ISSET (handle, (fd_set *)vec_eo)) events |= EV_WRITE;\n+          #endif\n+\n+          if (expect_true (events))\n+            fd_event (EV_A_ fd, events);\n+        }\n+  }\n+\n+#else\n+\n+  {\n+    int word, bit;\n+    for (word = vec_max; word--; )\n+      {\n+        fd_mask word_r = ((fd_mask *)vec_ro) [word];\n+        fd_mask word_w = ((fd_mask *)vec_wo) [word];\n+        #ifdef _WIN32\n+        word_w |= ((fd_mask *)vec_eo) [word];\n+        #endif\n+\n+        if (word_r || word_w)\n+          for (bit = NFDBITS; bit--; )\n+            {\n+              fd_mask mask = 1UL << bit;\n+              int events = 0;\n+\n+              events |= word_r & mask ? EV_READ  : 0;\n+              events |= word_w & mask ? EV_WRITE : 0;\n+\n+              if (expect_true (events))\n+                fd_event (EV_A_ word * NFDBITS + bit, events);\n+            }\n+      }\n+  }\n+\n+#endif\n+}\n+\n+int inline_size\n+select_init (EV_P_ int flags)\n+{\n+  backend_fudge  = 0.; /* posix says this is zero */\n+  backend_modify = select_modify;\n+  backend_poll   = select_poll;\n+\n+#if EV_SELECT_USE_FD_SET\n+  vec_ri  = ev_malloc (sizeof (fd_set)); FD_ZERO ((fd_set *)vec_ri);\n+  vec_ro  = ev_malloc (sizeof (fd_set));\n+  vec_wi  = ev_malloc (sizeof (fd_set)); FD_ZERO ((fd_set *)vec_wi);\n+  vec_wo  = ev_malloc (sizeof (fd_set));\n+  #ifdef _WIN32\n+  vec_eo  = ev_malloc (sizeof (fd_set));\n+  #endif\n+#else\n+  vec_max = 0;\n+  vec_ri  = 0;\n+  vec_ro  = 0;\n+  vec_wi  = 0;\n+  vec_wo  = 0;\n+  #ifdef _WIN32\n+  vec_eo  = 0;\n+  #endif\n+#endif\n+\n+  return EVBACKEND_SELECT;\n+}\n+\n+void inline_size\n+select_destroy (EV_P)\n+{\n+  ev_free (vec_ri);\n+  ev_free (vec_ro);\n+  ev_free (vec_wi);\n+  ev_free (vec_wo);\n+  #ifdef _WIN32\n+  ev_free (vec_eo);\n+  #endif\n+}\n+\n+"}, {"sha": "5ee3ed1b2a0eb2368cce927ba8af84bf37d8898f", "filename": "src/rt/libuv/ev/ev_vars.h", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_vars.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_vars.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_vars.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,203 @@\n+/*\n+ * loop member variable declarations\n+ *\n+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#define VARx(type,name) VAR(name, type name)\n+\n+VARx(ev_tstamp, now_floor) /* last time we refreshed rt_time */\n+VARx(ev_tstamp, mn_now)    /* monotonic clock \"now\" */\n+VARx(ev_tstamp, rtmn_diff) /* difference realtime - monotonic time */\n+\n+VARx(ev_tstamp, io_blocktime)\n+VARx(ev_tstamp, timeout_blocktime)\n+\n+VARx(int, backend)\n+VARx(int, activecnt) /* total number of active events (\"refcount\") */\n+VARx(EV_ATOMIC_T, loop_done)  /* signal by ev_break */\n+\n+VARx(int, backend_fd)\n+VARx(ev_tstamp, backend_fudge) /* assumed typical timer resolution */\n+VAR (backend_modify, void (*backend_modify)(EV_P_ int fd, int oev, int nev))\n+VAR (backend_poll  , void (*backend_poll)(EV_P_ ev_tstamp timeout))\n+\n+VARx(ANFD *, anfds)\n+VARx(int, anfdmax)\n+\n+VAR (pendings, ANPENDING *pendings [NUMPRI])\n+VAR (pendingmax, int pendingmax [NUMPRI])\n+VAR (pendingcnt, int pendingcnt [NUMPRI])\n+VARx(ev_prepare, pending_w) /* dummy pending watcher */\n+\n+/* for reverse feeding of events */\n+VARx(W *, rfeeds)\n+VARx(int, rfeedmax)\n+VARx(int, rfeedcnt)\n+\n+#if EV_USE_EVENTFD || EV_GENWRAP\n+VARx(int, evfd)\n+#endif\n+VAR (evpipe, int evpipe [2])\n+VARx(ev_io, pipe_w)\n+\n+#if !defined(_WIN32) || EV_GENWRAP\n+VARx(pid_t, curpid)\n+#endif\n+\n+VARx(char, postfork)  /* true if we need to recreate kernel state after fork */\n+\n+#if EV_USE_SELECT || EV_GENWRAP\n+VARx(void *, vec_ri)\n+VARx(void *, vec_ro)\n+VARx(void *, vec_wi)\n+VARx(void *, vec_wo)\n+#if defined(_WIN32) || EV_GENWRAP\n+VARx(void *, vec_eo)\n+#endif\n+VARx(int, vec_max)\n+#endif\n+\n+#if EV_USE_POLL || EV_GENWRAP\n+VARx(struct pollfd *, polls)\n+VARx(int, pollmax)\n+VARx(int, pollcnt)\n+VARx(int *, pollidxs) /* maps fds into structure indices */\n+VARx(int, pollidxmax)\n+#endif\n+\n+#if EV_USE_EPOLL || EV_GENWRAP\n+VARx(struct epoll_event *, epoll_events)\n+VARx(int, epoll_eventmax)\n+VARx(int *, epoll_eperms)\n+VARx(int, epoll_epermcnt)\n+VARx(int, epoll_epermmax)\n+#endif\n+\n+#if EV_USE_KQUEUE || EV_GENWRAP\n+VARx(struct kevent *, kqueue_changes)\n+VARx(int, kqueue_changemax)\n+VARx(int, kqueue_changecnt)\n+VARx(struct kevent *, kqueue_events)\n+VARx(int, kqueue_eventmax)\n+#endif\n+\n+#if EV_USE_PORT || EV_GENWRAP\n+VARx(struct port_event *, port_events)\n+VARx(int, port_eventmax)\n+#endif\n+\n+#if EV_USE_IOCP || EV_GENWRAP\n+VARx(HANDLE, iocp)\n+#endif\n+\n+VARx(int *, fdchanges)\n+VARx(int, fdchangemax)\n+VARx(int, fdchangecnt)\n+\n+VARx(ANHE *, timers)\n+VARx(int, timermax)\n+VARx(int, timercnt)\n+\n+#if EV_PERIODIC_ENABLE || EV_GENWRAP\n+VARx(ANHE *, periodics)\n+VARx(int, periodicmax)\n+VARx(int, periodiccnt)\n+#endif\n+\n+#if EV_IDLE_ENABLE || EV_GENWRAP\n+VAR (idles, ev_idle **idles [NUMPRI])\n+VAR (idlemax, int idlemax [NUMPRI])\n+VAR (idlecnt, int idlecnt [NUMPRI])\n+#endif\n+VARx(int, idleall) /* total number */\n+\n+VARx(struct ev_prepare **, prepares)\n+VARx(int, preparemax)\n+VARx(int, preparecnt)\n+\n+VARx(struct ev_check **, checks)\n+VARx(int, checkmax)\n+VARx(int, checkcnt)\n+\n+#if EV_FORK_ENABLE || EV_GENWRAP\n+VARx(struct ev_fork **, forks)\n+VARx(int, forkmax)\n+VARx(int, forkcnt)\n+#endif\n+\n+#if EV_CLEANUP_ENABLE || EV_GENWRAP\n+VARx(struct ev_cleanup **, cleanups)\n+VARx(int, cleanupmax)\n+VARx(int, cleanupcnt)\n+#endif\n+\n+#if EV_ASYNC_ENABLE || EV_GENWRAP\n+VARx(EV_ATOMIC_T, async_pending)\n+VARx(struct ev_async **, asyncs)\n+VARx(int, asyncmax)\n+VARx(int, asynccnt)\n+#endif\n+\n+#if EV_USE_INOTIFY || EV_GENWRAP\n+VARx(int, fs_fd)\n+VARx(ev_io, fs_w)\n+VARx(char, fs_2625) /* whether we are running in linux 2.6.25 or newer */\n+VAR (fs_hash, ANFS fs_hash [EV_INOTIFY_HASHSIZE])\n+#endif\n+\n+VARx(EV_ATOMIC_T, sig_pending)\n+VARx(int, nosigmask)\n+#if EV_USE_SIGNALFD || EV_GENWRAP\n+VARx(int, sigfd)\n+VARx(ev_io, sigfd_w)\n+VARx(sigset_t, sigfd_set)\n+#endif\n+\n+VARx(unsigned int, origflags) /* original loop flags */\n+\n+#if EV_FEATURE_API || EV_GENWRAP\n+VARx(unsigned int, loop_count) /* total number of loop iterations/blocks */\n+VARx(unsigned int, loop_depth) /* #ev_run enters - #ev_run leaves */\n+\n+VARx(void *, userdata)\n+VAR (release_cb, void (*release_cb)(EV_P))\n+VAR (acquire_cb, void (*acquire_cb)(EV_P))\n+VAR (invoke_cb , void (*invoke_cb) (EV_P))\n+#endif\n+\n+#undef VARx\n+"}, {"sha": "338886efe407cfba00e33a1e425cc90d4d760a0c", "filename": "src/rt/libuv/ev/ev_win32.c", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_win32.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_win32.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_win32.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,153 @@\n+/*\n+ * libev win32 compatibility cruft (_not_ a backend)\n+ *\n+ * Copyright (c) 2007,2008,2009 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#ifdef _WIN32\n+\n+/* timeb.h is actually xsi legacy functionality */\n+#include <sys/timeb.h>\n+\n+/* note: the comment below could not be substantiated, but what would I care */\n+/* MSDN says this is required to handle SIGFPE */\n+/* my wild guess would be that using something floating-pointy is required */\n+/* for the crt to do something about it */\n+volatile double SIGFPE_REQ = 0.0f;\n+\n+/* oh, the humanity! */\n+static int\n+ev_pipe (int filedes [2])\n+{\n+  struct sockaddr_in addr = { 0 };\n+  int addr_size = sizeof (addr);\n+  struct sockaddr_in adr2;\n+  int adr2_size = sizeof (adr2);\n+  SOCKET listener;\n+  SOCKET sock [2] = { -1, -1 };\n+\n+  if ((listener = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)\n+    return -1;\n+\n+  addr.sin_family = AF_INET;\n+  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);\n+  addr.sin_port = 0;\n+\n+  if (bind (listener, (struct sockaddr *)&addr, addr_size))\n+    goto fail;\n+\n+  if (getsockname (listener, (struct sockaddr *)&addr, &addr_size))\n+    goto fail;\n+\n+  if (listen (listener, 1))\n+    goto fail;\n+\n+  if ((sock [0] = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)\n+    goto fail;\n+\n+  if (connect (sock [0], (struct sockaddr *)&addr, addr_size))\n+    goto fail;\n+\n+  if ((sock [1] = accept (listener, 0, 0)) < 0)\n+    goto fail;\n+\n+  /* windows vista returns fantasy port numbers for sockets:\n+   * example for two interconnected tcp sockets:\n+   *\n+   * (Socket::unpack_sockaddr_in getsockname $sock0)[0] == 53364\n+   * (Socket::unpack_sockaddr_in getpeername $sock0)[0] == 53363\n+   * (Socket::unpack_sockaddr_in getsockname $sock1)[0] == 53363\n+   * (Socket::unpack_sockaddr_in getpeername $sock1)[0] == 53365\n+   *\n+   * wow! tridirectional sockets!\n+   *\n+   * this way of checking ports seems to work:\n+   */\n+  if (getpeername (sock [0], (struct sockaddr *)&addr, &addr_size))\n+    goto fail;\n+\n+  if (getsockname (sock [1], (struct sockaddr *)&adr2, &adr2_size))\n+    goto fail;\n+\n+  errno = WSAEINVAL;\n+  if (addr_size != adr2_size\n+      || addr.sin_addr.s_addr != adr2.sin_addr.s_addr /* just to be sure, I mean, it's windows */\n+      || addr.sin_port        != adr2.sin_port)\n+    goto fail;\n+\n+  closesocket (listener);\n+\n+#if EV_SELECT_IS_WINSOCKET\n+  filedes [0] = EV_WIN32_HANDLE_TO_FD (sock [0]);\n+  filedes [1] = EV_WIN32_HANDLE_TO_FD (sock [1]);\n+#else\n+  /* when select isn't winsocket, we also expect socket, connect, accept etc.\n+   * to work on fds */\n+  filedes [0] = sock [0];\n+  filedes [1] = sock [1];\n+#endif\n+\n+  return 0;\n+\n+fail:\n+  closesocket (listener);\n+\n+  if (sock [0] != INVALID_SOCKET) closesocket (sock [0]);\n+  if (sock [1] != INVALID_SOCKET) closesocket (sock [1]);\n+\n+  return -1;\n+}\n+\n+#undef pipe\n+#define pipe(filedes) ev_pipe (filedes)\n+  \n+#define EV_HAVE_EV_TIME 1\n+ev_tstamp\n+ev_time (void)\n+{\n+  FILETIME ft;\n+  ULARGE_INTEGER ui;\n+\n+  GetSystemTimeAsFileTime (&ft);\n+  ui.u.LowPart  = ft.dwLowDateTime;\n+  ui.u.HighPart = ft.dwHighDateTime;\n+\n+  /* msvc cannot convert ulonglong to double... yes, it is that sucky */\n+  return (LONGLONG)(ui.QuadPart - 116444736000000000) * 1e-7;\n+}\n+\n+#endif\n+"}, {"sha": "2c195c5db4b2f8e65de6e55603b9752f3729b24b", "filename": "src/rt/libuv/ev/ev_wrap.h", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_wrap.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fev_wrap.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fev_wrap.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,196 @@\n+/* DO NOT EDIT, automatically generated by update_ev_wrap */\n+#ifndef EV_WRAP_H\n+#define EV_WRAP_H\n+#define now_floor ((loop)->now_floor)\n+#define mn_now ((loop)->mn_now)\n+#define rtmn_diff ((loop)->rtmn_diff)\n+#define io_blocktime ((loop)->io_blocktime)\n+#define timeout_blocktime ((loop)->timeout_blocktime)\n+#define backend ((loop)->backend)\n+#define activecnt ((loop)->activecnt)\n+#define loop_done ((loop)->loop_done)\n+#define backend_fd ((loop)->backend_fd)\n+#define backend_fudge ((loop)->backend_fudge)\n+#define backend_modify ((loop)->backend_modify)\n+#define backend_poll ((loop)->backend_poll)\n+#define anfds ((loop)->anfds)\n+#define anfdmax ((loop)->anfdmax)\n+#define pendings ((loop)->pendings)\n+#define pendingmax ((loop)->pendingmax)\n+#define pendingcnt ((loop)->pendingcnt)\n+#define pending_w ((loop)->pending_w)\n+#define rfeeds ((loop)->rfeeds)\n+#define rfeedmax ((loop)->rfeedmax)\n+#define rfeedcnt ((loop)->rfeedcnt)\n+#define evfd ((loop)->evfd)\n+#define evpipe ((loop)->evpipe)\n+#define pipe_w ((loop)->pipe_w)\n+#define curpid ((loop)->curpid)\n+#define postfork ((loop)->postfork)\n+#define vec_ri ((loop)->vec_ri)\n+#define vec_ro ((loop)->vec_ro)\n+#define vec_wi ((loop)->vec_wi)\n+#define vec_wo ((loop)->vec_wo)\n+#define vec_eo ((loop)->vec_eo)\n+#define vec_max ((loop)->vec_max)\n+#define polls ((loop)->polls)\n+#define pollmax ((loop)->pollmax)\n+#define pollcnt ((loop)->pollcnt)\n+#define pollidxs ((loop)->pollidxs)\n+#define pollidxmax ((loop)->pollidxmax)\n+#define epoll_events ((loop)->epoll_events)\n+#define epoll_eventmax ((loop)->epoll_eventmax)\n+#define epoll_eperms ((loop)->epoll_eperms)\n+#define epoll_epermcnt ((loop)->epoll_epermcnt)\n+#define epoll_epermmax ((loop)->epoll_epermmax)\n+#define kqueue_changes ((loop)->kqueue_changes)\n+#define kqueue_changemax ((loop)->kqueue_changemax)\n+#define kqueue_changecnt ((loop)->kqueue_changecnt)\n+#define kqueue_events ((loop)->kqueue_events)\n+#define kqueue_eventmax ((loop)->kqueue_eventmax)\n+#define port_events ((loop)->port_events)\n+#define port_eventmax ((loop)->port_eventmax)\n+#define iocp ((loop)->iocp)\n+#define fdchanges ((loop)->fdchanges)\n+#define fdchangemax ((loop)->fdchangemax)\n+#define fdchangecnt ((loop)->fdchangecnt)\n+#define timers ((loop)->timers)\n+#define timermax ((loop)->timermax)\n+#define timercnt ((loop)->timercnt)\n+#define periodics ((loop)->periodics)\n+#define periodicmax ((loop)->periodicmax)\n+#define periodiccnt ((loop)->periodiccnt)\n+#define idles ((loop)->idles)\n+#define idlemax ((loop)->idlemax)\n+#define idlecnt ((loop)->idlecnt)\n+#define idleall ((loop)->idleall)\n+#define prepares ((loop)->prepares)\n+#define preparemax ((loop)->preparemax)\n+#define preparecnt ((loop)->preparecnt)\n+#define checks ((loop)->checks)\n+#define checkmax ((loop)->checkmax)\n+#define checkcnt ((loop)->checkcnt)\n+#define forks ((loop)->forks)\n+#define forkmax ((loop)->forkmax)\n+#define forkcnt ((loop)->forkcnt)\n+#define cleanups ((loop)->cleanups)\n+#define cleanupmax ((loop)->cleanupmax)\n+#define cleanupcnt ((loop)->cleanupcnt)\n+#define async_pending ((loop)->async_pending)\n+#define asyncs ((loop)->asyncs)\n+#define asyncmax ((loop)->asyncmax)\n+#define asynccnt ((loop)->asynccnt)\n+#define fs_fd ((loop)->fs_fd)\n+#define fs_w ((loop)->fs_w)\n+#define fs_2625 ((loop)->fs_2625)\n+#define fs_hash ((loop)->fs_hash)\n+#define sig_pending ((loop)->sig_pending)\n+#define nosigmask ((loop)->nosigmask)\n+#define sigfd ((loop)->sigfd)\n+#define sigfd_w ((loop)->sigfd_w)\n+#define sigfd_set ((loop)->sigfd_set)\n+#define origflags ((loop)->origflags)\n+#define loop_count ((loop)->loop_count)\n+#define loop_depth ((loop)->loop_depth)\n+#define userdata ((loop)->userdata)\n+#define release_cb ((loop)->release_cb)\n+#define acquire_cb ((loop)->acquire_cb)\n+#define invoke_cb ((loop)->invoke_cb)\n+#else\n+#undef EV_WRAP_H\n+#undef now_floor\n+#undef mn_now\n+#undef rtmn_diff\n+#undef io_blocktime\n+#undef timeout_blocktime\n+#undef backend\n+#undef activecnt\n+#undef loop_done\n+#undef backend_fd\n+#undef backend_fudge\n+#undef backend_modify\n+#undef backend_poll\n+#undef anfds\n+#undef anfdmax\n+#undef pendings\n+#undef pendingmax\n+#undef pendingcnt\n+#undef pending_w\n+#undef rfeeds\n+#undef rfeedmax\n+#undef rfeedcnt\n+#undef evfd\n+#undef evpipe\n+#undef pipe_w\n+#undef curpid\n+#undef postfork\n+#undef vec_ri\n+#undef vec_ro\n+#undef vec_wi\n+#undef vec_wo\n+#undef vec_eo\n+#undef vec_max\n+#undef polls\n+#undef pollmax\n+#undef pollcnt\n+#undef pollidxs\n+#undef pollidxmax\n+#undef epoll_events\n+#undef epoll_eventmax\n+#undef epoll_eperms\n+#undef epoll_epermcnt\n+#undef epoll_epermmax\n+#undef kqueue_changes\n+#undef kqueue_changemax\n+#undef kqueue_changecnt\n+#undef kqueue_events\n+#undef kqueue_eventmax\n+#undef port_events\n+#undef port_eventmax\n+#undef iocp\n+#undef fdchanges\n+#undef fdchangemax\n+#undef fdchangecnt\n+#undef timers\n+#undef timermax\n+#undef timercnt\n+#undef periodics\n+#undef periodicmax\n+#undef periodiccnt\n+#undef idles\n+#undef idlemax\n+#undef idlecnt\n+#undef idleall\n+#undef prepares\n+#undef preparemax\n+#undef preparecnt\n+#undef checks\n+#undef checkmax\n+#undef checkcnt\n+#undef forks\n+#undef forkmax\n+#undef forkcnt\n+#undef cleanups\n+#undef cleanupmax\n+#undef cleanupcnt\n+#undef async_pending\n+#undef asyncs\n+#undef asyncmax\n+#undef asynccnt\n+#undef fs_fd\n+#undef fs_w\n+#undef fs_2625\n+#undef fs_hash\n+#undef sig_pending\n+#undef nosigmask\n+#undef sigfd\n+#undef sigfd_w\n+#undef sigfd_set\n+#undef origflags\n+#undef loop_count\n+#undef loop_depth\n+#undef userdata\n+#undef release_cb\n+#undef acquire_cb\n+#undef invoke_cb\n+#endif"}, {"sha": "aaf6d534ca45f8c2c7041e3329bbda88a1d08ad6", "filename": "src/rt/libuv/ev/event.c", "status": "added", "additions": 402, "deletions": 0, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fevent.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fevent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fevent.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,402 @@\n+/*\n+ * libevent compatibility layer\n+ *\n+ * Copyright (c) 2007,2008,2009,2010 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#ifdef EV_EVENT_H\n+# include EV_EVENT_H\n+#else\n+# include \"event.h\"\n+#endif\n+\n+#if EV_MULTIPLICITY\n+# define dLOOPev struct ev_loop *loop = (struct ev_loop *)ev->ev_base\n+# define dLOOPbase struct ev_loop *loop = (struct ev_loop *)base\n+#else\n+# define dLOOPev\n+# define dLOOPbase\n+#endif\n+\n+/* never accessed, will always be cast from/to ev_loop */\n+struct event_base\n+{\n+  int dummy;\n+};\n+\n+static struct event_base *ev_x_cur;\n+\n+static ev_tstamp\n+ev_tv_get (struct timeval *tv)\n+{\n+  if (tv)\n+    {\n+      ev_tstamp after = tv->tv_sec + tv->tv_usec * 1e-6;\n+      return after ? after : 1e-6;\n+    }\n+  else\n+    return -1.;\n+}\n+\n+#define EVENT_STRINGIFY(s) # s\n+#define EVENT_VERSION(a,b) EVENT_STRINGIFY (a) \".\" EVENT_STRINGIFY (b)\n+\n+const char *event_get_version (void)\n+{\n+  /* returns ABI, not API or library, version */\n+  return EVENT_VERSION (EV_VERSION_MAJOR, EV_VERSION_MINOR);\n+}\n+\n+const char *event_get_method (void)\n+{\n+  return \"libev\";\n+}\n+\n+void *event_init (void)\n+{\n+#if EV_MULTIPLICITY\n+  if (ev_x_cur)\n+    ev_x_cur = (struct event_base *)ev_loop_new (EVFLAG_AUTO);\n+  else\n+    ev_x_cur = (struct event_base *)ev_default_loop (EVFLAG_AUTO);\n+#else\n+  assert ((\"libev: multiple event bases not supported when not compiled with EV_MULTIPLICITY\", !ev_x_cur));\n+\n+  ev_x_cur = (struct event_base *)(long)ev_default_loop (EVFLAG_AUTO);\n+#endif\n+\n+  return ev_x_cur;\n+}\n+\n+void event_base_free (struct event_base *base)\n+{\n+  dLOOPbase;\n+\n+#if EV_MULTIPLICITY\n+  if (!ev_is_default_loop (loop))\n+    ev_loop_destroy (loop);\n+#endif\n+}\n+\n+int event_dispatch (void)\n+{\n+  return event_base_dispatch (ev_x_cur);\n+}\n+\n+#ifdef EV_STANDALONE\n+void event_set_log_callback (event_log_cb cb)\n+{\n+  /* nop */\n+}\n+#endif\n+\n+int event_loop (int flags)\n+{\n+  return event_base_loop (ev_x_cur, flags);\n+}\n+\n+int event_loopexit (struct timeval *tv)\n+{\n+  return event_base_loopexit (ev_x_cur, tv);\n+}\n+\n+static void\n+ev_x_cb (struct event *ev, int revents)\n+{\n+  revents &= EV_READ | EV_WRITE | EV_TIMER | EV_SIGNAL;\n+\n+  ev->ev_res = revents;\n+  ev->ev_callback (ev->ev_fd, (short)revents, ev->ev_arg);\n+}\n+\n+static void\n+ev_x_cb_sig (EV_P_ struct ev_signal *w, int revents)\n+{\n+  struct event *ev = (struct event *)(((char *)w) - offsetof (struct event, iosig.sig));\n+\n+  if (revents & EV_ERROR)\n+    event_del (ev);\n+\n+  ev_x_cb (ev, revents);\n+}\n+\n+static void\n+ev_x_cb_io (EV_P_ struct ev_io *w, int revents)\n+{\n+  struct event *ev = (struct event *)(((char *)w) - offsetof (struct event, iosig.io));\n+\n+  if ((revents & EV_ERROR) || !(ev->ev_events & EV_PERSIST))\n+    event_del (ev);\n+\n+  ev_x_cb (ev, revents);\n+}\n+\n+static void\n+ev_x_cb_to (EV_P_ struct ev_timer *w, int revents)\n+{\n+  struct event *ev = (struct event *)(((char *)w) - offsetof (struct event, to));\n+\n+  event_del (ev);\n+\n+  ev_x_cb (ev, revents);\n+}\n+\n+void event_set (struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg)\n+{\n+  if (events & EV_SIGNAL)\n+    ev_init (&ev->iosig.sig, ev_x_cb_sig);\n+  else\n+    ev_init (&ev->iosig.io, ev_x_cb_io);\n+\n+  ev_init (&ev->to, ev_x_cb_to);\n+\n+  ev->ev_base     = ev_x_cur; /* not threadsafe, but it's how libevent works */\n+  ev->ev_fd       = fd;\n+  ev->ev_events   = events;\n+  ev->ev_pri      = 0;\n+  ev->ev_callback = cb;\n+  ev->ev_arg      = arg;\n+  ev->ev_res      = 0;\n+  ev->ev_flags    = EVLIST_INIT;\n+}\n+\n+int event_once (int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)\n+{\n+  return event_base_once (ev_x_cur, fd, events, cb, arg, tv);\n+}\n+\n+int event_add (struct event *ev, struct timeval *tv)\n+{\n+  dLOOPev;\n+\n+  if (ev->ev_events & EV_SIGNAL)\n+    {\n+      if (!ev_is_active (&ev->iosig.sig))\n+        {\n+          ev_signal_set (&ev->iosig.sig, ev->ev_fd);\n+          ev_signal_start (EV_A_ &ev->iosig.sig);\n+\n+          ev->ev_flags |= EVLIST_SIGNAL;\n+        }\n+    }\n+  else if (ev->ev_events & (EV_READ | EV_WRITE))\n+    {\n+      if (!ev_is_active (&ev->iosig.io))\n+        {\n+          ev_io_set (&ev->iosig.io, ev->ev_fd, ev->ev_events & (EV_READ | EV_WRITE));\n+          ev_io_start (EV_A_ &ev->iosig.io);\n+\n+          ev->ev_flags |= EVLIST_INSERTED;\n+        }\n+    }\n+\n+  if (tv)\n+    {\n+      ev->to.repeat = ev_tv_get (tv);\n+      ev_timer_again (EV_A_ &ev->to);\n+      ev->ev_flags |= EVLIST_TIMEOUT;\n+    }\n+  else\n+    {\n+      ev_timer_stop (EV_A_ &ev->to);\n+      ev->ev_flags &= ~EVLIST_TIMEOUT;\n+    }\n+\n+  ev->ev_flags |= EVLIST_ACTIVE;\n+\n+  return 0;\n+}\n+\n+int event_del (struct event *ev)\n+{\n+  dLOOPev;\n+\n+  if (ev->ev_events & EV_SIGNAL)\n+    ev_signal_stop (EV_A_ &ev->iosig.sig);\n+  else if (ev->ev_events & (EV_READ | EV_WRITE))\n+    ev_io_stop (EV_A_ &ev->iosig.io);\n+\n+  if (ev_is_active (&ev->to))\n+    ev_timer_stop (EV_A_ &ev->to);\n+\n+  ev->ev_flags = EVLIST_INIT;\n+\n+  return 0;\n+}\n+\n+void event_active (struct event *ev, int res, short ncalls)\n+{\n+  dLOOPev;\n+\n+  if (res & EV_TIMEOUT)\n+    ev_feed_event (EV_A_ &ev->to, res & EV_TIMEOUT);\n+\n+  if (res & EV_SIGNAL)\n+    ev_feed_event (EV_A_ &ev->iosig.sig, res & EV_SIGNAL);\n+\n+  if (res & (EV_READ | EV_WRITE))\n+    ev_feed_event (EV_A_ &ev->iosig.io, res & (EV_READ | EV_WRITE));\n+}\n+\n+int event_pending (struct event *ev, short events, struct timeval *tv)\n+{\n+  short revents = 0;\n+  dLOOPev;\n+\n+  if (ev->ev_events & EV_SIGNAL)\n+    {\n+      /* sig */\n+      if (ev_is_active (&ev->iosig.sig) || ev_is_pending (&ev->iosig.sig))\n+        revents |= EV_SIGNAL;\n+    }\n+  else if (ev->ev_events & (EV_READ | EV_WRITE))\n+    {\n+      /* io */\n+      if (ev_is_active (&ev->iosig.io) || ev_is_pending (&ev->iosig.io))\n+        revents |= ev->ev_events & (EV_READ | EV_WRITE);\n+    }\n+\n+  if (ev->ev_events & EV_TIMEOUT || ev_is_active (&ev->to) || ev_is_pending (&ev->to))\n+    {\n+      revents |= EV_TIMEOUT;\n+\n+      if (tv)\n+        {\n+          ev_tstamp at = ev_now (EV_A);\n+\n+          tv->tv_sec  = (long)at;\n+          tv->tv_usec = (long)((at - (ev_tstamp)tv->tv_sec) * 1e6);\n+        }\n+    }\n+\n+  return events & revents;\n+}\n+\n+int event_priority_init (int npri)\n+{\n+  return event_base_priority_init (ev_x_cur, npri);\n+}\n+\n+int event_priority_set (struct event *ev, int pri)\n+{\n+  ev->ev_pri = pri;\n+\n+  return 0;\n+}\n+\n+int event_base_set (struct event_base *base, struct event *ev)\n+{\n+  ev->ev_base = base;\n+\n+  return 0;\n+}\n+\n+int event_base_loop (struct event_base *base, int flags)\n+{\n+  dLOOPbase;\n+\n+  ev_run (EV_A_ flags);\n+\n+  return 0;\n+}\n+\n+int event_base_dispatch (struct event_base *base)\n+{\n+  return event_base_loop (base, 0);\n+}\n+\n+static void\n+ev_x_loopexit_cb (int revents, void *base)\n+{\n+  dLOOPbase;\n+\n+  ev_break (EV_A_ EVBREAK_ONE);\n+}\n+\n+int event_base_loopexit (struct event_base *base, struct timeval *tv)\n+{\n+  ev_tstamp after = ev_tv_get (tv);\n+  dLOOPbase;\n+\n+  ev_once (EV_A_ -1, 0, after >= 0. ? after : 0., ev_x_loopexit_cb, (void *)base);\n+\n+  return 0;\n+}\n+\n+struct ev_x_once\n+{\n+  int fd;\n+  void (*cb)(int, short, void *);\n+  void *arg;\n+};\n+\n+static void\n+ev_x_once_cb (int revents, void *arg)\n+{\n+  struct ev_x_once *once = (struct ev_x_once *)arg;\n+\n+  once->cb (once->fd, (short)revents, once->arg);\n+  free (once);\n+}\n+\n+int event_base_once (struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)\n+{\n+  struct ev_x_once *once = (struct ev_x_once *)malloc (sizeof (struct ev_x_once));\n+  dLOOPbase;\n+\n+  if (!once)\n+    return -1;\n+\n+  once->fd  = fd;\n+  once->cb  = cb;\n+  once->arg = arg;\n+\n+  ev_once (EV_A_ fd, events & (EV_READ | EV_WRITE), ev_tv_get (tv), ev_x_once_cb, (void *)once);\n+\n+  return 0;\n+}\n+\n+int event_base_priority_init (struct event_base *base, int npri)\n+{\n+  /*dLOOPbase;*/\n+\n+  return 0;\n+}\n+"}, {"sha": "10ff05a3cb4d64a397bb3aada943f2836858161a", "filename": "src/rt/libuv/ev/event.h", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fevent.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fevent.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fevent.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,170 @@\n+/*\n+ * libevent compatibility header, only core events supported\n+ *\n+ * Copyright (c) 2007,2008,2010 Marc Alexander Lehmann <libev@schmorp.de>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modifica-\n+ * tion, are permitted provided that the following conditions are met:\n+ *\n+ *   1.  Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *   2.  Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License (\"GPL\") version 2 or any later version,\n+ * in which case the provisions of the GPL are applicable instead of\n+ * the above. If you wish to allow the use of your version of this file\n+ * only under the terms of the GPL and not to allow others to use your\n+ * version of this file under the BSD license, indicate your decision\n+ * by deleting the provisions above and replace them with the notice\n+ * and other provisions required by the GPL. If you do not delete the\n+ * provisions above, a recipient may use your version of this file under\n+ * either the BSD or the GPL.\n+ */\n+\n+#ifndef EVENT_H_\n+#define EVENT_H_\n+\n+#ifdef EV_H\n+# include EV_H\n+#else\n+# include \"ev.h\"\n+#endif\n+\n+#ifndef EVLOOP_NONBLOCK\n+# define EVLOOP_NONBLOCK EVRUN_NOWAIT\n+#endif\n+#ifndef EVLOOP_ONESHOT\n+# define EVLOOP_ONESHOT EVRUN_ONCE\n+#endif\n+#ifndef EV_TIMEOUT\n+# define EV_TIMEOUT EV_TIMER\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* we need sys/time.h for struct timeval only */\n+#if !defined (WIN32) || defined (__MINGW32__)\n+# include <time.h> /* mingw seems to need this, for whatever reason */\n+# include <sys/time.h>\n+#endif\n+\n+struct event_base;\n+\n+#define EVLIST_TIMEOUT  0x01\n+#define EVLIST_INSERTED 0x02\n+#define EVLIST_SIGNAL   0x04\n+#define EVLIST_ACTIVE   0x08\n+#define EVLIST_INTERNAL 0x10\n+#define EVLIST_INIT     0x80\n+\n+struct event\n+{\n+  /* libev watchers we map onto */\n+  union {\n+    struct ev_io io;\n+    struct ev_signal sig;\n+  } iosig;\n+  struct ev_timer to;\n+\n+  /* compatibility slots */\n+  struct event_base *ev_base;\n+  void (*ev_callback)(int, short, void *arg);\n+  void *ev_arg;\n+  int ev_fd;\n+  int ev_pri;\n+  int ev_res;\n+  int ev_flags;\n+  short ev_events;\n+};\n+\n+#define EV_READ                    EV_READ\n+#define EV_WRITE                   EV_WRITE\n+#define EV_PERSIST                 0x10\n+\n+#define EVENT_SIGNAL(ev)           ((int) (ev)->ev_fd)\n+#define EVENT_FD(ev)               ((int) (ev)->ev_fd)\n+\n+#define event_initialized(ev)      ((ev)->ev_flags & EVLIST_INIT)\n+\n+#define evtimer_add(ev,tv)         event_add (ev, tv)\n+#define evtimer_set(ev,cb,data)    event_set (ev, -1, 0, cb, data)\n+#define evtimer_del(ev)            event_del (ev)\n+#define evtimer_pending(ev,tv)     event_pending (ev, EV_TIMEOUT, tv)\n+#define evtimer_initialized(ev)    event_initialized (ev)\n+\n+#define timeout_add(ev,tv)         evtimer_add (ev, tv)\n+#define timeout_set(ev,cb,data)    evtimer_set (ev, cb, data)\n+#define timeout_del(ev)            evtimer_del (ev)\n+#define timeout_pending(ev,tv)     evtimer_pending (ev, tv)\n+#define timeout_initialized(ev)    evtimer_initialized (ev)\n+\n+#define signal_add(ev,tv)          event_add (ev, tv)\n+#define signal_set(ev,sig,cb,data) event_set (ev, sig, EV_SIGNAL | EV_PERSIST, cb, data)\n+#define signal_del(ev)             event_del (ev)\n+#define signal_pending(ev,tv)      event_pending (ev, EV_SIGNAL, tv)\n+#define signal_initialized(ev)     event_initialized (ev)\n+\n+const char *event_get_version (void);\n+const char *event_get_method (void);\n+\n+void *event_init (void);\n+void event_base_free (struct event_base *base);\n+\n+#define EVLOOP_ONCE      EVLOOP_ONESHOT\n+int event_loop (int);\n+int event_loopexit (struct timeval *tv);\n+int event_dispatch (void);\n+\n+#define _EVENT_LOG_DEBUG 0\n+#define _EVENT_LOG_MSG   1\n+#define _EVENT_LOG_WARN  2\n+#define _EVENT_LOG_ERR   3\n+typedef void (*event_log_cb)(int severity, const char *msg);\n+void event_set_log_callback(event_log_cb cb);\n+\n+void event_set (struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg);\n+int event_once (int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv);\n+\n+int event_add (struct event *ev, struct timeval *tv);\n+int event_del (struct event *ev);\n+void event_active (struct event *ev, int res, short ncalls); /* ncalls is being ignored */\n+\n+int event_pending (struct event *ev, short, struct timeval *tv);\n+\n+int event_priority_init (int npri);\n+int event_priority_set (struct event *ev, int pri);\n+\n+int event_base_set (struct event_base *base, struct event *ev);\n+int event_base_loop (struct event_base *base, int);\n+int event_base_loopexit (struct event_base *base, struct timeval *tv);\n+int event_base_dispatch (struct event_base *base);\n+int event_base_once (struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv);\n+int event_base_priority_init (struct event_base *base, int fd);\n+\n+/* next line is different in the libevent+libev version */\n+/*libevent-include*/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "6ce63b9f76bc6ab5ff08f967f52f8cf4c53a1353", "filename": "src/rt/libuv/ev/install-sh", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Finstall-sh?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,294 @@\n+#!/bin/sh\n+#\n+# install - install a program, script, or datafile\n+#\n+# This originates from X11R5 (mit/util/scripts/install.sh), which was\n+# later released in X11R6 (xc/config/util/install.sh) with the\n+# following copyright and license.\n+#\n+# Copyright (C) 1994 X Consortium\n+#\n+# Permission is hereby granted, free of charge, to any person obtaining a copy\n+# of this software and associated documentation files (the \"Software\"), to\n+# deal in the Software without restriction, including without limitation the\n+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+# sell copies of the Software, and to permit persons to whom the Software is\n+# furnished to do so, subject to the following conditions:\n+#\n+# The above copyright notice and this permission notice shall be included in\n+# all copies or substantial portions of the Software.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-\n+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+#\n+# Except as contained in this notice, the name of the X Consortium shall not\n+# be used in advertising or otherwise to promote the sale, use or other deal-\n+# ings in this Software without prior written authorization from the X Consor-\n+# tium.\n+#\n+#\n+# FSF changes to this file are in the public domain.\n+#\n+# Calling this script install-sh is preferred over install.sh, to prevent\n+# `make' implicit rules from creating a file called install from it\n+# when there is no Makefile.\n+#\n+# This script is compatible with the BSD install script, but was written\n+# from scratch.  It can only install one file at a time, a restriction\n+# shared with many OS's install programs.\n+\n+\n+# set DOITPROG to echo to test this script\n+\n+# Don't use :- since 4.3BSD and earlier shells don't like it.\n+doit=\"${DOITPROG-}\"\n+\n+\n+# put in absolute paths if you don't have them in your path; or use env. vars.\n+\n+mvprog=\"${MVPROG-mv}\"\n+cpprog=\"${CPPROG-cp}\"\n+chmodprog=\"${CHMODPROG-chmod}\"\n+chownprog=\"${CHOWNPROG-chown}\"\n+chgrpprog=\"${CHGRPPROG-chgrp}\"\n+stripprog=\"${STRIPPROG-strip}\"\n+rmprog=\"${RMPROG-rm}\"\n+mkdirprog=\"${MKDIRPROG-mkdir}\"\n+\n+transformbasename=\"\"\n+transform_arg=\"\"\n+instcmd=\"$mvprog\"\n+chmodcmd=\"$chmodprog 0755\"\n+chowncmd=\"\"\n+chgrpcmd=\"\"\n+stripcmd=\"\"\n+rmcmd=\"$rmprog -f\"\n+mvcmd=\"$mvprog\"\n+src=\"\"\n+dst=\"\"\n+dir_arg=\"\"\n+\n+while [ x\"$1\" != x ]; do\n+    case $1 in\n+\t-c) instcmd=$cpprog\n+\t    shift\n+\t    continue;;\n+\n+\t-d) dir_arg=true\n+\t    shift\n+\t    continue;;\n+\n+\t-m) chmodcmd=\"$chmodprog $2\"\n+\t    shift\n+\t    shift\n+\t    continue;;\n+\n+\t-o) chowncmd=\"$chownprog $2\"\n+\t    shift\n+\t    shift\n+\t    continue;;\n+\n+\t-g) chgrpcmd=\"$chgrpprog $2\"\n+\t    shift\n+\t    shift\n+\t    continue;;\n+\n+\t-s) stripcmd=$stripprog\n+\t    shift\n+\t    continue;;\n+\n+\t-t=*) transformarg=`echo $1 | sed 's/-t=//'`\n+\t    shift\n+\t    continue;;\n+\n+\t-b=*) transformbasename=`echo $1 | sed 's/-b=//'`\n+\t    shift\n+\t    continue;;\n+\n+\t*)  if [ x\"$src\" = x ]\n+\t    then\n+\t\tsrc=$1\n+\t    else\n+\t\t# this colon is to work around a 386BSD /bin/sh bug\n+\t\t:\n+\t\tdst=$1\n+\t    fi\n+\t    shift\n+\t    continue;;\n+    esac\n+done\n+\n+if [ x\"$src\" = x ]\n+then\n+\techo \"$0: no input file specified\" >&2\n+\texit 1\n+else\n+\t:\n+fi\n+\n+if [ x\"$dir_arg\" != x ]; then\n+\tdst=$src\n+\tsrc=\"\"\n+\n+\tif [ -d \"$dst\" ]; then\n+\t\tinstcmd=:\n+\t\tchmodcmd=\"\"\n+\telse\n+\t\tinstcmd=$mkdirprog\n+\tfi\n+else\n+\n+# Waiting for this to be detected by the \"$instcmd $src $dsttmp\" command\n+# might cause directories to be created, which would be especially bad\n+# if $src (and thus $dsttmp) contains '*'.\n+\n+\tif [ -f \"$src\" ] || [ -d \"$src\" ]\n+\tthen\n+\t\t:\n+\telse\n+\t\techo \"$0: $src does not exist\" >&2\n+\t\texit 1\n+\tfi\n+\n+\tif [ x\"$dst\" = x ]\n+\tthen\n+\t\techo \"$0: no destination specified\" >&2\n+\t\texit 1\n+\telse\n+\t\t:\n+\tfi\n+\n+# If destination is a directory, append the input filename; if your system\n+# does not like double slashes in filenames, you may need to add some logic\n+\n+\tif [ -d \"$dst\" ]\n+\tthen\n+\t\tdst=$dst/`basename \"$src\"`\n+\telse\n+\t\t:\n+\tfi\n+fi\n+\n+## this sed command emulates the dirname command\n+dstdir=`echo \"$dst\" | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`\n+\n+# Make sure that the destination directory exists.\n+#  this part is taken from Noah Friedman's mkinstalldirs script\n+\n+# Skip lots of stat calls in the usual case.\n+if [ ! -d \"$dstdir\" ]; then\n+defaultIFS='\n+\t'\n+IFS=\"${IFS-$defaultIFS}\"\n+\n+oIFS=$IFS\n+# Some sh's can't handle IFS=/ for some reason.\n+IFS='%'\n+set - `echo \"$dstdir\" | sed -e 's@/@%@g' -e 's@^%@/@'`\n+IFS=$oIFS\n+\n+pathcomp=''\n+\n+while [ $# -ne 0 ] ; do\n+\tpathcomp=$pathcomp$1\n+\tshift\n+\n+\tif [ ! -d \"$pathcomp\" ] ;\n+        then\n+\t\t$mkdirprog \"$pathcomp\"\n+\telse\n+\t\t:\n+\tfi\n+\n+\tpathcomp=$pathcomp/\n+done\n+fi\n+\n+if [ x\"$dir_arg\" != x ]\n+then\n+\t$doit $instcmd \"$dst\" &&\n+\n+\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd \"$dst\"; else : ; fi &&\n+\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd \"$dst\"; else : ; fi &&\n+\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd \"$dst\"; else : ; fi &&\n+\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd \"$dst\"; else : ; fi\n+else\n+\n+# If we're going to rename the final executable, determine the name now.\n+\n+\tif [ x\"$transformarg\" = x ]\n+\tthen\n+\t\tdstfile=`basename \"$dst\"`\n+\telse\n+\t\tdstfile=`basename \"$dst\" $transformbasename |\n+\t\t\tsed $transformarg`$transformbasename\n+\tfi\n+\n+# don't allow the sed command to completely eliminate the filename\n+\n+\tif [ x\"$dstfile\" = x ]\n+\tthen\n+\t\tdstfile=`basename \"$dst\"`\n+\telse\n+\t\t:\n+\tfi\n+\n+# Make a couple of temp file names in the proper directory.\n+\n+\tdsttmp=$dstdir/_inst.$$_\n+\trmtmp=$dstdir/_rm.$$_\n+\n+# Trap to clean up temp files at exit.\n+\n+\ttrap 'status=$?; rm -f \"$dsttmp\" \"$rmtmp\" && exit $status' 0\n+\ttrap '(exit $?); exit' 1 2 13 15\n+\n+# Move or copy the file name to the temp name\n+\n+\t$doit $instcmd \"$src\" \"$dsttmp\" &&\n+\n+# and set any options; do chmod last to preserve setuid bits\n+\n+# If any of these fail, we abort the whole thing.  If we want to\n+# ignore errors from any of these, just make sure not to ignore\n+# errors from the above \"$doit $instcmd $src $dsttmp\" command.\n+\n+\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd \"$dsttmp\"; else :;fi &&\n+\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd \"$dsttmp\"; else :;fi &&\n+\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd \"$dsttmp\"; else :;fi &&\n+\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd \"$dsttmp\"; else :;fi &&\n+\n+# Now remove or move aside any old file at destination location.  We try this\n+# two ways since rm can't unlink itself on some systems and the destination\n+# file might be busy for other reasons.  In this case, the final cleanup\n+# might fail but the new file should still install successfully.\n+\n+{\n+\tif [ -f \"$dstdir/$dstfile\" ]\n+\tthen\n+\t\t$doit $rmcmd -f \"$dstdir/$dstfile\" 2>/dev/null ||\n+\t\t$doit $mvcmd -f \"$dstdir/$dstfile\" \"$rmtmp\" 2>/dev/null ||\n+\t\t{\n+\t\t  echo \"$0: cannot unlink or rename $dstdir/$dstfile\" >&2\n+\t\t  (exit 1); exit\n+\t\t}\n+\telse\n+\t\t:\n+\tfi\n+} &&\n+\n+# Now rename the file to the real destination.\n+\n+\t$doit $mvcmd \"$dsttmp\" \"$dstdir/$dstfile\"\n+\n+fi &&\n+\n+# The final little trick to \"correctly\" pass the exit status to the exit trap.\n+\n+{\n+\t(exit 0); exit\n+}"}, {"sha": "e3f4c81b236d53a9f0ea2aa965a4264b2958bfcd", "filename": "src/rt/libuv/ev/libev.m4", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Flibev.m4", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Flibev.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Flibev.m4?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,39 @@\n+dnl this file is part of libev, do not make local modifications\n+dnl http://software.schmorp.de/pkg/libev\n+\n+dnl libev support \n+AC_CHECK_HEADERS(sys/inotify.h sys/epoll.h sys/event.h port.h poll.h sys/select.h sys/eventfd.h sys/signalfd.h) \n+ \n+AC_CHECK_FUNCS(inotify_init epoll_ctl kqueue port_create poll select eventfd signalfd)\n+ \n+AC_CHECK_FUNCS(clock_gettime, [], [ \n+   dnl on linux, try syscall wrapper first\n+   if test $(uname) = Linux; then\n+      AC_MSG_CHECKING(for clock_gettime syscall)\n+      AC_LINK_IFELSE([AC_LANG_PROGRAM(\n+                      [#include <unistd.h>\n+                       #include <sys/syscall.h>\n+                       #include <time.h>],\n+                      [struct timespec ts; int status = syscall (SYS_clock_gettime, CLOCK_REALTIME, &ts)])],\n+                     [ac_have_clock_syscall=1\n+                      AC_DEFINE(HAVE_CLOCK_SYSCALL, 1, \"use syscall interface for clock_gettime\")\n+                      AC_MSG_RESULT(yes)],\n+                     [AC_MSG_RESULT(no)])\n+   fi\n+   if test -z \"$LIBEV_M4_AVOID_LIBRT\" && test -z \"$ac_have_clock_syscall\"; then\n+      AC_CHECK_LIB(rt, clock_gettime) \n+      unset ac_cv_func_clock_gettime\n+      AC_CHECK_FUNCS(clock_gettime)\n+   fi\n+])\n+\n+AC_CHECK_FUNCS(nanosleep, [], [ \n+   if test -z \"$LIBEV_M4_AVOID_LIBRT\"; then\n+      AC_CHECK_LIB(rt, nanosleep) \n+      unset ac_cv_func_nanosleep\n+      AC_CHECK_FUNCS(nanosleep)\n+   fi\n+])\n+\n+AC_CHECK_LIB(m, ceil)\n+"}, {"sha": "d88da2c264c8c312b286a83ae06d688d5287361a", "filename": "src/rt/libuv/ev/ltmain.sh", "status": "added", "additions": 8413, "deletions": 0, "changes": 8413, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fltmain.sh?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25"}, {"sha": "fc54c64ec969d9c1630335d8a88c5d72d3ca0856", "filename": "src/rt/libuv/ev/missing", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fmissing", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fmissing", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fmissing?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,336 @@\n+#! /bin/sh\n+# Common stub for a few missing GNU programs while installing.\n+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n+# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n+# 02111-1307, USA.\n+\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+if test $# -eq 0; then\n+  echo 1>&2 \"Try \\`$0 --help' for more information\"\n+  exit 1\n+fi\n+\n+run=:\n+\n+# In the cases where this matters, `missing' is being run in the\n+# srcdir already.\n+if test -f configure.ac; then\n+  configure_ac=configure.ac\n+else\n+  configure_ac=configure.in\n+fi\n+\n+case \"$1\" in\n+--run)\n+  # Try to run requested program, and just exit if it succeeds.\n+  run=\n+  shift\n+  \"$@\" && exit 0\n+  ;;\n+esac\n+\n+# If it does not exist, or fails to run (possibly an outdated version),\n+# try to emulate it.\n+case \"$1\" in\n+\n+  -h|--h|--he|--hel|--help)\n+    echo \"\\\n+$0 [OPTION]... PROGRAM [ARGUMENT]...\n+\n+Handle \\`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an\n+error status if there is no known handling for PROGRAM.\n+\n+Options:\n+  -h, --help      display this help and exit\n+  -v, --version   output version information and exit\n+  --run           try to run the given command, and emulate it if it fails\n+\n+Supported PROGRAM values:\n+  aclocal      touch file \\`aclocal.m4'\n+  autoconf     touch file \\`configure'\n+  autoheader   touch file \\`config.h.in'\n+  automake     touch all \\`Makefile.in' files\n+  bison        create \\`y.tab.[ch]', if possible, from existing .[ch]\n+  flex         create \\`lex.yy.c', if possible, from existing .c\n+  help2man     touch the output file\n+  lex          create \\`lex.yy.c', if possible, from existing .c\n+  makeinfo     touch the output file\n+  tar          try tar, gnutar, gtar, then tar without non-portable flags\n+  yacc         create \\`y.tab.[ch]', if possible, from existing .[ch]\"\n+    ;;\n+\n+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)\n+    echo \"missing 0.4 - GNU automake\"\n+    ;;\n+\n+  -*)\n+    echo 1>&2 \"$0: Unknown \\`$1' option\"\n+    echo 1>&2 \"Try \\`$0 --help' for more information\"\n+    exit 1\n+    ;;\n+\n+  aclocal*)\n+    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n+       # We have it, but it failed.\n+       exit 1\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+         you modified \\`acinclude.m4' or \\`${configure_ac}'.  You might want\n+         to install the \\`Automake' and \\`Perl' packages.  Grab them from\n+         any GNU archive site.\"\n+    touch aclocal.m4\n+    ;;\n+\n+  autoconf)\n+    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n+       # We have it, but it failed.\n+       exit 1\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+         you modified \\`${configure_ac}'.  You might want to install the\n+         \\`Autoconf' and \\`GNU m4' packages.  Grab them from any GNU\n+         archive site.\"\n+    touch configure\n+    ;;\n+\n+  autoheader)\n+    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n+       # We have it, but it failed.\n+       exit 1\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+         you modified \\`acconfig.h' or \\`${configure_ac}'.  You might want\n+         to install the \\`Autoconf' and \\`GNU m4' packages.  Grab them\n+         from any GNU archive site.\"\n+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\\([^)]*\\)).*/\\1/p' ${configure_ac}`\n+    test -z \"$files\" && files=\"config.h\"\n+    touch_files=\n+    for f in $files; do\n+      case \"$f\" in\n+      *:*) touch_files=\"$touch_files \"`echo \"$f\" |\n+\t\t\t\t       sed -e 's/^[^:]*://' -e 's/:.*//'`;;\n+      *) touch_files=\"$touch_files $f.in\";;\n+      esac\n+    done\n+    touch $touch_files\n+    ;;\n+\n+  automake*)\n+    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n+       # We have it, but it failed.\n+       exit 1\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+         you modified \\`Makefile.am', \\`acinclude.m4' or \\`${configure_ac}'.\n+         You might want to install the \\`Automake' and \\`Perl' packages.\n+         Grab them from any GNU archive site.\"\n+    find . -type f -name Makefile.am -print |\n+\t   sed 's/\\.am$/.in/' |\n+\t   while read f; do touch \"$f\"; done\n+    ;;\n+\n+  autom4te)\n+    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n+       # We have it, but it failed.\n+       exit 1\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is needed, and you do not seem to have it handy on your\n+         system.  You might have modified some files without having the\n+         proper tools for further handling them.\n+         You can get \\`$1' as part of \\`Autoconf' from any GNU\n+         archive site.\"\n+\n+    file=`echo \"$*\" | sed -n 's/.*--output[ =]*\\([^ ]*\\).*/\\1/p'`\n+    test -z \"$file\" && file=`echo \"$*\" | sed -n 's/.*-o[ ]*\\([^ ]*\\).*/\\1/p'`\n+    if test -f \"$file\"; then\n+\ttouch $file\n+    else\n+\ttest -z \"$file\" || exec >$file\n+\techo \"#! /bin/sh\"\n+\techo \"# Created by GNU Automake missing as a replacement of\"\n+\techo \"#  $ $@\"\n+\techo \"exit 0\"\n+\tchmod +x $file\n+\texit 1\n+    fi\n+    ;;\n+\n+  bison|yacc)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+         you modified a \\`.y' file.  You may need the \\`Bison' package\n+         in order for those modifications to take effect.  You can get\n+         \\`Bison' from any GNU archive site.\"\n+    rm -f y.tab.c y.tab.h\n+    if [ $# -ne 1 ]; then\n+        eval LASTARG=\"\\${$#}\"\n+\tcase \"$LASTARG\" in\n+\t*.y)\n+\t    SRCFILE=`echo \"$LASTARG\" | sed 's/y$/c/'`\n+\t    if [ -f \"$SRCFILE\" ]; then\n+\t         cp \"$SRCFILE\" y.tab.c\n+\t    fi\n+\t    SRCFILE=`echo \"$LASTARG\" | sed 's/y$/h/'`\n+\t    if [ -f \"$SRCFILE\" ]; then\n+\t         cp \"$SRCFILE\" y.tab.h\n+\t    fi\n+\t  ;;\n+\tesac\n+    fi\n+    if [ ! -f y.tab.h ]; then\n+\techo >y.tab.h\n+    fi\n+    if [ ! -f y.tab.c ]; then\n+\techo 'main() { return 0; }' >y.tab.c\n+    fi\n+    ;;\n+\n+  lex|flex)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+         you modified a \\`.l' file.  You may need the \\`Flex' package\n+         in order for those modifications to take effect.  You can get\n+         \\`Flex' from any GNU archive site.\"\n+    rm -f lex.yy.c\n+    if [ $# -ne 1 ]; then\n+        eval LASTARG=\"\\${$#}\"\n+\tcase \"$LASTARG\" in\n+\t*.l)\n+\t    SRCFILE=`echo \"$LASTARG\" | sed 's/l$/c/'`\n+\t    if [ -f \"$SRCFILE\" ]; then\n+\t         cp \"$SRCFILE\" lex.yy.c\n+\t    fi\n+\t  ;;\n+\tesac\n+    fi\n+    if [ ! -f lex.yy.c ]; then\n+\techo 'main() { return 0; }' >lex.yy.c\n+    fi\n+    ;;\n+\n+  help2man)\n+    if test -z \"$run\" && ($1 --version) > /dev/null 2>&1; then\n+       # We have it, but it failed.\n+       exit 1\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+\t you modified a dependency of a manual page.  You may need the\n+\t \\`Help2man' package in order for those modifications to take\n+\t effect.  You can get \\`Help2man' from any GNU archive site.\"\n+\n+    file=`echo \"$*\" | sed -n 's/.*-o \\([^ ]*\\).*/\\1/p'`\n+    if test -z \"$file\"; then\n+\tfile=`echo \"$*\" | sed -n 's/.*--output=\\([^ ]*\\).*/\\1/p'`\n+    fi\n+    if [ -f \"$file\" ]; then\n+\ttouch $file\n+    else\n+\ttest -z \"$file\" || exec >$file\n+\techo \".ab help2man is required to generate this page\"\n+\texit 1\n+    fi\n+    ;;\n+\n+  makeinfo)\n+    if test -z \"$run\" && (makeinfo --version) > /dev/null 2>&1; then\n+       # We have makeinfo, but it failed.\n+       exit 1\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is missing on your system.  You should only need it if\n+         you modified a \\`.texi' or \\`.texinfo' file, or any other file\n+         indirectly affecting the aspect of the manual.  The spurious\n+         call might also be the consequence of using a buggy \\`make' (AIX,\n+         DU, IRIX).  You might want to install the \\`Texinfo' package or\n+         the \\`GNU make' package.  Grab either from any GNU archive site.\"\n+    file=`echo \"$*\" | sed -n 's/.*-o \\([^ ]*\\).*/\\1/p'`\n+    if test -z \"$file\"; then\n+      file=`echo \"$*\" | sed 's/.* \\([^ ]*\\) *$/\\1/'`\n+      file=`sed -n '/^@setfilename/ { s/.* \\([^ ]*\\) *$/\\1/; p; q; }' $file`\n+    fi\n+    touch $file\n+    ;;\n+\n+  tar)\n+    shift\n+    if test -n \"$run\"; then\n+      echo 1>&2 \"ERROR: \\`tar' requires --run\"\n+      exit 1\n+    fi\n+\n+    # We have already tried tar in the generic part.\n+    # Look for gnutar/gtar before invocation to avoid ugly error\n+    # messages.\n+    if (gnutar --version > /dev/null 2>&1); then\n+       gnutar \"$@\" && exit 0\n+    fi\n+    if (gtar --version > /dev/null 2>&1); then\n+       gtar \"$@\" && exit 0\n+    fi\n+    firstarg=\"$1\"\n+    if shift; then\n+\tcase \"$firstarg\" in\n+\t*o*)\n+\t    firstarg=`echo \"$firstarg\" | sed s/o//`\n+\t    tar \"$firstarg\" \"$@\" && exit 0\n+\t    ;;\n+\tesac\n+\tcase \"$firstarg\" in\n+\t*h*)\n+\t    firstarg=`echo \"$firstarg\" | sed s/h//`\n+\t    tar \"$firstarg\" \"$@\" && exit 0\n+\t    ;;\n+\tesac\n+    fi\n+\n+    echo 1>&2 \"\\\n+WARNING: I can't seem to be able to run \\`tar' with the given arguments.\n+         You may want to install GNU tar or Free paxutils, or check the\n+         command line arguments.\"\n+    exit 1\n+    ;;\n+\n+  *)\n+    echo 1>&2 \"\\\n+WARNING: \\`$1' is needed, and you do not seem to have it handy on your\n+         system.  You might have modified some files without having the\n+         proper tools for further handling them.  Check the \\`README' file,\n+         it often tells you about the needed prerequisites for installing\n+         this package.  You may also peek at any GNU archive site, in case\n+         some other package would contain this missing \\`$1' program.\"\n+    exit 1\n+    ;;\n+esac\n+\n+exit 0"}, {"sha": "d2d5f21b611235316317197d3a32c2dff5897a6f", "filename": "src/rt/libuv/ev/mkinstalldirs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fmkinstalldirs", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fev%2Fmkinstalldirs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fev%2Fmkinstalldirs?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,111 @@\n+#! /bin/sh\n+# mkinstalldirs --- make directory hierarchy\n+# Author: Noah Friedman <friedman@prep.ai.mit.edu>\n+# Created: 1993-05-16\n+# Public domain\n+\n+errstatus=0\n+dirmode=\"\"\n+\n+usage=\"\\\n+Usage: mkinstalldirs [-h] [--help] [-m mode] dir ...\"\n+\n+# process command line arguments\n+while test $# -gt 0 ; do\n+  case $1 in\n+    -h | --help | --h*)         # -h for help\n+      echo \"$usage\" 1>&2\n+      exit 0\n+      ;;\n+    -m)                         # -m PERM arg\n+      shift\n+      test $# -eq 0 && { echo \"$usage\" 1>&2; exit 1; }\n+      dirmode=$1\n+      shift\n+      ;;\n+    --)                         # stop option processing\n+      shift\n+      break\n+      ;;\n+    -*)                         # unknown option\n+      echo \"$usage\" 1>&2\n+      exit 1\n+      ;;\n+    *)                          # first non-opt arg\n+      break\n+      ;;\n+  esac\n+done\n+\n+for file\n+do\n+  if test -d \"$file\"; then\n+    shift\n+  else\n+    break\n+  fi\n+done\n+\n+case $# in\n+  0) exit 0 ;;\n+esac\n+\n+case $dirmode in\n+  '')\n+    if mkdir -p -- . 2>/dev/null; then\n+      echo \"mkdir -p -- $*\"\n+      exec mkdir -p -- \"$@\"\n+    fi\n+    ;;\n+  *)\n+    if mkdir -m \"$dirmode\" -p -- . 2>/dev/null; then\n+      echo \"mkdir -m $dirmode -p -- $*\"\n+      exec mkdir -m \"$dirmode\" -p -- \"$@\"\n+    fi\n+    ;;\n+esac\n+\n+for file\n+do\n+  set fnord `echo \":$file\" | sed -ne 's/^:\\//#/;s/^://;s/\\// /g;s/^#/\\//;p'`\n+  shift\n+\n+  pathcomp=\n+  for d\n+  do\n+    pathcomp=\"$pathcomp$d\"\n+    case $pathcomp in\n+      -*) pathcomp=./$pathcomp ;;\n+    esac\n+\n+    if test ! -d \"$pathcomp\"; then\n+      echo \"mkdir $pathcomp\"\n+\n+      mkdir \"$pathcomp\" || lasterr=$?\n+\n+      if test ! -d \"$pathcomp\"; then\n+  \terrstatus=$lasterr\n+      else\n+  \tif test ! -z \"$dirmode\"; then\n+\t  echo \"chmod $dirmode $pathcomp\"\n+    \t  lasterr=\"\"\n+  \t  chmod \"$dirmode\" \"$pathcomp\" || lasterr=$?\n+\n+  \t  if test ! -z \"$lasterr\"; then\n+  \t    errstatus=$lasterr\n+  \t  fi\n+  \tfi\n+      fi\n+    fi\n+\n+    pathcomp=\"$pathcomp/\"\n+  done\n+done\n+\n+exit $errstatus\n+\n+# Local Variables:\n+# mode: shell-script\n+# sh-indentation: 2\n+# End:\n+# mkinstalldirs ends here"}, {"sha": "4a24462b2f68122ee0d987a38a1d7102f11129d2", "filename": "src/rt/libuv/msvs/libuv-benchmark.vcxproj", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-benchmark.vcxproj?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,172 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n+  <ItemGroup Label=\"ProjectConfigurations\">\n+    <ProjectConfiguration Include=\"Debug|Win32\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Debug|x64\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|Win32\">\n+      <Configuration>Release</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|x64\">\n+      <Configuration>Release</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+  </ItemGroup>\n+  <PropertyGroup Label=\"Globals\">\n+    <Keyword>Win32Proj</Keyword>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n+  <ImportGroup Label=\"ExtensionSettings\">\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <PropertyGroup Label=\"UserMacros\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+    </ClCompile>\n+    <Link>\n+      <TargetMachine>MachineX86</TargetMachine>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+    </ClCompile>\n+    <Link>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+    </ClCompile>\n+    <Link>\n+      <TargetMachine>MachineX86</TargetMachine>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n+      <OptimizeReferences>true</OptimizeReferences>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+    </ClCompile>\n+    <Link>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n+      <OptimizeReferences>true</OptimizeReferences>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemGroup>\n+    <ClCompile Include=\"..\\test\\benchmark-ping-pongs.c\" />\n+    <ClCompile Include=\"..\\test\\benchmark-pump.c\" />\n+    <ClCompile Include=\"..\\test\\benchmark-sizes.c\" />\n+    <ClCompile Include=\"..\\test\\echo-server.c\" />\n+    <ClCompile Include=\"..\\test\\run-benchmarks.c\" />\n+    <ClCompile Include=\"..\\test\\runner-unix.c\">\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n+    </ClCompile>\n+    <ClCompile Include=\"..\\test\\runner-win.c\" />\n+    <ClCompile Include=\"..\\test\\runner.c\" />\n+  </ItemGroup>\n+  <ItemGroup>\n+    <ClInclude Include=\"..\\test\\benchmark-list.h\" />\n+    <ClInclude Include=\"..\\test\\runner-unix.h\">\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n+    </ClInclude>\n+    <ClInclude Include=\"..\\test\\runner-win.h\" />\n+    <ClInclude Include=\"..\\test\\runner.h\" />\n+    <ClInclude Include=\"..\\test\\task.h\" />\n+  </ItemGroup>\n+  <ItemGroup>\n+    <ProjectReference Include=\"libuv.vcxproj\">\n+      <Project>{301fe650-cd34-14e5-6b63-42e383fa02bc}</Project>\n+    </ProjectReference>\n+  </ItemGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n+  <ImportGroup Label=\"ExtensionTargets\">\n+  </ImportGroup>\n+</Project>"}, {"sha": "0c360b9054658842bbb66e9347c870144771a49b", "filename": "src/rt/libuv/msvs/libuv-test.vcxproj", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv-test.vcxproj?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,184 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n+  <ItemGroup Label=\"ProjectConfigurations\">\n+    <ProjectConfiguration Include=\"Debug|Win32\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Debug|x64\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|Win32\">\n+      <Configuration>Release</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|x64\">\n+      <Configuration>Release</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+  </ItemGroup>\n+  <PropertyGroup Label=\"Globals\">\n+    <Keyword>Win32Proj</Keyword>\n+    <ProjectGuid>{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}</ProjectGuid>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>Application</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n+  <ImportGroup Label=\"ExtensionSettings\">\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <PropertyGroup Label=\"UserMacros\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <LinkIncremental>true</LinkIncremental>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+  </PropertyGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+    </ClCompile>\n+    <Link>\n+      <TargetMachine>MachineX86</TargetMachine>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+    </ClCompile>\n+    <Link>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+    </ClCompile>\n+    <Link>\n+      <TargetMachine>MachineX86</TargetMachine>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n+      <OptimizeReferences>true</OptimizeReferences>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+    </ClCompile>\n+    <Link>\n+      <GenerateDebugInformation>true</GenerateDebugInformation>\n+      <SubSystem>Console</SubSystem>\n+      <EnableCOMDATFolding>true</EnableCOMDATFolding>\n+      <OptimizeReferences>true</OptimizeReferences>\n+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>\n+    </Link>\n+  </ItemDefinitionGroup>\n+  <ItemGroup>\n+    <ClCompile Include=\"..\\test\\echo-server.c\" />\n+    <ClCompile Include=\"..\\test\\runner-unix.c\">\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n+    </ClCompile>\n+    <ClCompile Include=\"..\\test\\test-async.c\" />\n+    <ClCompile Include=\"..\\test\\test-delayed-accept.c\" />\n+    <ClCompile Include=\"..\\test\\test-callback-stack.c\" />\n+    <ClCompile Include=\"..\\test\\test-connection-fail.c\" />\n+    <ClCompile Include=\"..\\test\\test-get-currentexe.c\" />\n+    <ClCompile Include=\"..\\test\\test-fail-always.c\" />\n+    <ClCompile Include=\"..\\test\\test-loop-handles.c\" />\n+    <ClCompile Include=\"..\\test\\test-pass-always.c\" />\n+    <ClCompile Include=\"..\\test\\test-ping-pong.c\" />\n+    <ClCompile Include=\"..\\test\\runner-win.c\" />\n+    <ClCompile Include=\"..\\test\\runner.c\" />\n+    <ClCompile Include=\"..\\test\\test-bind-error.c\" />\n+    <ClCompile Include=\"..\\test\\test-shutdown-eof.c\" />\n+    <ClCompile Include=\"..\\test\\test-tcp-writealot.c\" />\n+    <ClCompile Include=\"..\\test\\test-timer-again.c\" />\n+    <ClCompile Include=\"..\\test\\test-timer.c\" />\n+    <ClCompile Include=\"..\\test\\run-tests.c\" />\n+  </ItemGroup>\n+  <ItemGroup>\n+    <ClInclude Include=\"..\\test\\runner-unix.h\">\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n+    </ClInclude>\n+    <ClInclude Include=\"..\\test\\test-list.h\" />\n+    <ClInclude Include=\"..\\test\\runner-win.h\" />\n+    <ClInclude Include=\"..\\test\\runner.h\" />\n+    <ClInclude Include=\"..\\test\\task.h\" />\n+  </ItemGroup>\n+  <ItemGroup>\n+    <ProjectReference Include=\"libuv.vcxproj\">\n+      <Project>{301fe650-cd34-14e5-6b63-42e383fa02bc}</Project>\n+    </ProjectReference>\n+  </ItemGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n+  <ImportGroup Label=\"ExtensionTargets\">\n+  </ImportGroup>\n+</Project>"}, {"sha": "e68d41d38c8ccaab69779dc76fd47ac47e7227f1", "filename": "src/rt/libuv/msvs/libuv.sln", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.sln?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,46 @@\n+\ufeff\r\n+Microsoft Visual Studio Solution File, Format Version 11.00\r\n+# Visual Studio 2010\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv\", \"libuv.vcxproj\", \"{301FE650-CD34-14E5-6B63-42E383FA02BC}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv-test\", \"libuv-test.vcxproj\", \"{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}\"\r\n+EndProject\r\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"libuv-benchmark\", \"libuv-benchmark.vcxproj\", \"{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}\"\r\n+EndProject\r\n+Global\r\n+\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n+\t\tDebug|Win32 = Debug|Win32\r\n+\t\tDebug|x64 = Debug|x64\r\n+\t\tRelease|Win32 = Release|Win32\r\n+\t\tRelease|x64 = Release|x64\r\n+\tEndGlobalSection\r\n+\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{301FE650-CD34-14E5-6B63-42E383FA02BC}.Release|x64.Build.0 = Release|x64\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{1D7C3F6C-A4AF-DD73-2D20-B2FC919B3744}.Release|x64.Build.0 = Release|x64\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|Win32.ActiveCfg = Debug|Win32\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|Win32.Build.0 = Debug|Win32\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|x64.ActiveCfg = Debug|x64\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Debug|x64.Build.0 = Debug|x64\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|Win32.ActiveCfg = Release|Win32\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|Win32.Build.0 = Release|Win32\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|x64.ActiveCfg = Release|x64\r\n+\t\t{6CCBDAFD-7A11-133D-357B-E2D2F4C621E4}.Release|x64.Build.0 = Release|x64\r\n+\tEndGlobalSection\r\n+\tGlobalSection(SolutionProperties) = preSolution\r\n+\t\tHideSolutionNode = FALSE\r\n+\tEndGlobalSection\r\n+EndGlobal\r"}, {"sha": "7b11f49e370d7594a18a35affaa509f85bbbfbd4", "filename": "src/rt/libuv/msvs/libuv.vcxproj", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fmsvs%2Flibuv.vcxproj?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,136 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n+  <ItemGroup Label=\"ProjectConfigurations\">\n+    <ProjectConfiguration Include=\"Debug|Win32\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Debug|x64\">\n+      <Configuration>Debug</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|Win32\">\n+      <Configuration>Release</Configuration>\n+      <Platform>Win32</Platform>\n+    </ProjectConfiguration>\n+    <ProjectConfiguration Include=\"Release|x64\">\n+      <Configuration>Release</Configuration>\n+      <Platform>x64</Platform>\n+    </ProjectConfiguration>\n+  </ItemGroup>\n+  <PropertyGroup Label=\"Globals\">\n+    <Keyword>Win32Proj</Keyword>\n+    <ProjectGuid>{301FE650-CD34-14E5-6B63-42E383FA02BC}</ProjectGuid>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>true</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n+    <ConfigurationType>StaticLibrary</ConfigurationType>\n+    <UseDebugLibraries>false</UseDebugLibraries>\n+  </PropertyGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n+  <ImportGroup Label=\"ExtensionSettings\">\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n+    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n+  </ImportGroup>\n+  <PropertyGroup Label=\"UserMacros\" />\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <OutDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</OutDir>\n+    <IntDir>$(SolutionDir)..\\build\\$(Platform)\\$(Configuration)\\</IntDir>\n+  </PropertyGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n+    <ClCompile>\n+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>\n+      <WarningLevel>Level3</WarningLevel>\n+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n+      <Optimization>Disabled</Optimization>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n+    <ClCompile>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n+    <ClCompile>\n+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>\n+    </ClCompile>\n+  </ItemDefinitionGroup>\n+  <ItemGroup>\n+    <ClInclude Include=\"..\\ngx-queue.h\" />\n+    <ClInclude Include=\"..\\uv-unix.h\">\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n+    </ClInclude>\n+    <ClInclude Include=\"..\\uv-win.h\" />\n+    <ClInclude Include=\"..\\uv.h\" />\n+    <ClInclude Include=\"..\\tree.h\" />\n+  </ItemGroup>\n+  <ItemGroup>\n+    <ClCompile Include=\"..\\uv-unix.c\">\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">true</ExcludedFromBuild>\n+      <ExcludedFromBuild Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">true</ExcludedFromBuild>\n+    </ClCompile>\n+    <ClCompile Include=\"..\\uv-win.c\" />\n+    <ClCompile Include=\"..\\uv-common.c\" />\n+  </ItemGroup>\n+  <ItemGroup>\n+    <None Include=\"..\\AUTHORS\" />\n+    <None Include=\"..\\config-mingw.mk\" />\n+    <None Include=\"..\\config-unix.mk\" />\n+    <None Include=\"..\\iocp-links.html\" />\n+    <None Include=\"..\\LICENSE\" />\n+    <None Include=\"..\\Makefile\" />\n+    <None Include=\"..\\README\" />\n+  </ItemGroup>\n+  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n+  <ImportGroup Label=\"ExtensionTargets\">\n+  </ImportGroup>\n+</Project>"}, {"sha": "f8576d67dc24f44fa6d1cf5c112ad15160457d7e", "filename": "src/rt/libuv/ngx-queue.h", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fngx-queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fngx-queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fngx-queue.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,102 @@\n+\n+/*\n+ * Copyright (C) Igor Sysoev\n+ */\n+\n+\n+#ifndef _NGX_QUEUE_H_INCLUDED_\n+#define _NGX_QUEUE_H_INCLUDED_\n+\n+\n+typedef struct ngx_queue_s  ngx_queue_t;\n+\n+struct ngx_queue_s {\n+    ngx_queue_t  *prev;\n+    ngx_queue_t  *next;\n+};\n+\n+\n+#define ngx_queue_init(q)                                                     \\\n+    (q)->prev = q;                                                            \\\n+    (q)->next = q\n+\n+\n+#define ngx_queue_empty(h)                                                    \\\n+    (h == (h)->prev)\n+\n+\n+#define ngx_queue_insert_head(h, x)                                           \\\n+    (x)->next = (h)->next;                                                    \\\n+    (x)->next->prev = x;                                                      \\\n+    (x)->prev = h;                                                            \\\n+    (h)->next = x\n+\n+\n+#define ngx_queue_insert_after   ngx_queue_insert_head\n+\n+\n+#define ngx_queue_insert_tail(h, x)                                           \\\n+    (x)->prev = (h)->prev;                                                    \\\n+    (x)->prev->next = x;                                                      \\\n+    (x)->next = h;                                                            \\\n+    (h)->prev = x\n+\n+\n+#define ngx_queue_head(h)                                                     \\\n+    (h)->next\n+\n+\n+#define ngx_queue_last(h)                                                     \\\n+    (h)->prev\n+\n+\n+#define ngx_queue_sentinel(h)                                                 \\\n+    (h)\n+\n+\n+#define ngx_queue_next(q)                                                     \\\n+    (q)->next\n+\n+\n+#define ngx_queue_prev(q)                                                     \\\n+    (q)->prev\n+\n+\n+#if (NGX_DEBUG)\n+\n+#define ngx_queue_remove(x)                                                   \\\n+    (x)->next->prev = (x)->prev;                                              \\\n+    (x)->prev->next = (x)->next;                                              \\\n+    (x)->prev = NULL;                                                         \\\n+    (x)->next = NULL\n+\n+#else\n+\n+#define ngx_queue_remove(x)                                                   \\\n+    (x)->next->prev = (x)->prev;                                              \\\n+    (x)->prev->next = (x)->next\n+\n+#endif\n+\n+\n+#define ngx_queue_split(h, q, n)                                              \\\n+    (n)->prev = (h)->prev;                                                    \\\n+    (n)->prev->next = n;                                                      \\\n+    (n)->next = q;                                                            \\\n+    (h)->prev = (q)->prev;                                                    \\\n+    (h)->prev->next = h;                                                      \\\n+    (q)->prev = n;\n+\n+\n+#define ngx_queue_add(h, n)                                                   \\\n+    (h)->prev->next = (n)->next;                                              \\\n+    (n)->next->prev = (h)->prev;                                              \\\n+    (h)->prev = (n)->prev;                                                    \\\n+    (h)->prev->next = h;\n+\n+\n+#define ngx_queue_data(q, type, link)                                         \\\n+    (type *) ((unsigned char *) q - offsetof(type, link))\n+\n+\n+#endif /* _NGX_QUEUE_H_INCLUDED_ */"}, {"sha": "33ef97e260e5b0662bfae28d6af48ce6402a341e", "filename": "src/rt/libuv/test/benchmark-list.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+BENCHMARK_DECLARE (sizes)\n+BENCHMARK_DECLARE (ping_pongs)\n+BENCHMARK_DECLARE (pump100_client)\n+BENCHMARK_DECLARE (pump1_client)\n+HELPER_DECLARE    (pump_server)\n+HELPER_DECLARE    (echo_server)\n+\n+TASK_LIST_START\n+  BENCHMARK_ENTRY  (sizes)\n+\n+  BENCHMARK_ENTRY  (ping_pongs)\n+  BENCHMARK_HELPER (ping_pongs, echo_server)\n+\n+  BENCHMARK_ENTRY  (pump100_client)\n+  BENCHMARK_HELPER (pump100_client, pump_server)\n+\n+  BENCHMARK_ENTRY  (pump1_client)\n+  BENCHMARK_HELPER (pump1_client, pump_server)\n+TASK_LIST_END"}, {"sha": "9b5543251cba54e062342801d631ba16a6260b47", "filename": "src/rt/libuv/test/benchmark-ping-pongs.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,217 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h> /* strlen */\n+\n+/* Run the benchmark for this many ms */\n+#define TIME 5000\n+\n+\n+typedef struct {\n+  int pongs;\n+  int state;\n+  uv_tcp_t tcp;\n+  uv_req_t connect_req;\n+  uv_req_t shutdown_req;\n+} pinger_t;\n+\n+typedef struct buf_s {\n+  uv_buf_t uv_buf_t;\n+  struct buf_s* next;\n+} buf_t;\n+\n+\n+static char PING[] = \"PING\\n\";\n+\n+static buf_t* buf_freelist = NULL;\n+static int pinger_shutdown_cb_called;\n+static int completed_pingers = 0;\n+static int64_t start_time;\n+\n+\n+static uv_buf_t buf_alloc(uv_tcp_t* tcp, size_t size) {\n+  buf_t* ab;\n+\n+  ab = buf_freelist;\n+\n+  if (ab != NULL) {\n+    buf_freelist = ab->next;\n+    return ab->uv_buf_t;\n+  }\n+\n+  ab = (buf_t*) malloc(size + sizeof *ab);\n+  ab->uv_buf_t.len = size;\n+  ab->uv_buf_t.base = ((char*) ab) + sizeof *ab;\n+\n+  return ab->uv_buf_t;\n+}\n+\n+\n+static void buf_free(uv_buf_t uv_buf_t) {\n+  buf_t* ab = (buf_t*) (uv_buf_t.base - sizeof *ab);\n+\n+  ab->next = buf_freelist;\n+  buf_freelist = ab;\n+}\n+\n+\n+static void pinger_close_cb(uv_handle_t* handle) {\n+  pinger_t* pinger;\n+\n+  pinger = (pinger_t*)handle->data;\n+  LOGF(\"ping_pongs: %d roundtrips/s\\n\", (1000 * pinger->pongs) / TIME);\n+\n+  free(pinger);\n+\n+  completed_pingers++;\n+}\n+\n+\n+static void pinger_write_cb(uv_req_t *req, int status) {\n+  ASSERT(status == 0);\n+\n+  free(req);\n+}\n+\n+\n+static void pinger_write_ping(pinger_t* pinger) {\n+  uv_req_t *req;\n+  uv_buf_t buf;\n+\n+  buf.base = (char*)&PING;\n+  buf.len = strlen(PING);\n+\n+  req = (uv_req_t*)malloc(sizeof(*req));\n+  uv_req_init(req, (uv_handle_t*)(&pinger->tcp), pinger_write_cb);\n+\n+  if (uv_write(req, &buf, 1)) {\n+    FATAL(\"uv_write failed\");\n+  }\n+}\n+\n+\n+static void pinger_shutdown_cb(uv_handle_t* handle, int status) {\n+  ASSERT(status == 0);\n+  pinger_shutdown_cb_called++;\n+\n+  /*\n+   * The close callback has not been triggered yet. We must wait for EOF\n+   * until we close the connection.\n+   */\n+  ASSERT(completed_pingers == 0);\n+}\n+\n+\n+static void pinger_read_cb(uv_tcp_t* tcp, ssize_t nread, uv_buf_t buf) {\n+  unsigned int i;\n+  pinger_t* pinger;\n+\n+  pinger = (pinger_t*)tcp->data;\n+\n+  if (nread < 0) {\n+    ASSERT(uv_last_error().code == UV_EOF);\n+\n+    if (buf.base) {\n+      buf_free(buf);\n+    }\n+\n+    ASSERT(pinger_shutdown_cb_called == 1);\n+    uv_close((uv_handle_t*)tcp, pinger_close_cb);\n+\n+    return;\n+  }\n+\n+  /* Now we count the pings */\n+  for (i = 0; i < nread; i++) {\n+    ASSERT(buf.base[i] == PING[pinger->state]);\n+    pinger->state = (pinger->state + 1) % (sizeof(PING) - 1);\n+    if (pinger->state == 0) {\n+      pinger->pongs++;\n+      if (uv_now() - start_time > TIME) {\n+        uv_req_init(&pinger->shutdown_req, (uv_handle_t*)tcp, pinger_shutdown_cb);\n+        uv_shutdown(&pinger->shutdown_req);\n+        break;\n+      } else {\n+        pinger_write_ping(pinger);\n+      }\n+    }\n+  }\n+\n+  buf_free(buf);\n+}\n+\n+\n+static void pinger_connect_cb(uv_req_t *req, int status) {\n+  pinger_t *pinger = (pinger_t*)req->handle->data;\n+\n+  ASSERT(status == 0);\n+\n+  pinger_write_ping(pinger);\n+\n+  if (uv_read_start((uv_tcp_t*)(req->handle), buf_alloc, pinger_read_cb)) {\n+    FATAL(\"uv_read_start failed\");\n+  }\n+}\n+\n+\n+static void pinger_new() {\n+  int r;\n+  struct sockaddr_in client_addr = uv_ip4_addr(\"0.0.0.0\", 0);\n+  struct sockaddr_in server_addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+  pinger_t *pinger;\n+\n+  pinger = (pinger_t*)malloc(sizeof(*pinger));\n+  pinger->state = 0;\n+  pinger->pongs = 0;\n+\n+  /* Try to connec to the server and do NUM_PINGS ping-pongs. */\n+  r = uv_tcp_init(&pinger->tcp);\n+  ASSERT(!r);\n+\n+  pinger->tcp.data = pinger;\n+\n+  /* We are never doing multiple reads/connects at a time anyway. */\n+  /* so these handles can be pre-initialized. */\n+  uv_req_init(&pinger->connect_req, (uv_handle_t*)&pinger->tcp,\n+      pinger_connect_cb);\n+\n+  uv_bind(&pinger->tcp, client_addr);\n+  r = uv_connect(&pinger->connect_req, server_addr);\n+  ASSERT(!r);\n+}\n+\n+\n+BENCHMARK_IMPL(ping_pongs) {\n+  uv_init();\n+  start_time = uv_now();\n+\n+  pinger_new();\n+  uv_run();\n+\n+  ASSERT(completed_pingers == 1);\n+\n+  return 0;\n+}"}, {"sha": "8a8f52a79d0f480889db073d2a8aaae37b5fa52e", "filename": "src/rt/libuv/test/benchmark-pump.c", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,389 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"task.h\"\n+#include \"../uv.h\"\n+\n+#include <math.h>\n+#include <stdio.h>\n+\n+\n+static int TARGET_CONNECTIONS;\n+#define WRITE_BUFFER_SIZE           8192\n+#define MAX_SIMULTANEOUS_CONNECTS   100\n+\n+#define PRINT_STATS                 0\n+#define STATS_INTERVAL              1000 /* msec */\n+#define STATS_COUNT                 5\n+\n+\n+static void do_write(uv_tcp_t*);\n+static void maybe_connect_some();\n+\n+static uv_req_t* req_alloc();\n+static void req_free(uv_req_t* uv_req);\n+\n+static uv_buf_t buf_alloc(uv_tcp_t*, size_t size);\n+static void buf_free(uv_buf_t uv_buf_t);\n+\n+\n+static uv_tcp_t server;\n+static struct sockaddr_in listen_addr;\n+static struct sockaddr_in connect_addr;\n+\n+static int64_t start_time;\n+\n+static int max_connect_socket = 0;\n+static int max_read_sockets = 0;\n+static int read_sockets = 0;\n+static int write_sockets = 0;\n+\n+static int64_t nrecv = 0;\n+static int64_t nrecv_total = 0;\n+static int64_t nsent = 0;\n+static int64_t nsent_total = 0;\n+\n+static int stats_left = 0;\n+\n+static char write_buffer[WRITE_BUFFER_SIZE];\n+\n+/* Make this as large as you need. */\n+#define MAX_WRITE_HANDLES 1000\n+\n+static uv_tcp_t write_handles[MAX_WRITE_HANDLES];\n+\n+static uv_timer_t timer_handle;\n+\n+\n+static double gbit(int64_t bytes, int64_t passed_ms) {\n+  double gbits = ((double)bytes / (1024 * 1024 * 1024)) * 8;\n+  return gbits / ((double)passed_ms / 1000);\n+}\n+\n+\n+static void show_stats(uv_handle_t *handle, int status) {\n+  int64_t diff;\n+\n+#if PRINT_STATS\n+  LOGF(\"connections: %d, write: %.1f gbit/s\\n\",\n+       write_sockets,\n+       gbit(nsent, STATS_INTERVAL));\n+#endif\n+\n+  /* Exit if the show is over */\n+  if (!--stats_left) {\n+\n+    uv_update_time();\n+    diff = uv_now() - start_time;\n+\n+    LOGF(\"pump%d_client: %.1f gbit/s\\n\", write_sockets,\n+        gbit(nsent_total, diff));\n+\n+    exit(0);\n+  }\n+\n+  /* Reset read and write counters */\n+  nrecv = 0;\n+  nsent = 0;\n+}\n+\n+\n+static void read_show_stats() {\n+  int64_t diff;\n+\n+  uv_update_time();\n+  diff = uv_now() - start_time;\n+\n+  LOGF(\"pump%d_server: %.1f gbit/s\\n\", max_read_sockets,\n+      gbit(nrecv_total, diff));\n+}\n+\n+\n+\n+void write_sockets_close_cb(uv_handle_t* handle) {\n+  /* If any client closes, the process is done. */\n+  exit(0);\n+}\n+\n+\n+void read_sockets_close_cb(uv_handle_t* handle) {\n+  free(handle);\n+  read_sockets--;\n+\n+  /* If it's past the first second and everyone has closed their connection\n+   * Then print stats.\n+   */\n+  if (uv_now() - start_time > 1000 && read_sockets == 0) {\n+    read_show_stats();\n+    uv_close((uv_handle_t*)&server, NULL);\n+  }\n+}\n+\n+\n+static void start_stats_collection() {\n+  uv_req_t* req = req_alloc();\n+  int r;\n+\n+  /* Show-stats timer */\n+  stats_left = STATS_COUNT;\n+  r = uv_timer_init(&timer_handle);\n+  ASSERT(r == 0);\n+  r = uv_timer_start(&timer_handle, show_stats, STATS_INTERVAL, STATS_INTERVAL);\n+  ASSERT(r == 0);\n+\n+  uv_update_time();\n+  start_time = uv_now();\n+}\n+\n+\n+static void read_cb(uv_tcp_t* tcp, ssize_t bytes, uv_buf_t buf) {\n+  if (nrecv_total == 0) {\n+    ASSERT(start_time == 0);\n+    uv_update_time();\n+    start_time = uv_now();\n+  }\n+\n+  if (bytes < 0) {\n+    uv_close((uv_handle_t*)tcp, read_sockets_close_cb);\n+    return;\n+  }\n+\n+  buf_free(buf);\n+\n+  nrecv += bytes;\n+  nrecv_total += bytes;\n+}\n+\n+\n+static void write_cb(uv_req_t *req, int status) {\n+  uv_buf_t* buf = (uv_buf_t*) req->data;\n+\n+  ASSERT(status == 0);\n+\n+  req_free(req);\n+\n+  nsent += sizeof write_buffer;\n+  nsent_total += sizeof write_buffer;\n+\n+  do_write((uv_tcp_t*)req->handle);\n+}\n+\n+\n+static void do_write(uv_tcp_t* tcp) {\n+  uv_req_t* req;\n+  uv_buf_t buf;\n+  int r;\n+\n+  buf.base = (char*) &write_buffer;\n+  buf.len = sizeof write_buffer;\n+\n+  while (tcp->write_queue_size == 0) {\n+    req = req_alloc();\n+    uv_req_init(req, (uv_handle_t*)tcp, write_cb);\n+\n+    r = uv_write(req, &buf, 1);\n+    ASSERT(r == 0);\n+  }\n+}\n+\n+\n+static void connect_cb(uv_req_t* req, int status) {\n+  int i;\n+\n+  if (status) LOG(uv_strerror(uv_last_error()));\n+  ASSERT(status == 0);\n+\n+  write_sockets++;\n+  req_free(req);\n+\n+  maybe_connect_some();\n+\n+  if (write_sockets == TARGET_CONNECTIONS) {\n+    start_stats_collection();\n+\n+    /* Yay! start writing */\n+    for (i = 0; i < write_sockets; i++) {\n+      do_write(&write_handles[i]);\n+    }\n+  }\n+}\n+\n+\n+static void maybe_connect_some() {\n+  uv_req_t* req;\n+  uv_tcp_t* tcp;\n+  int r;\n+\n+  while (max_connect_socket < TARGET_CONNECTIONS &&\n+         max_connect_socket < write_sockets + MAX_SIMULTANEOUS_CONNECTS) {\n+    tcp = &write_handles[max_connect_socket++];\n+\n+    r = uv_tcp_init(tcp);\n+    ASSERT(r == 0);\n+\n+    req = req_alloc();\n+    uv_req_init(req, (uv_handle_t*)tcp, connect_cb);\n+    r = uv_connect(req, connect_addr);\n+    ASSERT(r == 0);\n+  }\n+}\n+\n+\n+static void connection_cb(uv_tcp_t* s, int status) {\n+  uv_tcp_t* tcp;\n+  int r;\n+\n+  ASSERT(&server == s);\n+  ASSERT(status == 0);\n+\n+  tcp = malloc(sizeof(uv_tcp_t));\n+\n+  uv_tcp_init(tcp);\n+\n+  r = uv_accept(s, tcp);\n+  ASSERT(r == 0);\n+\n+  r = uv_read_start(tcp, buf_alloc, read_cb);\n+  ASSERT(r == 0);\n+\n+  read_sockets++;\n+  max_read_sockets++;\n+}\n+\n+\n+/*\n+ * Request allocator\n+ */\n+\n+typedef struct req_list_s {\n+  uv_req_t uv_req;\n+  struct req_list_s* next;\n+} req_list_t;\n+\n+\n+static req_list_t* req_freelist = NULL;\n+\n+\n+static uv_req_t* req_alloc() {\n+  req_list_t* req;\n+\n+  req = req_freelist;\n+  if (req != NULL) {\n+    req_freelist = req->next;\n+    return (uv_req_t*) req;\n+  }\n+\n+  req = (req_list_t*) malloc(sizeof *req);\n+  return (uv_req_t*) req;\n+}\n+\n+\n+static void req_free(uv_req_t* uv_req) {\n+  req_list_t* req = (req_list_t*) uv_req;\n+\n+  req->next = req_freelist;\n+  req_freelist = req;\n+}\n+\n+\n+/*\n+ * Buffer allocator\n+ */\n+\n+typedef struct buf_list_s {\n+  uv_buf_t uv_buf_t;\n+  struct buf_list_s* next;\n+} buf_list_t;\n+\n+\n+static buf_list_t* buf_freelist = NULL;\n+\n+\n+static uv_buf_t buf_alloc(uv_tcp_t* tcp, size_t size) {\n+  buf_list_t* buf;\n+\n+  buf = buf_freelist;\n+  if (buf != NULL) {\n+    buf_freelist = buf->next;\n+    return buf->uv_buf_t;\n+  }\n+\n+  buf = (buf_list_t*) malloc(size + sizeof *buf);\n+  buf->uv_buf_t.len = (unsigned int)size;\n+  buf->uv_buf_t.base = ((char*) buf) + sizeof *buf;\n+\n+  return buf->uv_buf_t;\n+}\n+\n+\n+static void buf_free(uv_buf_t uv_buf_t) {\n+  buf_list_t* buf = (buf_list_t*) (uv_buf_t.base - sizeof *buf);\n+\n+  buf->next = buf_freelist;\n+  buf_freelist = buf;\n+}\n+\n+\n+HELPER_IMPL(pump_server) {\n+  int r;\n+\n+  uv_init();\n+  listen_addr = uv_ip4_addr(\"0.0.0.0\", TEST_PORT);\n+\n+  /* Server */\n+  r = uv_tcp_init(&server);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server, listen_addr);\n+  ASSERT(r == 0);\n+  r = uv_listen(&server, MAX_WRITE_HANDLES, connection_cb);\n+  ASSERT(r == 0);\n+\n+  uv_run();\n+\n+  return 0;\n+}\n+\n+\n+void pump(int n) {\n+  ASSERT(n <= MAX_WRITE_HANDLES);\n+  TARGET_CONNECTIONS = n;\n+\n+  uv_init();\n+\n+  connect_addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+\n+  /* Start making connections */\n+  maybe_connect_some();\n+\n+  uv_run();\n+}\n+\n+\n+BENCHMARK_IMPL(pump100_client) {\n+  pump(100);\n+  return 0;\n+}\n+\n+\n+BENCHMARK_IMPL(pump1_client) {\n+  pump(1);\n+  return 0;\n+}"}, {"sha": "a5f573feec61706896825a89db00847097126d16", "filename": "src/rt/libuv/test/benchmark-sizes.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,35 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"task.h\"\n+#include \"../uv.h\"\n+\n+\n+BENCHMARK_IMPL(sizes) {\n+  LOGF(\"uv_req_t: %lu bytes\\n\", sizeof(uv_req_t));\n+  LOGF(\"uv_tcp_t: %lu bytes\\n\", sizeof(uv_tcp_t));\n+  LOGF(\"uv_prepare_t: %lu bytes\\n\", sizeof(uv_prepare_t));\n+  LOGF(\"uv_check_t: %lu bytes\\n\", sizeof(uv_check_t));\n+  LOGF(\"uv_idle_t: %lu bytes\\n\", sizeof(uv_idle_t));\n+  LOGF(\"uv_async_t: %lu bytes\\n\", sizeof(uv_async_t));\n+  LOGF(\"uv_timer_t: %lu bytes\\n\", sizeof(uv_timer_t));\n+  return 0;\n+}"}, {"sha": "a3f8f29ed10774f02679b9e78b9259ac520cc158", "filename": "src/rt/libuv/test/echo-server.c", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,188 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+typedef struct {\n+  uv_req_t req;\n+  uv_buf_t buf;\n+} write_req_t;\n+\n+\n+static int server_closed;\n+static uv_tcp_t server;\n+\n+\n+static void after_write(uv_req_t* req, int status);\n+static void after_read(uv_tcp_t*, ssize_t nread, uv_buf_t buf);\n+static void on_close(uv_handle_t* peer);\n+static void on_server_close(uv_handle_t* handle);\n+static void on_connection(uv_tcp_t*, int status);\n+\n+\n+static void after_write(uv_req_t* req, int status) {\n+  write_req_t* wr;\n+\n+  if (status) {\n+    uv_err_t err = uv_last_error();\n+    fprintf(stderr, \"uv_write error: %s\\n\", uv_strerror(err));\n+    ASSERT(0);\n+  }\n+\n+  wr = (write_req_t*) req;\n+\n+  /* Free the read/write buffer and the request */\n+  free(wr->buf.base);\n+  free(wr);\n+}\n+\n+\n+static void after_shutdown(uv_req_t* req, int status) {\n+  uv_close(req->handle, on_close);\n+  free(req);\n+}\n+\n+\n+static void after_read(uv_tcp_t* handle, ssize_t nread, uv_buf_t buf) {\n+  int i;\n+  write_req_t *wr;\n+  uv_req_t* req;\n+\n+  if (nread < 0) {\n+    /* Error or EOF */\n+    ASSERT (uv_last_error().code == UV_EOF);\n+\n+    if (buf.base) {\n+      free(buf.base);\n+    }\n+\n+    req = (uv_req_t*) malloc(sizeof *req);\n+    uv_req_init(req, (uv_handle_t*)handle, after_shutdown);\n+    uv_shutdown(req);\n+\n+    return;\n+  }\n+\n+  if (nread == 0) {\n+    /* Everything OK, but nothing read. */\n+    free(buf.base);\n+    return;\n+  }\n+\n+  /* Scan for the letter Q which signals that we should quit. */\n+  if (!server_closed) {\n+    for (i = 0; i < nread; i++) {\n+      if (buf.base[i] == 'Q') {\n+        uv_close((uv_handle_t*)&server, on_server_close);\n+        server_closed = 1;\n+      }\n+    }\n+  }\n+\n+  wr = (write_req_t*) malloc(sizeof *wr);\n+\n+  uv_req_init(&wr->req, (uv_handle_t*)handle, after_write);\n+  wr->buf.base = buf.base;\n+  wr->buf.len = nread;\n+  if (uv_write(&wr->req, &wr->buf, 1)) {\n+    FATAL(\"uv_write failed\");\n+  }\n+}\n+\n+\n+static void on_close(uv_handle_t* peer) {\n+  free(peer);\n+}\n+\n+\n+static uv_buf_t echo_alloc(uv_tcp_t* handle, size_t suggested_size) {\n+  uv_buf_t buf;\n+  buf.base = (char*) malloc(suggested_size);\n+  buf.len = suggested_size;\n+  return buf;\n+}\n+\n+\n+static void on_connection(uv_tcp_t* server, int status) {\n+  uv_tcp_t* handle;\n+  int r;\n+\n+  ASSERT(status == 0);\n+\n+  handle = (uv_tcp_t*) malloc(sizeof *handle);\n+  ASSERT(handle != NULL);\n+\n+  uv_tcp_init(handle);\n+\n+  r = uv_accept(server, handle);\n+  ASSERT(r == 0);\n+\n+  r = uv_read_start(handle, echo_alloc, after_read);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static void on_server_close(uv_handle_t* handle) {\n+  ASSERT(handle == (uv_handle_t*)&server);\n+}\n+\n+\n+static int echo_start(int port) {\n+  struct sockaddr_in addr = uv_ip4_addr(\"0.0.0.0\", port);\n+  int r;\n+\n+  r = uv_tcp_init(&server);\n+  if (r) {\n+    /* TODO: Error codes */\n+    fprintf(stderr, \"Socket creation error\\n\");\n+    return 1;\n+  }\n+\n+  r = uv_bind(&server, addr);\n+  if (r) {\n+    /* TODO: Error codes */\n+    fprintf(stderr, \"Bind error\\n\");\n+    return 1;\n+  }\n+\n+  r = uv_listen(&server, 128, on_connection);\n+  if (r) {\n+    /* TODO: Error codes */\n+    fprintf(stderr, \"Listen error\\n\");\n+    return 1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+HELPER_IMPL(echo_server) {\n+  uv_init();\n+  if (echo_start(TEST_PORT))\n+    return 1;\n+\n+  uv_run();\n+  return 0;\n+}"}, {"sha": "43d25a63bbd4d619d55cad176df8c2fae26a69ae", "filename": "src/rt/libuv/test/run-benchmarks.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,59 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"runner.h\"\n+#include \"task.h\"\n+\n+/* Actual benchmarks and helpers are defined in benchmark-list.h */\n+#include \"benchmark-list.h\"\n+\n+\n+/* The time in milliseconds after which a single benchmark times out. */\n+#define BENCHMARK_TIMEOUT  60000\n+\n+\n+int main(int argc, char **argv) {\n+  task_entry_t *task;\n+\n+  platform_init(argc, argv);\n+\n+  if (argc > 1) {\n+    /* A specific process was requested. */\n+    return run_process(argv[1]);\n+\n+  } else {\n+    /* Run all benchmarks. */\n+    task = (task_entry_t*)&TASKS;\n+    for (task = (task_entry_t*)&TASKS; task->main; task++) {\n+      if (task->is_helper) {\n+        continue;\n+      }\n+\n+      run_task(task, BENCHMARK_TIMEOUT, 1);\n+    }\n+    LOG(\"Done.\\n\");\n+\n+    return 0;\n+  }\n+}"}, {"sha": "f83006bdd8171ed78f46986ad0f4fa8cf6fa9c79", "filename": "src/rt/libuv/test/run-tests.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,86 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"runner.h\"\n+#include \"task.h\"\n+\n+/* Actual tests and helpers are defined in test-list.h */\n+#include \"test-list.h\"\n+\n+\n+/* The time in milliseconds after which a single test times out. */\n+#define TEST_TIMEOUT  5000\n+\n+\n+static void log_progress(int total, int passed, int failed, char* name) {\n+  LOGF(\"[%% %3d|+ %3d|- %3d]: %s\", (passed + failed) / total * 100,\n+      passed, failed, name);\n+}\n+\n+\n+int main(int argc, char **argv) {\n+  int total, passed, failed;\n+  task_entry_t* task;\n+\n+  platform_init(argc, argv);\n+\n+  if (argc > 1) {\n+    /* A specific process was requested. */\n+    return run_process(argv[1]);\n+\n+  } else {\n+    /* Count the number of tests. */\n+    total = 0;\n+    task = (task_entry_t*)&TASKS;\n+    for (task = (task_entry_t*)&TASKS; task->main; task++) {\n+      if (!task->is_helper) {\n+        total++;\n+      }\n+    }\n+\n+    /* Run all tests. */\n+    passed = 0;\n+    failed = 0;\n+    task = (task_entry_t*)&TASKS;\n+    for (task = (task_entry_t*)&TASKS; task->main; task++) {\n+      if (task->is_helper) {\n+        continue;\n+      }\n+\n+      rewind_cursor();\n+      log_progress(total, passed, failed, task->task_name);\n+\n+      if (run_task(task, TEST_TIMEOUT, 0)) {\n+        passed++;\n+      } else {\n+        failed++;\n+      }\n+    }\n+\n+    rewind_cursor();\n+    log_progress(total, passed, failed, \"Done.\\n\");\n+\n+    return 0;\n+  }\n+}"}, {"sha": "139b671942fe417423edaf2983c91ed9e22efc49", "filename": "src/rt/libuv/test/runner-unix.c", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,335 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"runner-unix.h\"\n+#include \"runner.h\"\n+\n+#include <stdint.h> /* uintptr_t */\n+\n+#include <unistd.h> /* usleep */\n+#include <string.h> /* strdup */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <signal.h>\n+#include <sys/wait.h>\n+#include <sys/stat.h>\n+#include <assert.h>\n+\n+#include <sys/select.h>\n+#include <pthread.h>\n+\n+#ifdef __APPLE__\n+#include <mach-o/dyld.h> /* _NSGetExecutablePath */\n+\n+static void get_executable_path() {\n+  uint32_t bufsize = sizeof(executable_path);\n+  _NSGetExecutablePath(executable_path, &bufsize);\n+}\n+#endif\n+\n+#ifdef __linux__\n+static void get_executable_path() {\n+  if (!executable_path[0]) {\n+    readlink(\"/proc/self/exe\", executable_path, PATHMAX - 1);\n+  }\n+}\n+#endif\n+\n+\n+/* Do platform-specific initialization. */\n+void platform_init(int argc, char **argv) {\n+  /* Disable stdio output buffering. */\n+  setvbuf(stdout, NULL, _IONBF, 0);\n+  setvbuf(stderr, NULL, _IONBF, 0);\n+#ifdef get_executable_path\n+  get_executable_path();\n+#else\n+  strcpy(executable_path, argv[0]);\n+#endif\n+}\n+\n+\n+/* Invoke \"arv[0] test-name\". Store process info in *p. */\n+/* Make sure that all stdio output of the processes is buffered up. */\n+int process_start(char* name, process_info_t* p) {\n+  FILE* stdout_file = tmpfile();\n+  if (!stdout_file) {\n+    perror(\"tmpfile\");\n+    return -1;\n+  }\n+\n+  p->terminated = 0;\n+  p->status = 0;\n+\n+  pid_t pid = fork();\n+\n+  if (pid < 0) {\n+    perror(\"vfork\");\n+    return -1;\n+  }\n+\n+  if (pid == 0) {\n+    /* child */\n+    dup2(fileno(stdout_file), STDOUT_FILENO);\n+    dup2(fileno(stdout_file), STDERR_FILENO);\n+\n+    char* args[3] = { executable_path, name, NULL };\n+    execvp(executable_path, args);\n+    perror(\"execvp()\");\n+    _exit(127);\n+  }\n+\n+  /* parent */\n+  p->pid = pid;\n+  p->name = strdup(name);\n+  p->stdout_file = stdout_file;\n+\n+  return 0;\n+}\n+\n+\n+typedef struct {\n+  int pipe[2];\n+  process_info_t* vec;\n+  int n;\n+} dowait_args;\n+\n+\n+/* This function is run inside a pthread. We do this so that we can possibly\n+ * timeout.\n+ */\n+static void* dowait(void* data) {\n+  dowait_args* args = data;\n+\n+  int i, status, r;\n+  process_info_t* p;\n+\n+  for (i = 0; i < args->n; i++) {\n+    p = (process_info_t*)(args->vec + i * sizeof(process_info_t));\n+    if (p->terminated) continue;\n+    status = 0;\n+    r = waitpid(p->pid, &p->status, 0);\n+    if (r < 0) {\n+      perror(\"waitpid\");\n+      return NULL;\n+    }\n+    p->terminated = 1;\n+  }\n+\n+  if (args->pipe[1] >= 0) {\n+    /* Write a character to the main thread to notify it about this. */\n+    char c = 0;\n+    write(args->pipe[1], &c, 1);\n+  }\n+\n+  return NULL;\n+}\n+\n+\n+/* Wait for all `n` processes in `vec` to terminate. */\n+/* Time out after `timeout` msec, or never if timeout == -1 */\n+/* Return 0 if all processes are terminated, -1 on error, -2 on timeout. */\n+int process_wait(process_info_t* vec, int n, int timeout) {\n+  int i;\n+  process_info_t* p;\n+  dowait_args args;\n+  args.vec = vec;\n+  args.n = n;\n+  args.pipe[0] = -1;\n+  args.pipe[1] = -1;\n+\n+  /* The simple case is where there is no timeout */\n+  if (timeout == -1) {\n+    dowait(&args);\n+    return 0;\n+  }\n+\n+  /* Hard case. Do the wait with a timeout.\n+   *\n+   * Assumption: we are the only ones making this call right now. Otherwise\n+   * we'd need to lock vec.\n+   */\n+\n+  pthread_t tid;\n+  int retval;\n+\n+  int r = pipe((int*)&(args.pipe));\n+  if (r) {\n+    perror(\"pipe()\");\n+    return -1;\n+  }\n+\n+  r = pthread_create(&tid, NULL, dowait, &args);\n+  if (r) {\n+    perror(\"pthread_create()\");\n+    retval = -1;\n+    goto terminate;\n+  }\n+\n+  struct timeval tv;\n+  tv.tv_sec = timeout / 1000;\n+  tv.tv_usec = 0;\n+\n+  fd_set fds;\n+  FD_ZERO(&fds);\n+  FD_SET(args.pipe[0], &fds);\n+\n+  r = select(args.pipe[0] + 1, &fds, NULL, NULL, &tv);\n+\n+  if (r == -1) {\n+    perror(\"select()\");\n+    retval = -1;\n+\n+  } else if (r) {\n+    /* The thread completed successfully. */\n+    retval = 0;\n+\n+  } else {\n+    /* Timeout. Kill all the children. */\n+    for (i = 0; i < n; i++) {\n+      p = (process_info_t*)(vec + i * sizeof(process_info_t));\n+      kill(p->pid, SIGTERM);\n+    }\n+    retval = -2;\n+\n+    /* Wait for thread to finish. */\n+    r = pthread_join(tid, NULL);\n+    if (r) {\n+      perror(\"pthread_join\");\n+      retval = -1;\n+    }\n+  }\n+\n+terminate:\n+  close(args.pipe[0]);\n+  close(args.pipe[1]);\n+  return retval;\n+}\n+\n+\n+/* Returns the number of bytes in the stdio output buffer for process `p`. */\n+long int process_output_size(process_info_t *p) {\n+  /* Size of the p->stdout_file */\n+  struct stat buf;\n+\n+  int r = fstat(fileno(p->stdout_file), &buf);\n+  if (r < 0) {\n+    return -1;\n+  }\n+\n+  return (long)buf.st_size;\n+}\n+\n+\n+/* Copy the contents of the stdio output buffer to `fd`. */\n+int process_copy_output(process_info_t *p, int fd) {\n+  int r = fseek(p->stdout_file, 0, SEEK_SET);\n+  if (r < 0) {\n+    perror(\"fseek\");\n+    return -1;\n+  }\n+\n+  size_t nread, nwritten;\n+  char buf[1024];\n+\n+  while ((nread = read(fileno(p->stdout_file), buf, 1024)) > 0) {\n+    nwritten = write(fd, buf, nread);\n+    /* TODO: what if write doesn't write the whole buffer... */\n+    if (nwritten < 0) {\n+      perror(\"write\");\n+      return -1;\n+    }\n+  }\n+\n+  if (nread < 0) {\n+    perror(\"read\");\n+    return -1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+/* Return the name that was specified when `p` was started by process_start */\n+char* process_get_name(process_info_t *p) {\n+  return p->name;\n+}\n+\n+\n+/* Terminate process `p`. */\n+int process_terminate(process_info_t *p) {\n+  return kill(p->pid, SIGTERM);\n+}\n+\n+\n+/* Return the exit code of process p. */\n+/* On error, return -1. */\n+int process_reap(process_info_t *p) {\n+  if (WIFEXITED(p->status)) {\n+    return WEXITSTATUS(p->status);\n+  } else  {\n+    return p->status; /* ? */\n+  }\n+}\n+\n+\n+/* Clean up after terminating process `p` (e.g. free the output buffer etc.). */\n+void process_cleanup(process_info_t *p) {\n+  fclose(p->stdout_file);\n+  free(p->name);\n+}\n+\n+\n+/* Move the console cursor one line up and back to the first column. */\n+void rewind_cursor() {\n+  fprintf(stderr, \"\\033[2K\\r\");\n+}\n+\n+\n+typedef void* (*uv_thread_cb)(void* arg);\n+\n+\n+uintptr_t uv_create_thread(void (*entry)(void* arg), void* arg) {\n+  pthread_t t;\n+  uv_thread_cb cb = (uv_thread_cb)entry;\n+  int r = pthread_create(&t, NULL, cb, arg);\n+\n+  if (r) {\n+    return 0;\n+  }\n+\n+  return (uintptr_t)t;\n+}\n+\n+\n+/* Wait for a thread to terminate. Should return 0 if the thread ended, -1 on\n+ * error.\n+ */\n+int uv_wait_thread(uintptr_t thread_id) {\n+  return pthread_join((pthread_t)thread_id, NULL);\n+}\n+\n+\n+/* Pause the calling thread for a number of milliseconds. */\n+void uv_sleep(int msec) {\n+  usleep(msec);\n+}"}, {"sha": "e21847f92c08658a9ff0fbd5a2b5b53272a33a39", "filename": "src/rt/libuv/test/runner-unix.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#ifndef TEST_RUNNER_UNIX_H\n+#define TEST_RUNNER_UNIX_H\n+\n+#include <sys/types.h>\n+#include <stdio.h> /* FILE */\n+\n+typedef struct {\n+  FILE* stdout_file;\n+  pid_t pid;\n+  char* name;\n+  int status;\n+  int terminated;\n+} process_info_t;\n+\n+#endif  /* TEST_RUNNER_UNIX_H */"}, {"sha": "09458a6b5ceb0f9c9e52dd1c8906df4a8fc9120f", "filename": "src/rt/libuv/test/runner-win.c", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,331 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include <io.h>\n+#include <malloc.h>\n+#include <stdio.h>\n+#include <process.h>\n+#include <windows.h>\n+\n+#include \"task.h\"\n+#include \"runner.h\"\n+\n+\n+/*\n+ * Define the stuff that MinGW doesn't have\n+ */\n+#ifndef GetFileSizeEx\n+  WINBASEAPI BOOL WINAPI GetFileSizeEx(HANDLE hFile,\n+                                       PLARGE_INTEGER lpFileSize);\n+#endif\n+\n+\n+/* Do platform-specific initialization. */\n+void platform_init(int argc, char **argv) {\n+  /* Disable the \"application crashed\" popup. */\n+  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX |\n+      SEM_NOOPENFILEERRORBOX);\n+\n+  /* Disable stdio output buffering. */\n+  setvbuf(stdout, NULL, _IONBF, 0);\n+  setvbuf(stderr, NULL, _IONBF, 0);\n+\n+  strcpy(executable_path, argv[0]);\n+}\n+\n+\n+int process_start(char *name, process_info_t *p) {\n+  HANDLE file = INVALID_HANDLE_VALUE;\n+  HANDLE nul = INVALID_HANDLE_VALUE;\n+  WCHAR path[MAX_PATH], filename[MAX_PATH];\n+  WCHAR image[MAX_PATH + 1];\n+  WCHAR args[MAX_PATH * 2];\n+  STARTUPINFOW si;\n+  PROCESS_INFORMATION pi;\n+  DWORD result;\n+\n+  if (GetTempPathW(sizeof(path) / sizeof(WCHAR), (WCHAR*)&path) == 0)\n+    goto error;\n+  if (GetTempFileNameW((WCHAR*)&path, L\"uv\", 0, (WCHAR*)&filename) == 0)\n+    goto error;\n+\n+  file = CreateFileW((WCHAR*)filename,\n+                     GENERIC_READ | GENERIC_WRITE,\n+                     0,\n+                     NULL,\n+                     CREATE_ALWAYS,\n+                     FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,\n+                     NULL);\n+  if (file == INVALID_HANDLE_VALUE)\n+    goto error;\n+\n+  if (!SetHandleInformation(file, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))\n+    goto error;\n+\n+  nul = CreateFileA(\"nul\",\n+                    GENERIC_READ,\n+                    FILE_SHARE_READ | FILE_SHARE_WRITE,\n+                    NULL,\n+                    OPEN_EXISTING,\n+                    FILE_ATTRIBUTE_NORMAL,\n+                    NULL);\n+  if (nul == INVALID_HANDLE_VALUE)\n+    goto error;\n+\n+  if (!SetHandleInformation(nul, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT))\n+    goto error;\n+\n+  result = GetModuleFileNameW(NULL, (WCHAR*)&image, sizeof(image) / sizeof(WCHAR));\n+  if (result == 0 || result == sizeof(image))\n+    goto error;\n+\n+  if (_snwprintf((wchar_t*)&args,\n+                 sizeof(args) / sizeof(wchar_t),\n+                 L\"\\\"%s\\\" %S\",\n+                 image,\n+                 name) < 0)\n+    goto error;\n+\n+  memset((void*)&si, 0, sizeof(si));\n+  si.cb = sizeof(si);\n+  si.dwFlags = STARTF_USESTDHANDLES;\n+  si.hStdInput = nul;\n+  si.hStdOutput = file;\n+  si.hStdError = file;\n+\n+  if (!CreateProcessW(image, args, NULL, NULL, TRUE,\n+                      0, NULL, NULL, &si, &pi))\n+    goto error;\n+\n+  CloseHandle(pi.hThread);\n+\n+  SetHandleInformation(nul, HANDLE_FLAG_INHERIT, 0);\n+  SetHandleInformation(file, HANDLE_FLAG_INHERIT, 0);\n+\n+  p->stdio_in = nul;\n+  p->stdio_out = file;\n+  p->process = pi.hProcess;\n+  p->name = name;\n+\n+  return 0;\n+\n+error:\n+  if (file != INVALID_HANDLE_VALUE)\n+    CloseHandle(file);\n+  if (nul != INVALID_HANDLE_VALUE)\n+    CloseHandle(nul);\n+\n+  return -1;\n+}\n+\n+\n+/* Timeout is is msecs. Set timeout < 0 to never time out. */\n+/* Returns 0 when all processes are terminated, -2 on timeout. */\n+int process_wait(process_info_t *vec, int n, int timeout) {\n+  int i;\n+  HANDLE handles[MAXIMUM_WAIT_OBJECTS];\n+  DWORD timeout_api, result;\n+\n+  /* If there's nothing to wait for, return immedately. */\n+  if (n == 0)\n+    return 0;\n+\n+  ASSERT(n <= MAXIMUM_WAIT_OBJECTS);\n+\n+  for (i = 0; i < n; i++)\n+    handles[i] = vec[i].process;\n+\n+  if (timeout >= 0) {\n+    timeout_api = (DWORD)timeout;\n+  } else {\n+    timeout_api = INFINITE;\n+  }\n+\n+  result = WaitForMultipleObjects(n, handles, TRUE, timeout_api);\n+\n+  if (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + n) {\n+    /* All processes are terminated. */\n+    return 0;\n+  }\n+  if (result == WAIT_TIMEOUT) {\n+    return -2;\n+  }\n+  return -1;\n+}\n+\n+\n+long int process_output_size(process_info_t *p) {\n+  LARGE_INTEGER size;\n+  if (!GetFileSizeEx(p->stdio_out, &size))\n+    return -1;\n+  return (long int)size.QuadPart;\n+}\n+\n+\n+int process_copy_output(process_info_t *p, int fd) {\n+  DWORD read;\n+  char buf[1024];\n+\n+  if (SetFilePointer(p->stdio_out, 0, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n+    return -1;\n+\n+  while (ReadFile(p->stdio_out, (void*)&buf, sizeof(buf), &read, NULL) &&\n+         read > 0)\n+    write(fd, buf, read);\n+\n+  if (GetLastError() != ERROR_HANDLE_EOF)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+\n+char* process_get_name(process_info_t *p) {\n+  return p->name;\n+}\n+\n+\n+int process_terminate(process_info_t *p) {\n+  if (!TerminateProcess(p->process, 1))\n+    return -1;\n+  return 0;\n+}\n+\n+\n+int process_reap(process_info_t *p) {\n+  DWORD exitCode;\n+  if (!GetExitCodeProcess(p->process, &exitCode))\n+    return -1;\n+  return (int)exitCode;\n+}\n+\n+\n+void process_cleanup(process_info_t *p) {\n+  CloseHandle(p->process);\n+  CloseHandle(p->stdio_in);\n+  CloseHandle(p->stdio_out);\n+}\n+\n+\n+static int clear_line() {\n+  HANDLE handle;\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+  COORD coord;\n+  DWORD written;\n+\n+  handle = (HANDLE)_get_osfhandle(fileno(stderr));\n+  if (handle == INVALID_HANDLE_VALUE)\n+    return -1;\n+\n+  if (!GetConsoleScreenBufferInfo(handle, &info))\n+    return -1;\n+\n+  coord = info.dwCursorPosition;\n+  if (coord.Y <= 0)\n+    return -1;\n+\n+  coord.X = 0;\n+\n+  if (!SetConsoleCursorPosition(handle, coord))\n+    return -1;\n+\n+  if (!FillConsoleOutputCharacterW(handle, 0x20, info.dwSize.X, coord, &written))\n+    return -1;\n+\n+  return 0;\n+}\n+\n+\n+void rewind_cursor() {\n+  if (clear_line() == -1) {\n+    /* If clear_line fails (stdout is not a console), print a newline. */\n+    fprintf(stderr, \"\\n\");\n+  }\n+}\n+\n+\n+typedef struct {\n+  void (*entry)(void* arg);\n+  void* arg;\n+} thread_info_t;\n+\n+\n+static unsigned __stdcall create_thread_helper(void* info) {\n+  /* Copy thread info locally, then free it */\n+  void (*entry)(void* arg) = ((thread_info_t*) info)->entry;\n+  void* arg = ((thread_info_t*) info)->arg;\n+\n+  free(info);\n+\n+  /* Run the actual thread proc */\n+  entry(arg);\n+\n+  /* Finalize */\n+  _endthreadex(0);\n+  return 0;\n+}\n+\n+\n+/* Create a thread. Returns the thread identifier, or 0 on failure. */\n+uintptr_t uv_create_thread(void (*entry)(void* arg), void* arg) {\n+  uintptr_t result;\n+  thread_info_t* info;\n+\n+  info = (thread_info_t*) malloc(sizeof *info);\n+  if (info == NULL) {\n+    return 0;\n+  }\n+\n+  info->entry = entry;\n+  info->arg = arg;\n+\n+  result = _beginthreadex(NULL,\n+                          0,\n+                          &create_thread_helper,\n+                          (void*) info,\n+                          0,\n+                          NULL);\n+\n+  if (result == 0) {\n+    free(info);\n+    return 0;\n+  }\n+\n+  return result;\n+}\n+\n+\n+/* Wait for a thread to terminate. Should return 0 if the thread ended, -1 on\n+ * error.\n+ */\n+int uv_wait_thread(uintptr_t thread_id) {\n+  if (WaitForSingleObject((HANDLE)thread_id, INFINITE) != WAIT_OBJECT_0) {\n+    return -1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+/* Pause the calling thread for a number of milliseconds. */\n+void uv_sleep(int msec) {\n+  Sleep(msec);\n+}"}, {"sha": "a2c8b6f3d97d34c491cdcedb64746e37332c995d", "filename": "src/rt/libuv/test/runner-win.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-win.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+/* Don't complain about _snprintf being unsecure. */\n+#define _CRT_SECURE_NO_WARNINGS\n+\n+/* Dont complain about write(), fileno() etc. being deprecated. */\n+#pragma warning(disable : 4996)\n+\n+\n+#include <windows.h>\n+#include <stdio.h>\n+\n+\n+/* Windows has no snprintf, only _snprintf. */\n+#define snprintf _snprintf\n+\n+\n+typedef struct {\n+  HANDLE process;\n+  HANDLE stdio_in;\n+  HANDLE stdio_out;\n+  char *name;\n+} process_info_t;"}, {"sha": "7b6590f67928b88cf8fb70d08c4dd71257ab9c00", "filename": "src/rt/libuv/test/runner.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,171 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include <string.h>\n+\n+#include \"runner.h\"\n+#include \"task.h\"\n+\n+char executable_path[PATHMAX] = { '\\0' };\n+\n+/* Start a specific process declared by TEST_ENTRY or TEST_HELPER. */\n+/* Returns the exit code of the specific process. */\n+int run_process(char* name) {\n+  task_entry_t *test;\n+\n+  for (test = (task_entry_t*)&TASKS; test->main; test++) {\n+    if (strcmp(name, test->process_name) == 0) {\n+      return test->main();\n+    }\n+  }\n+\n+  LOGF(\"Test process %s not found!\\n\", name);\n+  return 255;\n+}\n+\n+\n+/*\n+ * Runs all processes associated with a particular test or benchmark.\n+ * It returns 1 if the test succeeded, 0 if it failed.\n+ * If the test fails it prints diagnostic information.\n+ * If benchmark_output is nonzero, the output from the main process is\n+ * always shown.\n+ */\n+int run_task(task_entry_t *test, int timeout, int benchmark_output) {\n+  int i, result, success;\n+  char errmsg[256];\n+  task_entry_t *helper;\n+  int process_count;\n+  process_info_t processes[MAX_PROCESSES];\n+  process_info_t *main_process;\n+\n+  success = 0;\n+\n+  process_count = 0;\n+\n+  /* Start all helpers for this test first. */\n+  for (helper = (task_entry_t*)&TASKS; helper->main; helper++) {\n+    if (helper->is_helper &&\n+        strcmp(test->task_name, helper->task_name) == 0) {\n+      if (process_start(helper->process_name, &processes[process_count]) == -1) {\n+        snprintf((char*)&errmsg,\n+                 sizeof(errmsg),\n+                 \"process `%s` failed to start.\",\n+                 helper->process_name);\n+        goto finalize;\n+      }\n+      process_count++;\n+    }\n+  }\n+\n+  /* Wait a little bit to allow servers to start. Racy. */\n+  uv_sleep(100);\n+\n+  /* Start the main test process. */\n+  if (process_start(test->process_name, &processes[process_count]) == -1) {\n+    snprintf((char*)&errmsg, sizeof(errmsg), \"process `%s` failed to start.\",\n+        test->process_name);\n+    goto finalize;\n+  }\n+  main_process = &processes[process_count];\n+  process_count++;\n+\n+  /* Wait for the main process to terminate. */\n+  result = process_wait(main_process, 1, timeout);\n+  if (result == -1) {\n+    FATAL(\"process_wait failed\");\n+  } else if (result == -2) {\n+    snprintf((char*)&errmsg, sizeof(errmsg), \"timeout.\");\n+    goto finalize;\n+  }\n+\n+  /* Reap the main process. */\n+  result = process_reap(main_process);\n+  if (result != 0) {\n+    snprintf((char*)&errmsg, sizeof(errmsg), \"exit code %d.\", result);\n+    goto finalize;\n+  }\n+\n+  /* Yes! did it. */\n+  success = 1;\n+\n+finalize:\n+  /* Kill all (helper) processes that are still running. */\n+  for (i = 0; i < process_count; i++) {\n+    /* If terminate fails the process is probably already closed. */\n+    process_terminate(&processes[i]);\n+  }\n+\n+  /* Wait until all processes have really terminated. */\n+  if (process_wait((process_info_t*)&processes, process_count, -1) < 0) {\n+    FATAL(\"process_wait failed\");\n+  }\n+\n+  /* Show error and output from processes if the test failed. */\n+  if (!success) {\n+    LOGF(\"\\n`%s` failed: %s\\n\", test->task_name, errmsg);\n+\n+    for (i = 0; i < process_count; i++) {\n+      switch (process_output_size(&processes[i])) {\n+       case -1:\n+        LOGF(\"Output from process `%s`: (unavailable)\\n\",\n+             process_get_name(&processes[i]));\n+        break;\n+\n+       case 0:\n+        LOGF(\"Output from process `%s`: (no output)\\n\",\n+             process_get_name(&processes[i]));\n+        break;\n+\n+       default:\n+        LOGF(\"Output from process `%s`:\\n\", process_get_name(&processes[i]));\n+        process_copy_output(&processes[i], fileno(stderr));\n+        break;\n+      }\n+    }\n+    LOG(\"=============================================================\\n\");\n+\n+  /* In benchmark mode show concise output from the main process. */\n+  } else if (benchmark_output) {\n+    switch (process_output_size(main_process)) {\n+     case -1:\n+      LOGF(\"%s: (unavailabe)\\n\", test->task_name);\n+      break;\n+\n+     case 0:\n+      LOGF(\"%s: (no output)\\n\", test->task_name);\n+      break;\n+\n+     default:\n+      for (i = 0; i < process_count; i++) {\n+        process_copy_output(&processes[i], fileno(stderr));\n+      }\n+      break;\n+    }\n+  }\n+\n+  /* Clean up all process handles. */\n+  for (i = 0; i < process_count; i++) {\n+    process_cleanup(&processes[i]);\n+  }\n+\n+  return success;\n+}"}, {"sha": "11d498020a1ab1f2701d1c81d585f11e3ad8771c", "filename": "src/rt/libuv/test/runner.h", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Frunner.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,147 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#ifndef RUNNER_H_\n+#define RUNNER_H_\n+\n+\n+/*\n+ * The maximum number of processes (main + helpers) that a test / benchmark\n+ * can have.\n+ */\n+#define MAX_PROCESSES 8\n+\n+\n+/*\n+ * Struct to store both tests and to define helper processes for tasks.\n+ */\n+typedef struct {\n+  char *task_name;\n+  char *process_name;\n+  int (*main)();\n+  int is_helper;\n+} task_entry_t, bench_entry_t;\n+\n+\n+/* Runs an individual task; returns 1 if the test succeeded, 0 if it failed. */\n+/* If the test fails it prints diagnostic information. */\n+/* If benchmark_output is nonzero, the output from the main process is\n+/* always shown. */\n+int run_task(task_entry_t *test, int timeout, int benchmark_output);\n+\n+\n+/*\n+ * Macros used by test-list.h and benchmark-list.h.\n+ */\n+#define TASK_LIST_START                             \\\n+  task_entry_t TASKS[] = {\n+\n+#define TASK_LIST_END                               \\\n+    { 0, 0, 0, 0 }                                  \\\n+  };\n+\n+#define TEST_DECLARE(name)                          \\\n+  int run_test_##name();\n+\n+#define TEST_ENTRY(name)                            \\\n+    { #name, #name, &run_test_##name, 0 },\n+\n+#define BENCHMARK_DECLARE(name)                     \\\n+  int run_benchmark_##name();\n+\n+#define BENCHMARK_ENTRY(name)                       \\\n+    { #name, #name, &run_benchmark_##name, 0 },\n+\n+#define HELPER_DECLARE(name)                        \\\n+  int run_helper_##name();\n+\n+#define HELPER_ENTRY(task_name, name)               \\\n+    { #task_name, #name, &run_helper_##name, 1 },\n+\n+#define TEST_HELPER       HELPER_ENTRY\n+#define BENCHMARK_HELPER  HELPER_ENTRY\n+\n+#define PATHMAX 1024\n+extern char executable_path[PATHMAX];\n+\n+/*\n+ * Include platform-dependent definitions\n+ */\n+#ifdef _WIN32\n+# include \"runner-win.h\"\n+#else\n+# include \"runner-unix.h\"\n+#endif\n+\n+\n+/* The array that is filled by test-list.h or benchmark-list.h */\n+extern task_entry_t TASKS[];\n+\n+/* Start a specific process declared by TEST_ENTRY or TEST_HELPER. */\n+/* Returns the exit code of the specific process. */\n+int run_task(task_entry_t *test, int timeout, int benchmark_output);\n+\n+/* Start a specific process declared by TEST_ENTRY or TEST_HELPER. */\n+/* Returns the exit code of the specific process. */\n+int run_process(char* name);\n+\n+\n+/*\n+ * Stuff that should be implemented by test-runner-<platform>.h\n+ * All functions return 0 on success, -1 on failure, unless specified\n+ * otherwise.\n+ */\n+\n+/* Do platform-specific initialization. */\n+void platform_init();\n+\n+/* Invoke \"arv[0] test-name\". Store process info in *p. */\n+/* Make sure that all stdio output of the processes is buffered up. */\n+int process_start(char *name, process_info_t *p);\n+\n+/* Wait for all `n` processes in `vec` to terminate. */\n+/* Time out after `timeout` msec, or never if timeout == -1 */\n+/* Return 0 if all processes are terminated, -1 on error, -2 on timeout. */\n+int process_wait(process_info_t *vec, int n, int timeout);\n+\n+/* Returns the number of bytes in the stdio output buffer for process `p`. */\n+long int process_output_size(process_info_t *p);\n+\n+/* Copy the contents of the stdio output buffer to `fd`. */\n+int process_copy_output(process_info_t *p, int fd);\n+\n+/* Return the name that was specified when `p` was started by process_start */\n+char* process_get_name(process_info_t *p);\n+\n+/* Terminate process `p`. */\n+int process_terminate(process_info_t *p);\n+\n+/* Return the exit code of process p. */\n+/* On error, return -1. */\n+int process_reap(process_info_t *p);\n+\n+/* Clean up after terminating process `p` (e.g. free the output buffer etc.). */\n+void process_cleanup(process_info_t *p);\n+\n+/* Move the console cursor one line up and back to the first column. */\n+void rewind_cursor();\n+\n+#endif /* RUNNER_H_ */"}, {"sha": "8d9a1e8e0df8dbba796f77293b8182fe50f8c29a", "filename": "src/rt/libuv/test/task.h", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftask.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,89 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#ifndef TASK_H_\n+#define TASK_H_\n+\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define TEST_PORT 9123\n+#define TEST_PORT_2 9124\n+\n+\n+/* Log to stderr. */\n+#define LOG(...)    fprintf(stderr, \"%s\", __VA_ARGS__)\n+#define LOGF(...)   fprintf(stderr, __VA_ARGS__)\n+\n+/* Die with fatal error. */\n+#define FATAL(msg)                                        \\\n+  do {                                                    \\\n+    fprintf(stderr,                                       \\\n+            \"Fatal error in %s on line %d: %s\\n\",         \\\n+            __FILE__,                                     \\\n+            __LINE__,                                     \\\n+            msg);                                         \\\n+    abort();                                              \\\n+  } while (0)\n+\n+\n+\n+/* Have our own assert, so we are sure it does not get optimized away in\n+ * a release build.\n+ */\n+#define ASSERT(expr)                                      \\\n+ do {                                                     \\\n+  if (!(expr)) {                                          \\\n+    fprintf(stderr,                                       \\\n+            \"Assertion failed in %s on line %d: %s\\n\",    \\\n+            __FILE__,                                     \\\n+            __LINE__,                                     \\\n+            #expr);                                       \\\n+    abort();                                              \\\n+  }                                                       \\\n+ } while (0)\n+\n+\n+/* Just sugar for wrapping the main() for a task or helper. */\n+#define TEST_IMPL(name)   \\\n+  int run_test_##name()\n+\n+#define BENCHMARK_IMPL(name)  \\\n+  int run_benchmark_##name()\n+\n+#define HELPER_IMPL(name)  \\\n+  int run_helper_##name()\n+\n+\n+/* Create a thread. Returns the thread identifier, or 0 on failure. */\n+uintptr_t uv_create_thread(void (*entry)(void* arg), void* arg);\n+\n+/* Wait for a thread to terminate. Should return 0 if the thread ended, -1 on\n+ * error.\n+ */\n+int uv_wait_thread(uintptr_t thread_id);\n+\n+/* Pause the calling thread for a number of milliseconds. */\n+void uv_sleep(int msec);\n+\n+#endif /* TASK_H_ */"}, {"sha": "d820bf26f60c25b9b233731b14cb37b1c744c764", "filename": "src/rt/libuv/test/test-async.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,223 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+static uv_prepare_t prepare_handle;\n+\n+static uv_async_t async1_handle;\n+/* static uv_handle_t async2_handle; */\n+\n+static int prepare_cb_called = 0;\n+\n+static volatile int async1_cb_called = 0;\n+static int async1_closed = 0;\n+/* static volatile int async2_cb_called = 0; */\n+\n+static int close_cb_called = 0;\n+\n+static uintptr_t thread1_id = 0;\n+#if 0\n+static uintptr_t thread2_id = 0;\n+static uintptr_t thread3_id = 0;\n+#endif\n+\n+\n+/* Thread 1 makes sure that async1_cb_called reaches 3 before exiting. */\n+void thread1_entry(void *arg) {\n+  int state = 0;\n+\n+  uv_sleep(50);\n+\n+  while (1) {\n+    switch (async1_cb_called) {\n+      case 0:\n+        uv_async_send(&async1_handle);\n+        break;\n+\n+      case 1:\n+        uv_async_send(&async1_handle);\n+        break;\n+\n+      case 2:\n+        uv_async_send(&async1_handle);\n+        break;\n+\n+      default:\n+        return;\n+    }\n+  }\n+}\n+\n+#if 0\n+/* Thread 2 calls uv_async_send on async_handle_2 8 times. */\n+void thread2_entry(void *arg) {\n+  int i;\n+\n+  while (1) {\n+    switch (async1_cb_called) {\n+      case 0:\n+        uv_async_send(&async2_handle);\n+        break;\n+\n+      case 1:\n+        uv_async_send(&async2_handle);\n+        break;\n+\n+      case 2:\n+        uv_async_send(&async2_handle);\n+        break;\n+    }\n+    uv_sleep(5);\n+  }\n+\n+  if (async1_cb_called == 20) {\n+    uv_close(handle);\n+  }\n+}\n+\n+\n+/* Thread 3 calls uv_async_send on async_handle_2 8 times\n+ * after waiting half a second first.\n+ */\n+void thread3_entry(void *arg) {\n+  int i;\n+\n+  for (i = 0; i < 8; i++) {\n+    uv_async_send(&async2_handle);\n+  }\n+}\n+#endif\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+  close_cb_called++;\n+}\n+\n+\n+static void async1_cb(uv_handle_t* handle, int status) {\n+  ASSERT(handle == (uv_handle_t*)&async1_handle);\n+  ASSERT(status == 0);\n+\n+  async1_cb_called++;\n+  printf(\"async1_cb #%d\\n\", async1_cb_called);\n+\n+  if (async1_cb_called > 2 && !async1_closed) {\n+    async1_closed = 1;\n+    uv_close(handle, close_cb);\n+  }\n+}\n+\n+\n+#if 0\n+static void async2_cb(uv_handle_t* handle, int status) {\n+  ASSERT(handle == &async2_handle);\n+  ASSERT(status == 0);\n+\n+  async2_cb_called++;\n+  printf(\"async2_cb #%d\\n\", async2_cb_called);\n+\n+  if (async2_cb_called == 16) {\n+    uv_close(handle);\n+  }\n+}\n+#endif\n+\n+\n+static void prepare_cb(uv_handle_t* handle, int status) {\n+  int r;\n+\n+  ASSERT(handle == (uv_handle_t*)&prepare_handle);\n+  ASSERT(status == 0);\n+\n+  switch (prepare_cb_called) {\n+    case 0:\n+      thread1_id = uv_create_thread(thread1_entry, NULL);\n+      ASSERT(thread1_id != 0);\n+      break;\n+\n+#if 0\n+    case 1:\n+      thread2_id = uv_create_thread(thread2_entry, NULL);\n+      ASSERT(thread2_id != 0);\n+      break;\n+\n+    case 2:\n+      thread3_id = uv_create_thread(thread3_entry, NULL);\n+      ASSERT(thread3_id != 0);\n+      break;\n+#endif\n+\n+    case 1:\n+      r = uv_close(handle, close_cb);\n+      ASSERT(r == 0);\n+      break;\n+\n+    default:\n+      FATAL(\"Should never get here\");\n+  }\n+\n+  prepare_cb_called++;\n+}\n+\n+\n+TEST_IMPL(async) {\n+  int r;\n+\n+  uv_init();\n+\n+  r = uv_prepare_init(&prepare_handle);\n+  ASSERT(r == 0);\n+  r = uv_prepare_start(&prepare_handle, prepare_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_async_init(&async1_handle, async1_cb);\n+  ASSERT(r == 0);\n+\n+#if 0\n+  r = uv_async_init(&async2_handle, async2_cb, close_cb, NULL);\n+  ASSERT(r == 0);\n+#endif\n+\n+  r = uv_run();\n+  ASSERT(r == 0);\n+\n+  r = uv_wait_thread(thread1_id);\n+  ASSERT(r == 0);\n+#if 0\n+  r = uv_wait_thread(thread2_id);\n+  ASSERT(r == 0);\n+  r = uv_wait_thread(thread3_id);\n+  ASSERT(r == 0);\n+#endif\n+\n+  ASSERT(prepare_cb_called == 2);\n+  ASSERT(async1_cb_called > 2);\n+  /* ASSERT(async2_cb_called = 16); */\n+  ASSERT(close_cb_called == 2);\n+\n+  return 0;\n+}"}, {"sha": "587224acb9225ae5338cda1810f15e52a3d52b87", "filename": "src/rt/libuv/test/test-bind-error.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-bind-error.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,173 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+static int close_cb_called = 0;\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+  close_cb_called++;\n+}\n+\n+\n+TEST_IMPL(bind_error_addrinuse) {\n+  struct sockaddr_in addr = uv_ip4_addr(\"0.0.0.0\", TEST_PORT);\n+  uv_tcp_t server1, server2;\n+  int r;\n+\n+  uv_init();\n+\n+  r = uv_tcp_init(&server1);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server1, addr);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_init(&server2);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server2, addr);\n+  ASSERT(r == 0);\n+\n+  r = uv_listen(&server1, 128, NULL);\n+  ASSERT(r == 0);\n+  r = uv_listen(&server2, 128, NULL);\n+  ASSERT(r == -1);\n+\n+  ASSERT(uv_last_error().code == UV_EADDRINUSE);\n+\n+  uv_close((uv_handle_t*)&server1, close_cb);\n+  uv_close((uv_handle_t*)&server2, close_cb);\n+\n+  uv_run();\n+\n+  ASSERT(close_cb_called == 2);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(bind_error_addrnotavail_1) {\n+  struct sockaddr_in addr = uv_ip4_addr(\"127.255.255.255\", TEST_PORT);\n+  uv_tcp_t server;\n+  int r;\n+\n+  uv_init();\n+\n+  r = uv_tcp_init(&server);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server, addr);\n+\n+  /* It seems that Linux is broken here - bind succeeds. */\n+  if (r == -1) {\n+    ASSERT(uv_last_error().code == UV_EADDRNOTAVAIL);\n+  }\n+\n+  uv_close((uv_handle_t*)&server, close_cb);\n+\n+  uv_run();\n+\n+  ASSERT(close_cb_called == 1);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(bind_error_addrnotavail_2) {\n+  struct sockaddr_in addr = uv_ip4_addr(\"4.4.4.4\", TEST_PORT);\n+  uv_tcp_t server;\n+  int r;\n+\n+  uv_init();\n+\n+  r = uv_tcp_init(&server);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server, addr);\n+  ASSERT(r == -1);\n+  ASSERT(uv_last_error().code == UV_EADDRNOTAVAIL);\n+\n+  uv_close((uv_handle_t*)&server, close_cb);\n+\n+  uv_run();\n+\n+  ASSERT(close_cb_called == 1);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(bind_error_fault) {\n+  char garbage[] = \"blah blah blah blah blah blah blah blah blah blah blah blah\";\n+  struct sockaddr_in* garbage_addr;\n+  uv_tcp_t server;\n+  int r;\n+\n+  garbage_addr = (struct sockaddr_in*) &garbage;\n+\n+  uv_init();\n+\n+  r = uv_tcp_init(&server);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server, *garbage_addr);\n+  ASSERT(r == -1);\n+\n+  ASSERT(uv_last_error().code == UV_EFAULT);\n+\n+  uv_close((uv_handle_t*)&server, close_cb);\n+\n+  uv_run();\n+\n+  ASSERT(close_cb_called == 1);\n+\n+  return 0;\n+}\n+\n+/* Notes: On Linux uv_bind(server, NULL) will segfault the program.  */\n+\n+TEST_IMPL(bind_error_inval) {\n+  struct sockaddr_in addr1 = uv_ip4_addr(\"0.0.0.0\", TEST_PORT);\n+  struct sockaddr_in addr2 = uv_ip4_addr(\"0.0.0.0\", TEST_PORT_2);\n+  uv_tcp_t server;\n+  int r;\n+\n+  uv_init();\n+\n+  r = uv_tcp_init(&server);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server, addr1);\n+  ASSERT(r == 0);\n+  r = uv_bind(&server, addr2);\n+  ASSERT(r == -1);\n+\n+  ASSERT(uv_last_error().code == UV_EINVAL);\n+\n+  uv_close((uv_handle_t*)&server, close_cb);\n+\n+  uv_run();\n+\n+  ASSERT(close_cb_called == 1);\n+\n+  return 0;\n+}"}, {"sha": "5de5265be687a04e8e849d2a6ebbbbcfca3e4310", "filename": "src/rt/libuv/test/test-callback-stack.c", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,211 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+/*\n+ * TODO: Add explanation of why we want on_close to be called from fresh\n+ * stack.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+\n+\n+static const char MESSAGE[] = \"Failure is for the weak. Everyone dies alone.\";\n+\n+static uv_tcp_t client;\n+static uv_timer_t timer;\n+static uv_req_t connect_req, write_req, shutdown_req;\n+\n+static int nested = 0;\n+static int close_cb_called = 0;\n+static int connect_cb_called = 0;\n+static int write_cb_called = 0;\n+static int timer_cb_called = 0;\n+static int bytes_received = 0;\n+static int shutdown_cb_called = 0;\n+\n+\n+static uv_buf_t alloc_cb(uv_tcp_t* tcp, size_t size) {\n+  uv_buf_t buf;\n+  buf.len = size;\n+  buf.base = (char*) malloc(size);\n+  ASSERT(buf.base);\n+  return buf;\n+}\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(nested == 0 && \"close_cb must be called from a fresh stack\");\n+\n+  close_cb_called++;\n+}\n+\n+\n+static void shutdown_cb(uv_req_t* req, int status) {\n+  ASSERT(status == 0);\n+  ASSERT(nested == 0 && \"shutdown_cb must be called from a fresh stack\");\n+\n+  shutdown_cb_called++;\n+}\n+\n+\n+static void read_cb(uv_tcp_t* tcp, ssize_t nread, uv_buf_t buf) {\n+  ASSERT(nested == 0 && \"read_cb must be called from a fresh stack\");\n+\n+  printf(\"Read. nread == %d\\n\", nread);\n+  free(buf.base);\n+\n+  if (nread == 0) {\n+    ASSERT(uv_last_error().code == UV_EAGAIN);\n+    return;\n+\n+  } else if (nread == -1) {\n+    ASSERT(uv_last_error().code == UV_EOF);\n+\n+    nested++;\n+    if (uv_close((uv_handle_t*)tcp, close_cb)) {\n+      FATAL(\"uv_close failed\");\n+    }\n+    nested--;\n+\n+    return;\n+  }\n+\n+  bytes_received += nread;\n+\n+  /* We call shutdown here because when bytes_received == sizeof MESSAGE */\n+  /* there will be no more data sent nor received, so here it would be */\n+  /* possible for a backend to to call shutdown_cb immediately and *not* */\n+  /* from a fresh stack. */\n+  if (bytes_received == sizeof MESSAGE) {\n+    nested++;\n+    uv_req_init(&shutdown_req, (uv_handle_t*)tcp, shutdown_cb);\n+\n+    puts(\"Shutdown\");\n+\n+    if (uv_shutdown(&shutdown_req)) {\n+      FATAL(\"uv_shutdown failed\");\n+    }\n+    nested--;\n+  }\n+}\n+\n+\n+static void timer_cb(uv_handle_t* handle, int status) {\n+  int r;\n+\n+  ASSERT(handle == (uv_handle_t*)&timer);\n+  ASSERT(status == 0);\n+  ASSERT(nested == 0 && \"timer_cb must be called from a fresh stack\");\n+\n+  puts(\"Timeout complete. Now read data...\");\n+\n+  nested++;\n+  if (uv_read_start(&client, alloc_cb, read_cb)) {\n+    FATAL(\"uv_read_start failed\");\n+  }\n+  nested--;\n+\n+  timer_cb_called++;\n+\n+  r = uv_close(handle, close_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static void write_cb(uv_req_t* req, int status) {\n+  int r;\n+\n+  ASSERT(status == 0);\n+  ASSERT(nested == 0 && \"write_cb must be called from a fresh stack\");\n+\n+  puts(\"Data written. 500ms timeout...\");\n+\n+  /* After the data has been sent, we're going to wait for a while, then */\n+  /* start reading. This makes us certain that the message has been echoed */\n+  /* back to our receive buffer when we start reading. This maximizes the */\n+  /* tempation for the backend to use dirty stack for calling read_cb. */\n+  nested++;\n+  r = uv_timer_init(&timer);\n+  ASSERT(r == 0);\n+  r = uv_timer_start(&timer, timer_cb, 500, 0);\n+  ASSERT(r == 0);\n+  nested--;\n+\n+  write_cb_called++;\n+}\n+\n+\n+static void connect_cb(uv_req_t* req, int status) {\n+  uv_buf_t buf;\n+\n+  puts(\"Connected. Write some data to echo server...\");\n+\n+  ASSERT(status == 0);\n+  ASSERT(nested == 0 && \"connect_cb must be called from a fresh stack\");\n+\n+  nested++;\n+\n+  buf.base = (char*) &MESSAGE;\n+  buf.len = sizeof MESSAGE;\n+\n+  uv_req_init(&write_req, req->handle, write_cb);\n+\n+  if (uv_write(&write_req, &buf, 1)) {\n+    FATAL(\"uv_write failed\");\n+  }\n+\n+  nested--;\n+\n+  connect_cb_called++;\n+}\n+\n+\n+TEST_IMPL(callback_stack) {\n+  struct sockaddr_in addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+\n+  uv_init();\n+\n+  if (uv_tcp_init(&client)) {\n+    FATAL(\"uv_tcp_init failed\");\n+  }\n+\n+  puts(\"Connecting...\");\n+\n+  nested++;\n+  uv_req_init(&connect_req, (uv_handle_t*)&client, connect_cb);\n+  if (uv_connect(&connect_req, addr)) {\n+    FATAL(\"uv_connect failed\");\n+  }\n+  nested--;\n+\n+  uv_run();\n+\n+  ASSERT(nested == 0);\n+  ASSERT(connect_cb_called == 1 && \"connect_cb must be called exactly once\");\n+  ASSERT(write_cb_called == 1 && \"write_cb must be called exactly once\");\n+  ASSERT(timer_cb_called == 1 && \"timer_cb must be called exactly once\");\n+  ASSERT(bytes_received == sizeof MESSAGE);\n+  ASSERT(shutdown_cb_called == 1 && \"shutdown_cb must be called exactly once\");\n+  ASSERT(close_cb_called == 2 && \"close_cb must be called exactly twice\");\n+\n+  return 0;\n+}"}, {"sha": "fe7651974881403969424c0e5ab3f594622114fe", "filename": "src/rt/libuv/test/test-connection-fail.c", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,151 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+\n+static uv_tcp_t tcp;\n+static uv_req_t req;\n+static int connect_cb_calls;\n+static int close_cb_calls;\n+\n+static uv_timer_t timer;\n+static int timer_close_cb_calls;\n+static int timer_cb_calls;\n+\n+\n+static void on_close(uv_handle_t* handle) {\n+  close_cb_calls++;\n+}\n+\n+\n+static void timer_close_cb(uv_handle_t* handle) {\n+  timer_close_cb_calls++;\n+}\n+\n+\n+static void timer_cb(uv_handle_t* handle, int status) {\n+  ASSERT(status == 0);\n+  timer_cb_calls++;\n+\n+  /*\n+   * These are the important asserts. The connection callback has been made,\n+   * but libuv hasn't automatically closed the socket. The user must\n+   * uv_close the handle manually.\n+   */\n+  ASSERT(close_cb_calls == 0);\n+  ASSERT(connect_cb_calls == 1);\n+\n+  /* Close the tcp handle. */\n+  uv_close((uv_handle_t*)&tcp, on_close);\n+\n+  /* Close the timer. */\n+  uv_close(handle, timer_close_cb);\n+}\n+\n+\n+static void on_connect_with_close(uv_req_t *req, int status) {\n+  ASSERT(&tcp == (uv_tcp_t*) req->handle);\n+  ASSERT(status == -1);\n+  ASSERT(uv_last_error().code == UV_ECONNREFUSED);\n+  connect_cb_calls++;\n+\n+  ASSERT(close_cb_calls == 0);\n+  uv_close(req->handle, on_close);\n+}\n+\n+\n+static void on_connect_without_close(uv_req_t *req, int status) {\n+  ASSERT(status == -1);\n+  ASSERT(uv_last_error().code == UV_ECONNREFUSED);\n+  connect_cb_calls++;\n+\n+  uv_timer_start(&timer, timer_cb, 100, 0);\n+\n+  ASSERT(close_cb_calls == 0);\n+}\n+\n+\n+void connection_fail(uv_connect_cb connect_cb) {\n+  struct sockaddr_in client_addr, server_addr;\n+  int r;\n+\n+  client_addr = uv_ip4_addr(\"0.0.0.0\", 0);\n+\n+  /* There should be no servers listening on this port. */\n+  server_addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+\n+  /* Try to connec to the server and do NUM_PINGS ping-pongs. */\n+  r = uv_tcp_init(&tcp);\n+  ASSERT(!r);\n+\n+  /* We are never doing multiple reads/connects at a time anyway. */\n+  /* so these handles can be pre-initialized. */\n+  uv_req_init(&req, (uv_handle_t*)&tcp, connect_cb);\n+\n+  uv_bind(&tcp, client_addr);\n+  r = uv_connect(&req, server_addr);\n+  ASSERT(!r);\n+\n+  uv_run();\n+\n+  ASSERT(connect_cb_calls == 1);\n+  ASSERT(close_cb_calls == 1);\n+}\n+\n+\n+/*\n+ * This test attempts to connect to a port where no server is running. We\n+ * expect an error.\n+ */\n+TEST_IMPL(connection_fail) {\n+  uv_init();\n+\n+  connection_fail(on_connect_with_close);\n+\n+  ASSERT(timer_close_cb_calls == 0);\n+  ASSERT(timer_cb_calls == 0);\n+\n+  return 0;\n+}\n+\n+\n+/*\n+ * This test is the same as the first except it check that the close\n+ * callback of the tcp handle hasn't been made after the failed connection\n+ * attempt.\n+ */\n+TEST_IMPL(connection_fail_doesnt_auto_close) {\n+  uv_init();\n+\n+  uv_timer_init(&timer);\n+\n+  connection_fail(on_connect_without_close);\n+\n+  ASSERT(timer_close_cb_calls == 1);\n+  ASSERT(timer_cb_calls == 1);\n+\n+  return 0;\n+}"}, {"sha": "f903f9907a59ac37f6f7ee52a67e50c67e265fde", "filename": "src/rt/libuv/test/test-delayed-accept.c", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,199 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+static char BUFFER[1024];\n+\n+static int connection_cb_called = 0;\n+static int do_accept_called = 0;\n+static int close_cb_called = 0;\n+static int connect_cb_called = 0;\n+\n+\n+static uv_buf_t alloc_cb(uv_tcp_t* tcp, size_t size) {\n+  uv_buf_t buf;\n+  buf.base = (char*)malloc(size);\n+  buf.len = size;\n+  return buf;\n+}\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+\n+  free(handle);\n+\n+  close_cb_called++;\n+}\n+\n+\n+static void do_accept(uv_handle_t* timer_handle, int status) {\n+  uv_tcp_t* server;\n+  uv_tcp_t* accepted_handle = (uv_tcp_t*)malloc(sizeof *accepted_handle);\n+  int r;\n+  int tcpcnt;\n+\n+  ASSERT(timer_handle != NULL);\n+  ASSERT(status == 0);\n+  ASSERT(accepted_handle != NULL);\n+\n+  uv_tcp_init(accepted_handle);\n+\n+  /* Test to that uv_counters()->tcp_init does not increase across the uv_accept. */\n+  tcpcnt = uv_counters()->tcp_init;\n+\n+  server = (uv_tcp_t*)timer_handle->data;\n+  r = uv_accept(server, accepted_handle);\n+  ASSERT(r == 0);\n+\n+  ASSERT(uv_counters()->tcp_init == tcpcnt);\n+\n+  do_accept_called++;\n+\n+  /* Immediately close the accepted handle. */\n+  r = uv_close((uv_handle_t*)accepted_handle, close_cb);\n+  ASSERT(r == 0);\n+\n+  /* After accepting the two clients close the server handle */\n+  if (do_accept_called == 2) {\n+    r = uv_close((uv_handle_t*)server, close_cb);\n+    ASSERT(r == 0);\n+  }\n+\n+  /* Dispose the timer. */\n+  r = uv_close(timer_handle, close_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static void connection_cb(uv_tcp_t* tcp, int status) {\n+  int r;\n+  uv_timer_t* timer_handle;\n+\n+  ASSERT(status == 0);\n+\n+  timer_handle = (uv_timer_t*)malloc(sizeof *timer_handle);\n+  ASSERT(timer_handle != NULL);\n+\n+  /* Accept the client after 1 second */\n+  r = uv_timer_init(timer_handle);\n+  ASSERT(r == 0);\n+\n+  timer_handle->data = tcp;\n+\n+  r = uv_timer_start(timer_handle, do_accept, 1000, 0);\n+  ASSERT(r == 0);\n+\n+  connection_cb_called++;\n+}\n+\n+\n+static void start_server() {\n+  struct sockaddr_in addr = uv_ip4_addr(\"0.0.0.0\", TEST_PORT);\n+  uv_tcp_t* server = (uv_tcp_t*)malloc(sizeof *server);\n+  int r;\n+\n+  ASSERT(server != NULL);\n+\n+  r = uv_tcp_init(server);\n+  ASSERT(r == 0);\n+  ASSERT(uv_counters()->tcp_init == 1);\n+  ASSERT(uv_counters()->handle_init == 1);\n+\n+  r = uv_bind(server, addr);\n+  ASSERT(r == 0);\n+\n+  r = uv_listen(server, 128, connection_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static void read_cb(uv_tcp_t* tcp, ssize_t nread, uv_buf_t buf) {\n+  /* The server will not send anything, it should close gracefully. */\n+  ASSERT(tcp != NULL);\n+  ASSERT(nread == -1);\n+  ASSERT(uv_last_error().code == UV_EOF);\n+\n+  if (buf.base) {\n+    free(buf.base);\n+  }\n+\n+  uv_close((uv_handle_t*)tcp, close_cb);\n+}\n+\n+\n+static void connect_cb(uv_req_t* req, int status) {\n+  int r;\n+\n+  ASSERT(req != NULL);\n+  ASSERT(status == 0);\n+\n+  /* Not that the server will send anything, but otherwise we'll never know */\n+  /* when te server closes the connection. */\n+  r = uv_read_start((uv_tcp_t*)(req->handle), alloc_cb, read_cb);\n+  ASSERT(r == 0);\n+\n+  connect_cb_called++;\n+\n+  free(req);\n+}\n+\n+\n+static void client_connect() {\n+  struct sockaddr_in addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+  uv_tcp_t* client = (uv_tcp_t*)malloc(sizeof *client);\n+  uv_req_t* connect_req = (uv_req_t*)malloc(sizeof *connect_req);\n+  int r;\n+\n+  ASSERT(client != NULL);\n+  ASSERT(connect_req != NULL);\n+\n+  r = uv_tcp_init(client);\n+  ASSERT(r == 0);\n+\n+  uv_req_init(connect_req, (uv_handle_t*)client, connect_cb);\n+  r = uv_connect(connect_req, addr);\n+  ASSERT(r == 0);\n+}\n+\n+\n+\n+TEST_IMPL(delayed_accept) {\n+  uv_init();\n+\n+  start_server();\n+\n+  client_connect();\n+  client_connect();\n+\n+  uv_run();\n+\n+  ASSERT(connection_cb_called == 2);\n+  ASSERT(do_accept_called == 2);\n+  ASSERT(connect_cb_called == 2);\n+  ASSERT(close_cb_called == 7);\n+\n+  return 0;\n+}"}, {"sha": "0008459eac715c0456673b77b70ee1ce65e1f2e6", "filename": "src/rt/libuv/test/test-fail-always.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-fail-always.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-fail-always.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fail-always.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,29 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"task.h\"\n+\n+\n+TEST_IMPL(fail_always) {\n+  /* This test always fails. It is used to test the test runner. */\n+  FATAL(\"Yes, it always fails\");\n+  return 2;\n+}"}, {"sha": "880d9cd6d0fb65933b84a1901f98be5902246468", "filename": "src/rt/libuv/test/test-get-currentexe.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,53 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+#include <string.h>\n+\n+#define PATHMAX 1024\n+extern char executable_path[];\n+\n+TEST_IMPL(get_currentexe) {\n+  char buffer[PATHMAX];\n+  size_t size;\n+  char* match;\n+  int r;\n+\n+  size = sizeof(buffer) / sizeof(buffer[0]);\n+  r = uv_get_exepath(buffer, &size);\n+  ASSERT(!r);\n+\n+  match = strstr(buffer, executable_path);\n+  /* Verify that the path returned from uv_get_exepath is a subdirectory of executable_path */\n+  ASSERT(match && !strcmp(match, executable_path));\n+  ASSERT(size == strlen(buffer));\n+\n+  /* Negative tests */\n+  size = sizeof(buffer) / sizeof(buffer[0]);\n+  r = uv_get_exepath(NULL, &size);\n+  ASSERT(r == -1);\n+\n+  r = uv_get_exepath(buffer, NULL);\n+  ASSERT(r == -1);\n+\n+  return 0;\n+}"}, {"sha": "c3cb2522468fb931cbc51383f80de4e8414891e0", "filename": "src/rt/libuv/test/test-list.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,98 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+TEST_DECLARE   (ping_pong)\n+TEST_DECLARE   (delayed_accept)\n+TEST_DECLARE   (tcp_writealot)\n+TEST_DECLARE   (bind_error_addrinuse)\n+TEST_DECLARE   (bind_error_addrnotavail_1)\n+TEST_DECLARE   (bind_error_addrnotavail_2)\n+TEST_DECLARE   (bind_error_fault)\n+TEST_DECLARE   (bind_error_inval)\n+TEST_DECLARE   (connection_fail)\n+TEST_DECLARE   (connection_fail_doesnt_auto_close)\n+TEST_DECLARE   (shutdown_eof)\n+TEST_DECLARE   (callback_stack)\n+TEST_DECLARE   (timer)\n+TEST_DECLARE   (timer_again)\n+TEST_DECLARE   (loop_handles)\n+TEST_DECLARE   (ref)\n+TEST_DECLARE   (idle_ref)\n+TEST_DECLARE   (async_ref)\n+TEST_DECLARE   (prepare_ref)\n+TEST_DECLARE   (check_ref)\n+TEST_DECLARE   (async)\n+TEST_DECLARE   (get_currentexe)\n+TEST_DECLARE   (fail_always)\n+TEST_DECLARE   (pass_always)\n+HELPER_DECLARE (echo_server)\n+\n+TASK_LIST_START\n+  TEST_ENTRY  (ping_pong)\n+  TEST_HELPER (ping_pong, echo_server)\n+\n+  TEST_ENTRY  (delayed_accept)\n+\n+  TEST_ENTRY  (tcp_writealot)\n+  TEST_HELPER (tcp_writealot, echo_server)\n+\n+  TEST_ENTRY  (bind_error_addrinuse)\n+\n+  TEST_ENTRY  (bind_error_addrnotavail_1)\n+\n+  TEST_ENTRY  (bind_error_addrnotavail_2)\n+\n+  TEST_ENTRY  (bind_error_fault)\n+\n+  TEST_ENTRY  (bind_error_inval)\n+\n+  TEST_ENTRY  (connection_fail)\n+  TEST_ENTRY  (connection_fail_doesnt_auto_close)\n+\n+  TEST_ENTRY  (shutdown_eof)\n+  TEST_HELPER (shutdown_eof, echo_server)\n+\n+  TEST_ENTRY  (callback_stack)\n+  TEST_HELPER (callback_stack, echo_server)\n+\n+  TEST_ENTRY  (timer)\n+\n+  TEST_ENTRY  (timer_again)\n+\n+  TEST_ENTRY  (ref)\n+  TEST_ENTRY  (idle_ref)\n+  TEST_ENTRY  (async_ref)\n+  TEST_ENTRY  (prepare_ref)\n+  TEST_ENTRY  (check_ref)\n+\n+  TEST_ENTRY  (loop_handles)\n+\n+  TEST_ENTRY  (async)\n+\n+  TEST_ENTRY  (get_currentexe)\n+\n+#if 0\n+  /* These are for testing the test runner. */\n+  TEST_ENTRY  (fail_always)\n+  TEST_ENTRY  (pass_always)\n+#endif\n+TASK_LIST_END\n+"}, {"sha": "fa9cc18cc557f021e617445284ff07320ae6b133", "filename": "src/rt/libuv/test/test-loop-handles.c", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,419 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+/* Tests commented out with XXX are ones that are failing on Linux */\n+\n+/*\n+ * Purpose of this test is to check semantics of starting and stopping\n+ * prepare, check and idle watchers.\n+ *\n+ * - A watcher must be able to safely stop or close itself;\n+ * - Once a watcher is stopped or closed its callback should never be called.\n+ * - If a watcher is closed, it is implicitly stopped and its close_cb should\n+ *   be called exactly once.\n+ * - A watcher can safely start and stop other watchers of the same type.\n+ * - Prepare and check watchers are called once per event loop iterations.\n+ * - All active idle watchers are queued when the event loop has no more work\n+ *   to do. This is done repeatedly until all idle watchers are inactive.\n+ * - If a watcher starts another watcher of the same type its callback is not\n+ *   immediately queued. For check and prepare watchers, that means that if\n+ *   a watcher makes another of the same type active, it'll not be called until\n+ *   the next event loop iteration. For idle. watchers this means that the\n+ *   newly activated idle watcher might not be queued immediately.\n+ * - Prepare, check, idle watchers keep the event loop alive even when they're\n+ *   not active.\n+ *\n+ * This is what the test globally does:\n+ *\n+ * - prepare_1 is always active and counts event loop iterations. It also\n+ *   creates and starts prepare_2 every other iteration. Finally it verifies\n+ *   that no idle watchers are active before polling.\n+ * - prepare_2 is started by prepare_1 every other iteration. It immediately\n+ *   stops itself. It verifies that a watcher is not queued immediately\n+ *   if created by another watcher of the same type.\n+ * - There's a check watcher that stops the event loop after a certain number\n+ *   of iterations. It starts a varying number of idle_1 watchers.\n+ * - Idle_1 watchers stop themselves after being called a few times. All idle_1\n+ *   watchers try to start the idle_2 watcher if it is not already started or\n+ *   awaiting its close callback.\n+ * - The idle_2 watcher always exists but immediately closes itself after\n+ *   being started by a check_1 watcher. It verifies that a watcher is\n+ *   implicitly stopped when closed, and that a watcher can close itself\n+ *   safely.\n+ * - There is a repeating timer. It does not keep te event loop alive\n+ *   (ev_unref) but makes sure that the loop keeps polling the system for\n+ *   events.\n+ */\n+\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+\n+#include <math.h>\n+\n+\n+#define IDLE_COUNT      7\n+#define ITERATIONS      21\n+#define TIMEOUT         100\n+\n+\n+static uv_prepare_t prepare_1_handle;\n+static uv_prepare_t prepare_2_handle;\n+\n+static uv_check_t check_handle;\n+\n+static uv_idle_t idle_1_handles[IDLE_COUNT];\n+static uv_idle_t idle_2_handle;\n+\n+static uv_timer_t timer_handle;\n+\n+\n+static int loop_iteration = 0;\n+\n+static int prepare_1_cb_called = 0;\n+static int prepare_1_close_cb_called = 0;\n+\n+static int prepare_2_cb_called = 0;\n+static int prepare_2_close_cb_called = 0;\n+\n+static int check_cb_called = 0;\n+static int check_close_cb_called = 0;\n+\n+static int idle_1_cb_called = 0;\n+static int idle_1_close_cb_called = 0;\n+static int idles_1_active = 0;\n+\n+static int idle_2_cb_called = 0;\n+static int idle_2_close_cb_called = 0;\n+static int idle_2_cb_started = 0;\n+static int idle_2_is_active = 0;\n+\n+static int timer_cb_called = 0;\n+\n+\n+static void timer_cb(uv_handle_t* handle, int status) {\n+  ASSERT(handle == (uv_handle_t*)&timer_handle);\n+  ASSERT(status == 0);\n+\n+  timer_cb_called++;\n+}\n+\n+\n+static void idle_2_close_cb(uv_handle_t* handle) {\n+  LOG(\"IDLE_2_CLOSE_CB\\n\");\n+\n+  ASSERT(handle == (uv_handle_t*)&idle_2_handle);\n+\n+  ASSERT(idle_2_is_active);\n+\n+  idle_2_close_cb_called++;\n+  idle_2_is_active = 0;\n+}\n+\n+\n+static void idle_2_cb(uv_handle_t* handle, int status) {\n+  int r;\n+\n+  LOG(\"IDLE_2_CB\\n\");\n+\n+  ASSERT(handle == (uv_handle_t*)&idle_2_handle);\n+  ASSERT(status == 0);\n+\n+  idle_2_cb_called++;\n+\n+  r = uv_close(handle, idle_2_close_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static void idle_1_cb(uv_handle_t* handle, int status) {\n+  int r;\n+\n+  LOG(\"IDLE_1_CB\\n\");\n+\n+  ASSERT(handle != NULL);\n+  ASSERT(status == 0);\n+\n+  ASSERT(idles_1_active > 0);\n+\n+  /* Init idle_2 and make it active */\n+  if (!idle_2_is_active) {\n+    r = uv_idle_init(&idle_2_handle);\n+    ASSERT(r == 0);\n+    r = uv_idle_start(&idle_2_handle, idle_2_cb);\n+    ASSERT(r == 0);\n+    idle_2_is_active = 1;\n+    idle_2_cb_started++;\n+  }\n+\n+  idle_1_cb_called++;\n+\n+  if (idle_1_cb_called % 5 == 0) {\n+    r = uv_idle_stop((uv_idle_t*)handle);\n+    ASSERT(r == 0);\n+    idles_1_active--;\n+  }\n+}\n+\n+\n+static void idle_1_close_cb(uv_handle_t* handle) {\n+  LOG(\"IDLE_1_CLOSE_CB\\n\");\n+\n+  ASSERT(handle != NULL);\n+\n+  idle_1_close_cb_called++;\n+}\n+\n+\n+static void prepare_1_close_cb(uv_handle_t* handle) {\n+  LOG(\"PREPARE_1_CLOSE_CB\");\n+  ASSERT(handle == (uv_handle_t*)&prepare_1_handle);\n+\n+  prepare_1_close_cb_called++;\n+}\n+\n+\n+static void check_close_cb(uv_handle_t* handle) {\n+  LOG(\"CHECK_CLOSE_CB\\n\");\n+  ASSERT(handle == (uv_handle_t*)&check_handle);\n+\n+  check_close_cb_called++;\n+}\n+\n+\n+static void prepare_2_close_cb(uv_handle_t* handle) {\n+  LOG(\"PREPARE_2_CLOSE_CB\\n\");\n+  ASSERT(handle == (uv_handle_t*)&prepare_2_handle);\n+\n+  prepare_2_close_cb_called++;\n+}\n+\n+\n+static void check_cb(uv_handle_t* handle, int status) {\n+  int i, r;\n+\n+  LOG(\"CHECK_CB\\n\");\n+\n+  ASSERT(handle == (uv_handle_t*)&check_handle);\n+  ASSERT(status == 0);\n+\n+  /* XXX\n+  ASSERT(idles_1_active == 0);\n+  ASSERT(idle_2_is_active == 0);\n+  */\n+\n+  if (loop_iteration < ITERATIONS) {\n+    /* Make some idle watchers active */\n+    for (i = 0; i < 1 + (loop_iteration % IDLE_COUNT); i++) {\n+      r = uv_idle_start(&idle_1_handles[i], idle_1_cb);\n+      ASSERT(r == 0);\n+      idles_1_active++;\n+    }\n+\n+  } else {\n+    /* End of the test - close all handles */\n+    r = uv_close((uv_handle_t*)&prepare_1_handle, prepare_1_close_cb);\n+    ASSERT(r == 0);\n+    r = uv_close((uv_handle_t*)&check_handle, check_close_cb);\n+    ASSERT(r == 0);\n+    r = uv_close((uv_handle_t*)&prepare_2_handle, prepare_2_close_cb);\n+    ASSERT(r == 0);\n+\n+    for (i = 0; i < IDLE_COUNT; i++) {\n+      r = uv_close((uv_handle_t*)&idle_1_handles[i], idle_1_close_cb);\n+      ASSERT(r == 0);\n+    }\n+\n+    /* This handle is closed/recreated every time, close it only if it is */\n+    /* active.*/\n+    if (idle_2_is_active) {\n+      r = uv_close((uv_handle_t*)&idle_2_handle, idle_2_close_cb);\n+      ASSERT(r == 0);\n+    }\n+  }\n+\n+  check_cb_called++;\n+}\n+\n+\n+static void prepare_2_cb(uv_handle_t* handle, int status) {\n+  int r;\n+\n+  LOG(\"PREPARE_2_CB\\n\");\n+\n+  ASSERT(handle == (uv_handle_t*)&prepare_2_handle);\n+  ASSERT(status == 0);\n+\n+  /* XXX ASSERT(idles_1_active == 0); */\n+  /* XXX ASSERT(idle_2_is_active == 0); */\n+\n+  /* prepare_2 gets started by prepare_1 when (loop_iteration % 2 == 0), */\n+  /* and it stops itself immediately. A started watcher is not queued */\n+  /* until the next round, so when this callback is made */\n+  /* (loop_iteration % 2 == 0) cannot be true. */\n+  ASSERT(loop_iteration % 2 != 0);\n+\n+  r = uv_prepare_stop((uv_prepare_t*)handle);\n+  ASSERT(r == 0);\n+\n+  prepare_2_cb_called++;\n+}\n+\n+\n+static void prepare_1_cb(uv_handle_t* handle, int status) {\n+  int r;\n+\n+  LOG(\"PREPARE_1_CB\\n\");\n+\n+  ASSERT(handle == (uv_handle_t*)&prepare_1_handle);\n+  ASSERT(status == 0);\n+\n+  /* XXX\n+  ASSERT(idles_1_active == 0);\n+  ASSERT(idle_2_is_active == 0);\n+  */\n+\n+  if (loop_iteration % 2 == 0) {\n+    r = uv_prepare_start(&prepare_2_handle, prepare_2_cb);\n+    ASSERT(r == 0);\n+  }\n+\n+  prepare_1_cb_called++;\n+  loop_iteration++;\n+\n+  printf(\"Loop iteration %d of %d.\\n\", loop_iteration, ITERATIONS);\n+}\n+\n+\n+TEST_IMPL(loop_handles) {\n+  int i;\n+  int r;\n+\n+  uv_init();\n+\n+  r = uv_prepare_init(&prepare_1_handle);\n+  ASSERT(r == 0);\n+  r = uv_prepare_start(&prepare_1_handle, prepare_1_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_check_init(&check_handle);\n+  ASSERT(r == 0);\n+  r = uv_check_start(&check_handle, check_cb);\n+  ASSERT(r == 0);\n+\n+  /* initialize only, prepare_2 is started by prepare_1_cb */\n+  r = uv_prepare_init(&prepare_2_handle);\n+  ASSERT(r == 0);\n+\n+  for (i = 0; i < IDLE_COUNT; i++) {\n+    /* initialize only, idle_1 handles are started by check_cb */\n+    r = uv_idle_init(&idle_1_handles[i]);\n+    ASSERT(r == 0);\n+  }\n+\n+  /* don't init or start idle_2, both is done by idle_1_cb */\n+\n+  /* the timer callback is there to keep the event loop polling */\n+  /* unref it as it is not supposed to keep the loop alive */\n+  r = uv_timer_init(&timer_handle);\n+  ASSERT(r == 0);\n+  r = uv_timer_start(&timer_handle, timer_cb, TIMEOUT, TIMEOUT);\n+  ASSERT(r == 0);\n+  uv_unref();\n+\n+  r = uv_run();\n+  ASSERT(r == 0);\n+\n+  ASSERT(loop_iteration == ITERATIONS);\n+\n+  ASSERT(prepare_1_cb_called == ITERATIONS);\n+  ASSERT(prepare_1_close_cb_called == 1);\n+\n+  ASSERT(prepare_2_cb_called == floor(ITERATIONS / 2.0));\n+  ASSERT(prepare_2_close_cb_called == 1);\n+\n+  ASSERT(check_cb_called == ITERATIONS);\n+  ASSERT(check_close_cb_called == 1);\n+\n+  /* idle_1_cb should be called a lot */\n+  /* XXX ASSERT(idle_1_cb_called >= ITERATIONS * IDLE_COUNT * 2); */\n+  ASSERT(idle_1_close_cb_called == IDLE_COUNT);\n+  /* XXX ASSERT(idles_1_active == 0); */\n+\n+  /* XXX ASSERT(idle_2_cb_started >= ITERATIONS); */\n+  /* XXX ASSERT(idle_2_cb_called == idle_2_cb_started); */\n+  ASSERT(idle_2_close_cb_called == idle_2_cb_started);\n+  ASSERT(idle_2_is_active == 0);\n+\n+  ASSERT(timer_cb_called > 0);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(ref) {\n+  uv_init();\n+  uv_run();\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(idle_ref) {\n+  uv_idle_t h;\n+  uv_init();\n+  uv_idle_init(&h);\n+  uv_idle_start(&h, NULL);\n+  uv_unref();\n+  uv_run();\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(async_ref) {\n+  uv_async_t h;\n+  uv_init();\n+  uv_async_init(&h, NULL);\n+  uv_unref();\n+  uv_run();\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(prepare_ref) {\n+  uv_prepare_t h;\n+  uv_init();\n+  uv_prepare_init(&h);\n+  uv_prepare_start(&h, NULL);\n+  uv_unref();\n+  uv_run();\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(check_ref) {\n+  uv_check_t h;\n+  uv_init();\n+  uv_check_init(&h);\n+  uv_check_start(&h, NULL);\n+  uv_unref();\n+  uv_run();\n+  return 0;\n+}"}, {"sha": "4fb58ff94be9e039e902d2206d8f589b38f90d16", "filename": "src/rt/libuv/test/test-pass-always.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-pass-always.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-pass-always.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pass-always.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,28 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"task.h\"\n+\n+\n+TEST_IMPL(pass_always) {\n+  /* This test always passes. It is used to test the test runner. */\n+  return 0;\n+}"}, {"sha": "d8bf13d1f0e85fbc66d52fbffc60669010f564ec", "filename": "src/rt/libuv/test/test-ping-pong.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,177 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h> /* strlen */\n+\n+static int completed_pingers = 0;\n+\n+#define NUM_PINGS 1000\n+\n+/* 64 bytes is enough for a pinger */\n+#define BUFSIZE 10240\n+\n+static char PING[] = \"PING\\n\";\n+\n+\n+typedef struct {\n+  int pongs;\n+  int state;\n+  uv_tcp_t tcp;\n+  uv_req_t connect_req;\n+  uv_req_t read_req;\n+  char read_buffer[BUFSIZE];\n+} pinger_t;\n+\n+void pinger_try_read(pinger_t* pinger);\n+\n+\n+static uv_buf_t alloc_cb(uv_tcp_t* tcp, size_t size) {\n+  uv_buf_t buf;\n+  buf.base = (char*)malloc(size);\n+  buf.len = size;\n+  return buf;\n+}\n+\n+\n+static void pinger_on_close(uv_handle_t* handle) {\n+  pinger_t* pinger = (pinger_t*)handle->data;\n+\n+  ASSERT(NUM_PINGS == pinger->pongs);\n+\n+  free(pinger);\n+\n+  completed_pingers++;\n+}\n+\n+\n+static void pinger_after_write(uv_req_t *req, int status) {\n+  ASSERT(status == 0);\n+\n+  free(req);\n+}\n+\n+\n+static void pinger_write_ping(pinger_t* pinger) {\n+  uv_req_t *req;\n+  uv_buf_t buf;\n+\n+  buf.base = (char*)&PING;\n+  buf.len = strlen(PING);\n+\n+  req = (uv_req_t*)malloc(sizeof(*req));\n+  uv_req_init(req, (uv_handle_t*)(&pinger->tcp), pinger_after_write);\n+\n+  if (uv_write(req, &buf, 1)) {\n+    FATAL(\"uv_write failed\");\n+  }\n+\n+  puts(\"PING\");\n+}\n+\n+\n+static void pinger_read_cb(uv_tcp_t* tcp, ssize_t nread, uv_buf_t buf) {\n+  unsigned int i;\n+  pinger_t* pinger;\n+\n+  pinger = (pinger_t*)tcp->data;\n+\n+  if (nread < 0) {\n+    ASSERT(uv_last_error().code == UV_EOF);\n+\n+    puts(\"got EOF\");\n+\n+    if (buf.base) {\n+      free(buf.base);\n+    }\n+\n+    uv_close((uv_handle_t*)(&pinger->tcp), pinger_on_close);\n+\n+    return;\n+  }\n+\n+  /* Now we count the pings */\n+  for (i = 0; i < nread; i++) {\n+    ASSERT(buf.base[i] == PING[pinger->state]);\n+    pinger->state = (pinger->state + 1) % (sizeof(PING) - 1);\n+    if (pinger->state == 0) {\n+      printf(\"PONG %d\\n\", pinger->pongs);\n+      pinger->pongs++;\n+      if (pinger->pongs < NUM_PINGS) {\n+        pinger_write_ping(pinger);\n+      } else {\n+        uv_close((uv_handle_t*)(&pinger->tcp), pinger_on_close);\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n+\n+static void pinger_on_connect(uv_req_t *req, int status) {\n+  pinger_t *pinger = (pinger_t*)req->handle->data;\n+\n+  ASSERT(status == 0);\n+\n+  pinger_write_ping(pinger);\n+\n+  uv_read_start((uv_tcp_t*)(req->handle), alloc_cb, pinger_read_cb);\n+}\n+\n+\n+static void pinger_new() {\n+  int r;\n+  struct sockaddr_in server_addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+  pinger_t *pinger;\n+\n+  pinger = (pinger_t*)malloc(sizeof(*pinger));\n+  pinger->state = 0;\n+  pinger->pongs = 0;\n+\n+  /* Try to connec to the server and do NUM_PINGS ping-pongs. */\n+  r = uv_tcp_init(&pinger->tcp);\n+  pinger->tcp.data = pinger;\n+  ASSERT(!r);\n+\n+  /* We are never doing multiple reads/connects at a time anyway. */\n+  /* so these handles can be pre-initialized. */\n+  uv_req_init(&pinger->connect_req, (uv_handle_t*)(&pinger->tcp),\n+      pinger_on_connect);\n+\n+  r = uv_connect(&pinger->connect_req, server_addr);\n+  ASSERT(!r);\n+}\n+\n+\n+TEST_IMPL(ping_pong) {\n+  uv_init();\n+\n+  pinger_new();\n+  uv_run();\n+\n+  ASSERT(completed_pingers == 1);\n+\n+  return 0;\n+}"}, {"sha": "1ce81f71be74b3e402cdad3bfe180cd0db413926", "filename": "src/rt/libuv/test/test-shutdown-eof.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,176 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+static uv_timer_t timer;\n+static uv_tcp_t tcp;\n+static uv_req_t connect_req, write_req, shutdown_req;\n+static uv_buf_t qbuf;\n+static int got_q;\n+static int got_eof;\n+static int called_connect_cb;\n+static int called_shutdown_cb;\n+static int called_tcp_close_cb;\n+static int called_timer_close_cb;\n+static int called_timer_cb;\n+\n+\n+static uv_buf_t alloc_cb(uv_tcp_t* tcp, size_t size) {\n+  uv_buf_t buf;\n+  buf.base = (char*)malloc(size);\n+  buf.len = size;\n+  return buf;\n+}\n+\n+\n+static void read_cb(uv_tcp_t* t, ssize_t nread, uv_buf_t buf) {\n+  ASSERT(t == &tcp);\n+\n+  if (!got_q) {\n+    ASSERT(nread == 1);\n+    ASSERT(!got_eof);\n+    ASSERT(buf.base[0] == 'Q');\n+    free(buf.base);\n+    got_q = 1;\n+    puts(\"got Q\");\n+  } else {\n+    ASSERT(uv_last_error().code == UV_EOF);\n+    if (buf.base) {\n+      free(buf.base);\n+    }\n+    got_eof = 1;\n+    puts(\"got EOF\");\n+  }\n+}\n+\n+\n+static void shutdown_cb(uv_req_t *req, int status) {\n+  ASSERT(req == &shutdown_req);\n+\n+  ASSERT(called_connect_cb == 1);\n+  ASSERT(!got_eof);\n+  ASSERT(called_tcp_close_cb == 0);\n+  ASSERT(called_timer_close_cb == 0);\n+  ASSERT(called_timer_cb == 0);\n+\n+  called_shutdown_cb++;\n+}\n+\n+\n+static void connect_cb(uv_req_t *req, int status) {\n+  ASSERT(status == 0);\n+  ASSERT(req == &connect_req);\n+\n+  /* Start reading from our connection so we can receive the EOF.  */\n+  uv_read_start(&tcp, alloc_cb, read_cb);\n+\n+  /*\n+   * Write the letter 'Q' to gracefully kill the echo-server. This will not\n+   * effect our connection.\n+   */\n+  uv_req_init(&write_req, (uv_handle_t*)&tcp, NULL);\n+  uv_write(&write_req, &qbuf, 1);\n+\n+  /* Shutdown our end of the connection.  */\n+  uv_req_init(&shutdown_req, (uv_handle_t*)&tcp, shutdown_cb);\n+  uv_shutdown(&shutdown_req);\n+\n+  called_connect_cb++;\n+  ASSERT(called_shutdown_cb == 0);\n+}\n+\n+\n+void tcp_close_cb(uv_handle_t* handle) {\n+  ASSERT(handle == (uv_handle_t*) &tcp);\n+\n+  ASSERT(called_connect_cb == 1);\n+  ASSERT(got_q);\n+  ASSERT(got_eof);\n+  ASSERT(called_timer_cb == 1);\n+\n+  called_tcp_close_cb++;\n+}\n+\n+\n+void timer_close_cb(uv_handle_t* handle) {\n+  ASSERT(handle == (uv_handle_t*) &timer);\n+  called_timer_close_cb++;\n+}\n+\n+\n+void timer_cb(uv_handle_t* handle, int status) {\n+  ASSERT(handle == (uv_handle_t*) &timer);\n+  uv_close(handle, timer_close_cb);\n+\n+  /*\n+   * The most important assert of the test: we have not received\n+   * tcp_close_cb yet.\n+   */\n+  ASSERT(called_tcp_close_cb == 0);\n+  uv_close((uv_handle_t*) &tcp, tcp_close_cb);\n+\n+  called_timer_cb++;\n+}\n+\n+\n+/*\n+ * This test has a client which connects to the echo_server and immediately\n+ * issues a shutdown. The echo-server, in response, will also shutdown their\n+ * connection. We check, with a timer, that libuv is not automatically\n+ * calling uv_close when the client receives the EOF from echo-server.\n+ */\n+TEST_IMPL(shutdown_eof) {\n+  struct sockaddr_in server_addr;\n+  int r;\n+\n+  uv_init();\n+\n+  qbuf.base = \"Q\";\n+  qbuf.len = 1;\n+\n+  uv_timer_init(&timer);\n+  uv_timer_start(&timer, timer_cb, 100, 0);\n+\n+  server_addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+  r = uv_tcp_init(&tcp);\n+  ASSERT(!r);\n+\n+  uv_req_init(&connect_req, (uv_handle_t*) &tcp, connect_cb);\n+  r = uv_connect(&connect_req, server_addr);\n+  ASSERT(!r);\n+\n+  uv_run();\n+\n+  ASSERT(called_connect_cb == 1);\n+  ASSERT(called_shutdown_cb == 1);\n+  ASSERT(got_eof);\n+  ASSERT(got_q);\n+  ASSERT(called_tcp_close_cb == 1);\n+  ASSERT(called_timer_close_cb == 1);\n+  ASSERT(called_timer_cb == 1);\n+\n+  return 0;\n+}\n+"}, {"sha": "5105a0477aaf46920da0a4d3bc86bfaa3127d8b0", "filename": "src/rt/libuv/test/test-tcp-writealot.c", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,202 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+#define WRITES            3\n+#define CHUNKS_PER_WRITE  3\n+#define CHUNK_SIZE        10485760 /* 10 MB */\n+\n+#define TOTAL_BYTES       (WRITES * CHUNKS_PER_WRITE * CHUNK_SIZE)\n+\n+\n+static char* send_buffer;\n+\n+\n+static int shutdown_cb_called = 0;\n+static int connect_cb_called = 0;\n+static int write_cb_called = 0;\n+static int close_cb_called = 0;\n+static int bytes_sent = 0;\n+static int bytes_sent_done = 0;\n+static int bytes_received = 0;\n+static int bytes_received_done = 0;\n+\n+\n+static uv_buf_t alloc_cb(uv_tcp_t* tcp, size_t size) {\n+  uv_buf_t buf;\n+  buf.base = (char*)malloc(size);\n+  buf.len = size;\n+  return buf;\n+}\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+\n+  free(handle);\n+\n+  close_cb_called++;\n+}\n+\n+\n+static void shutdown_cb(uv_req_t* req, int status) {\n+  uv_tcp_t* tcp;\n+\n+  ASSERT(req);\n+  ASSERT(status == 0);\n+\n+  tcp = (uv_tcp_t*)(req->handle);\n+\n+  /* The write buffer should be empty by now. */\n+  ASSERT(tcp->write_queue_size == 0);\n+\n+  /* Now we wait for the EOF */\n+  shutdown_cb_called++;\n+\n+  /* We should have had all the writes called already. */\n+  ASSERT(write_cb_called == WRITES);\n+\n+  free(req);\n+}\n+\n+\n+static void read_cb(uv_tcp_t* tcp, ssize_t nread, uv_buf_t buf) {\n+  ASSERT(tcp != NULL);\n+\n+  if (nread < 0) {\n+    ASSERT(uv_last_error().code == UV_EOF);\n+    printf(\"GOT EOF\\n\");\n+\n+    if (buf.base) {\n+      free(buf.base);\n+    }\n+\n+    uv_close((uv_handle_t*)tcp, close_cb);\n+    return;\n+  }\n+\n+  bytes_received_done += nread;\n+\n+  free(buf.base);\n+}\n+\n+\n+static void write_cb(uv_req_t* req, int status) {\n+  ASSERT(req != NULL);\n+\n+  if (status) {\n+    uv_err_t err = uv_last_error();\n+    fprintf(stderr, \"uv_write error: %s\\n\", uv_strerror(err));\n+    ASSERT(0);\n+  }\n+\n+  bytes_sent_done += CHUNKS_PER_WRITE * CHUNK_SIZE;\n+  write_cb_called++;\n+\n+  free(req);\n+}\n+\n+\n+static void connect_cb(uv_req_t* req, int status) {\n+  uv_buf_t send_bufs[CHUNKS_PER_WRITE];\n+  uv_tcp_t* tcp;\n+  int i, j, r;\n+\n+  ASSERT(req != NULL);\n+  ASSERT(status == 0);\n+\n+  tcp = (uv_tcp_t*)req->handle;\n+\n+  connect_cb_called++;\n+  free(req);\n+\n+  /* Write a lot of data */\n+  for (i = 0; i < WRITES; i++) {\n+    for (j = 0; j < CHUNKS_PER_WRITE; j++) {\n+      send_bufs[j].len = CHUNK_SIZE;\n+      send_bufs[j].base = send_buffer + bytes_sent;\n+      bytes_sent += CHUNK_SIZE;\n+    }\n+\n+    req = (uv_req_t*)malloc(sizeof *req);\n+    ASSERT(req != NULL);\n+\n+    uv_req_init(req, (uv_handle_t*)tcp, write_cb);\n+    r = uv_write(req, (uv_buf_t*)&send_bufs, CHUNKS_PER_WRITE);\n+    ASSERT(r == 0);\n+  }\n+\n+  /* Shutdown on drain. FIXME: dealloc req? */\n+  req = (uv_req_t*) malloc(sizeof(uv_req_t));\n+  ASSERT(req != NULL);\n+  uv_req_init(req, (uv_handle_t*)tcp, shutdown_cb);\n+  r = uv_shutdown(req);\n+  ASSERT(r == 0);\n+\n+  /* Start reading */\n+  req = (uv_req_t*)malloc(sizeof *req);\n+  ASSERT(req != NULL);\n+\n+  uv_req_init(req, (uv_handle_t*)tcp, read_cb);\n+  r = uv_read_start(tcp, alloc_cb, read_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+TEST_IMPL(tcp_writealot) {\n+  struct sockaddr_in addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+  uv_tcp_t* client = (uv_tcp_t*)malloc(sizeof *client);\n+  uv_req_t* connect_req = (uv_req_t*)malloc(sizeof *connect_req);\n+  int r;\n+\n+  ASSERT(client != NULL);\n+  ASSERT(connect_req != NULL);\n+\n+  send_buffer = (char*)malloc(TOTAL_BYTES + 1);\n+\n+  ASSERT(send_buffer != NULL);\n+\n+  uv_init();\n+\n+  r = uv_tcp_init(client);\n+  ASSERT(r == 0);\n+\n+  uv_req_init(connect_req, (uv_handle_t*)client, connect_cb);\n+  r = uv_connect(connect_req, addr);\n+  ASSERT(r == 0);\n+\n+  uv_run();\n+\n+  ASSERT(shutdown_cb_called == 1);\n+  ASSERT(connect_cb_called == 1);\n+  ASSERT(write_cb_called == WRITES);\n+  ASSERT(close_cb_called == 1);\n+  ASSERT(bytes_sent == TOTAL_BYTES);\n+  ASSERT(bytes_sent_done == TOTAL_BYTES);\n+  ASSERT(bytes_received_done == TOTAL_BYTES);\n+\n+  return 0;\n+}"}, {"sha": "774820834910d7b7cdd5bdd0b9eb9bb1aca1a035", "filename": "src/rt/libuv/test/test-timer-again.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,141 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+\n+\n+static int close_cb_called = 0;\n+static int repeat_1_cb_called = 0;\n+static int repeat_2_cb_called = 0;\n+\n+static int repeat_2_cb_allowed = 0;\n+\n+static uv_timer_t dummy, repeat_1, repeat_2;\n+\n+static int64_t start_time;\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+\n+  close_cb_called++;\n+}\n+\n+\n+static void repeat_1_cb(uv_handle_t* handle, int status) {\n+  int r;\n+\n+  ASSERT(handle == (uv_handle_t*)&repeat_1);\n+  ASSERT(status == 0);\n+\n+  ASSERT(uv_timer_get_repeat((uv_timer_t*)handle) == 50);\n+\n+  LOGF(\"repeat_1_cb called after %ld ms\\n\", (long int)(uv_now() - start_time));\n+\n+  repeat_1_cb_called++;\n+\n+  r = uv_timer_again(&repeat_2);\n+  ASSERT(r == 0);\n+\n+  if (uv_now() >= start_time + 500) {\n+    uv_close(handle, close_cb);\n+    /* We're not calling uv_timer_again on repeat_2 any more, so after this */\n+    /* timer_2_cb is expected. */\n+    repeat_2_cb_allowed = 1;\n+    return;\n+  }\n+}\n+\n+\n+static void repeat_2_cb(uv_handle_t* handle, int status) {\n+  ASSERT(handle == (uv_handle_t*) &repeat_2);\n+  ASSERT(status == 0);\n+  ASSERT(repeat_2_cb_allowed);\n+\n+  LOGF(\"repeat_2_cb called after %ld ms\\n\", (long int)(uv_now() - start_time));\n+\n+  repeat_2_cb_called++;\n+\n+  if (uv_timer_get_repeat(&repeat_2) == 0) {\n+    ASSERT(!uv_is_active(handle));\n+    uv_close(handle, close_cb);\n+    return;\n+  }\n+\n+  LOGF(\"uv_timer_get_repeat %ld ms\\n\",\n+      (long int)uv_timer_get_repeat(&repeat_2));\n+  ASSERT(uv_timer_get_repeat(&repeat_2) == 100);\n+\n+  /* This shouldn't take effect immediately. */\n+  uv_timer_set_repeat(&repeat_2, 0);\n+}\n+\n+\n+TEST_IMPL(timer_again) {\n+  int r;\n+\n+  uv_init();\n+\n+  start_time = uv_now();\n+  ASSERT(0 < start_time);\n+\n+  /* Verify that it is not possible to uv_timer_again a never-started timer. */\n+  r = uv_timer_init(&dummy);\n+  ASSERT(r == 0);\n+  r = uv_timer_again(&dummy);\n+  ASSERT(r == -1);\n+  ASSERT(uv_last_error().code == UV_EINVAL);\n+  uv_unref();\n+\n+  /* Start timer repeat_1. */\n+  r = uv_timer_init(&repeat_1);\n+  ASSERT(r == 0);\n+  r = uv_timer_start(&repeat_1, repeat_1_cb, 50, 0);\n+  ASSERT(r == 0);\n+  ASSERT(uv_timer_get_repeat(&repeat_1) == 0);\n+\n+  /* Actually make repeat_1 repeating. */\n+  uv_timer_set_repeat(&repeat_1, 50);\n+  ASSERT(uv_timer_get_repeat(&repeat_1) == 50);\n+\n+  /*\n+   * Start another repeating timer. It'll be again()ed by the repeat_1 so\n+   * it should not time out until repeat_1 stops.\n+   */\n+  r = uv_timer_init(&repeat_2);\n+  ASSERT(r == 0);\n+  r = uv_timer_start(&repeat_2, repeat_2_cb, 100, 100);\n+  ASSERT(r == 0);\n+  ASSERT(uv_timer_get_repeat(&repeat_2) == 100);\n+\n+  uv_run();\n+\n+  ASSERT(repeat_1_cb_called == 10);\n+  ASSERT(repeat_2_cb_called == 2);\n+  ASSERT(close_cb_called == 2);\n+\n+  LOGF(\"Test took %ld ms (expected ~700 ms)\\n\",\n+       (long int)(uv_now() - start_time));\n+  ASSERT(700 <= uv_now() - start_time);\n+\n+  return 0;\n+}"}, {"sha": "5d39ad717c23ce49fd3e7693d2a1fee3b645520f", "filename": "src/rt/libuv/test/test-timer.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,134 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"../uv.h\"\n+#include \"task.h\"\n+\n+\n+static int once_cb_called = 0;\n+static int once_close_cb_called = 0;\n+static int repeat_cb_called = 0;\n+static int repeat_close_cb_called = 0;\n+\n+static int64_t start_time;\n+\n+\n+static void once_close_cb(uv_handle_t* handle) {\n+  printf(\"ONCE_CLOSE_CB\\n\");\n+\n+  ASSERT(handle != NULL);\n+\n+  once_close_cb_called++;\n+\n+  free(handle);\n+}\n+\n+\n+static void once_cb(uv_handle_t* handle, int status) {\n+  printf(\"ONCE_CB %d\\n\", once_cb_called);\n+\n+  ASSERT(handle != NULL);\n+  ASSERT(status == 0);\n+\n+  once_cb_called++;\n+\n+  uv_close(handle, once_close_cb);\n+\n+  /* Just call this randomly for the code coverage. */\n+  uv_update_time();\n+}\n+\n+\n+static void repeat_close_cb(uv_handle_t* handle) {\n+  printf(\"REPEAT_CLOSE_CB\\n\");\n+\n+  ASSERT(handle != NULL);\n+\n+  repeat_close_cb_called++;\n+}\n+\n+\n+static void repeat_cb(uv_handle_t* handle, int status) {\n+  printf(\"REPEAT_CB\\n\");\n+\n+  ASSERT(handle != NULL);\n+  ASSERT(status == 0);\n+\n+  repeat_cb_called++;\n+\n+  if (repeat_cb_called == 5) {\n+    uv_close(handle, repeat_close_cb);\n+  }\n+}\n+\n+\n+static void never_cb(uv_handle_t* handle, int status) {\n+  FATAL(\"never_cb should never be called\");\n+}\n+\n+\n+TEST_IMPL(timer) {\n+  uv_timer_t *once;\n+  uv_timer_t repeat, never;\n+  int i, r;\n+\n+  uv_init();\n+\n+  start_time = uv_now();\n+  ASSERT(0 < start_time);\n+\n+  /* Let 10 timers time out in 500 ms total. */\n+  for (i = 0; i < 10; i++) {\n+    once = (uv_timer_t*)malloc(sizeof(*once));\n+    ASSERT(once != NULL);\n+    r = uv_timer_init(once);\n+    ASSERT(r == 0);\n+    r = uv_timer_start(once, once_cb, i * 50, 0);\n+    ASSERT(r == 0);\n+  }\n+\n+  /* The 11th timer is a repeating timer that runs 4 times */\n+  r = uv_timer_init(&repeat);\n+  ASSERT(r == 0);\n+  r = uv_timer_start(&repeat, repeat_cb, 100, 100);\n+  ASSERT(r == 0);\n+\n+  /* The 12th timer should not do anything. */\n+  r = uv_timer_init(&never);\n+  ASSERT(r == 0);\n+  r = uv_timer_start(&never, never_cb, 100, 100);\n+  ASSERT(r == 0);\n+  r = uv_timer_stop(&never);\n+  ASSERT(r == 0);\n+  uv_unref();\n+\n+  uv_run();\n+\n+  ASSERT(once_cb_called == 10);\n+  ASSERT(once_close_cb_called == 10);\n+  printf(\"repeat_cb_called %d\\n\", repeat_cb_called);\n+  ASSERT(repeat_cb_called == 5);\n+  ASSERT(repeat_close_cb_called == 1);\n+\n+  ASSERT(500 <= uv_now() - start_time);\n+\n+  return 0;\n+}"}, {"sha": "37966d353c3de68aefa5dba3e773dc8513d0c9d7", "filename": "src/rt/libuv/tree.h", "status": "added", "additions": 762, "deletions": 0, "changes": 762, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftree.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Ftree.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftree.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,762 @@\n+/*-\n+ * Copyright 2002 Niels Provos <provos@citi.umich.edu>\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#ifndef  _UV_TREE_H_\n+#define  _UV_TREE_H_\n+\n+#define __unused\n+\n+/*\n+ * This file defines data structures for different types of trees:\n+ * splay trees and red-black trees.\n+ *\n+ * A splay tree is a self-organizing data structure.  Every operation\n+ * on the tree causes a splay to happen.  The splay moves the requested\n+ * node to the root of the tree and partly rebalances it.\n+ *\n+ * This has the benefit that request locality causes faster lookups as\n+ * the requested nodes move to the top of the tree.  On the other hand,\n+ * every lookup causes memory writes.\n+ *\n+ * The Balance Theorem bounds the total access time for m operations\n+ * and n inserts on an initially empty tree as O((m + n)lg n).  The\n+ * amortized cost for a sequence of m accesses to a splay tree is O(lg n);\n+ *\n+ * A red-black tree is a binary search tree with the node color as an\n+ * extra attribute.  It fulfills a set of conditions:\n+ *  - every search path from the root to a leaf consists of the\n+ *    same number of black nodes,\n+ *  - each red node (except for the root) has a black parent,\n+ *  - each leaf node is black.\n+ *\n+ * Every operation on a red-black tree is bounded as O(lg n).\n+ * The maximum height of a red-black tree is 2lg (n+1).\n+ */\n+\n+#define SPLAY_HEAD(name, type)                                                \\\n+struct name {                                                                 \\\n+  struct type *sph_root; /* root of the tree */                               \\\n+}\n+\n+#define SPLAY_INITIALIZER(root)                                               \\\n+  { NULL }\n+\n+#define SPLAY_INIT(root) do {                                                 \\\n+  (root)->sph_root = NULL;                                                    \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define SPLAY_ENTRY(type)                                                     \\\n+struct {                                                                      \\\n+  struct type *spe_left;          /* left element */                          \\\n+  struct type *spe_right;         /* right element */                         \\\n+}\n+\n+#define SPLAY_LEFT(elm, field)    (elm)->field.spe_left\n+#define SPLAY_RIGHT(elm, field)   (elm)->field.spe_right\n+#define SPLAY_ROOT(head)          (head)->sph_root\n+#define SPLAY_EMPTY(head)         (SPLAY_ROOT(head) == NULL)\n+\n+/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */\n+#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {                             \\\n+  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);              \\\n+  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \\\n+  (head)->sph_root = tmp;                                                     \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define SPLAY_ROTATE_LEFT(head, tmp, field) do {                              \\\n+  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);              \\\n+  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \\\n+  (head)->sph_root = tmp;                                                     \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define SPLAY_LINKLEFT(head, tmp, field) do {                                 \\\n+  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \\\n+  tmp = (head)->sph_root;                                                     \\\n+  (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                     \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define SPLAY_LINKRIGHT(head, tmp, field) do {                                \\\n+  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \\\n+  tmp = (head)->sph_root;                                                     \\\n+  (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                    \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define SPLAY_ASSEMBLE(head, node, left, right, field) do {                   \\\n+  SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);             \\\n+  SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);            \\\n+  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);             \\\n+  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);             \\\n+} while (/*CONSTCOND*/ 0)\n+\n+/* Generates prototypes and inline functions */\n+\n+#define SPLAY_PROTOTYPE(name, type, field, cmp)                               \\\n+void name##_SPLAY(struct name *, struct type *);                              \\\n+void name##_SPLAY_MINMAX(struct name *, int);                                 \\\n+struct type *name##_SPLAY_INSERT(struct name *, struct type *);               \\\n+struct type *name##_SPLAY_REMOVE(struct name *, struct type *);               \\\n+                                                                              \\\n+/* Finds the node with the same key as elm */                                 \\\n+static __inline struct type *                                                 \\\n+name##_SPLAY_FIND(struct name *head, struct type *elm)                        \\\n+{                                                                             \\\n+  if (SPLAY_EMPTY(head))                                                      \\\n+    return(NULL);                                                             \\\n+  name##_SPLAY(head, elm);                                                    \\\n+  if ((cmp)(elm, (head)->sph_root) == 0)                                      \\\n+    return (head->sph_root);                                                  \\\n+  return (NULL);                                                              \\\n+}                                                                             \\\n+                                                                              \\\n+static __inline struct type *                                                 \\\n+name##_SPLAY_NEXT(struct name *head, struct type *elm)                        \\\n+{                                                                             \\\n+  name##_SPLAY(head, elm);                                                    \\\n+  if (SPLAY_RIGHT(elm, field) != NULL) {                                      \\\n+    elm = SPLAY_RIGHT(elm, field);                                            \\\n+    while (SPLAY_LEFT(elm, field) != NULL) {                                  \\\n+      elm = SPLAY_LEFT(elm, field);                                           \\\n+    }                                                                         \\\n+  } else                                                                      \\\n+    elm = NULL;                                                               \\\n+  return (elm);                                                               \\\n+}                                                                             \\\n+                                                                              \\\n+static __inline struct type *                                                 \\\n+name##_SPLAY_MIN_MAX(struct name *head, int val)                              \\\n+{                                                                             \\\n+  name##_SPLAY_MINMAX(head, val);                                             \\\n+  return (SPLAY_ROOT(head));                                                  \\\n+}\n+\n+/* Main splay operation.\n+ * Moves node close to the key of elm to top\n+ */\n+#define SPLAY_GENERATE(name, type, field, cmp)                                \\\n+struct type *                                                                 \\\n+name##_SPLAY_INSERT(struct name *head, struct type *elm)                      \\\n+{                                                                             \\\n+    if (SPLAY_EMPTY(head)) {                                                  \\\n+      SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;                \\\n+    } else {                                                                  \\\n+      int __comp;                                                             \\\n+      name##_SPLAY(head, elm);                                                \\\n+      __comp = (cmp)(elm, (head)->sph_root);                                  \\\n+      if(__comp < 0) {                                                        \\\n+        SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);         \\\n+        SPLAY_RIGHT(elm, field) = (head)->sph_root;                           \\\n+        SPLAY_LEFT((head)->sph_root, field) = NULL;                           \\\n+      } else if (__comp > 0) {                                                \\\n+        SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);       \\\n+        SPLAY_LEFT(elm, field) = (head)->sph_root;                            \\\n+        SPLAY_RIGHT((head)->sph_root, field) = NULL;                          \\\n+      } else                                                                  \\\n+        return ((head)->sph_root);                                            \\\n+    }                                                                         \\\n+    (head)->sph_root = (elm);                                                 \\\n+    return (NULL);                                                            \\\n+}                                                                             \\\n+                                                                              \\\n+struct type *                                                                 \\\n+name##_SPLAY_REMOVE(struct name *head, struct type *elm)                      \\\n+{                                                                             \\\n+  struct type *__tmp;                                                         \\\n+  if (SPLAY_EMPTY(head))                                                      \\\n+    return (NULL);                                                            \\\n+  name##_SPLAY(head, elm);                                                    \\\n+  if ((cmp)(elm, (head)->sph_root) == 0) {                                    \\\n+    if (SPLAY_LEFT((head)->sph_root, field) == NULL) {                        \\\n+      (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                \\\n+    } else {                                                                  \\\n+      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \\\n+      (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                 \\\n+      name##_SPLAY(head, elm);                                                \\\n+      SPLAY_RIGHT((head)->sph_root, field) = __tmp;                           \\\n+    }                                                                         \\\n+    return (elm);                                                             \\\n+  }                                                                           \\\n+  return (NULL);                                                              \\\n+}                                                                             \\\n+                                                                              \\\n+void                                                                          \\\n+name##_SPLAY(struct name *head, struct type *elm)                             \\\n+{                                                                             \\\n+  struct type __node, *__left, *__right, *__tmp;                              \\\n+  int __comp;                                                                 \\\n+                                                                              \\\n+  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \\\n+  __left = __right = &__node;                                                 \\\n+                                                                              \\\n+  while ((__comp = (cmp)(elm, (head)->sph_root)) != 0) {                      \\\n+    if (__comp < 0) {                                                         \\\n+      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \\\n+      if (__tmp == NULL)                                                      \\\n+        break;                                                                \\\n+      if ((cmp)(elm, __tmp) < 0){                                             \\\n+        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \\\n+        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \\\n+          break;                                                              \\\n+      }                                                                       \\\n+      SPLAY_LINKLEFT(head, __right, field);                                   \\\n+    } else if (__comp > 0) {                                                  \\\n+      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \\\n+      if (__tmp == NULL)                                                      \\\n+        break;                                                                \\\n+      if ((cmp)(elm, __tmp) > 0){                                             \\\n+        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \\\n+        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \\\n+          break;                                                              \\\n+      }                                                                       \\\n+      SPLAY_LINKRIGHT(head, __left, field);                                   \\\n+    }                                                                         \\\n+  }                                                                           \\\n+  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \\\n+}                                                                             \\\n+                                                                              \\\n+/* Splay with either the minimum or the maximum element                       \\\n+ * Used to find minimum or maximum element in tree.                           \\\n+ */                                                                           \\\n+void name##_SPLAY_MINMAX(struct name *head, int __comp)                       \\\n+{                                                                             \\\n+  struct type __node, *__left, *__right, *__tmp;                              \\\n+                                                                              \\\n+  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \\\n+  __left = __right = &__node;                                                 \\\n+                                                                              \\\n+  while (1) {                                                                 \\\n+    if (__comp < 0) {                                                         \\\n+      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \\\n+      if (__tmp == NULL)                                                      \\\n+        break;                                                                \\\n+      if (__comp < 0){                                                        \\\n+        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \\\n+        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \\\n+          break;                                                              \\\n+      }                                                                       \\\n+      SPLAY_LINKLEFT(head, __right, field);                                   \\\n+    } else if (__comp > 0) {                                                  \\\n+      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \\\n+      if (__tmp == NULL)                                                      \\\n+        break;                                                                \\\n+      if (__comp > 0) {                                                       \\\n+        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \\\n+        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \\\n+          break;                                                              \\\n+      }                                                                       \\\n+      SPLAY_LINKRIGHT(head, __left, field);                                   \\\n+    }                                                                         \\\n+  }                                                                           \\\n+  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \\\n+}\n+\n+#define SPLAY_NEGINF  -1\n+#define SPLAY_INF     1\n+\n+#define SPLAY_INSERT(name, x, y)  name##_SPLAY_INSERT(x, y)\n+#define SPLAY_REMOVE(name, x, y)  name##_SPLAY_REMOVE(x, y)\n+#define SPLAY_FIND(name, x, y)    name##_SPLAY_FIND(x, y)\n+#define SPLAY_NEXT(name, x, y)    name##_SPLAY_NEXT(x, y)\n+#define SPLAY_MIN(name, x)        (SPLAY_EMPTY(x) ? NULL                      \\\n+                                  : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))\n+#define SPLAY_MAX(name, x)        (SPLAY_EMPTY(x) ? NULL                      \\\n+                                  : name##_SPLAY_MIN_MAX(x, SPLAY_INF))\n+\n+#define SPLAY_FOREACH(x, name, head)                                          \\\n+  for ((x) = SPLAY_MIN(name, head);                                           \\\n+       (x) != NULL;                                                           \\\n+       (x) = SPLAY_NEXT(name, head, x))\n+\n+/* Macros that define a red-black tree */\n+#define RB_HEAD(name, type)                                                   \\\n+struct name {                                                                 \\\n+  struct type *rbh_root; /* root of the tree */                               \\\n+}\n+\n+#define RB_INITIALIZER(root)                                                  \\\n+  { NULL }\n+\n+#define RB_INIT(root) do {                                                    \\\n+  (root)->rbh_root = NULL;                                                    \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define RB_BLACK  0\n+#define RB_RED    1\n+#define RB_ENTRY(type)                                                        \\\n+struct {                                                                      \\\n+  struct type *rbe_left;        /* left element */                            \\\n+  struct type *rbe_right;       /* right element */                           \\\n+  struct type *rbe_parent;      /* parent element */                          \\\n+  int rbe_color;                /* node color */                              \\\n+}\n+\n+#define RB_LEFT(elm, field)     (elm)->field.rbe_left\n+#define RB_RIGHT(elm, field)    (elm)->field.rbe_right\n+#define RB_PARENT(elm, field)   (elm)->field.rbe_parent\n+#define RB_COLOR(elm, field)    (elm)->field.rbe_color\n+#define RB_ROOT(head)           (head)->rbh_root\n+#define RB_EMPTY(head)          (RB_ROOT(head) == NULL)\n+\n+#define RB_SET(elm, parent, field) do {                                       \\\n+  RB_PARENT(elm, field) = parent;                                             \\\n+  RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;                          \\\n+  RB_COLOR(elm, field) = RB_RED;                                              \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define RB_SET_BLACKRED(black, red, field) do {                               \\\n+  RB_COLOR(black, field) = RB_BLACK;                                          \\\n+  RB_COLOR(red, field) = RB_RED;                                              \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#ifndef RB_AUGMENT\n+#define RB_AUGMENT(x)  do {} while (0)\n+#endif\n+\n+#define RB_ROTATE_LEFT(head, elm, tmp, field) do {                            \\\n+  (tmp) = RB_RIGHT(elm, field);                                               \\\n+  if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field)) != NULL) {                 \\\n+    RB_PARENT(RB_LEFT(tmp, field), field) = (elm);                            \\\n+  }                                                                           \\\n+  RB_AUGMENT(elm);                                                            \\\n+  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \\\n+    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \\\n+      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \\\n+    else                                                                      \\\n+      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \\\n+  } else                                                                      \\\n+    (head)->rbh_root = (tmp);                                                 \\\n+  RB_LEFT(tmp, field) = (elm);                                                \\\n+  RB_PARENT(elm, field) = (tmp);                                              \\\n+  RB_AUGMENT(tmp);                                                            \\\n+  if ((RB_PARENT(tmp, field)))                                                \\\n+    RB_AUGMENT(RB_PARENT(tmp, field));                                        \\\n+} while (/*CONSTCOND*/ 0)\n+\n+#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {                           \\\n+  (tmp) = RB_LEFT(elm, field);                                                \\\n+  if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field)) != NULL) {                 \\\n+    RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);                           \\\n+  }                                                                           \\\n+  RB_AUGMENT(elm);                                                            \\\n+  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \\\n+    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \\\n+      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \\\n+    else                                                                      \\\n+      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \\\n+  } else                                                                      \\\n+    (head)->rbh_root = (tmp);                                                 \\\n+  RB_RIGHT(tmp, field) = (elm);                                               \\\n+  RB_PARENT(elm, field) = (tmp);                                              \\\n+  RB_AUGMENT(tmp);                                                            \\\n+  if ((RB_PARENT(tmp, field)))                                                \\\n+    RB_AUGMENT(RB_PARENT(tmp, field));                                        \\\n+} while (/*CONSTCOND*/ 0)\n+\n+/* Generates prototypes and inline functions */\n+#define  RB_PROTOTYPE(name, type, field, cmp)                                 \\\n+  RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)\n+#define  RB_PROTOTYPE_STATIC(name, type, field, cmp)                          \\\n+  RB_PROTOTYPE_INTERNAL(name, type, field, cmp, __unused static)\n+#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)                   \\\n+attr void name##_RB_INSERT_COLOR(struct name *, struct type *);               \\\n+attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\\\n+attr struct type *name##_RB_REMOVE(struct name *, struct type *);             \\\n+attr struct type *name##_RB_INSERT(struct name *, struct type *);             \\\n+attr struct type *name##_RB_FIND(struct name *, struct type *);               \\\n+attr struct type *name##_RB_NFIND(struct name *, struct type *);              \\\n+attr struct type *name##_RB_NEXT(struct type *);                              \\\n+attr struct type *name##_RB_PREV(struct type *);                              \\\n+attr struct type *name##_RB_MINMAX(struct name *, int);                       \\\n+                                                                              \\\n+\n+/* Main rb operation.\n+ * Moves node close to the key of elm to top\n+ */\n+#define  RB_GENERATE(name, type, field, cmp)                                  \\\n+  RB_GENERATE_INTERNAL(name, type, field, cmp,)\n+#define  RB_GENERATE_STATIC(name, type, field, cmp)                           \\\n+  RB_GENERATE_INTERNAL(name, type, field, cmp, __unused static)\n+#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)                    \\\n+attr void                                                                     \\\n+name##_RB_INSERT_COLOR(struct name *head, struct type *elm)                   \\\n+{                                                                             \\\n+  struct type *parent, *gparent, *tmp;                                        \\\n+  while ((parent = RB_PARENT(elm, field)) != NULL &&                          \\\n+      RB_COLOR(parent, field) == RB_RED) {                                    \\\n+    gparent = RB_PARENT(parent, field);                                       \\\n+    if (parent == RB_LEFT(gparent, field)) {                                  \\\n+      tmp = RB_RIGHT(gparent, field);                                         \\\n+      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \\\n+        RB_COLOR(tmp, field) = RB_BLACK;                                      \\\n+        RB_SET_BLACKRED(parent, gparent, field);                              \\\n+        elm = gparent;                                                        \\\n+        continue;                                                             \\\n+      }                                                                       \\\n+      if (RB_RIGHT(parent, field) == elm) {                                   \\\n+        RB_ROTATE_LEFT(head, parent, tmp, field);                             \\\n+        tmp = parent;                                                         \\\n+        parent = elm;                                                         \\\n+        elm = tmp;                                                            \\\n+      }                                                                       \\\n+      RB_SET_BLACKRED(parent, gparent, field);                                \\\n+      RB_ROTATE_RIGHT(head, gparent, tmp, field);                             \\\n+    } else {                                                                  \\\n+      tmp = RB_LEFT(gparent, field);                                          \\\n+      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \\\n+        RB_COLOR(tmp, field) = RB_BLACK;                                      \\\n+        RB_SET_BLACKRED(parent, gparent, field);                              \\\n+        elm = gparent;                                                        \\\n+        continue;                                                             \\\n+      }                                                                       \\\n+      if (RB_LEFT(parent, field) == elm) {                                    \\\n+        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \\\n+        tmp = parent;                                                         \\\n+        parent = elm;                                                         \\\n+        elm = tmp;                                                            \\\n+      }                                                                       \\\n+      RB_SET_BLACKRED(parent, gparent, field);                                \\\n+      RB_ROTATE_LEFT(head, gparent, tmp, field);                              \\\n+    }                                                                         \\\n+  }                                                                           \\\n+  RB_COLOR(head->rbh_root, field) = RB_BLACK;                                 \\\n+}                                                                             \\\n+                                                                              \\\n+attr void                                                                     \\\n+name##_RB_REMOVE_COLOR(struct name *head, struct type *parent,                \\\n+    struct type *elm)                                                         \\\n+{                                                                             \\\n+  struct type *tmp;                                                           \\\n+  while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&                 \\\n+      elm != RB_ROOT(head)) {                                                 \\\n+    if (RB_LEFT(parent, field) == elm) {                                      \\\n+      tmp = RB_RIGHT(parent, field);                                          \\\n+      if (RB_COLOR(tmp, field) == RB_RED) {                                   \\\n+        RB_SET_BLACKRED(tmp, parent, field);                                  \\\n+        RB_ROTATE_LEFT(head, parent, tmp, field);                             \\\n+        tmp = RB_RIGHT(parent, field);                                        \\\n+      }                                                                       \\\n+      if ((RB_LEFT(tmp, field) == NULL ||                                     \\\n+          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \\\n+          (RB_RIGHT(tmp, field) == NULL ||                                    \\\n+          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \\\n+        RB_COLOR(tmp, field) = RB_RED;                                        \\\n+        elm = parent;                                                         \\\n+        parent = RB_PARENT(elm, field);                                       \\\n+      } else {                                                                \\\n+        if (RB_RIGHT(tmp, field) == NULL ||                                   \\\n+            RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {              \\\n+          struct type *oleft;                                                 \\\n+          if ((oleft = RB_LEFT(tmp, field))                                   \\\n+              != NULL)                                                        \\\n+            RB_COLOR(oleft, field) = RB_BLACK;                                \\\n+          RB_COLOR(tmp, field) = RB_RED;                                      \\\n+          RB_ROTATE_RIGHT(head, tmp, oleft, field);                           \\\n+          tmp = RB_RIGHT(parent, field);                                      \\\n+        }                                                                     \\\n+        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \\\n+        RB_COLOR(parent, field) = RB_BLACK;                                   \\\n+        if (RB_RIGHT(tmp, field))                                             \\\n+          RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;                   \\\n+        RB_ROTATE_LEFT(head, parent, tmp, field);                             \\\n+        elm = RB_ROOT(head);                                                  \\\n+        break;                                                                \\\n+      }                                                                       \\\n+    } else {                                                                  \\\n+      tmp = RB_LEFT(parent, field);                                           \\\n+      if (RB_COLOR(tmp, field) == RB_RED) {                                   \\\n+        RB_SET_BLACKRED(tmp, parent, field);                                  \\\n+        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \\\n+        tmp = RB_LEFT(parent, field);                                         \\\n+      }                                                                       \\\n+      if ((RB_LEFT(tmp, field) == NULL ||                                     \\\n+          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \\\n+          (RB_RIGHT(tmp, field) == NULL ||                                    \\\n+          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \\\n+        RB_COLOR(tmp, field) = RB_RED;                                        \\\n+        elm = parent;                                                         \\\n+        parent = RB_PARENT(elm, field);                                       \\\n+      } else {                                                                \\\n+        if (RB_LEFT(tmp, field) == NULL ||                                    \\\n+            RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {               \\\n+          struct type *oright;                                                \\\n+          if ((oright = RB_RIGHT(tmp, field))                                 \\\n+              != NULL)                                                        \\\n+            RB_COLOR(oright, field) = RB_BLACK;                               \\\n+          RB_COLOR(tmp, field) = RB_RED;                                      \\\n+          RB_ROTATE_LEFT(head, tmp, oright, field);                           \\\n+          tmp = RB_LEFT(parent, field);                                       \\\n+        }                                                                     \\\n+        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \\\n+        RB_COLOR(parent, field) = RB_BLACK;                                   \\\n+        if (RB_LEFT(tmp, field))                                              \\\n+          RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;                    \\\n+        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \\\n+        elm = RB_ROOT(head);                                                  \\\n+        break;                                                                \\\n+      }                                                                       \\\n+    }                                                                         \\\n+  }                                                                           \\\n+  if (elm)                                                                    \\\n+    RB_COLOR(elm, field) = RB_BLACK;                                          \\\n+}                                                                             \\\n+                                                                              \\\n+attr struct type *                                                            \\\n+name##_RB_REMOVE(struct name *head, struct type *elm)                         \\\n+{                                                                             \\\n+  struct type *child, *parent, *old = elm;                                    \\\n+  int color;                                                                  \\\n+  if (RB_LEFT(elm, field) == NULL)                                            \\\n+    child = RB_RIGHT(elm, field);                                             \\\n+  else if (RB_RIGHT(elm, field) == NULL)                                      \\\n+    child = RB_LEFT(elm, field);                                              \\\n+  else {                                                                      \\\n+    struct type *left;                                                        \\\n+    elm = RB_RIGHT(elm, field);                                               \\\n+    while ((left = RB_LEFT(elm, field)) != NULL)                              \\\n+      elm = left;                                                             \\\n+    child = RB_RIGHT(elm, field);                                             \\\n+    parent = RB_PARENT(elm, field);                                           \\\n+    color = RB_COLOR(elm, field);                                             \\\n+    if (child)                                                                \\\n+      RB_PARENT(child, field) = parent;                                       \\\n+    if (parent) {                                                             \\\n+      if (RB_LEFT(parent, field) == elm)                                      \\\n+        RB_LEFT(parent, field) = child;                                       \\\n+      else                                                                    \\\n+        RB_RIGHT(parent, field) = child;                                      \\\n+      RB_AUGMENT(parent);                                                     \\\n+    } else                                                                    \\\n+      RB_ROOT(head) = child;                                                  \\\n+    if (RB_PARENT(elm, field) == old)                                         \\\n+      parent = elm;                                                           \\\n+    (elm)->field = (old)->field;                                              \\\n+    if (RB_PARENT(old, field)) {                                              \\\n+      if (RB_LEFT(RB_PARENT(old, field), field) == old)                       \\\n+        RB_LEFT(RB_PARENT(old, field), field) = elm;                          \\\n+      else                                                                    \\\n+        RB_RIGHT(RB_PARENT(old, field), field) = elm;                         \\\n+      RB_AUGMENT(RB_PARENT(old, field));                                      \\\n+    } else                                                                    \\\n+      RB_ROOT(head) = elm;                                                    \\\n+    RB_PARENT(RB_LEFT(old, field), field) = elm;                              \\\n+    if (RB_RIGHT(old, field))                                                 \\\n+      RB_PARENT(RB_RIGHT(old, field), field) = elm;                           \\\n+    if (parent) {                                                             \\\n+      left = parent;                                                          \\\n+      do {                                                                    \\\n+        RB_AUGMENT(left);                                                     \\\n+      } while ((left = RB_PARENT(left, field)) != NULL);                      \\\n+    }                                                                         \\\n+    goto color;                                                               \\\n+  }                                                                           \\\n+  parent = RB_PARENT(elm, field);                                             \\\n+  color = RB_COLOR(elm, field);                                               \\\n+  if (child)                                                                  \\\n+    RB_PARENT(child, field) = parent;                                         \\\n+  if (parent) {                                                               \\\n+    if (RB_LEFT(parent, field) == elm)                                        \\\n+      RB_LEFT(parent, field) = child;                                         \\\n+    else                                                                      \\\n+      RB_RIGHT(parent, field) = child;                                        \\\n+    RB_AUGMENT(parent);                                                       \\\n+  } else                                                                      \\\n+    RB_ROOT(head) = child;                                                    \\\n+color:                                                                        \\\n+  if (color == RB_BLACK)                                                      \\\n+    name##_RB_REMOVE_COLOR(head, parent, child);                              \\\n+  return (old);                                                               \\\n+}                                                                             \\\n+                                                                              \\\n+/* Inserts a node into the RB tree */                                         \\\n+attr struct type *                                                            \\\n+name##_RB_INSERT(struct name *head, struct type *elm)                         \\\n+{                                                                             \\\n+  struct type *tmp;                                                           \\\n+  struct type *parent = NULL;                                                 \\\n+  int comp = 0;                                                               \\\n+  tmp = RB_ROOT(head);                                                        \\\n+  while (tmp) {                                                               \\\n+    parent = tmp;                                                             \\\n+    comp = (cmp)(elm, parent);                                                \\\n+    if (comp < 0)                                                             \\\n+      tmp = RB_LEFT(tmp, field);                                              \\\n+    else if (comp > 0)                                                        \\\n+      tmp = RB_RIGHT(tmp, field);                                             \\\n+    else                                                                      \\\n+      return (tmp);                                                           \\\n+  }                                                                           \\\n+  RB_SET(elm, parent, field);                                                 \\\n+  if (parent != NULL) {                                                       \\\n+    if (comp < 0)                                                             \\\n+      RB_LEFT(parent, field) = elm;                                           \\\n+    else                                                                      \\\n+      RB_RIGHT(parent, field) = elm;                                          \\\n+    RB_AUGMENT(parent);                                                       \\\n+  } else                                                                      \\\n+    RB_ROOT(head) = elm;                                                      \\\n+  name##_RB_INSERT_COLOR(head, elm);                                          \\\n+  return (NULL);                                                              \\\n+}                                                                             \\\n+                                                                              \\\n+/* Finds the node with the same key as elm */                                 \\\n+attr struct type *                                                            \\\n+name##_RB_FIND(struct name *head, struct type *elm)                           \\\n+{                                                                             \\\n+  struct type *tmp = RB_ROOT(head);                                           \\\n+  int comp;                                                                   \\\n+  while (tmp) {                                                               \\\n+    comp = cmp(elm, tmp);                                                     \\\n+    if (comp < 0)                                                             \\\n+      tmp = RB_LEFT(tmp, field);                                              \\\n+    else if (comp > 0)                                                        \\\n+      tmp = RB_RIGHT(tmp, field);                                             \\\n+    else                                                                      \\\n+      return (tmp);                                                           \\\n+  }                                                                           \\\n+  return (NULL);                                                              \\\n+}                                                                             \\\n+                                                                              \\\n+/* Finds the first node greater than or equal to the search key */            \\\n+attr struct type *                                                            \\\n+name##_RB_NFIND(struct name *head, struct type *elm)                          \\\n+{                                                                             \\\n+  struct type *tmp = RB_ROOT(head);                                           \\\n+  struct type *res = NULL;                                                    \\\n+  int comp;                                                                   \\\n+  while (tmp) {                                                               \\\n+    comp = cmp(elm, tmp);                                                     \\\n+    if (comp < 0) {                                                           \\\n+      res = tmp;                                                              \\\n+      tmp = RB_LEFT(tmp, field);                                              \\\n+    }                                                                         \\\n+    else if (comp > 0)                                                        \\\n+      tmp = RB_RIGHT(tmp, field);                                             \\\n+    else                                                                      \\\n+      return (tmp);                                                           \\\n+  }                                                                           \\\n+  return (res);                                                               \\\n+}                                                                             \\\n+                                                                              \\\n+/* ARGSUSED */                                                                \\\n+attr struct type *                                                            \\\n+name##_RB_NEXT(struct type *elm)                                              \\\n+{                                                                             \\\n+  if (RB_RIGHT(elm, field)) {                                                 \\\n+    elm = RB_RIGHT(elm, field);                                               \\\n+    while (RB_LEFT(elm, field))                                               \\\n+      elm = RB_LEFT(elm, field);                                              \\\n+  } else {                                                                    \\\n+    if (RB_PARENT(elm, field) &&                                              \\\n+        (elm == RB_LEFT(RB_PARENT(elm, field), field)))                       \\\n+      elm = RB_PARENT(elm, field);                                            \\\n+    else {                                                                    \\\n+      while (RB_PARENT(elm, field) &&                                         \\\n+          (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                    \\\n+        elm = RB_PARENT(elm, field);                                          \\\n+      elm = RB_PARENT(elm, field);                                            \\\n+    }                                                                         \\\n+  }                                                                           \\\n+  return (elm);                                                               \\\n+}                                                                             \\\n+                                                                              \\\n+/* ARGSUSED */                                                                \\\n+attr struct type *                                                            \\\n+name##_RB_PREV(struct type *elm)                                              \\\n+{                                                                             \\\n+  if (RB_LEFT(elm, field)) {                                                  \\\n+    elm = RB_LEFT(elm, field);                                                \\\n+    while (RB_RIGHT(elm, field))                                              \\\n+      elm = RB_RIGHT(elm, field);                                             \\\n+  } else {                                                                    \\\n+    if (RB_PARENT(elm, field) &&                                              \\\n+        (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                      \\\n+      elm = RB_PARENT(elm, field);                                            \\\n+    else {                                                                    \\\n+      while (RB_PARENT(elm, field) &&                                         \\\n+          (elm == RB_LEFT(RB_PARENT(elm, field), field)))                     \\\n+        elm = RB_PARENT(elm, field);                                          \\\n+      elm = RB_PARENT(elm, field);                                            \\\n+    }                                                                         \\\n+  }                                                                           \\\n+  return (elm);                                                               \\\n+}                                                                             \\\n+                                                                              \\\n+attr struct type *                                                            \\\n+name##_RB_MINMAX(struct name *head, int val)                                  \\\n+{                                                                             \\\n+  struct type *tmp = RB_ROOT(head);                                           \\\n+  struct type *parent = NULL;                                                 \\\n+  while (tmp) {                                                               \\\n+    parent = tmp;                                                             \\\n+    if (val < 0)                                                              \\\n+      tmp = RB_LEFT(tmp, field);                                              \\\n+    else                                                                      \\\n+      tmp = RB_RIGHT(tmp, field);                                             \\\n+  }                                                                           \\\n+  return (parent);                                                            \\\n+}\n+\n+#define RB_NEGINF   -1\n+#define RB_INF      1\n+\n+#define RB_INSERT(name, x, y)   name##_RB_INSERT(x, y)\n+#define RB_REMOVE(name, x, y)   name##_RB_REMOVE(x, y)\n+#define RB_FIND(name, x, y)     name##_RB_FIND(x, y)\n+#define RB_NFIND(name, x, y)    name##_RB_NFIND(x, y)\n+#define RB_NEXT(name, x, y)     name##_RB_NEXT(y)\n+#define RB_PREV(name, x, y)     name##_RB_PREV(y)\n+#define RB_MIN(name, x)         name##_RB_MINMAX(x, RB_NEGINF)\n+#define RB_MAX(name, x)         name##_RB_MINMAX(x, RB_INF)\n+\n+#define RB_FOREACH(x, name, head)                                             \\\n+  for ((x) = RB_MIN(name, head);                                              \\\n+       (x) != NULL;                                                           \\\n+       (x) = name##_RB_NEXT(x))\n+\n+#define RB_FOREACH_FROM(x, name, y)                                           \\\n+  for ((x) = (y);                                                             \\\n+      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \\\n+       (x) = (y))\n+\n+#define RB_FOREACH_SAFE(x, name, head, y)                                     \\\n+  for ((x) = RB_MIN(name, head);                                              \\\n+      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \\\n+       (x) = (y))\n+\n+#define RB_FOREACH_REVERSE(x, name, head)                                     \\\n+  for ((x) = RB_MAX(name, head);                                              \\\n+       (x) != NULL;                                                           \\\n+       (x) = name##_RB_PREV(x))\n+\n+#define RB_FOREACH_REVERSE_FROM(x, name, y)                                   \\\n+  for ((x) = (y);                                                             \\\n+      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \\\n+       (x) = (y))\n+\n+#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)                             \\\n+  for ((x) = RB_MAX(name, head);                                              \\\n+      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \\\n+       (x) = (y))\n+\n+#endif  /* _UV_TREE_H_ */"}, {"sha": "921ac20df3d404f59a987cff66b0056171ff9971", "filename": "src/rt/libuv/uv-common.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-common.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-common.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv-common.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,77 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+\n+#include <assert.h>\n+#include <stddef.h> /* NULL */\n+\n+\n+static uv_counters_t counters;\n+\n+\n+uv_counters_t* const uv_counters() {\n+  return &counters;\n+}\n+\n+\n+const char* uv_err_name(uv_err_t err) {\n+  switch (err.code) {\n+    case UV_UNKNOWN: return \"UNKNOWN\";\n+    case UV_OK: return \"OK\";\n+    case UV_EOF: return \"EOF\";\n+    case UV_EACCESS: return \"EACCESS\";\n+    case UV_EAGAIN: return \"EAGAIN\";\n+    case UV_EADDRINUSE: return \"EADDRINUSE\";\n+    case UV_EADDRNOTAVAIL: return \"EADDRNOTAVAIL\";\n+    case UV_EAFNOSUPPORT: return \"EAFNOSUPPORT\";\n+    case UV_EALREADY: return \"EALREADY\";\n+    case UV_EBADF: return \"EBADF\";\n+    case UV_EBUSY: return \"EBUSY\";\n+    case UV_ECONNABORTED: return \"ECONNABORTED\";\n+    case UV_ECONNREFUSED: return \"ECONNREFUSED\";\n+    case UV_ECONNRESET: return \"ECONNRESET\";\n+    case UV_EDESTADDRREQ: return \"EDESTADDRREQ\";\n+    case UV_EFAULT: return \"EFAULT\";\n+    case UV_EHOSTUNREACH: return \"EHOSTUNREACH\";\n+    case UV_EINTR: return \"EINTR\";\n+    case UV_EINVAL: return \"EINVAL\";\n+    case UV_EISCONN: return \"EISCONN\";\n+    case UV_EMFILE: return \"EMFILE\";\n+    case UV_ENETDOWN: return \"ENETDOWN\";\n+    case UV_ENETUNREACH: return \"ENETUNREACH\";\n+    case UV_ENFILE: return \"ENFILE\";\n+    case UV_ENOBUFS: return \"ENOBUFS\";\n+    case UV_ENOMEM: return \"ENOMEM\";\n+    case UV_ENONET: return \"ENONET\";\n+    case UV_ENOPROTOOPT: return \"ENOPROTOOPT\";\n+    case UV_ENOTCONN: return \"ENOTCONN\";\n+    case UV_ENOTSOCK: return \"ENOTSOCK\";\n+    case UV_ENOTSUP: return \"ENOTSUP\";\n+    case UV_EPROTO: return \"EPROTO\";\n+    case UV_EPROTONOSUPPORT: return \"EPROTONOSUPPORT\";\n+    case UV_EPROTOTYPE: return \"EPROTOTYPE\";\n+    case UV_ETIMEDOUT: return \"ETIMEDOUT\";\n+    default:\n+      assert(0);\n+      return NULL;\n+  }\n+}"}, {"sha": "b0e85d95706d0abdc6382ed85d5fc0a528d3d2df", "filename": "src/rt/libuv/uv-unix.c", "status": "added", "additions": 1301, "deletions": 0, "changes": 1301, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-unix.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-unix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv-unix.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,1301 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+\n+#include <stddef.h> /* NULL */\n+#include <stdio.h> /* printf */\n+#include <stdlib.h>\n+#include <string.h> /* strerror */\n+#include <errno.h>\n+#include <assert.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <arpa/inet.h>\n+#include <limits.h> /* PATH_MAX */\n+\n+#if defined(__APPLE__)\n+#include <mach-o/dyld.h> /* _NSGetExecutablePath */\n+#endif\n+\n+#if defined(__FreeBSD__)\n+#include <sys/sysctl.h>\n+#endif\n+\n+\n+static uv_err_t last_err;\n+\n+\n+void uv__tcp_io(EV_P_ ev_io* watcher, int revents);\n+void uv__next(EV_P_ ev_idle* watcher, int revents);\n+static void uv__tcp_connect(uv_tcp_t*);\n+int uv_tcp_open(uv_tcp_t*, int fd);\n+static void uv__finish_close(uv_handle_t* handle);\n+\n+\n+/* flags */\n+enum {\n+  UV_CLOSING  = 0x00000001, /* uv_close() called but not finished. */\n+  UV_CLOSED   = 0x00000002, /* close(2) finished. */\n+  UV_READING  = 0x00000004, /* uv_read_start() called. */\n+  UV_SHUTTING = 0x00000008, /* uv_shutdown() called but not complete. */\n+  UV_SHUT     = 0x00000010  /* Write side closed. */\n+};\n+\n+\n+void uv_flag_set(uv_handle_t* handle, int flag) {\n+  handle->flags |= flag;\n+}\n+\n+\n+uv_err_t uv_last_error() {\n+  return last_err;\n+}\n+\n+\n+char* uv_strerror(uv_err_t err) {\n+  return strerror(err.sys_errno_);\n+}\n+\n+\n+void uv_flag_unset(uv_handle_t* handle, int flag) {\n+  handle->flags = handle->flags & ~flag;\n+}\n+\n+\n+int uv_flag_is_set(uv_handle_t* handle, int flag) {\n+  return (handle->flags & flag) != 0;\n+}\n+\n+\n+static uv_err_code uv_translate_sys_error(int sys_errno) {\n+  switch (sys_errno) {\n+    case 0: return UV_OK;\n+    case EACCES: return UV_EACCESS;\n+    case EAGAIN: return UV_EAGAIN;\n+    case ECONNRESET: return UV_ECONNRESET;\n+    case EFAULT: return UV_EFAULT;\n+    case EMFILE: return UV_EMFILE;\n+    case EINVAL: return UV_EINVAL;\n+    case ECONNREFUSED: return UV_ECONNREFUSED;\n+    case EADDRINUSE: return UV_EADDRINUSE;\n+    case EADDRNOTAVAIL: return UV_EADDRNOTAVAIL;\n+    default: return UV_UNKNOWN;\n+  }\n+}\n+\n+\n+static uv_err_t uv_err_new_artificial(uv_handle_t* handle, int code) {\n+  uv_err_t err;\n+  err.sys_errno_ = 0;\n+  err.code = code;\n+  last_err = err;\n+  return err;\n+}\n+\n+\n+static uv_err_t uv_err_new(uv_handle_t* handle, int sys_error) {\n+  uv_err_t err;\n+  err.sys_errno_ = sys_error;\n+  err.code = uv_translate_sys_error(sys_error);\n+  last_err = err;\n+  return err;\n+}\n+\n+\n+struct sockaddr_in uv_ip4_addr(char* ip, int port) {\n+  struct sockaddr_in addr;\n+\n+  addr.sin_family = AF_INET;\n+  addr.sin_port = htons(port);\n+  addr.sin_addr.s_addr = inet_addr(ip);\n+\n+  return addr;\n+}\n+\n+\n+int uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n+  uv_tcp_t* tcp;\n+  uv_async_t* async;\n+  uv_timer_t* timer;\n+\n+  handle->close_cb = close_cb;\n+\n+  switch (handle->type) {\n+    case UV_TCP:\n+      tcp = (uv_tcp_t*) handle;\n+      ev_io_stop(EV_DEFAULT_ &tcp->write_watcher);\n+      ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n+      break;\n+\n+    case UV_PREPARE:\n+      uv_prepare_stop((uv_prepare_t*) handle);\n+      break;\n+\n+    case UV_CHECK:\n+      uv_check_stop((uv_check_t*) handle);\n+      break;\n+\n+    case UV_IDLE:\n+      uv_idle_stop((uv_idle_t*) handle);\n+      break;\n+\n+    case UV_ASYNC:\n+      async = (uv_async_t*)handle;\n+      ev_async_stop(EV_DEFAULT_ &async->async_watcher);\n+      ev_ref(EV_DEFAULT_UC);\n+      break;\n+\n+    case UV_TIMER:\n+      timer = (uv_timer_t*)handle;\n+      if (ev_is_active(&timer->timer_watcher)) {\n+        ev_ref(EV_DEFAULT_UC);\n+      }\n+      ev_timer_stop(EV_DEFAULT_ &timer->timer_watcher);\n+      break;\n+\n+    default:\n+      assert(0);\n+      return -1;\n+  }\n+\n+  uv_flag_set(handle, UV_CLOSING);\n+\n+  /* This is used to call the on_close callback in the next loop. */\n+  ev_idle_start(EV_DEFAULT_ &handle->next_watcher);\n+  ev_feed_event(EV_DEFAULT_ &handle->next_watcher, EV_IDLE);\n+  assert(ev_is_pending(&handle->next_watcher));\n+\n+  return 0;\n+}\n+\n+\n+void uv_init() {\n+  /* Initialize the default ev loop. */\n+#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060\n+  ev_default_loop(EVBACKEND_KQUEUE);\n+#else\n+  ev_default_loop(EVFLAG_AUTO);\n+#endif\n+}\n+\n+\n+int uv_run() {\n+  ev_run(EV_DEFAULT_ 0);\n+  return 0;\n+}\n+\n+\n+static void uv__handle_init(uv_handle_t* handle, uv_handle_type type) {\n+  uv_counters()->handle_init++;\n+\n+  handle->type = type;\n+  handle->flags = 0;\n+\n+  ev_init(&handle->next_watcher, uv__next);\n+  handle->next_watcher.data = handle;\n+\n+  /* Ref the loop until this handle is closed. See uv__finish_close. */\n+  ev_ref(EV_DEFAULT_UC);\n+}\n+\n+\n+int uv_tcp_init(uv_tcp_t* tcp) {\n+  uv__handle_init((uv_handle_t*)tcp, UV_TCP);\n+  uv_counters()->tcp_init++;\n+\n+  tcp->alloc_cb = NULL;\n+  tcp->connect_req = NULL;\n+  tcp->accepted_fd = -1;\n+  tcp->fd = -1;\n+  tcp->delayed_error = 0;\n+  ngx_queue_init(&tcp->write_queue);\n+  tcp->write_queue_size = 0;\n+\n+  ev_init(&tcp->read_watcher, uv__tcp_io);\n+  tcp->read_watcher.data = tcp;\n+\n+  ev_init(&tcp->write_watcher, uv__tcp_io);\n+  tcp->write_watcher.data = tcp;\n+\n+  assert(ngx_queue_empty(&tcp->write_queue));\n+  assert(tcp->write_queue_size == 0);\n+\n+  return 0;\n+}\n+\n+\n+int uv_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {\n+  int addrsize = sizeof(struct sockaddr_in);\n+  int domain = AF_INET;\n+  int r;\n+\n+  if (tcp->fd <= 0) {\n+    int fd = socket(AF_INET, SOCK_STREAM, 0);\n+\n+    if (fd < 0) {\n+      uv_err_new((uv_handle_t*)tcp, errno);\n+      return -1;\n+    }\n+\n+    if (uv_tcp_open(tcp, fd)) {\n+      close(fd);\n+      return -2;\n+    }\n+  }\n+\n+  assert(tcp->fd >= 0);\n+\n+  if (addr.sin_family != AF_INET) {\n+    uv_err_new((uv_handle_t*)tcp, EFAULT);\n+    return -1;\n+  }\n+\n+  r = bind(tcp->fd, (struct sockaddr*) &addr, addrsize);\n+  tcp->delayed_error = 0;\n+\n+  if (r) {\n+    switch (errno) {\n+      case EADDRINUSE:\n+        tcp->delayed_error = errno;\n+        return 0;\n+\n+      default:\n+        uv_err_new((uv_handle_t*)tcp, errno);\n+        return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_tcp_open(uv_tcp_t* tcp, int fd) {\n+  int yes;\n+  int r;\n+\n+  assert(fd >= 0);\n+  tcp->fd = fd;\n+\n+  /* Set non-blocking. */\n+  yes = 1;\n+  r = fcntl(fd, F_SETFL, O_NONBLOCK);\n+  assert(r == 0);\n+\n+  /* Reuse the port address. */\n+  r = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));\n+  assert(r == 0);\n+\n+  /* Associate the fd with each ev_io watcher. */\n+  ev_io_set(&tcp->read_watcher, fd, EV_READ);\n+  ev_io_set(&tcp->write_watcher, fd, EV_WRITE);\n+\n+  /* These should have been set up by uv_tcp_init. */\n+  assert(tcp->next_watcher.data == tcp);\n+  assert(tcp->write_watcher.data == tcp);\n+  assert(tcp->read_watcher.data == tcp);\n+  assert(tcp->read_watcher.cb == uv__tcp_io);\n+  assert(tcp->write_watcher.cb == uv__tcp_io);\n+\n+  return 0;\n+}\n+\n+\n+void uv__server_io(EV_P_ ev_io* watcher, int revents) {\n+  int fd;\n+  struct sockaddr addr;\n+  socklen_t addrlen;\n+  uv_tcp_t* tcp = watcher->data;\n+\n+  assert(watcher == &tcp->read_watcher ||\n+         watcher == &tcp->write_watcher);\n+  assert(revents == EV_READ);\n+\n+  assert(!uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING));\n+\n+  if (tcp->accepted_fd >= 0) {\n+    ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n+    return;\n+  }\n+\n+  while (1) {\n+    assert(tcp->accepted_fd < 0);\n+    fd = accept(tcp->fd, &addr, &addrlen);\n+\n+    if (fd < 0) {\n+      if (errno == EAGAIN) {\n+        /* No problem. */\n+        return;\n+      } else if (errno == EMFILE) {\n+        /* TODO special trick. unlock reserved socket, accept, close. */\n+        return;\n+      } else {\n+        uv_err_new((uv_handle_t*)tcp, errno);\n+        tcp->connection_cb(tcp, -1);\n+      }\n+\n+    } else {\n+      tcp->accepted_fd = fd;\n+      tcp->connection_cb(tcp, 0);\n+      if (tcp->accepted_fd >= 0) {\n+        /* The user hasn't yet accepted called uv_accept() */\n+        ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n+\n+int uv_accept(uv_tcp_t* server, uv_tcp_t* client) {\n+  if (server->accepted_fd < 0) {\n+    uv_err_new((uv_handle_t*) server, EAGAIN);\n+    return -1;\n+  }\n+\n+  if (uv_tcp_open(client, server->accepted_fd)) {\n+    /* Ignore error for now */\n+    server->accepted_fd = -1;\n+    close(server->accepted_fd);\n+    return -1;\n+  } else {\n+    server->accepted_fd = -1;\n+    ev_io_start(EV_DEFAULT_ &server->read_watcher);\n+    return 0;\n+  }\n+}\n+\n+\n+int uv_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n+  int r;\n+\n+  assert(tcp->fd >= 0);\n+\n+  if (tcp->delayed_error) {\n+    uv_err_new((uv_handle_t*)tcp, tcp->delayed_error);\n+    return -1;\n+  }\n+\n+  r = listen(tcp->fd, backlog);\n+  if (r < 0) {\n+    uv_err_new((uv_handle_t*)tcp, errno);\n+    return -1;\n+  }\n+\n+  tcp->connection_cb = cb;\n+\n+  /* Start listening for connections. */\n+  ev_io_set(&tcp->read_watcher, tcp->fd, EV_READ);\n+  ev_set_cb(&tcp->read_watcher, uv__server_io);\n+  ev_io_start(EV_DEFAULT_ &tcp->read_watcher);\n+\n+  return 0;\n+}\n+\n+\n+void uv__finish_close(uv_handle_t* handle) {\n+  uv_tcp_t* tcp;\n+\n+  assert(uv_flag_is_set(handle, UV_CLOSING));\n+  assert(!uv_flag_is_set(handle, UV_CLOSED));\n+  uv_flag_set(handle, UV_CLOSED);\n+\n+  switch (handle->type) {\n+    case UV_TCP:\n+      /* XXX Is it necessary to stop these watchers here? weren't they\n+       * supposed to be stopped in uv_close()?\n+       */\n+      tcp = (uv_tcp_t*)handle;\n+      ev_io_stop(EV_DEFAULT_ &tcp->write_watcher);\n+      ev_io_stop(EV_DEFAULT_ &tcp->read_watcher);\n+\n+      assert(!ev_is_active(&tcp->read_watcher));\n+      assert(!ev_is_active(&tcp->write_watcher));\n+\n+      close(tcp->fd);\n+      tcp->fd = -1;\n+\n+      if (tcp->accepted_fd >= 0) {\n+        close(tcp->accepted_fd);\n+        tcp->accepted_fd = -1;\n+      }\n+      break;\n+\n+    case UV_PREPARE:\n+      assert(!ev_is_active(&((uv_prepare_t*)handle)->prepare_watcher));\n+      break;\n+\n+    case UV_CHECK:\n+      assert(!ev_is_active(&((uv_check_t*)handle)->check_watcher));\n+      break;\n+\n+    case UV_IDLE:\n+      assert(!ev_is_active(&((uv_idle_t*)handle)->idle_watcher));\n+      break;\n+\n+    case UV_ASYNC:\n+      assert(!ev_is_active(&((uv_async_t*)handle)->async_watcher));\n+      break;\n+\n+    case UV_TIMER:\n+      assert(!ev_is_active(&((uv_timer_t*)handle)->timer_watcher));\n+      break;\n+\n+    default:\n+      assert(0);\n+      break;\n+  }\n+\n+  ev_idle_stop(EV_DEFAULT_ &handle->next_watcher);\n+\n+  if (handle->close_cb) {\n+    handle->close_cb(handle);\n+  }\n+\n+  ev_unref(EV_DEFAULT_UC);\n+}\n+\n+\n+uv_req_t* uv_write_queue_head(uv_tcp_t* tcp) {\n+  ngx_queue_t* q;\n+  uv_req_t* req;\n+\n+  if (ngx_queue_empty(&tcp->write_queue)) {\n+    return NULL;\n+  }\n+\n+  q = ngx_queue_head(&tcp->write_queue);\n+  if (!q) {\n+    return NULL;\n+  }\n+\n+  req = ngx_queue_data(q, struct uv_req_s, queue);\n+  assert(req);\n+\n+  return req;\n+}\n+\n+\n+void uv__next(EV_P_ ev_idle* watcher, int revents) {\n+  uv_handle_t* handle = watcher->data;\n+  assert(watcher == &handle->next_watcher);\n+  assert(revents == EV_IDLE);\n+\n+  /* For now this function is only to handle the closing event, but we might\n+   * put more stuff here later.\n+   */\n+  assert(uv_flag_is_set(handle, UV_CLOSING));\n+  uv__finish_close(handle);\n+}\n+\n+\n+static void uv__drain(uv_tcp_t* tcp) {\n+  uv_req_t* req;\n+  uv_shutdown_cb cb;\n+\n+  assert(!uv_write_queue_head(tcp));\n+  assert(tcp->write_queue_size == 0);\n+\n+  ev_io_stop(EV_DEFAULT_ &tcp->write_watcher);\n+\n+  /* Shutdown? */\n+  if (uv_flag_is_set((uv_handle_t*)tcp, UV_SHUTTING) &&\n+      !uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING) &&\n+      !uv_flag_is_set((uv_handle_t*)tcp, UV_SHUT)) {\n+    assert(tcp->shutdown_req);\n+\n+    req = tcp->shutdown_req;\n+    cb = (uv_shutdown_cb)req->cb;\n+\n+    if (shutdown(tcp->fd, SHUT_WR)) {\n+      /* Error. Report it. User should call uv_close(). */\n+      uv_err_new((uv_handle_t*)tcp, errno);\n+      if (cb) cb(req, -1);\n+    } else {\n+      uv_err_new((uv_handle_t*)tcp, 0);\n+      uv_flag_set((uv_handle_t*)tcp, UV_SHUT);\n+      if (cb) cb(req, 0);\n+    }\n+  }\n+}\n+\n+\n+void uv__write(uv_tcp_t* tcp) {\n+  uv_req_t* req;\n+  struct iovec* iov;\n+  int iovcnt;\n+  ssize_t n;\n+  uv_write_cb cb;\n+\n+  assert(tcp->fd >= 0);\n+\n+  /* TODO: should probably while(1) here until EAGAIN */\n+\n+  /* Get the request at the head of the queue. */\n+  req = uv_write_queue_head(tcp);\n+  if (!req) {\n+    assert(tcp->write_queue_size == 0);\n+    uv__drain(tcp);\n+    return;\n+  }\n+\n+  assert(req->handle == (uv_handle_t*)tcp);\n+\n+  /* Cast to iovec. We had to have our own uv_buf_t instead of iovec\n+   * because Windows's WSABUF is not an iovec.\n+   */\n+  assert(sizeof(uv_buf_t) == sizeof(struct iovec));\n+  iov = (struct iovec*) &(req->bufs[req->write_index]);\n+  iovcnt = req->bufcnt - req->write_index;\n+\n+  /* Now do the actual writev. Note that we've been updating the pointers\n+   * inside the iov each time we write. So there is no need to offset it.\n+   */\n+\n+  n = writev(tcp->fd, iov, iovcnt);\n+\n+  cb = (uv_write_cb)req->cb;\n+\n+  if (n < 0) {\n+    if (errno != EAGAIN) {\n+      uv_err_t err = uv_err_new((uv_handle_t*)tcp, errno);\n+\n+      if (cb) {\n+        cb(req, -1);\n+      }\n+      return;\n+    }\n+  } else {\n+    /* Successful write */\n+\n+    /* The loop updates the counters. */\n+    while (n > 0) {\n+      uv_buf_t* buf = &(req->bufs[req->write_index]);\n+      size_t len = buf->len;\n+\n+      assert(req->write_index < req->bufcnt);\n+\n+      if (n < len) {\n+        buf->base += n;\n+        buf->len -= n;\n+        tcp->write_queue_size -= n;\n+        n = 0;\n+\n+        /* There is more to write. Break and ensure the watcher is pending. */\n+        break;\n+\n+      } else {\n+        /* Finished writing the buf at index req->write_index. */\n+        req->write_index++;\n+\n+        assert(n >= len);\n+        n -= len;\n+\n+        assert(tcp->write_queue_size >= len);\n+        tcp->write_queue_size -= len;\n+\n+        if (req->write_index == req->bufcnt) {\n+          /* Then we're done! */\n+          assert(n == 0);\n+\n+          /* Pop the req off tcp->write_queue. */\n+          ngx_queue_remove(&req->queue);\n+          free(req->bufs); /* FIXME: we should not be allocing for each read */\n+          req->bufs = NULL;\n+\n+          /* NOTE: call callback AFTER freeing the request data. */\n+          if (cb) {\n+            cb(req, 0);\n+          }\n+\n+          if (!ngx_queue_empty(&tcp->write_queue)) {\n+            assert(tcp->write_queue_size > 0);\n+          } else {\n+            /* Write queue drained. */\n+            uv__drain(tcp);\n+          }\n+\n+          return;\n+        }\n+      }\n+    }\n+  }\n+\n+  /* Either we've counted n down to zero or we've got EAGAIN. */\n+  assert(n == 0 || n == -1);\n+\n+  /* We're not done yet. */\n+  assert(ev_is_active(&tcp->write_watcher));\n+  ev_io_start(EV_DEFAULT_ &tcp->write_watcher);\n+}\n+\n+\n+void uv__read(uv_tcp_t* tcp) {\n+  uv_buf_t buf;\n+  struct iovec* iov;\n+  ssize_t nread;\n+\n+  /* XXX: Maybe instead of having UV_READING we just test if\n+   * tcp->read_cb is NULL or not?\n+   */\n+  while (tcp->read_cb && uv_flag_is_set((uv_handle_t*)tcp, UV_READING)) {\n+    assert(tcp->alloc_cb);\n+    buf = tcp->alloc_cb(tcp, 64 * 1024);\n+\n+    assert(buf.len > 0);\n+    assert(buf.base);\n+\n+    iov = (struct iovec*) &buf;\n+\n+    nread = readv(tcp->fd, iov, 1);\n+\n+    if (nread < 0) {\n+      /* Error */\n+      if (errno == EAGAIN) {\n+        /* Wait for the next one. */\n+        if (uv_flag_is_set((uv_handle_t*)tcp, UV_READING)) {\n+          ev_io_start(EV_DEFAULT_UC_ &tcp->read_watcher);\n+        }\n+        uv_err_new((uv_handle_t*)tcp, EAGAIN);\n+        tcp->read_cb(tcp, 0, buf);\n+        return;\n+      } else {\n+        /* Error. User should call uv_close(). */\n+        uv_err_new((uv_handle_t*)tcp, errno);\n+        tcp->read_cb(tcp, -1, buf);\n+        assert(!ev_is_active(&tcp->read_watcher));\n+        return;\n+      }\n+    } else if (nread == 0) {\n+      /* EOF */\n+      uv_err_new_artificial((uv_handle_t*)tcp, UV_EOF);\n+      ev_io_stop(EV_DEFAULT_UC_ &tcp->read_watcher);\n+      tcp->read_cb(tcp, -1, buf);\n+      return;\n+    } else {\n+      /* Successful read */\n+      tcp->read_cb(tcp, nread, buf);\n+    }\n+  }\n+}\n+\n+\n+int uv_shutdown(uv_req_t* req) {\n+  uv_tcp_t* tcp = (uv_tcp_t*)req->handle;\n+  assert(tcp->fd >= 0);\n+  assert(tcp->type == UV_TCP);\n+\n+  if (uv_flag_is_set((uv_handle_t*)tcp, UV_SHUT) ||\n+      uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSED) ||\n+      uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING)) {\n+    return -1;\n+  }\n+\n+  tcp->shutdown_req = req;\n+  req->type = UV_SHUTDOWN;\n+\n+  uv_flag_set((uv_handle_t*)tcp, UV_SHUTTING);\n+\n+  ev_io_start(EV_DEFAULT_UC_ &tcp->write_watcher);\n+\n+  return 0;\n+}\n+\n+\n+void uv__tcp_io(EV_P_ ev_io* watcher, int revents) {\n+  uv_tcp_t* tcp = watcher->data;\n+  assert(watcher == &tcp->read_watcher ||\n+         watcher == &tcp->write_watcher);\n+\n+  assert(tcp->fd >= 0);\n+\n+  assert(!uv_flag_is_set((uv_handle_t*)tcp, UV_CLOSING));\n+\n+  if (tcp->connect_req) {\n+    uv__tcp_connect(tcp);\n+  } else {\n+    if (revents & EV_READ) {\n+      uv__read(tcp);\n+    }\n+\n+    if (revents & EV_WRITE) {\n+      uv__write(tcp);\n+    }\n+  }\n+}\n+\n+\n+/**\n+ * We get called here from directly following a call to connect(2).\n+ * In order to determine if we've errored out or succeeded must call\n+ * getsockopt.\n+ */\n+static void uv__tcp_connect(uv_tcp_t* tcp) {\n+  int error;\n+  uv_req_t* req;\n+  uv_connect_cb connect_cb;\n+  socklen_t errorsize = sizeof(int);\n+\n+  assert(tcp->fd >= 0);\n+\n+  req = tcp->connect_req;\n+  assert(req);\n+\n+  if (tcp->delayed_error) {\n+    /* To smooth over the differences between unixes errors that\n+     * were reported synchronously on the first connect can be delayed\n+     * until the next tick--which is now.\n+     */\n+    error = tcp->delayed_error;\n+    tcp->delayed_error = 0;\n+  } else {\n+    /* Normal situation: we need to get the socket error from the kernel. */\n+    getsockopt(tcp->fd, SOL_SOCKET, SO_ERROR, &error, &errorsize);\n+  }\n+\n+  if (!error) {\n+    ev_io_start(EV_DEFAULT_ &tcp->read_watcher);\n+\n+    /* Successful connection */\n+    tcp->connect_req = NULL;\n+    connect_cb = (uv_connect_cb) req->cb;\n+    if (connect_cb) {\n+      connect_cb(req, 0);\n+    }\n+\n+  } else if (error == EINPROGRESS) {\n+    /* Still connecting. */\n+    return;\n+  } else {\n+    /* Error */\n+    uv_err_t err = uv_err_new((uv_handle_t*)tcp, error);\n+\n+    tcp->connect_req = NULL;\n+\n+    connect_cb = (uv_connect_cb) req->cb;\n+    if (connect_cb) {\n+      connect_cb(req, -1);\n+    }\n+  }\n+}\n+\n+\n+int uv_connect(uv_req_t* req, struct sockaddr_in addr) {\n+  uv_tcp_t* tcp = (uv_tcp_t*)req->handle;\n+  int addrsize;\n+  int r;\n+\n+  if (tcp->fd <= 0) {\n+    int fd = socket(AF_INET, SOCK_STREAM, 0);\n+\n+    if (fd < 0) {\n+      uv_err_new((uv_handle_t*)tcp, errno);\n+      return -1;\n+    }\n+\n+    if (uv_tcp_open(tcp, fd)) {\n+      close(fd);\n+      return -2;\n+    }\n+  }\n+\n+  req->type = UV_CONNECT;\n+  ngx_queue_init(&req->queue);\n+\n+  if (tcp->connect_req) {\n+    uv_err_new((uv_handle_t*)tcp, EALREADY);\n+    return -1;\n+  }\n+\n+  if (tcp->type != UV_TCP) {\n+    uv_err_new((uv_handle_t*)tcp, ENOTSOCK);\n+    return -1;\n+  }\n+\n+  tcp->connect_req = req;\n+\n+  addrsize = sizeof(struct sockaddr_in);\n+  assert(addr.sin_family == AF_INET);\n+\n+  r = connect(tcp->fd, (struct sockaddr*)&addr, addrsize);\n+  tcp->delayed_error = 0;\n+\n+  if (r != 0 && errno != EINPROGRESS) {\n+    switch (errno) {\n+      /* If we get a ECONNREFUSED wait until the next tick to report the\n+       * error. Solaris wants to report immediately--other unixes want to\n+       * wait.\n+       */\n+      case ECONNREFUSED:\n+        tcp->delayed_error = errno;\n+        break;\n+\n+      default:\n+        uv_err_new((uv_handle_t*)tcp, errno);\n+        return -1;\n+    }\n+  }\n+\n+  assert(tcp->write_watcher.data == tcp);\n+  ev_io_start(EV_DEFAULT_ &tcp->write_watcher);\n+\n+  if (tcp->delayed_error) {\n+    ev_feed_event(EV_DEFAULT_ &tcp->write_watcher, EV_WRITE);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static size_t uv__buf_count(uv_buf_t bufs[], int bufcnt) {\n+  size_t total = 0;\n+  int i;\n+\n+  for (i = 0; i < bufcnt; i++) {\n+    total += bufs[i].len;\n+  }\n+\n+  return total;\n+}\n+\n+\n+/* The buffers to be written must remain valid until the callback is called.\n+ * This is not required for the uv_buf_t array.\n+ */\n+int uv_write(uv_req_t* req, uv_buf_t bufs[], int bufcnt) {\n+  uv_tcp_t* tcp = (uv_tcp_t*)req->handle;\n+  assert(tcp->fd >= 0);\n+\n+  ngx_queue_init(&req->queue);\n+  req->type = UV_WRITE;\n+\n+  /* TODO: Don't malloc for each write... */\n+  req->bufs = malloc(sizeof(uv_buf_t) * bufcnt);\n+  memcpy(req->bufs, bufs, bufcnt * sizeof(uv_buf_t));\n+  req->bufcnt = bufcnt;\n+\n+  req->write_index = 0;\n+  tcp->write_queue_size += uv__buf_count(bufs, bufcnt);\n+\n+  /* Append the request to write_queue. */\n+  ngx_queue_insert_tail(&tcp->write_queue, &req->queue);\n+\n+  assert(!ngx_queue_empty(&tcp->write_queue));\n+  assert(tcp->write_watcher.cb == uv__tcp_io);\n+  assert(tcp->write_watcher.data == tcp);\n+  assert(tcp->write_watcher.fd == tcp->fd);\n+\n+  ev_io_start(EV_DEFAULT_ &tcp->write_watcher);\n+\n+  return 0;\n+}\n+\n+\n+void uv_ref() {\n+  ev_ref(EV_DEFAULT_UC);\n+}\n+\n+\n+void uv_unref() {\n+  ev_unref(EV_DEFAULT_UC);\n+}\n+\n+\n+void uv_update_time() {\n+  ev_now_update(EV_DEFAULT_UC);\n+}\n+\n+\n+int64_t uv_now() {\n+  return (int64_t)(ev_now(EV_DEFAULT_UC) * 1000);\n+}\n+\n+\n+int uv_read_start(uv_tcp_t* tcp, uv_alloc_cb alloc_cb, uv_read_cb read_cb) {\n+  /* The UV_READING flag is irrelevant of the state of the tcp - it just\n+   * expresses the desired state of the user.\n+   */\n+  uv_flag_set((uv_handle_t*)tcp, UV_READING);\n+\n+  /* TODO: try to do the read inline? */\n+  /* TODO: keep track of tcp state. If we've gotten a EOF then we should\n+   * not start the IO watcher.\n+   */\n+  assert(tcp->fd >= 0);\n+  assert(alloc_cb);\n+\n+  tcp->read_cb = read_cb;\n+  tcp->alloc_cb = alloc_cb;\n+\n+  /* These should have been set by uv_tcp_init. */\n+  assert(tcp->read_watcher.data == tcp);\n+  assert(tcp->read_watcher.cb == uv__tcp_io);\n+\n+  ev_io_start(EV_DEFAULT_UC_ &tcp->read_watcher);\n+  return 0;\n+}\n+\n+\n+int uv_read_stop(uv_tcp_t* tcp) {\n+  uv_flag_unset((uv_handle_t*)tcp, UV_READING);\n+\n+  ev_io_stop(EV_DEFAULT_UC_ &tcp->read_watcher);\n+  tcp->read_cb = NULL;\n+  tcp->alloc_cb = NULL;\n+  return 0;\n+}\n+\n+\n+void uv_req_init(uv_req_t* req, uv_handle_t* handle, void* cb) {\n+  uv_counters()->req_init++;\n+  req->type = UV_UNKNOWN_REQ;\n+  req->cb = cb;\n+  req->handle = handle;\n+  ngx_queue_init(&req->queue);\n+}\n+\n+\n+static void uv__prepare(EV_P_ ev_prepare* w, int revents) {\n+  uv_prepare_t* prepare = w->data;\n+\n+  if (prepare->prepare_cb) {\n+    prepare->prepare_cb((uv_handle_t*)prepare, 0);\n+  }\n+}\n+\n+\n+int uv_prepare_init(uv_prepare_t* prepare) {\n+  uv__handle_init((uv_handle_t*)prepare, UV_PREPARE);\n+  uv_counters()->prepare_init++;\n+\n+  ev_prepare_init(&prepare->prepare_watcher, uv__prepare);\n+  prepare->prepare_watcher.data = prepare;\n+\n+  prepare->prepare_cb = NULL;\n+\n+  return 0;\n+}\n+\n+\n+int uv_prepare_start(uv_prepare_t* prepare, uv_loop_cb cb) {\n+  int was_active = ev_is_active(&prepare->prepare_watcher);\n+\n+  prepare->prepare_cb = cb;\n+\n+  ev_prepare_start(EV_DEFAULT_UC_ &prepare->prepare_watcher);\n+\n+  if (!was_active) {\n+    ev_unref(EV_DEFAULT_UC);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_prepare_stop(uv_prepare_t* prepare) {\n+  int was_active = ev_is_active(&prepare->prepare_watcher);\n+\n+  ev_prepare_stop(EV_DEFAULT_UC_ &prepare->prepare_watcher);\n+\n+  if (was_active) {\n+    ev_ref(EV_DEFAULT_UC);\n+  }\n+  return 0;\n+}\n+\n+\n+\n+static void uv__check(EV_P_ ev_check* w, int revents) {\n+  uv_check_t* check = w->data;\n+\n+  if (check->check_cb) {\n+    check->check_cb((uv_handle_t*)check, 0);\n+  }\n+}\n+\n+\n+int uv_check_init(uv_check_t* check) {\n+  uv__handle_init((uv_handle_t*)check, UV_CHECK);\n+  uv_counters()->check_init;\n+\n+  ev_check_init(&check->check_watcher, uv__check);\n+  check->check_watcher.data = check;\n+\n+  check->check_cb = NULL;\n+\n+  return 0;\n+}\n+\n+\n+int uv_check_start(uv_check_t* check, uv_loop_cb cb) {\n+  int was_active = ev_is_active(&check->check_watcher);\n+\n+  check->check_cb = cb;\n+\n+  ev_check_start(EV_DEFAULT_UC_ &check->check_watcher);\n+\n+  if (!was_active) {\n+    ev_unref(EV_DEFAULT_UC);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_check_stop(uv_check_t* check) {\n+  int was_active = ev_is_active(&check->check_watcher);\n+\n+  ev_check_stop(EV_DEFAULT_UC_ &check->check_watcher);\n+\n+  if (was_active) {\n+    ev_ref(EV_DEFAULT_UC);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static void uv__idle(EV_P_ ev_idle* w, int revents) {\n+  uv_idle_t* idle = (uv_idle_t*)(w->data);\n+\n+  if (idle->idle_cb) {\n+    idle->idle_cb((uv_handle_t*)idle, 0);\n+  }\n+}\n+\n+\n+\n+int uv_idle_init(uv_idle_t* idle) {\n+  uv__handle_init((uv_handle_t*)idle, UV_IDLE);\n+  uv_counters()->idle_init++;\n+\n+  ev_idle_init(&idle->idle_watcher, uv__idle);\n+  idle->idle_watcher.data = idle;\n+\n+  idle->idle_cb = NULL;\n+\n+  return 0;\n+}\n+\n+\n+int uv_idle_start(uv_idle_t* idle, uv_loop_cb cb) {\n+  int was_active = ev_is_active(&idle->idle_watcher);\n+\n+  idle->idle_cb = cb;\n+  ev_idle_start(EV_DEFAULT_UC_ &idle->idle_watcher);\n+\n+  if (!was_active) {\n+    ev_unref(EV_DEFAULT_UC);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_idle_stop(uv_idle_t* idle) {\n+  int was_active = ev_is_active(&idle->idle_watcher);\n+\n+  ev_idle_stop(EV_DEFAULT_UC_ &idle->idle_watcher);\n+\n+  if (was_active) {\n+    ev_ref(EV_DEFAULT_UC);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_is_active(uv_handle_t* handle) {\n+  switch (handle->type) {\n+    case UV_TIMER:\n+      return ev_is_active(&((uv_timer_t*)handle)->timer_watcher);\n+\n+    case UV_PREPARE:\n+      return ev_is_active(&((uv_prepare_t*)handle)->prepare_watcher);\n+\n+    case UV_CHECK:\n+      return ev_is_active(&((uv_check_t*)handle)->check_watcher);\n+\n+    case UV_IDLE:\n+      return ev_is_active(&((uv_idle_t*)handle)->idle_watcher);\n+\n+    default:\n+      return 1;\n+  }\n+}\n+\n+\n+static void uv__async(EV_P_ ev_async* w, int revents) {\n+  uv_async_t* async = w->data;\n+\n+  if (async->async_cb) {\n+    async->async_cb((uv_handle_t*)async, 0);\n+  }\n+}\n+\n+\n+int uv_async_init(uv_async_t* async, uv_async_cb async_cb) {\n+  uv__handle_init((uv_handle_t*)async, UV_ASYNC);\n+  uv_counters()->async_init++;\n+\n+  ev_async_init(&async->async_watcher, uv__async);\n+  async->async_watcher.data = async;\n+\n+  async->async_cb = async_cb;\n+\n+  /* Note: This does not have symmetry with the other libev wrappers. */\n+  ev_async_start(EV_DEFAULT_UC_ &async->async_watcher);\n+  ev_unref(EV_DEFAULT_UC);\n+\n+  return 0;\n+}\n+\n+\n+int uv_async_send(uv_async_t* async) {\n+  ev_async_send(EV_DEFAULT_UC_ &async->async_watcher);\n+}\n+\n+\n+static void uv__timer_cb(EV_P_ ev_timer* w, int revents) {\n+  uv_timer_t* timer = w->data;\n+\n+  if (!ev_is_active(w)) {\n+    ev_ref(EV_DEFAULT_UC);\n+  }\n+\n+  if (timer->timer_cb) {\n+    timer->timer_cb((uv_handle_t*)timer, 0);\n+  }\n+}\n+\n+\n+int uv_timer_init(uv_timer_t* timer) {\n+  uv__handle_init((uv_handle_t*)timer, UV_TIMER);\n+  uv_counters()->timer_init++;\n+\n+  ev_init(&timer->timer_watcher, uv__timer_cb);\n+  timer->timer_watcher.data = timer;\n+\n+  return 0;\n+}\n+\n+\n+int uv_timer_start(uv_timer_t* timer, uv_loop_cb cb, int64_t timeout,\n+    int64_t repeat) {\n+  if (ev_is_active(&timer->timer_watcher)) {\n+    return -1;\n+  }\n+\n+  timer->timer_cb = cb;\n+  ev_timer_set(&timer->timer_watcher, timeout / 1000.0, repeat / 1000.0);\n+  ev_timer_start(EV_DEFAULT_UC_ &timer->timer_watcher);\n+  ev_unref(EV_DEFAULT_UC);\n+  return 0;\n+}\n+\n+\n+int uv_timer_stop(uv_timer_t* timer) {\n+  if (ev_is_active(&timer->timer_watcher)) {\n+    ev_ref(EV_DEFAULT_UC);\n+  }\n+\n+  ev_timer_stop(EV_DEFAULT_UC_ &timer->timer_watcher);\n+  return 0;\n+}\n+\n+\n+int uv_timer_again(uv_timer_t* timer) {\n+  if (!ev_is_active(&timer->timer_watcher)) {\n+    uv_err_new((uv_handle_t*)timer, EINVAL);\n+    return -1;\n+  }\n+\n+  ev_timer_again(EV_DEFAULT_UC_ &timer->timer_watcher);\n+  return 0;\n+}\n+\n+void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat) {\n+  assert(timer->type == UV_TIMER);\n+  timer->timer_watcher.repeat = repeat / 1000.0;\n+}\n+\n+int64_t uv_timer_get_repeat(uv_timer_t* timer) {\n+  assert(timer->type == UV_TIMER);\n+  return (int64_t)(1000 * timer->timer_watcher.repeat);\n+}\n+\n+\n+int uv_get_exepath(char* buffer, size_t* size) {\n+  uint32_t usize;\n+  int result;\n+  char* path;\n+  char* fullpath;\n+\n+  if (!buffer || !size) {\n+    return -1;\n+  }\n+\n+#if defined(__APPLE__)\n+  usize = *size;\n+  result = _NSGetExecutablePath(buffer, &usize);\n+  if (result) return result;\n+\n+  path = (char*)malloc(2 * PATH_MAX);\n+  fullpath = realpath(buffer, path);\n+\n+  if (fullpath == NULL) {\n+    free(path);\n+    return -1;\n+  }\n+\n+  strncpy(buffer, fullpath, *size);\n+  free(fullpath);\n+  *size = strlen(buffer);\n+  return 0;\n+#elif defined(__linux__)\n+  *size = readlink(\"/proc/self/exe\", buffer, *size - 1);\n+  if (*size <= 0) return -1;\n+  buffer[*size] = '\\0';\n+  return 0;\n+#elif defined(__FreeBSD__)\n+  int mib[4];\n+\n+  mib[0] = CTL_KERN;\n+  mib[1] = KERN_PROC;\n+  mib[2] = KERN_PROC_PATHNAME;\n+  mib[3] = -1;\n+\n+  size_t cb = *size;\n+  if (sysctl(mib, 4, buffer, &cb, NULL, 0) < 0) {\n+\t  *size = 0;\n+\t  return -1;\n+  }\n+  *size = strlen(buffer);\n+\n+  return 0;\n+#else\n+  assert(0 && \"implement me\");\n+  /* Need to return argv[0] */\n+#endif\n+}\n+\n+"}, {"sha": "9d6890133419fbe4b3a65490eaaeba5dc6452531", "filename": "src/rt/libuv/uv-unix.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv-unix.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,100 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#ifndef UV_UNIX_H\n+#define UV_UNIX_H\n+\n+#include \"ngx-queue.h\"\n+\n+#include \"ev/ev.h\"\n+\n+#include <sys/socket.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\n+\n+\n+/* Note: May be cast to struct iovec. See writev(2). */\n+typedef struct {\n+  char* base;\n+  size_t len;\n+} uv_buf_t;\n+\n+\n+#define UV_REQ_PRIVATE_FIELDS \\\n+  int write_index; \\\n+  ev_timer timer; \\\n+  ngx_queue_t queue; \\\n+  uv_buf_t* bufs; \\\n+  int bufcnt;\n+\n+\n+/* TODO: union or classes please! */\n+#define UV_HANDLE_PRIVATE_FIELDS \\\n+  int fd; \\\n+  int flags; \\\n+  ev_idle next_watcher;\n+\n+\n+/* UV_TCP */\n+#define UV_TCP_PRIVATE_FIELDS \\\n+  int delayed_error; \\\n+  uv_read_cb read_cb; \\\n+  uv_alloc_cb alloc_cb; \\\n+  uv_connection_cb connection_cb; \\\n+  int accepted_fd; \\\n+  uv_req_t *connect_req; \\\n+  uv_req_t *shutdown_req; \\\n+  ev_io read_watcher; \\\n+  ev_io write_watcher; \\\n+  ngx_queue_t write_queue;\n+\n+\n+/* UV_PREPARE */ \\\n+#define UV_PREPARE_PRIVATE_FIELDS \\\n+  ev_prepare prepare_watcher; \\\n+  uv_loop_cb prepare_cb;\n+\n+\n+/* UV_CHECK */\n+#define UV_CHECK_PRIVATE_FIELDS \\\n+  ev_check check_watcher; \\\n+  uv_loop_cb check_cb;\n+\n+\n+/* UV_IDLE */\n+#define UV_IDLE_PRIVATE_FIELDS \\\n+  ev_idle idle_watcher; \\\n+  uv_loop_cb idle_cb;\n+\n+\n+/* UV_ASYNC */\n+#define UV_ASYNC_PRIVATE_FIELDS \\\n+  ev_async async_watcher; \\\n+  uv_loop_cb async_cb;\n+\n+\n+/* UV_TIMER */\n+#define UV_TIMER_PRIVATE_FIELDS \\\n+  ev_timer timer_watcher; \\\n+  uv_loop_cb timer_cb;\n+\n+\n+#endif /* UV_UNIX_H */"}, {"sha": "6a42b4d47722914afe3976c2b6a76b7b8a6a5b98", "filename": "src/rt/libuv/uv-win.c", "status": "added", "additions": 1766, "deletions": 0, "changes": 1766, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-win.c", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-win.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv-win.c?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,1766 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <limits.h>\n+#include <malloc.h>\n+#include <stdio.h>\n+\n+#include \"uv.h\"\n+#include \"tree.h\"\n+\n+/*\n+ * Guids and typedefs for winsock extension functions\n+ * Mingw32 doesn't have these :-(\n+ */\n+#ifndef WSAID_ACCEPTEX\n+# define WSAID_ACCEPTEX                                        \\\n+         {0xb5367df1, 0xcbac, 0x11cf,                          \\\n+         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n+\n+# define WSAID_CONNECTEX                                       \\\n+         {0x25a207b9, 0xddf3, 0x4660,                          \\\n+         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}\n+\n+# define WSAID_GETACCEPTEXSOCKADDRS                            \\\n+         {0xb5367df2, 0xcbac, 0x11cf,                          \\\n+         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n+\n+# define WSAID_DISCONNECTEX                                    \\\n+         {0x7fda2e11, 0x8630, 0x436f,                          \\\n+         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}\n+\n+# define WSAID_TRANSMITFILE                                    \\\n+         {0xb5367df0, 0xcbac, 0x11cf,                          \\\n+         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n+\n+  typedef BOOL(*LPFN_ACCEPTEX)\n+              (SOCKET sListenSocket,\n+               SOCKET sAcceptSocket,\n+               PVOID lpOutputBuffer,\n+               DWORD dwReceiveDataLength,\n+               DWORD dwLocalAddressLength,\n+               DWORD dwRemoteAddressLength,\n+               LPDWORD lpdwBytesReceived,\n+               LPOVERLAPPED lpOverlapped);\n+\n+  typedef BOOL(*LPFN_CONNECTEX)\n+              (SOCKET s,\n+               const struct sockaddr* name,\n+               int namelen,\n+               PVOID lpSendBuffer,\n+               DWORD dwSendDataLength,\n+               LPDWORD lpdwBytesSent,\n+               LPOVERLAPPED lpOverlapped);\n+\n+  typedef void(*LPFN_GETACCEPTEXSOCKADDRS)\n+              (PVOID lpOutputBuffer,\n+               DWORD dwReceiveDataLength,\n+               DWORD dwLocalAddressLength,\n+               DWORD dwRemoteAddressLength,\n+               LPSOCKADDR* LocalSockaddr,\n+               LPINT LocalSockaddrLength,\n+               LPSOCKADDR* RemoteSockaddr,\n+               LPINT RemoteSockaddrLength);\n+\n+  typedef BOOL(*LPFN_DISCONNECTEX)\n+              (SOCKET hSocket,\n+               LPOVERLAPPED lpOverlapped,\n+               DWORD dwFlags,\n+               DWORD reserved);\n+\n+  typedef BOOL(*LPFN_TRANSMITFILE)\n+              (SOCKET hSocket,\n+               HANDLE hFile,\n+               DWORD nNumberOfBytesToWrite,\n+               DWORD nNumberOfBytesPerSend,\n+               LPOVERLAPPED lpOverlapped,\n+               LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,\n+               DWORD dwFlags);\n+#endif\n+\n+/*\n+ * MinGW is missing this too\n+ */\n+#ifndef SO_UPDATE_CONNECT_CONTEXT\n+# define SO_UPDATE_CONNECT_CONTEXT   0x7010\n+#endif\n+\n+\n+/*\n+ * Pointers to winsock extension functions to be retrieved dynamically\n+ */\n+static LPFN_CONNECTEX               pConnectEx;\n+static LPFN_ACCEPTEX                pAcceptEx;\n+static LPFN_GETACCEPTEXSOCKADDRS    pGetAcceptExSockAddrs;\n+static LPFN_DISCONNECTEX            pDisconnectEx;\n+static LPFN_TRANSMITFILE            pTransmitFile;\n+\n+\n+/*\n+ * Private uv_handle flags\n+ */\n+#define UV_HANDLE_CLOSING          0x0001\n+#define UV_HANDLE_CLOSED           0x0002\n+#define UV_HANDLE_BOUND            0x0004\n+#define UV_HANDLE_LISTENING        0x0008\n+#define UV_HANDLE_CONNECTION       0x0010\n+#define UV_HANDLE_CONNECTED        0x0020\n+#define UV_HANDLE_READING          0x0040\n+#define UV_HANDLE_ACTIVE           0x0040\n+#define UV_HANDLE_EOF              0x0080\n+#define UV_HANDLE_SHUTTING         0x0100\n+#define UV_HANDLE_SHUT             0x0200\n+#define UV_HANDLE_ENDGAME_QUEUED   0x0400\n+#define UV_HANDLE_BIND_ERROR       0x1000\n+\n+/*\n+ * Private uv_req flags.\n+ */\n+/* The request is currently queued. */\n+#define UV_REQ_PENDING             0x01\n+\n+\n+/* Binary tree used to keep the list of timers sorted. */\n+static int uv_timer_compare(uv_timer_t* handle1, uv_timer_t* handle2);\n+RB_HEAD(uv_timer_tree_s, uv_timer_s);\n+RB_PROTOTYPE_STATIC(uv_timer_tree_s, uv_timer_s, tree_entry, uv_timer_compare)\n+\n+/* The head of the timers tree */\n+static struct uv_timer_tree_s uv_timers_ = RB_INITIALIZER(uv_timers_);\n+\n+\n+/* Lists of active uv_prepare / uv_check / uv_idle watchers */\n+static uv_handle_t* uv_prepare_handles_ = NULL;\n+static uv_handle_t* uv_check_handles_ = NULL;\n+static uv_handle_t* uv_idle_handles_ = NULL;\n+\n+/* This pointer will refer to the prepare/check/idle handle whose callback */\n+/* is scheduled to be called next. This is needed to allow safe removal */\n+/* from one of the lists above while that list being iterated. */\n+static uv_handle_t* uv_next_loop_handle_ = NULL;\n+\n+\n+/* Head of a single-linked list of closed handles */\n+static uv_handle_t* uv_endgame_handles_ = NULL;\n+\n+\n+/* Tail of a single-linked circular queue of pending reqs. If the queue is */\n+/* empty, tail_ is NULL. If there is only one item, tail_->next_req == tail_ */\n+static uv_req_t* uv_pending_reqs_tail_ = NULL;\n+\n+\n+/* The current time according to the event loop. in msecs. */\n+static int64_t uv_now_ = 0;\n+static int64_t uv_ticks_per_msec_ = 0;\n+\n+\n+/*\n+ * Global I/O completion port\n+ */\n+static HANDLE uv_iocp_;\n+\n+\n+/* Global error code */\n+static const uv_err_t uv_ok_ = { UV_OK, ERROR_SUCCESS };\n+static uv_err_t uv_last_error_ = { UV_OK, ERROR_SUCCESS };\n+\n+/* Error message string */\n+static char* uv_err_str_ = NULL;\n+\n+\n+/* Reference count that keeps the event loop alive */\n+static int uv_refs_ = 0;\n+\n+\n+/* Ip address used to bind to any port at any interface */\n+static struct sockaddr_in uv_addr_ip4_any_;\n+\n+\n+/* A zero-size buffer for use by uv_read */\n+static char uv_zero_[] = \"\";\n+\n+\n+/* Atomic set operation on char */\n+#ifdef _MSC_VER /* MSVC */\n+\n+/* _InterlockedOr8 is supported by MSVC on x32 and x64. It is  slightly less */\n+/* efficient than InterlockedExchange, but InterlockedExchange8 does not */\n+/* exist, and interlocked operations on larger targets might require the */\n+/* target to be aligned. */\n+#pragma intrinsic(_InterlockedOr8)\n+\n+static char __declspec(inline) uv_atomic_exchange_set(char volatile* target) {\n+  return _InterlockedOr8(target, 1);\n+}\n+\n+#else /* GCC */\n+\n+/* Mingw-32 version, hopefully this works for 64-bit gcc as well. */\n+static inline char uv_atomic_exchange_set(char volatile* target) {\n+  const char one = 1;\n+  char old_value;\n+  __asm__ __volatile__ (\"lock xchgb %0, %1\\n\\t\"\n+                        : \"=r\"(old_value), \"=m\"(*target)\n+                        : \"0\"(one), \"m\"(*target)\n+                        : \"memory\");\n+  return old_value;\n+}\n+\n+#endif\n+\n+\n+/*\n+ * Display an error message and abort the event loop.\n+ */\n+static void uv_fatal_error(const int errorno, const char* syscall) {\n+  char* buf = NULL;\n+  const char* errmsg;\n+\n+  FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n+      FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n+      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&buf, 0, NULL);\n+\n+  if (buf) {\n+    errmsg = buf;\n+  } else {\n+    errmsg = \"Unknown error\";\n+  }\n+\n+  /* FormatMessage messages include a newline character already, */\n+  /* so don't add another. */\n+  if (syscall) {\n+    fprintf(stderr, \"%s: (%d) %s\", syscall, errorno, errmsg);\n+  } else {\n+    fprintf(stderr, \"(%d) %s\", errorno, errmsg);\n+  }\n+\n+  if (buf) {\n+    LocalFree(buf);\n+  }\n+\n+  *((char*)NULL) = 0xff; /* Force debug break */\n+  abort();\n+}\n+\n+\n+uv_err_t uv_last_error() {\n+  return uv_last_error_;\n+}\n+\n+\n+char* uv_strerror(uv_err_t err) {\n+  if (uv_err_str_ != NULL) {\n+    LocalFree((void*) uv_err_str_);\n+  }\n+\n+  FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n+      FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err.sys_errno_,\n+      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&uv_err_str_, 0, NULL);\n+\n+  if (uv_err_str_) {\n+    return uv_err_str_;\n+  } else {\n+    return \"Unknown error\";\n+  }\n+}\n+\n+\n+static uv_err_code uv_translate_sys_error(int sys_errno) {\n+  switch (sys_errno) {\n+    case ERROR_SUCCESS:                     return UV_OK;\n+    case ERROR_NOACCESS:                    return UV_EACCESS;\n+    case WSAEACCES:                         return UV_EACCESS;\n+    case ERROR_ADDRESS_ALREADY_ASSOCIATED:  return UV_EADDRINUSE;\n+    case WSAEADDRINUSE:                     return UV_EADDRINUSE;\n+    case WSAEADDRNOTAVAIL:                  return UV_EADDRNOTAVAIL;\n+    case WSAEWOULDBLOCK:                    return UV_EAGAIN;\n+    case WSAEALREADY:                       return UV_EALREADY;\n+    case ERROR_CONNECTION_REFUSED:          return UV_ECONNREFUSED;\n+    case WSAECONNREFUSED:                   return UV_ECONNREFUSED;\n+    case WSAEFAULT:                         return UV_EFAULT;\n+    case ERROR_INVALID_DATA:                return UV_EINVAL;\n+    case WSAEINVAL:                         return UV_EINVAL;\n+    case ERROR_TOO_MANY_OPEN_FILES:         return UV_EMFILE;\n+    case WSAEMFILE:                         return UV_EMFILE;\n+    case ERROR_OUTOFMEMORY:                 return UV_ENOMEM;\n+    default:                                return UV_UNKNOWN;\n+  }\n+}\n+\n+\n+static uv_err_t uv_new_sys_error(int sys_errno) {\n+  uv_err_t e;\n+  e.code = uv_translate_sys_error(sys_errno);\n+  e.sys_errno_ = sys_errno;\n+  return e;\n+}\n+\n+\n+static void uv_set_sys_error(int sys_errno) {\n+  uv_last_error_.code = uv_translate_sys_error(sys_errno);\n+  uv_last_error_.sys_errno_ = sys_errno;\n+}\n+\n+\n+/*\n+ * Retrieves the pointer to a winsock extension function.\n+ */\n+static void uv_get_extension_function(SOCKET socket, GUID guid,\n+    void **target) {\n+  DWORD result, bytes;\n+\n+  result = WSAIoctl(socket,\n+                    SIO_GET_EXTENSION_FUNCTION_POINTER,\n+                    &guid,\n+                    sizeof(guid),\n+                    (void*)target,\n+                    sizeof(*target),\n+                    &bytes,\n+                    NULL,\n+                    NULL);\n+\n+  if (result == SOCKET_ERROR) {\n+    *target = NULL;\n+    uv_fatal_error(WSAGetLastError(),\n+                   \"WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER)\");\n+  }\n+}\n+\n+\n+void uv_init() {\n+  const GUID wsaid_connectex            = WSAID_CONNECTEX;\n+  const GUID wsaid_acceptex             = WSAID_ACCEPTEX;\n+  const GUID wsaid_getacceptexsockaddrs = WSAID_GETACCEPTEXSOCKADDRS;\n+  const GUID wsaid_disconnectex         = WSAID_DISCONNECTEX;\n+  const GUID wsaid_transmitfile         = WSAID_TRANSMITFILE;\n+\n+  WSADATA wsa_data;\n+  int errorno;\n+  LARGE_INTEGER timer_frequency;\n+  SOCKET dummy;\n+\n+  /* Initialize winsock */\n+  errorno = WSAStartup(MAKEWORD(2, 2), &wsa_data);\n+  if (errorno != 0) {\n+    uv_fatal_error(errorno, \"WSAStartup\");\n+  }\n+\n+  /* Set implicit binding address used by connectEx */\n+  uv_addr_ip4_any_ = uv_ip4_addr(\"0.0.0.0\", 0);\n+\n+  /* Retrieve the needed winsock extension function pointers. */\n+  dummy = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);\n+  if (dummy == INVALID_SOCKET) {\n+    uv_fatal_error(WSAGetLastError(), \"socket\");\n+  }\n+\n+  uv_get_extension_function(dummy,\n+                            wsaid_connectex,\n+                            (void**)&pConnectEx);\n+  uv_get_extension_function(dummy,\n+                            wsaid_acceptex,\n+                            (void**)&pAcceptEx);\n+  uv_get_extension_function(dummy,\n+                            wsaid_getacceptexsockaddrs,\n+                            (void**)&pGetAcceptExSockAddrs);\n+  uv_get_extension_function(dummy,\n+                            wsaid_disconnectex,\n+                            (void**)&pDisconnectEx);\n+  uv_get_extension_function(dummy,\n+                            wsaid_transmitfile,\n+                            (void**)&pTransmitFile);\n+\n+  if (closesocket(dummy) == SOCKET_ERROR) {\n+    uv_fatal_error(WSAGetLastError(), \"closesocket\");\n+  }\n+\n+  /* Create an I/O completion port */\n+  uv_iocp_ = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);\n+  if (uv_iocp_ == NULL) {\n+    uv_fatal_error(GetLastError(), \"CreateIoCompletionPort\");\n+  }\n+\n+  /* Initialize the event loop time */\n+  if (!QueryPerformanceFrequency(&timer_frequency))\n+    uv_fatal_error(GetLastError(), \"QueryPerformanceFrequency\");\n+  uv_ticks_per_msec_ = timer_frequency.QuadPart / 1000;\n+\n+  uv_update_time();\n+}\n+\n+\n+void uv_req_init(uv_req_t* req, uv_handle_t* handle, void* cb) {\n+  uv_counters()->req_init++;\n+  req->type = UV_UNKNOWN_REQ;\n+  req->flags = 0;\n+  req->handle = handle;\n+  req->cb = cb;\n+}\n+\n+\n+static uv_req_t* uv_overlapped_to_req(OVERLAPPED* overlapped) {\n+  return CONTAINING_RECORD(overlapped, uv_req_t, overlapped);\n+}\n+\n+\n+static void uv_insert_pending_req(uv_req_t* req) {\n+  req->next_req = NULL;\n+  if (uv_pending_reqs_tail_) {\n+    req->next_req = uv_pending_reqs_tail_->next_req;\n+    uv_pending_reqs_tail_ = req;\n+  } else {\n+    req->next_req = req;\n+    uv_pending_reqs_tail_ = req;\n+  }\n+}\n+\n+\n+static uv_req_t* uv_remove_pending_req() {\n+  uv_req_t* req;\n+\n+  if (uv_pending_reqs_tail_) {\n+    req = uv_pending_reqs_tail_->next_req;\n+\n+    if (req == uv_pending_reqs_tail_) {\n+      uv_pending_reqs_tail_ = NULL;\n+    } else {\n+      uv_pending_reqs_tail_->next_req = req->next_req;\n+    }\n+\n+    return req;\n+\n+  } else {\n+    /* queue empty */\n+    return NULL;\n+  }\n+}\n+\n+\n+static int uv_tcp_set_socket(uv_tcp_t* handle, SOCKET socket) {\n+  DWORD yes = 1;\n+\n+  assert(handle->socket == INVALID_SOCKET);\n+\n+  /* Set the socket to nonblocking mode */\n+  if (ioctlsocket(socket, FIONBIO, &yes) == SOCKET_ERROR) {\n+    uv_set_sys_error(WSAGetLastError());\n+    return -1;\n+  }\n+\n+  /* Make the socket non-inheritable */\n+  if (!SetHandleInformation((HANDLE)socket, HANDLE_FLAG_INHERIT, 0)) {\n+    uv_set_sys_error(GetLastError());\n+    return -1;\n+  }\n+\n+  /* Associate it with the I/O completion port. */\n+  /* Use uv_handle_t pointer as completion key. */\n+  if (CreateIoCompletionPort((HANDLE)socket,\n+                             uv_iocp_,\n+                             (ULONG_PTR)socket,\n+                             0) == NULL) {\n+    uv_set_sys_error(GetLastError());\n+    return -1;\n+  }\n+\n+  handle->socket = socket;\n+\n+  return 0;\n+}\n+\n+\n+static void uv_tcp_init_connection(uv_tcp_t* handle) {\n+  handle->flags |= UV_HANDLE_CONNECTION;\n+  handle->write_reqs_pending = 0;\n+  uv_req_init(&(handle->read_req), (uv_handle_t*)handle, NULL);\n+}\n+\n+\n+int uv_tcp_init(uv_tcp_t* handle) {\n+  SOCKET sock;\n+\n+  handle->socket = INVALID_SOCKET;\n+  handle->write_queue_size = 0;\n+  handle->type = UV_TCP;\n+  handle->flags = 0;\n+  handle->reqs_pending = 0;\n+  handle->error = uv_ok_;\n+  handle->accept_socket = INVALID_SOCKET;\n+\n+  uv_counters()->handle_init++;\n+  uv_counters()->tcp_init++;\n+\n+  uv_refs_++;\n+\n+  return 0;\n+}\n+\n+\n+static void uv_tcp_endgame(uv_tcp_t* handle) {\n+  uv_err_t err;\n+  int status;\n+\n+  if (handle->flags & UV_HANDLE_SHUTTING &&\n+      !(handle->flags & UV_HANDLE_SHUT) &&\n+      handle->write_reqs_pending == 0) {\n+\n+    if (shutdown(handle->socket, SD_SEND) != SOCKET_ERROR) {\n+      status = 0;\n+      handle->flags |= UV_HANDLE_SHUT;\n+    } else {\n+      status = -1;\n+      err = uv_new_sys_error(WSAGetLastError());\n+    }\n+    if (handle->shutdown_req->cb) {\n+      handle->shutdown_req->flags &= ~UV_REQ_PENDING;\n+      if (status == -1) {\n+        uv_last_error_ = err;\n+      }\n+      ((uv_shutdown_cb)handle->shutdown_req->cb)(handle->shutdown_req, status);\n+    }\n+    handle->reqs_pending--;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n+      handle->reqs_pending == 0) {\n+    assert(!(handle->flags & UV_HANDLE_CLOSED));\n+    handle->flags |= UV_HANDLE_CLOSED;\n+\n+    if (handle->close_cb) {\n+      handle->close_cb((uv_handle_t*)handle);\n+    }\n+\n+    uv_refs_--;\n+  }\n+}\n+\n+\n+static void uv_timer_endgame(uv_timer_t* handle) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n+    assert(!(handle->flags & UV_HANDLE_CLOSED));\n+    handle->flags |= UV_HANDLE_CLOSED;\n+\n+    if (handle->close_cb) {\n+      handle->close_cb((uv_handle_t*)handle);\n+    }\n+\n+    uv_refs_--;\n+  }\n+}\n+\n+\n+static void uv_loop_endgame(uv_handle_t* handle) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n+    assert(!(handle->flags & UV_HANDLE_CLOSED));\n+    handle->flags |= UV_HANDLE_CLOSED;\n+\n+    if (handle->close_cb) {\n+      handle->close_cb(handle);\n+    }\n+\n+    uv_refs_--;\n+  }\n+}\n+\n+\n+static void uv_async_endgame(uv_async_t* handle) {\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n+      !handle->async_sent) {\n+    assert(!(handle->flags & UV_HANDLE_CLOSED));\n+    handle->flags |= UV_HANDLE_CLOSED;\n+\n+    if (handle->close_cb) {\n+      handle->close_cb((uv_handle_t*)handle);\n+    }\n+\n+    uv_refs_--;\n+  }\n+}\n+\n+\n+static void uv_process_endgames() {\n+  uv_handle_t* handle;\n+\n+  while (uv_endgame_handles_) {\n+    handle = uv_endgame_handles_;\n+    uv_endgame_handles_ = handle->endgame_next;\n+\n+    handle->flags &= ~UV_HANDLE_ENDGAME_QUEUED;\n+\n+    switch (handle->type) {\n+      case UV_TCP:\n+        uv_tcp_endgame((uv_tcp_t*)handle);\n+        break;\n+\n+      case UV_TIMER:\n+        uv_timer_endgame((uv_timer_t*)handle);\n+        break;\n+\n+      case UV_PREPARE:\n+      case UV_CHECK:\n+      case UV_IDLE:\n+        uv_loop_endgame(handle);\n+        break;\n+\n+      case UV_ASYNC:\n+        uv_async_endgame((uv_async_t*)handle);\n+        break;\n+\n+      default:\n+        assert(0);\n+        break;\n+    }\n+  }\n+}\n+\n+\n+static void uv_want_endgame(uv_handle_t* handle) {\n+  if (!(handle->flags & UV_HANDLE_ENDGAME_QUEUED)) {\n+    handle->flags |= UV_HANDLE_ENDGAME_QUEUED;\n+\n+    handle->endgame_next = uv_endgame_handles_;\n+    uv_endgame_handles_ = handle;\n+  }\n+}\n+\n+\n+static int uv_close_error(uv_handle_t* handle, uv_err_t e) {\n+  uv_tcp_t* tcp;\n+\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n+    return 0;\n+  }\n+\n+  handle->error = e;\n+  handle->flags |= UV_HANDLE_CLOSING;\n+\n+  /* Handle-specific close actions */\n+  switch (handle->type) {\n+    case UV_TCP:\n+      tcp = (uv_tcp_t*)handle;\n+      tcp->flags &= ~(UV_HANDLE_READING | UV_HANDLE_LISTENING);\n+      closesocket(tcp->socket);\n+      if (tcp->reqs_pending == 0) {\n+        uv_want_endgame(handle);\n+      }\n+      return 0;\n+\n+    case UV_TIMER:\n+      uv_timer_stop((uv_timer_t*)handle);\n+      uv_want_endgame(handle);\n+      return 0;\n+\n+    case UV_PREPARE:\n+      uv_prepare_stop((uv_prepare_t*)handle);\n+      uv_want_endgame(handle);\n+      return 0;\n+\n+    case UV_CHECK:\n+      uv_check_stop((uv_check_t*)handle);\n+      uv_want_endgame(handle);\n+      return 0;\n+\n+    case UV_IDLE:\n+      uv_idle_stop((uv_idle_t*)handle);\n+      uv_want_endgame(handle);\n+      return 0;\n+\n+    case UV_ASYNC:\n+      if (!((uv_async_t*)handle)->async_sent) {\n+        uv_want_endgame(handle);\n+      }\n+      return 0;\n+\n+    default:\n+      /* Not supported */\n+      assert(0);\n+      return -1;\n+  }\n+}\n+\n+\n+int uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n+  handle->close_cb = close_cb;\n+  return uv_close_error(handle, uv_ok_);\n+}\n+\n+\n+struct sockaddr_in uv_ip4_addr(char* ip, int port) {\n+  struct sockaddr_in addr;\n+\n+  addr.sin_family = AF_INET;\n+  addr.sin_port = htons(port);\n+  addr.sin_addr.s_addr = inet_addr(ip);\n+\n+  return addr;\n+}\n+\n+\n+int uv_bind(uv_tcp_t* handle, struct sockaddr_in addr) {\n+  DWORD err;\n+  int r;\n+  SOCKET sock;\n+  int addrsize = sizeof(struct sockaddr_in);\n+\n+  if (addr.sin_family != AF_INET) {\n+    uv_set_sys_error(WSAEFAULT);\n+    return -1;\n+  }\n+\n+  if (handle->socket == INVALID_SOCKET) {\n+    sock = socket(AF_INET, SOCK_STREAM, 0);\n+    if (sock == INVALID_SOCKET) {\n+      uv_set_sys_error(WSAGetLastError());\n+      return -1;\n+    }\n+\n+    if (uv_tcp_set_socket(handle, sock) == -1) {\n+      closesocket(sock);\n+      return -1;\n+    }\n+  }\n+\n+  r = bind(handle->socket, (struct sockaddr*) &addr, addrsize);\n+\n+  if (r == SOCKET_ERROR) {\n+    err = WSAGetLastError();\n+    if (err == WSAEADDRINUSE) {\n+      /* Some errors are not to be reported until connect() or listen() */\n+      handle->error = uv_new_sys_error(err);\n+      handle->flags |= UV_HANDLE_BIND_ERROR;\n+    } else {\n+      uv_set_sys_error(err);\n+      return -1;\n+    }\n+  }\n+\n+  handle->flags |= UV_HANDLE_BOUND;\n+\n+  return 0;\n+}\n+\n+\n+static void uv_queue_accept(uv_tcp_t* handle) {\n+  uv_req_t* req;\n+  BOOL success;\n+  DWORD bytes;\n+  SOCKET accept_socket;\n+\n+  assert(handle->flags & UV_HANDLE_LISTENING);\n+  assert(handle->accept_socket == INVALID_SOCKET);\n+\n+  /* Prepare the uv_req structure. */\n+  req = &handle->accept_req;\n+  assert(!(req->flags & UV_REQ_PENDING));\n+  req->type = UV_ACCEPT;\n+  req->flags |= UV_REQ_PENDING;\n+\n+  /* Open a socket for the accepted connection. */\n+  accept_socket = socket(AF_INET, SOCK_STREAM, 0);\n+  if (accept_socket == INVALID_SOCKET) {\n+    req->error = uv_new_sys_error(WSAGetLastError());\n+    uv_insert_pending_req(req);\n+    return;\n+  }\n+\n+  /* Prepare the overlapped structure. */\n+  memset(&(req->overlapped), 0, sizeof(req->overlapped));\n+\n+  success = pAcceptEx(handle->socket,\n+                      accept_socket,\n+                      (void*)&handle->accept_buffer,\n+                      0,\n+                      sizeof(struct sockaddr_storage),\n+                      sizeof(struct sockaddr_storage),\n+                      &bytes,\n+                      &req->overlapped);\n+\n+  if (!success && WSAGetLastError() != ERROR_IO_PENDING) {\n+    /* Make this req pending reporting an error. */\n+    req->error = uv_new_sys_error(WSAGetLastError());\n+    uv_insert_pending_req(req);\n+    /* Destroy the preallocated client socket. */\n+    closesocket(accept_socket);\n+    return;\n+  }\n+\n+  handle->accept_socket = accept_socket;\n+\n+  handle->reqs_pending++;\n+  req->flags |= UV_REQ_PENDING;\n+}\n+\n+\n+static void uv_queue_read(uv_tcp_t* handle) {\n+  uv_req_t* req;\n+  uv_buf_t buf;\n+  int result;\n+  DWORD bytes, flags;\n+\n+  assert(handle->flags & UV_HANDLE_READING);\n+\n+  req = &handle->read_req;\n+  assert(!(req->flags & UV_REQ_PENDING));\n+  memset(&req->overlapped, 0, sizeof(req->overlapped));\n+  req->type = UV_READ;\n+\n+  buf.base = (char*) &uv_zero_;\n+  buf.len = 0;\n+\n+  flags = 0;\n+  result = WSARecv(handle->socket,\n+                   (WSABUF*)&buf,\n+                   1,\n+                   &bytes,\n+                   &flags,\n+                   &req->overlapped,\n+                   NULL);\n+  if (result != 0 && WSAGetLastError() != ERROR_IO_PENDING) {\n+    /* Make this req pending reporting an error. */\n+    req->error = uv_new_sys_error(WSAGetLastError());\n+    uv_insert_pending_req(req);\n+    return;\n+  }\n+\n+  req->flags |= UV_REQ_PENDING;\n+  handle->reqs_pending++;\n+}\n+\n+\n+int uv_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {\n+  assert(backlog > 0);\n+\n+  if (handle->flags & UV_HANDLE_BIND_ERROR) {\n+    uv_last_error_ = handle->error;\n+    return -1;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_LISTENING ||\n+      handle->flags & UV_HANDLE_READING) {\n+    /* Already listening. */\n+    uv_set_sys_error(WSAEALREADY);\n+    return -1;\n+  }\n+\n+  if (listen(handle->socket, backlog) == SOCKET_ERROR) {\n+    uv_set_sys_error(WSAGetLastError());\n+    return -1;\n+  }\n+\n+  handle->flags |= UV_HANDLE_LISTENING;\n+  handle->connection_cb = cb;\n+\n+  uv_req_init(&(handle->accept_req), (uv_handle_t*)handle, NULL);\n+  uv_queue_accept(handle);\n+\n+  return 0;\n+}\n+\n+\n+int uv_accept(uv_tcp_t* server, uv_tcp_t* client) {\n+  int rv = 0;\n+\n+  if (server->accept_socket == INVALID_SOCKET) {\n+    uv_set_sys_error(WSAENOTCONN);\n+    return -1;\n+  }\n+\n+  if (uv_tcp_set_socket(client, server->accept_socket) == -1) {\n+    closesocket(server->accept_socket);\n+    rv = -1;\n+  } else {\n+    uv_tcp_init_connection(client);\n+  }\n+\n+  server->accept_socket = INVALID_SOCKET;\n+\n+  if (!(server->flags & UV_HANDLE_CLOSING)) {\n+    uv_queue_accept(server);\n+  }\n+\n+  return rv;\n+}\n+\n+\n+int uv_read_start(uv_tcp_t* handle, uv_alloc_cb alloc_cb, uv_read_cb read_cb) {\n+  if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n+    uv_set_sys_error(WSAEINVAL);\n+    return -1;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_READING) {\n+    uv_set_sys_error(WSAEALREADY);\n+    return -1;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_EOF) {\n+    uv_set_sys_error(WSAESHUTDOWN);\n+    return -1;\n+  }\n+\n+  handle->flags |= UV_HANDLE_READING;\n+  handle->read_cb = read_cb;\n+  handle->alloc_cb = alloc_cb;\n+\n+  /* If reading was stopped and then started again, there could stell be a */\n+  /* read request pending. */\n+  if (!(handle->read_req.flags & UV_REQ_PENDING))\n+    uv_queue_read(handle);\n+\n+  return 0;\n+}\n+\n+\n+int uv_read_stop(uv_tcp_t* handle) {\n+  handle->flags &= ~UV_HANDLE_READING;\n+\n+  return 0;\n+}\n+\n+\n+int uv_connect(uv_req_t* req, struct sockaddr_in addr) {\n+  int addrsize = sizeof(struct sockaddr_in);\n+  BOOL success;\n+  DWORD bytes;\n+  uv_tcp_t* handle = (uv_tcp_t*)req->handle;\n+\n+  assert(!(req->flags & UV_REQ_PENDING));\n+\n+  if (handle->flags & UV_HANDLE_BIND_ERROR) {\n+    uv_last_error_ = handle->error;\n+    return -1;\n+  }\n+\n+  if (addr.sin_family != AF_INET) {\n+    uv_set_sys_error(WSAEFAULT);\n+    return -1;\n+  }\n+\n+  if (!(handle->flags & UV_HANDLE_BOUND) &&\n+      uv_bind(handle, uv_addr_ip4_any_) < 0)\n+    return -1;\n+\n+  memset(&req->overlapped, 0, sizeof(req->overlapped));\n+  req->type = UV_CONNECT;\n+\n+  success = pConnectEx(handle->socket,\n+                       (struct sockaddr*)&addr,\n+                       addrsize,\n+                       NULL,\n+                       0,\n+                       &bytes,\n+                       &req->overlapped);\n+\n+  if (!success && WSAGetLastError() != ERROR_IO_PENDING) {\n+    uv_set_sys_error(WSAGetLastError());\n+    return -1;\n+  }\n+\n+  req->flags |= UV_REQ_PENDING;\n+  handle->reqs_pending++;\n+\n+  return 0;\n+}\n+\n+\n+static size_t uv_count_bufs(uv_buf_t bufs[], int count) {\n+  size_t bytes = 0;\n+  int i;\n+\n+  for (i = 0; i < count; i++) {\n+    bytes += (size_t)bufs[i].len;\n+  }\n+\n+  return bytes;\n+}\n+\n+\n+int uv_write(uv_req_t* req, uv_buf_t bufs[], int bufcnt) {\n+  int result;\n+  DWORD bytes, err;\n+  uv_tcp_t* handle = (uv_tcp_t*) req->handle;\n+\n+  assert(!(req->flags & UV_REQ_PENDING));\n+\n+  if (!(req->handle->flags & UV_HANDLE_CONNECTION)) {\n+    uv_set_sys_error(WSAEINVAL);\n+    return -1;\n+  }\n+\n+  if (req->handle->flags & UV_HANDLE_SHUTTING) {\n+    uv_set_sys_error(WSAESHUTDOWN);\n+    return -1;\n+  }\n+\n+  memset(&req->overlapped, 0, sizeof(req->overlapped));\n+  req->type = UV_WRITE;\n+\n+  result = WSASend(handle->socket,\n+                   (WSABUF*)bufs,\n+                   bufcnt,\n+                   &bytes,\n+                   0,\n+                   &req->overlapped,\n+                   NULL);\n+  if (result != 0) {\n+    err = WSAGetLastError();\n+    if (err != WSA_IO_PENDING) {\n+      /* Send failed due to an error. */\n+      uv_set_sys_error(WSAGetLastError());\n+      return -1;\n+    }\n+  }\n+\n+  if (result == 0) {\n+    /* Request completed immediately. */\n+    req->queued_bytes = 0;\n+  } else {\n+    /* Request queued by the kernel. */\n+    req->queued_bytes = uv_count_bufs(bufs, bufcnt);\n+    handle->write_queue_size += req->queued_bytes;\n+  }\n+\n+  req->flags |= UV_REQ_PENDING;\n+  handle->reqs_pending++;\n+  handle->write_reqs_pending++;\n+\n+  return 0;\n+}\n+\n+\n+int uv_shutdown(uv_req_t* req) {\n+  uv_tcp_t* handle = (uv_tcp_t*) req->handle;\n+  int status = 0;\n+\n+  if (!(req->handle->flags & UV_HANDLE_CONNECTION)) {\n+    uv_set_sys_error(WSAEINVAL);\n+    return -1;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_SHUTTING) {\n+    uv_set_sys_error(WSAESHUTDOWN);\n+    return -1;\n+  }\n+\n+  req->type = UV_SHUTDOWN;\n+  req->flags |= UV_REQ_PENDING;\n+\n+  handle->flags |= UV_HANDLE_SHUTTING;\n+    handle->shutdown_req = req;\n+  handle->reqs_pending++;\n+\n+  uv_want_endgame((uv_handle_t*)handle);\n+\n+  return 0;\n+}\n+\n+\n+static void uv_tcp_return_req(uv_tcp_t* handle, uv_req_t* req) {\n+  DWORD bytes, flags, err;\n+  uv_buf_t buf;\n+\n+  assert(handle->type == UV_TCP);\n+\n+  /* Mark the request non-pending */\n+  req->flags &= ~UV_REQ_PENDING;\n+\n+  switch (req->type) {\n+    case UV_WRITE:\n+      handle->write_queue_size -= req->queued_bytes;\n+      if (req->cb) {\n+        uv_last_error_ = req->error;\n+        ((uv_write_cb)req->cb)(req, uv_last_error_.code == UV_OK ? 0 : -1);\n+      }\n+      handle->write_reqs_pending--;\n+      if (handle->write_reqs_pending == 0 &&\n+          handle->flags & UV_HANDLE_SHUTTING) {\n+        uv_want_endgame((uv_handle_t*)handle);\n+      }\n+      break;\n+\n+    case UV_READ:\n+      if (req->error.code != UV_OK) {\n+        /* An error occurred doing the 0-read. */\n+        if (!(handle->flags & UV_HANDLE_READING)) {\n+          break;\n+        }\n+\n+        /* Stop reading and report error. */\n+        handle->flags &= ~UV_HANDLE_READING;\n+        uv_last_error_ = req->error;\n+        buf.base = 0;\n+        buf.len = 0;\n+        handle->read_cb(handle, -1, buf);\n+        break;\n+      }\n+\n+      /* Do nonblocking reads until the buffer is empty */\n+      while (handle->flags & UV_HANDLE_READING) {\n+        buf = handle->alloc_cb(handle, 65536);\n+        assert(buf.len > 0);\n+        flags = 0;\n+        if (WSARecv(handle->socket,\n+                    (WSABUF*)&buf,\n+                    1,\n+                    &bytes,\n+                    &flags,\n+                    NULL,\n+                    NULL) != SOCKET_ERROR) {\n+          if (bytes > 0) {\n+            /* Successful read */\n+            handle->read_cb(handle, bytes, buf);\n+            /* Read again only if bytes == buf.len */\n+            if (bytes < buf.len) {\n+              break;\n+            }\n+          } else {\n+            /* Connection closed */\n+            handle->flags &= ~UV_HANDLE_READING;\n+            handle->flags |= UV_HANDLE_EOF;\n+            uv_last_error_.code = UV_EOF;\n+            uv_last_error_.sys_errno_ = ERROR_SUCCESS;\n+            handle->read_cb(handle, -1, buf);\n+            break;\n+          }\n+        } else {\n+          err = WSAGetLastError();\n+          if (err == WSAEWOULDBLOCK) {\n+            /* Read buffer was completely empty, report a 0-byte read. */\n+            uv_set_sys_error(WSAEWOULDBLOCK);\n+            handle->read_cb(handle, 0, buf);\n+          } else {\n+            /* Ouch! serious error. */\n+            uv_set_sys_error(err);\n+            handle->read_cb(handle, -1, buf);\n+          }\n+          break;\n+        }\n+      }\n+      /* Post another 0-read if still reading and not closing. */\n+      if (handle->flags & UV_HANDLE_READING) {\n+        uv_queue_read(handle);\n+      }\n+      break;\n+\n+    case UV_ACCEPT:\n+      /* If handle->accepted_socket is not a valid socket, then */\n+      /* uv_queue_accept must have failed. This is a serious error. We stop */\n+      /* accepting connections and report this error to the connection */\n+      /* callback. */\n+      if (handle->accept_socket == INVALID_SOCKET) {\n+        if (!(handle->flags & UV_HANDLE_LISTENING)) {\n+          break;\n+        }\n+        handle->flags &= ~UV_HANDLE_LISTENING;\n+        if (handle->connection_cb) {\n+          uv_last_error_ = req->error;\n+          handle->connection_cb(handle, -1);\n+        }\n+        break;\n+      }\n+\n+      if (req->error.code == UV_OK &&\n+          setsockopt(handle->accept_socket,\n+                     SOL_SOCKET,\n+                     SO_UPDATE_ACCEPT_CONTEXT,\n+                     (char*)&handle->socket,\n+                     sizeof(handle->socket)) == 0) {\n+        /* Accept and SO_UPDATE_ACCEPT_CONTEXT were successful. */\n+        if (handle->connection_cb) {\n+          handle->connection_cb(handle, 0);\n+        }\n+      } else {\n+        /* Error related to accepted socket is ignored because the server */\n+        /* socket may still be healthy. If the server socket is broken\n+        /* uv_queue_accept will detect it. */\n+        closesocket(handle->accept_socket);\n+        if (handle->flags & UV_HANDLE_LISTENING) {\n+          uv_queue_accept(handle);\n+        }\n+      }\n+      break;\n+\n+    case UV_CONNECT:\n+      if (req->cb) {\n+        if (req->error.code == UV_OK) {\n+          if (setsockopt(handle->socket,\n+                         SOL_SOCKET,\n+                         SO_UPDATE_CONNECT_CONTEXT,\n+                         NULL,\n+                         0) == 0) {\n+            uv_tcp_init_connection(handle);\n+            ((uv_connect_cb)req->cb)(req, 0);\n+          } else {\n+            uv_set_sys_error(WSAGetLastError());\n+            ((uv_connect_cb)req->cb)(req, -1);\n+          }\n+        } else {\n+          uv_last_error_ = req->error;\n+          ((uv_connect_cb)req->cb)(req, -1);\n+        }\n+      }\n+      break;\n+\n+    default:\n+      assert(0);\n+  }\n+\n+   /* The number of pending requests is now down by one */\n+  handle->reqs_pending--;\n+\n+  /* Queue the handle's close callback if it is closing and there are no */\n+  /* more pending requests. */\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n+      handle->reqs_pending == 0) {\n+    uv_want_endgame((uv_handle_t*)handle);\n+  }\n+}\n+\n+\n+static int uv_timer_compare(uv_timer_t* a, uv_timer_t* b) {\n+  if (a->due < b->due)\n+    return -1;\n+  if (a->due > b->due)\n+    return 1;\n+  if ((intptr_t)a < (intptr_t)b)\n+    return -1;\n+  if ((intptr_t)a > (intptr_t)b)\n+    return 1;\n+  return 0;\n+}\n+\n+\n+RB_GENERATE_STATIC(uv_timer_tree_s, uv_timer_s, tree_entry, uv_timer_compare);\n+\n+\n+int uv_timer_init(uv_timer_t* handle) {\n+  uv_counters()->handle_init++;\n+  uv_counters()->timer_init++;\n+\n+  handle->type = UV_TIMER;\n+  handle->flags = 0;\n+  handle->error = uv_ok_;\n+  handle->timer_cb = NULL;\n+  handle->repeat = 0;\n+\n+  uv_refs_++;\n+\n+  return 0;\n+}\n+\n+\n+int uv_timer_start(uv_timer_t* handle, uv_loop_cb timer_cb, int64_t timeout, int64_t repeat) {\n+  if (handle->flags & UV_HANDLE_ACTIVE) {\n+    RB_REMOVE(uv_timer_tree_s, &uv_timers_, handle);\n+  }\n+\n+  handle->timer_cb = (void*) timer_cb;\n+  handle->due = uv_now_ + timeout;\n+  handle->repeat = repeat;\n+  handle->flags |= UV_HANDLE_ACTIVE;\n+\n+  if (RB_INSERT(uv_timer_tree_s, &uv_timers_, handle) != NULL) {\n+    uv_fatal_error(ERROR_INVALID_DATA, \"RB_INSERT\");\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_timer_stop(uv_timer_t* handle) {\n+  if (!(handle->flags & UV_HANDLE_ACTIVE))\n+    return 0;\n+\n+  RB_REMOVE(uv_timer_tree_s, &uv_timers_, handle);\n+\n+  handle->flags &= ~UV_HANDLE_ACTIVE;\n+\n+  return 0;\n+}\n+\n+\n+int uv_timer_again(uv_timer_t* handle) {\n+  /* If timer_cb is NULL that means that the timer was never started. */\n+  if (!handle->timer_cb) {\n+    uv_set_sys_error(ERROR_INVALID_DATA);\n+    return -1;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_ACTIVE) {\n+    RB_REMOVE(uv_timer_tree_s, &uv_timers_, handle);\n+    handle->flags &= ~UV_HANDLE_ACTIVE;\n+  }\n+\n+  if (handle->repeat) {\n+    handle->due = uv_now_ + handle->repeat;\n+\n+    if (RB_INSERT(uv_timer_tree_s, &uv_timers_, handle) != NULL) {\n+      uv_fatal_error(ERROR_INVALID_DATA, \"RB_INSERT\");\n+    }\n+\n+    handle->flags |= UV_HANDLE_ACTIVE;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+void uv_timer_set_repeat(uv_timer_t* handle, int64_t repeat) {\n+  assert(handle->type == UV_TIMER);\n+  handle->repeat = repeat;\n+}\n+\n+\n+int64_t uv_timer_get_repeat(uv_timer_t* handle) {\n+  assert(handle->type == UV_TIMER);\n+  return handle->repeat;\n+}\n+\n+\n+void uv_update_time() {\n+  LARGE_INTEGER counter;\n+\n+  if (!QueryPerformanceCounter(&counter))\n+    uv_fatal_error(GetLastError(), \"QueryPerformanceCounter\");\n+\n+  uv_now_ = counter.QuadPart / uv_ticks_per_msec_;\n+}\n+\n+\n+int64_t uv_now() {\n+  return uv_now_;\n+}\n+\n+\n+int uv_loop_init(uv_handle_t* handle) {\n+  handle->flags = 0;\n+  handle->error = uv_ok_;\n+\n+  uv_refs_++;\n+\n+  return 0;\n+}\n+\n+\n+static int uv_loop_start(uv_handle_t* handle, uv_loop_cb loop_cb,\n+    uv_handle_t** list) {\n+  uv_handle_t* old_head;\n+\n+  if (handle->flags & UV_HANDLE_ACTIVE)\n+    return 0;\n+\n+  old_head = *list;\n+\n+  handle->loop_next = old_head;\n+  handle->loop_prev = NULL;\n+\n+  if (old_head) {\n+    old_head->loop_prev = handle;\n+  }\n+\n+  *list = handle;\n+\n+  handle->loop_cb = loop_cb;\n+  handle->flags |= UV_HANDLE_ACTIVE;\n+\n+  return 0;\n+}\n+\n+\n+static int uv_loop_stop(uv_handle_t* handle, uv_handle_t** list) {\n+  if (!(handle->flags & UV_HANDLE_ACTIVE))\n+    return 0;\n+\n+  /* Update loop head if needed */\n+  if (*list == handle) {\n+    *list = handle->loop_next;\n+  }\n+\n+  /* Update the iterator-next pointer of needed */\n+  if (uv_next_loop_handle_ == handle) {\n+    uv_next_loop_handle_ = handle->loop_next;\n+  }\n+\n+  if (handle->loop_prev) {\n+    handle->loop_prev->loop_next = handle->loop_next;\n+  }\n+  if (handle->loop_next) {\n+    handle->loop_next->loop_prev = handle->loop_prev;\n+  }\n+\n+  handle->flags &= ~UV_HANDLE_ACTIVE;\n+\n+  return 0;\n+}\n+\n+\n+static void uv_loop_invoke(uv_handle_t* list) {\n+  uv_handle_t *handle;\n+\n+  uv_next_loop_handle_ = list;\n+\n+  while (uv_next_loop_handle_ != NULL) {\n+    handle = uv_next_loop_handle_;\n+    uv_next_loop_handle_ = handle->loop_next;\n+\n+    handle->loop_cb(handle, 0);\n+  }\n+}\n+\n+\n+int uv_prepare_init(uv_prepare_t* handle) {\n+  uv_counters()->handle_init++;\n+  uv_counters()->prepare_init++;\n+  handle->type = UV_PREPARE;\n+  return uv_loop_init((uv_handle_t*)handle);\n+}\n+\n+\n+int uv_check_init(uv_check_t* handle) {\n+  uv_counters()->handle_init++;\n+  uv_counters()->check_init++;\n+  handle->type = UV_CHECK;\n+  return uv_loop_init((uv_handle_t*)handle);\n+}\n+\n+\n+int uv_idle_init(uv_idle_t* handle) {\n+  uv_counters()->handle_init++;\n+  uv_counters()->idle_init++;\n+  handle->type = UV_IDLE;\n+  return uv_loop_init((uv_handle_t*)handle);\n+}\n+\n+\n+int uv_prepare_start(uv_prepare_t* handle, uv_loop_cb loop_cb) {\n+  assert(handle->type == UV_PREPARE);\n+  return uv_loop_start((uv_handle_t*)handle, loop_cb, &uv_prepare_handles_);\n+}\n+\n+\n+int uv_check_start(uv_check_t* handle, uv_loop_cb loop_cb) {\n+  assert(handle->type == UV_CHECK);\n+  return uv_loop_start((uv_handle_t*)handle, loop_cb, &uv_check_handles_);\n+}\n+\n+\n+int uv_idle_start(uv_idle_t* handle, uv_loop_cb loop_cb) {\n+  assert(handle->type == UV_IDLE);\n+  return uv_loop_start((uv_handle_t*)handle, loop_cb, &uv_idle_handles_);\n+}\n+\n+\n+int uv_prepare_stop(uv_prepare_t* handle) {\n+  assert(handle->type == UV_PREPARE);\n+  return uv_loop_stop((uv_handle_t*)handle, &uv_prepare_handles_);\n+}\n+\n+\n+int uv_check_stop(uv_check_t* handle) {\n+  assert(handle->type == UV_CHECK);\n+  return uv_loop_stop((uv_handle_t*)handle, &uv_check_handles_);\n+}\n+\n+\n+int uv_idle_stop(uv_idle_t* handle) {\n+  assert(handle->type == UV_IDLE);\n+  return uv_loop_stop((uv_handle_t*)handle, &uv_idle_handles_);\n+}\n+\n+\n+int uv_is_active(uv_handle_t* handle) {\n+  switch (handle->type) {\n+    case UV_TIMER:\n+    case UV_IDLE:\n+    case UV_PREPARE:\n+    case UV_CHECK:\n+      return (handle->flags & UV_HANDLE_ACTIVE) ? 1 : 0;\n+\n+    default:\n+      return 1;\n+  }\n+}\n+\n+\n+int uv_async_init(uv_async_t* handle, uv_async_cb async_cb) {\n+  uv_req_t* req;\n+\n+  uv_counters()->handle_init++;\n+  uv_counters()->async_init++;\n+\n+  handle->type = UV_ASYNC;\n+  handle->flags = 0;\n+  handle->async_sent = 0;\n+  handle->error = uv_ok_;\n+\n+  req = &handle->async_req;\n+  uv_req_init(req, (uv_handle_t*)handle, async_cb);\n+  req->type = UV_WAKEUP;\n+\n+  uv_refs_++;\n+\n+  return 0;\n+}\n+\n+\n+int uv_async_send(uv_async_t* handle) {\n+  if (handle->type != UV_ASYNC) {\n+    /* Can't set errno because that's not thread-safe. */\n+    return -1;\n+  }\n+\n+  /* The user should make sure never to call uv_async_send to a closing */\n+  /* or closed handle. */\n+  assert(!(handle->flags & UV_HANDLE_CLOSING));\n+\n+  if (!uv_atomic_exchange_set(&handle->async_sent)) {\n+    if (!PostQueuedCompletionStatus(uv_iocp_,\n+                                    0,\n+                                    0,\n+                                    &handle->async_req.overlapped)) {\n+      uv_fatal_error(GetLastError(), \"PostQueuedCompletionStatus\");\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static void uv_async_return_req(uv_async_t* handle, uv_req_t* req) {\n+  assert(handle->type == UV_ASYNC);\n+  assert(req->type == UV_WAKEUP);\n+\n+  handle->async_sent = 0;\n+  if (req->cb) {\n+    ((uv_async_cb)req->cb)((uv_handle_t*)handle, 0);\n+  }\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n+    uv_want_endgame((uv_handle_t*)handle);\n+  }\n+}\n+\n+\n+static void uv_process_reqs() {\n+  uv_req_t* req;\n+  uv_handle_t* handle;\n+\n+  while (req = uv_remove_pending_req()) {\n+    handle = req->handle;\n+\n+    switch (handle->type) {\n+      case UV_TCP:\n+        uv_tcp_return_req((uv_tcp_t*)handle, req);\n+        break;\n+\n+      case UV_ASYNC:\n+        uv_async_return_req((uv_async_t*)handle, req);\n+        break;\n+\n+      default:\n+        assert(0);\n+    }\n+  }\n+}\n+\n+\n+static void uv_process_timers() {\n+  uv_timer_t* timer;\n+\n+  /* Call timer callbacks */\n+  for (timer = RB_MIN(uv_timer_tree_s, &uv_timers_);\n+       timer != NULL && timer->due <= uv_now_;\n+       timer = RB_MIN(uv_timer_tree_s, &uv_timers_)) {\n+    RB_REMOVE(uv_timer_tree_s, &uv_timers_, timer);\n+\n+    if (timer->repeat != 0) {\n+      /* If it is a repeating timer, reschedule with repeat timeout. */\n+      timer->due += timer->repeat;\n+      if (timer->due < uv_now_) {\n+        timer->due = uv_now_;\n+      }\n+      if (RB_INSERT(uv_timer_tree_s, &uv_timers_, timer) != NULL) {\n+        uv_fatal_error(ERROR_INVALID_DATA, \"RB_INSERT\");\n+      }\n+    } else {\n+      /* If non-repeating, mark the timer as inactive. */\n+      timer->flags &= ~UV_HANDLE_ACTIVE;\n+    }\n+\n+    timer->timer_cb((uv_handle_t*) timer, 0);\n+  }\n+}\n+\n+\n+static DWORD uv_get_poll_timeout() {\n+  uv_timer_t* timer;\n+  int64_t delta;\n+\n+  /* Check if there are any running timers */\n+  timer = RB_MIN(uv_timer_tree_s, &uv_timers_);\n+  if (timer) {\n+    uv_update_time();\n+\n+    delta = timer->due - uv_now_;\n+    if (delta >= UINT_MAX) {\n+      /* Can't have a timeout greater than UINT_MAX, and a timeout value of */\n+      /* UINT_MAX means infinite, so that's no good either. */\n+      return UINT_MAX - 1;\n+    } else if (delta < 0) {\n+      /* Negative timeout values are not allowed */\n+      return 0;\n+    } else {\n+      return (DWORD)delta;\n+    }\n+  } else {\n+    /* No timers */\n+    return INFINITE;\n+  }\n+}\n+\n+\n+static void uv_poll() {\n+  BOOL success;\n+  DWORD bytes;\n+  ULONG_PTR key;\n+  OVERLAPPED* overlapped;\n+  uv_req_t* req;\n+\n+  success = GetQueuedCompletionStatus(uv_iocp_,\n+                                      &bytes,\n+                                      &key,\n+                                      &overlapped,\n+                                      uv_get_poll_timeout());\n+\n+  uv_update_time();\n+\n+  if (overlapped) {\n+    /* Package was dequeued */\n+    req = uv_overlapped_to_req(overlapped);\n+\n+    if (success) {\n+      req->error = uv_ok_;\n+    } else {\n+      req->error = uv_new_sys_error(GetLastError());\n+    }\n+\n+    uv_insert_pending_req(req);\n+\n+  } else if (GetLastError() != WAIT_TIMEOUT) {\n+    /* Serious error */\n+    uv_fatal_error(GetLastError(), \"GetQueuedCompletionStatus\");\n+  }\n+}\n+\n+\n+int uv_run() {\n+  while (1) {\n+    uv_update_time();\n+    uv_process_timers();\n+\n+    /* Terrible: please fix me! */\n+    while (uv_refs_ > 0 &&\n+        (uv_idle_handles_ || uv_pending_reqs_tail_ || uv_endgame_handles_)) {\n+      /* Terrible: please fix me! */\n+      while (uv_pending_reqs_tail_ || uv_endgame_handles_) {\n+        uv_process_endgames();\n+        uv_process_reqs();\n+      }\n+\n+      /* Call idle callbacks */\n+      uv_loop_invoke(uv_idle_handles_);\n+    }\n+\n+    if (uv_refs_ <= 0) {\n+      break;\n+    }\n+\n+    uv_loop_invoke(uv_prepare_handles_);\n+\n+    uv_poll();\n+\n+    uv_loop_invoke(uv_check_handles_);\n+  }\n+\n+  assert(uv_refs_ == 0);\n+  return 0;\n+}\n+\n+\n+void uv_ref() {\n+  uv_refs_++;\n+}\n+\n+\n+void uv_unref() {\n+  uv_refs_--;\n+}\n+\n+\n+int uv_utf16_to_utf8(wchar_t* utf16Buffer, size_t utf16Size, char* utf8Buffer, size_t utf8Size) {\n+  return WideCharToMultiByte(CP_UTF8, 0, utf16Buffer, utf16Size, utf8Buffer, utf8Size, NULL, NULL);\n+}\n+\n+\n+int uv_get_exepath(char* buffer, size_t* size) {\n+  int retVal;\n+  size_t utf16Size;\n+  wchar_t* utf16Buffer;\n+\n+  if (!buffer || !size) {\n+    return -1;\n+  }\n+\n+  utf16Buffer = (wchar_t*)malloc(sizeof(wchar_t) * *size);\n+  if (!utf16Buffer) {\n+    retVal = -1;\n+    goto done;\n+  }\n+\n+  /* Get the path as UTF-16 */\n+  utf16Size = GetModuleFileNameW(NULL, utf16Buffer, *size - 1);\n+  if (utf16Size <= 0) {\n+    uv_set_sys_error(GetLastError());\n+    retVal = -1;\n+    goto done;\n+  }\n+\n+  utf16Buffer[utf16Size] = L'\\0';\n+\n+  /* Convert to UTF-8 */\n+  *size = uv_utf16_to_utf8(utf16Buffer, utf16Size, buffer, *size);\n+  if (!*size) {\n+    uv_set_sys_error(GetLastError());\n+    retVal = -1;\n+    goto done;\n+  }\n+\n+  buffer[*size] = '\\0';\n+  retVal = 0;\n+\n+done:\n+  if (utf16Buffer) {\n+    free(utf16Buffer);\n+  }\n+\n+  return retVal;\n+}"}, {"sha": "837da7d101392003fc58d861d4cdd12d614fe43f", "filename": "src/rt/libuv/uv-win.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv-win.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25", "patch": "@@ -0,0 +1,112 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#ifndef _WIN32_WINNT\n+# define _WIN32_WINNT   0x0501\n+#endif\n+\n+#include <stdint.h>\n+#include <winsock2.h>\n+#include <mswsock.h>\n+#include <ws2tcpip.h>\n+#include <windows.h>\n+\n+#include \"tree.h\"\n+\n+\n+/**\n+ * It should be possible to cast uv_buf_t[] to WSABUF[]\n+ * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n+ */\n+typedef struct uv_buf_t {\n+  ULONG len;\n+  char* base;\n+} uv_buf_t;\n+\n+#define UV_REQ_PRIVATE_FIELDS             \\\n+  union {                                 \\\n+    /* Used by I/O operations */          \\\n+    struct {                              \\\n+      OVERLAPPED overlapped;              \\\n+      size_t queued_bytes;                \\\n+    };                                    \\\n+  };                                      \\\n+  int flags;                              \\\n+  uv_err_t error;                         \\\n+  struct uv_req_s* next_req;\n+\n+#define uv_tcp_connection_fields          \\\n+  uv_alloc_cb alloc_cb;                   \\\n+  uv_read_cb read_cb;                     \\\n+  struct uv_req_s read_req;               \\\n+  unsigned int write_reqs_pending;        \\\n+  uv_req_t* shutdown_req;\n+\n+#define uv_tcp_server_fields              \\\n+  uv_connection_cb connection_cb;         \\\n+  SOCKET accept_socket;                   \\\n+  struct uv_req_s accept_req;             \\\n+  char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32];\n+\n+#define UV_TCP_PRIVATE_FIELDS             \\\n+  unsigned int reqs_pending;              \\\n+  union {                                 \\\n+    SOCKET socket;                        \\\n+    HANDLE handle;                        \\\n+  };                                      \\\n+  union {                                 \\\n+    struct { uv_tcp_connection_fields };  \\\n+    struct { uv_tcp_server_fields     };  \\\n+  };\n+\n+#define UV_TIMER_PRIVATE_FIELDS           \\\n+  RB_ENTRY(uv_timer_s) tree_entry;        \\\n+  int64_t due;                            \\\n+  int64_t repeat;                         \\\n+  uv_loop_cb timer_cb;\n+\n+#define UV_LOOP_PRIVATE_FIELDS            \\\n+  uv_handle_t* loop_prev;                 \\\n+  uv_handle_t* loop_next;                 \\\n+  uv_loop_cb loop_cb;\n+\n+#define UV_ASYNC_PRIVATE_FIELDS           \\\n+  struct uv_req_s async_req;              \\\n+  /* char to avoid alignment issues */    \\\n+  char volatile async_sent;\n+\n+#define UV_PREPARE_PRIVATE_FIELDS /* empty */\n+#define UV_CHECK_PRIVATE_FIELDS   /* empty */\n+#define UV_IDLE_PRIVATE_FIELDS    /* empty */\n+\n+/*\n+ * TODO: remove UV_LOOP_PRIVATE_FIELDS from UV_HANDLE_PRIVATE_FIELDS and\n+ * use it in UV_(PREPARE|CHECK|IDLE)_PRIVATE_FIELDS instead.\n+ */\n+\n+#define UV_HANDLE_PRIVATE_FIELDS          \\\n+  uv_handle_t* endgame_next;              \\\n+  unsigned int flags;                     \\\n+  uv_err_t error;                         \\\n+  UV_LOOP_PRIVATE_FIELDS\n+\n+\n+int uv_utf16_to_utf8(wchar_t* utf16Buffer, size_t utf16Size, char* utf8Buffer, size_t utf8Size);"}, {"sha": "cd48fde6fe01975b658efebfadfa81c2c6aab878", "filename": "src/rt/libuv/uv.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv.h", "raw_url": "https://github.com/rust-lang/rust/raw/904f443fa99a6349a09441c645aa8f5e4d86fd25/src%2Frt%2Flibuv%2Fuv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv.h?ref=904f443fa99a6349a09441c645aa8f5e4d86fd25"}]}