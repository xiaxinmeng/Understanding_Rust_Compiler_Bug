{"sha": "45d05ed78384b28fbd341068f36912a2e0308292", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDA1ZWQ3ODM4NGIyOGZiZDM0MTA2OGYzNjkxMmEyZTAzMDgyOTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T12:27:33Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T12:36:25Z"}, "message": "id-ify impls_in_crate_query", "tree": {"sha": "5b7f7abfc59e6e832be7fb0b22b3dcc704de946c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b7f7abfc59e6e832be7fb0b22b3dcc704de946c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d05ed78384b28fbd341068f36912a2e0308292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d05ed78384b28fbd341068f36912a2e0308292", "html_url": "https://github.com/rust-lang/rust/commit/45d05ed78384b28fbd341068f36912a2e0308292", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d05ed78384b28fbd341068f36912a2e0308292/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c43631829d8bac8b7533c994d8cf1241a95ce70", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c43631829d8bac8b7533c994d8cf1241a95ce70", "html_url": "https://github.com/rust-lang/rust/commit/4c43631829d8bac8b7533c994d8cf1241a95ce70"}], "stats": {"total": 130, "additions": 74, "deletions": 56}, "files": [{"sha": "821f919d47ea79a85af672cadcace4149f89e4f6", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=45d05ed78384b28fbd341068f36912a2e0308292", "patch": "@@ -997,6 +997,15 @@ pub struct ImplBlock {\n }\n \n impl ImplBlock {\n+    pub fn all_in_crate(db: &impl HirDatabase, krate: Crate) -> Vec<ImplBlock> {\n+        let impls = db.impls_in_crate(krate.crate_id);\n+        impls.all_impls().map(Self::from).collect()\n+    }\n+    pub fn for_trait(db: &impl HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplBlock> {\n+        let impls = db.impls_in_crate(krate.crate_id);\n+        impls.lookup_impl_blocks_for_trait(trait_).map(Self::from).collect()\n+    }\n+\n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n         db.impl_data(self.id).target_trait.clone()\n     }"}, {"sha": "32f05a4d8b9ecac9576ff9f2b920bc1555e15d61", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=45d05ed78384b28fbd341068f36912a2e0308292", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use ra_arena::map::ArenaMap;\n-use ra_db::salsa;\n+use ra_db::{salsa, CrateId};\n \n use crate::{\n     ty::{\n@@ -60,7 +60,7 @@ pub trait HirDatabase: DefDatabase {\n     fn generic_defaults(&self, def: GenericDefId) -> Substs;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n-    fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n+    fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplBlocks>;\n \n     #[salsa::invoke(crate::ty::traits::impls_for_trait_query)]\n     fn impls_for_trait(&self, krate: Crate, trait_: Trait) -> Arc<[ImplBlock]>;"}, {"sha": "489fcd64b98f5d02207d40e7a754e4dd9d0a1b46", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 55, "deletions": 46, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=45d05ed78384b28fbd341068f36912a2e0308292", "patch": "@@ -5,14 +5,19 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n-use hir_def::{lang_item::LangItemTarget, resolver::Resolver, AstItemDef, HasModule};\n+use hir_def::{\n+    lang_item::LangItemTarget, resolver::HasResolver, resolver::Resolver, AssocItemId, AstItemDef,\n+    HasModule, ImplId, TraitId,\n+};\n+use ra_db::CrateId;\n+use ra_prof::profile;\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{Ty, TypeCtor},\n-    AssocItem, Crate, Function, ImplBlock, Module, Mutability, Name, Trait,\n+    AssocItem, Crate, Function, Mutability, Name, Trait,\n };\n \n use super::{autoderef, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -37,54 +42,58 @@ impl TyFingerprint {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n-    impls: FxHashMap<TyFingerprint, Vec<ImplBlock>>,\n-    impls_by_trait: FxHashMap<Trait, Vec<ImplBlock>>,\n+    impls: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+    impls_by_trait: FxHashMap<TraitId, Vec<ImplId>>,\n }\n \n impl CrateImplBlocks {\n     pub(crate) fn impls_in_crate_query(\n         db: &impl HirDatabase,\n-        krate: Crate,\n+        krate: CrateId,\n     ) -> Arc<CrateImplBlocks> {\n-        let mut crate_impl_blocks =\n+        let _p = profile(\"impls_in_crate_query\");\n+        let mut res =\n             CrateImplBlocks { impls: FxHashMap::default(), impls_by_trait: FxHashMap::default() };\n-        if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module);\n+\n+        let crate_def_map = db.crate_def_map(krate);\n+        for (_module_id, module_data) in crate_def_map.modules.iter() {\n+            for &impl_id in module_data.impls.iter() {\n+                let impl_data = db.impl_data(impl_id);\n+                let resolver = impl_id.resolver(db);\n+\n+                let target_ty = { Ty::from_hir(db, &resolver, &impl_data.target_type) };\n+\n+                match &impl_data.target_trait {\n+                    Some(trait_ref) => {\n+                        if let Some(tr) =\n+                            TraitRef::from_hir(db, &resolver, &trait_ref, Some(target_ty))\n+                        {\n+                            res.impls_by_trait.entry(tr.trait_.id).or_default().push(impl_id);\n+                        }\n+                    }\n+                    None => {\n+                        if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n+                            res.impls.entry(target_ty_fp).or_default().push(impl_id);\n+                        }\n+                    }\n+                }\n+            }\n         }\n-        Arc::new(crate_impl_blocks)\n+\n+        Arc::new(res)\n     }\n-    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplBlock> + '_ {\n+    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplId> + '_ {\n         let fingerprint = TyFingerprint::for_impl(ty);\n         fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flatten().copied()\n     }\n \n-    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplBlock> + '_ {\n-        self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n+    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplId> + '_ {\n+        self.impls_by_trait.get(&tr.id).into_iter().flatten().copied()\n     }\n \n-    pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n+    pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplId> + 'a {\n         self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n     }\n-\n-    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n-        for impl_block in module.impl_blocks(db) {\n-            let target_ty = impl_block.target_ty(db);\n-\n-            if impl_block.target_trait(db).is_some() {\n-                if let Some(tr) = impl_block.target_trait_ref(db) {\n-                    self.impls_by_trait.entry(tr.trait_).or_default().push(impl_block);\n-                }\n-            } else {\n-                if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                    self.impls.entry(target_ty_fp).or_default().push(impl_block);\n-                }\n-            }\n-        }\n-\n-        for child in module.children(db) {\n-            self.collect_recursive(db, child);\n-        }\n-    }\n }\n \n fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {\n@@ -279,14 +288,14 @@ fn iterate_inherent_methods<T>(\n     mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     for krate in def_crates(db, krate, &ty.value)? {\n-        let impls = db.impls_in_crate(krate);\n+        let impls = db.impls_in_crate(krate.crate_id);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n-            for item in impl_block.items(db) {\n+            for &item in db.impl_data(impl_block).items.iter() {\n                 if !is_valid_candidate(db, name, mode, item) {\n                     continue;\n                 }\n-                if let Some(result) = callback(&ty.value, item) {\n+                if let Some(result) = callback(&ty.value, item.into()) {\n                     return Some(result);\n                 }\n             }\n@@ -299,17 +308,17 @@ fn is_valid_candidate(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n     mode: LookupMode,\n-    item: AssocItem,\n+    item: AssocItemId,\n ) -> bool {\n     match item {\n-        AssocItem::Function(m) => {\n-            let data = db.function_data(m.id);\n-            name.map_or(true, |name| data.name == *name)\n+        AssocItemId::FunctionId(m) => {\n+            let data = db.function_data(m);\n+            name.map_or(true, |name| &data.name == name)\n                 && (data.has_self_param || mode == LookupMode::Path)\n         }\n-        AssocItem::Const(c) => {\n-            name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n-                && (mode == LookupMode::Path)\n+        AssocItemId::ConstId(c) => {\n+            let data = db.const_data(c);\n+            name.map_or(true, |name| data.name.as_ref() == Some(name)) && (mode == LookupMode::Path)\n         }\n         _ => false,\n     }\n@@ -344,11 +353,11 @@ impl Ty {\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         for krate in def_crates(db, krate, &self)? {\n-            let impls = db.impls_in_crate(krate);\n+            let impls = db.impls_in_crate(krate.crate_id);\n \n             for impl_block in impls.lookup_impl_blocks(&self) {\n-                for item in impl_block.items(db) {\n-                    if let Some(result) = callback(item) {\n+                for &item in db.impl_data(impl_block).items.iter() {\n+                    if let Some(result) = callback(item.into()) {\n                         return Some(result);\n                     }\n                 }"}, {"sha": "12dc9657255a9839902afad68200deada898d44b", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=45d05ed78384b28fbd341068f36912a2e0308292", "patch": "@@ -1,3 +1,3 @@\n //! FIXME: write short doc here\n \n-pub use hir_ty::primitive::{FloatBitness, IntBitness, Signedness, FloatTy, IntTy, Uncertain};\n+pub use hir_ty::primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain};"}, {"sha": "2eeb030999034153152d3427406d929f56c2074a", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=45d05ed78384b28fbd341068f36912a2e0308292", "patch": "@@ -88,8 +88,8 @@ pub(crate) fn impls_for_trait_query(\n     for dep in krate.dependencies(db) {\n         impls.extend(db.impls_for_trait(dep.krate, trait_).iter());\n     }\n-    let crate_impl_blocks = db.impls_in_crate(krate);\n-    impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_));\n+    let crate_impl_blocks = db.impls_in_crate(krate.crate_id);\n+    impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_).map(ImplBlock::from));\n     impls.into_iter().collect()\n }\n "}, {"sha": "b3ebd914546c621a369383328428bfc30a2ae2b2", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d05ed78384b28fbd341068f36912a2e0308292/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=45d05ed78384b28fbd341068f36912a2e0308292", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{db::HirDatabase, ApplicationTy, FromSource, Ty, TypeCtor};\n+use hir::{ApplicationTy, FromSource, ImplBlock, Ty, TypeCtor};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n@@ -56,11 +56,11 @@ fn impls_for_def(\n     };\n \n     let krate = module.krate();\n-    let impls = db.impls_in_crate(krate);\n+    let impls = ImplBlock::all_in_crate(db, krate);\n \n     Some(\n         impls\n-            .all_impls()\n+            .into_iter()\n             .filter(|impl_block| is_equal_for_find_impls(&ty, &impl_block.target_ty(db)))\n             .map(|imp| imp.to_nav(db))\n             .collect(),\n@@ -77,9 +77,9 @@ fn impls_for_trait(\n     let tr = hir::Trait::from_source(db, src)?;\n \n     let krate = module.krate();\n-    let impls = db.impls_in_crate(krate);\n+    let impls = ImplBlock::for_trait(db, krate, tr);\n \n-    Some(impls.lookup_impl_blocks_for_trait(tr).map(|imp| imp.to_nav(db)).collect())\n+    Some(impls.into_iter().map(|imp| imp.to_nav(db)).collect())\n }\n \n fn is_equal_for_find_impls(original_ty: &Ty, impl_ty: &Ty) -> bool {"}]}