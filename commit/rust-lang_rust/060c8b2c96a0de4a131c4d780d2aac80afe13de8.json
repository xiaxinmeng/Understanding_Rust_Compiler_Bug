{"sha": "060c8b2c96a0de4a131c4d780d2aac80afe13de8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MGM4YjJjOTZhMGRlNGExMzFjNGQ3ODBkMmFhYzgwYWZlMTNkZTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-03T17:34:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-03T17:34:59Z"}, "message": "Merge #6287\n\n6287: Don't replace entire module and file nodes when inserting imports r=matklad a=Veykril\n\nThis change minifies the resulting diff of import insertions by inserting or replacing the produced use tree directly through an `action` return value instead replacing the entire container node. This action has to be applied by the caller now. This unfortunately pulls the `AssistBuilder` into scope of `insert_use` back again but I tried to at least keep it away from the `insert_use` fn itself.\r\n\r\nI'm open to more/better ideas regarding this :)\r\n\r\nFixes #6196\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "1c9c4d8b4134418dcf0dcfaf97d43c97d391f246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c9c4d8b4134418dcf0dcfaf97d43c97d391f246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/060c8b2c96a0de4a131c4d780d2aac80afe13de8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfoZTDCRBK7hj4Ov3rIwAAdHIIALF9WTq6mzY9fOLUdZHU6Fms\nD26TdjyhRQ6/B2ur64UsfuwGGm0ejAURs7rTfYm0xtn8FxGyo/dAFaGRnpkN1Xwp\nLelOl6mF4L1kitmnr9/VjYyrOiuK2bNPZad0/0igTnNaQg4loHZNad6wYbZzJfUs\na5FB54ev0kKef15EF0nWD9cxn+7cWFscxEVIGSuCpU6iPvaOA8qwO5GDCeGbQlmN\nsLGQA5qOxlZhT3mI3ivzdrAe1Lp7HXnary445Iu0TuZ54I/H2frY1DSZmKDRdLuT\n+ytZYjBuVfelTK/EwqUtjBWi1Vdd3i+PBvZap6HxEypWhl3de9gNfRDBwrCksqA=\n=4j6Q\n-----END PGP SIGNATURE-----\n", "payload": "tree 1c9c4d8b4134418dcf0dcfaf97d43c97d391f246\nparent 5e622332774fbd57c12addd46b058c8feb2b08a6\nparent cd349dbbc4a39342fd54e46fc9d70e3e649a2fda\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1604424899 +0000\ncommitter GitHub <noreply@github.com> 1604424899 +0000\n\nMerge #6287\n\n6287: Don't replace entire module and file nodes when inserting imports r=matklad a=Veykril\n\nThis change minifies the resulting diff of import insertions by inserting or replacing the produced use tree directly through an `action` return value instead replacing the entire container node. This action has to be applied by the caller now. This unfortunately pulls the `AssistBuilder` into scope of `insert_use` back again but I tried to at least keep it away from the `insert_use` fn itself.\r\n\r\nI'm open to more/better ideas regarding this :)\r\n\r\nFixes #6196\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/060c8b2c96a0de4a131c4d780d2aac80afe13de8", "html_url": "https://github.com/rust-lang/rust/commit/060c8b2c96a0de4a131c4d780d2aac80afe13de8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/060c8b2c96a0de4a131c4d780d2aac80afe13de8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e622332774fbd57c12addd46b058c8feb2b08a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e622332774fbd57c12addd46b058c8feb2b08a6", "html_url": "https://github.com/rust-lang/rust/commit/5e622332774fbd57c12addd46b058c8feb2b08a6"}, {"sha": "cd349dbbc4a39342fd54e46fc9d70e3e649a2fda", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd349dbbc4a39342fd54e46fc9d70e3e649a2fda", "html_url": "https://github.com/rust-lang/rust/commit/cd349dbbc4a39342fd54e46fc9d70e3e649a2fda"}], "stats": {"total": 236, "additions": 129, "deletions": 107}, "files": [{"sha": "37dd6126618efd813d9bd592246b795481618214", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=060c8b2c96a0de4a131c4d780d2aac80afe13de8", "patch": "@@ -99,17 +99,16 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let range = ctx.sema.original_range(import_assets.syntax_under_caret()).range;\n     let group = import_group_message(import_assets.import_candidate());\n     let scope = ImportScope::find_insert_use_container(import_assets.syntax_under_caret(), ctx)?;\n-    let syntax = scope.as_syntax_node();\n     for (import, _) in proposed_imports {\n         acc.add_group(\n             &group,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n             format!(\"Import `{}`\", &import),\n             range,\n             |builder| {\n-                let new_syntax =\n+                let rewriter =\n                     insert_use(&scope, mod_path_to_ast(&import), ctx.config.insert_use.merge);\n-                builder.replace(syntax.text_range(), new_syntax.to_string())\n+                builder.rewrite(rewriter);\n             },\n         );\n     }"}, {"sha": "dddab255eea85f945082efc06b5df8b575d911d4", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 69, "deletions": 87, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=060c8b2c96a0de4a131c4d780d2aac80afe13de8", "patch": "@@ -1,16 +1,14 @@\n-use hir::{EnumVariant, Module, ModuleDef, Name};\n-use ide_db::base_db::FileId;\n+use hir::{AsName, EnumVariant, Module, ModuleDef, Name};\n use ide_db::{defs::Definition, search::Reference, RootDatabase};\n-use itertools::Itertools;\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n     algo::find_node_at_offset,\n-    ast::{self, edit::IndentLevel, ArgListOwner, AstNode, NameOwner, VisibilityOwner},\n-    SourceFile, TextRange, TextSize,\n+    algo::SyntaxRewriter,\n+    ast::{self, edit::IndentLevel, make, ArgListOwner, AstNode, NameOwner, VisibilityOwner},\n+    SourceFile, SyntaxElement,\n };\n \n use crate::{\n-    assist_context::AssistBuilder,\n     utils::{insert_use, mod_path_to_ast, ImportScope},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n@@ -43,7 +41,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n         return None;\n     }\n \n-    let variant_name = variant.name()?.to_string();\n+    let variant_name = variant.name()?;\n     let variant_hir = ctx.sema.to_def(&variant)?;\n     if existing_struct_def(ctx.db(), &variant_name, &variant_hir) {\n         return None;\n@@ -62,49 +60,58 @@ pub(crate) fn extract_struct_from_enum_variant(\n         |builder| {\n             let definition = Definition::ModuleDef(ModuleDef::EnumVariant(variant_hir));\n             let res = definition.usages(&ctx.sema).all();\n-            let start_offset = variant.parent_enum().syntax().text_range().start();\n+\n             let mut visited_modules_set = FxHashSet::default();\n             visited_modules_set.insert(current_module);\n+            let mut rewriters = FxHashMap::default();\n             for reference in res {\n+                let rewriter = rewriters\n+                    .entry(reference.file_range.file_id)\n+                    .or_insert_with(SyntaxRewriter::default);\n                 let source_file = ctx.sema.parse(reference.file_range.file_id);\n                 update_reference(\n                     ctx,\n-                    builder,\n+                    rewriter,\n                     reference,\n                     &source_file,\n                     &enum_module_def,\n                     &variant_hir_name,\n                     &mut visited_modules_set,\n                 );\n             }\n+            let mut rewriter =\n+                rewriters.remove(&ctx.frange.file_id).unwrap_or_else(SyntaxRewriter::default);\n+            for (file_id, rewriter) in rewriters {\n+                builder.edit_file(file_id);\n+                builder.rewrite(rewriter);\n+            }\n+            builder.edit_file(ctx.frange.file_id);\n+            update_variant(&mut rewriter, &variant_name, &field_list);\n             extract_struct_def(\n-                builder,\n+                &mut rewriter,\n                 &enum_ast,\n-                &variant_name,\n-                &field_list.to_string(),\n-                start_offset,\n-                ctx.frange.file_id,\n-                &visibility,\n+                variant_name.clone(),\n+                &field_list,\n+                &variant.parent_enum().syntax().clone().into(),\n+                visibility,\n             );\n-            let list_range = field_list.syntax().text_range();\n-            update_variant(builder, &variant_name, ctx.frange.file_id, list_range);\n+            builder.rewrite(rewriter);\n         },\n     )\n }\n \n-fn existing_struct_def(db: &RootDatabase, variant_name: &str, variant: &EnumVariant) -> bool {\n+fn existing_struct_def(db: &RootDatabase, variant_name: &ast::Name, variant: &EnumVariant) -> bool {\n     variant\n         .parent_enum(db)\n         .module(db)\n         .scope(db, None)\n         .into_iter()\n-        .any(|(name, _)| name.to_string() == variant_name)\n+        .any(|(name, _)| name == variant_name.as_name())\n }\n \n-#[allow(dead_code)]\n fn insert_import(\n     ctx: &AssistContext,\n-    builder: &mut AssistBuilder,\n+    rewriter: &mut SyntaxRewriter,\n     path: &ast::PathExpr,\n     module: &Module,\n     enum_module_def: &ModuleDef,\n@@ -116,69 +123,59 @@ fn insert_import(\n         mod_path.segments.pop();\n         mod_path.segments.push(variant_hir_name.clone());\n         let scope = ImportScope::find_insert_use_container(path.syntax(), ctx)?;\n-        let syntax = scope.as_syntax_node();\n \n-        let new_syntax =\n-            insert_use(&scope, mod_path_to_ast(&mod_path), ctx.config.insert_use.merge);\n-        // FIXME: this will currently panic as multiple imports will have overlapping text ranges\n-        builder.replace(syntax.text_range(), new_syntax.to_string())\n+        *rewriter += insert_use(&scope, mod_path_to_ast(&mod_path), ctx.config.insert_use.merge);\n     }\n     Some(())\n }\n \n-// FIXME: this should use strongly-typed `make`, rather than string manipulation.\n fn extract_struct_def(\n-    builder: &mut AssistBuilder,\n+    rewriter: &mut SyntaxRewriter,\n     enum_: &ast::Enum,\n-    variant_name: &str,\n-    variant_list: &str,\n-    start_offset: TextSize,\n-    file_id: FileId,\n-    visibility: &Option<ast::Visibility>,\n+    variant_name: ast::Name,\n+    variant_list: &ast::TupleFieldList,\n+    start_offset: &SyntaxElement,\n+    visibility: Option<ast::Visibility>,\n ) -> Option<()> {\n-    let visibility_string = if let Some(visibility) = visibility {\n-        format!(\"{} \", visibility.to_string())\n-    } else {\n-        \"\".to_string()\n-    };\n-    let indent = IndentLevel::from_node(enum_.syntax());\n-    let struct_def = format!(\n-        r#\"{}struct {}{};\n-\n-{}\"#,\n-        visibility_string,\n-        variant_name,\n-        list_with_visibility(variant_list),\n-        indent\n+    let variant_list = make::tuple_field_list(\n+        variant_list\n+            .fields()\n+            .flat_map(|field| Some(make::tuple_field(Some(make::visibility_pub()), field.ty()?))),\n     );\n-    builder.edit_file(file_id);\n-    builder.insert(start_offset, struct_def);\n+\n+    rewriter.insert_before(\n+        start_offset,\n+        make::struct_(visibility, variant_name, None, variant_list.into()).syntax(),\n+    );\n+    rewriter.insert_before(start_offset, &make::tokens::blank_line());\n+\n+    if let indent_level @ 1..=usize::MAX = IndentLevel::from_node(enum_.syntax()).0 as usize {\n+        rewriter\n+            .insert_before(start_offset, &make::tokens::whitespace(&\" \".repeat(4 * indent_level)));\n+    }\n     Some(())\n }\n \n fn update_variant(\n-    builder: &mut AssistBuilder,\n-    variant_name: &str,\n-    file_id: FileId,\n-    list_range: TextRange,\n+    rewriter: &mut SyntaxRewriter,\n+    variant_name: &ast::Name,\n+    field_list: &ast::TupleFieldList,\n ) -> Option<()> {\n-    let inside_variant_range = TextRange::new(\n-        list_range.start().checked_add(TextSize::from(1))?,\n-        list_range.end().checked_sub(TextSize::from(1))?,\n-    );\n-    builder.edit_file(file_id);\n-    builder.replace(inside_variant_range, variant_name);\n+    let (l, r): (SyntaxElement, SyntaxElement) =\n+        (field_list.l_paren_token()?.into(), field_list.r_paren_token()?.into());\n+    let replacement = vec![l, variant_name.syntax().clone().into(), r];\n+    rewriter.replace_with_many(field_list.syntax(), replacement);\n     Some(())\n }\n \n fn update_reference(\n     ctx: &AssistContext,\n-    builder: &mut AssistBuilder,\n+    rewriter: &mut SyntaxRewriter,\n     reference: Reference,\n     source_file: &SourceFile,\n-    _enum_module_def: &ModuleDef,\n-    _variant_hir_name: &Name,\n-    _visited_modules_set: &mut FxHashSet<Module>,\n+    enum_module_def: &ModuleDef,\n+    variant_hir_name: &Name,\n+    visited_modules_set: &mut FxHashSet<Module>,\n ) -> Option<()> {\n     let path_expr: ast::PathExpr = find_node_at_offset::<ast::PathExpr>(\n         source_file.syntax(),\n@@ -187,35 +184,21 @@ fn update_reference(\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let list = call.arg_list()?;\n     let segment = path_expr.path()?.segment()?;\n-    let _module = ctx.sema.scope(&path_expr.syntax()).module()?;\n-    let list_range = list.syntax().text_range();\n-    let inside_list_range = TextRange::new(\n-        list_range.start().checked_add(TextSize::from(1))?,\n-        list_range.end().checked_sub(TextSize::from(1))?,\n-    );\n-    builder.edit_file(reference.file_range.file_id);\n-    /* FIXME: this most likely requires AST-based editing, see `insert_import`\n+    let module = ctx.sema.scope(&path_expr.syntax()).module()?;\n     if !visited_modules_set.contains(&module) {\n-        if insert_import(ctx, builder, &path_expr, &module, enum_module_def, variant_hir_name)\n+        if insert_import(ctx, rewriter, &path_expr, &module, enum_module_def, variant_hir_name)\n             .is_some()\n         {\n             visited_modules_set.insert(module);\n         }\n     }\n-    */\n-    builder.replace(inside_list_range, format!(\"{}{}\", segment, list));\n-    Some(())\n-}\n \n-fn list_with_visibility(list: &str) -> String {\n-    list.split(',')\n-        .map(|part| {\n-            let index = if part.chars().next().unwrap() == '(' { 1usize } else { 0 };\n-            let mut mod_part = part.trim().to_string();\n-            mod_part.insert_str(index, \"pub \");\n-            mod_part\n-        })\n-        .join(\", \")\n+    let lparen = syntax::SyntaxElement::from(list.l_paren_token()?);\n+    let rparen = syntax::SyntaxElement::from(list.r_paren_token()?);\n+    rewriter.insert_after(&lparen, segment.syntax());\n+    rewriter.insert_after(&lparen, &lparen);\n+    rewriter.insert_before(&rparen, &rparen);\n+    Some(())\n }\n \n #[cfg(test)]\n@@ -250,7 +233,6 @@ pub enum A { One(One) }\"#,\n     }\n \n     #[test]\n-    #[ignore] // FIXME: this currently panics if `insert_import` is used\n     fn test_extract_struct_with_complex_imports() {\n         check_assist(\n             extract_struct_from_enum_variant,"}, {"sha": "d7e1d95805e67529b4f172bd19b0bec2c5c1a55e", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=060c8b2c96a0de4a131c4d780d2aac80afe13de8", "patch": "@@ -45,10 +45,9 @@ pub(crate) fn replace_qualified_name_with_use(\n             // affected (that is, all paths inside the node we added the `use` to).\n             let mut rewriter = SyntaxRewriter::default();\n             shorten_paths(&mut rewriter, syntax.clone(), &path);\n-            let rewritten_syntax = rewriter.rewrite(&syntax);\n-            if let Some(ref import_scope) = ImportScope::from(rewritten_syntax) {\n-                let new_syntax = insert_use(import_scope, path, ctx.config.insert_use.merge);\n-                builder.replace(syntax.text_range(), new_syntax.to_string())\n+            if let Some(ref import_scope) = ImportScope::from(syntax.clone()) {\n+                rewriter += insert_use(import_scope, path, ctx.config.insert_use.merge);\n+                builder.rewrite(rewriter);\n             }\n         },\n     )"}, {"sha": "84a0dffdd446964f42a150f787fd69f2d7ed27cc", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=060c8b2c96a0de4a131c4d780d2aac80afe13de8", "patch": "@@ -1,12 +1,9 @@\n //! Handle syntactic aspects of inserting a new `use`.\n-use std::{\n-    cmp::Ordering,\n-    iter::{self, successors},\n-};\n+use std::{cmp::Ordering, iter::successors};\n \n use itertools::{EitherOrBoth, Itertools};\n use syntax::{\n-    algo,\n+    algo::SyntaxRewriter,\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n@@ -88,20 +85,19 @@ impl ImportScope {\n }\n \n /// Insert an import path into the given file/node. A `merge` value of none indicates that no import merging is allowed to occur.\n-pub(crate) fn insert_use(\n+pub(crate) fn insert_use<'a>(\n     scope: &ImportScope,\n     path: ast::Path,\n     merge: Option<MergeBehaviour>,\n-) -> SyntaxNode {\n+) -> SyntaxRewriter<'a> {\n+    let mut rewriter = SyntaxRewriter::default();\n     let use_item = make::use_(make::use_tree(path.clone(), None, None, false));\n     // merge into existing imports if possible\n     if let Some(mb) = merge {\n         for existing_use in scope.as_syntax_node().children().filter_map(ast::Use::cast) {\n             if let Some(merged) = try_merge_imports(&existing_use, &use_item, mb) {\n-                let to_delete: SyntaxElement = existing_use.syntax().clone().into();\n-                let to_delete = to_delete.clone()..=to_delete;\n-                let to_insert = iter::once(merged.syntax().clone().into());\n-                return algo::replace_children(scope.as_syntax_node(), to_delete, to_insert);\n+                rewriter.replace(existing_use.syntax(), merged.syntax());\n+                return rewriter;\n             }\n         }\n     }\n@@ -157,7 +153,15 @@ pub(crate) fn insert_use(\n         buf\n     };\n \n-    algo::insert_children(scope.as_syntax_node(), insert_position, to_insert)\n+    match insert_position {\n+        InsertPosition::First => {\n+            rewriter.insert_many_as_first_children(scope.as_syntax_node(), to_insert)\n+        }\n+        InsertPosition::Last => return rewriter, // actually unreachable\n+        InsertPosition::Before(anchor) => rewriter.insert_many_before(&anchor, to_insert),\n+        InsertPosition::After(anchor) => rewriter.insert_many_after(&anchor, to_insert),\n+    }\n+    rewriter\n }\n \n fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n@@ -1101,7 +1105,8 @@ use foo::bar::baz::Qux;\",\n             .find_map(ast::Path::cast)\n             .unwrap();\n \n-        let result = insert_use(&file, path, mb).to_string();\n+        let rewriter = insert_use(&file, path, mb);\n+        let result = rewriter.rewrite(file.as_syntax_node()).to_string();\n         assert_eq_text!(&result, ra_fixture_after);\n     }\n "}, {"sha": "2cf436e7a1f2969640045367b0b566f3004e4271", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060c8b2c96a0de4a131c4d780d2aac80afe13de8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=060c8b2c96a0de4a131c4d780d2aac80afe13de8", "patch": "@@ -351,6 +351,23 @@ pub fn visibility_pub_crate() -> ast::Visibility {\n     ast_from_text(\"pub(crate) struct S\")\n }\n \n+pub fn visibility_pub() -> ast::Visibility {\n+    ast_from_text(\"pub struct S\")\n+}\n+\n+pub fn tuple_field_list(fields: impl IntoIterator<Item = ast::TupleField>) -> ast::TupleFieldList {\n+    let fields = fields.into_iter().join(\", \");\n+    ast_from_text(&format!(\"struct f({});\", fields))\n+}\n+\n+pub fn tuple_field(visibility: Option<ast::Visibility>, ty: ast::Type) -> ast::TupleField {\n+    let visibility = match visibility {\n+        None => String::new(),\n+        Some(it) => format!(\"{} \", it),\n+    };\n+    ast_from_text(&format!(\"struct f({}{});\", visibility, ty))\n+}\n+\n pub fn fn_(\n     visibility: Option<ast::Visibility>,\n     fn_name: ast::Name,\n@@ -373,6 +390,26 @@ pub fn fn_(\n     ))\n }\n \n+pub fn struct_(\n+    visibility: Option<ast::Visibility>,\n+    strukt_name: ast::Name,\n+    type_params: Option<ast::GenericParamList>,\n+    field_list: ast::FieldList,\n+) -> ast::Struct {\n+    let semicolon = if matches!(field_list, ast::FieldList::TupleFieldList(_)) { \";\" } else { \"\" };\n+    let type_params =\n+        if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n+    let visibility = match visibility {\n+        None => String::new(),\n+        Some(it) => format!(\"{} \", it),\n+    };\n+\n+    ast_from_text(&format!(\n+        \"{}struct {}{}{}{}\",\n+        visibility, strukt_name, type_params, field_list, semicolon\n+    ))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let node = match parse.tree().syntax().descendants().find_map(N::cast) {"}]}