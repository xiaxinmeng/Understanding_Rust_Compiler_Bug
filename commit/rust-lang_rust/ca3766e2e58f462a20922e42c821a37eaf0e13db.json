{"sha": "ca3766e2e58f462a20922e42c821a37eaf0e13db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMzc2NmUyZTU4ZjQ2MmEyMDkyMmU0MmM4MjFhMzdlYWYwZTEzZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-14T14:43:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-14T14:43:32Z"}, "message": "Auto merge of #64456 - Centril:rollup-ytqdwaq, r=Centril\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #63846 (Added table containing the system calls used by Instant and SystemTime.)\n - #64116 (Fix minor typo in docs.)\n - #64203 (A few cosmetic improvements to code & comments in liballoc and libcore)\n - #64302 (Shrink `ObligationCauseCode`)\n - #64372 (use randSecure and randABytes)\n - #64374 (Box `DiagnosticBuilder`.)\n - #64375 (Fast path for vec.clear/truncate )\n - #64378 (Fix inconsistent link formatting.)\n - #64384 (Trim rustc-workspace-hack)\n - #64393 ( declare EnvKey before use to fix build error)\n - #64420 (Inline `mark_neighbours_as_waiting_from`.)\n - #64422 (Remove raw string literal quotes from error index descriptions)\n - #64423 (Add self to .mailmap)\n - #64425 (typo fix)\n - #64431 (fn ptr is structural match)\n - #64435 (codegen: use \"_N\" (like for other locals) instead of \"argN\", for argument names.)\n - #64439 (fix #64430, confusing `owned_box` error message in no_std build)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "02f2665ed12dcf87a18bf431eee4d8ae31a90adc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02f2665ed12dcf87a18bf431eee4d8ae31a90adc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca3766e2e58f462a20922e42c821a37eaf0e13db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3766e2e58f462a20922e42c821a37eaf0e13db", "html_url": "https://github.com/rust-lang/rust/commit/ca3766e2e58f462a20922e42c821a37eaf0e13db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca3766e2e58f462a20922e42c821a37eaf0e13db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "457666860cf198ddacc3d235b7360499eec3b897", "url": "https://api.github.com/repos/rust-lang/rust/commits/457666860cf198ddacc3d235b7360499eec3b897", "html_url": "https://github.com/rust-lang/rust/commit/457666860cf198ddacc3d235b7360499eec3b897"}, {"sha": "1c7959bb5d8d780e84eef29db9ae32b4d4b4b3d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c7959bb5d8d780e84eef29db9ae32b4d4b4b3d2", "html_url": "https://github.com/rust-lang/rust/commit/1c7959bb5d8d780e84eef29db9ae32b4d4b4b3d2"}], "stats": {"total": 1045, "additions": 663, "deletions": 382}, "files": [{"sha": "9587aaab3594506bf8398f25a9d433096a6cb939", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -184,6 +184,7 @@ Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Nick Platt <platt.nicholas@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n+Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>\n Oliver Scherer <oliver.schneider@kit.edu> <git-spam-no-reply9815368754983@oli-obk.de>\n Oliver Scherer <oliver.schneider@kit.edu> <git-spam9815368754983@oli-obk.de>\n Oliver Scherer <oliver.schneider@kit.edu> <github333195615777966@oli-obk.de>"}, {"sha": "57e4a22742759325cb8f94178732324bd40e3c68", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -3256,13 +3256,9 @@ version = \"1.0.0\"\n dependencies = [\n  \"byteorder\",\n  \"crossbeam-utils 0.6.5\",\n- \"parking_lot 0.7.1\",\n- \"rand 0.6.1\",\n- \"scopeguard 0.3.3\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n- \"syn 0.15.35\",\n  \"winapi 0.3.6\",\n ]\n "}, {"sha": "ecb5948f11b363447d0738106c8175be60e06346", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -102,8 +102,8 @@ fn test_append() {\n         assert_eq!(m.pop_front(), Some(elt))\n     }\n     assert_eq!(n.len(), 0);\n-    // let's make sure it's working properly, since we\n-    // did some direct changes to private members\n+    // Let's make sure it's working properly, since we\n+    // did some direct changes to private members.\n     n.push_back(3);\n     assert_eq!(n.len(), 1);\n     assert_eq!(n.pop_front(), Some(3));"}, {"sha": "cf025eee4358b71de1ff6e244dceb8402a9aeb8f", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -19,26 +19,26 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces Unique::empty() on zero-sized types\n-/// * Produces Unique::empty() on zero-length allocations\n-/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n-/// * Guards against 32-bit systems allocating more than isize::MAX bytes\n-/// * Guards against overflowing your length\n-/// * Aborts on OOM or calls handle_alloc_error as applicable\n-/// * Avoids freeing Unique::empty()\n-/// * Contains a ptr::Unique and thus endows the user with all related benefits\n+/// * Produces `Unique::empty()` on zero-sized types.\n+/// * Produces `Unique::empty()` on zero-length allocations.\n+/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n+/// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n+/// * Guards against overflowing your length.\n+/// * Aborts on OOM or calls `handle_alloc_error` as applicable.\n+/// * Avoids freeing `Unique::empty()`.\n+/// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n-/// free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec\n-/// to handle the actual things *stored* inside of a RawVec.\n+/// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n+/// to handle the actual things *stored* inside of a `RawVec`.\n ///\n-/// Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types.\n-/// This enables you to use capacity growing logic catch the overflows in your length\n+/// Note that a `RawVec` always forces its capacity to be `usize::MAX` for zero-sized types.\n+/// This enables you to use capacity-growing logic catch the overflows in your length\n /// that might occur with zero-sized types.\n ///\n-/// However this means that you need to be careful when round-tripping this type\n-/// with a `Box<[T]>`: `capacity()` won't yield the len. However `with_capacity`,\n-/// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n+/// The above means that you need to be careful when round-tripping this type with a\n+/// `Box<[T]>`, since `capacity()` won't yield the length. However, `with_capacity`,\n+/// `shrink_to_fit`, and `from_box` will actually set `RawVec`'s private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n@@ -49,14 +49,14 @@ pub struct RawVec<T, A: Alloc = Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Like `new` but parameterized over the choice of allocator for\n-    /// the returned RawVec.\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n     pub const fn new_in(a: A) -> Self {\n-        // !0 is usize::MAX. This branch should be stripped at compile time.\n-        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`\n+        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n         //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n         RawVec {\n             ptr: Unique::empty(),\n             // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n@@ -65,15 +65,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Like `with_capacity` but parameterized over the choice of\n-    /// allocator for the returned RawVec.\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, false, a)\n     }\n \n-    /// Like `with_capacity_zeroed` but parameterized over the choice\n-    /// of allocator for the returned RawVec.\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, true, a)\n@@ -86,7 +86,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n             alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // handles ZSTs and `capacity = 0` alike\n+            // Handles ZSTs and `capacity == 0` alike.\n             let ptr = if alloc_size == 0 {\n                 NonNull::<T>::dangling()\n             } else {\n@@ -113,20 +113,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Creates the biggest possible RawVec (on the system heap)\n-    /// without allocating. If T has positive size, then this makes a\n-    /// RawVec with capacity 0. If T has 0 size, then it makes a\n-    /// RawVec with capacity `usize::MAX`. Useful for implementing\n+    /// Creates the biggest possible `RawVec` (on the system heap)\n+    /// without allocating. If `T` has positive size, then this makes a\n+    /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n+    /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub const fn new() -> Self {\n         Self::new_in(Global)\n     }\n \n-    /// Creates a RawVec (on the system heap) with exactly the\n+    /// Creates a `RawVec` (on the system heap) with exactly the\n     /// capacity and alignment requirements for a `[T; capacity]`. This is\n-    /// equivalent to calling RawVec::new when `capacity` is 0 or T is\n+    /// equivalent to calling `RawVec::new` when `capacity` is `0` or `T` is\n     /// zero-sized. Note that if `T` is zero-sized this means you will\n-    /// *not* get a RawVec with the requested capacity!\n+    /// *not* get a `RawVec` with the requested capacity.\n     ///\n     /// # Panics\n     ///\n@@ -136,27 +136,27 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, false, Global)\n     }\n \n-    /// Like `with_capacity` but guarantees the buffer is zeroed.\n+    /// Like `with_capacity`, but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, true, Global)\n     }\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Reconstitutes a RawVec from a pointer, capacity, and allocator.\n+    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n+    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -167,13 +167,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Reconstitutes a RawVec from a pointer, capacity.\n+    /// Reconstitutes a `RawVec` from a pointer and capacity.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (on the system heap), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n+    /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -194,7 +194,7 @@ impl<T> RawVec<T, Global> {\n \n impl<T, A: Alloc> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// Unique::empty() if `capacity = 0` or T is zero-sized. In the former case, you must\n+    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -212,12 +212,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Returns a shared reference to the allocator backing this RawVec.\n+    /// Returns a shared reference to the allocator backing this `RawVec`.\n     pub fn alloc(&self) -> &A {\n         &self.a\n     }\n \n-    /// Returns a mutable reference to the allocator backing this RawVec.\n+    /// Returns a mutable reference to the allocator backing this `RawVec`.\n     pub fn alloc_mut(&mut self) -> &mut A {\n         &mut self.a\n     }\n@@ -247,7 +247,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -290,20 +290,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n             let (new_cap, uniq) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n-                    // isize::MAX bytes, `elem_size * self.cap <= isize::MAX` as\n+                    // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n                     // a precondition, so this can't overflow. Additionally the\n                     // alignment will never be too large as to \"not be\n                     // satisfiable\", so `Layout::from_size_align` will always\n                     // return `Some`.\n                     //\n-                    // tl;dr; we bypass runtime checks due to dynamic assertions\n+                    // TL;DR, we bypass runtime checks due to dynamic assertions\n                     // in this module, allowing us to use\n                     // `from_size_align_unchecked`.\n                     let new_cap = 2 * self.cap;\n@@ -320,8 +320,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     }\n                 }\n                 None => {\n-                    // skip to 4 because tiny Vec's are dumb; but not if that\n-                    // would cause overflow\n+                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n+                    // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n@@ -342,7 +342,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -356,15 +356,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => return false, // nothing to double\n             };\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            // Since we guarantee that we never allocate more than isize::MAX\n+            // Since we guarantee that we never allocate more than `isize::MAX`\n             // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n             // this can't overflow.\n             //\n-            // Similarly like with `double` above we can go straight to\n+            // Similarly to with `double` above, we can go straight to\n             // `Layout::from_size_align_unchecked` as we know this won't\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n@@ -409,7 +409,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n@@ -424,7 +424,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<usize, TryReserveError> {\n \n-        // Nothing we can really do about these checks :(\n+        // Nothing we can really do about these checks, sadly.\n         let required_cap = used_capacity.checked_add(needed_extra_capacity)\n             .ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n@@ -459,7 +459,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     ///\n     /// # Examples\n     ///\n@@ -538,7 +538,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n             // (regardless of whether `self.cap - used_capacity` wrapped).\n-            // Therefore we can safely call grow_in_place.\n+            // Therefore, we can safely call `grow_in_place`.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n@@ -576,14 +576,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n             return;\n         }\n \n-        // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n+        // This check is my waterloo; it's the only thing `Vec` wouldn't have to do.\n         assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n \n         if amount == 0 {\n             // We want to create a new zero-length vector within the\n-            // same allocator.  We use ptr::write to avoid an\n+            // same allocator. We use `ptr::write` to avoid an\n             // erroneous attempt to drop the contents, and we use\n-            // ptr::read to sidestep condition against destructuring\n+            // `ptr::read` to sidestep condition against destructuring\n             // types that implement Drop.\n \n             unsafe {\n@@ -600,7 +600,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 //\n                 // We also know that `self.cap` is greater than `amount`, and\n                 // consequently we don't need runtime checks for creating either\n-                // layout\n+                // layout.\n                 let old_size = elem_size * self.cap;\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n@@ -653,7 +653,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return Ok(());\n             }\n \n-            // Nothing we can really do about these checks :(\n+            // Nothing we can really do about these checks, sadly.\n             let new_cap = match strategy {\n                 Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n                 Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n@@ -692,15 +692,15 @@ impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n-    /// that may have been performed. (see description of type for details)\n+    /// that may have been performed. (See description of type for details.)\n     ///\n     /// # Undefined Behavior\n     ///\n     /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n     /// the rules around uninitialized boxed values are not finalized yet,\n     /// but until they are, it is advisable to avoid them.\n     pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `capacity()` here, actually using the real `cap` field!\n+        // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n         let output: Box<[T]> = Box::from_raw(slice);\n         mem::forget(self);\n@@ -709,7 +709,7 @@ impl<T> RawVec<T, Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n@@ -721,22 +721,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n         unsafe { self.dealloc_buffer(); }\n     }\n }\n \n-\n-\n // We need to guarantee the following:\n-// * We don't ever allocate `> isize::MAX` byte-size objects\n-// * We don't overflow `usize::MAX` and actually allocate too little\n+// * We don't ever allocate `> isize::MAX` byte-size objects.\n+// * We don't overflow `usize::MAX` and actually allocate too little.\n //\n // On 64-bit we just need to check for overflow since trying to allocate\n // `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n // an extra guard for this in case we're running on a platform which can use\n-// all 4GB in user-space. e.g., PAE or x32\n+// all 4GB in user-space, e.g., PAE or x32.\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n@@ -751,5 +749,5 @@ fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n // ensure that the code generation related to these panics is minimal as there's\n // only one location which panics rather than a bunch throughout the module.\n fn capacity_overflow() -> ! {\n-    panic!(\"capacity overflow\")\n+    panic!(\"capacity overflow\");\n }"}, {"sha": "d35b62fc1ef15ce8b18ac8bd7628b38a3c9190ee", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -5,12 +5,12 @@ fn allocator_param() {\n     use crate::alloc::AllocErr;\n \n     // Writing a test of integration between third-party\n-    // allocators and RawVec is a little tricky because the RawVec\n+    // allocators and `RawVec` is a little tricky because the `RawVec`\n     // API does not expose fallible allocation methods, so we\n     // cannot check what happens when allocator is exhausted\n     // (beyond detecting a panic).\n     //\n-    // Instead, this just checks that the RawVec methods do at\n+    // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n     // storage.\n \n@@ -44,7 +44,7 @@ fn allocator_param() {\n fn reserve_does_not_overallocate() {\n     {\n         let mut v: RawVec<u32> = RawVec::new();\n-        // First `reserve` allocates like `reserve_exact`\n+        // First, `reserve` allocates like `reserve_exact`.\n         v.reserve(0, 9);\n         assert_eq!(9, v.capacity());\n     }"}, {"sha": "439f24e95ca0d2b4b7d0100993c4623b5480513d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -567,7 +567,7 @@ impl<T: ?Sized> Rc<T> {\n     ///     let x = Rc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!"}, {"sha": "3bf22a87feaa77f5c855ba69a55b53046609229e", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -547,7 +547,7 @@ impl<T: ?Sized> Arc<T> {\n     ///     let x = Arc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!"}, {"sha": "c513658c842e51eb7bd6a2444c3d9b45d2b37022", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -685,21 +685,25 @@ impl<T> Vec<T> {\n     /// [`drain`]: #method.drain\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n-        let current_len = self.len;\n-        unsafe {\n-            let mut ptr = self.as_mut_ptr().add(self.len);\n-            // Set the final length at the end, keeping in mind that\n-            // dropping an element might panic. Works around a missed\n-            // optimization, as seen in the following issue:\n-            // https://github.com/rust-lang/rust/issues/51802\n-            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+        if mem::needs_drop::<T>() {\n+            let current_len = self.len;\n+            unsafe {\n+                let mut ptr = self.as_mut_ptr().add(self.len);\n+                // Set the final length at the end, keeping in mind that\n+                // dropping an element might panic. Works around a missed\n+                // optimization, as seen in the following issue:\n+                // https://github.com/rust-lang/rust/issues/51802\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n \n-            // drop any extra elements\n-            for _ in len..current_len {\n-                local_len.decrement_len(1);\n-                ptr = ptr.offset(-1);\n-                ptr::drop_in_place(ptr);\n+                // drop any extra elements\n+                for _ in len..current_len {\n+                    local_len.decrement_len(1);\n+                    ptr = ptr.offset(-1);\n+                    ptr::drop_in_place(ptr);\n+                }\n             }\n+        } else if len <= self.len {\n+            self.len = len;\n         }\n     }\n "}, {"sha": "0afbf4f134679b7343de55c5e8377a577cfd2323", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -153,13 +153,13 @@ impl dyn Any {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n-        // Get TypeId of the type this function is instantiated with\n+        // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get TypeId of the type in the trait object\n+        // Get `TypeId` of the type in the trait object.\n         let concrete = self.type_id();\n \n-        // Compare both TypeIds on equality\n+        // Compare both `TypeId`s on equality.\n         t == concrete\n     }\n "}, {"sha": "347e7dce6e67d242e7a68bf1a63c41917eea250b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -602,10 +602,10 @@ unsafe impl<T: ?Sized> Freeze for *mut T {}\n unsafe impl<T: ?Sized> Freeze for &T {}\n unsafe impl<T: ?Sized> Freeze for &mut T {}\n \n-/// Types which can be safely moved after being pinned.\n+/// Types that can be safely moved after being pinned.\n ///\n /// Since Rust itself has no notion of immovable types, and considers moves\n-/// (e.g. through assignment or [`mem::replace`]) to always be safe,\n+/// (e.g., through assignment or [`mem::replace`]) to always be safe,\n /// this trait cannot prevent types from moving by itself.\n ///\n /// Instead it is used to prevent moves through the type system,"}, {"sha": "13ccc9b252a775cbf82564e5b7ca1e21184d1fd1", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -1042,7 +1042,7 @@ impl<T: ?Sized> *const T {\n         (self as *const u8) == null()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *const U {\n@@ -1726,7 +1726,7 @@ impl<T: ?Sized> *mut T {\n         (self as *mut u8) == null_mut()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *mut U {"}, {"sha": "7dcd57f1f985888e9c109fd5fa8c6c3ae6305d1f", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -125,7 +125,7 @@ impl<T: ?Sized> NonNull<T> {\n         &mut *self.as_ptr()\n     }\n \n-    /// Cast to a pointer of another type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {"}, {"sha": "2c8590aa4e3fa14f3b87504c2e3fb950205e27e9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -190,7 +190,7 @@ pub enum ParamName {\n     Fresh(usize),\n \n     /// Indicates an illegal name was given and an error has been\n-    /// repored (so we should squelch other derived errors). Occurs\n+    /// reported (so we should squelch other derived errors). Occurs\n     /// when, e.g., `'_` is used in the wrong place.\n     Error,\n }"}, {"sha": "ab24b3f2f059f1b953a5b5befa982e9630090ff0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -55,7 +55,8 @@ use crate::hir::def_id::DefId;\n use crate::hir::Node;\n use crate::infer::opaque_types;\n use crate::middle::region;\n-use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n+use crate::traits::{ObligationCauseCode};\n use crate::ty::error::TypeError;\n use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n@@ -624,13 +625,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ObligationCauseCode::MatchExpressionArm {\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                 source,\n                 ref prior_arms,\n                 last_ty,\n                 discrim_hir_id,\n                 ..\n-            } => match source {\n+            }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n@@ -681,7 +682,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             },\n-            ObligationCauseCode::IfExpression { then, outer, semicolon } => {\n+            ObligationCauseCode::IfExpression(box IfExpressionCause { then, outer, semicolon }) => {\n                 err.span_label(then, \"expected because of this\");\n                 outer.map(|sp| err.span_label(sp, \"if and else have incompatible types\"));\n                 if let Some(sp) = semicolon {\n@@ -1622,13 +1623,15 @@ impl<'tcx> ObligationCause<'tcx> {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n-            MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n-                hir::MatchSource::TryDesugar => {\n-                    \"try expression alternatives have incompatible types\"\n-                }\n-                _ => \"match arms have incompatible types\",\n-            }),\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) =>\n+                Error0308(match source {\n+                    hir::MatchSource::IfLetDesugar { .. } =>\n+                        \"`if let` arms have incompatible types\",\n+                    hir::MatchSource::TryDesugar => {\n+                        \"try expression alternatives have incompatible types\"\n+                    }\n+                    _ => \"match arms have incompatible types\",\n+                }),\n             IfExpression { .. } => Error0308(\"if and else have incompatible types\"),\n             IfExpressionWithNoElse => Error0317(\"if may be missing an else clause\"),\n             MainFunctionType => Error0580(\"main function has wrong type\"),\n@@ -1656,7 +1659,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n-            MatchExpressionArm { source, .. } => match source {\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },"}, {"sha": "b8bc74141973882f992c236832f625986dfc7945", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -17,8 +17,8 @@ pub struct RawConst<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-/// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n-/// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n+/// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n+/// array length computations, enum discriminants and the pattern matching logic.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum ConstValue<'tcx> {"}, {"sha": "4494c034d51e2e087a3564bb086845ddb0f064c2", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -68,6 +68,10 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n+// `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PendingPredicateObligation<'_>, 136);\n+\n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {"}, {"sha": "d2683090add4031e4790eb118756a00d7d471c71", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -123,6 +123,10 @@ pub struct Obligation<'tcx, T> {\n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n+// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PredicateObligation<'_>, 112);\n+\n /// The reason why we incurred this obligation; used for error reporting.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n@@ -147,7 +151,8 @@ impl<'tcx> ObligationCause<'tcx> {\n             ObligationCauseCode::StartFunctionType => {\n                 tcx.sess.source_map().def_span(self.span)\n             }\n-            ObligationCauseCode::MatchExpressionArm { arm_span, .. } => arm_span,\n+            ObligationCauseCode::MatchExpressionArm(\n+                box MatchExpressionArmCause { arm_span, .. }) => arm_span,\n             _ => self.span,\n         }\n     }\n@@ -223,23 +228,13 @@ pub enum ObligationCauseCode<'tcx> {\n     ExprAssignable,\n \n     /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm {\n-        arm_span: Span,\n-        source: hir::MatchSource,\n-        prior_arms: Vec<Span>,\n-        last_ty: Ty<'tcx>,\n-        discrim_hir_id: hir::HirId,\n-    },\n+    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n \n     /// Computing common supertype in the pattern guard for the arms of a match expression\n     MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n     /// Computing common supertype in an if expression\n-    IfExpression {\n-        then: Span,\n-        outer: Option<Span>,\n-        semicolon: Option<Span>,\n-    },\n+    IfExpression(Box<IfExpressionCause>),\n \n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n@@ -269,6 +264,26 @@ pub enum ObligationCauseCode<'tcx> {\n     TrivialBound,\n }\n \n+// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ObligationCauseCode<'_>, 32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_span: Span,\n+    pub source: hir::MatchSource,\n+    pub prior_arms: Vec<Span>,\n+    pub last_ty: Ty<'tcx>,\n+    pub discrim_hir_id: hir::HirId,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct IfExpressionCause {\n+    pub then: Span,\n+    pub outer: Option<Span>,\n+    pub semicolon: Option<Span>,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the"}, {"sha": "6930c9368282b8b9cfb0b2e79c7a2449a2ec2f69", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -508,31 +508,33 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 trait_item_def_id,\n             }),\n             super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm {\n+            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                 arm_span,\n                 source,\n                 ref prior_arms,\n                 last_ty,\n                 discrim_hir_id,\n-            } => {\n+            }) => {\n                 tcx.lift(&last_ty).map(|last_ty| {\n-                    super::MatchExpressionArm {\n+                    super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                         arm_span,\n                         source,\n                         prior_arms: prior_arms.clone(),\n                         last_ty,\n                         discrim_hir_id,\n-                    }\n+                    })\n                 })\n             }\n             super::MatchExpressionArmPattern { span, ty } => {\n                 tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n             }\n-            super::IfExpression { then, outer, semicolon } => Some(super::IfExpression {\n-                then,\n-                outer,\n-                semicolon,\n-            }),\n+            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n+                Some(super::IfExpression(box super::IfExpressionCause {\n+                    then,\n+                    outer,\n+                    semicolon,\n+                }))\n+            }\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),\n             super::StartFunctionType => Some(super::StartFunctionType),"}, {"sha": "25d921b7cea4ce3e537b51a45ad231b06a8a158d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -2396,9 +2396,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(item, None);\n-        self.mk_generic_adt(def_id, ty)\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Option<Ty<'tcx>> {\n+        let def_id = self.lang_items().require(item).ok()?;\n+        Some(self.mk_generic_adt(def_id, ty))\n     }\n \n     #[inline]"}, {"sha": "2ca517dc3b1a7e8319ece659d0e02c43db65bdf7", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -229,7 +229,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 // We instead thus allocate some scratch space...\n                 let scratch_size = cast.size(bx);\n                 let scratch_align = cast.align(bx);\n-                let llscratch = bx.alloca(cast.llvm_type(bx), \"abi_cast\", scratch_align);\n+                let llscratch = bx.alloca(cast.llvm_type(bx), scratch_align);\n                 bx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value..."}, {"sha": "423a01ad1f9374a6da0a7f61b914bbe6434f4a86", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -387,23 +387,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         )\n     }\n \n-    fn alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        bx.dynamic_alloca(ty, name, align)\n+        bx.dynamic_alloca(ty, align)\n     }\n \n-    fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty,\n-                                      name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n@@ -412,16 +406,9 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn array_alloca(&mut self,\n                         ty: &'ll Type,\n                         len: &'ll Value,\n-                        name: &str,\n                         align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n-                                           name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }"}, {"sha": "5fbfe9138f2a46518bdcd2354bf215bde28c1002", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -871,7 +871,7 @@ fn codegen_msvc_try(\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = bx.type_ptr_to(bx.type_i64());\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64p, \"slot\", ptr_align);\n+        let slot = bx.alloca(i64p, ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));"}, {"sha": "8829a33992ae3d3b06a01a9a3a5bbfdf04471d33", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let llslot = match op.val {\n                     Immediate(_) | Pair(..) => {\n                         let scratch =\n-                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout, \"ret\");\n+                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout);\n                         op.val.store(&mut bx, scratch);\n                         scratch.llval\n                     }\n@@ -767,7 +767,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match (arg, op.val) {\n                 (&mir::Operand::Copy(_), Ref(_, None, _)) |\n                 (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                    let tmp = PlaceRef::alloca(&mut bx, op.layout, \"const\");\n+                    let tmp = PlaceRef::alloca(&mut bx, op.layout);\n                     op.val.store(&mut bx, tmp);\n                     op.val = Ref(tmp.llval, None, tmp.align);\n                 }\n@@ -925,7 +925,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n                     PassMode::Indirect(..) | PassMode::Cast(_) => {\n-                        let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                        let scratch = PlaceRef::alloca(bx, arg.layout);\n                         op.val.store(bx, scratch);\n                         (scratch.llval, scratch.align, true)\n                     }\n@@ -940,7 +940,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                     // have scary latent bugs around.\n \n-                    let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                    let scratch = PlaceRef::alloca(bx, arg.layout);\n                     base::memcpy_ty(bx, scratch.llval, scratch.align, llval, align,\n                                     op.layout, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n@@ -1017,7 +1017,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n                 cx.tcx().types.i32\n             ]));\n-            let slot = PlaceRef::alloca(bx, layout, \"personalityslot\");\n+            let slot = PlaceRef::alloca(bx, layout);\n             self.personality_slot = Some(slot);\n             slot\n         }\n@@ -1116,15 +1116,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         llargs.push(tmp.llval);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result, so we create a temporary `alloca` for the\n                         // result.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n@@ -1174,7 +1174,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_ref()));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n-                    let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n+                    let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);\n                     let op = bx.load_operand(place);\n@@ -1227,7 +1227,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n-                    let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n+                    let tmp = PlaceRef::alloca(bx, ret_ty.layout);\n                     tmp.storage_live(bx);\n                     bx.store_arg_ty(&ret_ty, llval, tmp);\n                     let op = bx.load_operand(tmp);"}, {"sha": "aa3971a1da81aa0f14c5df0e1c4395d73c4eeeed", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -268,11 +268,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n                 if layout.is_unsized() {\n                     let indirect_place =\n-                        PlaceRef::alloca_unsized_indirect(&mut bx, layout, &name.as_str());\n+                        PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                    bx.set_var_name(indirect_place.llval, name);\n                     // FIXME: add an appropriate debuginfo\n                     LocalRef::UnsizedPlace(indirect_place)\n                 } else {\n-                    let place = PlaceRef::alloca(&mut bx, layout, &name.as_str());\n+                    let place = PlaceRef::alloca(&mut bx, layout);\n+                    bx.set_var_name(place.llval, name);\n                     if dbg {\n                         let (scope, span) = fx.debug_loc(mir::SourceInfo {\n                             span: decl.source_info.span,\n@@ -293,14 +295,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     if layout.is_unsized() {\n-                        let indirect_place = PlaceRef::alloca_unsized_indirect(\n-                            &mut bx,\n-                            layout,\n-                            &format!(\"{:?}\", local),\n-                        );\n+                        let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                        bx.set_var_name(indirect_place.llval, format_args!(\"{:?}\", local));\n                         LocalRef::UnsizedPlace(indirect_place)\n                     } else {\n-                        LocalRef::Place(PlaceRef::alloca(&mut bx, layout, &format!(\"{:?}\", local)))\n+                        let place = PlaceRef::alloca(&mut bx, layout);\n+                        bx.set_var_name(place.llval, format_args!(\"{:?}\", local));\n+                        LocalRef::Place(place)\n                     }\n                 } else {\n                     // If this is an immediate local, we do not create an\n@@ -452,10 +453,11 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n+        // FIXME(eddyb) don't allocate a `String` unless it gets used.\n         let name = if let Some(name) = arg_decl.name {\n             name.as_str().to_string()\n         } else {\n-            format!(\"arg{}\", arg_index)\n+            format!(\"{:?}\", local)\n         };\n \n         if Some(local) == mir.spread_arg {\n@@ -470,7 +472,8 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n+            bx.set_var_name(place.llval, name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n@@ -558,11 +561,13 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             llarg_idx += 1;\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n-            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n-            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             if fx.fn_ty.c_variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n                 let va_list_did = match tcx.lang_items().va_list() {\n                     Some(did) => did,"}, {"sha": "daa25b2ea0591f572d82853cb20c7c980bf68bdd", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, \"unsized_tmp\", max_align);\n+        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, max_align);\n         bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place."}, {"sha": "a4b4cb53bb1fb883c4459e5108fefdaf47c597f5", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -71,25 +71,21 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str\n     ) -> Self {\n-        debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n-        let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align.abi);\n+        let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n         Self::new_sized(tmp, layout)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str,\n     ) -> Self {\n-        debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n         let ptr_ty = bx.cx().tcx().mk_mut_ptr(layout.ty);\n         let ptr_layout = bx.cx().layout_of(ptr_ty);\n-        Self::alloca(bx, ptr_layout, name)\n+        Self::alloca(bx, ptr_layout)\n     }\n \n     pub fn len<Cx: ConstMethods<'tcx, Value = V>>("}, {"sha": "f21836a953c223ff31c81c57394ad04faeac53cf", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"codegen_rvalue: creating ugly alloca\");\n-                        let scratch = PlaceRef::alloca(&mut bx, operand.layout, \"__unsize_temp\");\n+                        let scratch = PlaceRef::alloca(&mut bx, operand.layout);\n                         scratch.storage_live(&mut bx);\n                         operand.val.store(&mut bx, scratch);\n                         base::coerce_unsized_into(&mut bx, scratch, dest);"}, {"sha": "1886701fb3a88d95e1c9d4c274c1afe2f64039b6", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -109,13 +109,12 @@ pub trait BuilderMethods<'a, 'tcx>:\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value);\n \n-    fn alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n-    fn dynamic_alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n+    fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n+    fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn array_alloca(\n         &mut self,\n         ty: Self::Type,\n         len: Self::Value,\n-        name: &str,\n         align: Align,\n     ) -> Self::Value;\n "}, {"sha": "6c52e626ababd86917cf4566556368b03d7cb184", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -559,13 +559,20 @@ impl<O: ForestObligation> ObligationForest<O> {\n         trace\n     }\n \n-    #[inline]\n-    fn mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+    // This always-inlined function is for the hot call site.\n+    #[inline(always)]\n+    fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n         for dependent in node.parent.iter().chain(node.dependents.iter()) {\n             self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n         }\n     }\n \n+    // This never-inlined function is for the cold call site.\n+    #[inline(never)]\n+    fn uninlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n+        self.inlined_mark_neighbors_as_waiting_from(node)\n+    }\n+\n     /// Marks all nodes that depend on a pending node as `NodeState::Waiting`.\n     fn mark_as_waiting(&self) {\n         for node in &self.nodes {\n@@ -576,7 +583,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &self.nodes {\n             if node.state.get() == NodeState::Pending {\n-                self.mark_neighbors_as_waiting_from(node);\n+                // This call site is hot.\n+                self.inlined_mark_neighbors_as_waiting_from(node);\n             }\n         }\n     }\n@@ -588,7 +596,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n             NodeState::Pending | NodeState::Done => {},\n         }\n \n-        self.mark_neighbors_as_waiting_from(node);\n+        // This call site is cold.\n+        self.uninlined_mark_neighbors_as_waiting_from(node);\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts"}, {"sha": "c626dd0434d52ffff5dfa4c926a09b0d634e84da", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -37,7 +37,7 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n                                           &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n-                                          db.handler.flags.external_macro_backtrace);\n+                                          db.handler().flags.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    db.message(),"}, {"sha": "7b8902f125aee1ed3aa6bc87376c07c23b99782a", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -18,8 +18,17 @@ use log::debug;\n /// extending `HandlerFlags`, accessed via `self.handler.flags`.\n #[must_use]\n #[derive(Clone)]\n-pub struct DiagnosticBuilder<'a> {\n-    pub handler: &'a Handler,\n+pub struct DiagnosticBuilder<'a>(Box<DiagnosticBuilderInner<'a>>);\n+\n+/// This is a large type, and often used as a return value, especially within\n+/// the frequently-used `PResult` type. In theory, return value optimization\n+/// (RVO) should avoid unnecessary copying. In practice, it does not (at the\n+/// time of writing). The split between `DiagnosticBuilder` and\n+/// `DiagnosticBuilderInner` exists to avoid many `memcpy` calls.\n+#[must_use]\n+#[derive(Clone)]\n+struct DiagnosticBuilderInner<'a> {\n+    handler: &'a Handler,\n     diagnostic: Diagnostic,\n     allow_suggestions: bool,\n }\n@@ -52,7 +61,7 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.diagnostic.$n($($name),*);\n+            self.0.diagnostic.$n($($name),*);\n             self\n         }\n     };\n@@ -69,7 +78,7 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n-            self.diagnostic.$n($($name),*);\n+            self.0.diagnostic.$n($($name),*);\n             self\n         }\n     };\n@@ -79,24 +88,28 @@ impl<'a> Deref for DiagnosticBuilder<'a> {\n     type Target = Diagnostic;\n \n     fn deref(&self) -> &Diagnostic {\n-        &self.diagnostic\n+        &self.0.diagnostic\n     }\n }\n \n impl<'a> DerefMut for DiagnosticBuilder<'a> {\n     fn deref_mut(&mut self) -> &mut Diagnostic {\n-        &mut self.diagnostic\n+        &mut self.0.diagnostic\n     }\n }\n \n impl<'a> DiagnosticBuilder<'a> {\n+    pub fn handler(&self) -> &'a Handler{\n+        self.0.handler\n+    }\n+\n     /// Emit the diagnostic.\n     pub fn emit(&mut self) {\n         if self.cancelled() {\n             return;\n         }\n \n-        self.handler.emit_db(&self);\n+        self.0.handler.emit_db(&self);\n         self.cancel();\n     }\n \n@@ -115,8 +128,8 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// Buffers the diagnostic for later emission, unless handler\n     /// has disabled such buffering.\n     pub fn buffer(mut self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n-        if self.handler.flags.dont_buffer_diagnostics ||\n-            self.handler.flags.treat_err_as_bug.is_some()\n+        if self.0.handler.flags.dont_buffer_diagnostics ||\n+            self.0.handler.flags.treat_err_as_bug.is_some()\n         {\n             self.emit();\n             return;\n@@ -126,7 +139,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         // implements `Drop`.\n         let diagnostic;\n         unsafe {\n-            diagnostic = std::ptr::read(&self.diagnostic);\n+            diagnostic = std::ptr::read(&self.0.diagnostic);\n             std::mem::forget(self);\n         };\n         // Logging here is useful to help track down where in logs an error was\n@@ -144,7 +157,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         span: Option<S>,\n     ) -> &mut Self {\n         let span = span.map(|s| s.into()).unwrap_or_else(|| MultiSpan::new());\n-        self.diagnostic.sub(level, message, span, None);\n+        self.0.diagnostic.sub(level, message, span, None);\n         self\n     }\n \n@@ -160,7 +173,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// locally in whichever way makes the most sense.\n     pub fn delay_as_bug(&mut self) {\n         self.level = Level::Bug;\n-        self.handler.delay_as_bug(self.diagnostic.clone());\n+        self.0.handler.delay_as_bug(self.0.diagnostic.clone());\n         self.cancel();\n     }\n \n@@ -171,7 +184,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n     pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n-        self.diagnostic.span_label(span, label);\n+        self.0.diagnostic.span_label(span, label);\n         self\n     }\n \n@@ -208,10 +221,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.multipart_suggestion(\n+        self.0.diagnostic.multipart_suggestion(\n             msg,\n             suggestion,\n             applicability,\n@@ -225,29 +238,28 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.tool_only_multipart_suggestion(\n+        self.0.diagnostic.tool_only_multipart_suggestion(\n             msg,\n             suggestion,\n             applicability,\n         );\n         self\n     }\n \n-\n     pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n         msg: &str,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion(\n+        self.0.diagnostic.span_suggestion(\n             sp,\n             msg,\n             suggestion,\n@@ -263,10 +275,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestions(\n+        self.0.diagnostic.span_suggestions(\n             sp,\n             msg,\n             suggestions,\n@@ -282,10 +294,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion_short(\n+        self.0.diagnostic.span_suggestion_short(\n             sp,\n             msg,\n             suggestion,\n@@ -301,10 +313,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.span_suggestion_hidden(\n+        self.0.diagnostic.span_suggestion_hidden(\n             sp,\n             msg,\n             suggestion,\n@@ -320,10 +332,10 @@ impl<'a> DiagnosticBuilder<'a> {\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        if !self.allow_suggestions {\n+        if !self.0.allow_suggestions {\n             return self\n         }\n-        self.diagnostic.tool_only_span_suggestion(\n+        self.0.diagnostic.tool_only_span_suggestion(\n             sp,\n             msg,\n             suggestion,\n@@ -336,7 +348,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n \n     pub fn allow_suggestions(&mut self, allow: bool) -> &mut Self {\n-        self.allow_suggestions = allow;\n+        self.0.allow_suggestions = allow;\n         self\n     }\n \n@@ -359,19 +371,18 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n-    pub fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic)\n-                         -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder {\n+    pub fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder(Box::new(DiagnosticBuilderInner {\n             handler,\n             diagnostic,\n             allow_suggestions: true,\n-        }\n+        }))\n     }\n }\n \n impl<'a> Debug for DiagnosticBuilder<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.diagnostic.fmt(f)\n+        self.0.diagnostic.fmt(f)\n     }\n }\n \n@@ -381,7 +392,7 @@ impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !panicking() && !self.cancelled() {\n             let mut db = DiagnosticBuilder::new(\n-                self.handler,\n+                self.0.handler,\n                 Level::Bug,\n                 \"the following error was constructed but not emitted\",\n             );"}, {"sha": "66608361c8d44863119ca08761cc6958074cab07", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -385,7 +385,7 @@ impl Emitter for EmitterWriter {\n                                           &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n-                                          db.handler.flags.external_macro_backtrace);\n+                                          db.handler().flags.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    &db.styled_message(),"}, {"sha": "57ddaa4eff0386c9c7ecbbb958c1f4b9d11cbc1a", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -589,7 +589,7 @@ pub fn const_eval_provider<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    // see comment in const_eval_provider for what we're doing here\n+    // see comment in const_eval_raw_provider for what we're doing here\n     if key.param_env.reveal == Reveal::All {\n         let mut key = key.clone();\n         key.param_env.reveal = Reveal::UserFacing;"}, {"sha": "4aaa5e8ee259af8da1fd94e4eba4f73e313093fe", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -1229,7 +1229,13 @@ fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n                 ty::RawPtr(..) => {\n                     // `#[structural_match]` ignores substructure of\n                     // `*const _`/`*mut _`, so skip super_visit_with\n-\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::FnDef(..) | ty::FnPtr(..) => {\n+                    // types of formals and return in `fn(_) -> _` are also irrelevant\n+                    //\n                     // (But still tell caller to continue search.)\n                     return false;\n                 }"}, {"sha": "308a3d8ebc2cfd4a88fa291d5d2978f81845c7f5", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -2,7 +2,8 @@ use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n use crate::check::coercion::CoerceMany;\n use rustc::hir::{self, ExprKind};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::traits::{ObligationCause, ObligationCauseCode};\n+use rustc::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n+use rustc::traits::{ObligationCauseCode};\n use rustc::ty::Ty;\n use syntax_pos::Span;\n \n@@ -146,13 +147,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n                     0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n-                    _ => (expr.span, ObligationCauseCode::MatchExpressionArm {\n-                        arm_span,\n-                        source: match_src,\n-                        prior_arms: other_arms.clone(),\n-                        last_ty: prior_arm_ty.unwrap(),\n-                        discrim_hir_id: discrim.hir_id,\n-                    }),\n+                    _ => (expr.span,\n+                          ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                            arm_span,\n+                            source: match_src,\n+                            prior_arms: other_arms.clone(),\n+                            last_ty: prior_arm_ty.unwrap(),\n+                            discrim_hir_id: discrim.hir_id,\n+                          })\n+                         ),\n                 };\n                 let cause = self.cause(span, code);\n                 coercion.coerce(self, &cause, &arm.body, arm_ty);\n@@ -345,11 +348,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Finally construct the cause:\n-        self.cause(error_sp, ObligationCauseCode::IfExpression {\n+        self.cause(error_sp, ObligationCauseCode::IfExpression(box IfExpressionCause {\n             then: then_sp,\n             outer: outer_sp,\n             semicolon: remove_semicolon,\n-        })\n+        }))\n     }\n \n     fn demand_discriminant_type("}, {"sha": "d626bff15002049ae9e7433effcc254cd9174dbf", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -529,11 +529,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ); // recreated from (*) above\n \n                 // Check that E' = S'.\n-                let cause = &self.misc(hir_ty.span);\n+                let cause = self.misc(hir_ty.span);\n                 let InferOk {\n                     value: (),\n                     obligations,\n-                } = self.at(cause, self.param_env)\n+                } = self.at(&cause, self.param_env)\n                     .eq(*expected_ty, supplied_ty)?;\n                 all_obligations.extend(obligations);\n \n@@ -549,7 +549,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 all_obligations.push(\n                     Obligation::new(\n-                        cause.clone(),\n+                        cause,\n                         self.param_env,\n                         ty::Predicate::TypeOutlives(\n                             ty::Binder::dummy("}, {"sha": "51adf501b4db8510f59e1bad1ef45c4c999c2873", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -309,7 +309,7 @@ fn compare_predicate_entailment<'tcx>(\n \n             let cause = ObligationCause {\n                 span: impl_err_span,\n-                ..cause.clone()\n+                ..cause\n             };\n \n             let mut diag = struct_span_err!(tcx.sess,"}, {"sha": "56bd903040ab43548007350392a1dc2bb500e47d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -813,18 +813,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         error: MethodError<'tcx>\n     ) {\n         let rcvr = &args[0];\n-        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n-            if let Ok(pick) = self.lookup_probe(\n-                span,\n-                segment.ident,\n-                new_rcvr_t,\n-                rcvr,\n-                probe::ProbeScope::AllTraits,\n-            ) {\n-                err.span_label(\n-                    pick.item.ident.span,\n-                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                );\n+        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, rcvr_t, lang_item| {\n+            if let Some(new_rcvr_t) = self.tcx.mk_lang_item(rcvr_t, lang_item) {\n+                if let Ok(pick) = self.lookup_probe(\n+                    span,\n+                    segment.ident,\n+                    new_rcvr_t,\n+                    rcvr,\n+                    probe::ProbeScope::AllTraits,\n+                ) {\n+                    err.span_label(\n+                        pick.item.ident.span,\n+                        &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                    );\n+                }\n             }\n         };\n \n@@ -840,17 +842,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Try alternative arbitrary self types that could fulfill this call.\n                 // FIXME: probe for all types that *could* be arbitrary self-types, not\n                 // just this whitelist.\n-                let box_rcvr_t = self.tcx.mk_box(rcvr_t);\n-                try_alt_rcvr(&mut err, box_rcvr_t);\n-                let pin_rcvr_t = self.tcx.mk_lang_item(\n-                    rcvr_t,\n-                    lang_items::PinTypeLangItem,\n-                );\n-                try_alt_rcvr(&mut err, pin_rcvr_t);\n-                let arc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Arc);\n-                try_alt_rcvr(&mut err, arc_rcvr_t);\n-                let rc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Rc);\n-                try_alt_rcvr(&mut err, rc_rcvr_t);\n+                try_alt_rcvr(&mut err, rcvr_t, lang_items::OwnedBoxLangItem);\n+                try_alt_rcvr(&mut err, rcvr_t, lang_items::PinTypeLangItem);\n+                try_alt_rcvr(&mut err, rcvr_t, lang_items::Arc);\n+                try_alt_rcvr(&mut err, rcvr_t, lang_items::Rc);\n             }\n             err.emit();\n         }"}, {"sha": "b89893692698c2ca0b4d4f6ce23a5ec42c900966", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -290,7 +290,7 @@ impl Error for VarError {\n ///\n /// Note that while concurrent access to environment variables is safe in Rust,\n /// some platforms only expose inherently unsafe non-threadsafe APIs for\n-/// inspecting the environment. As a result extra care needs to be taken when\n+/// inspecting the environment. As a result, extra care needs to be taken when\n /// auditing calls to unsafe external FFI functions to ensure that any external\n /// environment accesses are properly synchronized with accesses in Rust.\n ///"}, {"sha": "4a1bb75d588c9c008c4b670124ffd87f2a895cd6", "filename": "src/libstd/error.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -197,10 +197,10 @@ pub trait Error: Debug + Display {\n     #[stable(feature = \"error_source\", since = \"1.30.0\")]\n     fn source(&self) -> Option<&(dyn Error + 'static)> { None }\n \n-    /// Gets the `TypeId` of `self`\n+    /// Gets the `TypeId` of `self`.\n     #[doc(hidden)]\n     #[unstable(feature = \"error_type_id\",\n-               reason = \"this is memory unsafe to override in user code\",\n+               reason = \"this is memory-unsafe to override in user code\",\n                issue = \"60784\")]\n     fn type_id(&self, _: private::Internal) -> TypeId where Self: 'static {\n         TypeId::of::<Self>()\n@@ -616,19 +616,19 @@ impl Error for char::ParseCharError {\n     }\n }\n \n-// copied from any.rs\n+// Copied from `any.rs`.\n impl dyn Error + 'static {\n     /// Returns `true` if the boxed type is the same as `T`\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn is<T: Error + 'static>(&self) -> bool {\n-        // Get TypeId of the type this function is instantiated with\n+        // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get TypeId of the type in the trait object\n+        // Get `TypeId` of the type in the trait object.\n         let boxed = self.type_id(private::Internal);\n \n-        // Compare both TypeIds on equality\n+        // Compare both `TypeId`s on equality.\n         t == boxed\n     }\n \n@@ -662,21 +662,21 @@ impl dyn Error + 'static {\n }\n \n impl dyn Error + 'static + Send {\n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn is<T: Error + 'static>(&self) -> bool {\n         <dyn Error + 'static>::is::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n         <dyn Error + 'static>::downcast_ref::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n@@ -685,21 +685,21 @@ impl dyn Error + 'static + Send {\n }\n \n impl dyn Error + 'static + Send + Sync {\n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn is<T: Error + 'static>(&self) -> bool {\n         <dyn Error + 'static>::is::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n         <dyn Error + 'static>::downcast_ref::<T>(self)\n     }\n \n-    /// Forwards to the method defined on the type `Any`.\n+    /// Forwards to the method defined on the type `dyn Error`.\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n@@ -710,7 +710,7 @@ impl dyn Error + 'static + Send + Sync {\n impl dyn Error {\n     #[inline]\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n-    /// Attempt to downcast the box to a concrete type.\n+    /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n         if self.is::<T>() {\n             unsafe {\n@@ -878,12 +878,12 @@ impl<'a> Iterator for ErrorIter<'a> {\n impl dyn Error + Send {\n     #[inline]\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n-    /// Attempt to downcast the box to a concrete type.\n+    /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>)\n                                         -> Result<Box<T>, Box<dyn Error + Send>> {\n         let err: Box<dyn Error> = self;\n         <dyn Error>::downcast(err).map_err(|s| unsafe {\n-            // reapply the Send marker\n+            // Reapply the `Send` marker.\n             transmute::<Box<dyn Error>, Box<dyn Error + Send>>(s)\n         })\n     }\n@@ -892,12 +892,12 @@ impl dyn Error + Send {\n impl dyn Error + Send + Sync {\n     #[inline]\n     #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n-    /// Attempt to downcast the box to a concrete type.\n+    /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>)\n                                         -> Result<Box<T>, Box<Self>> {\n         let err: Box<dyn Error> = self;\n         <dyn Error>::downcast(err).map_err(|s| unsafe {\n-            // reapply the Send+Sync marker\n+            // Reapply the `Send + Sync` marker.\n             transmute::<Box<dyn Error>, Box<dyn Error + Send + Sync>>(s)\n         })\n     }"}, {"sha": "d7f4cc5d1fdaafc15d572f05c67ce262bd97e771", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -615,7 +615,7 @@ impl CString {\n }\n \n // Turns this `CString` into an empty string to prevent\n-// memory unsafe code from working by accident. Inline\n+// memory-unsafe code from working by accident. Inline\n // to prevent LLVM from optimizing it away in debug builds.\n #[stable(feature = \"cstring_drop\", since = \"1.13.0\")]\n impl Drop for CString {"}, {"sha": "c798ee0e2209afca52808d5897e709db59d17bee", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -201,9 +201,9 @@ pub struct StdinLock<'a> {\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n /// is synchronized via a mutex. If you need more explicit control over\n-/// locking, see the [`lock() method`][lock].\n+/// locking, see the [`Stdin::lock`] method.\n ///\n-/// [lock]: struct.Stdin.html#method.lock\n+/// [`Stdin::lock`]: struct.Stdin.html#method.lock\n ///\n /// ### Note: Windows Portability Consideration\n /// When operating in a console, the Windows implementation of this stream does not support\n@@ -425,9 +425,9 @@ pub struct StdoutLock<'a> {\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n /// is synchronized via a mutex. If you need more explicit control over\n-/// locking, see the [Stdout::lock] method.\n+/// locking, see the [`Stdout::lock`] method.\n ///\n-/// [Stdout::lock]: struct.Stdout.html#method.lock\n+/// [`Stdout::lock`]: struct.Stdout.html#method.lock\n ///\n /// ### Note: Windows Portability Consideration\n /// When operating in a console, the Windows implementation of this stream does not support"}, {"sha": "c50025ab7d1deb47a2a9a48a8dc02952cd4146a3", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -1595,7 +1595,7 @@ pub fn id() -> u32 {\n \n /// A trait for implementing arbitrary return types in the `main` function.\n ///\n-/// The c-main function only supports to return integers as return type.\n+/// The C-main function only supports to return integers as return type.\n /// So, every type implementing the `Termination` trait has to be converted\n /// to an integer.\n ///"}, {"sha": "1fc88fbde742fe327365492236b625b745d1a846", "filename": "src/libstd/sys/vxworks/process/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -1,5 +1,6 @@\n pub use self::process_common::{Command, ExitStatus, ExitCode, Stdio, StdioPipes};\n pub use self::process_inner::Process;\n+pub use crate::ffi::OsString as EnvKey;\n \n mod process_common;\n #[path = \"process_vxworks.rs\"]"}, {"sha": "13648abd1e4476b48a28e748dd49b43fd698d700", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -12,8 +12,6 @@ use crate::collections::BTreeMap;\n \n use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n \n-pub use crate::ffi::OsString as EnvKey;\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "c22880db2bf032cae9cdf6a9beb9d8540f3afa98", "filename": "src/libstd/sys/vxworks/rand.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -14,17 +14,24 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n mod imp {\n     use libc;\n     use crate::io;\n-\n-    extern \"C\" {\n-        fn randBytes (randBuf: *mut libc::c_uchar,\n-                      numOfBytes: libc::c_int) -> libc::c_int;\n-    }\n+    use core::sync::atomic::{AtomicBool, Ordering::Relaxed};\n \n     pub fn fill_bytes(v: &mut [u8]) {\n+        static RNG_INIT: AtomicBool = AtomicBool::new(false);\n+        while !RNG_INIT.load(Relaxed) {\n+            let ret = unsafe { libc::randSecure() };\n+            if ret < 0 {\n+                panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n+            } else if ret > 0 {\n+                RNG_INIT.store(true, Relaxed);\n+                break;\n+            }\n+            unsafe { libc::usleep(10) };\n+        }\n         let ret = unsafe {\n-            randBytes(v.as_mut_ptr() as *mut libc::c_uchar, v.len() as libc::c_int)\n+            libc::randABytes(v.as_mut_ptr() as *mut libc::c_uchar, v.len() as libc::c_int)\n         };\n-        if ret == -1 {\n+        if ret < 0 {\n             panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n         }\n     }"}, {"sha": "3bf2b8be1fe8e32d68a43f7301a0dcae418773be", "filename": "src/libstd/time.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -59,6 +59,30 @@ pub use core::time::Duration;\n ///    println!(\"{}\", now.elapsed().as_secs());\n /// }\n /// ```\n+///\n+/// # Underlying System calls\n+/// Currently, the following system calls are being used to get the current time using `now()`:\n+///\n+/// |  Platform |               System call                                            |\n+/// |:---------:|:--------------------------------------------------------------------:|\n+/// | Cloud ABI | [clock_time_get (Monotonic Clock)]                                   |\n+/// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n+/// | UNIX      | [clock_time_get (Monotonic Clock)]                                   |\n+/// | Darwin    | [mach_absolute_time]                                                 |\n+/// | VXWorks   | [clock_gettime (Monotonic Clock)]                                    |\n+/// | WASI      | [__wasi_clock_time_get (Monotonic Clock)]                            |\n+/// | Windows   | [QueryPerformanceCounter]                                            |\n+///\n+/// [QueryPerformanceCounter]: https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter\n+/// [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time\n+/// [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode\n+/// [__wasi_clock_time_get (Monotonic Clock)]: https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-api.md#clock_time_get\n+/// [clock_gettime (Monotonic Clock)]: https://linux.die.net/man/3/clock_gettime\n+/// [mach_absolute_time]: https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/services/services.html\n+/// [clock_time_get (Monotonic Clock)]: https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt\n+///\n+/// **Disclaimer:** These system calls might change over time.\n+///\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct Instant(time::Instant);\n@@ -114,6 +138,28 @@ pub struct Instant(time::Instant);\n ///    }\n /// }\n /// ```\n+///\n+/// # Underlying System calls\n+/// Currently, the following system calls are being used to get the current time using `now()`:\n+///\n+/// |  Platform |               System call                                            |\n+/// |:---------:|:--------------------------------------------------------------------:|\n+/// | Cloud ABI | [clock_time_get (Realtime Clock)]                                    |\n+/// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n+/// | UNIX      | [clock_gettime (Realtime Clock)]                                     |\n+/// | DARWIN    | [gettimeofday]                                                       |\n+/// | VXWorks   | [clock_gettime (Realtime Clock)]                                     |\n+/// | WASI      | [__wasi_clock_time_get (Realtime Clock)]                             |\n+/// | Windows   | [GetSystemTimeAsFileTime]                                            |\n+///\n+/// [clock_time_get (Realtime Clock)]: https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt\n+/// [gettimeofday]: http://man7.org/linux/man-pages/man2/gettimeofday.2.html\n+/// [clock_gettime (Realtime Clock)]: https://linux.die.net/man/3/clock_gettime\n+/// [__wasi_clock_time_get (Realtime Clock)]: https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-api.md#clock_time_get\n+/// [GetSystemTimeAsFileTime]: https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime\n+///\n+/// **Disclaimer:** These system calls might change over time.\n+///\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct SystemTime(time::SystemTime);"}, {"sha": "2441a027f9940b7e2f6faf53521753f7833ac491", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -13,6 +13,8 @@ use crate::symbol::Symbol;\n \n use errors::{Applicability, FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+#[cfg(target_arch = \"x86_64\")]\n+use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::{Lrc, Lock, Once};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use syntax_pos::edition::Edition;\n@@ -38,6 +40,11 @@ crate mod unescape_error_reporting;\n \n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n+// `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n+// (See also the comment on `DiagnosticBuilderInner`.)\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PResult<'_, bool>, 16);\n+\n /// Collected spans during parsing for places where a certain feature was\n /// used and should be feature gated accordingly in `check_crate`.\n #[derive(Default)]"}, {"sha": "ded310d0aebb13543cbc9e1da126c3aed7324a67", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "f67487c83ba23d2dc83b8ac5b7c90b552e0545e9", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -49,27 +49,27 @@\n #![crate_type = \"lib\"]\n \n pub mod tests {\n-    // CHECK: @f1(i32 inreg %arg0, i32 inreg %arg1, i32 %arg2)\n+    // CHECK: @f1(i32 inreg %_1, i32 inreg %_2, i32 %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f1(_: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f2(i32* inreg %arg0, i32* inreg %arg1, i32* %arg2)\n+    // CHECK: @f2(i32* inreg %_1, i32* inreg %_2, i32* %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f2(_: *const i32, _: *const i32, _: *const i32) {}\n \n-    // CHECK: @f3(float %arg0, i32 inreg %arg1, i32 inreg %arg2, i32 %arg3)\n+    // CHECK: @f3(float %_1, i32 inreg %_2, i32 inreg %_3, i32 %_4)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f3(_: f32, _: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f4(i32 inreg %arg0, float %arg1, i32 inreg %arg2, i32 %arg3)\n+    // CHECK: @f4(i32 inreg %_1, float %_2, i32 inreg %_3, i32 %_4)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f4(_: i32, _: f32, _: i32, _: i32) {}\n \n-    // CHECK: @f5(i64 %arg0, i32 %arg1)\n+    // CHECK: @f5(i64 %_1, i32 %_2)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f5(_: i64, _: i32) {}\n \n-    // CHECK: @f6(i1 inreg zeroext %arg0, i32 inreg %arg1, i32 %arg2)\n+    // CHECK: @f6(i1 inreg zeroext %_1, i32 inreg %_2, i32 %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f6(_: bool, _: i32, _: i32) {}\n }"}, {"sha": "7e1791cd4f296f5c3ace1b66e5736c6ceaa5f9d4", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -18,48 +18,48 @@ pub fn boolean(x: bool) -> bool {\n   x\n }\n \n-// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn readonly_borrow(_: &i32) {\n }\n \n-// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n pub fn static_borrow(_: &'static i32) {\n }\n \n-// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // borrow with named lifetime may be captured\n #[no_mangle]\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n+// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %_1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n+// CHECK: @mutable_unsafe_borrow(i16* align 2 dereferenceable(2) %_1)\n // ... unless this is a mutable borrow, those never alias\n #[no_mangle]\n pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n }\n \n-// CHECK: @mutable_borrow(i32* align 4 dereferenceable(4) %arg0)\n+// CHECK: @mutable_borrow(i32* align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n-// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %arg0)\n+// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %_1)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }\n \n-// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %arg0)\n+// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn borrowed_struct(_: &S) {\n@@ -80,36 +80,36 @@ pub fn struct_return() -> S {\n }\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice([0 x i8]* nonnull align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @mutable_slice([0 x i8]* nonnull align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %_1.0, [[USIZE]] %_1.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull align 1 %arg0.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %arg0.1)\n+// CHECK: @trait_borrow({}* nonnull align 1 %_1.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {"}, {"sha": "05888c0e733ad10bbcb52a7a40a238d9e29c319c", "filename": "src/test/codegen/personality_lifetimes.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -20,12 +20,13 @@ pub fn test() {\n     let _s = S;\n     // Check that the personality slot alloca gets a lifetime start in each cleanup block, not just\n     // in the first one.\n+    // CHECK: [[SLOT:%[0-9]+]] = alloca { i8*, i32 }\n     // CHECK-LABEL: cleanup:\n-    // CHECK: bitcast{{.*}}personalityslot\n-    // CHECK-NEXT: call void @llvm.lifetime.start\n+    // CHECK: [[BITCAST:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n+    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST]])\n     // CHECK-LABEL: cleanup1:\n-    // CHECK: bitcast{{.*}}personalityslot\n-    // CHECK-NEXT: call void @llvm.lifetime.start\n+    // CHECK: [[BITCAST1:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n+    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST1]])\n     might_unwind();\n     let _t = S;\n     might_unwind();"}, {"sha": "15f99fd0c22a023094251b5f4511dfb0fb07d149", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "87f29f6047c6a0af8932ad2887a7d343268fa007", "filename": "src/test/codegen/repeat-trusted-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -6,7 +6,7 @@\n \n use std::iter;\n \n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "e705d5ce3cd72d87acb2e385ba44f9beb3ffe048", "filename": "src/test/codegen/repr-transparent.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -14,36 +14,36 @@ pub struct Zst2(());\n #[repr(transparent)]\n pub struct F32(f32);\n \n-// CHECK: define float @test_F32(float %arg0)\n+// CHECK: define float @test_F32(float %_1)\n #[no_mangle]\n pub extern fn test_F32(_: F32) -> F32 { loop {} }\n \n #[repr(transparent)]\n pub struct Ptr(*mut u8);\n \n-// CHECK: define i8* @test_Ptr(i8* %arg0)\n+// CHECK: define i8* @test_Ptr(i8* %_1)\n #[no_mangle]\n pub extern fn test_Ptr(_: Ptr) -> Ptr { loop {} }\n \n #[repr(transparent)]\n pub struct WithZst(u64, Zst1);\n \n-// CHECK: define i64 @test_WithZst(i64 %arg0)\n+// CHECK: define i64 @test_WithZst(i64 %_1)\n #[no_mangle]\n pub extern fn test_WithZst(_: WithZst) -> WithZst { loop {} }\n \n #[repr(transparent)]\n pub struct WithZeroSizedArray(*const f32, [i8; 0]);\n \n // Apparently we use i32* when newtype-unwrapping f32 pointers. Whatever.\n-// CHECK: define i32* @test_WithZeroSizedArray(i32* %arg0)\n+// CHECK: define i32* @test_WithZeroSizedArray(i32* %_1)\n #[no_mangle]\n pub extern fn test_WithZeroSizedArray(_: WithZeroSizedArray) -> WithZeroSizedArray { loop {} }\n \n #[repr(transparent)]\n pub struct Generic<T>(T);\n \n-// CHECK: define double @test_Generic(double %arg0)\n+// CHECK: define double @test_Generic(double %_1)\n #[no_mangle]\n pub extern fn test_Generic(_: Generic<f64>) -> Generic<f64> { loop {} }\n \n@@ -53,14 +53,14 @@ pub struct GenericPlusZst<T>(T, Zst2);\n #[repr(u8)]\n pub enum Bool { True, False, FileNotFound }\n \n-// CHECK: define{{( zeroext)?}} i8 @test_Gpz(i8{{( zeroext)?}} %arg0)\n+// CHECK: define{{( zeroext)?}} i8 @test_Gpz(i8{{( zeroext)?}} %_1)\n #[no_mangle]\n pub extern fn test_Gpz(_: GenericPlusZst<Bool>) -> GenericPlusZst<Bool> { loop {} }\n \n #[repr(transparent)]\n pub struct LifetimePhantom<'a, T: 'a>(*const T, PhantomData<&'a T>);\n \n-// CHECK: define i16* @test_LifetimePhantom(i16* %arg0)\n+// CHECK: define i16* @test_LifetimePhantom(i16* %_1)\n #[no_mangle]\n pub extern fn test_LifetimePhantom(_: LifetimePhantom<i16>) -> LifetimePhantom<i16> { loop {} }\n \n@@ -70,28 +70,28 @@ pub struct UnitPhantom<T, U> { val: T, unit: PhantomData<U> }\n \n pub struct Px;\n \n-// CHECK: define float @test_UnitPhantom(float %arg0)\n+// CHECK: define float @test_UnitPhantom(float %_1)\n #[no_mangle]\n pub extern fn test_UnitPhantom(_: UnitPhantom<f32, Px>) -> UnitPhantom<f32, Px> { loop {} }\n \n #[repr(transparent)]\n pub struct TwoZsts(Zst1, i8, Zst2);\n \n-// CHECK: define{{( signext)?}} i8 @test_TwoZsts(i8{{( signext)?}} %arg0)\n+// CHECK: define{{( signext)?}} i8 @test_TwoZsts(i8{{( signext)?}} %_1)\n #[no_mangle]\n pub extern fn test_TwoZsts(_: TwoZsts) -> TwoZsts { loop {} }\n \n #[repr(transparent)]\n pub struct Nested1(Zst2, Generic<f64>);\n \n-// CHECK: define double @test_Nested1(double %arg0)\n+// CHECK: define double @test_Nested1(double %_1)\n #[no_mangle]\n pub extern fn test_Nested1(_: Nested1) -> Nested1 { loop {} }\n \n #[repr(transparent)]\n pub struct Nested2(Nested1, Zst1);\n \n-// CHECK: define double @test_Nested2(double %arg0)\n+// CHECK: define double @test_Nested2(double %_1)\n #[no_mangle]\n pub extern fn test_Nested2(_: Nested2) -> Nested2 { loop {} }\n \n@@ -101,7 +101,7 @@ struct f32x4(f32, f32, f32, f32);\n #[repr(transparent)]\n pub struct Vector(f32x4);\n \n-// CHECK: define <4 x float> @test_Vector(<4 x float> %arg0)\n+// CHECK: define <4 x float> @test_Vector(<4 x float> %_1)\n #[no_mangle]\n pub extern fn test_Vector(_: Vector) -> Vector { loop {} }\n \n@@ -111,7 +111,7 @@ impl<T: ?Sized> Mirror for T { type It = Self; }\n #[repr(transparent)]\n pub struct StructWithProjection(<f32 as Mirror>::It);\n \n-// CHECK: define float @test_Projection(float %arg0)\n+// CHECK: define float @test_Projection(float %_1)\n #[no_mangle]\n pub extern fn test_Projection(_: StructWithProjection) -> StructWithProjection { loop {} }\n \n@@ -120,7 +120,7 @@ pub enum EnumF32 {\n     Variant(F32)\n }\n \n-// CHECK: define float @test_EnumF32(float %arg0)\n+// CHECK: define float @test_EnumF32(float %_1)\n #[no_mangle]\n pub extern fn test_EnumF32(_: EnumF32) -> EnumF32 { loop {} }\n \n@@ -129,7 +129,7 @@ pub enum EnumF32WithZsts {\n     Variant(Zst1, F32, Zst2)\n }\n \n-// CHECK: define float @test_EnumF32WithZsts(float %arg0)\n+// CHECK: define float @test_EnumF32WithZsts(float %_1)\n #[no_mangle]\n pub extern fn test_EnumF32WithZsts(_: EnumF32WithZsts) -> EnumF32WithZsts { loop {} }\n \n@@ -138,7 +138,7 @@ pub union UnionF32 {\n     field: F32,\n }\n \n-// CHECK: define float @test_UnionF32(float %arg0)\n+// CHECK: define float @test_UnionF32(float %_1)\n #[no_mangle]\n pub extern fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n \n@@ -149,7 +149,7 @@ pub union UnionF32WithZsts {\n     zst2: Zst2,\n }\n \n-// CHECK: define float @test_UnionF32WithZsts(float %arg0)\n+// CHECK: define float @test_UnionF32WithZsts(float %_1)\n #[no_mangle]\n pub extern fn test_UnionF32WithZsts(_: UnionF32WithZsts) -> UnionF32WithZsts { loop {} }\n "}, {"sha": "d91ee7f816dede3620fc035ff1d2bbbe9c56e2cd", "filename": "src/test/codegen/scalar-pair-bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -20,24 +20,24 @@ pub fn pair_i32_bool(pair: (i32, bool)) -> (i32, bool) {\n     pair\n }\n \n-// CHECK: define { i8, i8 } @pair_and_or(i1 zeroext %arg0.0, i1 zeroext %arg0.1)\n+// CHECK: define { i8, i8 } @pair_and_or(i1 zeroext %_1.0, i1 zeroext %_1.1)\n #[no_mangle]\n pub fn pair_and_or((a, b): (bool, bool)) -> (bool, bool) {\n     // Make sure it can operate directly on the unpacked args\n-    // CHECK: and i1 %arg0.0, %arg0.1\n-    // CHECK: or i1 %arg0.0, %arg0.1\n+    // CHECK: and i1 %_1.0, %_1.1\n+    // CHECK: or i1 %_1.0, %_1.1\n     (a && b, a || b)\n }\n \n-// CHECK: define void @pair_branches(i1 zeroext %arg0.0, i1 zeroext %arg0.1)\n+// CHECK: define void @pair_branches(i1 zeroext %_1.0, i1 zeroext %_1.1)\n #[no_mangle]\n pub fn pair_branches((a, b): (bool, bool)) {\n     // Make sure it can branch directly on the unpacked bool args\n-    // CHECK: br i1 %arg0.0\n+    // CHECK: br i1 %_1.0\n     if a {\n         println!(\"Hello!\");\n     }\n-    // CHECK: br i1 %arg0.1\n+    // CHECK: br i1 %_1.1\n     if b {\n         println!(\"Goodbye!\");\n     }"}, {"sha": "7339df17b057a230004e2eb3fbc703fc534ce668", "filename": "src/test/codegen/union-abi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -16,38 +16,38 @@ pub struct i64x4(i64, i64, i64, i64);\n #[derive(Copy, Clone)]\n pub union UnionI64x4{ a:(), b: i64x4 }\n \n-// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4(_: UnionI64x4) { loop {} }\n \n pub union UnionI64x4_{ a: i64x4, b: (), c:i64x4, d: Unhab, e: ((),()), f: UnionI64x4 }\n \n-// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4_(_: UnionI64x4_) { loop {} }\n \n pub union UnionI64x4I64{ a: i64x4, b: i64 }\n \n-// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4I64(_: UnionI64x4I64) { loop {} }\n \n pub union UnionI64x4Tuple{ a: i64x4, b: (i64, i64, i64, i64) }\n \n-// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4Tuple(_: UnionI64x4Tuple) { loop {} }\n \n \n pub union UnionF32{a:f32}\n \n-// CHECK: define float @test_UnionF32(float %arg0)\n+// CHECK: define float @test_UnionF32(float %_1)\n #[no_mangle]\n pub fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n \n pub union UnionF32F32{a:f32, b:f32}\n \n-// CHECK: define float @test_UnionF32F32(float %arg0)\n+// CHECK: define float @test_UnionF32F32(float %_1)\n #[no_mangle]\n pub fn test_UnionF32F32(_: UnionF32F32) -> UnionF32F32 { loop {} }\n \n@@ -58,13 +58,13 @@ pub union UnionF32U32{a:f32, b:u32}\n pub fn test_UnionF32U32(_: UnionF32U32) -> UnionF32U32 { loop {} }\n \n pub union UnionU128{a:u128}\n-// CHECK: define i128 @test_UnionU128(i128 %arg0)\n+// CHECK: define i128 @test_UnionU128(i128 %_1)\n #[no_mangle]\n pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n \n #[repr(C)]\n pub union CUnionU128{a:u128}\n-// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %arg0)\n+// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %_1)\n #[no_mangle]\n pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n "}, {"sha": "0bc66e06e67319b04bb7a49b25627716e5ce7c72", "filename": "src/test/ui/issues/issue-64430.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Fissues%2Fissue-64430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Fissues%2Fissue-64430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64430.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags:-C panic=abort\n+\n+#![no_std]\n+pub struct Foo;\n+\n+fn main() {\n+    Foo.bar()\n+    //~^ ERROR E0599\n+}\n+\n+#[panic_handler]\n+fn panic(_info: &core::panic::PanicInfo) -> ! {\n+    loop{}\n+}"}, {"sha": "f1b2de8d8b36f21525c215c166aacb68e840251c", "filename": "src/test/ui/issues/issue-64430.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Fissues%2Fissue-64430.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Fissues%2Fissue-64430.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64430.stderr?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `bar` found for type `Foo` in the current scope\n+  --> $DIR/issue-64430.rs:7:9\n+   |\n+LL | pub struct Foo;\n+   | --------------- method `bar` not found for this\n+...\n+LL |     Foo.bar()\n+   |         ^^^ method not found in `Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "5b378fb2a5928ec8787ec87008ef029901e3f004", "filename": "src/test/ui/rfc1445/fn-ptr-is-structurally-matchable.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffn-ptr-is-structurally-matchable.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -0,0 +1,135 @@\n+// run-pass\n+\n+// This file checks that fn ptrs are considered structurally matchable.\n+// See also rust-lang/rust#63479.\n+\n+fn main() {\n+    let mut count = 0;\n+\n+    // A type which is not structurally matchable:\n+    struct NotSM;\n+\n+    // And one that is:\n+    #[derive(PartialEq, Eq)]\n+    struct SM;\n+\n+    fn trivial() {}\n+\n+    fn sm_to(_: SM) {}\n+    fn not_sm_to(_: NotSM) {}\n+    fn to_sm() -> SM { SM }\n+    fn to_not_sm() -> NotSM { NotSM }\n+\n+    // To recreate the scenario of interest in #63479, we need to add\n+    // a ref-level-of-indirection so that we descend into the type.\n+\n+    fn r_sm_to(_: &SM) {}\n+    fn r_not_sm_to(_: &NotSM) {}\n+    fn r_to_r_sm(_: &()) -> &SM { &SM }\n+    fn r_to_r_not_sm(_: &()) -> &NotSM { &NotSM }\n+\n+    #[derive(PartialEq, Eq)]\n+    struct Wrap<T>(T);\n+\n+    // In the code below, we put the match input into a local so that\n+    // we can assign it an explicit type that is an fn ptr instead of\n+    // a singleton type of the fn itself that the type inference would\n+    // otherwise assign.\n+\n+    // Check that fn() is #[structural_match]\n+    const CFN1: Wrap<fn()> = Wrap(trivial);\n+    let input: Wrap<fn()> = Wrap(trivial);\n+    match Wrap(input) {\n+        Wrap(CFN1) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] when T is too.\n+    const CFN2: Wrap<fn(SM)> = Wrap(sm_to);\n+    let input: Wrap<fn(SM)> = Wrap(sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN2) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] when T is too.\n+    const CFN3: Wrap<fn() -> SM> = Wrap(to_sm);\n+    let input: Wrap<fn() -> SM> = Wrap(to_sm);\n+    match Wrap(input) {\n+        Wrap(CFN3) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] even if T is not.\n+    const CFN4: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n+    let input: Wrap<fn(NotSM)> = Wrap(not_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN4) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] even if T is not.\n+    const CFN5: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n+    let input: Wrap<fn() -> NotSM> = Wrap(to_not_sm);\n+    match Wrap(input) {\n+        Wrap(CFN5) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(&T) is #[structural_match] when T is too.\n+    const CFN6: Wrap<fn(&SM)> = Wrap(r_sm_to);\n+    let input: Wrap<fn(&SM)> = Wrap(r_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN6) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> &T is #[structural_match] when T is too.\n+    const CFN7: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n+    let input: Wrap<fn(&()) -> &SM> = Wrap(r_to_r_sm);\n+    match Wrap(input) {\n+        Wrap(CFN7) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn(T) is #[structural_match] even if T is not.\n+    const CFN8: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n+    let input: Wrap<fn(&NotSM)> = Wrap(r_not_sm_to);\n+    match Wrap(input) {\n+        Wrap(CFN8) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that fn() -> T is #[structural_match] even if T is not.\n+    const CFN9: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n+    let input: Wrap<fn(&()) -> &NotSM> = Wrap(r_to_r_not_sm);\n+    match Wrap(input) {\n+        Wrap(CFN9) => count += 1,\n+        Wrap(_) => {}\n+    };\n+\n+    // Check that a type which has fn ptrs is `#[structural_match]`.\n+    #[derive(PartialEq, Eq)]\n+    struct Foo {\n+        alpha: fn(NotSM),\n+        beta: fn() -> NotSM,\n+        gamma: fn(SM),\n+        delta: fn() -> SM,\n+    }\n+\n+    const CFOO: Foo = Foo {\n+        alpha: not_sm_to,\n+        beta: to_not_sm,\n+        gamma: sm_to,\n+        delta: to_sm,\n+    };\n+\n+    let input = Foo { alpha: not_sm_to, beta: to_not_sm, gamma: sm_to, delta: to_sm };\n+    match input {\n+        CFOO => count += 1,\n+        Foo { .. } => {}\n+    };\n+\n+    // Final count must be 10 now if all\n+    assert_eq!(count, 10);\n+}"}, {"sha": "b3c91cec580bfc777b7b41c5827a5699c549a903", "filename": "src/test/ui/rfc1445/issue-63479-match-fnptr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+\n+// The actual regression test from #63479. (Including this because my\n+// first draft at fn-ptr-is-structurally-matchable.rs failed to actually\n+// cover the case this hit; I've since expanded it accordingly, but the\n+// experience left me wary of leaving this regression test out.)\n+\n+#[derive(Eq)]\n+struct A {\n+  a: i64\n+}\n+\n+impl PartialEq for A {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.a.eq(&other.a)\n+    }\n+}\n+\n+type Fn = fn(&[A]);\n+\n+fn my_fn(_args: &[A]) {\n+  println!(\"hello world\");\n+}\n+\n+const TEST: Fn = my_fn;\n+\n+struct B(Fn);\n+\n+fn main() {\n+  let s = B(my_fn);\n+  match s {\n+    B(TEST) => println!(\"matched\"),\n+    _ => panic!(\"didn't match\")\n+  };\n+}"}, {"sha": "592b3f14c85aff7bf8309f75d44071385aafae54", "filename": "src/tools/error_index_generator/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftools%2Ferror_index_generator%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fbuild.rs?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -35,7 +35,7 @@ fn register_all() -> Vec<(&'static str, Option<&'static str>)> {\n         ($($ecode:ident: $message:expr,)* ; $($code:ident,)*) => (\n             $(\n                 {long_codes.extend([\n-                    (stringify!($ecode), Some(stringify!($message))),\n+                    (stringify!($ecode), Some($message)),\n                 ].iter());}\n             )*\n             $("}, {"sha": "d068e1cf307b81f144d306cc460334a0549c8c70", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca3766e2e58f462a20922e42c821a37eaf0e13db/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=ca3766e2e58f462a20922e42c821a37eaf0e13db", "patch": "@@ -14,12 +14,6 @@ path = \"lib.rs\"\n # For documentation about what this is and why in the world these dependencies\n # are appearing, see `README.md`.\n \n-[build-dependencies]\n-# Currently Cargo/RLS depend on `failure` which depends on `synstructure` which\n-# enables this feature. Clippy, however, does not depend on anything that\n-# enables this feature. Enable it unconditionally.\n-syn = { version = \"0.15\", features = ['extra-traits'] }\n-\n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\"\n features = [\n@@ -65,14 +59,10 @@ features = [\n [dependencies]\n curl-sys = { version = \"0.4.13\", features = [\"http2\", \"libnghttp2-sys\"], optional = true }\n crossbeam-utils = { version = \"0.6.5\", features = [\"nightly\"] }\n-parking_lot = { version = \"0.7\", features = ['nightly'] }\n-rand = { version = \"0.6.1\", features = [\"i128_support\"] }\n serde = { version = \"1.0.82\", features = ['derive'] }\n serde_json = { version = \"1.0.31\", features = [\"raw_value\"] }\n smallvec = { version = \"0.6\", features = ['union', 'may_dangle'] }\n-scopeguard = { version = \"0.3.3\", features = [\"use_std\", \"default\"] }\n byteorder = { version = \"1.2.7\", features = [\"i128\"] }\n-syn = { version = \"0.15.35\", features = [\"extra-traits\", \"full\"] }\n \n \n [target.'cfg(not(windows))'.dependencies]"}]}