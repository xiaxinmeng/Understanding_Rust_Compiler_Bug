{"sha": "d61d359d5ef5e3192611297805dbfbb52c55de8f", "node_id": "C_kwDOAAsO6NoAKGQ2MWQzNTlkNWVmNWUzMTkyNjExMjk3ODA1ZGJmYmI1MmM1NWRlOGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T13:13:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T13:13:35Z"}, "message": "Auto merge of #2753 - RalfJung:rustup, r=RalfJung\n\nRustup\n\nPulls in https://github.com/rust-lang/rust/pull/104658", "tree": {"sha": "374888d2e6ddfc2006e9eb8dadc2f0d6214562e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/374888d2e6ddfc2006e9eb8dadc2f0d6214562e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d61d359d5ef5e3192611297805dbfbb52c55de8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d61d359d5ef5e3192611297805dbfbb52c55de8f", "html_url": "https://github.com/rust-lang/rust/commit/d61d359d5ef5e3192611297805dbfbb52c55de8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d61d359d5ef5e3192611297805dbfbb52c55de8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87a202e6f23896f867457c0a26b31b367fa1c0e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/87a202e6f23896f867457c0a26b31b367fa1c0e0", "html_url": "https://github.com/rust-lang/rust/commit/87a202e6f23896f867457c0a26b31b367fa1c0e0"}, {"sha": "236ae262bc80dabf67669a2763fda5034982b9b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/236ae262bc80dabf67669a2763fda5034982b9b9", "html_url": "https://github.com/rust-lang/rust/commit/236ae262bc80dabf67669a2763fda5034982b9b9"}], "stats": {"total": 17450, "additions": 11180, "deletions": 6270}, "files": [{"sha": "da47b08c7df55bc54fa99408563defa00803d51e", "filename": "Cargo.lock", "status": "modified", "additions": 434, "deletions": 105, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -30,7 +30,7 @@ version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"43bb833f0bf979d8475d38fbf09ed3b8a55e1885fe93ad3f93239fc6a4f17b98\"\n dependencies = [\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"once_cell\",\n  \"version_check\",\n ]\n@@ -50,7 +50,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rand_xorshift\",\n ]\n \n@@ -197,6 +197,18 @@ dependencies = [\n  \"rustc-demangle\",\n ]\n \n+[[package]]\n+name = \"base16ct\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"349a06037c7bf932dd7e7d1f653678b2038b9ad46a74102f1fc7bd7872678cce\"\n+\n+[[package]]\n+name = \"base64ct\"\n+version = \"1.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b645a089122eccb6111b4f81cbc1a49f5900ac4666bb93ac027feaecf15607bf\"\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -259,6 +271,10 @@ dependencies = [\n  \"toml\",\n ]\n \n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"bump-stage0\"\n version = \"0.1.0\"\n@@ -271,6 +287,12 @@ dependencies = [\n  \"toml\",\n ]\n \n+[[package]]\n+name = \"bumpalo\"\n+version = \"3.11.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"572f695136211188308f16ad2ca5c851a712c464060ae6974944458eb83880ba\"\n+\n [[package]]\n name = \"bytecount\"\n version = \"0.6.2\"\n@@ -341,6 +363,7 @@ dependencies = [\n  \"opener\",\n  \"openssl\",\n  \"os_info\",\n+ \"pasetors\",\n  \"pathdiff\",\n  \"percent-encoding\",\n  \"pretty_env_logger\",\n@@ -358,6 +381,7 @@ dependencies = [\n  \"tar\",\n  \"tempfile\",\n  \"termcolor\",\n+ \"time 0.3.17\",\n  \"toml_edit\",\n  \"unicode-width\",\n  \"unicode-xid\",\n@@ -443,10 +467,13 @@ dependencies = [\n  \"glob\",\n  \"itertools\",\n  \"lazy_static\",\n+ \"pasetors\",\n+ \"serde\",\n  \"serde_json\",\n  \"snapbox\",\n  \"tar\",\n  \"termcolor\",\n+ \"time 0.3.17\",\n  \"toml_edit\",\n  \"url\",\n  \"winapi\",\n@@ -585,7 +612,7 @@ dependencies = [\n  \"num-integer\",\n  \"num-traits\",\n  \"serde\",\n- \"time\",\n+ \"time 0.1.43\",\n  \"winapi\",\n ]\n \n@@ -597,7 +624,7 @@ checksum = \"23b71c3ce99b7611011217b366d923f1d0a7e07a92bb2dbf1e84508c673ca3bd\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n- \"clap_derive\",\n+ \"clap_derive 3.2.18\",\n  \"clap_lex 0.2.2\",\n  \"indexmap\",\n  \"once_cell\",\n@@ -614,7 +641,9 @@ checksum = \"6bf8832993da70a4c6d13c581f4463c2bdda27b9bf1c5498dc4365543abe6d6f\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n+ \"clap_derive 4.0.13\",\n  \"clap_lex 0.3.0\",\n+ \"once_cell\",\n  \"strsim\",\n  \"termcolor\",\n ]\n@@ -641,6 +670,19 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"clap_derive\"\n+version = \"4.0.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c42f169caba89a7d512b5418b09864543eeb4d497416c917d7137863bd2076ad\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"clap_lex\"\n version = \"0.2.2\"\n@@ -884,6 +926,12 @@ version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"82a90734b3d5dcf656e7624cca6bce9c3a90ee11f900e80141a7427ccfb3d317\"\n \n+[[package]]\n+name = \"const-oid\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cec318a675afcb6a1ea1d4340e2d377e56e47c266f28043ceccbf4412ddfdd3b\"\n+\n [[package]]\n name = \"content_inspector\"\n version = \"0.2.4\"\n@@ -903,7 +951,7 @@ checksum = \"6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rand_xorshift\",\n ]\n \n@@ -938,7 +986,7 @@ dependencies = [\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.35.0\"\n+version = \"0.35.1\"\n dependencies = [\n  \"anyhow\",\n  \"curl\",\n@@ -1000,13 +1048,26 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"crypto-bigint\"\n+version = \"0.4.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ef2b4b23cddf68b89b8f8069890e8c270d54e2d5fe1b143820234805e4cb17ef\"\n+dependencies = [\n+ \"generic-array\",\n+ \"rand_core\",\n+ \"subtle\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"crypto-common\"\n-version = \"0.1.2\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a4600d695eb3f6ce1cd44e6e291adceb2cc3ab12f20a33777ecd0bf6eba34e06\"\n+checksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\n dependencies = [\n  \"generic-array\",\n+ \"typenum\",\n ]\n \n [[package]]\n@@ -1031,6 +1092,12 @@ dependencies = [\n  \"quote\",\n ]\n \n+[[package]]\n+name = \"ct-codecs\"\n+version = \"1.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3b7eb4404b8195a9abb6356f4ac07d8ba267045c8d6d220ac4dc992e6cc75df\"\n+\n [[package]]\n name = \"ctor\"\n version = \"0.1.26\"\n@@ -1087,6 +1154,17 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"der\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f1a467a65c5e759bce6e65eaf91cc29f466cdc57cb65777bd646872a8a1fd4de\"\n+dependencies = [\n+ \"const-oid\",\n+ \"pem-rfc7468\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"derive-new\"\n version = \"0.5.8\"\n@@ -1125,12 +1203,13 @@ checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \n [[package]]\n name = \"digest\"\n-version = \"0.10.2\"\n+version = \"0.10.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8cb780dce4f9a8f5c087362b3a4595936b2019e7c8b30f2c3e9a7e94e6ae9837\"\n+checksum = \"8168378f4e5023e7218c89c891c0fd8ecdb5e5e4f18cb78f38cf245dd021e76f\"\n dependencies = [\n  \"block-buffer\",\n  \"crypto-common\",\n+ \"subtle\",\n ]\n \n [[package]]\n@@ -1217,6 +1296,27 @@ version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"453440c271cf5577fd2a40e4942540cb7d0d2f85e27c8d07dd0023c925a67541\"\n \n+[[package]]\n+name = \"ecdsa\"\n+version = \"0.14.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"413301934810f597c1d19ca71c8710e99a3f1ba28a0d2ebc01551a2daeea3c5c\"\n+dependencies = [\n+ \"der\",\n+ \"elliptic-curve\",\n+ \"rfc6979\",\n+ \"signature\",\n+]\n+\n+[[package]]\n+name = \"ed25519-compact\"\n+version = \"2.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6a3d382e8464107391c8706b4c14b087808ecb909f6c15c34114bc42e53a9e4c\"\n+dependencies = [\n+ \"getrandom\",\n+]\n+\n [[package]]\n name = \"either\"\n version = \"1.6.0\"\n@@ -1235,6 +1335,28 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"elliptic-curve\"\n+version = \"0.12.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e7bb888ab5300a19b8e5bceef25ac745ad065f3c9f7efc6de1b91958110891d3\"\n+dependencies = [\n+ \"base16ct\",\n+ \"crypto-bigint\",\n+ \"der\",\n+ \"digest\",\n+ \"ff\",\n+ \"generic-array\",\n+ \"group\",\n+ \"hkdf\",\n+ \"pem-rfc7468\",\n+ \"pkcs8\",\n+ \"rand_core\",\n+ \"sec1\",\n+ \"subtle\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"ena\"\n version = \"0.14.0\"\n@@ -1354,6 +1476,22 @@ dependencies = [\n  \"instant\",\n ]\n \n+[[package]]\n+name = \"ff\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d013fc25338cc558c5c2cfbad646908fb23591e2404481826742b651c9af7160\"\n+dependencies = [\n+ \"rand_core\",\n+ \"subtle\",\n+]\n+\n+[[package]]\n+name = \"fiat-crypto\"\n+version = \"0.1.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a214f5bb88731d436478f3ae1f8a277b62124089ba9fb67f4f93fb100ef73c90\"\n+\n [[package]]\n name = \"filetime\"\n version = \"0.2.14\"\n@@ -1611,26 +1749,17 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n-[[package]]\n-name = \"getrandom\"\n-version = \"0.1.16\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce\"\n-dependencies = [\n- \"cfg-if\",\n- \"libc\",\n- \"wasi 0.9.0+wasi-snapshot-preview1\",\n-]\n-\n [[package]]\n name = \"getrandom\"\n version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n dependencies = [\n  \"cfg-if\",\n+ \"js-sys\",\n  \"libc\",\n- \"wasi 0.11.0+wasi-snapshot-preview1\",\n+ \"wasi\",\n+ \"wasm-bindgen\",\n ]\n \n [[package]]\n@@ -1693,6 +1822,17 @@ dependencies = [\n  \"regex\",\n ]\n \n+[[package]]\n+name = \"group\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5dfbfb3a6cfbd390d5c9564ab283a0349b9b9fcd46a706c1eb10e0db70bfbac7\"\n+dependencies = [\n+ \"ff\",\n+ \"rand_core\",\n+ \"subtle\",\n+]\n+\n [[package]]\n name = \"gsgdt\"\n version = \"0.1.2\"\n@@ -1782,6 +1922,24 @@ version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"644f9158b2f133fd50f5fb3242878846d9eb792e445c893805ff0e3824006e35\"\n \n+[[package]]\n+name = \"hkdf\"\n+version = \"0.12.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"791a029f6b9fc27657f6f188ec6e5e43f6911f6f878e0dc5501396e09809d437\"\n+dependencies = [\n+ \"hmac\",\n+]\n+\n+[[package]]\n+name = \"hmac\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e\"\n+dependencies = [\n+ \"digest\",\n+]\n+\n [[package]]\n name = \"home\"\n version = \"0.5.3\"\n@@ -1946,7 +2104,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"af1955a75fa080c677d3972822ec4bad316169ab1cfc6c257a942c2265dbe5fe\"\n dependencies = [\n  \"bitmaps\",\n- \"rand_core 0.6.2\",\n+ \"rand_core\",\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n@@ -2079,6 +2237,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"js-sys\"\n+version = \"0.3.60\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"49409df3e3bf0856b916e2ceaca09ee28e6871cf7d9ce97a692cacfdb2a25a47\"\n+dependencies = [\n+ \"wasm-bindgen\",\n+]\n+\n [[package]]\n name = \"jsondocck\"\n version = \"0.1.0\"\n@@ -2097,8 +2264,10 @@ name = \"jsondoclint\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n+ \"clap 4.0.15\",\n  \"fs-err\",\n  \"rustdoc-json-types\",\n+ \"serde\",\n  \"serde_json\",\n ]\n \n@@ -2480,14 +2649,14 @@ version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n  \"env_logger 0.9.0\",\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"lazy_static\",\n  \"libc\",\n  \"libffi\",\n  \"libloading\",\n  \"log\",\n  \"measureme\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n@@ -2647,6 +2816,17 @@ dependencies = [\n  \"num-traits\",\n ]\n \n+[[package]]\n+name = \"orion\"\n+version = \"0.17.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f2baf7fd2e326e3895c681176788dd227fcd8369350e53c570592d8563fecbb6\"\n+dependencies = [\n+ \"fiat-crypto\",\n+ \"subtle\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"os_info\"\n version = \"3.5.0\"\n@@ -2679,6 +2859,17 @@ version = \"3.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n \n+[[package]]\n+name = \"p384\"\n+version = \"0.11.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dfc8c5bf642dde52bb9e87c0ecd8ca5a76faac2eeed98dedb7c717997e1080aa\"\n+dependencies = [\n+ \"ecdsa\",\n+ \"elliptic-curve\",\n+ \"sha2\",\n+]\n+\n [[package]]\n name = \"packed_simd_2\"\n version = \"0.3.8\"\n@@ -2760,12 +2951,42 @@ dependencies = [\n  \"windows-sys\",\n ]\n \n+[[package]]\n+name = \"pasetors\"\n+version = \"0.6.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ed20c4c21d893414f42e0cbfebe8a8036b5ae9b0264611fb6504e395eda6ceec\"\n+dependencies = [\n+ \"ct-codecs\",\n+ \"ed25519-compact\",\n+ \"getrandom\",\n+ \"orion\",\n+ \"p384\",\n+ \"rand_core\",\n+ \"regex\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"sha2\",\n+ \"subtle\",\n+ \"time 0.3.17\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"pathdiff\"\n version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd\"\n \n+[[package]]\n+name = \"pem-rfc7468\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24d159833a9105500e0398934e205e0773f0b27529557134ecfc51c27646adac\"\n+dependencies = [\n+ \"base64ct\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"2.1.0\"\n@@ -2861,7 +3082,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5d5285893bb5eb82e6aaf5d59ee909a06a16737a8970984dd7746ba9283498d6\"\n dependencies = [\n  \"phf_shared\",\n- \"rand 0.8.5\",\n+ \"rand\",\n ]\n \n [[package]]\n@@ -2885,6 +3106,16 @@ version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184\"\n \n+[[package]]\n+name = \"pkcs8\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9eca2c590a5f85da82668fa685c09ce2888b9430e83299debf1f34b65fd4a4ba\"\n+dependencies = [\n+ \"der\",\n+ \"spki\",\n+]\n+\n [[package]]\n name = \"pkg-config\"\n version = \"0.3.25\"\n@@ -3056,38 +3287,15 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n-[[package]]\n-name = \"rand\"\n-version = \"0.7.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n-dependencies = [\n- \"getrandom 0.1.16\",\n- \"libc\",\n- \"rand_chacha 0.2.2\",\n- \"rand_core 0.5.1\",\n- \"rand_hc\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\n dependencies = [\n  \"libc\",\n- \"rand_chacha 0.3.0\",\n- \"rand_core 0.6.2\",\n-]\n-\n-[[package]]\n-name = \"rand_chacha\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402\"\n-dependencies = [\n- \"ppv-lite86\",\n- \"rand_core 0.5.1\",\n+ \"rand_chacha\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -3097,43 +3305,25 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e12735cf05c9e10bf21534da50a147b924d555dc7a547c42e6bb2d5b6017ae0d\"\n dependencies = [\n  \"ppv-lite86\",\n- \"rand_core 0.6.2\",\n+ \"rand_core\",\n ]\n \n [[package]]\n name = \"rand_core\"\n-version = \"0.5.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n-dependencies = [\n- \"getrandom 0.1.16\",\n-]\n-\n-[[package]]\n-name = \"rand_core\"\n-version = \"0.6.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34cf66eb183df1c5876e2dcf6b13d57340741e8dc255b48e40a26de954d06ae7\"\n-dependencies = [\n- \"getrandom 0.2.8\",\n-]\n-\n-[[package]]\n-name = \"rand_hc\"\n-version = \"0.2.0\"\n+version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n+checksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\n dependencies = [\n- \"rand_core 0.5.1\",\n+ \"getrandom\",\n ]\n \n [[package]]\n name = \"rand_xorshift\"\n-version = \"0.2.0\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77d416b86801d23dde1aa643023b775c3a462efc0ed96443add11546cdf1dca8\"\n+checksum = \"d25bf25ec5ae4a3f1b92f929810509a2f53d7dca2f50b794ff57e3face536c8f\"\n dependencies = [\n- \"rand_core 0.5.1\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -3142,7 +3332,7 @@ version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6f97cdb2a36ed4183de61b2f824cc45c9f1037f28afe0a322e9fff4c108b5aaa\"\n dependencies = [\n- \"rand_core 0.6.2\",\n+ \"rand_core\",\n ]\n \n [[package]]\n@@ -3184,7 +3374,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n dependencies = [\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n  \"redox_syscall\",\n ]\n \n@@ -3248,6 +3438,17 @@ dependencies = [\n  \"walkdir\",\n ]\n \n+[[package]]\n+name = \"rfc6979\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7743f17af12fa0b03b803ba12cd6a8d9483a587e89c69445e3909655c0b9fabb\"\n+dependencies = [\n+ \"crypto-bigint\",\n+ \"hmac\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"rls\"\n version = \"2.0.0\"\n@@ -3387,9 +3588,10 @@ version = \"1.0.0\"\n dependencies = [\n  \"bstr 0.2.17\",\n  \"clap 3.2.20\",\n+ \"getrandom\",\n  \"libc\",\n  \"libz-sys\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"regex\",\n  \"serde_json\",\n  \"syn\",\n@@ -3402,7 +3604,7 @@ name = \"rustc_abi\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"rand_xoshiro\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n@@ -3636,6 +3838,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"serde_json\",\n  \"smallvec\",\n  \"snap\",\n@@ -3770,6 +3973,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"serde\",\n  \"serde_json\",\n  \"termcolor\",\n@@ -3906,7 +4110,7 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4226,6 +4430,8 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"serde\",\n+ \"serde_json\",\n  \"smallvec\",\n  \"tracing\",\n ]\n@@ -4774,6 +4980,20 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n+[[package]]\n+name = \"sec1\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3be24c1842290c45df0a7bf069e0c268a747ad05a192f2fd7dcfdbc1cba40928\"\n+dependencies = [\n+ \"base16ct\",\n+ \"der\",\n+ \"generic-array\",\n+ \"pkcs8\",\n+ \"subtle\",\n+ \"zeroize\",\n+]\n+\n [[package]]\n name = \"security-framework\"\n version = \"2.0.0\"\n@@ -4805,18 +5025,18 @@ checksum = \"1ef965a420fe14fdac7dd018862966a4c14094f900e1650bbc71ddd7d580c8af\"\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.12\"\n+version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2333e6df6d6598f2b1974829f853c2b4c5f4a6e503c10af918081aa6f8564e1\"\n+checksum = \"e25dfac463d778e353db5be2449d1cce89bd6fd23c9f1ea21310ce6e5a1b29c4\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.147\"\n+version = \"1.0.152\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d193d69bae983fc11a79df82342761dfbf28a99fc8d203dca4c3c1b590948965\"\n+checksum = \"bb7d1f0d3021d347a83e556fc4683dea2ea09d87bccdf88ff5c12545d89d5efb\"\n dependencies = [\n  \"serde_derive\",\n ]\n@@ -4833,9 +5053,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.147\"\n+version = \"1.0.152\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f1d362ca8fc9c3e3a7484440752472d68a6caa98f1ab81d99b5dfe517cec852\"\n+checksum = \"af487d118eecd09402d70a5d72551860e788df87b464af30e5ea6a38c75c541e\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4853,9 +5073,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.85\"\n+version = \"1.0.91\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n+checksum = \"877c235533714907a8c2464236f5c4b2a17262ef1bd71f38f35ea592c8da6883\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -4876,9 +5096,9 @@ dependencies = [\n \n [[package]]\n name = \"sha2\"\n-version = \"0.10.1\"\n+version = \"0.10.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99c3bd8169c58782adad9290a9af5939994036b76187f7b4f0e6de91dbbfc0ec\"\n+checksum = \"82e6b795fe2e3b1e845bafcb27aa35405c4d47cdfc92af5fc8d3002f76cebdc0\"\n dependencies = [\n  \"cfg-if\",\n  \"cpufeatures\",\n@@ -4906,6 +5126,16 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"42a568c8f2cd051a4d283bd6eb0343ac214c1b0f1ac19f93e1175b2dee38c73d\"\n \n+[[package]]\n+name = \"signature\"\n+version = \"1.6.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"74233d3b3b2f6d4b006dc19dee745e73e2a6bfb6f93607cd3b02bd5b00797d7c\"\n+dependencies = [\n+ \"digest\",\n+ \"rand_core\",\n+]\n+\n [[package]]\n name = \"similar\"\n version = \"2.1.0\"\n@@ -5009,6 +5239,16 @@ dependencies = [\n  \"uuid\",\n ]\n \n+[[package]]\n+name = \"spki\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"67cf02bbac7a337dc36e4f5a693db6c21e7863f45070f7064577eb4367a3212b\"\n+dependencies = [\n+ \"base64ct\",\n+ \"der\",\n+]\n+\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.2.0\"\n@@ -5053,11 +5293,12 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.7.3\",\n+ \"rand\",\n+ \"rand_xorshift\",\n  \"rustc-demangle\",\n  \"std_detect\",\n  \"unwind\",\n- \"wasi 0.11.0+wasi-snapshot-preview1\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -5131,11 +5372,17 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"subtle\"\n+version = \"2.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601\"\n+\n [[package]]\n name = \"syn\"\n-version = \"1.0.102\"\n+version = \"1.0.107\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3fcd952facd492f9be3ef0d0b7032a6e442ee9b361d4acc2b1d0c4aaa5f613a1\"\n+checksum = \"1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5309,6 +5556,7 @@ dependencies = [\n  \"lazy_static\",\n  \"miropt-test-tools\",\n  \"regex\",\n+ \"semver\",\n  \"termcolor\",\n  \"walkdir\",\n ]\n@@ -5327,6 +5575,33 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"time\"\n+version = \"0.3.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a561bf4617eebd33bca6434b988f39ed798e527f51a1e797d0ee4f61c0a38376\"\n+dependencies = [\n+ \"itoa\",\n+ \"serde\",\n+ \"time-core\",\n+ \"time-macros\",\n+]\n+\n+[[package]]\n+name = \"time-core\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2e153e1f1acaef8acc537e68b44906d2db6436e2b35ac2c6b42640fff91f00fd\"\n+\n+[[package]]\n+name = \"time-macros\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d967f99f534ca7e495c575c62638eebc2898a8c84c119b89e250477bc4ba16b2\"\n+dependencies = [\n+ \"time-core\",\n+]\n+\n [[package]]\n name = \"tinystr\"\n version = \"0.7.0\"\n@@ -5495,7 +5770,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675\"\n dependencies = [\n  \"cfg-if\",\n- \"rand 0.8.5\",\n+ \"rand\",\n  \"static_assertions\",\n ]\n \n@@ -5510,9 +5785,9 @@ dependencies = [\n \n [[package]]\n name = \"typenum\"\n-version = \"1.12.0\"\n+version = \"1.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"373c8a200f9e67a0c95e62a4f52fbf80c23b4381c05a17845531982fa99e6b33\"\n+checksum = \"497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba\"\n \n [[package]]\n name = \"ucd-parse\"\n@@ -5778,7 +6053,7 @@ version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7\"\n dependencies = [\n- \"getrandom 0.2.8\",\n+ \"getrandom\",\n ]\n \n [[package]]\n@@ -5819,12 +6094,6 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n-[[package]]\n-name = \"wasi\"\n-version = \"0.9.0+wasi-snapshot-preview1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n-\n [[package]]\n name = \"wasi\"\n version = \"0.11.0+wasi-snapshot-preview1\"\n@@ -5836,6 +6105,60 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"wasm-bindgen\"\n+version = \"0.2.83\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"eaf9f5aceeec8be17c128b2e93e031fb8a4d469bb9c4ae2d7dc1888b26887268\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"wasm-bindgen-macro\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-backend\"\n+version = \"0.2.83\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4c8ffb332579b0557b52d268b91feab8df3615f265d5270fec2a8c95b17c1142\"\n+dependencies = [\n+ \"bumpalo\",\n+ \"log\",\n+ \"once_cell\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro\"\n+version = \"0.2.83\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"052be0f94026e6cbc75cdefc9bae13fd6052cdcaf532fa6c45e7ae33a1e6c810\"\n+dependencies = [\n+ \"quote\",\n+ \"wasm-bindgen-macro-support\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro-support\"\n+version = \"0.2.83\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07bc0c051dc5f23e307b13285f9d75df86bfdf816c5721e573dec1f9b8aa193c\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-backend\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-shared\"\n+version = \"0.2.83\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1c38c045535d93ec4f0b4defec448e4291638ee608530863b1e2ba115d4fff7f\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.3.9\"\n@@ -6028,6 +6351,12 @@ dependencies = [\n  \"synstructure\",\n ]\n \n+[[package]]\n+name = \"zeroize\"\n+version = \"1.5.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c394b5bd0c6f669e7275d9c20aa90ae064cb22e75a1cad54e1b34088034b149f\"\n+\n [[package]]\n name = \"zerovec\"\n version = \"0.9.0\""}, {"sha": "ce08d4edb567d05f1e108655c0fd56588913f00d", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -4,6 +4,7 @@ members = [\n   \"library/std\",\n   \"library/test\",\n   \"src/rustdoc-json-types\",\n+  \"src/tools/build_helper\",\n   \"src/tools/cargotest\",\n   \"src/tools/clippy\",\n   \"src/tools/clippy/clippy_dev\","}, {"sha": "e656fb3740bbdf74a9301cd233a65208980886d8", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2170,10 +2170,10 @@ impl fmt::Display for InlineAsmTemplatePiece {\n                 Ok(())\n             }\n             Self::Placeholder { operand_idx, modifier: Some(modifier), .. } => {\n-                write!(f, \"{{{}:{}}}\", operand_idx, modifier)\n+                write!(f, \"{{{operand_idx}:{modifier}}}\")\n             }\n             Self::Placeholder { operand_idx, modifier: None, .. } => {\n-                write!(f, \"{{{}}}\", operand_idx)\n+                write!(f, \"{{{operand_idx}}}\")\n             }\n         }\n     }\n@@ -2185,7 +2185,7 @@ impl InlineAsmTemplatePiece {\n         use fmt::Write;\n         let mut out = String::new();\n         for p in s.iter() {\n-            let _ = write!(out, \"{}\", p);\n+            let _ = write!(out, \"{p}\");\n         }\n         out\n     }"}, {"sha": "4dc9c30a2c807a2050c8fb72638cb2b3e4a4d2a8", "filename": "compiler/rustc_ast/src/ast_traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -214,15 +214,15 @@ impl HasTokens for Attribute {\n         match &self.kind {\n             AttrKind::Normal(normal) => normal.tokens.as_ref(),\n             kind @ AttrKind::DocComment(..) => {\n-                panic!(\"Called tokens on doc comment attr {:?}\", kind)\n+                panic!(\"Called tokens on doc comment attr {kind:?}\")\n             }\n         }\n     }\n     fn tokens_mut(&mut self) -> Option<&mut Option<LazyAttrTokenStream>> {\n         Some(match &mut self.kind {\n             AttrKind::Normal(normal) => &mut normal.tokens,\n             kind @ AttrKind::DocComment(..) => {\n-                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n+                panic!(\"Called tokens_mut on doc comment attr {kind:?}\")\n             }\n         })\n     }"}, {"sha": "c6b6207b3186e85442b1c388c221b6974b0306b3", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -310,7 +310,7 @@ impl Attribute {\n             AttrKind::Normal(normal) => normal\n                 .tokens\n                 .as_ref()\n-                .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n+                .unwrap_or_else(|| panic!(\"attribute is missing tokens: {self:?}\"))\n                 .to_attr_token_stream()\n                 .to_tokenstream(),\n             &AttrKind::DocComment(comment_kind, data) => TokenStream::new(vec![TokenTree::Token("}, {"sha": "35939496348988af0e5d3c7f2aaac62120978490", "filename": "compiler/rustc_ast/src/expand/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -9,8 +9,8 @@ pub enum AllocatorKind {\n impl AllocatorKind {\n     pub fn fn_name(&self, base: Symbol) -> String {\n         match *self {\n-            AllocatorKind::Global => format!(\"__rg_{}\", base),\n-            AllocatorKind::Default => format!(\"__rdl_{}\", base),\n+            AllocatorKind::Global => format!(\"__rg_{base}\"),\n+            AllocatorKind::Default => format!(\"__rdl_{base}\"),\n         }\n     }\n }"}, {"sha": "f947ae4d05732f341632abeddcc61af32c7fb07c", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -125,27 +125,27 @@ impl fmt::Display for Lit {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let Lit { kind, symbol, suffix } = *self;\n         match kind {\n-            Byte => write!(f, \"b'{}'\", symbol)?,\n-            Char => write!(f, \"'{}'\", symbol)?,\n-            Str => write!(f, \"\\\"{}\\\"\", symbol)?,\n+            Byte => write!(f, \"b'{symbol}'\")?,\n+            Char => write!(f, \"'{symbol}'\")?,\n+            Str => write!(f, \"\\\"{symbol}\\\"\")?,\n             StrRaw(n) => write!(\n                 f,\n                 \"r{delim}\\\"{string}\\\"{delim}\",\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n-            ByteStr => write!(f, \"b\\\"{}\\\"\", symbol)?,\n+            ByteStr => write!(f, \"b\\\"{symbol}\\\"\")?,\n             ByteStrRaw(n) => write!(\n                 f,\n                 \"br{delim}\\\"{string}\\\"{delim}\",\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n-            Integer | Float | Bool | Err => write!(f, \"{}\", symbol)?,\n+            Integer | Float | Bool | Err => write!(f, \"{symbol}\")?,\n         }\n \n         if let Some(suffix) = suffix {\n-            write!(f, \"{}\", suffix)?;\n+            write!(f, \"{suffix}\")?;\n         }\n \n         Ok(())\n@@ -756,7 +756,7 @@ impl Token {\n                 _ => return None,\n             },\n             SingleQuote => match joint.kind {\n-                Ident(name, false) => Lifetime(Symbol::intern(&format!(\"'{}\", name))),\n+                Ident(name, false) => Lifetime(Symbol::intern(&format!(\"'{name}\"))),\n                 _ => return None,\n             },\n "}, {"sha": "fabd43a1618a4387fa8af8680fe8a52f17af90d1", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -258,8 +258,7 @@ impl AttrTokenStream {\n \n                         assert!(\n                             found,\n-                            \"Failed to find trailing delimited group in: {:?}\",\n-                            target_tokens\n+                            \"Failed to find trailing delimited group in: {target_tokens:?}\"\n                         );\n                     }\n                     let mut flat: SmallVec<[_; 1]> = SmallVec::new();"}, {"sha": "74b842ac96eacd935fe92d2eeae6f22cb2c45927", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -34,7 +34,7 @@ pub enum LitError {\n     InvalidIntSuffix,\n     InvalidFloatSuffix,\n     NonDecimalFloat(u32),\n-    IntTooLarge,\n+    IntTooLarge(u32),\n }\n \n impl LitKind {\n@@ -168,7 +168,7 @@ impl fmt::Display for LitKind {\n         match *self {\n             LitKind::Byte(b) => {\n                 let b: String = ascii::escape_default(b).map(Into::<char>::into).collect();\n-                write!(f, \"b'{}'\", b)?;\n+                write!(f, \"b'{b}'\")?;\n             }\n             LitKind::Char(ch) => write!(f, \"'{}'\", escape_char_symbol(ch))?,\n             LitKind::Str(sym, StrStyle::Cooked) => write!(f, \"\\\"{}\\\"\", escape_string_symbol(sym))?,\n@@ -192,15 +192,15 @@ impl fmt::Display for LitKind {\n                 )?;\n             }\n             LitKind::Int(n, ty) => {\n-                write!(f, \"{}\", n)?;\n+                write!(f, \"{n}\")?;\n                 match ty {\n                     ast::LitIntType::Unsigned(ty) => write!(f, \"{}\", ty.name())?,\n                     ast::LitIntType::Signed(ty) => write!(f, \"{}\", ty.name())?,\n                     ast::LitIntType::Unsuffixed => {}\n                 }\n             }\n             LitKind::Float(symbol, ty) => {\n-                write!(f, \"{}\", symbol)?;\n+                write!(f, \"{symbol}\")?;\n                 match ty {\n                     ast::LitFloatType::Suffixed(ty) => write!(f, \"{}\", ty.name())?,\n                     ast::LitFloatType::Unsuffixed => {}\n@@ -333,6 +333,6 @@ fn integer_lit(symbol: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitErr\n         // but these kinds of errors are already reported by the lexer.\n         let from_lexer =\n             base < 10 && s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n-        if from_lexer { LitError::LexerError } else { LitError::IntTooLarge }\n+        if from_lexer { LitError::LexerError } else { LitError::IntTooLarge(base) }\n     })\n }"}, {"sha": "941d3179587ebea510fc29bd4049f26212eb75c9", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     Err(supported_abis) => {\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n-                            let _ = write!(abis, \", `{}`\", m);\n+                            let _ = write!(abis, \", `{m}`\");\n                         }\n                         self.tcx.sess.emit_err(InvalidAbiClobberAbi {\n                             abi_span: *abi_span,\n@@ -262,7 +262,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             let sub = if !valid_modifiers.is_empty() {\n                                 let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n                                 for m in &valid_modifiers[1..] {\n-                                    let _ = write!(mods, \", `{}`\", m);\n+                                    let _ = write!(mods, \", `{m}`\");\n                                 }\n                                 InvalidAsmTemplateModifierRegClassSub::SupportModifier {\n                                     class_name: class.name(),"}, {"sha": "ea30bed5ace4f208584812a885da055d96f98c42", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1051,7 +1051,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     }\n                     _ => {\n                         // Replace the ident for bindings that aren't simple.\n-                        let name = format!(\"__arg{}\", index);\n+                        let name = format!(\"__arg{index}\");\n                         let ident = Ident::from_str(&name);\n \n                         (ident, false)"}, {"sha": "2e135aafb1e0f36856dce96b87ab3251424a6a50", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -296,7 +296,7 @@ impl std::fmt::Display for ImplTraitPosition {\n             ImplTraitPosition::ImplReturn => \"`impl` method return\",\n         };\n \n-        write!(f, \"{}\", name)\n+        write!(f, \"{name}\")\n     }\n }\n \n@@ -503,7 +503,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn orig_local_def_id(&self, node: NodeId) -> LocalDefId {\n         self.orig_opt_local_def_id(node)\n-            .unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+            .unwrap_or_else(|| panic!(\"no entry for node id: `{node:?}`\"))\n     }\n \n     /// Given the id of some node in the AST, finds the `LocalDefId` associated with it by the name\n@@ -524,7 +524,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn local_def_id(&self, node: NodeId) -> LocalDefId {\n-        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{node:?}`\"))\n     }\n \n     /// Get the previously recorded `to` local def id given the `from` local def id, obtained using\n@@ -2197,7 +2197,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_trait_ref(&mut self, p: &TraitRef, itctx: &ImplTraitContext) -> hir::TraitRef<'hir> {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n-            qpath => panic!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n+            qpath => panic!(\"lower_trait_ref: unexpected QPath `{qpath:?}`\"),\n         };\n         hir::TraitRef { path, hir_ref_id: self.lower_node_id(p.ref_id) }\n     }"}, {"sha": "6a8064b0e874e84fc7731af56d705b41457d861d", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -191,23 +191,23 @@ fn doc_comment_to_string(\n     data: Symbol,\n ) -> String {\n     match (comment_kind, attr_style) {\n-        (CommentKind::Line, ast::AttrStyle::Outer) => format!(\"///{}\", data),\n-        (CommentKind::Line, ast::AttrStyle::Inner) => format!(\"//!{}\", data),\n-        (CommentKind::Block, ast::AttrStyle::Outer) => format!(\"/**{}*/\", data),\n-        (CommentKind::Block, ast::AttrStyle::Inner) => format!(\"/*!{}*/\", data),\n+        (CommentKind::Line, ast::AttrStyle::Outer) => format!(\"///{data}\"),\n+        (CommentKind::Line, ast::AttrStyle::Inner) => format!(\"//!{data}\"),\n+        (CommentKind::Block, ast::AttrStyle::Outer) => format!(\"/**{data}*/\"),\n+        (CommentKind::Block, ast::AttrStyle::Inner) => format!(\"/*!{data}*/\"),\n     }\n }\n \n pub fn literal_to_string(lit: token::Lit) -> String {\n     let token::Lit { kind, symbol, suffix } = lit;\n     let mut out = match kind {\n-        token::Byte => format!(\"b'{}'\", symbol),\n-        token::Char => format!(\"'{}'\", symbol),\n-        token::Str => format!(\"\\\"{}\\\"\", symbol),\n+        token::Byte => format!(\"b'{symbol}'\"),\n+        token::Char => format!(\"'{symbol}'\"),\n+        token::Str => format!(\"\\\"{symbol}\\\"\"),\n         token::StrRaw(n) => {\n             format!(\"r{delim}\\\"{string}\\\"{delim}\", delim = \"#\".repeat(n as usize), string = symbol)\n         }\n-        token::ByteStr => format!(\"b\\\"{}\\\"\", symbol),\n+        token::ByteStr => format!(\"b\\\"{symbol}\\\"\"),\n         token::ByteStrRaw(n) => {\n             format!(\"br{delim}\\\"{string}\\\"{delim}\", delim = \"#\".repeat(n as usize), string = symbol)\n         }"}, {"sha": "bf2c73a66a2cbb435e605af1c68b9321c6ecbbaa", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -411,9 +411,9 @@ impl<'a> State<'a> {\n             ast::VisibilityKind::Restricted { path, shorthand, .. } => {\n                 let path = Self::to_string(|s| s.print_path(path, false, 0));\n                 if *shorthand && (path == \"crate\" || path == \"self\" || path == \"super\") {\n-                    self.word_nbsp(format!(\"pub({})\", path))\n+                    self.word_nbsp(format!(\"pub({path})\"))\n                 } else {\n-                    self.word_nbsp(format!(\"pub(in {})\", path))\n+                    self.word_nbsp(format!(\"pub(in {path})\"))\n                 }\n             }\n             ast::VisibilityKind::Inherited => {}"}, {"sha": "40531c1c164f207609395f15cdfcaf1c14dab9d0", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -619,7 +619,7 @@ fn try_gate_cfg(name: Symbol, span: Span, sess: &ParseSess, features: Option<&Fe\n fn gate_cfg(gated_cfg: &GatedCfg, cfg_span: Span, sess: &ParseSess, features: &Features) {\n     let (cfg, feature, has_feature) = gated_cfg;\n     if !has_feature(features) && !cfg_span.allows_unstable(*feature) {\n-        let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n+        let explain = format!(\"`cfg({cfg})` is experimental and subject to change\");\n         feature_err(sess, *feature, cfg_span, &explain).emit();\n     }\n }\n@@ -975,7 +975,7 @@ pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n }\n \n pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n-    assert!(attr.has_name(sym::repr), \"expected `#[repr(..)]`, found: {:?}\", attr);\n+    assert!(attr.has_name(sym::repr), \"expected `#[repr(..)]`, found: {attr:?}\");\n     use ReprAttr::*;\n     let mut acc = Vec::new();\n     let diagnostic = &sess.parse_sess.span_diagnostic;"}, {"sha": "3ba7a3c5336b247de22203ade044a36814d5fcbc", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -51,7 +51,7 @@ pub(crate) struct UnknownMetaItem<'a> {\n // Manual implementation to be able to format `expected` items correctly.\n impl<'a> IntoDiagnostic<'a> for UnknownMetaItem<'_> {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n+        let expected = self.expected.iter().map(|name| format!(\"`{name}`\")).collect::<Vec<_>>();\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n             fluent::attr_unknown_meta_item,"}, {"sha": "a4943d112042dc212d419f0247933a88cecb158a", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -440,15 +440,14 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         closure_kind: &str,\n         borrowed_path: &str,\n         capture_span: Span,\n+        scope: &str,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             closure_span,\n             E0373,\n-            \"{} may outlive the current function, but it borrows {}, which is owned by the current \\\n-             function\",\n-            closure_kind,\n-            borrowed_path,\n+            \"{closure_kind} may outlive the current {scope}, but it borrows {borrowed_path}, \\\n+             which is owned by the current {scope}\",\n         );\n         err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n             .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));"}, {"sha": "d99bfc01a4298ccd50fb8d7fa0adec260065e361", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -394,7 +394,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }\n                 }\n                 let typeck = self.infcx.tcx.typeck(self.mir_def_id());\n-                let hir_id = hir.get_parent_node(expr.hir_id);\n+                let hir_id = hir.parent_id(expr.hir_id);\n                 if let Some(parent) = hir.find(hir_id) {\n                     let (def_id, args, offset) = if let hir::Node::Expr(parent_expr) = parent\n                         && let hir::ExprKind::MethodCall(_, _, args, _) = parent_expr.kind\n@@ -527,26 +527,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // that are *partially* initialized by assigning to a field of an uninitialized\n             // binding. We differentiate between them for more accurate wording here.\n             \"isn't fully initialized\"\n-        } else if spans\n-            .iter()\n-            .filter(|i| {\n-                // We filter these to avoid misleading wording in cases like the following,\n-                // where `x` has an `init`, but it is in the same place we're looking at:\n-                // ```\n-                // let x;\n-                // x += 1;\n-                // ```\n-                !i.contains(span)\n-                    // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n-                        && !visitor\n-                            .errors\n-                            .iter()\n-                            .map(|(sp, _)| *sp)\n-                            .any(|sp| span < sp && !sp.contains(span))\n-            })\n-            .count()\n-            == 0\n-        {\n+        } else if !spans.iter().any(|i| {\n+            // We filter these to avoid misleading wording in cases like the following,\n+            // where `x` has an `init`, but it is in the same place we're looking at:\n+            // ```\n+            // let x;\n+            // x += 1;\n+            // ```\n+            !i.contains(span)\n+            // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n+            && !visitor\n+                .errors\n+                .iter()\n+                .map(|(sp, _)| *sp)\n+                .any(|sp| span < sp && !sp.contains(span))\n+        }) {\n             show_assign_sugg = true;\n             \"isn't initialized\"\n         } else {\n@@ -1428,6 +1423,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             //\n             // then just use the normal error. The closure isn't escaping\n             // and `move` will not help here.\n+            (\n+                Some(name),\n+                BorrowExplanation::UsedLater(LaterUseKind::ClosureCapture, var_or_use_span, _),\n+            ) => self.report_escaping_closure_capture(\n+                borrow_spans,\n+                borrow_span,\n+                &RegionName {\n+                    name: self.synthesize_region_name(),\n+                    source: RegionNameSource::Static,\n+                },\n+                ConstraintCategory::CallArgument(None),\n+                var_or_use_span,\n+                &format!(\"`{}`\", name),\n+                \"block\",\n+            ),\n             (\n                 Some(name),\n                 BorrowExplanation::MustBeValidFor {\n@@ -1448,6 +1458,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     category,\n                     span,\n                     &format!(\"`{}`\", name),\n+                    \"function\",\n                 ),\n             (\n                 name,\n@@ -1900,6 +1911,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         Some(err)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_closure_capture(\n         &mut self,\n         use_span: UseSpans<'tcx>,\n@@ -1908,6 +1920,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         category: ConstraintCategory<'tcx>,\n         constraint_span: Span,\n         captured_var: &str,\n+        scope: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         let tcx = self.infcx.tcx;\n         let args_span = use_span.args_or_use();\n@@ -1938,8 +1951,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None => \"closure\",\n         };\n \n-        let mut err =\n-            self.cannot_capture_in_long_lived_closure(args_span, kind, captured_var, var_span);\n+        let mut err = self.cannot_capture_in_long_lived_closure(\n+            args_span,\n+            kind,\n+            captured_var,\n+            var_span,\n+            scope,\n+        );\n         err.span_suggestion_verbose(\n             sugg_span,\n             &format!(\n@@ -1961,10 +1979,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if matches!(use_span.generator_kind(), Some(GeneratorKind::Async(_))) {\n                     err.note(\n                         \"async blocks are not executed immediately and must either take a \\\n-                    reference or ownership of outside variables they use\",\n+                         reference or ownership of outside variables they use\",\n                     );\n                 } else {\n-                    let msg = format!(\"function requires argument type to outlive `{}`\", fr_name);\n+                    let msg = format!(\"{scope} requires argument type to outlive `{fr_name}`\");\n                     err.span_note(constraint_span, &msg);\n                 }\n             }"}, {"sha": "c4ae30151c4bd2ee6eac2beea26dbed1d1438a4d", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -444,6 +444,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// First span returned points to the location of the conflicting use\n     /// Second span if `Some` is returned in the case of closures and points\n     /// to the use of the path\n+    #[instrument(level = \"debug\", skip(self))]\n     fn later_use_kind(\n         &self,\n         borrow: &BorrowData<'tcx>,\n@@ -461,11 +462,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let block = &self.body.basic_blocks[location.block];\n \n                 let kind = if let Some(&Statement {\n-                    kind: StatementKind::FakeRead(box (FakeReadCause::ForLet(_), _)),\n+                    kind: StatementKind::FakeRead(box (FakeReadCause::ForLet(_), place)),\n                     ..\n                 }) = block.statements.get(location.statement_index)\n                 {\n-                    LaterUseKind::FakeLetRead\n+                    if let Some(l) = place.as_local()\n+                        && let local_decl = &self.body.local_decls[l]\n+                        && local_decl.ty.is_closure()\n+                    {\n+                        LaterUseKind::ClosureCapture\n+                    } else {\n+                        LaterUseKind::FakeLetRead\n+                    }\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {"}, {"sha": "09ef84f7cbb84f8d1534d66e7249704d8425b0b3", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -344,20 +344,25 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     } else {\n                         err.span_help(source_info.span, \"try removing `&mut` here\");\n                     }\n-                } else if decl.mutability == Mutability::Not\n-                    && !matches!(\n+                } else if decl.mutability == Mutability::Not {\n+                    if matches!(\n                         decl.local_info,\n                         Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(\n                             hir::ImplicitSelfKind::MutRef\n-                        ))))\n-                    )\n-                {\n-                    err.span_suggestion_verbose(\n-                        decl.source_info.span.shrink_to_lo(),\n-                        \"consider making the binding mutable\",\n-                        \"mut \",\n-                        Applicability::MachineApplicable,\n-                    );\n+                        ),)))\n+                    ) {\n+                        err.note(\n+                            \"as `Self` may be unsized, this call attempts to take `&mut &mut self`\",\n+                        );\n+                        err.note(\"however, `&mut self` expands to `self: &mut Self`, therefore `self` cannot be borrowed mutably\");\n+                    } else {\n+                        err.span_suggestion_verbose(\n+                            decl.source_info.span.shrink_to_lo(),\n+                            \"consider making the binding mutable\",\n+                            \"mut \",\n+                            Applicability::MachineApplicable,\n+                        );\n+                    };\n                 }\n             }\n \n@@ -1004,7 +1009,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let hir = self.infcx.tcx.hir();\n         let closure_id = self.mir_hir_id();\n         let closure_span = self.infcx.tcx.def_span(self.mir_def_id());\n-        let fn_call_id = hir.get_parent_node(closure_id);\n+        let fn_call_id = hir.parent_id(closure_id);\n         let node = hir.get(fn_call_id);\n         let def_id = hir.enclosing_body_owner(fn_call_id);\n         let mut look_at_return = true;"}, {"sha": "cc33ef14756e5fbda6f1254428dcbf2322c3b5d7", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 13, "deletions": 69, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -4,9 +4,9 @@\n \n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{self as hir, Item, ItemKind, Node};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n@@ -192,6 +192,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // buffered in the `MirBorrowckCtxt`.\n \n         let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n+        let mut last_unexpected_hidden_region: Option<(Span, Ty<'_>, ty::OpaqueTypeKey<'tcx>)> =\n+            None;\n \n         for nll_error in nll_errors.into_iter() {\n             match nll_error {\n@@ -234,13 +236,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n                     let named_key = self.regioncx.name_regions(self.infcx.tcx, key);\n                     let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n-                    self.buffer_error(unexpected_hidden_region_diagnostic(\n+                    let mut diag = unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n                         span,\n                         named_ty,\n                         named_region,\n                         named_key,\n-                    ));\n+                    );\n+                    if last_unexpected_hidden_region != Some((span, named_ty, named_key)) {\n+                        self.buffer_error(diag);\n+                        last_unexpected_hidden_region = Some((span, named_ty, named_key));\n+                    } else {\n+                        diag.delay_as_bug();\n+                    }\n                 }\n \n                 RegionErrorKind::BoundUniversalRegionError {\n@@ -291,71 +299,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlives_suggestion.add_suggestion(self);\n     }\n \n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n-        def_id: DefId,\n-        trait_objects: &FxIndexSet<DefId>,\n-    ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.infcx.tcx;\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n-                {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n-                }\n-            }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                            .next()\n-                        {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -795,6 +738,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 Some(arg),\n                 captures,\n                 Some((param.param_ty_span, param.param_ty.to_string())),\n+                self.infcx.tcx.is_suitable_region(f).map(|r| r.def_id),\n             );\n         }\n     }\n@@ -850,7 +794,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         visitor.visit_ty(param.param_ty);\n \n         let Some((ident, self_ty)) =\n-            self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &visitor.0) else {return};\n+            NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &visitor.0) else { return; };\n \n         self.suggest_constrain_dyn_trait_in_impl(diag, &visitor.0, ident, self_ty);\n     }"}, {"sha": "579ce90a760f2e977ee9a0a1e65da7827590c4ca", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// increment the counter.\n     ///\n     /// This is _not_ idempotent. Call `give_region_a_name` when possible.\n-    fn synthesize_region_name(&self) -> Symbol {\n+    pub(crate) fn synthesize_region_name(&self) -> Symbol {\n         let c = self.next_region_name.replace_with(|counter| *counter + 1);\n         Symbol::intern(&format!(\"'{:?}\", c))\n     }"}, {"sha": "278ffed07477b5b3bdf8224a7b3c79c89b2b9ace", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 37, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -863,7 +863,6 @@ enum WriteKind {\n /// local place can be mutated.\n //\n // FIXME: @nikomatsakis suggested that this flag could be removed with the following modifications:\n-// - Merge `check_access_permissions()` and `check_if_reassignment_to_immutable_state()`.\n // - Split `is_mutable()` into `is_assignable()` (can be directly assigned) and\n //   `is_declared_mutable()`.\n // - Take flow state into consideration in `is_assignable()` for local variables.\n@@ -1132,20 +1131,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Write of P[i] or *P requires P init'd.\n         self.check_if_assigned_path_is_moved(location, place_span, flow_state);\n \n-        // Special case: you can assign an immutable local variable\n-        // (e.g., `x = ...`) so long as it has never been initialized\n-        // before (at this point in the flow).\n-        if let Some(local) = place_span.0.as_local() {\n-            if let Mutability::Not = self.body.local_decls[local].mutability {\n-                // check for reassignments to immutable local variables\n-                self.check_if_reassignment_to_immutable_state(\n-                    location, local, place_span, flow_state,\n-                );\n-                return;\n-            }\n-        }\n-\n-        // Otherwise, use the normal access permission rules.\n         self.access_place(\n             location,\n             place_span,\n@@ -1554,24 +1539,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    fn check_if_reassignment_to_immutable_state(\n-        &mut self,\n-        location: Location,\n-        local: Local,\n-        place_span: (Place<'tcx>, Span),\n-        flow_state: &Flows<'cx, 'tcx>,\n-    ) {\n-        debug!(\"check_if_reassignment_to_immutable_state({:?})\", local);\n-\n-        // Check if any of the initializations of `local` have happened yet:\n-        if let Some(init_index) = self.is_local_ever_initialized(local, flow_state) {\n-            // And, if so, report an error.\n-            let init = &self.move_data.inits[init_index];\n-            let span = init.span(&self.body);\n-            self.report_illegal_reassignment(location, place_span, span, place_span.0);\n-        }\n-    }\n-\n     fn check_if_full_path_is_moved(\n         &mut self,\n         location: Location,\n@@ -2037,12 +2004,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // partial initialization, do not complain about mutability\n         // errors except for actual mutation (as opposed to an attempt\n         // to do a partial initialization).\n-        let previously_initialized =\n-            self.is_local_ever_initialized(place.local, flow_state).is_some();\n+        let previously_initialized = self.is_local_ever_initialized(place.local, flow_state);\n \n         // at this point, we have set up the error reporting state.\n-        if previously_initialized {\n-            self.report_mutability_error(place, span, the_place_err, error_access, location);\n+        if let Some(init_index) = previously_initialized {\n+            if let (AccessKind::Mutate, Some(_)) = (error_access, place.as_local()) {\n+                // If this is a mutate access to an immutable local variable with no projections\n+                // report the error as an illegal reassignment\n+                let init = &self.move_data.inits[init_index];\n+                let assigned_span = init.span(&self.body);\n+                self.report_illegal_reassignment(location, (place, span), assigned_span, place);\n+            } else {\n+                self.report_mutability_error(place, span, the_place_err, error_access, location)\n+            }\n             true\n         } else {\n             false"}, {"sha": "b2b7b9d75bd37163e9ac20a305ba9e19ac9366ef", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -638,7 +638,7 @@ fn report_missing_placeholders(\n                 if show_doc_note {\n                     diag.note(concat!(\n                         stringify!($kind),\n-                        \" formatting not supported; see the documentation for `std::fmt`\",\n+                        \" formatting is not supported; see the documentation for `std::fmt`\",\n                     ));\n                 }\n                 if suggestions.len() > 0 {"}, {"sha": "a92242b2615c1f66b1cfb438c61a0bbf48ad0e97", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1244,7 +1244,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().any(|value| *value == gcc_func) {\n             self.function_call(func, args, funclet)\n         }\n         else {"}, {"sha": "4424b31c0542c65777d80571ebc85cafbdd1c925", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -253,7 +253,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n-        debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n+        debug_assert!(self.functions.borrow().values().any(|value| *value == function),\n             \"{:?} ({:?}) is not a function\", value, value.get_type());\n         function\n     }"}, {"sha": "546540dfd76232ad2b6d50887e1b9304d1f9e63d", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -34,13 +34,6 @@ pub trait ArgAttributesExt {\n     );\n }\n \n-fn should_use_mutable_noalias(cx: &CodegenCx<'_, '_>) -> bool {\n-    // LLVM prior to version 12 had known miscompiles in the presence of\n-    // noalias attributes (see #54878), but we don't support earlier\n-    // versions at all anymore. We now enable mutable noalias by default.\n-    cx.tcx.sess.opts.unstable_opts.mutable_noalias.unwrap_or(true)\n-}\n-\n const ABI_AFFECTING_ATTRIBUTES: [(ArgAttribute, llvm::AttributeKind); 1] =\n     [(ArgAttribute::InReg, llvm::AttributeKind::InReg)];\n \n@@ -88,9 +81,6 @@ fn get_attrs<'ll>(this: &ArgAttributes, cx: &CodegenCx<'ll, '_>) -> SmallVec<[&'\n                 attrs.push(llattr.create_attr(cx.llcx));\n             }\n         }\n-        if regular.contains(ArgAttribute::NoAliasMutRef) && should_use_mutable_noalias(cx) {\n-            attrs.push(llvm::AttributeKind::NoAlias.create_attr(cx.llcx));\n-        }\n     } else if cx.tcx.sess.opts.unstable_opts.sanitizer.contains(SanitizerSet::MEMORY) {\n         // If we're not optimising, *but* memory sanitizer is on, emit noundef, since it affects\n         // memory sanitizer's behavior."}, {"sha": "680d810f78eb9b4121e98955f6cbad23629f52a3", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 283, "deletions": 266, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -8,8 +8,8 @@ use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n-use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::errors::{ExpectedPointerMutability, InvalidMonomorphization};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n@@ -284,15 +284,11 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n+                        tcx.sess.emit_err(InvalidMonomorphization::BasicIntegerType {\n                             span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                name, ty\n-                            ),\n-                        );\n+                            name,\n+                            ty,\n+                        });\n                         return;\n                     }\n                 }\n@@ -838,40 +834,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     llret_ty: &'ll Type,\n     span: Span,\n ) -> Result<&'ll Value, ()> {\n-    // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n-            {\n-                emit_error!($($fmt)*);\n-                return Err(());\n-            }\n-        }\n+        ($diag: expr) => {{\n+            bx.sess().emit_err($diag);\n+            return Err(());\n+        }};\n     }\n \n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond: expr, $diag: expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($diag);\n             }\n         };\n     }\n \n     macro_rules! require_simd {\n-        ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+        ($ty: expr, $diag: expr) => {\n+            require!($ty.is_simd(), $diag)\n         };\n     }\n \n@@ -881,7 +861,11 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     let arg_tys = sig.inputs();\n \n     if name == sym::simd_select_bitmask {\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n+\n         let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n \n         let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n@@ -902,12 +886,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n-            _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::InvalidBitmask {\n+                span,\n+                name,\n                 mask_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         };\n \n         let i1 = bx.type_i1();\n@@ -919,7 +904,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     }\n \n     // every intrinsic below takes a SIMD vector as its first argument\n-    require_simd!(arg_tys[0], \"input\");\n+    require_simd!(arg_tys[0], InvalidMonomorphization::SimdInput { span, name, ty: arg_tys[0] });\n     let in_ty = arg_tys[0];\n \n     let comparison = match name {\n@@ -934,23 +919,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n \n     let (in_len, in_elem) = arg_tys[0].simd_size_and_type(bx.tcx());\n     if let Some(cmp_op) = comparison {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n+\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnIntegerType { span, name, ret_ty, out_ty }\n         );\n \n         return Ok(compare_simd_types(\n@@ -975,34 +961,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                         span_bug!(span, \"could not evaluate shuffle index array length\")\n                     })\n                 }\n-                _ => return_error!(\n-                    \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                    args[2].layout.ty\n-                ),\n+                _ => return_error!(InvalidMonomorphization::SimdShuffle {\n+                    span,\n+                    name,\n+                    ty: args[2].layout.ty\n+                }),\n             }\n         } else {\n             stripped.parse().unwrap_or_else(|_| {\n                 span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n             })\n         };\n \n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let total_len = u128::from(in_len) * 2;\n@@ -1015,15 +994,20 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let val = bx.const_get_elt(vector, i as u64);\n                 match bx.const_to_opt_u128(val, true) {\n                     None => {\n-                        emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexNotConstant {\n+                            span,\n+                            name,\n+                            arg_idx,\n+                        });\n                         None\n                     }\n                     Some(idx) if idx >= total_len => {\n-                        emit_error!(\n-                            \"shuffle index #{} is out of bounds (limit {})\",\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexOutOfBounds {\n+                            span,\n+                            name,\n                             arg_idx,\n-                            total_len\n-                        );\n+                            total_len,\n+                        });\n                         None\n                     }\n                     Some(idx) => Some(bx.const_i32(idx as i32)),\n@@ -1044,10 +1028,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphization::InsertedType {\n+                span,\n+                name,\n+                in_elem,\n+                in_ty,\n+                out_ty: arg_tys[2]\n+            }\n         );\n         return Ok(bx.insert_element(\n             args[0].immediate(),\n@@ -1058,28 +1045,26 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()));\n     }\n \n     if name == sym::simd_select {\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphization::MismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphization::MaskType { span, name, ty: m_elem_ty }),\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = bx.type_i1();\n@@ -1111,11 +1096,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 args[0].immediate(),\n                 i.bit_width().unwrap_or_else(|| bx.data_layout().pointer_size.bits()),\n             ),\n-            _ => return_error!(\n-                \"vector argument `{}`'s element type `{}`, expected integer element type\",\n+            _ => return_error!(InvalidMonomorphization::VectorArgument {\n+                span,\n+                name,\n                 in_ty,\n                 in_elem\n-            ),\n+            }),\n         };\n \n         // Shift the MSB to the right by \"in_elem_bitwidth - 1\" into the first bit position.\n@@ -1150,12 +1136,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n                 return Ok(bx.load(array_ty, ptr, Align::ONE));\n             }\n-            _ => return_error!(\n-                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n                 ret_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         }\n     }\n \n@@ -1168,42 +1155,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         span: Span,\n         args: &[OperandRef<'tcx, &'ll Value>],\n     ) -> Result<&'ll Value, ()> {\n-        #[allow(unused_macro_rules)]\n-        macro_rules! emit_error {\n-            ($msg: tt) => {\n-                emit_error!($msg, )\n-            };\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n-                {\n-                    emit_error!($($fmt)*);\n-                    return Err(());\n-                }\n-            }\n+            ($diag: expr) => {{\n+                bx.sess().emit_err($diag);\n+                return Err(());\n+            }};\n         }\n \n         let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n             let elem_ty = bx.cx.type_float_from_ty(*f);\n             match f.bit_width() {\n                 32 => (\"f32\", elem_ty),\n                 64 => (\"f64\", elem_ty),\n-                _ => {\n-                    return_error!(\n-                        \"unsupported element type `{}` of floating-point vector `{}`\",\n-                        f.name_str(),\n-                        in_ty\n-                    );\n-                }\n+                _ => return_error!(InvalidMonomorphization::FloatingPointVector {\n+                    span,\n+                    name,\n+                    f_ty: *f,\n+                    in_ty,\n+                }),\n             }\n         } else {\n-            return_error!(\"`{}` is not a floating-point type\", in_ty);\n+            return_error!(InvalidMonomorphization::FloatingPointType { span, name, in_ty });\n         };\n \n         let vec_ty = bx.type_vector(elem_ty, in_len);\n@@ -1225,7 +1197,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-            _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+            _ => return_error!(InvalidMonomorphization::UnrecognizedIntrinsic { span, name }),\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n@@ -1319,37 +1291,48 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         // Of the same length:\n         let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            out_len\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n         );\n         require!(\n             in_len == out_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            out_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n         );\n \n         // The return type must match the first argument type\n-        require!(ret_ty == in_ty, \"expected return type `{}`, found `{}`\", in_ty, ret_ty);\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n@@ -1376,15 +1359,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*_ {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1400,10 +1383,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                                 to be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1452,32 +1437,40 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n \n         // Of the same length:\n         let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == element_len1,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            element_len1\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n         );\n         require!(\n             in_len == element_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            element_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n         );\n \n         // This counts how many pointers\n@@ -1508,15 +1501,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*mut {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1531,10 +1524,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                         be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1581,10 +1576,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -1607,25 +1599,28 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                                 32 => bx.const_real(bx.type_f32(), $identity),\n                                 64 => bx.const_real(bx.type_f64(), $identity),\n                                 v => return_error!(\n-                                    r#\"\n-unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n-                                    sym::$name,\n-                                    in_ty,\n-                                    in_elem,\n-                                    v,\n-                                    ret_ty\n+                                    InvalidMonomorphization::UnsupportedSymbolOfSize {\n+                                        span,\n+                                        name,\n+                                        symbol: sym::$name,\n+                                        in_ty,\n+                                        in_elem,\n+                                        size: v,\n+                                        ret_ty\n+                                    }\n                                 ),\n                             }\n                         };\n                         Ok(bx.$float_reduce(acc, args[0].immediate()))\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1653,22 +1648,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_i) => Ok(bx.$int_red(args[0].immediate(), true)),\n                     ty::Uint(_u) => Ok(bx.$int_red(args[0].immediate(), false)),\n                     ty::Float(_f) => Ok(bx.$float_red(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1686,22 +1679,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n+                        _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                            span,\n+                            name,\n+                            symbol: sym::$name,\n                             in_ty,\n                             in_elem,\n                             ret_ty\n-                        ),\n+                        }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -1714,13 +1705,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                         let r = bx.$red(input);\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1733,16 +1725,18 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     bitwise_red!(simd_reduce_any: vector_reduce_or, true);\n \n     if name == sym::simd_cast_ptr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n@@ -1751,19 +1745,29 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast fat pointer `{}`\", in_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: in_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(p) => {\n                 let (metadata, check_sized) = p.ty.ptr_metadata_ty(bx.tcx, |ty| {\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast to fat pointer `{}`\", out_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: out_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n         }\n \n         if in_elem == out_elem {\n@@ -1774,66 +1778,76 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     }\n \n     if name == sym::simd_expose_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n+            }\n         }\n         match out_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", out_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: out_elem }),\n         }\n \n         return Ok(bx.ptrtoint(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_from_exposed_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", in_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: in_elem }),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n+            }\n         }\n \n         return Ok(bx.inttoptr(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_cast || name == sym::simd_as {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -1912,11 +1926,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         }\n         require!(\n             false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+            InvalidMonomorphization::UnsupportedCast {\n+                span,\n+                name,\n+                in_ty,\n+                in_elem,\n+                ret_ty,\n+                out_elem\n+            }\n         );\n     }\n     macro_rules! arith_binary {\n@@ -1928,10 +1945,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -1959,10 +1976,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -2000,12 +2017,12 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphization::ExpectedVectorElementType {\n+                    span,\n+                    name,\n+                    expected_element: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vector_type: arg_tys[0]\n+                });\n             }\n         };\n         let llvm_intrinsic = &format!("}, {"sha": "d1ad687e6aee32a2b3e30c17557e58e366efce87", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -27,6 +27,7 @@ rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "8ca7103ed482cc5f7646537165823a4dbcf2041d", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 102, "deletions": 79, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -11,7 +11,7 @@ use rustc_metadata::find_native_static_library;\n use rustc_metadata::fs::{emit_wrapper_file, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n-use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Lto, Strip};\n+use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Strip};\n use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SplitDwarfKind};\n use rustc_session::cstore::DllImport;\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n@@ -208,16 +208,16 @@ pub fn link_binary<'a>(\n     Ok(())\n }\n \n+// Crate type is not passed when calculating the dylibs to include for LTO. In that case all\n+// crate types must use the same dependency formats.\n pub fn each_linked_rlib(\n-    sess: &Session,\n     info: &CrateInfo,\n+    crate_type: Option<CrateType>,\n     f: &mut dyn FnMut(CrateNum, &Path),\n ) -> Result<(), errors::LinkRlibError> {\n     let crates = info.used_crates.iter();\n-    let mut fmts = None;\n \n-    let lto_active = matches!(sess.lto(), Lto::Fat | Lto::Thin);\n-    if lto_active {\n+    let fmts = if crate_type.is_none() {\n         for combination in info.dependency_formats.iter().combinations(2) {\n             let (ty1, list1) = &combination[0];\n             let (ty2, list2) = &combination[1];\n@@ -230,27 +230,23 @@ pub fn each_linked_rlib(\n                 });\n             }\n         }\n-    }\n-\n-    for (ty, list) in info.dependency_formats.iter() {\n-        match ty {\n-            CrateType::Executable\n-            | CrateType::Staticlib\n-            | CrateType::Cdylib\n-            | CrateType::ProcMacro => {\n-                fmts = Some(list);\n-                break;\n-            }\n-            CrateType::Dylib if lto_active => {\n-                fmts = Some(list);\n-                break;\n-            }\n-            _ => {}\n+        if info.dependency_formats.is_empty() {\n+            return Err(errors::LinkRlibError::MissingFormat);\n         }\n-    }\n-    let Some(fmts) = fmts else {\n-        return Err(errors::LinkRlibError::MissingFormat);\n+        &info.dependency_formats[0].1\n+    } else {\n+        let fmts = info\n+            .dependency_formats\n+            .iter()\n+            .find_map(|&(ty, ref list)| if Some(ty) == crate_type { Some(list) } else { None });\n+\n+        let Some(fmts) = fmts else {\n+            return Err(errors::LinkRlibError::MissingFormat);\n+        };\n+\n+        fmts\n     };\n+\n     for &cnum in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n             Some(&Linkage::NotLinked | &Linkage::Dynamic | &Linkage::IncludedFromDylib) => continue,\n@@ -516,64 +512,71 @@ fn link_staticlib<'a>(\n     )?;\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n-        let name = codegen_results.crate_info.crate_name[&cnum];\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-\n-        // Here when we include the rlib into our staticlib we need to make a\n-        // decision whether to include the extra object files along the way.\n-        // These extra object files come from statically included native\n-        // libraries, but they may be cfg'd away with #[link(cfg(..))].\n-        //\n-        // This unstable feature, though, only needs liblibc to work. The only\n-        // use case there is where musl is statically included in liblibc.rlib,\n-        // so if we don't want the included version we just need to skip it. As\n-        // a result the logic here is that if *any* linked library is cfg'd away\n-        // we just skip all object files.\n-        //\n-        // Clearly this is not sufficient for a general purpose feature, and\n-        // we'd want to read from the library's metadata to determine which\n-        // object files come from where and selectively skip them.\n-        let skip_object_files = native_libs.iter().any(|lib| {\n-            matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n-                && !relevant_lib(sess, lib)\n-        });\n+    let res = each_linked_rlib(\n+        &codegen_results.crate_info,\n+        Some(CrateType::Staticlib),\n+        &mut |cnum, path| {\n+            let name = codegen_results.crate_info.crate_name[&cnum];\n+            let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+\n+            // Here when we include the rlib into our staticlib we need to make a\n+            // decision whether to include the extra object files along the way.\n+            // These extra object files come from statically included native\n+            // libraries, but they may be cfg'd away with #[link(cfg(..))].\n+            //\n+            // This unstable feature, though, only needs liblibc to work. The only\n+            // use case there is where musl is statically included in liblibc.rlib,\n+            // so if we don't want the included version we just need to skip it. As\n+            // a result the logic here is that if *any* linked library is cfg'd away\n+            // we just skip all object files.\n+            //\n+            // Clearly this is not sufficient for a general purpose feature, and\n+            // we'd want to read from the library's metadata to determine which\n+            // object files come from where and selectively skip them.\n+            let skip_object_files = native_libs.iter().any(|lib| {\n+                matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n+                    && !relevant_lib(sess, lib)\n+            });\n \n-        let lto = are_upstream_rust_objects_already_included(sess)\n-            && !ignored_for_lto(sess, &codegen_results.crate_info, cnum);\n+            let lto = are_upstream_rust_objects_already_included(sess)\n+                && !ignored_for_lto(sess, &codegen_results.crate_info, cnum);\n \n-        // Ignoring obj file starting with the crate name\n-        // as simple comparison is not enough - there\n-        // might be also an extra name suffix\n-        let obj_start = name.as_str().to_owned();\n+            // Ignoring obj file starting with the crate name\n+            // as simple comparison is not enough - there\n+            // might be also an extra name suffix\n+            let obj_start = name.as_str().to_owned();\n \n-        ab.add_archive(\n-            path,\n-            Box::new(move |fname: &str| {\n-                // Ignore metadata files, no matter the name.\n-                if fname == METADATA_FILENAME {\n-                    return true;\n-                }\n+            ab.add_archive(\n+                path,\n+                Box::new(move |fname: &str| {\n+                    // Ignore metadata files, no matter the name.\n+                    if fname == METADATA_FILENAME {\n+                        return true;\n+                    }\n \n-                // Don't include Rust objects if LTO is enabled\n-                if lto && looks_like_rust_object_file(fname) {\n-                    return true;\n-                }\n+                    // Don't include Rust objects if LTO is enabled\n+                    if lto && looks_like_rust_object_file(fname) {\n+                        return true;\n+                    }\n \n-                // Otherwise if this is *not* a rust object and we're skipping\n-                // objects then skip this file\n-                if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                    return true;\n-                }\n+                    // Otherwise if this is *not* a rust object and we're skipping\n+                    // objects then skip this file\n+                    if skip_object_files\n+                        && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\"))\n+                    {\n+                        return true;\n+                    }\n \n-                // ok, don't skip this\n-                false\n-            }),\n-        )\n-        .unwrap();\n+                    // ok, don't skip this\n+                    false\n+                }),\n+            )\n+            .unwrap();\n \n-        all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n-    });\n+            all_native_libs\n+                .extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n+        },\n+    );\n     if let Err(e) = res {\n         sess.emit_fatal(e);\n     }\n@@ -1354,7 +1357,8 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n     if !lib_args.is_empty() {\n         sess.emit_note(errors::StaticLibraryNativeArtifacts);\n         // Prefix for greppability\n-        sess.emit_note(errors::NativeStaticLibs { arguments: lib_args.join(\" \") });\n+        // Note: This must not be translated as tools are allowed to depend on this exact string.\n+        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n     }\n }\n \n@@ -2612,7 +2616,7 @@ fn add_static_crate<'a>(\n             sess.target.no_builtins || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n         let mut archive = archive_builder_builder.new_archive_builder(sess);\n-        if let Err(e) = archive.add_archive(\n+        if let Err(error) = archive.add_archive(\n             cratepath,\n             Box::new(move |f| {\n                 if f == METADATA_FILENAME {\n@@ -2652,7 +2656,7 @@ fn add_static_crate<'a>(\n                 false\n             }),\n         ) {\n-            sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n+            sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n         }\n         if archive.build(&dst) {\n             link_upstream(&dst);\n@@ -2822,11 +2826,30 @@ fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n                     // Implement the \"linker flavor\" part of -Zgcc-ld\n                     // by asking cc to use some kind of lld.\n                     cmd.arg(\"-fuse-ld=lld\");\n+\n                     if !flavor.is_gnu() {\n                         // Tell clang to use a non-default LLD flavor.\n                         // Gcc doesn't understand the target option, but we currently assume\n                         // that gcc is not used for Apple and Wasm targets (#97402).\n-                        cmd.arg(format!(\"--target={}\", sess.target.llvm_target));\n+                        //\n+                        // Note that we don't want to do that by default on macOS: e.g. passing a\n+                        // 10.7 target to LLVM works, but not to recent versions of clang/macOS, as\n+                        // shown in issue #101653 and the discussion in PR #101792.\n+                        //\n+                        // It could be required in some cases of cross-compiling with\n+                        // `-Zgcc-ld=lld`, but this is generally unspecified, and we don't know\n+                        // which specific versions of clang, macOS SDK, host and target OS\n+                        // combinations impact us here.\n+                        //\n+                        // So we do a simple first-approximation until we know more of what the\n+                        // Apple targets require (and which would be handled prior to hitting this\n+                        // `-Zgcc-ld=lld` codepath anyway), but the expectation is that until then\n+                        // this should be manually passed if needed. We specify the target when\n+                        // targeting a different linker flavor on macOS, and that's also always\n+                        // the case when targeting WASM.\n+                        if sess.target.linker_flavor != sess.host.linker_flavor {\n+                            cmd.arg(format!(\"--target={}\", sess.target.llvm_target));\n+                        }\n                     }\n                 }\n             }"}, {"sha": "7aadcdd222877478e422c82843a7aba4e8fd7d1c", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1002,7 +1002,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+    drop(link::each_linked_rlib(crate_info, None, &mut |cnum, path| {\n         if link::ignored_for_lto(sess, crate_info, cnum) {\n             return;\n         }"}, {"sha": "d318c15d34221231ef8843f97083094d054edb87", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -5,6 +5,7 @@ use crate::back::write::{\n     submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm, ComputedLtoType, OngoingCodegen,\n };\n use crate::common::{IntPredicate, RealPredicate, TypeKind};\n+use crate::errors;\n use crate::meth;\n use crate::mir;\n use crate::mir::operand::OperandValue;\n@@ -451,10 +452,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let Some(llfn) = cx.declare_c_main(llfty) else {\n             // FIXME: We should be smart and show a better diagnostic here.\n             let span = cx.tcx().def_span(rust_main_def_id);\n-            cx.sess()\n-                .struct_span_err(span, \"entry symbol `main` declared multiple times\")\n-                .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n-                .emit();\n+            cx.sess().emit_err(errors::MultipleMainFunctions { span });\n             cx.sess().abort_if_errors();\n             bug!();\n         };\n@@ -595,8 +593,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 &metadata,\n                 &exported_symbols::metadata_symbol_name(tcx),\n             );\n-            if let Err(err) = std::fs::write(&file_name, data) {\n-                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n+            if let Err(error) = std::fs::write(&file_name, data) {\n+                tcx.sess.emit_fatal(errors::MetadataObjectFileWrite { error });\n             }\n             Some(CompiledModule {\n                 name: metadata_cgu_name,\n@@ -815,11 +813,7 @@ impl CrateInfo {\n         let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n         let windows_subsystem = subsystem.map(|subsystem| {\n             if subsystem != sym::windows && subsystem != sym::console {\n-                tcx.sess.fatal(&format!(\n-                    \"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                    subsystem\n-                ));\n+                tcx.sess.emit_fatal(errors::InvalidWindowsSubsystem { subsystem });\n             }\n             subsystem.to_string()\n         });"}, {"sha": "e1abb73a504a3bea8ce211910cc63bd15ffcbd75", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,10 +1,8 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_errors::struct_span_err;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n-use rustc_session::Session;\n use rustc_span::Span;\n \n use crate::base;\n@@ -193,10 +191,6 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n-    struct_span_err!(a, b, E0511, \"{}\", c).emit();\n-}\n-\n pub fn asm_const_to_str<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,"}, {"sha": "1599ccbb2594c747e7ef31495e0c2171f5c06417", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -93,6 +93,7 @@ fn push_debuginfo_type_name<'tcx>(\n                     Err(e) => {\n                         // Computing the layout can still fail here, e.g. if the target architecture\n                         // cannot represent the type. See https://github.com/rust-lang/rust/issues/94961.\n+                        // FIXME: migrate once `rustc_middle::mir::interpret::InterpError` is translatable.\n                         tcx.sess.fatal(&format!(\"{}\", e));\n                     }\n                 }"}, {"sha": "d81252653dfe8094d9aafcf505075acb60a5f33c", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 431, "deletions": 6, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -6,7 +6,9 @@ use rustc_errors::{\n     IntoDiagnosticArg,\n };\n use rustc_macros::Diagnostic;\n+use rustc_middle::ty::Ty;\n use rustc_span::{Span, Symbol};\n+use rustc_type_ir::FloatTy;\n use std::borrow::Cow;\n use std::io::Error;\n use std::path::{Path, PathBuf};\n@@ -444,12 +446,6 @@ pub struct LinkerFileStem;\n #[diag(codegen_ssa_static_library_native_artifacts)]\n pub struct StaticLibraryNativeArtifacts;\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_ssa_native_static_libs)]\n-pub struct NativeStaticLibs {\n-    pub arguments: String,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(codegen_ssa_link_script_unavailable)]\n pub struct LinkScriptUnavailable;\n@@ -555,3 +551,432 @@ pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_multiple_main_functions)]\n+#[help]\n+pub struct MultipleMainFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_metadata_object_file_write)]\n+pub struct MetadataObjectFileWrite {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_windows_subsystem)]\n+pub struct InvalidWindowsSubsystem {\n+    pub subsystem: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_erroneous_constant)]\n+pub struct ErroneousConstant {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_polymorphic_constant_too_generic)]\n+pub struct PolymorphicConstantTooGeneric {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_shuffle_indices_evaluation)]\n+pub struct ShuffleIndicesEvaluation {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_missing_memory_ordering)]\n+pub struct MissingMemoryOrdering;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_atomic_ordering)]\n+pub struct UnknownAtomicOrdering;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_atomic_compare_exchange)]\n+pub struct AtomicCompareExchange;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_atomic_operation)]\n+pub struct UnknownAtomicOperation;\n+\n+#[derive(Diagnostic)]\n+pub enum InvalidMonomorphization<'tcx> {\n+    #[diag(codegen_ssa_invalid_monomorphization_basic_integer_type, code = \"E0511\")]\n+    BasicIntegerType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_basic_float_type, code = \"E0511\")]\n+    BasicFloatType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_float_to_int_unchecked, code = \"E0511\")]\n+    FloatToIntUnchecked {\n+        #[primary_span]\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_floating_point_vector, code = \"E0511\")]\n+    FloatingPointVector {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        f_ty: FloatTy,\n+        in_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_floating_point_type, code = \"E0511\")]\n+    FloatingPointType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unrecognized_intrinsic, code = \"E0511\")]\n+    UnrecognizedIntrinsic {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_argument, code = \"E0511\")]\n+    SimdArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_input, code = \"E0511\")]\n+    SimdInput {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_first, code = \"E0511\")]\n+    SimdFirst {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_second, code = \"E0511\")]\n+    SimdSecond {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_third, code = \"E0511\")]\n+    SimdThird {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_return, code = \"E0511\")]\n+    SimdReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+    InvalidBitmask {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        mask_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+    ReturnLengthInputType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_second_argument_length, code = \"E0511\")]\n+    SecondArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_argument_length, code = \"E0511\")]\n+    ThirdArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+    ReturnIntegerType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+    SimdShuffle {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length, code = \"E0511\")]\n+    ReturnLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_element, code = \"E0511\")]\n+    ReturnElement {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_not_constant, code = \"E0511\")]\n+    ShuffleIndexNotConstant {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds, code = \"E0511\")]\n+    ShuffleIndexOutOfBounds {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+        total_len: u128,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_inserted_type, code = \"E0511\")]\n+    InsertedType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_type, code = \"E0511\")]\n+    ReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_return_type, code = \"E0511\")]\n+    ExpectedReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+    MismatchedLengths {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        m_len: u64,\n+        v_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mask_type, code = \"E0511\")]\n+    MaskType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_vector_argument, code = \"E0511\")]\n+    VectorArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cannot_return, code = \"E0511\")]\n+    CannotReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_element_type, code = \"E0511\")]\n+    ExpectedElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        second_arg: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        mutability: ExpectedPointerMutability,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_arg_element_type, code = \"E0511\")]\n+    ThirdArgElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        third_arg: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size, code = \"E0511\")]\n+    UnsupportedSymbolOfSize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        size: u64,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol, code = \"E0511\")]\n+    UnsupportedSymbol {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cast_fat_pointer, code = \"E0511\")]\n+    CastFatPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_pointer, code = \"E0511\")]\n+    ExpectedPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_usize, code = \"E0511\")]\n+    ExpectedUsize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+    UnsupportedCast {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+    UnsupportedOperation {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_vector_element_type, code = \"E0511\")]\n+    ExpectedVectorElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        vector_type: Ty<'tcx>,\n+    },\n+}\n+\n+pub enum ExpectedPointerMutability {\n+    Mut,\n+    Not,\n+}\n+\n+impl IntoDiagnosticArg for ExpectedPointerMutability {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        match self {\n+            ExpectedPointerMutability::Mut => DiagnosticArgValue::Str(Cow::Borrowed(\"*mut\")),\n+            ExpectedPointerMutability::Not => DiagnosticArgValue::Str(Cow::Borrowed(\"*_\")),\n+        }\n+    }\n+}"}, {"sha": "14fe84a146da0792144787ee67a46f049a46dfa9", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use crate::mir::operand::OperandRef;\n use crate::traits::*;\n use rustc_middle::mir;\n@@ -44,10 +45,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.cx.tcx().const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).map_err(|err| {\n             match err {\n                 ErrorHandled::Reported(_) => {\n-                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+                    self.cx.tcx().sess.emit_err(errors::ErroneousConstant { span: constant.span });\n                 }\n                 ErrorHandled::TooGeneric => {\n-                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n+                    self.cx\n+                        .tcx()\n+                        .sess\n+                        .diagnostic()\n+                        .emit_bug(errors::PolymorphicConstantTooGeneric { span: constant.span });\n                 }\n             }\n             err\n@@ -87,7 +92,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (llval, c.ty())\n             })\n             .unwrap_or_else(|_| {\n-                bx.tcx().sess.span_err(span, \"could not evaluate shuffle_indices at compile time\");\n+                bx.tcx().sess.emit_err(errors::ShuffleIndicesEvaluation { span });\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(ty);\n                 let llty = bx.backend_type(bx.layout_of(ty));"}, {"sha": "766dc74cbbb6a39e66dd5dbacd6c82b80a821125", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 52, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,7 +1,9 @@\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n use super::FunctionCx;\n-use crate::common::{span_invalid_monomorphization_error, IntPredicate};\n+use crate::common::IntPredicate;\n+use crate::errors;\n+use crate::errors::InvalidMonomorphization;\n use crate::glue;\n use crate::meth;\n use crate::traits::*;\n@@ -305,15 +307,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            bx.tcx().sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                name, ty\n-                            ),\n-                        );\n+                        bx.tcx().sess.emit_err(InvalidMonomorphization::BasicIntegerType { span, name, ty });\n                         return;\n                     }\n                 }\n@@ -329,45 +323,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            bx.tcx().sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic float type, found `{}`\",\n-                                name, arg_tys[0]\n-                            ),\n-                        );\n+                        bx.tcx().sess.emit_err(InvalidMonomorphization::BasicFloatType { span, name, ty: arg_tys[0] });\n                         return;\n                     }\n                 }\n             }\n \n             sym::float_to_int_unchecked => {\n                 if float_type_width(arg_tys[0]).is_none() {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                  intrinsic: expected basic float type, \\\n-                                  found `{}`\",\n-                            arg_tys[0]\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::FloatToIntUnchecked { span, ty: arg_tys[0] });\n                     return;\n                 }\n                 let Some((_width, signed)) = int_type_width_signed(ret_ty, bx.tcx()) else {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                    intrinsic:  expected basic integer type, \\\n-                                    found `{}`\",\n-                            ret_ty\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::FloatToIntUnchecked { span, ty: ret_ty });\n                     return;\n                 };\n                 if signed {\n@@ -402,7 +370,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 use crate::common::{AtomicRmwBinOp, SynchronizationScope};\n \n                 let Some((instruction, ordering)) = atomic.split_once('_') else {\n-                    bx.sess().fatal(\"Atomic intrinsic missing memory ordering\");\n+                    bx.sess().emit_fatal(errors::MissingMemoryOrdering);\n                 };\n \n                 let parse_ordering = |bx: &Bx, s| match s {\n@@ -412,25 +380,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     \"release\" => Release,\n                     \"acqrel\" => AcquireRelease,\n                     \"seqcst\" => SequentiallyConsistent,\n-                    _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n+                    _ => bx.sess().emit_fatal(errors::UnknownAtomicOrdering),\n                 };\n \n                 let invalid_monomorphization = |ty| {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\",\n-                            name, ty\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::BasicIntegerType { span, name, ty });\n                 };\n \n                 match instruction {\n                     \"cxchg\" | \"cxchgweak\" => {\n                         let Some((success, failure)) = ordering.split_once('_') else {\n-                            bx.sess().fatal(\"Atomic compare-exchange intrinsic missing failure memory ordering\");\n+                            bx.sess().emit_fatal(errors::AtomicCompareExchange);\n                         };\n                         let ty = substs.type_at(0);\n                         if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n@@ -529,7 +489,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             \"min\" => AtomicRmwBinOp::AtomicMin,\n                             \"umax\" => AtomicRmwBinOp::AtomicUMax,\n                             \"umin\" => AtomicRmwBinOp::AtomicUMin,\n-                            _ => bx.sess().fatal(\"unknown atomic operation\"),\n+                            _ => bx.sess().emit_fatal(errors::UnknownAtomicOperation),\n                         };\n \n                         let ty = substs.type_at(0);"}, {"sha": "0a90572d39e30cec6545b4124ea30dd5820e3cba", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -115,7 +115,7 @@ fn is_parent_const_stable_trait(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let local_def_id = def_id.expect_local();\n     let hir_id = tcx.local_def_id_to_hir_id(local_def_id);\n \n-    let Some(parent) = tcx.hir().find_parent_node(hir_id) else { return false };\n+    let Some(parent) = tcx.hir().opt_parent_id(hir_id) else { return false };\n     let parent_def = tcx.hir().get(parent);\n \n     if !matches!("}, {"sha": "ea2a4388b92f00296193d9403601669f9b5379cc", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -277,12 +277,12 @@ impl<Node: Idx> Dominators<Node> {\n     }\n \n     pub fn immediate_dominator(&self, node: Node) -> Node {\n-        assert!(self.is_reachable(node), \"node {:?} is not reachable\", node);\n+        assert!(self.is_reachable(node), \"node {node:?} is not reachable\");\n         self.immediate_dominators[node].unwrap()\n     }\n \n     pub fn dominators(&self, node: Node) -> Iter<'_, Node> {\n-        assert!(self.is_reachable(node), \"node {:?} is not reachable\", node);\n+        assert!(self.is_reachable(node), \"node {node:?} is not reachable\");\n         Iter { dominators: self, node: Some(node) }\n     }\n "}, {"sha": "c8e66eb672cc29b6a7b4dc670ae9e4d49ce7d3db", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -233,10 +233,9 @@ where\n             .map(G::Node::new)\n             .map(|node| match this.start_walk_from(node) {\n                 WalkReturn::Complete { scc_index } => scc_index,\n-                WalkReturn::Cycle { min_depth } => panic!(\n-                    \"`start_walk_node({:?})` returned cycle with depth {:?}\",\n-                    node, min_depth\n-                ),\n+                WalkReturn::Cycle { min_depth } => {\n+                    panic!(\"`start_walk_node({node:?})` returned cycle with depth {min_depth:?}\")\n+                }\n             })\n             .collect();\n \n@@ -272,8 +271,7 @@ where\n             NodeState::NotVisited => return None,\n \n             NodeState::InCycleWith { parent } => panic!(\n-                \"`find_state` returned `InCycleWith({:?})`, which ought to be impossible\",\n-                parent\n+                \"`find_state` returned `InCycleWith({parent:?})`, which ought to be impossible\"\n             ),\n         })\n     }\n@@ -369,7 +367,7 @@ where\n                     previous_node = previous;\n                 }\n                 // Only InCycleWith nodes were added to the reverse linked list.\n-                other => panic!(\"Invalid previous link while compressing cycle: {:?}\", other),\n+                other => panic!(\"Invalid previous link while compressing cycle: {other:?}\"),\n             }\n \n             debug!(\"find_state: parent_state = {:?}\", node_state);\n@@ -394,7 +392,7 @@ where\n                 // NotVisited can not be part of a cycle since it should\n                 // have instead gotten explored.\n                 NodeState::NotVisited | NodeState::InCycleWith { .. } => {\n-                    panic!(\"invalid parent state: {:?}\", node_state)\n+                    panic!(\"invalid parent state: {node_state:?}\")\n                 }\n             }\n         }"}, {"sha": "4b6aa116520df9f91ab1f98800c6d374dd631a6a", "filename": "compiler/rustc_data_structures/src/obligation_forest/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fgraphviz.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -30,7 +30,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         let counter = COUNTER.fetch_add(1, Ordering::AcqRel);\n \n-        let file_path = dir.as_ref().join(format!(\"{:010}_{}.gv\", counter, description));\n+        let file_path = dir.as_ref().join(format!(\"{counter:010}_{description}.gv\"));\n \n         let mut gv_file = BufWriter::new(File::create(file_path).unwrap());\n \n@@ -47,7 +47,7 @@ impl<'a, O: ForestObligation + 'a> dot::Labeller<'a> for &'a ObligationForest<O>\n     }\n \n     fn node_id(&self, index: &Self::Node) -> dot::Id<'_> {\n-        dot::Id::new(format!(\"obligation_{}\", index)).unwrap()\n+        dot::Id::new(format!(\"obligation_{index}\")).unwrap()\n     }\n \n     fn node_label(&self, index: &Self::Node) -> dot::LabelText<'_> {"}, {"sha": "393f173908128457c7f70f01c8eddbbc8240c7cf", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -545,7 +545,7 @@ impl SelfProfiler {\n         // length can behave as a source of entropy for heap addresses, when\n         // ASLR is disabled and the heap is otherwise determinic.\n         let pid: u32 = process::id();\n-        let filename = format!(\"{}-{:07}.rustc_profile\", crate_name, pid);\n+        let filename = format!(\"{crate_name}-{pid:07}.rustc_profile\");\n         let path = output_directory.join(&filename);\n         let profiler =\n             Profiler::with_counter(&path, measureme::counters::Counter::by_name(counter_name)?)?;"}, {"sha": "719e4e3d97443c937381903fb23e8bbb29eaa58f", "filename": "compiler/rustc_data_structures/src/small_c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -30,7 +30,7 @@ impl SmallCStr {\n             SmallVec::from_vec(data)\n         };\n         if let Err(e) = ffi::CStr::from_bytes_with_nul(&data) {\n-            panic!(\"The string \\\"{}\\\" cannot be converted into a CStr: {}\", s, e);\n+            panic!(\"The string \\\"{s}\\\" cannot be converted into a CStr: {e}\");\n         }\n         SmallCStr { data }\n     }\n@@ -39,7 +39,7 @@ impl SmallCStr {\n     pub fn new_with_nul(s: &str) -> SmallCStr {\n         let b = s.as_bytes();\n         if let Err(e) = ffi::CStr::from_bytes_with_nul(b) {\n-            panic!(\"The string \\\"{}\\\" cannot be converted into a CStr: {}\", s, e);\n+            panic!(\"The string \\\"{s}\\\" cannot be converted into a CStr: {e}\");\n         }\n         SmallCStr { data: SmallVec::from_slice(s.as_bytes()) }\n     }\n@@ -74,7 +74,7 @@ impl<'a> FromIterator<&'a str> for SmallCStr {\n             iter.into_iter().flat_map(|s| s.as_bytes()).copied().collect::<SmallVec<_>>();\n         data.push(0);\n         if let Err(e) = ffi::CStr::from_bytes_with_nul(&data) {\n-            panic!(\"The iterator {:?} cannot be converted into a CStr: {}\", data, e);\n+            panic!(\"The iterator {data:?} cannot be converted into a CStr: {e}\");\n         }\n         Self { data }\n     }"}, {"sha": "d1a99bcaeb75452a28b497c99f1bddddea8ecd3e", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -71,8 +71,7 @@ where\n         // This should return just one element, otherwise it's a bug\n         assert!(\n             filter.next().is_none(),\n-            \"Collection {:#?} should have just one matching element\",\n-            self\n+            \"Collection {self:#?} should have just one matching element\"\n         );\n         Some(value)\n     }"}, {"sha": "42c97cc6a9d7418be734945a66ed3009a5004337", "filename": "compiler/rustc_driver/src/args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fargs.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -25,7 +25,7 @@ pub fn arg_expand_all(at_args: &[String]) -> Vec<String> {\n             Ok(arg) => args.extend(arg),\n             Err(err) => rustc_session::early_error(\n                 rustc_session::config::ErrorOutputType::default(),\n-                &format!(\"Failed to load argument file: {}\", err),\n+                &format!(\"Failed to load argument file: {err}\"),\n             ),\n         }\n     }\n@@ -42,8 +42,8 @@ impl fmt::Display for Error {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Error::Utf8Error(None) => write!(fmt, \"Utf8 error\"),\n-            Error::Utf8Error(Some(path)) => write!(fmt, \"Utf8 error in {}\", path),\n-            Error::IOError(path, err) => write!(fmt, \"IO Error: {}: {}\", path, err),\n+            Error::Utf8Error(Some(path)) => write!(fmt, \"Utf8 error in {path}\"),\n+            Error::IOError(path, err) => write!(fmt, \"IO Error: {path}: {err}\"),\n         }\n     }\n }"}, {"sha": "3cbe0052359b332971a8e4638bc40821dc8c4b72", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -486,11 +486,8 @@ impl Compilation {\n \n fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     let upper_cased_code = code.to_ascii_uppercase();\n-    let normalised = if upper_cased_code.starts_with('E') {\n-        upper_cased_code\n-    } else {\n-        format!(\"E{0:0>4}\", code)\n-    };\n+    let normalised =\n+        if upper_cased_code.starts_with('E') { upper_cased_code } else { format!(\"E{code:0>4}\") };\n     match registry.try_find_description(&normalised) {\n         Ok(Some(description)) => {\n             let mut is_in_code_block = false;\n@@ -513,14 +510,14 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n             if io::stdout().is_terminal() {\n                 show_content_with_pager(&text);\n             } else {\n-                print!(\"{}\", text);\n+                print!(\"{text}\");\n             }\n         }\n         Ok(None) => {\n-            early_error(output, &format!(\"no extended information for {}\", code));\n+            early_error(output, &format!(\"no extended information for {code}\"));\n         }\n         Err(InvalidErrorCode) => {\n-            early_error(output, &format!(\"{} is not a valid error code\", code));\n+            early_error(output, &format!(\"{code} is not a valid error code\"));\n         }\n     }\n }\n@@ -552,7 +549,7 @@ fn show_content_with_pager(content: &str) {\n     // If pager fails for whatever reason, we should still print the content\n     // to standard output\n     if fallback_to_println {\n-        print!(\"{}\", content);\n+        print!(\"{content}\");\n     }\n }\n \n@@ -672,7 +669,7 @@ fn print_crate_info(\n                 );\n                 let id = rustc_session::output::find_crate_name(sess, attrs, input);\n                 if *req == PrintRequest::CrateName {\n-                    println!(\"{}\", id);\n+                    println!(\"{id}\");\n                     continue;\n                 }\n                 let crate_types = collect_crate_types(sess, attrs);\n@@ -704,7 +701,7 @@ fn print_crate_info(\n                         }\n \n                         if let Some(value) = value {\n-                            Some(format!(\"{}=\\\"{}\\\"\", name, value))\n+                            Some(format!(\"{name}=\\\"{value}\\\"\"))\n                         } else {\n                             Some(name.to_string())\n                         }\n@@ -713,7 +710,7 @@ fn print_crate_info(\n \n                 cfgs.sort();\n                 for cfg in cfgs {\n-                    println!(\"{}\", cfg);\n+                    println!(\"{cfg}\");\n                 }\n             }\n             CallingConventions => {\n@@ -739,7 +736,7 @@ fn print_crate_info(\n                     let stable = sess.target.options.supported_split_debuginfo.contains(split);\n                     let unstable_ok = sess.unstable_options();\n                     if stable || unstable_ok {\n-                        println!(\"{}\", split);\n+                        println!(\"{split}\");\n                     }\n                 }\n             }\n@@ -776,14 +773,14 @@ pub fn version_at_macro_invocation(\n ) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{} {}\", binary, version);\n+    println!(\"{binary} {version}\");\n \n     if verbose {\n-        println!(\"binary: {}\", binary);\n-        println!(\"commit-hash: {}\", commit_hash);\n-        println!(\"commit-date: {}\", commit_date);\n+        println!(\"binary: {binary}\");\n+        println!(\"commit-hash: {commit_hash}\");\n+        println!(\"commit-date: {commit_date}\");\n         println!(\"host: {}\", config::host_triple());\n-        println!(\"release: {}\", release);\n+        println!(\"release: {release}\");\n \n         let debug_flags = matches.opt_strs(\"Z\");\n         let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n@@ -1037,7 +1034,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n                 .map(|&(name, ..)| ('C', name))\n                 .chain(Z_OPTIONS.iter().map(|&(name, ..)| ('Z', name)))\n                 .find(|&(_, name)| *opt == name.replace('_', \"-\"))\n-                .map(|(flag, _)| format!(\"{}. Did you mean `-{} {}`?\", e, flag, opt)),\n+                .map(|(flag, _)| format!(\"{e}. Did you mean `-{flag} {opt}`?\")),\n             _ => None,\n         };\n         early_error(ErrorOutputType::default(), &msg.unwrap_or_else(|| e.to_string()));\n@@ -1148,7 +1145,7 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n             } else {\n                 result.push(a.to_string());\n                 match ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.iter().find(|s| option == **s) {\n-                    Some(s) => result.push(format!(\"{}=[REDACTED]\", s)),\n+                    Some(s) => result.push(format!(\"{s}=[REDACTED]\")),\n                     None => result.push(content),\n                 }\n             }\n@@ -1246,7 +1243,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     let mut xs: Vec<Cow<'static, str>> = vec![\n         \"the compiler unexpectedly panicked. this is a bug.\".into(),\n-        format!(\"we would appreciate a bug report: {}\", bug_report_url).into(),\n+        format!(\"we would appreciate a bug report: {bug_report_url}\").into(),\n         format!(\n             \"rustc {} running on {}\",\n             util::version_str!().unwrap_or(\"unknown_version\"),\n@@ -1379,7 +1376,7 @@ pub fn main() -> ! {\n                 arg.into_string().unwrap_or_else(|arg| {\n                     early_error(\n                         ErrorOutputType::default(),\n-                        &format!(\"argument {} is not valid Unicode: {:?}\", i, arg),\n+                        &format!(\"argument {i} is not valid Unicode: {arg:?}\"),\n                     )\n                 })\n             })"}, {"sha": "b2451bc730f79f7eb1ddea06cf54708d1dc24f52", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -360,7 +360,7 @@ fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n \n fn write_or_print(out: &str, ofile: Option<&Path>, sess: &Session) {\n     match ofile {\n-        None => print!(\"{}\", out),\n+        None => print!(\"{out}\"),\n         Some(p) => {\n             if let Err(e) = std::fs::write(p, out) {\n                 sess.emit_fatal(UnprettyDumpFail {\n@@ -402,7 +402,7 @@ pub fn print_after_parsing(\n         }\n         AstTree(PpAstTreeMode::Normal) => {\n             debug!(\"pretty printing AST tree\");\n-            format!(\"{:#?}\", krate)\n+            format!(\"{krate:#?}\")\n         }\n         _ => unreachable!(),\n     };\n@@ -446,7 +446,7 @@ pub fn print_after_hir_lowering<'tcx>(\n \n         AstTree(PpAstTreeMode::Expanded) => {\n             debug!(\"pretty-printing expanded AST\");\n-            format!(\"{:#?}\", krate)\n+            format!(\"{krate:#?}\")\n         }\n \n         Hir(s) => call_with_pp_support_hir(&s, tcx, move |annotation, hir_map| {"}, {"sha": "76d5da19399ed9bb58776ed01b066ad90e3496d2", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -579,8 +579,7 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0300, // unexpanded macro\n //  E0304, // expected signed integer constant\n //  E0305, // expected constant\n-    E0313, // lifetime of borrowed pointer outlives lifetime of captured\n-           // variable\n+//  E0313, // removed: found unreachable\n //  E0314, // closure outlives stack frame\n //  E0315, // cannot invoke closure outside of its lifetime\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums"}, {"sha": "ac78f66adada052ae5b3487fa532bb4b8f65874a", "filename": "compiler/rustc_error_codes/src/error_codes/E0015.md", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0015.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0015.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0015.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,5 +1,4 @@\n-A constant item was initialized with something that is not a constant\n-expression.\n+A non-`const` function was called in a `const` context.\n \n Erroneous code example:\n \n@@ -8,26 +7,20 @@ fn create_some() -> Option<u8> {\n     Some(1)\n }\n \n-const FOO: Option<u8> = create_some(); // error!\n+// error: cannot call non-const fn `create_some` in constants\n+const FOO: Option<u8> = create_some();\n ```\n \n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors.\n+All functions used in a `const` context (constant or static expression) must\n+be marked `const`.\n \n To fix this error, you can declare `create_some` as a constant function:\n \n ```\n-const fn create_some() -> Option<u8> { // declared as a const function\n+// declared as a `const` function:\n+const fn create_some() -> Option<u8> {\n     Some(1)\n }\n \n-const FOO: Option<u8> = create_some(); // ok!\n-\n-// These are also working:\n-struct Bar {\n-    x: u8,\n-}\n-\n-const OTHER_FOO: Option<u8> = Some(1);\n-const BAR: Bar = Bar {x: 1};\n+const FOO: Option<u8> = create_some(); // no error!\n ```"}, {"sha": "995d945f1589e0d16df7a12cc0e09b7573c6df93", "filename": "compiler/rustc_error_codes/src/error_codes/E0588.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0588.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0588.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0588.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -11,7 +11,7 @@ struct Aligned(i32);\n struct Packed(Aligned);\n ```\n \n-Just like you cannot have both `align` and `packed` representation hints on a\n+Just like you cannot have both `align` and `packed` representation hints on the\n same type, a `packed` type cannot contain another type with the `align`\n representation hint. However, you can do the opposite:\n "}, {"sha": "3891745b5008efaa8475462cdb2d21e050e29e84", "filename": "compiler/rustc_error_codes/src/error_codes/E0729.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0729.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,3 +1,5 @@\n+#### Note: this error code is no longer emitted by the compiler\n+\n Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\n since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\n checker for NLL uncovered some bugs in the old borrow checker, which in some"}, {"sha": "c8c7afb5f919632b8555682136978d0ea4dc4c99", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -157,8 +157,6 @@ codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n \n codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n \n-codegen_ssa_native_static_libs = native-static-libs: {$arguments}\n-\n codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n \n codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n@@ -194,3 +192,102 @@ codegen_ssa_unknown_archive_kind =\n     Don't know how to build archive of type: {$kind}\n \n codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n+codegen_ssa_multiple_main_functions = entry symbol `main` declared multiple times\n+    .help = did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\n+\n+codegen_ssa_metadata_object_file_write = error writing metadata object file: {$error}\n+\n+codegen_ssa_invalid_windows_subsystem = invalid windows subsystem `{$subsystem}`, only `windows` and `console` are allowed\n+\n+codegen_ssa_erroneous_constant = erroneous constant encountered\n+\n+codegen_ssa_shuffle_indices_evaluation = could not evaluate shuffle_indices at compile time\n+\n+codegen_ssa_missing_memory_ordering = Atomic intrinsic missing memory ordering\n+\n+codegen_ssa_unknown_atomic_ordering = unknown ordering in atomic intrinsic\n+\n+codegen_ssa_atomic_compare_exchange = Atomic compare-exchange intrinsic missing failure memory ordering\n+\n+codegen_ssa_unknown_atomic_operation = unknown atomic operation\n+\n+codegen_ssa_invalid_monomorphization_basic_integer_type = invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_basic_float_type = invalid monomorphization of `{$name}` intrinsic: expected basic float type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_float_to_int_unchecked = invalid monomorphization of `float_to_int_unchecked` intrinsic: expected basic float type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_floating_point_vector = invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$f_ty}` of floating-point vector `{$in_ty}`\n+\n+codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphization of `{$name}` intrinsic: `{$in_ty}` is not a floating-point type\n+\n+codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n+\n+codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n+\n+codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n+\n+codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type"}, {"sha": "c1cb07cf0dfe8f97a6b58e53ab6199d50cd8e0a4", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -172,3 +172,142 @@ infer_msl_unmet_req = because this has an unmet lifetime requirement\n infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n infer_suggest_add_let_for_letchains = consider adding `let`\n+\n+infer_explicit_lifetime_required_with_ident = explicit lifetime required in the type of `{$simple_ident}`\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_with_param_type = explicit lifetime required in parameter type\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_sugg_with_ident = add explicit lifetime `{$named}` to the type of `{$simple_ident}`\n+\n+infer_explicit_lifetime_required_sugg_with_param_type = add explicit lifetime `{$named}` to type\n+\n+infer_actual_impl_expl_expected_signature_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n+infer_actual_impl_expl_expected_passive_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_passive_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n+infer_actual_impl_expl_expected_other_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`\n+\n+infer_actual_impl_expl_but_actually_implements_trait = ...but it actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+infer_actual_impl_expl_but_actually_implemented_for_ty = ...but `{$trait_path}` is actually implemented for the type `{$ty}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+infer_actual_impl_expl_but_actually_ty_implements = ...but `{$ty}` actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+\n+infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n+    .label_satisfy = doesn't satisfy where-clause\n+    .label_where = due to a where-clause on `{$def_id}`...\n+    .label_dup = implementation of `{$trait_def_id}` is not general enough\n+\n+infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signature\n+    .found = found `{$found}`\n+    .expected = expected `{$expected}`\n+    .expected_found = expected signature `{$expected}`\n+               {\"   \"}found signature `{$found}`\n+\n+infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+infer_tid_consider_borrowing = consider borrowing this type parameter in the trait\n+infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+\n+infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s 'static` requirement\n+infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n+infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+\n+infer_but_calling_introduces = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$lifetime_kind ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{assoc_item}` introduces an implicit `'static` lifetime requirement\n+    .label1 = {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }\n+    .label2 = ...is used and required to live as long as `'static` here because of an implicit lifetime bound on the {$has_impl_path ->\n+        [named] `impl` of `{$impl_path}`\n+        *[anon] inherent `impl`\n+    }\n+\n+infer_but_needs_to_satisfy = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but it needs to satisfy a `'static` lifetime requirement\n+    .influencer = this data with {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }...\n+    .require = {$spans_empty ->\n+        *[true] ...is used and required to live as long as `'static` here\n+        [false] ...and is required to live as long as `'static` here\n+    }\n+    .used_here = ...is used here...\n+    .introduced_by_bound = 'static` lifetime requirement introduced by this bound\n+\n+infer_more_targeted = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{$ident}` introduces an implicit `'static` lifetime requirement\n+\n+infer_ril_introduced_here = `'static` requirement introduced here\n+infer_ril_introduced_by = requirement introduced by this return type\n+infer_ril_because_of = because of this returned expression\n+infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type"}, {"sha": "bc37d91a7c6afd5cdcec34daa242be14e090bcae", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -85,6 +85,7 @@ session_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float lite\n     .help = valid suffixes are `f32` and `f64`\n \n session_int_literal_too_large = integer literal is too large\n+    .note = value exceeds limit of `{$limit}`\n \n session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n     .help = valid widths are 8, 16, 32, 64 and 128"}, {"sha": "cadd53fbd8356b3409ec98e7d9eaac9cfb54fcc4", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -17,6 +17,7 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n unicode-width = \"0.1.4\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.9\""}, {"sha": "cbfee582d871f2c5925b0e8449e60dad19749212", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,7 +1,7 @@\n use crate::diagnostic::IntoDiagnosticArg;\n use crate::{\n     Diagnostic, DiagnosticId, DiagnosticMessage, DiagnosticStyledString, ErrorGuaranteed,\n-    SubdiagnosticMessage,\n+    ExplicitBug, SubdiagnosticMessage,\n };\n use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n@@ -12,6 +12,7 @@ use std::borrow::Cow;\n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n+use std::panic;\n use std::thread::panicking;\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n@@ -308,6 +309,58 @@ impl EmissionGuarantee for Noted {\n     }\n }\n \n+/// Marker type which enables implementation of `create_bug` and `emit_bug` functions for\n+/// bug struct diagnostics.\n+#[derive(Copy, Clone)]\n+pub struct Bug;\n+\n+impl<'a> DiagnosticBuilder<'a, Bug> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n+    pub(crate) fn new_bug(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Bug, None, message);\n+        Self::new_diagnostic_bug(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_bug(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+        debug!(\"Created new diagnostic bug\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for Bug {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+        // Then panic. No need to return the marker type.\n+        panic::panic_any(ExplicitBug);\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_bug(handler, msg)\n+    }\n+}\n+\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`]."}, {"sha": "794b6efcc2b246674b452ad0f4e3aa3e120b2b6a", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -9,6 +9,7 @@ use rustc_span::edition::Edition;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n+use rustc_type_ir as type_ir;\n use std::borrow::Cow;\n use std::fmt;\n use std::num::ParseIntError;\n@@ -170,6 +171,12 @@ impl IntoDiagnosticArg for ast::token::TokenKind {\n     }\n }\n \n+impl IntoDiagnosticArg for type_ir::FloatTy {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.name_str()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for Level {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(match self {"}, {"sha": "b4d23e96f8f45ca06a991bbfac73fa5622a0be41", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -978,6 +978,7 @@ impl Handler {\n         self.inner.borrow_mut().span_bug(span, msg)\n     }\n \n+    /// For documentation on this, see `Session::delay_span_bug`.\n     #[track_caller]\n     pub fn delay_span_bug(\n         &self,\n@@ -1132,6 +1133,20 @@ impl Handler {\n         self.create_fatal(fatal).emit()\n     }\n \n+    pub fn create_bug<'a>(\n+        &'a self,\n+        bug: impl IntoDiagnostic<'a, diagnostic_builder::Bug>,\n+    ) -> DiagnosticBuilder<'a, diagnostic_builder::Bug> {\n+        bug.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_bug<'a>(\n+        &'a self,\n+        bug: impl IntoDiagnostic<'a, diagnostic_builder::Bug>,\n+    ) -> diagnostic_builder::Bug {\n+        self.create_bug(bug).emit()\n+    }\n+\n     fn emit_diag_at_span(\n         &self,\n         mut diag: Diagnostic,\n@@ -1529,6 +1544,7 @@ impl HandlerInner {\n         self.emit_diagnostic(diag.set_span(sp));\n     }\n \n+    /// For documentation on this, see `Session::delay_span_bug`.\n     #[track_caller]\n     fn delay_span_bug(\n         &mut self,"}, {"sha": "f469b2daef5eb7cf767e6f272ea2d6c05dbbe29f", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -114,6 +114,12 @@ impl BestFailure {\n }\n \n impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    type Failure = (Token, usize, &'static str);\n+\n+    fn build_failure(tok: Token, position: usize, msg: &'static str) -> Self::Failure {\n+        (tok, position, msg)\n+    }\n+\n     fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n         if self.remaining_matcher.is_none()\n             || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n@@ -122,7 +128,7 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n         }\n     }\n \n-    fn after_arm(&mut self, result: &NamedParseResult) {\n+    fn after_arm(&mut self, result: &NamedParseResult<Self::Failure>) {\n         match result {\n             Success(_) => {\n                 // Nonterminal parser recovery might turn failed matches into successful ones,\n@@ -132,7 +138,7 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n                     \"should not collect detailed info for successful macro match\",\n                 );\n             }\n-            Failure(token, approx_position, msg) => {\n+            Failure((token, approx_position, msg)) => {\n                 debug!(?token, ?msg, \"a new failure of an arm\");\n \n                 if self\n@@ -175,6 +181,21 @@ impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n     }\n }\n \n+/// Currently used by macro_rules! compilation to extract a little information from the `Failure` case.\n+pub struct FailureForwarder;\n+\n+impl<'matcher> Tracker<'matcher> for FailureForwarder {\n+    type Failure = (Token, usize, &'static str);\n+\n+    fn build_failure(tok: Token, position: usize, msg: &'static str) -> Self::Failure {\n+        (tok, position, msg)\n+    }\n+\n+    fn description() -> &'static str {\n+        \"failure-forwarder\"\n+    }\n+}\n+\n pub(super) fn emit_frag_parse_err(\n     mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n     parser: &Parser<'_>,"}, {"sha": "2e199541b92b43c08f0387b84deef90e8275a2cd", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -305,13 +305,13 @@ enum EofMatcherPositions {\n }\n \n /// Represents the possible results of an attempted parse.\n-pub(crate) enum ParseResult<T> {\n+pub(crate) enum ParseResult<T, F> {\n     /// Parsed successfully.\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n     /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.\n     /// The usize is the approximate position of the token in the input token stream.\n-    Failure(Token, usize, &'static str),\n+    Failure(F),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n     ErrorReported(ErrorGuaranteed),\n@@ -320,7 +320,7 @@ pub(crate) enum ParseResult<T> {\n /// A `ParseResult` where the `Success` variant contains a mapping of\n /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n /// of metavars to the token trees they bind to.\n-pub(crate) type NamedParseResult = ParseResult<NamedMatches>;\n+pub(crate) type NamedParseResult<F> = ParseResult<NamedMatches, F>;\n \n /// Contains a mapping of `MacroRulesNormalizedIdent`s to `NamedMatch`es.\n /// This represents the mapping of metavars to the token trees they bind to.\n@@ -458,7 +458,7 @@ impl TtParser {\n         token: &Token,\n         approx_position: usize,\n         track: &mut T,\n-    ) -> Option<NamedParseResult> {\n+    ) -> Option<NamedParseResult<T::Failure>> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n         // modified if `token == Eof`.\n         let mut eof_mps = EofMatcherPositions::None;\n@@ -595,14 +595,14 @@ impl TtParser {\n                 EofMatcherPositions::Multiple => {\n                     Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n                 }\n-                EofMatcherPositions::None => Failure(\n+                EofMatcherPositions::None => Failure(T::build_failure(\n                     Token::new(\n                         token::Eof,\n                         if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n                     ),\n                     approx_position,\n                     \"missing tokens in macro arguments\",\n-                ),\n+                )),\n             })\n         } else {\n             None\n@@ -615,7 +615,7 @@ impl TtParser {\n         parser: &mut Cow<'_, Parser<'_>>,\n         matcher: &'matcher [MatcherLoc],\n         track: &mut T,\n-    ) -> NamedParseResult {\n+    ) -> NamedParseResult<T::Failure> {\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n         // `parse_tt_inner` then processes all of these possible matcher positions and produces\n@@ -648,11 +648,11 @@ impl TtParser {\n                 (0, 0) => {\n                     // There are no possible next positions AND we aren't waiting for the black-box\n                     // parser: syntax error.\n-                    return Failure(\n+                    return Failure(T::build_failure(\n                         parser.token.clone(),\n                         parser.approx_token_stream_pos(),\n                         \"no rules expected this token in macro call\",\n-                    );\n+                    ));\n                 }\n \n                 (_, 0) => {\n@@ -711,11 +711,11 @@ impl TtParser {\n         }\n     }\n \n-    fn ambiguity_error(\n+    fn ambiguity_error<F>(\n         &self,\n         matcher: &[MatcherLoc],\n         token_span: rustc_span::Span,\n-    ) -> NamedParseResult {\n+    ) -> NamedParseResult<F> {\n         let nts = self\n             .bb_mps\n             .iter()\n@@ -741,11 +741,11 @@ impl TtParser {\n         )\n     }\n \n-    fn nameize<I: Iterator<Item = NamedMatch>>(\n+    fn nameize<I: Iterator<Item = NamedMatch>, F>(\n         &self,\n         matcher: &[MatcherLoc],\n         mut res: I,\n-    ) -> NamedParseResult {\n+    ) -> NamedParseResult<F> {\n         // Make that each metavar has _exactly one_ binding. If so, insert the binding into the\n         // `NamedParseResult`. Otherwise, it's an error.\n         let mut ret_val = FxHashMap::default();"}, {"sha": "c0489f686336b2747c9252500425e451561a83b6", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -141,31 +141,40 @@ fn trace_macros_note(cx_expansions: &mut FxIndexMap<Span, Vec<String>>, sp: Span\n }\n \n pub(super) trait Tracker<'matcher> {\n+    /// The contents of `ParseResult::Failure`.\n+    type Failure;\n+\n+    /// Arm failed to match. If the token is `token::Eof`, it indicates an unexpected\n+    /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.\n+    /// The usize is the approximate position of the token in the input token stream.\n+    fn build_failure(tok: Token, position: usize, msg: &'static str) -> Self::Failure;\n+\n     /// This is called before trying to match next MatcherLoc on the current token.\n-    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc);\n+    fn before_match_loc(&mut self, _parser: &TtParser, _matcher: &'matcher MatcherLoc) {}\n \n     /// This is called after an arm has been parsed, either successfully or unsuccessfully. When this is called,\n     /// `before_match_loc` was called at least once (with a `MatcherLoc::Eof`).\n-    fn after_arm(&mut self, result: &NamedParseResult);\n+    fn after_arm(&mut self, _result: &NamedParseResult<Self::Failure>) {}\n \n     /// For tracing.\n     fn description() -> &'static str;\n \n-    fn recovery() -> Recovery;\n+    fn recovery() -> Recovery {\n+        Recovery::Forbidden\n+    }\n }\n \n /// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n pub(super) struct NoopTracker;\n \n impl<'matcher> Tracker<'matcher> for NoopTracker {\n-    fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n-    fn after_arm(&mut self, _: &NamedParseResult) {}\n+    type Failure = ();\n+\n+    fn build_failure(_tok: Token, _position: usize, _msg: &'static str) -> Self::Failure {}\n+\n     fn description() -> &'static str {\n         \"none\"\n     }\n-    fn recovery() -> Recovery {\n-        Recovery::Forbidden\n-    }\n }\n \n /// Expands the rules based macro defined by `lhses` and `rhses` for a given\n@@ -326,8 +335,8 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n \n                 return Ok((i, named_matches));\n             }\n-            Failure(_, reached_position, _) => {\n-                trace!(%reached_position, \"Failed to match arm, trying the next one\");\n+            Failure(_) => {\n+                trace!(\"Failed to match arm, trying the next one\");\n                 // Try the next arm.\n             }\n             Error(_, _) => {\n@@ -381,11 +390,13 @@ pub fn compile_declarative_macro(\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n     let tt_spec = Some(NonterminalKind::TT);\n \n-    // Parse the macro_rules! invocation\n-    let (macro_rules, body) = match &def.kind {\n-        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.tokens.clone()),\n+    let macro_def = match &def.kind {\n+        ast::ItemKind::MacroDef(def) => def,\n         _ => unreachable!(),\n     };\n+    let macro_rules = macro_def.macro_rules;\n+\n+    // Parse the macro_rules! invocation\n \n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n@@ -426,13 +437,32 @@ pub fn compile_declarative_macro(\n     // Convert it into `MatcherLoc` form.\n     let argument_gram = mbe::macro_parser::compute_locs(&argument_gram);\n \n-    let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n+    let create_parser = || {\n+        let body = macro_def.body.tokens.clone();\n+        Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS)\n+    };\n+\n+    let parser = create_parser();\n     let mut tt_parser =\n         TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n     let argument_map =\n         match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n             Success(m) => m,\n-            Failure(token, _, msg) => {\n+            Failure(()) => {\n+                // The fast `NoopTracker` doesn't have any info on failure, so we need to retry it with another one\n+                // that gives us the information we need.\n+                // For this we need to reclone the macro body as the previous parser consumed it.\n+                let retry_parser = create_parser();\n+\n+                let parse_result = tt_parser.parse_tt(\n+                    &mut Cow::Owned(retry_parser),\n+                    &argument_gram,\n+                    &mut diagnostics::FailureForwarder,\n+                );\n+                let Failure((token, _, msg)) = parse_result else {\n+                    unreachable!(\"matcher returned something other than Failure after retry\");\n+                };\n+\n                 let s = parse_failure_msg(&token);\n                 let sp = token.span.substitute_dummy(def.span);\n                 let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);"}, {"sha": "ad85231860d2de31a33af07eaf7a67bb163eedb5", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -70,7 +70,7 @@ impl std::fmt::Debug for AttributeGate {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match *self {\n             Self::Gated(ref stab, name, expl, _) => {\n-                write!(fmt, \"Gated({:?}, {}, {})\", stab, name, expl)\n+                write!(fmt, \"Gated({stab:?}, {name}, {expl})\")\n             }\n             Self::Ungated => write!(fmt, \"Ungated\"),\n         }"}, {"sha": "8e2a13a6c0ab1deed02aecbd473868ad1b65cf4e", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -120,7 +120,7 @@ fn find_lang_feature_issue(feature: Symbol) -> Option<NonZeroU32> {\n             .find(|t| t.name == feature);\n         match found {\n             Some(found) => found.issue,\n-            None => panic!(\"feature `{}` is not declared anywhere\", feature),\n+            None => panic!(\"feature `{feature}` is not declared anywhere\"),\n         }\n     }\n }"}, {"sha": "b70a55e89533524bf82f017529f7fb536d1811df", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -516,7 +516,7 @@ impl<'a> LabelText<'a> {\n         match *self {\n             LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n             EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(s)),\n-            HtmlStr(ref s) => format!(\"<{}>\", s),\n+            HtmlStr(ref s) => format!(\"<{s}>\"),\n         }\n     }\n \n@@ -622,7 +622,7 @@ where\n     if let Some(fontname) = options.iter().find_map(|option| {\n         if let RenderOption::Fontname(fontname) = option { Some(fontname) } else { None }\n     }) {\n-        font = format!(r#\"fontname=\"{}\"\"#, fontname);\n+        font = format!(r#\"fontname=\"{fontname}\"\"#);\n         graph_attrs.push(&font[..]);\n         content_attrs.push(&font[..]);\n     }\n@@ -635,8 +635,8 @@ where\n     if !(graph_attrs.is_empty() && content_attrs.is_empty()) {\n         writeln!(w, r#\"    graph[{}];\"#, graph_attrs.join(\" \"))?;\n         let content_attrs_str = content_attrs.join(\" \");\n-        writeln!(w, r#\"    node[{}];\"#, content_attrs_str)?;\n-        writeln!(w, r#\"    edge[{}];\"#, content_attrs_str)?;\n+        writeln!(w, r#\"    node[{content_attrs_str}];\"#)?;\n+        writeln!(w, r#\"    edge[{content_attrs_str}];\"#)?;\n     }\n \n     let mut text = Vec::new();\n@@ -649,7 +649,7 @@ where\n         write!(text, \"{}\", id.as_slice()).unwrap();\n \n         if !options.contains(&RenderOption::NoNodeLabels) {\n-            write!(text, \"[label={}]\", escaped).unwrap();\n+            write!(text, \"[label={escaped}]\").unwrap();\n         }\n \n         let style = g.node_style(n);\n@@ -678,7 +678,7 @@ where\n         write!(text, \"{} -> {}\", source_id.as_slice(), target_id.as_slice()).unwrap();\n \n         if !options.contains(&RenderOption::NoEdgeLabels) {\n-            write!(text, \"[label={}]\", escaped_label).unwrap();\n+            write!(text, \"[label={escaped_label}]\").unwrap();\n         }\n \n         let style = g.edge_style(e);"}, {"sha": "921039797869feca60ee20aee3677e578998b757", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -597,8 +597,7 @@ impl<Id> Res<Id> {\n     where\n         Id: Debug,\n     {\n-        self.opt_def_id()\n-            .unwrap_or_else(|| panic!(\"attempted .def_id() on invalid res: {:?}\", self))\n+        self.opt_def_id().unwrap_or_else(|| panic!(\"attempted .def_id() on invalid res: {self:?}\"))\n     }\n \n     /// Return `Some(..)` with the `DefId` of this `Res` if it has a ID, else `None`."}, {"sha": "21cf214e47c50d13535d11c2847b5ed4bce82e2a", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -53,9 +53,8 @@ impl DefPathTable {\n             //\n             // See the documentation for DefPathHash for more information.\n             panic!(\n-                \"found DefPathHash collision between {:?} and {:?}. \\\n-                    Compilation cannot continue.\",\n-                def_path1, def_path2\n+                \"found DefPathHash collision between {def_path1:?} and {def_path2:?}. \\\n+                    Compilation cannot continue.\"\n             );\n         }\n \n@@ -224,7 +223,7 @@ impl DefPath {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n         for component in &self.data {\n-            write!(s, \"::{}\", component).unwrap();\n+            write!(s, \"::{component}\").unwrap();\n         }\n \n         s\n@@ -240,7 +239,7 @@ impl DefPath {\n         for component in &self.data {\n             s.extend(opt_delimiter);\n             opt_delimiter = Some('-');\n-            write!(s, \"{}\", component).unwrap();\n+            write!(s, \"{component}\").unwrap();\n         }\n \n         s\n@@ -433,7 +432,7 @@ impl fmt::Display for DefPathData {\n         match self.name() {\n             DefPathDataName::Named(name) => f.write_str(name.as_str()),\n             // FIXME(#70334): this will generate legacy {{closure}}, {{impl}}, etc\n-            DefPathDataName::Anon { namespace } => write!(f, \"{{{{{}}}}}\", namespace),\n+            DefPathDataName::Anon { namespace } => write!(f, \"{{{{{namespace}}}}}\"),\n         }\n     }\n }"}, {"sha": "bc897ed8112e59e5659dde99527a1452abae6be2", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -3460,7 +3460,7 @@ impl<'hir> Node<'hir> {\n     /// ```ignore (illustrative)\n     /// ctor\n     ///     .ctor_hir_id()\n-    ///     .and_then(|ctor_id| tcx.hir().find(tcx.hir().get_parent_node(ctor_id)))\n+    ///     .and_then(|ctor_id| tcx.hir().find_parent(ctor_id))\n     ///     .and_then(|parent| parent.ident())\n     /// ```\n     pub fn ident(&self) -> Option<Ident> {"}, {"sha": "3b4add0cf4d40295f1de0d41e3cf8a7ee199fc76", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -119,7 +119,7 @@ impl HirId {\n \n impl fmt::Display for HirId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self)\n+        write!(f, \"{self:?}\")\n     }\n }\n "}, {"sha": "9a111cb8609fd33c1680051b16fa45a6fde6633e", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 85, "deletions": 39, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -682,7 +682,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::Binder::bind_with_vars(tcx.mk_trait_ref(trait_def_id, substs), bound_vars);\n \n         debug!(?poly_trait_ref, ?assoc_bindings);\n-        bounds.trait_bounds.push((poly_trait_ref, span, constness));\n+        bounds.push_trait_bound(tcx, poly_trait_ref, span, constness);\n \n         let mut dup_bindings = FxHashMap::default();\n         for binding in &assoc_bindings {\n@@ -853,18 +853,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Sets `implicitly_sized` to true on `Bounds` if necessary\n-    pub(crate) fn add_implicitly_sized<'hir>(\n+    pub(crate) fn add_implicitly_sized(\n         &self,\n-        bounds: &mut Bounds<'hir>,\n-        ast_bounds: &'hir [hir::GenericBound<'hir>],\n-        self_ty_where_predicates: Option<(LocalDefId, &'hir [hir::WherePredicate<'hir>])>,\n+        bounds: &mut Bounds<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n+        self_ty_where_predicates: Option<(LocalDefId, &'tcx [hir::WherePredicate<'tcx>])>,\n         span: Span,\n     ) {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n         let mut unbound = None;\n-        let mut search_bounds = |ast_bounds: &'hir [hir::GenericBound<'hir>]| {\n+        let mut search_bounds = |ast_bounds: &'tcx [hir::GenericBound<'tcx>]| {\n             for ab in ast_bounds {\n                 if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n                     if unbound.is_none() {\n@@ -912,7 +913,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // No lang item for `Sized`, so we can't add it as a bound.\n             return;\n         }\n-        bounds.implicitly_sized = Some(span);\n+        bounds.push_sized(tcx, self_ty, span);\n     }\n \n     /// This helper takes a *converted* parameter type (`param_ty`)\n@@ -963,10 +964,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n                 hir::GenericBound::Outlives(lifetime) => {\n                     let region = self.ast_region_to_region(lifetime, None);\n-                    bounds.region_bounds.push((\n-                        ty::Binder::bind_with_vars(region, bound_vars),\n+                    bounds.push_region_bound(\n+                        self.tcx(),\n+                        ty::Binder::bind_with_vars(\n+                            ty::OutlivesPredicate(param_ty, region),\n+                            bound_vars,\n+                        ),\n                         lifetime.ident.span,\n-                    ));\n+                    );\n                 }\n             }\n         }\n@@ -1199,17 +1204,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     (_, _) => {\n                         let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n                         let expected = def_kind.descr(assoc_item_def_id);\n-                        let reported = tcx\n-                            .sess\n-                            .struct_span_err(\n+                        let mut err = tcx.sess.struct_span_err(\n+                            binding.span,\n+                            &format!(\"expected {expected} bound, found {got}\"),\n+                        );\n+                        err.span_note(\n+                            tcx.def_span(assoc_item_def_id),\n+                            &format!(\"{expected} defined here\"),\n+                        );\n+\n+                        if let hir::def::DefKind::AssocConst = def_kind\n+                          && let Some(t) = term.ty() && (t.is_enum() || t.references_error())\n+                          && tcx.features().associated_const_equality {\n+                            err.span_suggestion(\n                                 binding.span,\n-                                &format!(\"expected {expected} bound, found {got}\"),\n-                            )\n-                            .span_note(\n-                                tcx.def_span(assoc_item_def_id),\n-                                &format!(\"{expected} defined here\"),\n-                            )\n-                            .emit();\n+                                \"if equating a const, try wrapping with braces\",\n+                                format!(\"{} = {{ const }}\", binding.item_name),\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                        let reported = err.emit();\n                         term = match def_kind {\n                             hir::def::DefKind::AssocTy => {\n                                 tcx.ty_error_with_guaranteed(reported).into()\n@@ -1225,13 +1239,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         };\n                     }\n                 }\n-                bounds.projection_bounds.push((\n-                    projection_ty.map_bound(|projection_ty| ty::ProjectionPredicate {\n-                        projection_ty,\n-                        term: term,\n-                    }),\n+                bounds.push_projection_bound(\n+                    tcx,\n+                    projection_ty\n+                        .map_bound(|projection_ty| ty::ProjectionPredicate { projection_ty, term }),\n                     binding.span,\n-                ));\n+                );\n             }\n             ConvertedBindingKind::Constraint(ast_bounds) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n@@ -1260,7 +1273,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn conv_object_ty_poly_trait_ref(\n         &self,\n         span: Span,\n-        trait_bounds: &[hir::PolyTraitRef<'_>],\n+        hir_trait_bounds: &[hir::PolyTraitRef<'_>],\n         lifetime: &hir::Lifetime,\n         borrowed: bool,\n         representation: DynKind,\n@@ -1270,7 +1283,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut bounds = Bounds::default();\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n-        for trait_bound in trait_bounds.iter().rev() {\n+        for trait_bound in hir_trait_bounds.iter().rev() {\n             if let GenericArgCountResult {\n                 correct:\n                     Err(GenericArgCountMismatch { invalid_args: cur_potential_assoc_types, .. }),\n@@ -1287,10 +1300,45 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n+        let mut trait_bounds = vec![];\n+        let mut projection_bounds = vec![];\n+        for (pred, span) in bounds.predicates() {\n+            let bound_pred = pred.kind();\n+            match bound_pred.skip_binder() {\n+                ty::PredicateKind::Clause(clause) => match clause {\n+                    ty::Clause::Trait(trait_pred) => {\n+                        assert_eq!(trait_pred.polarity, ty::ImplPolarity::Positive);\n+                        trait_bounds.push((\n+                            bound_pred.rebind(trait_pred.trait_ref),\n+                            span,\n+                            trait_pred.constness,\n+                        ));\n+                    }\n+                    ty::Clause::Projection(proj) => {\n+                        projection_bounds.push((bound_pred.rebind(proj), span));\n+                    }\n+                    ty::Clause::TypeOutlives(_) => {\n+                        // Do nothing, we deal with regions separately\n+                    }\n+                    ty::Clause::RegionOutlives(_) => bug!(),\n+                },\n+                ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::ObjectSafe(_)\n+                | ty::PredicateKind::ClosureKind(_, _, _)\n+                | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::Coerce(_)\n+                | ty::PredicateKind::ConstEvaluatable(_)\n+                | ty::PredicateKind::ConstEquate(_, _)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+                | ty::PredicateKind::Ambiguous => bug!(),\n+            }\n+        }\n+\n         // Expand trait aliases recursively and check that only one regular (non-auto) trait\n         // is used and no 'maybe' bounds are used.\n         let expanded_traits =\n-            traits::expand_trait_aliases(tcx, bounds.trait_bounds.iter().map(|&(a, b, _)| (a, b)));\n+            traits::expand_trait_aliases(tcx, trait_bounds.iter().map(|&(a, b, _)| (a, b)));\n+\n         let (mut auto_traits, regular_traits): (Vec<_>, Vec<_>) = expanded_traits\n             .filter(|i| i.trait_ref().self_ty().skip_binder() == dummy_self)\n             .partition(|i| tcx.trait_is_auto(i.trait_ref().def_id()));\n@@ -1327,8 +1375,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         if regular_traits.is_empty() && auto_traits.is_empty() {\n-            let trait_alias_span = bounds\n-                .trait_bounds\n+            let trait_alias_span = trait_bounds\n                 .iter()\n                 .map(|&(trait_ref, _, _)| trait_ref.def_id())\n                 .find(|&trait_ref| tcx.is_trait_alias(trait_ref))\n@@ -1359,8 +1406,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types: FxHashMap<Span, BTreeSet<DefId>> = FxHashMap::default();\n \n-        let regular_traits_refs_spans = bounds\n-            .trait_bounds\n+        let regular_traits_refs_spans = trait_bounds\n             .into_iter()\n             .filter(|(trait_ref, _, _)| !tcx.trait_is_auto(trait_ref.def_id()));\n \n@@ -1414,15 +1460,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // the discussion in #56288 for alternatives.\n                         if !references_self {\n                             // Include projections defined on supertraits.\n-                            bounds.projection_bounds.push((pred, span));\n+                            projection_bounds.push((pred, span));\n                         }\n                     }\n                     _ => (),\n                 }\n             }\n         }\n \n-        for (projection_bound, _) in &bounds.projection_bounds {\n+        for (projection_bound, _) in &projection_bounds {\n             for def_ids in associated_types.values_mut() {\n                 def_ids.remove(&projection_bound.projection_def_id());\n             }\n@@ -1431,7 +1477,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.complain_about_missing_associated_types(\n             associated_types,\n             potential_assoc_types,\n-            trait_bounds,\n+            hir_trait_bounds,\n         );\n \n         // De-duplicate auto traits so that, e.g., `dyn Trait + Send + Send` is the same as\n@@ -1473,7 +1519,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let substs = tcx.intern_substs(&substs[..]);\n \n                 let span = i.bottom().1;\n-                let empty_generic_args = trait_bounds.iter().any(|hir_bound| {\n+                let empty_generic_args = hir_trait_bounds.iter().any(|hir_bound| {\n                     hir_bound.trait_ref.path.res == Res::Def(DefKind::Trait, trait_ref.def_id)\n                         && hir_bound.span.contains(span)\n                 });\n@@ -1505,7 +1551,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n         });\n \n-        let existential_projections = bounds.projection_bounds.iter().map(|(bound, _)| {\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|mut b| {\n                 assert_eq!(b.projection_ty.self_ty(), dummy_self);\n \n@@ -2936,7 +2982,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), ident, .. }) =\n             hir.get(fn_hir_id) else { return None };\n         let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n-                hir.get(hir.get_parent_node(fn_hir_id)) else { bug!(\"ImplItem should have Impl parent\") };\n+                hir.get_parent(fn_hir_id) else { bug!(\"ImplItem should have Impl parent\") };\n \n         let trait_ref = self.instantiate_mono_trait_ref(\n             i.of_trait.as_ref()?,"}, {"sha": "0880c8c15f2e0592ead59099fd535d25fc645c7d", "filename": "compiler/rustc_hir_analysis/src/bounds.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,6 +1,7 @@\n //! Bounds are restrictions applied to some types after they've been converted into the\n //! `ty` form from the HIR.\n \n+use rustc_hir::LangItem;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_span::Span;\n \n@@ -15,73 +16,53 @@ use rustc_span::Span;\n ///           ^^^^^^^^^ bounding the type parameter `T`\n ///\n /// impl dyn Bar + Baz\n-///          ^^^^^^^^^ bounding the forgotten dynamic type\n+///          ^^^^^^^^^ bounding the type-erased dynamic type\n /// ```\n ///\n /// Our representation is a bit mixed here -- in some cases, we\n /// include the self type (e.g., `trait_bounds`) but in others we do not\n #[derive(Default, PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    /// A list of region bounds on the (implicit) self type. So if you\n-    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n-    /// the `T` is not explicitly included).\n-    pub region_bounds: Vec<(ty::Binder<'tcx, ty::Region<'tcx>>, Span)>,\n-\n-    /// A list of trait bounds. So if you had `T: Debug` this would be\n-    /// `T: Debug`. Note that the self-type is explicit here.\n-    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span, ty::BoundConstness)>,\n-\n-    /// A list of projection equality bounds. So if you had `T:\n-    /// Iterator<Item = u32>` this would include `<T as\n-    /// Iterator>::Item => u32`. Note that the self-type is explicit\n-    /// here.\n-    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n-\n-    /// `Some` if there is *no* `?Sized` predicate. The `span`\n-    /// is the location in the source of the `T` declaration which can\n-    /// be cited as the source of the `T: Sized` requirement.\n-    pub implicitly_sized: Option<Span>,\n+    pub predicates: Vec<(ty::Predicate<'tcx>, Span)>,\n }\n \n impl<'tcx> Bounds<'tcx> {\n-    /// Converts a bounds list into a flat set of predicates (like\n-    /// where-clauses). Because some of our bounds listings (e.g.,\n-    /// regions) don't include the self-type, you must supply the\n-    /// self-type here (the `param_ty` parameter).\n-    pub fn predicates<'out, 's>(\n-        &'s self,\n+    pub fn push_region_bound(\n+        &mut self,\n         tcx: TyCtxt<'tcx>,\n-        param_ty: Ty<'tcx>,\n-        // the output must live shorter than the duration of the borrow of self and 'tcx.\n-    ) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> + 'out\n-    where\n-        'tcx: 'out,\n-        's: 'out,\n-    {\n-        // If it could be sized, and is, add the `Sized` predicate.\n-        let sized_predicate = self.implicitly_sized.and_then(|span| {\n-            // FIXME: use tcx.at(span).mk_trait_ref(LangItem::Sized) here? This may make no-core code harder to write.\n-            let sized = tcx.lang_items().sized_trait()?;\n-            let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(sized, [param_ty]));\n-            Some((trait_ref.without_const().to_predicate(tcx), span))\n-        });\n+        region: ty::PolyTypeOutlivesPredicate<'tcx>,\n+        span: Span,\n+    ) {\n+        self.predicates.push((region.to_predicate(tcx), span));\n+    }\n \n-        let region_preds = self.region_bounds.iter().map(move |&(region_bound, span)| {\n-            let pred = region_bound\n-                .map_bound(|region_bound| ty::OutlivesPredicate(param_ty, region_bound))\n-                .to_predicate(tcx);\n-            (pred, span)\n-        });\n-        let trait_bounds =\n-            self.trait_bounds.iter().map(move |&(bound_trait_ref, span, constness)| {\n-                let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n-                (predicate, span)\n-            });\n-        let projection_bounds = self\n-            .projection_bounds\n-            .iter()\n-            .map(move |&(projection, span)| (projection.to_predicate(tcx), span));\n+    pub fn push_trait_bound(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        span: Span,\n+        constness: ty::BoundConstness,\n+    ) {\n+        self.predicates.push((trait_ref.with_constness(constness).to_predicate(tcx), span));\n+    }\n+\n+    pub fn push_projection_bound(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        projection: ty::PolyProjectionPredicate<'tcx>,\n+        span: Span,\n+    ) {\n+        self.predicates.push((projection.to_predicate(tcx), span));\n+    }\n+\n+    pub fn push_sized(&mut self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) {\n+        let sized_def_id = tcx.require_lang_item(LangItem::Sized, Some(span));\n+        let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [ty]));\n+        // Preferrable to put this obligation first, since we report better errors for sized ambiguity.\n+        self.predicates.insert(0, (trait_ref.without_const().to_predicate(tcx), span));\n+    }\n \n-        sized_predicate.into_iter().chain(region_preds).chain(trait_bounds).chain(projection_bounds)\n+    pub fn predicates(&self) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> + '_ {\n+        self.predicates.iter().cloned()\n     }\n }"}, {"sha": "0d3391bbc1efbabd36d80c1e846292189eb065de", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -270,8 +270,8 @@ fn compare_method_predicate_entailment<'tcx>(\n     let unnormalized_impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(unnormalized_impl_sig));\n \n     let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n-    let impl_fty = ocx.normalize(&norm_cause, param_env, unnormalized_impl_fty);\n-    debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n+    let impl_sig = ocx.normalize(&norm_cause, param_env, unnormalized_impl_sig);\n+    debug!(\"compare_impl_method: impl_fty={:?}\", impl_sig);\n \n     let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n     let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n@@ -294,18 +294,17 @@ fn compare_method_predicate_entailment<'tcx>(\n     // type would be more appropriate. In other places we have a `Vec<Span>`\n     // corresponding to their `Vec<Predicate>`, but we don't have that here.\n     // Fixing this would improve the output of test `issue-83765.rs`.\n-    let result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n+    let result = ocx.sup(&cause, param_env, trait_sig, impl_sig);\n \n     if let Err(terr) = result {\n-        debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n+        debug!(?impl_sig, ?trait_sig, ?terr, \"sub_types failed\");\n \n         let emitted = report_trait_method_mismatch(\n             &infcx,\n             cause,\n             terr,\n-            (trait_m, trait_fty),\n-            (impl_m, impl_fty),\n-            trait_sig,\n+            (trait_m, trait_sig),\n+            (impl_m, impl_sig),\n             impl_trait_ref,\n         );\n         return Err(emitted);\n@@ -484,7 +483,8 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n     let param_env = tcx.param_env(def_id);\n \n-    // First, check a few of the same thing as `compare_impl_method`, just so we don't ICE during substitutions later.\n+    // First, check a few of the same things as `compare_impl_method`,\n+    // just so we don't ICE during substitution later.\n     compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n     compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n     check_region_bounds_on_impl_item(tcx, impl_m, trait_m, true)?;\n@@ -577,14 +577,11 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     debug!(?trait_sig, ?impl_sig, \"equating function signatures\");\n \n-    let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n-    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n-\n     // Unify the whole function signature. We need to do this to fully infer\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n     // `compare_method_predicate_entailment`.\n-    match ocx.eq(&cause, param_env, trait_fty, impl_fty) {\n+    match ocx.eq(&cause, param_env, trait_sig, impl_sig) {\n         Ok(()) => {}\n         Err(terr) => {\n             // This function gets called during `compare_method_predicate_entailment` when normalizing a\n@@ -595,9 +592,8 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n                 infcx,\n                 cause,\n                 terr,\n-                (trait_m, trait_fty),\n-                (impl_m, impl_fty),\n-                trait_sig,\n+                (trait_m, trait_sig),\n+                (impl_m, impl_sig),\n                 impl_trait_ref,\n             );\n             return Err(emitted);\n@@ -771,9 +767,8 @@ fn report_trait_method_mismatch<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     mut cause: ObligationCause<'tcx>,\n     terr: TypeError<'tcx>,\n-    (trait_m, trait_fty): (&ty::AssocItem, Ty<'tcx>),\n-    (impl_m, impl_fty): (&ty::AssocItem, Ty<'tcx>),\n-    trait_sig: ty::FnSig<'tcx>,\n+    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> ErrorGuaranteed {\n     let tcx = infcx.tcx;\n@@ -858,10 +853,7 @@ fn report_trait_method_mismatch<'tcx>(\n         &mut diag,\n         &cause,\n         trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-        Some(infer::ValuePairs::Terms(ExpectedFound {\n-            expected: trait_fty.into(),\n-            found: impl_fty.into(),\n-        })),\n+        Some(infer::ValuePairs::Sigs(ExpectedFound { expected: trait_sig, found: impl_sig })),\n         terr,\n         false,\n         false,"}, {"sha": "969f7de51cebd4326f2c515648f6466f5e8485a8", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -97,21 +97,22 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n \n-    let assumed_wf_types = ocx.assumed_wf_types(param_env, span, body_def_id);\n-\n     let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n \n     if !tcx.features().trivial_bounds {\n         wfcx.check_false_global_bounds()\n     }\n     f(&mut wfcx);\n+\n+    let assumed_wf_types = wfcx.ocx.assumed_wf_types(param_env, span, body_def_id);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n+\n     let errors = wfcx.select_all_or_error();\n     if !errors.is_empty() {\n         infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return;\n     }\n \n-    let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n \n@@ -1489,54 +1490,38 @@ fn check_fn_or_method<'tcx>(\n     def_id: LocalDefId,\n ) {\n     let tcx = wfcx.tcx();\n-    let sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n+    let mut sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), sig);\n \n     // Normalize the input and output types one at a time, using a different\n     // `WellFormedLoc` for each. We cannot call `normalize_associated_types`\n     // on the entire `FnSig`, since this would use the same `WellFormedLoc`\n     // for each type, preventing the HIR wf check from generating\n     // a nice error message.\n-    let ty::FnSig { mut inputs_and_output, c_variadic, unsafety, abi } = sig;\n-    inputs_and_output = tcx.mk_type_list(inputs_and_output.iter().enumerate().map(|(i, ty)| {\n-        wfcx.normalize(\n-            span,\n-            Some(WellFormedLoc::Param {\n-                function: def_id,\n-                // Note that the `param_idx` of the output type is\n-                // one greater than the index of the last input type.\n-                param_idx: i.try_into().unwrap(),\n-            }),\n-            ty,\n-        )\n-    }));\n-    // Manually call `normalize_associated_types_in` on the other types\n-    // in `FnSig`. This ensures that if the types of these fields\n-    // ever change to include projections, we will start normalizing\n-    // them automatically.\n-    let sig = ty::FnSig {\n-        inputs_and_output,\n-        c_variadic: wfcx.normalize(span, None, c_variadic),\n-        unsafety: wfcx.normalize(span, None, unsafety),\n-        abi: wfcx.normalize(span, None, abi),\n-    };\n+    let arg_span =\n+        |idx| hir_decl.inputs.get(idx).map_or(hir_decl.output.span(), |arg: &hir::Ty<'_>| arg.span);\n+\n+    sig.inputs_and_output =\n+        tcx.mk_type_list(sig.inputs_and_output.iter().enumerate().map(|(idx, ty)| {\n+            wfcx.normalize(\n+                arg_span(idx),\n+                Some(WellFormedLoc::Param {\n+                    function: def_id,\n+                    // Note that the `param_idx` of the output type is\n+                    // one greater than the index of the last input type.\n+                    param_idx: idx.try_into().unwrap(),\n+                }),\n+                ty,\n+            )\n+        }));\n \n-    for (i, (&input_ty, ty)) in iter::zip(sig.inputs(), hir_decl.inputs).enumerate() {\n+    for (idx, ty) in sig.inputs_and_output.iter().enumerate() {\n         wfcx.register_wf_obligation(\n-            ty.span,\n-            Some(WellFormedLoc::Param { function: def_id, param_idx: i.try_into().unwrap() }),\n-            input_ty.into(),\n+            arg_span(idx),\n+            Some(WellFormedLoc::Param { function: def_id, param_idx: idx.try_into().unwrap() }),\n+            ty.into(),\n         );\n     }\n \n-    wfcx.register_wf_obligation(\n-        hir_decl.output.span(),\n-        Some(WellFormedLoc::Param {\n-            function: def_id,\n-            param_idx: sig.inputs().len().try_into().unwrap(),\n-        }),\n-        sig.output().into(),\n-    );\n-\n     check_where_clauses(wfcx, span, def_id);\n \n     check_return_position_impl_trait_in_trait_bounds(\n@@ -1912,7 +1897,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n             }\n             let pred = obligation.predicate;\n             // Match the existing behavior.\n-            if pred.is_global() && !pred.has_late_bound_regions() {\n+            if pred.is_global() && !pred.has_late_bound_vars() {\n                 let pred = self.normalize(span, None, pred);\n                 let hir_node = tcx.hir().find(self.body_id);\n "}, {"sha": "70cc15b2f8c543268f926a32ff79ea330acce294", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -21,7 +21,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n                 struct_span_err!(\n                     tcx.sess,\n-                    item.span,\n+                    tcx.def_span(def_id),\n                     E0199,\n                     \"implementing the trait `{}` is not unsafe\",\n                     trait_ref.print_only_trait_path()\n@@ -38,7 +38,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n                 struct_span_err!(\n                     tcx.sess,\n-                    item.span,\n+                    tcx.def_span(def_id),\n                     E0200,\n                     \"the trait `{}` requires an `unsafe impl` declaration\",\n                     trait_ref.print_only_trait_path()\n@@ -61,7 +61,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             (Unsafety::Normal, Some(attr_name), Unsafety::Normal, hir::ImplPolarity::Positive) => {\n                 struct_span_err!(\n                     tcx.sess,\n-                    item.span,\n+                    tcx.def_span(def_id),\n                     E0569,\n                     \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n                     attr_name"}, {"sha": "7afde550b42ad878d1e61bc299fdd8c041c27122", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 99, "deletions": 52, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -17,15 +17,16 @@\n use crate::astconv::AstConv;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::errors;\n+use hir::def::DefKind;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericParamKind, Node};\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n@@ -212,7 +213,7 @@ pub(crate) fn placeholder_type_error_diag<'tcx>(\n             is_fn = true;\n \n             // Check if parent is const or static\n-            let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n+            let parent_id = tcx.hir().parent_id(hir_ty.hir_id);\n             let parent_node = tcx.hir().get(parent_id);\n \n             is_const_or_static = matches!(\n@@ -1108,7 +1109,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), generics, .. }) => {\n             // Do not try to infer the return type for a impl method coming from a trait\n             if let Item(hir::Item { kind: ItemKind::Impl(i), .. }) =\n-                tcx.hir().get(tcx.hir().get_parent_node(hir_id))\n+                tcx.hir().get_parent(hir_id)\n                 && i.of_trait.is_some()\n             {\n                 <dyn AstConv<'_>>::ty_of_fn(\n@@ -1195,12 +1196,11 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n                 ty::ReErased => tcx.lifetimes.re_static,\n                 _ => r,\n             });\n-            let fn_sig = ty::Binder::dummy(fn_sig);\n \n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_ty(ty);\n             let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n-            let ret_ty = fn_sig.skip_binder().output();\n+            let ret_ty = fn_sig.output();\n             if ret_ty.is_suggestable(tcx, false) {\n                 diag.span_suggestion(\n                     ty.span,\n@@ -1223,26 +1223,26 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n                         Applicability::MachineApplicable,\n                     );\n                 }\n+            } else if let Some(sugg) = suggest_impl_trait(tcx, ret_ty, ty.span, hir_id, def_id) {\n+                diag.span_suggestion(\n+                    ty.span,\n+                    \"replace with an appropriate return type\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n             } else if ret_ty.is_closure() {\n-                // We're dealing with a closure, so we should suggest using `impl Fn` or trait bounds\n-                // to prevent the user from getting a papercut while trying to use the unique closure\n-                // syntax (e.g. `[closure@src/lib.rs:2:5: 2:9]`).\n                 diag.help(\"consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\");\n+            }\n+            // Also note how `Fn` traits work just in case!\n+            if ret_ty.is_closure() {\n                 diag.note(\n                     \"for more information on `Fn` traits and closure types, see \\\n                      https://doc.rust-lang.org/book/ch13-01-closures.html\",\n                 );\n-            } else if let Some(i_ty) = suggest_impl_iterator(tcx, ret_ty, ty.span, hir_id, def_id) {\n-                diag.span_suggestion(\n-                    ty.span,\n-                    \"replace with an appropriate return type\",\n-                    format!(\"impl Iterator<Item = {}>\", i_ty),\n-                    Applicability::MachineApplicable,\n-                );\n             }\n             diag.emit();\n \n-            fn_sig\n+            ty::Binder::dummy(fn_sig)\n         }\n         None => <dyn AstConv<'_>>::ty_of_fn(\n             icx,\n@@ -1256,47 +1256,94 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n     }\n }\n \n-fn suggest_impl_iterator<'tcx>(\n+fn suggest_impl_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ret_ty: Ty<'tcx>,\n     span: Span,\n     hir_id: hir::HirId,\n     def_id: LocalDefId,\n-) -> Option<Ty<'tcx>> {\n-    let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator) else { return None; };\n-    let Some(iterator_item) = tcx.get_diagnostic_item(sym::IteratorItem) else { return None; };\n-    if !tcx\n-        .infer_ctxt()\n-        .build()\n-        .type_implements_trait(iter_trait, [ret_ty], tcx.param_env(def_id))\n-        .must_apply_modulo_regions()\n-    {\n-        return None;\n-    }\n-    let infcx = tcx.infer_ctxt().build();\n-    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n-    // Find the type of `Iterator::Item`.\n-    let origin = TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n-    let ty_var = infcx.next_ty_var(origin);\n-    let projection = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Projection(\n-        ty::ProjectionPredicate {\n-            projection_ty: tcx.mk_alias_ty(iterator_item, tcx.mk_substs([ret_ty.into()].iter())),\n-            term: ty_var.into(),\n-        },\n-    )));\n-    // Add `<ret_ty as Iterator>::Item = _` obligation.\n-    ocx.register_obligation(crate::traits::Obligation::misc(\n-        tcx,\n-        span,\n-        hir_id,\n-        tcx.param_env(def_id),\n-        projection,\n-    ));\n-    if ocx.select_where_possible().is_empty()\n-        && let item_ty = infcx.resolve_vars_if_possible(ty_var)\n-        && item_ty.is_suggestable(tcx, false)\n-    {\n-        return Some(item_ty);\n+) -> Option<String> {\n+    let format_as_assoc: fn(_, _, _, _, _) -> _ =\n+        |tcx: TyCtxt<'tcx>,\n+         _: ty::SubstsRef<'tcx>,\n+         trait_def_id: DefId,\n+         assoc_item_def_id: DefId,\n+         item_ty: Ty<'tcx>| {\n+            let trait_name = tcx.item_name(trait_def_id);\n+            let assoc_name = tcx.item_name(assoc_item_def_id);\n+            Some(format!(\"impl {trait_name}<{assoc_name} = {item_ty}>\"))\n+        };\n+    let format_as_parenthesized: fn(_, _, _, _, _) -> _ =\n+        |tcx: TyCtxt<'tcx>,\n+         substs: ty::SubstsRef<'tcx>,\n+         trait_def_id: DefId,\n+         _: DefId,\n+         item_ty: Ty<'tcx>| {\n+            let trait_name = tcx.item_name(trait_def_id);\n+            let args_tuple = substs.type_at(1);\n+            let ty::Tuple(types) = *args_tuple.kind() else { return None; };\n+            if !types.is_suggestable(tcx, false) {\n+                return None;\n+            }\n+            let maybe_ret =\n+                if item_ty.is_unit() { String::new() } else { format!(\" -> {item_ty}\") };\n+            Some(format!(\n+                \"impl {trait_name}({}){maybe_ret}\",\n+                types.iter().map(|ty| ty.to_string()).collect::<Vec<_>>().join(\", \")\n+            ))\n+        };\n+\n+    for (trait_def_id, assoc_item_def_id, formatter) in [\n+        (\n+            tcx.get_diagnostic_item(sym::Iterator),\n+            tcx.get_diagnostic_item(sym::IteratorItem),\n+            format_as_assoc,\n+        ),\n+        (\n+            tcx.lang_items().future_trait(),\n+            tcx.get_diagnostic_item(sym::FutureOutput),\n+            format_as_assoc,\n+        ),\n+        (tcx.lang_items().fn_trait(), tcx.lang_items().fn_once_output(), format_as_parenthesized),\n+        (\n+            tcx.lang_items().fn_mut_trait(),\n+            tcx.lang_items().fn_once_output(),\n+            format_as_parenthesized,\n+        ),\n+        (\n+            tcx.lang_items().fn_once_trait(),\n+            tcx.lang_items().fn_once_output(),\n+            format_as_parenthesized,\n+        ),\n+    ] {\n+        let Some(trait_def_id) = trait_def_id else { continue; };\n+        let Some(assoc_item_def_id) = assoc_item_def_id else { continue; };\n+        if tcx.def_kind(assoc_item_def_id) != DefKind::AssocTy {\n+            continue;\n+        }\n+        let param_env = tcx.param_env(def_id);\n+        let infcx = tcx.infer_ctxt().build();\n+        let substs = ty::InternalSubsts::for_item(tcx, trait_def_id, |param, _| {\n+            if param.index == 0 { ret_ty.into() } else { infcx.var_for_def(span, param) }\n+        });\n+        if !infcx.type_implements_trait(trait_def_id, substs, param_env).must_apply_modulo_regions()\n+        {\n+            continue;\n+        }\n+        let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+        let item_ty = ocx.normalize(\n+            &ObligationCause::misc(span, hir_id),\n+            param_env,\n+            tcx.mk_projection(assoc_item_def_id, substs),\n+        );\n+        // FIXME(compiler-errors): We may benefit from resolving regions here.\n+        if ocx.select_where_possible().is_empty()\n+            && let item_ty = infcx.resolve_vars_if_possible(item_ty)\n+            && item_ty.is_suggestable(tcx, false)\n+            && let Some(sugg) = formatter(tcx, infcx.resolve_vars_if_possible(substs), trait_def_id, assoc_item_def_id, item_ty)\n+        {\n+            return Some(sugg);\n+        }\n     }\n     None\n }"}, {"sha": "96221c3e3d86e1326c0ab330f7c847b820bb8ec1", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -103,7 +103,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 // `min_const_generics`.\n                 Some(parent_def_id.to_def_id())\n             } else {\n-                let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n+                let parent_node = tcx.hir().get_parent(hir_id);\n                 match parent_node {\n                     // HACK(eddyb) this provides the correct generics for repeat\n                     // expressions' count (i.e. `N` in `[x; N]`), and explicit\n@@ -320,7 +320,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n \n     // provide junk type parameter defs for const blocks.\n     if let Node::AnonConst(_) = node {\n-        let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n+        let parent_node = tcx.hir().get_parent(hir_id);\n         if let Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) = parent_node {\n             params.push(ty::GenericParamDef {\n                 index: next_index(),"}, {"sha": "093e9560ccdfedc408aff716744dca3c48cc909a", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -28,7 +28,7 @@ fn associated_type_bounds<'tcx>(\n     let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n     let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n     // Associated types are implicitly sized unless a `?Sized` bound is found\n-    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, ast_bounds, None, span);\n+    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n \n     let trait_def_id = tcx.parent(assoc_item_def_id);\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -44,9 +44,7 @@ fn associated_type_bounds<'tcx>(\n         }\n     });\n \n-    let all_bounds = tcx\n-        .arena\n-        .alloc_from_iter(bounds.predicates(tcx, item_ty).into_iter().chain(bounds_from_parent));\n+    let all_bounds = tcx.arena.alloc_from_iter(bounds.predicates().chain(bounds_from_parent));\n     debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), all_bounds);\n     all_bounds\n }\n@@ -74,10 +72,10 @@ fn opaque_type_bounds<'tcx>(\n         let icx = ItemCtxt::new(tcx, opaque_def_id);\n         let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n-        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, ast_bounds, None, span);\n+        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n         debug!(?bounds);\n \n-        tcx.arena.alloc_from_iter(bounds.predicates(tcx, item_ty))\n+        tcx.arena.alloc_from_iter(bounds.predicates())\n     })\n }\n "}, {"sha": "35f10dc873745f59d4355f1ebe675890f468f0b7", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -682,7 +682,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     };\n                     let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                     // Ensure that the parent of the def is an item, not HRTB\n-                    let parent_id = self.tcx.hir().get_parent_node(hir_id);\n+                    let parent_id = self.tcx.hir().parent_id(hir_id);\n                     if !parent_id.is_owner() {\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -1195,8 +1195,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     // Fresh lifetimes in APIT used to be allowed in async fns and forbidden in\n                     // regular fns.\n                     if let Some(hir::PredicateOrigin::ImplTrait) = where_bound_origin\n-                        && let hir::LifetimeName::Param(_) = lifetime_ref.res\n-                        && lifetime_ref.is_anonymous()\n+                        && let hir::LifetimeName::Param(param_id) = lifetime_ref.res\n+                        && let Some(generics) = self.tcx.hir().get_generics(self.tcx.local_parent(param_id))\n+                        && let Some(param) = generics.params.iter().find(|p| p.def_id == param_id)\n+                        && param.is_elided_lifetime()\n                         && let hir::IsAsync::NotAsync = self.tcx.asyncness(lifetime_ref.hir_id.owner.def_id)\n                         && !self.tcx.features().anonymous_lifetime_in_impl_trait\n                     {"}, {"sha": "18fc43ce15cbd4794c5f9d84273a8a4f748ff72f", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -165,12 +165,13 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 <dyn AstConv<'_>>::add_implicitly_sized(\n                     &icx,\n                     &mut bounds,\n+                    param_ty,\n                     &[],\n                     Some((param.def_id, ast_generics.predicates)),\n                     param.span,\n                 );\n                 trace!(?bounds);\n-                predicates.extend(bounds.predicates(tcx, param_ty));\n+                predicates.extend(bounds.predicates());\n                 trace!(?predicates);\n             }\n             GenericParamKind::Const { .. } => {\n@@ -217,7 +218,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     &mut bounds,\n                     bound_vars,\n                 );\n-                predicates.extend(bounds.predicates(tcx, ty));\n+                predicates.extend(bounds.predicates());\n             }\n \n             hir::WherePredicate::RegionPredicate(region_pred) => {\n@@ -270,7 +271,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // We create bi-directional Outlives predicates between the original\n     // and the duplicated parameter, to ensure that they do not get out of sync.\n     if let Node::Item(&Item { kind: ItemKind::OpaqueTy(..), .. }) = node {\n-        let opaque_ty_id = tcx.hir().get_parent_node(hir_id);\n+        let opaque_ty_id = tcx.hir().parent_id(hir_id);\n         let opaque_ty_node = tcx.hir().get(opaque_ty_id);\n         let Node::Ty(&Ty { kind: TyKind::OpaqueDef(_, lifetimes, _), .. }) = opaque_ty_node else {\n             bug!(\"unexpected {opaque_ty_node:?}\")\n@@ -536,7 +537,7 @@ pub(super) fn super_predicates_that_define_assoc_type(\n             <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n         };\n \n-        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+        let superbounds1 = superbounds1.predicates();\n \n         // Convert any explicit superbounds in the where-clause,\n         // e.g., `trait Foo where Self: Bar`.\n@@ -745,5 +746,5 @@ fn predicates_from_bound<'tcx>(\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     let mut bounds = Bounds::default();\n     astconv.add_bounds(param_ty, [bound].into_iter(), &mut bounds, bound_vars);\n-    bounds.predicates(astconv.tcx(), param_ty).collect()\n+    bounds.predicates().collect()\n }"}, {"sha": "1f9a9f80302e3590957b9ef5a7d466ddfd860c1e", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -28,7 +28,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n         _ => return None,\n     };\n \n-    let parent_node_id = tcx.hir().get_parent_node(hir_id);\n+    let parent_node_id = tcx.hir().parent_id(hir_id);\n     let parent_node = tcx.hir().get(parent_node_id);\n \n     let (generics, arg_idx) = match parent_node {\n@@ -402,7 +402,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         }\n \n         Node::AnonConst(_) => {\n-            let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n+            let parent_node = tcx.hir().get_parent(hir_id);\n             match parent_node {\n                 Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n                 | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n@@ -445,7 +445,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         ..\n                     },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get(tcx.hir().get_parent_node(binding_id))\n+                    tcx.hir().get_parent(binding_id)\n                     && e.hir_id == hir_id =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n@@ -472,7 +472,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 Node::TypeBinding(\n                     binding @ &TypeBinding { hir_id: binding_id, gen_args, ref kind, .. },\n                 ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get(tcx.hir().get_parent_node(binding_id))\n+                    tcx.hir().get_parent(binding_id)\n                     && let Some((idx, _)) =\n                         gen_args.args.iter().enumerate().find(|(_, arg)| {\n                             if let GenericArg::Const(ct) = arg {"}, {"sha": "574b1e8b485afad6ffc8d1ada76b48f564d73786", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -597,11 +597,15 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                 let span = self.path_segment.ident.span;\n \n                 // insert a suggestion of the form \"Y<'a, 'b>\"\n-                let ident = self.path_segment.ident.name.to_ident_string();\n-                let sugg = format!(\"{}<{}>\", ident, suggested_args);\n+                let sugg = format!(\"<{}>\", suggested_args);\n                 debug!(\"sugg: {:?}\", sugg);\n \n-                err.span_suggestion_verbose(span, &msg, sugg, Applicability::HasPlaceholders);\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    &msg,\n+                    sugg,\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n \n             AngleBrackets::Available => {\n@@ -643,11 +647,15 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                 let span = self.path_segment.ident.span;\n \n                 // insert a suggestion of the form \"Y<T, U>\"\n-                let ident = self.path_segment.ident.name.to_ident_string();\n-                let sugg = format!(\"{}<{}>\", ident, suggested_args);\n+                let sugg = format!(\"<{}>\", suggested_args);\n                 debug!(\"sugg: {:?}\", sugg);\n \n-                err.span_suggestion_verbose(span, &msg, sugg, Applicability::HasPlaceholders);\n+                err.span_suggestion_verbose(\n+                    span.shrink_to_hi(),\n+                    &msg,\n+                    sugg,\n+                    Applicability::HasPlaceholders,\n+                );\n             }\n             AngleBrackets::Available => {\n                 let gen_args_span = self.gen_args.span().unwrap();\n@@ -716,7 +724,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n             num = num_trait_generics_except_self,\n         );\n \n-        if let Some(parent_node) = self.tcx.hir().find_parent_node(self.path_segment.hir_id)\n+        if let Some(parent_node) = self.tcx.hir().opt_parent_id(self.path_segment.hir_id)\n         && let Some(parent_node) = self.tcx.hir().find(parent_node)\n         && let hir::Node::Expr(expr) = parent_node {\n             match expr.kind {"}, {"sha": "3e3af8395a1119e65afb8a2286df07e9785e624b", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1268,15 +1268,15 @@ impl<'a> State<'a> {\n                 hir::InlineAsmOperand::In { reg, ref expr } => {\n                     s.word(\"in\");\n                     s.popen();\n-                    s.word(format!(\"{}\", reg));\n+                    s.word(format!(\"{reg}\"));\n                     s.pclose();\n                     s.space();\n                     s.print_expr(expr);\n                 }\n                 hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n                     s.word(if late { \"lateout\" } else { \"out\" });\n                     s.popen();\n-                    s.word(format!(\"{}\", reg));\n+                    s.word(format!(\"{reg}\"));\n                     s.pclose();\n                     s.space();\n                     match expr {\n@@ -1287,15 +1287,15 @@ impl<'a> State<'a> {\n                 hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n                     s.word(if late { \"inlateout\" } else { \"inout\" });\n                     s.popen();\n-                    s.word(format!(\"{}\", reg));\n+                    s.word(format!(\"{reg}\"));\n                     s.pclose();\n                     s.space();\n                     s.print_expr(expr);\n                 }\n                 hir::InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                     s.word(if late { \"inlateout\" } else { \"inout\" });\n                     s.popen();\n-                    s.word(format!(\"{}\", reg));\n+                    s.word(format!(\"{reg}\"));\n                     s.pclose();\n                     s.space();\n                     s.print_expr(in_expr);"}, {"sha": "b6f19d3cc684ae1d84fc97b0c1f3fd390af54975", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -224,14 +224,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut ret_span: MultiSpan = semi_span.into();\n         ret_span.push_span_label(\n             expr.span,\n-            \"this could be implicitly returned but it is a statement, not a \\\n-                            tail expression\",\n+            \"this could be implicitly returned but it is a statement, not a tail expression\",\n         );\n         ret_span.push_span_label(ret, \"the `match` arms can conform to this return type\");\n         ret_span.push_span_label(\n             semi_span,\n-            \"the `match` is a statement because of this semicolon, consider \\\n-                            removing it\",\n+            \"the `match` is a statement because of this semicolon, consider removing it\",\n         );\n         diag.span_note(ret_span, \"you might have meant to return the `match` expression\");\n         diag.tool_only_span_suggestion(\n@@ -289,15 +287,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, sp: Span) -> Option<(Span, String)> {\n         let node = {\n-            let rslt = self.tcx.hir().get_parent_node(self.tcx.hir().get_parent_node(hir_id));\n+            let rslt = self.tcx.hir().parent_id(self.tcx.hir().parent_id(hir_id));\n             self.tcx.hir().get(rslt)\n         };\n         if let hir::Node::Block(block) = node {\n             // check that the body's parent is an fn\n-            let parent = self\n-                .tcx\n-                .hir()\n-                .get(self.tcx.hir().get_parent_node(self.tcx.hir().get_parent_node(block.hir_id)));\n+            let parent = self.tcx.hir().get_parent(self.tcx.hir().parent_id(block.hir_id));\n             if let (Some(expr), hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })) =\n                 (&block.expr, parent)\n             {\n@@ -526,7 +521,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         None\n                     }\n                 })?;\n-                let opaque_ty = self.tcx.mk_opaque(rpit_def_id, substs);\n \n                 if !self.can_coerce(first_ty, expected) || !self.can_coerce(second_ty, expected) {\n                     return None;\n@@ -540,13 +534,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     {\n                         let pred = pred.kind().rebind(match pred.kind().skip_binder() {\n                             ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => {\n-                                assert_eq!(trait_pred.trait_ref.self_ty(), opaque_ty);\n+                                // FIXME(rpitit): This will need to be fixed when we move to associated types\n+                                assert!(matches!(\n+                                    *trait_pred.trait_ref.self_ty().kind(),\n+                                    ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n+                                    if def_id == rpit_def_id && substs == substs\n+                                ));\n                                 ty::PredicateKind::Clause(ty::Clause::Trait(\n                                     trait_pred.with_self_ty(self.tcx, ty),\n                                 ))\n                             }\n                             ty::PredicateKind::Clause(ty::Clause::Projection(mut proj_pred)) => {\n-                                assert_eq!(proj_pred.projection_ty.self_ty(), opaque_ty);\n+                                assert!(matches!(\n+                                    *proj_pred.projection_ty.self_ty().kind(),\n+                                    ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n+                                    if def_id == rpit_def_id && substs == substs\n+                                ));\n                                 proj_pred = proj_pred.with_self_ty(self.tcx, ty);\n                                 ty::PredicateKind::Clause(ty::Clause::Projection(proj_pred))\n                             }"}, {"sha": "2cb976f718c22b72d16640e6b98e9bace72c549f", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         callee_span: Span,\n     ) {\n         let hir = self.tcx.hir();\n-        let parent_hir_id = hir.get_parent_node(hir_id);\n+        let parent_hir_id = hir.parent_id(hir_id);\n         let parent_node = hir.get(parent_hir_id);\n         if let (\n             hir::Node::Expr(hir::Expr {\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             {\n                 // Actually need to unwrap a few more layers of HIR to get to\n                 // the _real_ closure...\n-                let async_closure = hir.get_parent_node(hir.get_parent_node(parent_hir_id));\n+                let async_closure = hir.parent_id(hir.parent_id(parent_hir_id));\n                 if let hir::Node::Expr(hir::Expr {\n                     kind: hir::ExprKind::Closure(&hir::Closure { fn_decl_span, .. }),\n                     ..\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call_expr: &'tcx hir::Expr<'tcx>,\n         callee_expr: &'tcx hir::Expr<'tcx>,\n     ) -> bool {\n-        let hir_id = self.tcx.hir().get_parent_node(call_expr.hir_id);\n+        let hir_id = self.tcx.hir().parent_id(call_expr.hir_id);\n         let parent_node = self.tcx.hir().get(hir_id);\n         if let (\n             hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Array(_), .. }),"}, {"sha": "3453da500b984f8f55f706d150d6d138efb0c575", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -13,14 +13,15 @@ use rustc_infer::infer::{InferOk, InferResult};\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TypeSuperVisitable, TypeVisitor};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use std::cmp;\n use std::iter;\n+use std::ops::ControlFlow;\n \n /// What signature do we *expect* the closure to have from context?\n #[derive(Debug, Clone, TypeFoldable, TypeVisitable)]\n@@ -54,7 +55,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // closure sooner rather than later, so first examine the expected\n         // type, and see if can glean a closure kind from there.\n         let (expected_sig, expected_kind) = match expected.to_option(self) {\n-            Some(ty) => self.deduce_expectations_from_expected_type(ty),\n+            Some(ty) => self.deduce_closure_signature(ty),\n             None => (None, None),\n         };\n         let body = self.tcx.hir().body(closure.body);\n@@ -162,13 +163,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Given the expected type, figures out what it can about this closure we\n     /// are about to type check:\n     #[instrument(skip(self), level = \"debug\")]\n-    fn deduce_expectations_from_expected_type(\n+    fn deduce_closure_signature(\n         &self,\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => self\n-                .deduce_signature_from_predicates(\n+                .deduce_closure_signature_from_predicates(\n+                    expected_ty,\n                     self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n                 ),\n             ty::Dynamic(ref object_type, ..) => {\n@@ -181,7 +183,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .and_then(|did| self.tcx.fn_trait_kind_from_def_id(did));\n                 (sig, kind)\n             }\n-            ty::Infer(ty::TyVar(vid)) => self.deduce_signature_from_predicates(\n+            ty::Infer(ty::TyVar(vid)) => self.deduce_closure_signature_from_predicates(\n+                self.tcx.mk_ty_var(self.root_var(vid)),\n                 self.obligations_for_self_ty(vid).map(|obl| (obl.predicate, obl.cause.span)),\n             ),\n             ty::FnPtr(sig) => {\n@@ -192,8 +195,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn deduce_signature_from_predicates(\n+    fn deduce_closure_signature_from_predicates(\n         &self,\n+        expected_ty: Ty<'tcx>,\n         predicates: impl DoubleEndedIterator<Item = (ty::Predicate<'tcx>, Span)>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let mut expected_sig = None;\n@@ -214,13 +218,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n-                expected_sig = self.normalize(\n+                let inferred_sig = self.normalize(\n                     obligation.cause.span,\n                     self.deduce_sig_from_projection(\n                     Some(obligation.cause.span),\n                         bound_predicate.rebind(proj_predicate),\n                     ),\n                 );\n+                // Make sure that we didn't infer a signature that mentions itself.\n+                // This can happen when we elaborate certain supertrait bounds that\n+                // mention projections containing the `Self` type. See #105401.\n+                struct MentionsTy<'tcx> {\n+                    expected_ty: Ty<'tcx>,\n+                }\n+                impl<'tcx> TypeVisitor<'tcx> for MentionsTy<'tcx> {\n+                    type BreakTy = ();\n+\n+                    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                        if t == self.expected_ty {\n+                            ControlFlow::BREAK\n+                        } else {\n+                            t.super_visit_with(self)\n+                        }\n+                    }\n+                }\n+                if inferred_sig.visit_with(&mut MentionsTy { expected_ty }).is_continue() {\n+                    expected_sig = inferred_sig;\n+                }\n             }\n \n             // Even if we can't infer the full signature, we may be able to"}, {"sha": "9e91a3f90764cf4c879d0f2f3b6043052baa0f10", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1547,7 +1547,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                         err.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n-                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n+                        let parent_id = fcx.tcx.hir().parent_id(blk_id);\n                         err = self.report_return_mismatched_types(\n                             cause,\n                             expected,\n@@ -1578,7 +1578,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             None,\n                         );\n                         if !fcx.tcx.features().unsized_locals {\n-                            let id = fcx.tcx.hir().get_parent_node(id);\n+                            let id = fcx.tcx.hir().parent_id(id);\n                             unsized_return = self.is_return_ty_unsized(fcx, id);\n                         }\n                     }\n@@ -1668,7 +1668,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let mut pointing_at_return_type = false;\n         let mut fn_output = None;\n \n-        let parent_id = fcx.tcx.hir().get_parent_node(id);\n+        let parent_id = fcx.tcx.hir().parent_id(id);\n         let parent = fcx.tcx.hir().get(parent_id);\n         if let Some(expr) = expression\n             && let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(&hir::Closure { body, .. }), .. }) = parent"}, {"sha": "f68a428d09ae3ba4b1d7f4e5043d7c0b71bc064c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 282, "deletions": 19, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,21 +1,26 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n use rustc_infer::infer::InferOk;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut};\n+use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n+use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n+use rustc_middle::ty::relate::TypeRelation;\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitable};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -40,7 +45,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_alternative_method_deref(err, expr, error);\n \n         // Use `||` to give these suggestions a precedence\n-        let _ = self.suggest_missing_parentheses(err, expr)\n+        let suggested = self.suggest_missing_parentheses(err, expr)\n             || self.suggest_remove_last_method_call(err, expr, expected)\n             || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n@@ -52,8 +57,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty)\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n+            || self.suggest_clone_for_ref(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected);\n+        if !suggested {\n+            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n+        }\n     }\n \n     pub fn emit_coerce_suggestions(\n@@ -75,6 +84,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n+        self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n     }\n \n     /// Requires that the two types unify, and prints an error message if\n@@ -205,13 +215,222 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n+    pub fn point_at_expr_source_of_inferred_type(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        found: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        let map = self.tcx.hir();\n+\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n+        let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n+        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n+        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = map.find_parent(pat.hir_id) else { return false; };\n+        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n+        if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n+            return false;\n+        }\n+\n+        // Locate all the usages of the relevant binding.\n+        struct FindExprs<'hir> {\n+            hir_id: hir::HirId,\n+            uses: Vec<&'hir hir::Expr<'hir>>,\n+        }\n+        impl<'v> Visitor<'v> for FindExprs<'v> {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n+                    && let hir::def::Res::Local(hir_id) = path.res\n+                    && hir_id == self.hir_id\n+                {\n+                    self.uses.push(ex);\n+                }\n+                hir::intravisit::walk_expr(self, ex);\n+            }\n+        }\n+\n+        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n+        let id = map.get_parent_item(hir_id);\n+        let hir_id: hir::HirId = id.into();\n+\n+        let Some(node) = map.find(hir_id) else { return false; };\n+        let Some(body_id) = node.body_id() else { return false; };\n+        let body = map.body(body_id);\n+        expr_finder.visit_expr(body.value);\n+        // Hack to make equality checks on types with inference variables and regions useful.\n+        let mut eraser = BottomUpFolder {\n+            tcx: self.tcx,\n+            lt_op: |_| self.tcx.lifetimes.re_erased,\n+            ct_op: |c| c,\n+            ty_op: |t| match *t.kind() {\n+                ty::Infer(ty::TyVar(vid)) => self.tcx.mk_ty_infer(ty::TyVar(self.root_var(vid))),\n+                ty::Infer(ty::IntVar(_)) => {\n+                    self.tcx.mk_ty_infer(ty::IntVar(ty::IntVid { index: 0 }))\n+                }\n+                ty::Infer(ty::FloatVar(_)) => {\n+                    self.tcx.mk_ty_infer(ty::FloatVar(ty::FloatVid { index: 0 }))\n+                }\n+                _ => t,\n+            },\n+        };\n+        let mut prev = eraser.fold_ty(ty);\n+        let mut prev_span = None;\n+\n+        for binding in expr_finder.uses {\n+            // In every expression where the binding is referenced, we will look at that\n+            // expression's type and see if it is where the incorrect found type was fully\n+            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n+            if let Some(hir::Node::Expr(expr)\n+            | hir::Node::Stmt(hir::Stmt {\n+                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n+                ..\n+            })) = &map.find_parent(binding.hir_id)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n+            {\n+                // We special case methods, because they can influence inference through the\n+                // call's arguments and we can provide a more explicit span.\n+                let sig = self.tcx.fn_sig(def_id);\n+                let def_self_ty = sig.input(0).skip_binder();\n+                let rcvr_ty = self.node_ty(rcvr.hir_id);\n+                // Get the evaluated type *after* calling the method call, so that the influence\n+                // of the arguments can be reflected in the receiver type. The receiver\n+                // expression has the type *before* theis analysis is done.\n+                let ty = match self.lookup_probe(\n+                    segment.ident,\n+                    rcvr_ty,\n+                    expr,\n+                    probe::ProbeScope::TraitsInScope,\n+                ) {\n+                    Ok(pick) => pick.self_ty,\n+                    Err(_) => rcvr_ty,\n+                };\n+                // Remove one layer of references to account for `&mut self` and\n+                // `&self`, so that we can compare it against the binding.\n+                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n+                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n+                    _ => (ty, def_self_ty),\n+                };\n+                let mut param_args = FxHashMap::default();\n+                let mut param_expected = FxHashMap::default();\n+                let mut param_found = FxHashMap::default();\n+                if self.can_eq(self.param_env, ty, found).is_ok() {\n+                    // We only point at the first place where the found type was inferred.\n+                    for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n+                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n+                            // We found an argument that references a type parameter in `Self`,\n+                            // so we assume that this is the argument that caused the found\n+                            // type, which we know already because of `can_eq` above was first\n+                            // inferred in this method call.\n+                            let arg = &args[i];\n+                            let arg_ty = self.node_ty(arg.hir_id);\n+                            err.span_label(\n+                                arg.span,\n+                                &format!(\n+                                    \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n+                                     inferred as `{ty}`\",\n+                                ),\n+                            );\n+                            param_args.insert(param_ty, (arg, arg_ty));\n+                        }\n+                    }\n+                }\n+\n+                // Here we find, for a type param `T`, the type that `T` is in the current\n+                // method call *and* in the original expected type. That way, we can see if we\n+                // can give any structured suggestion for the function argument.\n+                let mut c = CollectAllMismatches {\n+                    infcx: &self.infcx,\n+                    param_env: self.param_env,\n+                    errors: vec![],\n+                };\n+                let _ = c.relate(def_self_ty, ty);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_found.insert(error.expected, error.found);\n+                    }\n+                }\n+                c.errors = vec![];\n+                let _ = c.relate(def_self_ty, expected);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_expected.insert(error.expected, error.found);\n+                    }\n+                }\n+                for (param, (arg, arg_ty)) in param_args.iter() {\n+                    let Some(expected) = param_expected.get(param) else { continue; };\n+                    let Some(found) = param_found.get(param) else { continue; };\n+                    if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                    self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n+                }\n+\n+                let ty = eraser.fold_ty(ty);\n+                if ty.references_error() {\n+                    break;\n+                }\n+                if ty != prev\n+                    && param_args.is_empty()\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    err.span_label(\n+                        segment.ident.span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n+                    break;\n+                } else if !param_args.is_empty() {\n+                    break;\n+                }\n+                prev = ty;\n+            } else {\n+                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n+                if ty.references_error() {\n+                    break;\n+                }\n+                if ty != prev\n+                    && let Some(span) = prev_span\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    // We use the *previous* span because if the type is known *here* it means\n+                    // it was *evaluated earlier*. We don't do this for method calls because we\n+                    // evaluate the method's self type eagerly, but not in any other case.\n+                    err.span_label(\n+                        span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n+                    break;\n+                }\n+                prev = ty;\n+            }\n+            if binding.hir_id == expr.hir_id {\n+                // Do not look at expressions that come after the expression we were originally\n+                // evaluating and had a type error.\n+                break;\n+            }\n+            prev_span = Some(binding.span);\n+        }\n+        true\n+    }\n+\n     fn annotate_expected_due_to_let_ty(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n         error: Option<TypeError<'tcx>>,\n     ) {\n-        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let parent = self.tcx.hir().parent_id(expr.hir_id);\n         match (self.tcx.hir().find(parent), error) {\n             (Some(hir::Node::Local(hir::Local { ty: Some(ty), init: Some(init), .. })), _)\n                 if init.hir_id == expr.hir_id =>\n@@ -258,10 +477,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         hir::Path { res: hir::def::Res::Local(hir_id), .. },\n                     )) => {\n                         if let Some(hir::Node::Pat(pat)) = self.tcx.hir().find(*hir_id) {\n-                            let parent = self.tcx.hir().get_parent_node(pat.hir_id);\n                             primary_span = pat.span;\n                             secondary_span = pat.span;\n-                            match self.tcx.hir().find(parent) {\n+                            match self.tcx.hir().find_parent(pat.hir_id) {\n                                 Some(hir::Node::Local(hir::Local { ty: Some(ty), .. })) => {\n                                     primary_span = ty.span;\n                                     post_message = \" type\";\n@@ -326,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         error: Option<TypeError<'tcx>>,\n     ) {\n-        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let parent = self.tcx.hir().parent_id(expr.hir_id);\n         let Some(TypeError::Sorts(ExpectedFound { expected, .. })) = error else {return;};\n         let Some(hir::Node::Expr(hir::Expr {\n                     kind: hir::ExprKind::Assign(lhs, rhs, _), ..\n@@ -510,7 +728,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // Unroll desugaring, to make sure this works for `for` loops etc.\n                 loop {\n-                    parent = self.tcx.hir().get_parent_node(id);\n+                    parent = self.tcx.hir().parent_id(id);\n                     if let Some(parent_span) = self.tcx.hir().opt_span(parent) {\n                         if parent_span.find_ancestor_inside(expr.span).is_some() {\n                             // The parent node is part of the same span, so is the result of the\n@@ -790,12 +1008,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         };\n \n-        let local_parent = self.tcx.hir().get_parent_node(local_id);\n+        let local_parent = self.tcx.hir().parent_id(local_id);\n         let Some(Node::Param(hir::Param { hir_id: param_hir_id, .. })) = self.tcx.hir().find(local_parent) else {\n             return None;\n         };\n \n-        let param_parent = self.tcx.hir().get_parent_node(*param_hir_id);\n+        let param_parent = self.tcx.hir().parent_id(*param_hir_id);\n         let Some(Node::Expr(hir::Expr {\n             hir_id: expr_hir_id,\n             kind: hir::ExprKind::Closure(hir::Closure { fn_decl: closure_fn_decl, .. }),\n@@ -804,7 +1022,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         };\n \n-        let expr_parent = self.tcx.hir().get_parent_node(*expr_hir_id);\n+        let expr_parent = self.tcx.hir().parent_id(*expr_hir_id);\n         let hir = self.tcx.hir().find(expr_parent);\n         let closure_params_len = closure_fn_decl.inputs.len();\n         let (\n@@ -857,7 +1075,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => None,\n         }?;\n \n-        match hir.find(hir.get_parent_node(expr.hir_id))? {\n+        match hir.find_parent(expr.hir_id)? {\n             Node::ExprField(field) => {\n                 if field.ident.name == local.name && field.is_shorthand {\n                     return Some(local.name);\n@@ -883,7 +1101,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Returns whether the given expression is an `else if`.\n     pub(crate) fn is_else_if_block(&self, expr: &hir::Expr<'_>) -> bool {\n         if let hir::ExprKind::If(..) = expr.kind {\n-            let parent_id = self.tcx.hir().get_parent_node(expr.hir_id);\n+            let parent_id = self.tcx.hir().parent_id(expr.hir_id);\n             if let Some(Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::If(_, _, Some(else_expr)),\n                 ..\n@@ -1040,7 +1258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(hir::Node::Expr(hir::Expr {\n                             kind: hir::ExprKind::Assign(..),\n                             ..\n-                        })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n+                        })) = self.tcx.hir().find_parent(expr.hir_id)\n                         {\n                             if mutability.is_mut() {\n                                 // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n@@ -1162,7 +1380,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     // If we've reached our target type with just removing `&`, then just print now.\n-                    if steps == 0 {\n+                    if steps == 0 && !remove.trim().is_empty() {\n                         return Some((\n                             prefix_span,\n                             format!(\"consider removing the `{}`\", remove.trim()),\n@@ -1221,6 +1439,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             (prefix_span, format!(\"{}{}\", prefix, \"*\".repeat(steps)))\n                         };\n+                        if suggestion.trim().is_empty() {\n+                            return None;\n+                        }\n \n                         return Some((\n                             span,\n@@ -1267,9 +1488,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut sugg = vec![];\n \n-        if let Some(hir::Node::ExprField(field)) =\n-            self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n-        {\n+        if let Some(hir::Node::ExprField(field)) = self.tcx.hir().find_parent(expr.hir_id) {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n             if field.is_shorthand {\n                 // This is a field literal\n@@ -1625,7 +1844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             [start, end],\n             _,\n         ) = expr.kind else { return; };\n-        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let parent = self.tcx.hir().parent_id(expr.hir_id);\n         if let Some(hir::Node::ExprField(_)) = self.tcx.hir().find(parent) {\n             // Ignore `Foo { field: a..Default::default() }`\n             return;\n@@ -1673,4 +1892,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Applicability::MachineApplicable,\n         );\n     }\n+\n+    /// Identify when the type error is because `()` is found in a binding that was assigned a\n+    /// block without a tail expression.\n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        checked_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) {\n+        if !checked_ty.is_unit() {\n+            return;\n+        }\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind else { return; };\n+        let hir::def::Res::Local(hir_id) = path.res else { return; };\n+        let Some(hir::Node::Pat(pat)) = self.tcx.hir().find(hir_id) else {\n+            return;\n+        };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = self.tcx.hir().find_parent(pat.hir_id) else { return; };\n+        let hir::ExprKind::Block(block, None) = init.kind else { return; };\n+        if block.expr.is_some() {\n+            return;\n+        }\n+        let [.., stmt] = block.stmts else {\n+            err.span_label(block.span, \"this empty block is missing a tail expression\");\n+            return;\n+        };\n+        let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n+        let Some(ty) = self.node_ty_opt(tail_expr.hir_id) else { return; };\n+        if self.can_eq(self.param_env, expected_ty, ty).is_ok() {\n+            err.span_suggestion_short(\n+                stmt.span.with_lo(tail_expr.span.hi()),\n+                \"remove this semicolon\",\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            err.span_label(block.span, \"this block is missing a tail expression\");\n+        }\n+    }\n }"}, {"sha": "b08b22108c8ce899ac43859a95caf83919bbec6b", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -234,6 +234,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) => self.check_expr_path(qpath, expr, args),\n             _ => self.check_expr_kind(expr, expected),\n         });\n+        let ty = self.resolve_vars_if_possible(ty);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.kind {\n@@ -920,7 +921,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         original_expr_id: HirId,\n         then: impl FnOnce(&hir::Expr<'_>),\n     ) {\n-        let mut parent = self.tcx.hir().get_parent_node(original_expr_id);\n+        let mut parent = self.tcx.hir().parent_id(original_expr_id);\n         while let Some(node) = self.tcx.hir().find(parent) {\n             match node {\n                 hir::Node::Expr(hir::Expr {\n@@ -943,7 +944,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }) => {\n                     // Check if our original expression is a child of the condition of a while loop\n                     let expr_is_ancestor = std::iter::successors(Some(original_expr_id), |id| {\n-                        self.tcx.hir().find_parent_node(*id)\n+                        self.tcx.hir().opt_parent_id(*id)\n                     })\n                     .take_while(|id| *id != parent)\n                     .any(|id| id == expr.hir_id);\n@@ -959,7 +960,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 | hir::Node::TraitItem(_)\n                 | hir::Node::Crate(_) => break,\n                 _ => {\n-                    parent = self.tcx.hir().get_parent_node(parent);\n+                    parent = self.tcx.hir().parent_id(parent);\n                 }\n             }\n         }\n@@ -1083,7 +1084,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Do not suggest `if let x = y` as `==` is way more likely to be the intention.\n                 let hir = self.tcx.hir();\n                 if let hir::Node::Expr(hir::Expr { kind: ExprKind::If { .. }, .. }) =\n-                    hir.get(hir.get_parent_node(hir.get_parent_node(expr.hir_id)))\n+                    hir.get_parent(hir.parent_id(expr.hir_id))\n                 {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_lo(),\n@@ -2216,7 +2217,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span, None);\n                             return field_ty;\n                         }\n-                        private_candidate = Some((adjustments, base_def.did(), field_ty));\n+                        private_candidate = Some((adjustments, base_def.did()));\n                     }\n                 }\n                 ty::Tuple(tys) => {\n@@ -2239,12 +2240,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n \n-        if let Some((adjustments, did, field_ty)) = private_candidate {\n+        if let Some((adjustments, did)) = private_candidate {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n             self.ban_private_field_access(expr, base_ty, field, did);\n-            return field_ty;\n+            return self.tcx().ty_error();\n         }\n \n         if field.name == kw::Empty {\n@@ -2462,7 +2463,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.span_label(field.span, \"method, not a field\");\n         let expr_is_call =\n             if let hir::Node::Expr(hir::Expr { kind: ExprKind::Call(callee, _args), .. }) =\n-                self.tcx.hir().get(self.tcx.hir().get_parent_node(expr.hir_id))\n+                self.tcx.hir().get_parent(expr.hir_id)\n             {\n                 expr.hir_id == callee.hir_id\n             } else {"}, {"sha": "634688de01a656fbdddff66dfa2b3fda88bac9d8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1435,9 +1435,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn expr_in_place(&self, mut expr_id: hir::HirId) -> bool {\n         let mut contained_in_place = false;\n \n-        while let hir::Node::Expr(parent_expr) =\n-            self.tcx.hir().get(self.tcx.hir().get_parent_node(expr_id))\n-        {\n+        while let hir::Node::Expr(parent_expr) = self.tcx.hir().get_parent(expr_id) {\n             match &parent_expr.kind {\n                 hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {\n                     if lhs.hir_id == expr_id {"}, {"sha": "7d6b4aaebf4ea93c4313699c7d0208c065273088", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -473,38 +473,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call_expr: &hir::Expr<'tcx>,\n     ) {\n         // Next, let's construct the error\n-        let (error_span, full_call_span, ctor_of, is_method) = match &call_expr.kind {\n+        let (error_span, full_call_span, call_name, is_method) = match &call_expr.kind {\n             hir::ExprKind::Call(\n                 hir::Expr { hir_id, span, kind: hir::ExprKind::Path(qpath), .. },\n                 _,\n             ) => {\n                 if let Res::Def(DefKind::Ctor(of, _), _) =\n                     self.typeck_results.borrow().qpath_res(qpath, *hir_id)\n                 {\n-                    (call_span, *span, Some(of), false)\n+                    let name = match of {\n+                        CtorOf::Struct => \"struct\",\n+                        CtorOf::Variant => \"enum variant\",\n+                    };\n+                    (call_span, *span, name, false)\n                 } else {\n-                    (call_span, *span, None, false)\n+                    (call_span, *span, \"function\", false)\n                 }\n             }\n-            hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None, false),\n+            hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, \"function\", false),\n             hir::ExprKind::MethodCall(path_segment, _, _, span) => {\n                 let ident_span = path_segment.ident.span;\n                 let ident_span = if let Some(args) = path_segment.args {\n                     ident_span.with_hi(args.span_ext.hi())\n                 } else {\n                     ident_span\n                 };\n-                // methods are never ctors\n-                (*span, ident_span, None, true)\n+                (*span, ident_span, \"method\", true)\n             }\n             k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n         };\n         let args_span = error_span.trim_start(full_call_span).unwrap_or(error_span);\n-        let call_name = match ctor_of {\n-            Some(CtorOf::Struct) => \"struct\",\n-            Some(CtorOf::Variant) => \"enum variant\",\n-            None => \"function\",\n-        };\n \n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n@@ -690,8 +688,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err = tcx.sess.struct_span_err_with_code(\n                             full_call_span,\n                             &format!(\n-                                \"this {} takes {}{} but {} {} supplied\",\n-                                call_name,\n+                                \"{call_name} takes {}{} but {} {} supplied\",\n                                 if c_variadic { \"at least \" } else { \"\" },\n                                 potentially_plural_count(\n                                     formal_and_expected_inputs.len(),\n@@ -801,6 +798,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 full_call_span,\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n+            if let (Some(callee_ty), hir::ExprKind::MethodCall(_, rcvr, _, _)) =\n+                (callee_ty, &call_expr.kind)\n+            {\n+                // Type that would have accepted this argument if it hadn't been inferred earlier.\n+                // FIXME: We leave an inference variable for now, but it'd be nice to get a more\n+                // specific type to increase the accuracy of the diagnostic.\n+                let expected = self.infcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span: full_call_span,\n+                });\n+                self.point_at_expr_source_of_inferred_type(&mut err, rcvr, expected, callee_ty);\n+            }\n             // Call out where the function is defined\n             self.label_fn_like(\n                 &mut err,\n@@ -1803,7 +1812,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     hir_id: call_hir_id,\n                     span: call_span,\n                     ..\n-                }) = hir.get(hir.get_parent_node(expr.hir_id))\n+                }) = hir.get_parent(expr.hir_id)\n                     && callee.hir_id == expr.hir_id\n                 {\n                     if self.closure_span_overlaps_error(error, *call_span) {"}, {"sha": "236bdc60e677d8899dc0415b68d0fe206d5d89d0", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.typeck_results\n             .borrow()\n             .liberated_fn_sigs()\n-            .get(self.tcx.hir().get_parent_node(self.body_id))\n+            .get(self.tcx.hir().parent_id(self.body_id))\n             .copied()\n     }\n \n@@ -642,7 +642,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Check if the parent expression is a call to Pin::new.  If it\n                 // is and we were expecting a Box, ergo Pin<Box<expected>>, we\n                 // can suggest Box::pin.\n-                let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+                let parent = self.tcx.hir().parent_id(expr.hir_id);\n                 let Some(Node::Expr(Expr { kind: ExprKind::Call(fn_name, _), .. })) = self.tcx.hir().find(parent) else {\n                     return false;\n                 };\n@@ -1014,6 +1014,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub(crate) fn suggest_clone_for_ref(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expr_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if let ty::Ref(_, inner_ty, hir::Mutability::Not) = expr_ty.kind()\n+            && let Some(clone_trait_def) = self.tcx.lang_items().clone_trait()\n+            && expected_ty == *inner_ty\n+            && self\n+                .infcx\n+                .type_implements_trait(\n+                    clone_trait_def,\n+                    [self.tcx.erase_regions(expected_ty)],\n+                    self.param_env\n+                )\n+                .must_apply_modulo_regions()\n+          {\n+              diag.span_suggestion_verbose(\n+                  expr.span.shrink_to_hi(),\n+                  \"consider using clone here\",\n+                  \".clone()\",\n+                  Applicability::MachineApplicable,\n+              );\n+              return true;\n+          }\n+        false\n+    }\n+\n     pub(crate) fn suggest_copied_or_cloned(\n         &self,\n         diag: &mut Diagnostic,"}, {"sha": "472205be7b5e3e81a96f1438b97d6865a691786c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -140,7 +140,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         diag_expr_id: HirId,\n     ) {\n         let hir = self.tcx.hir();\n-        let parent = match hir.find_parent_node(place_with_id.hir_id) {\n+        let parent = match hir.opt_parent_id(place_with_id.hir_id) {\n             Some(parent) => parent,\n             None => place_with_id.hir_id,\n         };"}, {"sha": "99e09b86a232313d782be3a55be7ac67eb9fbe91", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -224,7 +224,7 @@ fn typeck_with_fallback<'tcx>(\n                     _ => None,\n                 })\n                 .unwrap_or_else(|| match tcx.hir().get(id) {\n-                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(id)) {\n+                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().parent_id(id)) {\n                         Node::Expr(&hir::Expr {\n                             kind: hir::ExprKind::ConstBlock(ref anon_const),\n                             ..\n@@ -240,10 +240,8 @@ fn typeck_with_fallback<'tcx>(\n                         }),\n                         Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n                         | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty = asm\n-                                .operands\n-                                .iter()\n-                                .filter_map(|(op, _op_sp)| match op {\n+                            let operand_ty =\n+                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n                                     hir::InlineAsmOperand::Const { anon_const }\n                                         if anon_const.hir_id == id =>\n                                     {\n@@ -259,8 +257,7 @@ fn typeck_with_fallback<'tcx>(\n                                         }))\n                                     }\n                                     _ => None,\n-                                })\n-                                .next();\n+                                });\n                             operand_ty.unwrap_or_else(fallback)\n                         }\n                         _ => fallback(),"}, {"sha": "d276bcdb81e3e68e726397420be8d55b0b77d5c5", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -57,7 +57,12 @@ pub enum MethodError<'tcx> {\n     PrivateMatch(DefKind, DefId, Vec<DefId>),\n \n     // Found a `Self: Sized` bound where `Self` is a trait object.\n-    IllegalSizedBound(Vec<DefId>, bool, Span),\n+    IllegalSizedBound {\n+        candidates: Vec<DefId>,\n+        needs_mut: bool,\n+        bound_span: Span,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+    },\n \n     // Found a match, but the return type is wrong\n     BadReturnType,\n@@ -112,7 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n-            Err(IllegalSizedBound(..)) => true,\n+            Err(IllegalSizedBound { .. }) => true,\n             Err(BadReturnType) => bug!(\"no return type expectations but got BadReturnType\"),\n         }\n     }\n@@ -236,7 +241,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     _ => Vec::new(),\n                 };\n \n-            return Err(IllegalSizedBound(candidates, needs_mut, span));\n+            return Err(IllegalSizedBound { candidates, needs_mut, bound_span: span, self_expr });\n         }\n \n         Ok(result.callee)"}, {"sha": "3d6c2119bea333e568dbd49f026bd343f1bdb32c", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -341,8 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Find an identifier with which this trait was imported (note that `_` doesn't count).\n         let any_id = import_items\n             .iter()\n-            .filter_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None })\n-            .next();\n+            .find_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None });\n         if let Some(any_id) = any_id {\n             if any_id.name == Empty {\n                 // Glob import, so just use its name."}, {"sha": "2daf1979ee5e69d51642a7588f38aa29d6a12272", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1111,7 +1111,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n             })\n-            .flat_map(|step| {\n+            .find_map(|step| {\n                 let InferOk { value: self_ty, obligations: _ } = self\n                     .fcx\n                     .probe_instantiate_query_response(\n@@ -1147,7 +1147,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         })\n                     })\n             })\n-            .next()\n     }\n \n     /// For each type `T` in the step list, this attempts to find a method where"}, {"sha": "536c4270659582b17f32581b0f7488f405cb2381", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 955, "deletions": 920, "changes": 1875, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn report_method_error(\n         &self,\n-        mut span: Span,\n+        span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n         source: SelfSource<'tcx>,\n@@ -114,923 +114,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        let report_candidates = |span: Span,\n-                                 err: &mut Diagnostic,\n-                                 sources: &mut Vec<CandidateSource>,\n-                                 sugg_span: Option<Span>| {\n-            sources.sort();\n-            sources.dedup();\n-            // Dynamic limit to avoid hiding just one candidate, which is silly.\n-            let limit = if sources.len() == 5 { 5 } else { 4 };\n-\n-            for (idx, source) in sources.iter().take(limit).enumerate() {\n-                match *source {\n-                    CandidateSource::Impl(impl_did) => {\n-                        // Provide the best span we can. Use the item, if local to crate, else\n-                        // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n-                            let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n-                            self.associated_value(impl_trait_ref.def_id, item_name)\n-                        }) else {\n-                            continue;\n-                        };\n-\n-                        let note_span = if item.def_id.is_local() {\n-                            Some(self.tcx.def_span(item.def_id))\n-                        } else if impl_did.is_local() {\n-                            Some(self.tcx.def_span(impl_did))\n-                        } else {\n-                            None\n-                        };\n-\n-                        let impl_ty = self.tcx.at(span).type_of(impl_did);\n-\n-                        let insertion = match self.tcx.impl_trait_ref(impl_did) {\n-                            None => String::new(),\n-                            Some(trait_ref) => format!(\n-                                \" of the trait `{}`\",\n-                                self.tcx.def_path_str(trait_ref.def_id)\n-                            ),\n-                        };\n-\n-                        let (note_str, idx) = if sources.len() > 1 {\n-                            (\n-                                format!(\n-                                    \"candidate #{} is defined in an impl{} for the type `{}`\",\n-                                    idx + 1,\n-                                    insertion,\n-                                    impl_ty,\n-                                ),\n-                                Some(idx + 1),\n-                            )\n-                        } else {\n-                            (\n-                                format!(\n-                                    \"the candidate is defined in an impl{} for the type `{}`\",\n-                                    insertion, impl_ty,\n-                                ),\n-                                None,\n-                            )\n-                        };\n-                        if let Some(note_span) = note_span {\n-                            // We have a span pointing to the method. Show note with snippet.\n-                            err.span_note(note_span, &note_str);\n-                        } else {\n-                            err.note(&note_str);\n-                        }\n-                        if let Some(sugg_span) = sugg_span\n-                            && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-                            let path = self.tcx.def_path_str(trait_ref.def_id);\n-\n-                            let ty = match item.kind {\n-                                ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n-                                ty::AssocKind::Fn => self\n-                                    .tcx\n-                                    .fn_sig(item.def_id)\n-                                    .inputs()\n-                                    .skip_binder()\n-                                    .get(0)\n-                                    .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n-                                    .copied()\n-                                    .unwrap_or(rcvr_ty),\n-                            };\n-                            print_disambiguation_help(\n-                                item_name,\n-                                args,\n-                                err,\n-                                path,\n-                                ty,\n-                                item.kind,\n-                                item.def_id,\n-                                sugg_span,\n-                                idx,\n-                                self.tcx.sess.source_map(),\n-                                item.fn_has_self_parameter,\n-                            );\n-                        }\n-                    }\n-                    CandidateSource::Trait(trait_did) => {\n-                        let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n-                        let item_span = self.tcx.def_span(item.def_id);\n-                        let idx = if sources.len() > 1 {\n-                            let msg = &format!(\n-                                \"candidate #{} is defined in the trait `{}`\",\n-                                idx + 1,\n-                                self.tcx.def_path_str(trait_did)\n-                            );\n-                            err.span_note(item_span, msg);\n-                            Some(idx + 1)\n-                        } else {\n-                            let msg = &format!(\n-                                \"the candidate is defined in the trait `{}`\",\n-                                self.tcx.def_path_str(trait_did)\n-                            );\n-                            err.span_note(item_span, msg);\n-                            None\n-                        };\n-                        if let Some(sugg_span) = sugg_span {\n-                            let path = self.tcx.def_path_str(trait_did);\n-                            print_disambiguation_help(\n-                                item_name,\n-                                args,\n-                                err,\n-                                path,\n-                                rcvr_ty,\n-                                item.kind,\n-                                item.def_id,\n-                                sugg_span,\n-                                idx,\n-                                self.tcx.sess.source_map(),\n-                                item.fn_has_self_parameter,\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-            if sources.len() > limit {\n-                err.note(&format!(\"and {} others\", sources.len() - limit));\n-            }\n-        };\n-\n         let sugg_span = if let SelfSource::MethodCall(expr) = source {\n             // Given `foo.bar(baz)`, `expr` is `bar`, but we want to point to the whole thing.\n-            self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id)).span\n+            self.tcx.hir().expect_expr(self.tcx.hir().parent_id(expr.hir_id)).span\n         } else {\n             span\n         };\n \n         match error {\n-            MethodError::NoMatch(NoMatchData {\n-                mut static_candidates,\n-                unsatisfied_predicates,\n-                out_of_scope_traits,\n-                lev_candidate,\n-                mode,\n-            }) => {\n-                let tcx = self.tcx;\n-\n-                let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n-                let is_method = mode == Mode::MethodCall;\n-                let item_kind = if is_method {\n-                    \"method\"\n-                } else if rcvr_ty.is_enum() {\n-                    \"variant or associated item\"\n-                } else {\n-                    match (item_name.as_str().chars().next(), rcvr_ty.is_fresh_ty()) {\n-                        (Some(name), false) if name.is_lowercase() => \"function or associated item\",\n-                        (Some(_), false) => \"associated item\",\n-                        (Some(_), true) | (None, false) => \"variant or associated item\",\n-                        (None, true) => \"variant\",\n-                    }\n-                };\n-\n-                if self.suggest_wrapping_range_with_parens(\n-                    tcx, rcvr_ty, source, span, item_name, &ty_str,\n-                ) || self.suggest_constraining_numerical_ty(\n-                    tcx, rcvr_ty, source, span, item_kind, item_name, &ty_str,\n-                ) {\n-                    return None;\n-                }\n-                span = item_name.span;\n-\n-                // Don't show generic arguments when the method can't be found in any implementation (#81576).\n-                let mut ty_str_reported = ty_str.clone();\n-                if let ty::Adt(_, generics) = rcvr_ty.kind() {\n-                    if generics.len() > 0 {\n-                        let mut autoderef = self.autoderef(span, rcvr_ty);\n-                        let candidate_found = autoderef.any(|(ty, _)| {\n-                            if let ty::Adt(adt_def, _) = ty.kind() {\n-                                self.tcx\n-                                    .inherent_impls(adt_def.did())\n-                                    .iter()\n-                                    .filter_map(|def_id| self.associated_value(*def_id, item_name))\n-                                    .count()\n-                                    >= 1\n-                            } else {\n-                                false\n-                            }\n-                        });\n-                        let has_deref = autoderef.step_count() > 0;\n-                        if !candidate_found && !has_deref && unsatisfied_predicates.is_empty() {\n-                            if let Some((path_string, _)) = ty_str.split_once('<') {\n-                                ty_str_reported = path_string.to_string();\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n+            MethodError::NoMatch(mut no_match_data) => {\n+                return self.report_no_match_method_error(\n                     span,\n-                    E0599,\n-                    \"no {} named `{}` found for {} `{}` in the current scope\",\n-                    item_kind,\n+                    rcvr_ty,\n                     item_name,\n-                    rcvr_ty.prefix_string(self.tcx),\n-                    ty_str_reported,\n+                    source,\n+                    args,\n+                    sugg_span,\n+                    &mut no_match_data,\n                 );\n-                if rcvr_ty.references_error() {\n-                    err.downgrade_to_delayed_bug();\n-                }\n-\n-                if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n-                    self.suggest_await_before_method(\n-                        &mut err, item_name, rcvr_ty, cal, span,\n-                    );\n-                }\n-                if let Some(span) =\n-                    tcx.resolutions(()).confused_type_with_std_module.get(&span.with_parent(None))\n-                {\n-                    err.span_suggestion(\n-                        span.shrink_to_lo(),\n-                        \"you are looking for the module in `std`, not the primitive type\",\n-                        \"std::\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if let ty::RawPtr(_) = &rcvr_ty.kind() {\n-                    err.note(\n-                        \"try using `<*const T>::as_ref()` to get a reference to the \\\n-                         type behind the pointer: https://doc.rust-lang.org/std/\\\n-                         primitive.pointer.html#method.as_ref\",\n-                    );\n-                    err.note(\n-                        \"using `<*const T>::as_ref()` on a pointer which is unaligned or points \\\n-                         to invalid or uninitialized memory is undefined behavior\",\n-                    );\n-                }\n-\n-                let ty_span = match rcvr_ty.kind() {\n-                    ty::Param(param_type) => Some(\n-                        param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n-                    ),\n-                    ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n-                    _ => None,\n-                };\n-                if let Some(span) = ty_span {\n-                    err.span_label(\n-                        span,\n-                        format!(\n-                            \"{item_kind} `{item_name}` not found for this {}\",\n-                            rcvr_ty.prefix_string(self.tcx)\n-                        ),\n-                    );\n-                }\n-\n-                if let SelfSource::MethodCall(rcvr_expr) = source {\n-                    self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n-                        let call_expr = self\n-                            .tcx\n-                            .hir()\n-                            .expect_expr(self.tcx.hir().get_parent_node(rcvr_expr.hir_id));\n-                        let probe = self.lookup_probe(\n-                            item_name,\n-                            output_ty,\n-                            call_expr,\n-                            ProbeScope::AllTraits,\n-                        );\n-                        probe.is_ok()\n-                    });\n-                }\n-\n-                let mut custom_span_label = false;\n-\n-                if !static_candidates.is_empty() {\n-                    err.note(\n-                        \"found the following associated functions; to be used as methods, \\\n-                         functions must have a `self` parameter\",\n-                    );\n-                    err.span_label(span, \"this is an associated function, not a method\");\n-                    custom_span_label = true;\n-                }\n-                if static_candidates.len() == 1 {\n-                    self.suggest_associated_call_syntax(\n-                        &mut err,\n-                        &static_candidates,\n-                        rcvr_ty,\n-                        source,\n-                        item_name,\n-                        args,\n-                        sugg_span,\n-                    );\n-\n-                    report_candidates(span, &mut err, &mut static_candidates, None);\n-                } else if static_candidates.len() > 1 {\n-                    report_candidates(span, &mut err, &mut static_candidates, Some(sugg_span));\n-                }\n-\n-                let mut bound_spans = vec![];\n-                let mut restrict_type_params = false;\n-                let mut unsatisfied_bounds = false;\n-                if item_name.name == sym::count && self.is_slice_ty(rcvr_ty, span) {\n-                    let msg = \"consider using `len` instead\";\n-                    if let SelfSource::MethodCall(_expr) = source {\n-                        err.span_suggestion_short(\n-                            span,\n-                            msg,\n-                            \"len\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        err.span_label(span, msg);\n-                    }\n-                    if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n-                        let iterator_trait = self.tcx.def_path_str(iterator_trait);\n-                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"));\n-                    }\n-                } else if !unsatisfied_predicates.is_empty() {\n-                    let mut type_params = FxHashMap::default();\n-\n-                    // Pick out the list of unimplemented traits on the receiver.\n-                    // This is used for custom error messages with the `#[rustc_on_unimplemented]` attribute.\n-                    let mut unimplemented_traits = FxHashMap::default();\n-                    let mut unimplemented_traits_only = true;\n-                    for (predicate, _parent_pred, cause) in &unsatisfied_predicates {\n-                        if let (ty::PredicateKind::Clause(ty::Clause::Trait(p)), Some(cause)) =\n-                            (predicate.kind().skip_binder(), cause.as_ref())\n-                        {\n-                            if p.trait_ref.self_ty() != rcvr_ty {\n-                                // This is necessary, not just to keep the errors clean, but also\n-                                // because our derived obligations can wind up with a trait ref that\n-                                // requires a different param_env to be correctly compared.\n-                                continue;\n-                            }\n-                            unimplemented_traits.entry(p.trait_ref.def_id).or_insert((\n-                                predicate.kind().rebind(p.trait_ref),\n-                                Obligation {\n-                                    cause: cause.clone(),\n-                                    param_env: self.param_env,\n-                                    predicate: *predicate,\n-                                    recursion_depth: 0,\n-                                },\n-                            ));\n-                        }\n-                    }\n-\n-                    // Make sure that, if any traits other than the found ones were involved,\n-                    // we don't don't report an unimplemented trait.\n-                    // We don't want to say that `iter::Cloned` is not an iterator, just\n-                    // because of some non-Clone item being iterated over.\n-                    for (predicate, _parent_pred, _cause) in &unsatisfied_predicates {\n-                        match predicate.kind().skip_binder() {\n-                            ty::PredicateKind::Clause(ty::Clause::Trait(p))\n-                                if unimplemented_traits.contains_key(&p.trait_ref.def_id) => {}\n-                            _ => {\n-                                unimplemented_traits_only = false;\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n-                    let mut collect_type_param_suggestions =\n-                        |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n-                            // We don't care about regions here, so it's fine to skip the binder here.\n-                            if let (ty::Param(_), ty::PredicateKind::Clause(ty::Clause::Trait(p))) =\n-                                (self_ty.kind(), parent_pred.kind().skip_binder())\n-                            {\n-                                let hir = self.tcx.hir();\n-                                let node = match p.trait_ref.self_ty().kind() {\n-                                    ty::Param(_) => {\n-                                        // Account for `fn` items like in `issue-35677.rs` to\n-                                        // suggest restricting its type params.\n-                                        let parent_body =\n-                                            hir.body_owner(hir::BodyId { hir_id: self.body_id });\n-                                        Some(hir.get(parent_body))\n-                                    }\n-                                    ty::Adt(def, _) => {\n-                                        def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n-                                    }\n-                                    _ => None,\n-                                };\n-                                if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n-                                    if let Some(g) = kind.generics() {\n-                                        let key = (\n-                                            g.tail_span_for_predicate_suggestion(),\n-                                            g.add_where_or_trailing_comma(),\n-                                        );\n-                                        type_params\n-                                            .entry(key)\n-                                            .or_insert_with(FxHashSet::default)\n-                                            .insert(obligation.to_owned());\n-                                    }\n-                                }\n-                            }\n-                        };\n-                    let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n-                        let msg = format!(\n-                            \"doesn't satisfy `{}`\",\n-                            if obligation.len() > 50 { quiet } else { obligation }\n-                        );\n-                        match &self_ty.kind() {\n-                            // Point at the type that couldn't satisfy the bound.\n-                            ty::Adt(def, _) => {\n-                                bound_spans.push((self.tcx.def_span(def.did()), msg))\n-                            }\n-                            // Point at the trait object that couldn't satisfy the bound.\n-                            ty::Dynamic(preds, _, _) => {\n-                                for pred in preds.iter() {\n-                                    match pred.skip_binder() {\n-                                        ty::ExistentialPredicate::Trait(tr) => bound_spans\n-                                            .push((self.tcx.def_span(tr.def_id), msg.clone())),\n-                                        ty::ExistentialPredicate::Projection(_)\n-                                        | ty::ExistentialPredicate::AutoTrait(_) => {}\n-                                    }\n-                                }\n-                            }\n-                            // Point at the closure that couldn't satisfy the bound.\n-                            ty::Closure(def_id, _) => bound_spans.push((\n-                                tcx.def_span(*def_id),\n-                                format!(\"doesn't satisfy `{}`\", quiet),\n-                            )),\n-                            _ => {}\n-                        }\n-                    };\n-                    let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        let bound_predicate = pred.kind();\n-                        match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n-                                let pred = bound_predicate.rebind(pred);\n-                                // `<Foo as Iterator>::Item = String`.\n-                                let projection_ty = pred.skip_binder().projection_ty;\n-\n-                                let substs_with_infer_self = tcx.mk_substs(\n-                                    iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n-                                        .chain(projection_ty.substs.iter().skip(1)),\n-                                );\n-\n-                                let quiet_projection_ty =\n-                                    tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n-\n-                                let term = pred.skip_binder().term;\n-\n-                                let obligation = format!(\"{} = {}\", projection_ty, term);\n-                                let quiet = with_forced_trimmed_paths!(format!(\n-                                    \"{} = {}\",\n-                                    quiet_projection_ty, term\n-                                ));\n-\n-                                bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n-                                Some((obligation, projection_ty.self_ty()))\n-                            }\n-                            ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n-                                let p = poly_trait_ref.trait_ref;\n-                                let self_ty = p.self_ty();\n-                                let path = p.print_only_trait_path();\n-                                let obligation = format!(\"{}: {}\", self_ty, path);\n-                                let quiet = with_forced_trimmed_paths!(format!(\"_: {}\", path));\n-                                bound_span_label(self_ty, &obligation, &quiet);\n-                                Some((obligation, self_ty))\n-                            }\n-                            _ => None,\n-                        }\n-                    };\n-\n-                    // Find all the requirements that come from a local `impl` block.\n-                    let mut skip_list: FxHashSet<_> = Default::default();\n-                    let mut spanned_predicates: FxHashMap<MultiSpan, _> = Default::default();\n-                    for (data, p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n-                        .iter()\n-                        .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n-                        .filter_map(|(p, parent, c)| match c.code() {\n-                            ObligationCauseCode::ImplDerivedObligation(data) => {\n-                                Some((&data.derived, p, parent, data.impl_def_id, data))\n-                            }\n-                            _ => None,\n-                        })\n-                    {\n-                        let parent_trait_ref = data.parent_trait_pred;\n-                        let path = parent_trait_ref.print_modifiers_and_trait_path();\n-                        let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n-                        let unsatisfied_msg = \"unsatisfied trait bound introduced here\";\n-                        let derive_msg =\n-                            \"unsatisfied trait bound introduced in this `derive` macro\";\n-                        match self.tcx.hir().get_if_local(impl_def_id) {\n-                            // Unmet obligation comes from a `derive` macro, point at it once to\n-                            // avoid multiple span labels pointing at the same place.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n-                                ..\n-                            })) if matches!(\n-                                self_ty.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) || matches!(\n-                                of_trait.as_ref().map(|t| t\n-                                    .path\n-                                    .span\n-                                    .ctxt()\n-                                    .outer_expn_data()\n-                                    .kind),\n-                                Some(ExpnKind::Macro(MacroKind::Derive, _))\n-                            ) =>\n-                            {\n-                                let span = self_ty.span.ctxt().outer_expn_data().call_site;\n-                                let mut spans: MultiSpan = span.into();\n-                                spans.push_span_label(span, derive_msg);\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-\n-                            // Unmet obligation coming from an `impl`.\n-                            Some(Node::Item(hir::Item {\n-                                kind:\n-                                    hir::ItemKind::Impl(hir::Impl {\n-                                        of_trait, self_ty, generics, ..\n-                                    }),\n-                                span: item_span,\n-                                ..\n-                            })) => {\n-                                let sized_pred =\n-                                    unsatisfied_predicates.iter().any(|(pred, _, _)| {\n-                                        match pred.kind().skip_binder() {\n-                                            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n-                                                Some(pred.def_id())\n-                                                    == self.tcx.lang_items().sized_trait()\n-                                                    && pred.polarity == ty::ImplPolarity::Positive\n-                                            }\n-                                            _ => false,\n-                                        }\n-                                    });\n-                                for param in generics.params {\n-                                    if param.span == cause.span && sized_pred {\n-                                        let (sp, sugg) = match param.colon_span {\n-                                            Some(sp) => (sp.shrink_to_hi(), \" ?Sized +\"),\n-                                            None => (param.span.shrink_to_hi(), \": ?Sized\"),\n-                                        };\n-                                        err.span_suggestion_verbose(\n-                                            sp,\n-                                            \"consider relaxing the type parameter's implicit \\\n-                                             `Sized` bound\",\n-                                            sugg,\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                }\n-                                if let Some(pred) = parent_p {\n-                                    // Done to add the \"doesn't satisfy\" `span_label`.\n-                                    let _ = format_pred(*pred);\n-                                }\n-                                skip_list.insert(p);\n-                                let mut spans = if cause.span != *item_span {\n-                                    let mut spans: MultiSpan = cause.span.into();\n-                                    spans.push_span_label(cause.span, unsatisfied_msg);\n-                                    spans\n-                                } else {\n-                                    let mut spans = Vec::with_capacity(2);\n-                                    if let Some(trait_ref) = of_trait {\n-                                        spans.push(trait_ref.path.span);\n-                                    }\n-                                    spans.push(self_ty.span);\n-                                    spans.into()\n-                                };\n-                                if let Some(trait_ref) = of_trait {\n-                                    spans.push_span_label(trait_ref.path.span, \"\");\n-                                }\n-                                spans.push_span_label(self_ty.span, \"\");\n-\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(rustc_ast::ast::IsAuto::Yes, ..),\n-                                span: item_span,\n-                                ..\n-                            })) => {\n-                                tcx.sess.delay_span_bug(\n-                                        *item_span,\n-                                        \"auto trait is invoked with no method error, but no error reported?\",\n-                                    );\n-                            }\n-                            Some(_) => unreachable!(),\n-                            None => (),\n-                        }\n-                    }\n-                    let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n-                    spanned_predicates.sort_by_key(|(span, (_, _, _))| span.primary_span());\n-                    for (span, (_path, _self_ty, preds)) in spanned_predicates {\n-                        let mut preds: Vec<_> = preds\n-                            .into_iter()\n-                            .filter_map(|pred| format_pred(*pred))\n-                            .map(|(p, _)| format!(\"`{}`\", p))\n-                            .collect();\n-                        preds.sort();\n-                        preds.dedup();\n-                        let msg = if let [pred] = &preds[..] {\n-                            format!(\"trait bound {} was not satisfied\", pred)\n-                        } else {\n-                            format!(\n-                                \"the following trait bounds were not satisfied:\\n{}\",\n-                                preds.join(\"\\n\"),\n-                            )\n-                        };\n-                        err.span_note(span, &msg);\n-                        unsatisfied_bounds = true;\n-                    }\n-\n-                    // The requirements that didn't have an `impl` span to show.\n-                    let mut bound_list = unsatisfied_predicates\n-                        .iter()\n-                        .filter_map(|(pred, parent_pred, _cause)| {\n-                            format_pred(*pred).map(|(p, self_ty)| {\n-                                collect_type_param_suggestions(self_ty, *pred, &p);\n-                                (\n-                                    match parent_pred {\n-                                        None => format!(\"`{}`\", &p),\n-                                        Some(parent_pred) => match format_pred(*parent_pred) {\n-                                            None => format!(\"`{}`\", &p),\n-                                            Some((parent_p, _)) => {\n-                                                collect_type_param_suggestions(\n-                                                    self_ty,\n-                                                    *parent_pred,\n-                                                    &p,\n-                                                );\n-                                                format!(\n-                                                    \"`{}`\\nwhich is required by `{}`\",\n-                                                    p, parent_p\n-                                                )\n-                                            }\n-                                        },\n-                                    },\n-                                    *pred,\n-                                )\n-                            })\n-                        })\n-                        .filter(|(_, pred)| !skip_list.contains(&pred))\n-                        .map(|(t, _)| t)\n-                        .enumerate()\n-                        .collect::<Vec<(usize, String)>>();\n-\n-                    for ((span, add_where_or_comma), obligations) in type_params.into_iter() {\n-                        restrict_type_params = true;\n-                        // #74886: Sort here so that the output is always the same.\n-                        let mut obligations = obligations.into_iter().collect::<Vec<_>>();\n-                        obligations.sort();\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            &format!(\n-                                \"consider restricting the type parameter{s} to satisfy the \\\n-                                 trait bound{s}\",\n-                                s = pluralize!(obligations.len())\n-                            ),\n-                            format!(\"{} {}\", add_where_or_comma, obligations.join(\", \")),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-\n-                    bound_list.sort_by(|(_, a), (_, b)| a.cmp(b)); // Sort alphabetically.\n-                    bound_list.dedup_by(|(_, a), (_, b)| a == b); // #35677\n-                    bound_list.sort_by_key(|(pos, _)| *pos); // Keep the original predicate order.\n-\n-                    if !bound_list.is_empty() || !skip_list.is_empty() {\n-                        let bound_list = bound_list\n-                            .into_iter()\n-                            .map(|(_, path)| path)\n-                            .collect::<Vec<_>>()\n-                            .join(\"\\n\");\n-                        let actual_prefix = rcvr_ty.prefix_string(self.tcx);\n-                        info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n-                        let (primary_message, label) =\n-                            if unimplemented_traits.len() == 1 && unimplemented_traits_only {\n-                                unimplemented_traits\n-                                    .into_iter()\n-                                    .next()\n-                                    .map(|(_, (trait_ref, obligation))| {\n-                                        if trait_ref.self_ty().references_error()\n-                                            || rcvr_ty.references_error()\n-                                        {\n-                                            // Avoid crashing.\n-                                            return (None, None);\n-                                        }\n-                                        let OnUnimplementedNote { message, label, .. } = self\n-                                            .err_ctxt()\n-                                            .on_unimplemented_note(trait_ref, &obligation);\n-                                        (message, label)\n-                                    })\n-                                    .unwrap()\n-                            } else {\n-                                (None, None)\n-                            };\n-                        let primary_message = primary_message.unwrap_or_else(|| format!(\n-                            \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, \\\n-                             but its trait bounds were not satisfied\"\n-                        ));\n-                        err.set_primary_message(&primary_message);\n-                        if let Some(label) = label {\n-                            custom_span_label = true;\n-                            err.span_label(span, label);\n-                        }\n-                        if !bound_list.is_empty() {\n-                            err.note(&format!(\n-                                \"the following trait bounds were not satisfied:\\n{bound_list}\"\n-                            ));\n-                        }\n-                        self.suggest_derive(&mut err, &unsatisfied_predicates);\n-\n-                        unsatisfied_bounds = true;\n-                    }\n-                }\n-\n-                let label_span_not_found = |err: &mut Diagnostic| {\n-                    if unsatisfied_predicates.is_empty() {\n-                        err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n-                        let is_string_or_ref_str = match rcvr_ty.kind() {\n-                            ty::Ref(_, ty, _) => {\n-                                ty.is_str()\n-                                    || matches!(\n-                                        ty.kind(),\n-                                        ty::Adt(adt, _) if Some(adt.did()) == self.tcx.lang_items().string()\n-                                    )\n-                            }\n-                            ty::Adt(adt, _) => Some(adt.did()) == self.tcx.lang_items().string(),\n-                            _ => false,\n-                        };\n-                        if is_string_or_ref_str && item_name.name == sym::iter {\n-                            err.span_suggestion_verbose(\n-                                item_name.span,\n-                                \"because of the in-memory representation of `&str`, to obtain \\\n-                                 an `Iterator` over each of its codepoint use method `chars`\",\n-                                \"chars\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        if let ty::Adt(adt, _) = rcvr_ty.kind() {\n-                            let mut inherent_impls_candidate = self\n-                                .tcx\n-                                .inherent_impls(adt.did())\n-                                .iter()\n-                                .copied()\n-                                .filter(|def_id| {\n-                                    if let Some(assoc) = self.associated_value(*def_id, item_name) {\n-                                        // Check for both mode is the same so we avoid suggesting\n-                                        // incorrect associated item.\n-                                        match (mode, assoc.fn_has_self_parameter, source) {\n-                                            (Mode::MethodCall, true, SelfSource::MethodCall(_)) => {\n-                                                // We check that the suggest type is actually\n-                                                // different from the received one\n-                                                // So we avoid suggestion method with Box<Self>\n-                                                // for instance\n-                                                self.tcx.at(span).type_of(*def_id) != rcvr_ty\n-                                                    && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n-                                            }\n-                                            (Mode::Path, false, _) => true,\n-                                            _ => false,\n-                                        }\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                                .collect::<Vec<_>>();\n-                            if !inherent_impls_candidate.is_empty() {\n-                                inherent_impls_candidate.sort();\n-                                inherent_impls_candidate.dedup();\n-\n-                                // number of type to shows at most.\n-                                let limit = if inherent_impls_candidate.len() == 5 { 5 } else { 4 };\n-                                let type_candidates = inherent_impls_candidate\n-                                    .iter()\n-                                    .take(limit)\n-                                    .map(|impl_item| {\n-                                        format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n-                                    })\n-                                    .collect::<Vec<_>>()\n-                                    .join(\"\\n\");\n-                                let additional_types = if inherent_impls_candidate.len() > limit {\n-                                    format!(\n-                                        \"\\nand {} more types\",\n-                                        inherent_impls_candidate.len() - limit\n-                                    )\n-                                } else {\n-                                    \"\".to_string()\n-                                };\n-                                err.note(&format!(\n-                                    \"the {item_kind} was found for\\n{}{}\",\n-                                    type_candidates, additional_types\n-                                ));\n-                            }\n-                        }\n-                    } else {\n-                        let ty_str = if ty_str.len() > 50 {\n-                            String::new()\n-                        } else {\n-                            format!(\"on `{ty_str}` \")\n-                        };\n-                        err.span_label(span, format!(\n-                            \"{item_kind} cannot be called {ty_str}due to unsatisfied trait bounds\"\n-                        ));\n-                    }\n-                };\n-\n-                // If the method name is the name of a field with a function or closure type,\n-                // give a helping note that it has to be called as `(x.f)(...)`.\n-                if let SelfSource::MethodCall(expr) = source {\n-                    if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n-                        && lev_candidate.is_none()\n-                        && !custom_span_label\n-                    {\n-                        label_span_not_found(&mut err);\n-                    }\n-                } else if !custom_span_label {\n-                    label_span_not_found(&mut err);\n-                }\n-\n-                // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n-                // can't be called due to `typeof(expr): Clone` not holding.\n-                if unsatisfied_predicates.is_empty() {\n-                    self.suggest_calling_method_on_field(\n-                        &mut err, source, span, rcvr_ty, item_name,\n-                    );\n-                }\n-\n-                self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n-\n-                bound_spans.sort();\n-                bound_spans.dedup();\n-                for (span, msg) in bound_spans.into_iter() {\n-                    err.span_label(span, &msg);\n-                }\n-\n-                if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n-                } else {\n-                    self.suggest_traits_to_import(\n-                        &mut err,\n-                        span,\n-                        rcvr_ty,\n-                        item_name,\n-                        args.map(|(_, args)| args.len() + 1),\n-                        source,\n-                        out_of_scope_traits,\n-                        &unsatisfied_predicates,\n-                        &static_candidates,\n-                        unsatisfied_bounds,\n-                    );\n-                }\n-\n-                // Don't emit a suggestion if we found an actual method\n-                // that had unsatisfied trait bounds\n-                if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n-                    let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n-                    if let Some(suggestion) = lev_distance::find_best_match_for_name(\n-                        &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n-                        item_name.name,\n-                        None,\n-                    ) {\n-                        err.span_suggestion(\n-                            span,\n-                            \"there is a variant with a similar name\",\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-\n-                if item_name.name == sym::as_str && rcvr_ty.peel_refs().is_str() {\n-                    let msg = \"remove this method call\";\n-                    let mut fallback_span = true;\n-                    if let SelfSource::MethodCall(expr) = source {\n-                        let call_expr =\n-                            self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-                        if let Some(span) = call_expr.span.trim_start(expr.span) {\n-                            err.span_suggestion(span, msg, \"\", Applicability::MachineApplicable);\n-                            fallback_span = false;\n-                        }\n-                    }\n-                    if fallback_span {\n-                        err.span_label(span, msg);\n-                    }\n-                } else if let Some(lev_candidate) = lev_candidate {\n-                    // Don't emit a suggestion if we found an actual method\n-                    // that had unsatisfied trait bounds\n-                    if unsatisfied_predicates.is_empty() {\n-                        let def_kind = lev_candidate.kind.as_def_kind();\n-                        // Methods are defined within the context of a struct and their first parameter is always self,\n-                        // which represents the instance of the struct the method is being called on\n-                        // Associated functions don\u2019t take self as a parameter and\n-                        // they are not methods because they don\u2019t have an instance of the struct to work with.\n-                        if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n-                            err.span_suggestion(\n-                                span,\n-                                \"there is a method with a similar name\",\n-                                lev_candidate.name,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            err.span_suggestion(\n-                                span,\n-                                &format!(\n-                                    \"there is {} {} with a similar name\",\n-                                    def_kind.article(),\n-                                    def_kind.descr(lev_candidate.def_id),\n-                                ),\n-                                lev_candidate.name,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n-                }\n-\n-                self.check_for_deref_method(&mut err, source, rcvr_ty, item_name);\n-\n-                return Some(err);\n             }\n \n             MethodError::Ambiguity(mut sources) => {\n@@ -1042,7 +143,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 err.span_label(item_name.span, format!(\"multiple `{}` found\", item_name));\n \n-                report_candidates(span, &mut err, &mut sources, Some(sugg_span));\n+                self.note_candidates_on_method_error(\n+                    rcvr_ty,\n+                    item_name,\n+                    args,\n+                    span,\n+                    &mut err,\n+                    &mut sources,\n+                    Some(sugg_span),\n+                );\n                 err.emit();\n             }\n \n@@ -1067,10 +176,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.emit();\n             }\n \n-            MethodError::IllegalSizedBound(candidates, needs_mut, bound_span) => {\n-                let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n-                let mut err = self.sess().struct_span_err(span, &msg);\n-                err.span_label(bound_span, \"this has a `Sized` requirement\");\n+            MethodError::IllegalSizedBound { candidates, needs_mut, bound_span, self_expr } => {\n+                let msg = if needs_mut {\n+                    with_forced_trimmed_paths!(format!(\n+                        \"the `{item_name}` method cannot be invoked on `{rcvr_ty}`\"\n+                    ))\n+                } else {\n+                    format!(\"the `{item_name}` method cannot be invoked on a trait object\")\n+                };\n+                let mut err = self.sess().struct_span_err(span, &msg);\n+                if !needs_mut {\n+                    err.span_label(bound_span, \"this has a `Sized` requirement\");\n+                }\n                 if !candidates.is_empty() {\n                     let help = format!(\n                         \"{an}other candidate{s} {were} found in the following trait{s}, perhaps \\\n@@ -1088,7 +205,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             *region,\n                             ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() },\n                         );\n-                        err.note(&format!(\"you need `{}` instead of `{}`\", trait_type, rcvr_ty));\n+                        let msg = format!(\"you need `{}` instead of `{}`\", trait_type, rcvr_ty);\n+                        let mut kind = &self_expr.kind;\n+                        while let hir::ExprKind::AddrOf(_, _, expr)\n+                        | hir::ExprKind::Unary(hir::UnOp::Deref, expr) = kind\n+                        {\n+                            kind = &expr.kind;\n+                        }\n+                        if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = kind\n+                            && let hir::def::Res::Local(hir_id) = path.res\n+                            && let Some(hir::Node::Pat(b)) = self.tcx.hir().find(hir_id)\n+                            && let Some(hir::Node::Param(p)) = self.tcx.hir().find_parent(b.hir_id)\n+                            && let Some(node) = self.tcx.hir().find_parent(p.hir_id)\n+                            && let Some(decl) = node.fn_decl()\n+                            && let Some(ty) = decl.inputs.iter().find(|ty| ty.span == p.ty_span)\n+                            && let hir::TyKind::Ref(_, mut_ty) = &ty.kind\n+                            && let hir::Mutability::Not = mut_ty.mutbl\n+                        {\n+                            err.span_suggestion_verbose(\n+                                mut_ty.ty.span.shrink_to_lo(),\n+                                &msg,\n+                                \"mut \",\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.help(&msg);\n+                        }\n                     }\n                 }\n                 err.emit();\n@@ -1099,6 +241,899 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    pub fn report_no_match_method_error(\n+        &self,\n+        mut span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        item_name: Ident,\n+        source: SelfSource<'tcx>,\n+        args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n+        sugg_span: Span,\n+        no_match_data: &mut NoMatchData<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n+        let mode = no_match_data.mode;\n+        let tcx = self.tcx;\n+        let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n+        let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n+        let is_method = mode == Mode::MethodCall;\n+        let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n+        let lev_candidate = no_match_data.lev_candidate;\n+        let item_kind = if is_method {\n+            \"method\"\n+        } else if rcvr_ty.is_enum() {\n+            \"variant or associated item\"\n+        } else {\n+            match (item_name.as_str().chars().next(), rcvr_ty.is_fresh_ty()) {\n+                (Some(name), false) if name.is_lowercase() => \"function or associated item\",\n+                (Some(_), false) => \"associated item\",\n+                (Some(_), true) | (None, false) => \"variant or associated item\",\n+                (None, true) => \"variant\",\n+            }\n+        };\n+\n+        if self.suggest_wrapping_range_with_parens(tcx, rcvr_ty, source, span, item_name, &ty_str)\n+            || self.suggest_constraining_numerical_ty(\n+                tcx, rcvr_ty, source, span, item_kind, item_name, &ty_str,\n+            )\n+        {\n+            return None;\n+        }\n+        span = item_name.span;\n+\n+        // Don't show generic arguments when the method can't be found in any implementation (#81576).\n+        let mut ty_str_reported = ty_str.clone();\n+        if let ty::Adt(_, generics) = rcvr_ty.kind() {\n+            if generics.len() > 0 {\n+                let mut autoderef = self.autoderef(span, rcvr_ty);\n+                let candidate_found = autoderef.any(|(ty, _)| {\n+                    if let ty::Adt(adt_def, _) = ty.kind() {\n+                        self.tcx\n+                            .inherent_impls(adt_def.did())\n+                            .iter()\n+                            .any(|def_id| self.associated_value(*def_id, item_name).is_some())\n+                    } else {\n+                        false\n+                    }\n+                });\n+                let has_deref = autoderef.step_count() > 0;\n+                if !candidate_found && !has_deref && unsatisfied_predicates.is_empty() {\n+                    if let Some((path_string, _)) = ty_str.split_once('<') {\n+                        ty_str_reported = path_string.to_string();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0599,\n+            \"no {} named `{}` found for {} `{}` in the current scope\",\n+            item_kind,\n+            item_name,\n+            rcvr_ty.prefix_string(self.tcx),\n+            ty_str_reported,\n+        );\n+        if rcvr_ty.references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n+        if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n+            self.suggest_await_before_method(\n+                &mut err, item_name, rcvr_ty, cal, span,\n+            );\n+        }\n+        if let Some(span) =\n+            tcx.resolutions(()).confused_type_with_std_module.get(&span.with_parent(None))\n+        {\n+            err.span_suggestion(\n+                span.shrink_to_lo(),\n+                \"you are looking for the module in `std`, not the primitive type\",\n+                \"std::\",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        if let ty::RawPtr(_) = &rcvr_ty.kind() {\n+            err.note(\n+                \"try using `<*const T>::as_ref()` to get a reference to the \\\n+                 type behind the pointer: https://doc.rust-lang.org/std/\\\n+                 primitive.pointer.html#method.as_ref\",\n+            );\n+            err.note(\n+                \"using `<*const T>::as_ref()` on a pointer which is unaligned or points \\\n+                 to invalid or uninitialized memory is undefined behavior\",\n+            );\n+        }\n+\n+        let ty_span = match rcvr_ty.kind() {\n+            ty::Param(param_type) => {\n+                Some(param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()))\n+            }\n+            ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n+            _ => None,\n+        };\n+        if let Some(span) = ty_span {\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"{item_kind} `{item_name}` not found for this {}\",\n+                    rcvr_ty.prefix_string(self.tcx)\n+                ),\n+            );\n+        }\n+\n+        if let SelfSource::MethodCall(rcvr_expr) = source {\n+            self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n+                let call_expr =\n+                    self.tcx.hir().expect_expr(self.tcx.hir().parent_id(rcvr_expr.hir_id));\n+                let probe =\n+                    self.lookup_probe(item_name, output_ty, call_expr, ProbeScope::AllTraits);\n+                probe.is_ok()\n+            });\n+        }\n+\n+        let mut custom_span_label = false;\n+\n+        let static_candidates = &mut no_match_data.static_candidates;\n+        if !static_candidates.is_empty() {\n+            err.note(\n+                \"found the following associated functions; to be used as methods, \\\n+                 functions must have a `self` parameter\",\n+            );\n+            err.span_label(span, \"this is an associated function, not a method\");\n+            custom_span_label = true;\n+        }\n+        if static_candidates.len() == 1 {\n+            self.suggest_associated_call_syntax(\n+                &mut err,\n+                &static_candidates,\n+                rcvr_ty,\n+                source,\n+                item_name,\n+                args,\n+                sugg_span,\n+            );\n+\n+            self.note_candidates_on_method_error(\n+                rcvr_ty,\n+                item_name,\n+                args,\n+                span,\n+                &mut err,\n+                static_candidates,\n+                None,\n+            );\n+        } else if static_candidates.len() > 1 {\n+            self.note_candidates_on_method_error(\n+                rcvr_ty,\n+                item_name,\n+                args,\n+                span,\n+                &mut err,\n+                static_candidates,\n+                Some(sugg_span),\n+            );\n+        }\n+\n+        let mut bound_spans = vec![];\n+        let mut restrict_type_params = false;\n+        let mut unsatisfied_bounds = false;\n+        if item_name.name == sym::count && self.is_slice_ty(rcvr_ty, span) {\n+            let msg = \"consider using `len` instead\";\n+            if let SelfSource::MethodCall(_expr) = source {\n+                err.span_suggestion_short(span, msg, \"len\", Applicability::MachineApplicable);\n+            } else {\n+                err.span_label(span, msg);\n+            }\n+            if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n+                let iterator_trait = self.tcx.def_path_str(iterator_trait);\n+                err.note(&format!(\n+                    \"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"\n+                ));\n+            }\n+        } else if !unsatisfied_predicates.is_empty() {\n+            let mut type_params = FxHashMap::default();\n+\n+            // Pick out the list of unimplemented traits on the receiver.\n+            // This is used for custom error messages with the `#[rustc_on_unimplemented]` attribute.\n+            let mut unimplemented_traits = FxHashMap::default();\n+            let mut unimplemented_traits_only = true;\n+            for (predicate, _parent_pred, cause) in unsatisfied_predicates {\n+                if let (ty::PredicateKind::Clause(ty::Clause::Trait(p)), Some(cause)) =\n+                    (predicate.kind().skip_binder(), cause.as_ref())\n+                {\n+                    if p.trait_ref.self_ty() != rcvr_ty {\n+                        // This is necessary, not just to keep the errors clean, but also\n+                        // because our derived obligations can wind up with a trait ref that\n+                        // requires a different param_env to be correctly compared.\n+                        continue;\n+                    }\n+                    unimplemented_traits.entry(p.trait_ref.def_id).or_insert((\n+                        predicate.kind().rebind(p.trait_ref),\n+                        Obligation {\n+                            cause: cause.clone(),\n+                            param_env: self.param_env,\n+                            predicate: *predicate,\n+                            recursion_depth: 0,\n+                        },\n+                    ));\n+                }\n+            }\n+\n+            // Make sure that, if any traits other than the found ones were involved,\n+            // we don't don't report an unimplemented trait.\n+            // We don't want to say that `iter::Cloned` is not an iterator, just\n+            // because of some non-Clone item being iterated over.\n+            for (predicate, _parent_pred, _cause) in unsatisfied_predicates {\n+                match predicate.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(p))\n+                        if unimplemented_traits.contains_key(&p.trait_ref.def_id) => {}\n+                    _ => {\n+                        unimplemented_traits_only = false;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            let mut collect_type_param_suggestions =\n+                |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n+                    // We don't care about regions here, so it's fine to skip the binder here.\n+                    if let (ty::Param(_), ty::PredicateKind::Clause(ty::Clause::Trait(p))) =\n+                        (self_ty.kind(), parent_pred.kind().skip_binder())\n+                    {\n+                        let hir = self.tcx.hir();\n+                        let node = match p.trait_ref.self_ty().kind() {\n+                            ty::Param(_) => {\n+                                // Account for `fn` items like in `issue-35677.rs` to\n+                                // suggest restricting its type params.\n+                                let parent_body =\n+                                    hir.body_owner(hir::BodyId { hir_id: self.body_id });\n+                                Some(hir.get(parent_body))\n+                            }\n+                            ty::Adt(def, _) => {\n+                                def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n+                            }\n+                            _ => None,\n+                        };\n+                        if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n+                            if let Some(g) = kind.generics() {\n+                                let key = (\n+                                    g.tail_span_for_predicate_suggestion(),\n+                                    g.add_where_or_trailing_comma(),\n+                                );\n+                                type_params\n+                                    .entry(key)\n+                                    .or_insert_with(FxHashSet::default)\n+                                    .insert(obligation.to_owned());\n+                            }\n+                        }\n+                    }\n+                };\n+            let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n+                let msg = format!(\n+                    \"doesn't satisfy `{}`\",\n+                    if obligation.len() > 50 { quiet } else { obligation }\n+                );\n+                match &self_ty.kind() {\n+                    // Point at the type that couldn't satisfy the bound.\n+                    ty::Adt(def, _) => bound_spans.push((self.tcx.def_span(def.did()), msg)),\n+                    // Point at the trait object that couldn't satisfy the bound.\n+                    ty::Dynamic(preds, _, _) => {\n+                        for pred in preds.iter() {\n+                            match pred.skip_binder() {\n+                                ty::ExistentialPredicate::Trait(tr) => {\n+                                    bound_spans.push((self.tcx.def_span(tr.def_id), msg.clone()))\n+                                }\n+                                ty::ExistentialPredicate::Projection(_)\n+                                | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                            }\n+                        }\n+                    }\n+                    // Point at the closure that couldn't satisfy the bound.\n+                    ty::Closure(def_id, _) => bound_spans\n+                        .push((tcx.def_span(*def_id), format!(\"doesn't satisfy `{}`\", quiet))),\n+                    _ => {}\n+                }\n+            };\n+            let mut format_pred = |pred: ty::Predicate<'tcx>| {\n+                let bound_predicate = pred.kind();\n+                match bound_predicate.skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n+                        let pred = bound_predicate.rebind(pred);\n+                        // `<Foo as Iterator>::Item = String`.\n+                        let projection_ty = pred.skip_binder().projection_ty;\n+\n+                        let substs_with_infer_self = tcx.mk_substs(\n+                            iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n+                                .chain(projection_ty.substs.iter().skip(1)),\n+                        );\n+\n+                        let quiet_projection_ty =\n+                            tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n+\n+                        let term = pred.skip_binder().term;\n+\n+                        let obligation = format!(\"{} = {}\", projection_ty, term);\n+                        let quiet = with_forced_trimmed_paths!(format!(\n+                            \"{} = {}\",\n+                            quiet_projection_ty, term\n+                        ));\n+\n+                        bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                        Some((obligation, projection_ty.self_ty()))\n+                    }\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n+                        let p = poly_trait_ref.trait_ref;\n+                        let self_ty = p.self_ty();\n+                        let path = p.print_only_trait_path();\n+                        let obligation = format!(\"{}: {}\", self_ty, path);\n+                        let quiet = with_forced_trimmed_paths!(format!(\"_: {}\", path));\n+                        bound_span_label(self_ty, &obligation, &quiet);\n+                        Some((obligation, self_ty))\n+                    }\n+                    _ => None,\n+                }\n+            };\n+\n+            // Find all the requirements that come from a local `impl` block.\n+            let mut skip_list: FxHashSet<_> = Default::default();\n+            let mut spanned_predicates: FxHashMap<MultiSpan, _> = Default::default();\n+            for (data, p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n+                .iter()\n+                .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n+                .filter_map(|(p, parent, c)| match c.code() {\n+                    ObligationCauseCode::ImplDerivedObligation(data) => {\n+                        Some((&data.derived, p, parent, data.impl_def_id, data))\n+                    }\n+                    _ => None,\n+                })\n+            {\n+                let parent_trait_ref = data.parent_trait_pred;\n+                let path = parent_trait_ref.print_modifiers_and_trait_path();\n+                let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n+                let unsatisfied_msg = \"unsatisfied trait bound introduced here\";\n+                let derive_msg = \"unsatisfied trait bound introduced in this `derive` macro\";\n+                match self.tcx.hir().get_if_local(impl_def_id) {\n+                    // Unmet obligation comes from a `derive` macro, point at it once to\n+                    // avoid multiple span labels pointing at the same place.\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n+                        ..\n+                    })) if matches!(\n+                        self_ty.span.ctxt().outer_expn_data().kind,\n+                        ExpnKind::Macro(MacroKind::Derive, _)\n+                    ) || matches!(\n+                        of_trait.as_ref().map(|t| t.path.span.ctxt().outer_expn_data().kind),\n+                        Some(ExpnKind::Macro(MacroKind::Derive, _))\n+                    ) =>\n+                    {\n+                        let span = self_ty.span.ctxt().outer_expn_data().call_site;\n+                        let mut spans: MultiSpan = span.into();\n+                        spans.push_span_label(span, derive_msg);\n+                        let entry = spanned_predicates.entry(spans);\n+                        entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                    }\n+\n+                    // Unmet obligation coming from an `impl`.\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, generics, .. }),\n+                        span: item_span,\n+                        ..\n+                    })) => {\n+                        let sized_pred =\n+                            unsatisfied_predicates.iter().any(|(pred, _, _)| {\n+                                match pred.kind().skip_binder() {\n+                                    ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n+                                        Some(pred.def_id()) == self.tcx.lang_items().sized_trait()\n+                                            && pred.polarity == ty::ImplPolarity::Positive\n+                                    }\n+                                    _ => false,\n+                                }\n+                            });\n+                        for param in generics.params {\n+                            if param.span == cause.span && sized_pred {\n+                                let (sp, sugg) = match param.colon_span {\n+                                    Some(sp) => (sp.shrink_to_hi(), \" ?Sized +\"),\n+                                    None => (param.span.shrink_to_hi(), \": ?Sized\"),\n+                                };\n+                                err.span_suggestion_verbose(\n+                                    sp,\n+                                    \"consider relaxing the type parameter's implicit \\\n+                                     `Sized` bound\",\n+                                    sugg,\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        }\n+                        if let Some(pred) = parent_p {\n+                            // Done to add the \"doesn't satisfy\" `span_label`.\n+                            let _ = format_pred(*pred);\n+                        }\n+                        skip_list.insert(p);\n+                        let mut spans = if cause.span != *item_span {\n+                            let mut spans: MultiSpan = cause.span.into();\n+                            spans.push_span_label(cause.span, unsatisfied_msg);\n+                            spans\n+                        } else {\n+                            let mut spans = Vec::with_capacity(2);\n+                            if let Some(trait_ref) = of_trait {\n+                                spans.push(trait_ref.path.span);\n+                            }\n+                            spans.push(self_ty.span);\n+                            spans.into()\n+                        };\n+                        if let Some(trait_ref) = of_trait {\n+                            spans.push_span_label(trait_ref.path.span, \"\");\n+                        }\n+                        spans.push_span_label(self_ty.span, \"\");\n+\n+                        let entry = spanned_predicates.entry(spans);\n+                        entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                    }\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Trait(rustc_ast::ast::IsAuto::Yes, ..),\n+                        span: item_span,\n+                        ..\n+                    })) => {\n+                        tcx.sess.delay_span_bug(\n+                            *item_span,\n+                            \"auto trait is invoked with no method error, but no error reported?\",\n+                        );\n+                    }\n+                    Some(_) => unreachable!(),\n+                    None => (),\n+                }\n+            }\n+            let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n+            spanned_predicates.sort_by_key(|(span, (_, _, _))| span.primary_span());\n+            for (span, (_path, _self_ty, preds)) in spanned_predicates {\n+                let mut preds: Vec<_> = preds\n+                    .into_iter()\n+                    .filter_map(|pred| format_pred(*pred))\n+                    .map(|(p, _)| format!(\"`{}`\", p))\n+                    .collect();\n+                preds.sort();\n+                preds.dedup();\n+                let msg = if let [pred] = &preds[..] {\n+                    format!(\"trait bound {} was not satisfied\", pred)\n+                } else {\n+                    format!(\"the following trait bounds were not satisfied:\\n{}\", preds.join(\"\\n\"),)\n+                };\n+                err.span_note(span, &msg);\n+                unsatisfied_bounds = true;\n+            }\n+\n+            // The requirements that didn't have an `impl` span to show.\n+            let mut bound_list = unsatisfied_predicates\n+                .iter()\n+                .filter_map(|(pred, parent_pred, _cause)| {\n+                    format_pred(*pred).map(|(p, self_ty)| {\n+                        collect_type_param_suggestions(self_ty, *pred, &p);\n+                        (\n+                            match parent_pred {\n+                                None => format!(\"`{}`\", &p),\n+                                Some(parent_pred) => match format_pred(*parent_pred) {\n+                                    None => format!(\"`{}`\", &p),\n+                                    Some((parent_p, _)) => {\n+                                        collect_type_param_suggestions(self_ty, *parent_pred, &p);\n+                                        format!(\"`{}`\\nwhich is required by `{}`\", p, parent_p)\n+                                    }\n+                                },\n+                            },\n+                            *pred,\n+                        )\n+                    })\n+                })\n+                .filter(|(_, pred)| !skip_list.contains(&pred))\n+                .map(|(t, _)| t)\n+                .enumerate()\n+                .collect::<Vec<(usize, String)>>();\n+\n+            for ((span, add_where_or_comma), obligations) in type_params.into_iter() {\n+                restrict_type_params = true;\n+                // #74886: Sort here so that the output is always the same.\n+                let mut obligations = obligations.into_iter().collect::<Vec<_>>();\n+                obligations.sort();\n+                err.span_suggestion_verbose(\n+                    span,\n+                    &format!(\n+                        \"consider restricting the type parameter{s} to satisfy the \\\n+                         trait bound{s}\",\n+                        s = pluralize!(obligations.len())\n+                    ),\n+                    format!(\"{} {}\", add_where_or_comma, obligations.join(\", \")),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            bound_list.sort_by(|(_, a), (_, b)| a.cmp(b)); // Sort alphabetically.\n+            bound_list.dedup_by(|(_, a), (_, b)| a == b); // #35677\n+            bound_list.sort_by_key(|(pos, _)| *pos); // Keep the original predicate order.\n+\n+            if !bound_list.is_empty() || !skip_list.is_empty() {\n+                let bound_list =\n+                    bound_list.into_iter().map(|(_, path)| path).collect::<Vec<_>>().join(\"\\n\");\n+                let actual_prefix = rcvr_ty.prefix_string(self.tcx);\n+                info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n+                let (primary_message, label) = if unimplemented_traits.len() == 1\n+                    && unimplemented_traits_only\n+                {\n+                    unimplemented_traits\n+                        .into_iter()\n+                        .next()\n+                        .map(|(_, (trait_ref, obligation))| {\n+                            if trait_ref.self_ty().references_error() || rcvr_ty.references_error()\n+                            {\n+                                // Avoid crashing.\n+                                return (None, None);\n+                            }\n+                            let OnUnimplementedNote { message, label, .. } =\n+                                self.err_ctxt().on_unimplemented_note(trait_ref, &obligation);\n+                            (message, label)\n+                        })\n+                        .unwrap()\n+                } else {\n+                    (None, None)\n+                };\n+                let primary_message = primary_message.unwrap_or_else(|| {\n+                    format!(\n+                        \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, \\\n+                    but its trait bounds were not satisfied\"\n+                    )\n+                });\n+                err.set_primary_message(&primary_message);\n+                if let Some(label) = label {\n+                    custom_span_label = true;\n+                    err.span_label(span, label);\n+                }\n+                if !bound_list.is_empty() {\n+                    err.note(&format!(\n+                        \"the following trait bounds were not satisfied:\\n{bound_list}\"\n+                    ));\n+                }\n+                self.suggest_derive(&mut err, &unsatisfied_predicates);\n+\n+                unsatisfied_bounds = true;\n+            }\n+        }\n+\n+        let label_span_not_found = |err: &mut Diagnostic| {\n+            if unsatisfied_predicates.is_empty() {\n+                err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n+                let is_string_or_ref_str = match rcvr_ty.kind() {\n+                    ty::Ref(_, ty, _) => {\n+                        ty.is_str()\n+                            || matches!(\n+                                ty.kind(),\n+                                ty::Adt(adt, _) if Some(adt.did()) == self.tcx.lang_items().string()\n+                            )\n+                    }\n+                    ty::Adt(adt, _) => Some(adt.did()) == self.tcx.lang_items().string(),\n+                    _ => false,\n+                };\n+                if is_string_or_ref_str && item_name.name == sym::iter {\n+                    err.span_suggestion_verbose(\n+                        item_name.span,\n+                        \"because of the in-memory representation of `&str`, to obtain \\\n+                         an `Iterator` over each of its codepoint use method `chars`\",\n+                        \"chars\",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if let ty::Adt(adt, _) = rcvr_ty.kind() {\n+                    let mut inherent_impls_candidate = self\n+                        .tcx\n+                        .inherent_impls(adt.did())\n+                        .iter()\n+                        .copied()\n+                        .filter(|def_id| {\n+                            if let Some(assoc) = self.associated_value(*def_id, item_name) {\n+                                // Check for both mode is the same so we avoid suggesting\n+                                // incorrect associated item.\n+                                match (mode, assoc.fn_has_self_parameter, source) {\n+                                    (Mode::MethodCall, true, SelfSource::MethodCall(_)) => {\n+                                        // We check that the suggest type is actually\n+                                        // different from the received one\n+                                        // So we avoid suggestion method with Box<Self>\n+                                        // for instance\n+                                        self.tcx.at(span).type_of(*def_id) != rcvr_ty\n+                                            && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n+                                    }\n+                                    (Mode::Path, false, _) => true,\n+                                    _ => false,\n+                                }\n+                            } else {\n+                                false\n+                            }\n+                        })\n+                        .collect::<Vec<_>>();\n+                    if !inherent_impls_candidate.is_empty() {\n+                        inherent_impls_candidate.sort();\n+                        inherent_impls_candidate.dedup();\n+\n+                        // number of type to shows at most.\n+                        let limit = if inherent_impls_candidate.len() == 5 { 5 } else { 4 };\n+                        let type_candidates = inherent_impls_candidate\n+                            .iter()\n+                            .take(limit)\n+                            .map(|impl_item| {\n+                                format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n+                            })\n+                            .collect::<Vec<_>>()\n+                            .join(\"\\n\");\n+                        let additional_types = if inherent_impls_candidate.len() > limit {\n+                            format!(\"\\nand {} more types\", inherent_impls_candidate.len() - limit)\n+                        } else {\n+                            \"\".to_string()\n+                        };\n+                        err.note(&format!(\n+                            \"the {item_kind} was found for\\n{}{}\",\n+                            type_candidates, additional_types\n+                        ));\n+                    }\n+                }\n+            } else {\n+                let ty_str =\n+                    if ty_str.len() > 50 { String::new() } else { format!(\"on `{ty_str}` \") };\n+                err.span_label(\n+                    span,\n+                    format!(\"{item_kind} cannot be called {ty_str}due to unsatisfied trait bounds\"),\n+                );\n+            }\n+        };\n+\n+        // If the method name is the name of a field with a function or closure type,\n+        // give a helping note that it has to be called as `(x.f)(...)`.\n+        if let SelfSource::MethodCall(expr) = source {\n+            if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n+                && lev_candidate.is_none()\n+                && !custom_span_label\n+            {\n+                label_span_not_found(&mut err);\n+            }\n+        } else if !custom_span_label {\n+            label_span_not_found(&mut err);\n+        }\n+\n+        // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n+        // can't be called due to `typeof(expr): Clone` not holding.\n+        if unsatisfied_predicates.is_empty() {\n+            self.suggest_calling_method_on_field(&mut err, source, span, rcvr_ty, item_name);\n+        }\n+\n+        self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n+\n+        bound_spans.sort();\n+        bound_spans.dedup();\n+        for (span, msg) in bound_spans.into_iter() {\n+            err.span_label(span, &msg);\n+        }\n+\n+        if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n+        } else {\n+            self.suggest_traits_to_import(\n+                &mut err,\n+                span,\n+                rcvr_ty,\n+                item_name,\n+                args.map(|(_, args)| args.len() + 1),\n+                source,\n+                no_match_data.out_of_scope_traits.clone(),\n+                &unsatisfied_predicates,\n+                &static_candidates,\n+                unsatisfied_bounds,\n+            );\n+        }\n+\n+        // Don't emit a suggestion if we found an actual method\n+        // that had unsatisfied trait bounds\n+        if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n+            let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n+            if let Some(suggestion) = lev_distance::find_best_match_for_name(\n+                &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n+                item_name.name,\n+                None,\n+            ) {\n+                err.span_suggestion(\n+                    span,\n+                    \"there is a variant with a similar name\",\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+\n+        if item_name.name == sym::as_str && rcvr_ty.peel_refs().is_str() {\n+            let msg = \"remove this method call\";\n+            let mut fallback_span = true;\n+            if let SelfSource::MethodCall(expr) = source {\n+                let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().parent_id(expr.hir_id));\n+                if let Some(span) = call_expr.span.trim_start(expr.span) {\n+                    err.span_suggestion(span, msg, \"\", Applicability::MachineApplicable);\n+                    fallback_span = false;\n+                }\n+            }\n+            if fallback_span {\n+                err.span_label(span, msg);\n+            }\n+        } else if let Some(lev_candidate) = lev_candidate {\n+            // Don't emit a suggestion if we found an actual method\n+            // that had unsatisfied trait bounds\n+            if unsatisfied_predicates.is_empty() {\n+                let def_kind = lev_candidate.kind.as_def_kind();\n+                // Methods are defined within the context of a struct and their first parameter is always self,\n+                // which represents the instance of the struct the method is being called on\n+                // Associated functions don\u2019t take self as a parameter and\n+                // they are not methods because they don\u2019t have an instance of the struct to work with.\n+                if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n+                    err.span_suggestion(\n+                        span,\n+                        \"there is a method with a similar name\",\n+                        lev_candidate.name,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    err.span_suggestion(\n+                        span,\n+                        &format!(\n+                            \"there is {} {} with a similar name\",\n+                            def_kind.article(),\n+                            def_kind.descr(lev_candidate.def_id),\n+                        ),\n+                        lev_candidate.name,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+\n+        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name);\n+        return Some(err);\n+    }\n+\n+    fn note_candidates_on_method_error(\n+        &self,\n+        rcvr_ty: Ty<'tcx>,\n+        item_name: Ident,\n+        args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n+        span: Span,\n+        err: &mut Diagnostic,\n+        sources: &mut Vec<CandidateSource>,\n+        sugg_span: Option<Span>,\n+    ) {\n+        sources.sort();\n+        sources.dedup();\n+        // Dynamic limit to avoid hiding just one candidate, which is silly.\n+        let limit = if sources.len() == 5 { 5 } else { 4 };\n+\n+        for (idx, source) in sources.iter().take(limit).enumerate() {\n+            match *source {\n+                CandidateSource::Impl(impl_did) => {\n+                    // Provide the best span we can. Use the item, if local to crate, else\n+                    // the impl, if local to crate (item may be defaulted), else nothing.\n+                    let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n+                        let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n+                        self.associated_value(impl_trait_ref.def_id, item_name)\n+                    }) else {\n+                        continue;\n+                    };\n+\n+                    let note_span = if item.def_id.is_local() {\n+                        Some(self.tcx.def_span(item.def_id))\n+                    } else if impl_did.is_local() {\n+                        Some(self.tcx.def_span(impl_did))\n+                    } else {\n+                        None\n+                    };\n+\n+                    let impl_ty = self.tcx.at(span).type_of(impl_did);\n+\n+                    let insertion = match self.tcx.impl_trait_ref(impl_did) {\n+                        None => String::new(),\n+                        Some(trait_ref) => {\n+                            format!(\" of the trait `{}`\", self.tcx.def_path_str(trait_ref.def_id))\n+                        }\n+                    };\n+\n+                    let (note_str, idx) = if sources.len() > 1 {\n+                        (\n+                            format!(\n+                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                                idx + 1,\n+                                insertion,\n+                                impl_ty,\n+                            ),\n+                            Some(idx + 1),\n+                        )\n+                    } else {\n+                        (\n+                            format!(\n+                                \"the candidate is defined in an impl{} for the type `{}`\",\n+                                insertion, impl_ty,\n+                            ),\n+                            None,\n+                        )\n+                    };\n+                    if let Some(note_span) = note_span {\n+                        // We have a span pointing to the method. Show note with snippet.\n+                        err.span_note(note_span, &note_str);\n+                    } else {\n+                        err.note(&note_str);\n+                    }\n+                    if let Some(sugg_span) = sugg_span\n+                        && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n+                        let path = self.tcx.def_path_str(trait_ref.def_id);\n+\n+                        let ty = match item.kind {\n+                            ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n+                            ty::AssocKind::Fn => self\n+                                .tcx\n+                                .fn_sig(item.def_id)\n+                                .inputs()\n+                                .skip_binder()\n+                                .get(0)\n+                                .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n+                                .copied()\n+                                .unwrap_or(rcvr_ty),\n+                        };\n+                        print_disambiguation_help(\n+                            item_name,\n+                            args,\n+                            err,\n+                            path,\n+                            ty,\n+                            item.kind,\n+                            item.def_id,\n+                            sugg_span,\n+                            idx,\n+                            self.tcx.sess.source_map(),\n+                            item.fn_has_self_parameter,\n+                        );\n+                    }\n+                }\n+                CandidateSource::Trait(trait_did) => {\n+                    let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n+                    let item_span = self.tcx.def_span(item.def_id);\n+                    let idx = if sources.len() > 1 {\n+                        let msg = &format!(\n+                            \"candidate #{} is defined in the trait `{}`\",\n+                            idx + 1,\n+                            self.tcx.def_path_str(trait_did)\n+                        );\n+                        err.span_note(item_span, msg);\n+                        Some(idx + 1)\n+                    } else {\n+                        let msg = &format!(\n+                            \"the candidate is defined in the trait `{}`\",\n+                            self.tcx.def_path_str(trait_did)\n+                        );\n+                        err.span_note(item_span, msg);\n+                        None\n+                    };\n+                    if let Some(sugg_span) = sugg_span {\n+                        let path = self.tcx.def_path_str(trait_did);\n+                        print_disambiguation_help(\n+                            item_name,\n+                            args,\n+                            err,\n+                            path,\n+                            rcvr_ty,\n+                            item.kind,\n+                            item.def_id,\n+                            sugg_span,\n+                            idx,\n+                            self.tcx.sess.source_map(),\n+                            item.fn_has_self_parameter,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        if sources.len() > limit {\n+            err.note(&format!(\"and {} others\", sources.len() - limit));\n+        }\n+    }\n+\n     /// Suggest calling `Ty::method` if `.method()` isn't found because the method\n     /// doesn't take a `self` receiver.\n     fn suggest_associated_call_syntax(\n@@ -1265,7 +1300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n-                    let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+                    let call_expr = tcx.hir().expect_expr(tcx.hir().parent_id(expr.hir_id));\n \n                     if let Some(span) = call_expr.span.trim_start(item_name.span) {\n                         err.span_suggestion(\n@@ -1447,7 +1482,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n                         let parent_node =\n-                            self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n+                            self.tcx.hir().get_parent(hir_id);\n                         let msg = format!(\n                             \"you must specify a type for this binding, like `{}`\",\n                             concrete_type,\n@@ -1520,7 +1555,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut visitor = LetVisitor { result: None, ident_name: seg1.ident.name };\n         visitor.visit_body(&body);\n \n-        let parent = self.tcx.hir().get_parent_node(seg1.hir_id);\n+        let parent = self.tcx.hir().parent_id(seg1.hir_id);\n         if let Some(Node::Expr(call_expr)) = self.tcx.hir().find(parent)\n             && let Some(expr) = visitor.result\n             && let Some(self_ty) = self.node_ty_opt(expr.hir_id)\n@@ -1558,7 +1593,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         && let Some((fields, substs)) =\n             self.get_field_candidates_considering_privacy(span, actual, mod_id)\n         {\n-            let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+            let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().parent_id(expr.hir_id));\n \n             let lang_items = self.tcx.lang_items();\n             let never_mention_traits = [\n@@ -1628,7 +1663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n         let SelfSource::MethodCall(expr) = source else { return; };\n-        let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+        let call_expr = tcx.hir().expect_expr(tcx.hir().parent_id(expr.hir_id));\n \n         let ty::Adt(kind, substs) = actual.kind() else { return; };\n         match kind.adt_kind() {\n@@ -2589,7 +2624,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return false;\n         }\n \n-        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let parent = self.tcx.hir().parent_id(expr.hir_id);\n         if  let Some(Node::Expr(call_expr)) = self.tcx.hir().find(parent) &&\n             let hir::ExprKind::MethodCall(\n                 hir::PathSegment { ident: method_name, .. },"}, {"sha": "e0304fa2d3b98b017f04ca6927c86e06d40639d7", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -553,6 +553,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (lhs, Some((true, rhs_ty, rhs_sp))) => one_side_err(rhs_sp, rhs_ty, lhs),\n             _ => span_bug!(span, \"Impossible, verified above.\"),\n         }\n+        if (lhs, rhs).references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n         if self.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"In a match expression, only numbers and characters can be matched \\\n@@ -692,7 +695,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         if let PatKind::Ref(inner, mutbl) = pat.kind\n         && let PatKind::Binding(_, _, binding, ..) = inner.kind {\n-            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n+            let binding_parent_id = tcx.hir().parent_id(pat.hir_id);\n             let binding_parent = tcx.hir().get(binding_parent_id);\n             debug!(?inner, ?pat, ?binding_parent);\n \n@@ -936,7 +939,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         res.descr(),\n                     ),\n                 );\n-                match self.tcx.hir().get(self.tcx.hir().get_parent_node(pat.hir_id)) {\n+                match self.tcx.hir().get_parent(pat.hir_id) {\n                     hir::Node::PatField(..) => {\n                         e.span_suggestion_verbose(\n                             ident.span.shrink_to_hi(),"}, {"sha": "15179392c88cdb9166d901fa67b180bb19acec64", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1091,7 +1091,7 @@ impl<T: Idx> ToString for BitSet<T> {\n                 assert!(mask <= 0xFF);\n                 let byte = word & mask;\n \n-                result.push_str(&format!(\"{}{:02x}\", sep, byte));\n+                result.push_str(&format!(\"{sep}{byte:02x}\"));\n \n                 if remain <= 8 {\n                     break;"}, {"sha": "d809740c6ab31f8f332fc1689931bd3652dcd338", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -135,10 +135,7 @@ impl<I: Idx> IntervalSet<I> {\n         };\n         debug_assert!(\n             self.check_invariants(),\n-            \"wrong intervals after insert {:?}..={:?} to {:?}\",\n-            start,\n-            end,\n-            self\n+            \"wrong intervals after insert {start:?}..={end:?} to {self:?}\"\n         );\n         result\n     }"}, {"sha": "033a1842edb25c57c95ea20d97c910be67a82c3e", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 416, "deletions": 5, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,15 +1,18 @@\n use hir::GenericParamKind;\n use rustc_errors::{\n     fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n-    MultiSpan, SubdiagnosticMessage,\n+    IntoDiagnosticArg, MultiSpan, SubdiagnosticMessage,\n };\n use rustc_hir as hir;\n-use rustc_hir::{FnRetTy, Ty};\n+use rustc_hir::FnRetTy;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_middle::ty::{Region, TyCtxt};\n+use rustc_middle::ty::print::TraitRefPrintOnlyTraitPath;\n+use rustc_middle::ty::{Binder, FnSig, Region, Ty, TyCtxt};\n use rustc_span::symbol::kw;\n+use rustc_span::Symbol;\n use rustc_span::{symbol::Ident, BytePos, Span};\n \n+use crate::infer::error_reporting::nice_region_error::placeholder_error::Highlighted;\n use crate::infer::error_reporting::{\n     need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n     ObligationCauseAsDiagArg,\n@@ -357,8 +360,8 @@ impl AddToDiagnostic for LifetimeMismatchLabels {\n pub struct AddLifetimeParamsSuggestion<'a> {\n     pub tcx: TyCtxt<'a>,\n     pub sub: Region<'a>,\n-    pub ty_sup: &'a Ty<'a>,\n-    pub ty_sub: &'a Ty<'a>,\n+    pub ty_sup: &'a hir::Ty<'a>,\n+    pub ty_sub: &'a hir::Ty<'a>,\n     pub add_note: bool,\n }\n \n@@ -520,3 +523,411 @@ pub struct MismatchedStaticLifetime<'a> {\n     #[subdiagnostic]\n     pub implicit_static_lifetimes: Vec<ImplicitStaticLifetimeSubdiag>,\n }\n+\n+#[derive(Diagnostic)]\n+pub enum ExplicitLifetimeRequired<'a> {\n+    #[diag(infer_explicit_lifetime_required_with_ident, code = \"E0621\")]\n+    WithIdent {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        simple_ident: Ident,\n+        named: String,\n+        #[suggestion(\n+            infer_explicit_lifetime_required_sugg_with_ident,\n+            code = \"{new_ty}\",\n+            applicability = \"unspecified\"\n+        )]\n+        new_ty_span: Span,\n+        #[skip_arg]\n+        new_ty: Ty<'a>,\n+    },\n+    #[diag(infer_explicit_lifetime_required_with_param_type, code = \"E0621\")]\n+    WithParamType {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        named: String,\n+        #[suggestion(\n+            infer_explicit_lifetime_required_sugg_with_param_type,\n+            code = \"{new_ty}\",\n+            applicability = \"unspecified\"\n+        )]\n+        new_ty_span: Span,\n+        #[skip_arg]\n+        new_ty: Ty<'a>,\n+    },\n+}\n+\n+pub enum TyOrSig<'tcx> {\n+    Ty(Highlighted<'tcx, Ty<'tcx>>),\n+    ClosureSig(Highlighted<'tcx, Binder<'tcx, FnSig<'tcx>>>),\n+}\n+\n+impl IntoDiagnosticArg for TyOrSig<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        match self {\n+            TyOrSig::Ty(ty) => ty.into_diagnostic_arg(),\n+            TyOrSig::ClosureSig(sig) => sig.into_diagnostic_arg(),\n+        }\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ActualImplExplNotes<'tcx> {\n+    #[note(infer_actual_impl_expl_expected_signature_two)]\n+    ExpectedSignatureTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_any)]\n+    ExpectedSignatureAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_some)]\n+    ExpectedSignatureSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_nothing)]\n+    ExpectedSignatureNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_two)]\n+    ExpectedPassiveTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_any)]\n+    ExpectedPassiveAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_some)]\n+    ExpectedPassiveSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_nothing)]\n+    ExpectedPassiveNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_two)]\n+    ExpectedOtherTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_any)]\n+    ExpectedOtherAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_some)]\n+    ExpectedOtherSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_nothing)]\n+    ExpectedOtherNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_implements_trait)]\n+    ButActuallyImplementsTrait {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_implemented_for_ty)]\n+    ButActuallyImplementedForTy {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+        ty: String,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_ty_implements)]\n+    ButActuallyTyImplements {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+        ty: String,\n+    },\n+}\n+\n+pub enum ActualImplExpectedKind {\n+    Signature,\n+    Passive,\n+    Other,\n+}\n+\n+pub enum ActualImplExpectedLifetimeKind {\n+    Two,\n+    Any,\n+    Some,\n+    Nothing,\n+}\n+\n+impl<'tcx> ActualImplExplNotes<'tcx> {\n+    pub fn new_expected(\n+        kind: ActualImplExpectedKind,\n+        lt_kind: ActualImplExpectedLifetimeKind,\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    ) -> Self {\n+        match (kind, lt_kind) {\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedSignatureTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedSignatureAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedSignatureSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedSignatureNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedPassiveTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedPassiveAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedPassiveSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedPassiveNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedOtherTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedOtherAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedOtherSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedOtherNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_trait_placeholder_mismatch)]\n+pub struct TraitPlaceholderMismatch<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(label_satisfy)]\n+    pub satisfy_span: Option<Span>,\n+    #[label(label_where)]\n+    pub where_span: Option<Span>,\n+    #[label(label_dup)]\n+    pub dup_span: Option<Span>,\n+    pub def_id: String,\n+    pub trait_def_id: String,\n+\n+    #[subdiagnostic]\n+    pub actual_impl_expl_notes: Vec<ActualImplExplNotes<'tcx>>,\n+}\n+\n+pub struct ConsiderBorrowingParamHelp {\n+    pub spans: Vec<Span>,\n+}\n+\n+impl AddToDiagnostic for ConsiderBorrowingParamHelp {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let mut type_param_span: MultiSpan = self.spans.clone().into();\n+        for &span in &self.spans {\n+            // Seems like we can't call f() here as Into<DiagnosticMessage> is required\n+            type_param_span.push_span_label(span, fluent::infer_tid_consider_borrowing);\n+        }\n+        let msg = f(diag, fluent::infer_tid_param_help.into());\n+        diag.span_help(type_param_span, msg);\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(infer_tid_rel_help)]\n+pub struct RelationshipHelp;\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_trait_impl_diff)]\n+pub struct TraitImplDiff {\n+    #[primary_span]\n+    #[label(found)]\n+    pub sp: Span,\n+    #[label(expected)]\n+    pub trait_sp: Span,\n+    #[note(expected_found)]\n+    pub note: (),\n+    #[subdiagnostic]\n+    pub param_help: ConsiderBorrowingParamHelp,\n+    #[subdiagnostic]\n+    // Seems like subdiagnostics are always pushed to the end, so this one\n+    // also has to be a subdiagnostic to maintain order.\n+    pub rel_help: Option<RelationshipHelp>,\n+    pub expected: String,\n+    pub found: String,\n+}\n+\n+pub struct DynTraitConstraintSuggestion {\n+    pub span: Span,\n+    pub ident: Ident,\n+}\n+\n+impl AddToDiagnostic for DynTraitConstraintSuggestion {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let mut multi_span: MultiSpan = vec![self.span].into();\n+        multi_span.push_span_label(self.span, fluent::infer_dtcs_has_lifetime_req_label);\n+        multi_span.push_span_label(self.ident.span, fluent::infer_dtcs_introduces_requirement);\n+        let msg = f(diag, fluent::infer_dtcs_has_req_note.into());\n+        diag.span_note(multi_span, msg);\n+        let msg = f(diag, fluent::infer_dtcs_suggestion.into());\n+        diag.span_suggestion_verbose(\n+            self.span.shrink_to_hi(),\n+            msg,\n+            \" + '_\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_but_calling_introduces, code = \"E0772\")]\n+pub struct ButCallingIntroduces {\n+    #[label(label1)]\n+    pub param_ty_span: Span,\n+    #[primary_span]\n+    #[label(label2)]\n+    pub cause_span: Span,\n+\n+    pub has_param_name: bool,\n+    pub param_name: String,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+    pub assoc_item: Symbol,\n+    pub has_impl_path: bool,\n+    pub impl_path: String,\n+}\n+\n+pub struct ReqIntroducedLocations {\n+    pub span: MultiSpan,\n+    pub spans: Vec<Span>,\n+    pub fn_decl_span: Span,\n+    pub cause_span: Span,\n+    pub add_label: bool,\n+}\n+\n+impl AddToDiagnostic for ReqIntroducedLocations {\n+    fn add_to_diagnostic_with<F>(mut self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        for sp in self.spans {\n+            self.span.push_span_label(sp, fluent::infer_ril_introduced_here);\n+        }\n+\n+        if self.add_label {\n+            self.span.push_span_label(self.fn_decl_span, fluent::infer_ril_introduced_by);\n+        }\n+        self.span.push_span_label(self.cause_span, fluent::infer_ril_because_of);\n+        let msg = f(diag, fluent::infer_ril_static_introduced_by.into());\n+        diag.span_note(self.span, msg);\n+    }\n+}\n+\n+pub struct MoreTargeted {\n+    pub ident: Symbol,\n+}\n+\n+impl AddToDiagnostic for MoreTargeted {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.code(rustc_errors::error_code!(E0772));\n+        diag.set_primary_message(fluent::infer_more_targeted);\n+        diag.set_arg(\"ident\", self.ident);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_but_needs_to_satisfy, code = \"E0759\")]\n+pub struct ButNeedsToSatisfy {\n+    #[primary_span]\n+    pub sp: Span,\n+    #[label(influencer)]\n+    pub influencer_point: Span,\n+    #[label(used_here)]\n+    pub spans: Vec<Span>,\n+    #[label(require)]\n+    pub require_span_as_label: Option<Span>,\n+    #[note(require)]\n+    pub require_span_as_note: Option<Span>,\n+    #[note(introduced_by_bound)]\n+    pub bound: Option<Span>,\n+\n+    #[subdiagnostic]\n+    pub req_introduces_loc: Option<ReqIntroducedLocations>,\n+\n+    pub spans_empty: bool,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+}"}, {"sha": "d816a9ed3d7c102517e024ac39f0d9a3eb52e863", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -427,3 +427,15 @@ impl<'tcx> ToTrace<'tcx> for ty::AliasTy<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> ToTrace<'tcx> for ty::FnSig<'tcx> {\n+    fn to_trace(\n+        _: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        TypeTrace { cause: cause.clone(), values: Sigs(ExpectedFound::new(a_is_expected, a, b)) }\n+    }\n+}"}, {"sha": "5c3e9a2d5cccd904de3a8d9756f5fb9ef7ba82c8", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! Error Reporting Code for the inference engine\n //!\n //! Because of the way inference, and in particular region inference,\n@@ -303,6 +302,7 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n                     None,\n                     format!(\"captures `{}`\", hidden_region),\n                     None,\n+                    Some(reg_info.def_id),\n                 )\n             }\n         }\n@@ -1428,8 +1428,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         impl<'tcx> OpaqueTypesVisitor<'tcx> {\n             fn visit_expected_found(\n                 tcx: TyCtxt<'tcx>,\n-                expected: Ty<'tcx>,\n-                found: Ty<'tcx>,\n+                expected: impl TypeVisitable<'tcx>,\n+                found: impl TypeVisitable<'tcx>,\n                 ignore_span: Span,\n             ) -> Self {\n                 let mut types_visitor = OpaqueTypesVisitor {\n@@ -1569,6 +1569,11 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             _ => (false, Mismatch::Fixed(\"type\")),\n                         }\n                     }\n+                    ValuePairs::Sigs(infer::ExpectedFound { expected, found }) => {\n+                        OpaqueTypesVisitor::visit_expected_found(self.tcx, expected, found, span)\n+                            .report(diag);\n+                        (false, Mismatch::Fixed(\"signature\"))\n+                    }\n                     ValuePairs::TraitRefs(_) | ValuePairs::PolyTraitRefs(_) => {\n                         (false, Mismatch::Fixed(\"trait\"))\n                     }\n@@ -2040,6 +2045,17 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     ret => ret,\n                 }\n             }\n+            infer::Sigs(exp_found) => {\n+                let exp_found = self.resolve_vars_if_possible(exp_found);\n+                if exp_found.references_error() {\n+                    return None;\n+                }\n+                let (exp, fnd) = self.cmp_fn_sig(\n+                    &ty::Binder::dummy(exp_found.expected),\n+                    &ty::Binder::dummy(exp_found.found),\n+                );\n+                Some((exp, fnd, None, None))\n+            }\n         }\n     }\n "}, {"sha": "59fb74eb54378f0c1e836c33214251659871d701", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -9,7 +9,7 @@ mod different_lifetimes;\n pub mod find_anon_type;\n mod mismatched_static_lifetime;\n mod named_anon_conflict;\n-mod placeholder_error;\n+pub(crate) mod placeholder_error;\n mod placeholder_relation;\n mod static_impl_trait;\n mod trait_impl_difference;"}, {"sha": "4e13ec90228d66c8b451cb885b17ed794094e258", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,8 +1,11 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n-use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use crate::{\n+    errors::ExplicitLifetimeRequired,\n+    infer::error_reporting::nice_region_error::find_anon_type::find_anon_type,\n+};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_middle::ty;\n use rustc_span::symbol::kw;\n \n@@ -86,31 +89,17 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         {\n             return None;\n         }\n-\n-        let (error_var, span_label_var) = match param.pat.simple_ident() {\n-            Some(simple_ident) => (\n-                format!(\"the type of `{}`\", simple_ident),\n-                format!(\"the type of `{}`\", simple_ident),\n-            ),\n-            None => (\"parameter type\".to_owned(), \"type\".to_owned()),\n+        let named = named.to_string();\n+        let err = match param.pat.simple_ident() {\n+            Some(simple_ident) => ExplicitLifetimeRequired::WithIdent {\n+                span,\n+                simple_ident,\n+                named,\n+                new_ty_span,\n+                new_ty,\n+            },\n+            None => ExplicitLifetimeRequired::WithParamType { span, named, new_ty_span, new_ty },\n         };\n-\n-        let mut diag = struct_span_err!(\n-            self.tcx().sess,\n-            span,\n-            E0621,\n-            \"explicit lifetime required in {}\",\n-            error_var\n-        );\n-\n-        diag.span_label(span, format!(\"lifetime `{}` required\", named));\n-        diag.span_suggestion(\n-            new_ty_span,\n-            &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n-            new_ty,\n-            Applicability::Unspecified,\n-        );\n-\n-        Some(diag)\n+        Some(self.tcx().sess.parse_sess.create_err(err))\n     }\n }"}, {"sha": "202f39521e967d7283fbfe8b747ccb94788878ed", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 155, "deletions": 156, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,18 +1,58 @@\n+use crate::errors::{\n+    ActualImplExpectedKind, ActualImplExpectedLifetimeKind, ActualImplExplNotes,\n+    TraitPlaceholderMismatch, TyOrSig,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, RePlaceholder, ReVar, Region, TyCtxt};\n \n-use std::fmt::{self, Write};\n+use std::fmt;\n+\n+// HACK(eddyb) maybe move this in a more central location.\n+#[derive(Copy, Clone)]\n+pub struct Highlighted<'tcx, T> {\n+    tcx: TyCtxt<'tcx>,\n+    highlight: RegionHighlightMode<'tcx>,\n+    value: T,\n+}\n+\n+impl<'tcx, T> IntoDiagnosticArg for Highlighted<'tcx, T>\n+where\n+    T: for<'a> Print<'tcx, FmtPrinter<'a, 'tcx>, Error = fmt::Error, Output = FmtPrinter<'a, 'tcx>>,\n+{\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        rustc_errors::DiagnosticArgValue::Str(self.to_string().into())\n+    }\n+}\n+\n+impl<'tcx, T> Highlighted<'tcx, T> {\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'tcx, U> {\n+        Highlighted { tcx: self.tcx, highlight: self.highlight, value: f(self.value) }\n+    }\n+}\n+\n+impl<'tcx, T> fmt::Display for Highlighted<'tcx, T>\n+where\n+    T: for<'a> Print<'tcx, FmtPrinter<'a, 'tcx>, Error = fmt::Error, Output = FmtPrinter<'a, 'tcx>>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n+        printer.region_highlight_mode = self.highlight;\n+\n+        let s = self.value.print(printer)?.into_buffer();\n+        f.write_str(&s)\n+    }\n+}\n \n impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n@@ -205,26 +245,21 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_substs: SubstsRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let span = cause.span();\n-        let msg = format!(\n-            \"implementation of `{}` is not general enough\",\n-            self.tcx().def_path_str(trait_def_id),\n-        );\n-        let mut err = self.tcx().sess.struct_span_err(span, &msg);\n-\n-        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id)\n-        | ObligationCauseCode::ExprItemObligation(def_id, ..) =\n-            *cause.code()\n-        {\n-            err.span_label(span, \"doesn't satisfy where-clause\");\n-            err.span_label(\n-                self.tcx().def_span(def_id),\n-                &format!(\"due to a where-clause on `{}`...\", self.tcx().def_path_str(def_id)),\n-            );\n-            true\n-        } else {\n-            err.span_label(span, &msg);\n-            false\n-        };\n+\n+        let (leading_ellipsis, satisfy_span, where_span, dup_span, def_id) =\n+            if let ObligationCauseCode::ItemObligation(def_id)\n+            | ObligationCauseCode::ExprItemObligation(def_id, ..) = *cause.code()\n+            {\n+                (\n+                    true,\n+                    Some(span),\n+                    Some(self.tcx().def_span(def_id)),\n+                    None,\n+                    self.tcx().def_path_str(def_id),\n+                )\n+            } else {\n+                (false, None, None, Some(span), String::new())\n+            };\n \n         let expected_trait_ref = self\n             .cx\n@@ -284,8 +319,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             ?expected_self_ty_has_vid,\n         );\n \n-        self.explain_actual_impl_that_was_found(\n-            &mut err,\n+        let actual_impl_expl_notes = self.explain_actual_impl_that_was_found(\n             sub_placeholder,\n             sup_placeholder,\n             has_sub,\n@@ -299,7 +333,15 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             leading_ellipsis,\n         );\n \n-        err\n+        self.tcx().sess.create_err(TraitPlaceholderMismatch {\n+            span,\n+            satisfy_span,\n+            where_span,\n+            dup_span,\n+            def_id,\n+            trait_def_id: self.tcx().def_path_str(trait_def_id),\n+            actual_impl_expl_notes,\n+        })\n     }\n \n     /// Add notes with details about the expected and actual trait refs, with attention to cases\n@@ -309,7 +351,6 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// due to the number of combinations we have to deal with.\n     fn explain_actual_impl_that_was_found(\n         &self,\n-        err: &mut Diagnostic,\n         sub_placeholder: Option<Region<'tcx>>,\n         sup_placeholder: Option<Region<'tcx>>,\n         has_sub: Option<usize>,\n@@ -321,39 +362,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n         leading_ellipsis: bool,\n-    ) {\n-        // HACK(eddyb) maybe move this in a more central location.\n-        #[derive(Copy, Clone)]\n-        struct Highlighted<'tcx, T> {\n-            tcx: TyCtxt<'tcx>,\n-            highlight: RegionHighlightMode<'tcx>,\n-            value: T,\n-        }\n-\n-        impl<'tcx, T> Highlighted<'tcx, T> {\n-            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'tcx, U> {\n-                Highlighted { tcx: self.tcx, highlight: self.highlight, value: f(self.value) }\n-            }\n-        }\n-\n-        impl<'tcx, T> fmt::Display for Highlighted<'tcx, T>\n-        where\n-            T: for<'a> Print<\n-                'tcx,\n-                FmtPrinter<'a, 'tcx>,\n-                Error = fmt::Error,\n-                Output = FmtPrinter<'a, 'tcx>,\n-            >,\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n-                printer.region_highlight_mode = self.highlight;\n-\n-                let s = self.value.print(printer)?.into_buffer();\n-                f.write_str(&s)\n-            }\n-        }\n-\n+    ) -> Vec<ActualImplExplNotes<'tcx>> {\n         // The weird thing here with the `maybe_highlighting_region` calls and the\n         // the match inside is meant to be like this:\n         //\n@@ -380,120 +389,110 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n         expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n         expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n-        err.note(&{\n-            let passive_voice = match (has_sub, has_sup) {\n-                (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n-                (None, None) => {\n-                    expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n-                    match expected_has_vid {\n-                        Some(_) => true,\n-                        None => any_self_ty_has_vid,\n-                    }\n-                }\n-            };\n \n-            let mut note = if same_self_type {\n-                let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n-                self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-\n-                if self_ty.value.is_closure()\n-                    && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n-                {\n-                    let closure_sig = self_ty.map(|closure| {\n-                        if let ty::Closure(_, substs) = closure.kind() {\n-                            self.tcx().signature_unclosure(\n-                                substs.as_closure().sig(),\n-                                rustc_hir::Unsafety::Normal,\n-                            )\n-                        } else {\n-                            bug!(\"type is not longer closure\");\n-                        }\n-                    });\n-\n-                    format!(\n-                        \"{}closure with signature `{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        closure_sig,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n-                } else {\n-                    format!(\n-                        \"{}`{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        self_ty,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n+        let passive_voice = match (has_sub, has_sup) {\n+            (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n+            (None, None) => {\n+                expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n+                match expected_has_vid {\n+                    Some(_) => true,\n+                    None => any_self_ty_has_vid,\n                 }\n-            } else if passive_voice {\n-                format!(\n-                    \"{}`{}` would have to be implemented for the type `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n+            }\n+        };\n+\n+        let (kind, ty_or_sig, trait_path) = if same_self_type {\n+            let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n+            self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+\n+            if self_ty.value.is_closure() && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n+            {\n+                let closure_sig = self_ty.map(|closure| {\n+                    if let ty::Closure(_, substs) = closure.kind() {\n+                        self.tcx().signature_unclosure(\n+                            substs.as_closure().sig(),\n+                            rustc_hir::Unsafety::Normal,\n+                        )\n+                    } else {\n+                        bug!(\"type is not longer closure\");\n+                    }\n+                });\n+                (\n+                    ActualImplExpectedKind::Signature,\n+                    TyOrSig::ClosureSig(closure_sig),\n                     expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n-                format!(\n-                    \"{}`{}` must implement `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                (\n+                    ActualImplExpectedKind::Other,\n+                    TyOrSig::Ty(self_ty),\n                     expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n                 )\n-            };\n+            }\n+        } else if passive_voice {\n+            (\n+                ActualImplExpectedKind::Passive,\n+                TyOrSig::Ty(expected_trait_ref.map(|tr| tr.self_ty())),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+            )\n+        } else {\n+            (\n+                ActualImplExpectedKind::Other,\n+                TyOrSig::Ty(expected_trait_ref.map(|tr| tr.self_ty())),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+            )\n+        };\n \n-            match (has_sub, has_sup) {\n-                (Some(n1), Some(n2)) => {\n-                    let _ = write!(\n-                        note,\n-                        \", for any two lifetimes `'{}` and `'{}`...\",\n-                        std::cmp::min(n1, n2),\n-                        std::cmp::max(n1, n2),\n-                    );\n-                }\n-                (Some(n), _) | (_, Some(n)) => {\n-                    let _ = write!(note, \", for any lifetime `'{}`...\", n,);\n-                }\n-                (None, None) => {\n-                    if let Some(n) = expected_has_vid {\n-                        let _ = write!(note, \", for some specific lifetime `'{}`...\", n,);\n-                    }\n+        let (lt_kind, lifetime_1, lifetime_2) = match (has_sub, has_sup) {\n+            (Some(n1), Some(n2)) => {\n+                (ActualImplExpectedLifetimeKind::Two, std::cmp::min(n1, n2), std::cmp::max(n1, n2))\n+            }\n+            (Some(n), _) | (_, Some(n)) => (ActualImplExpectedLifetimeKind::Any, n, 0),\n+            (None, None) => {\n+                if let Some(n) = expected_has_vid {\n+                    (ActualImplExpectedLifetimeKind::Some, n, 0)\n+                } else {\n+                    (ActualImplExpectedLifetimeKind::Nothing, 0, 0)\n                 }\n             }\n+        };\n \n-            note\n-        });\n+        let note_1 = ActualImplExplNotes::new_expected(\n+            kind,\n+            lt_kind,\n+            leading_ellipsis,\n+            ty_or_sig,\n+            trait_path,\n+            lifetime_1,\n+            lifetime_2,\n+        );\n \n         let mut actual_trait_ref = highlight_trait_ref(actual_trait_ref);\n         actual_trait_ref.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-        err.note(&{\n-            let passive_voice = match actual_has_vid {\n-                Some(_) => any_self_ty_has_vid,\n-                None => true,\n-            };\n \n-            let mut note = if same_self_type {\n-                format!(\n-                    \"...but it actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            } else if passive_voice {\n-                format!(\n-                    \"...but `{}` is actually implemented for the type `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                )\n-            } else {\n-                format!(\n-                    \"...but `{}` actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            };\n+        let passive_voice = match actual_has_vid {\n+            Some(_) => any_self_ty_has_vid,\n+            None => true,\n+        };\n \n-            if let Some(n) = actual_has_vid {\n-                let _ = write!(note, \", for some specific lifetime `'{}`\", n);\n+        let trait_path = actual_trait_ref.map(|tr| tr.print_only_trait_path());\n+        let ty = actual_trait_ref.map(|tr| tr.self_ty()).to_string();\n+        let has_lifetime = actual_has_vid.is_some();\n+        let lifetime = actual_has_vid.unwrap_or_default();\n+\n+        let note_2 = if same_self_type {\n+            ActualImplExplNotes::ButActuallyImplementsTrait { trait_path, has_lifetime, lifetime }\n+        } else if passive_voice {\n+            ActualImplExplNotes::ButActuallyImplementedForTy {\n+                trait_path,\n+                ty,\n+                has_lifetime,\n+                lifetime,\n             }\n+        } else {\n+            ActualImplExplNotes::ButActuallyTyImplements { trait_path, ty, has_lifetime, lifetime }\n+        };\n \n-            note\n-        });\n+        vec![note_1, note_2]\n     }\n }"}, {"sha": "fb0f09198ccc185330064cb2b7df525d1048f26c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 197, "deletions": 199, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,20 +1,28 @@\n //! Error Reporting for static impl Traits.\n \n+use crate::errors::{\n+    ButCallingIntroduces, ButNeedsToSatisfy, DynTraitConstraintSuggestion, MoreTargeted,\n+    ReqIntroducedLocations,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{AddToDiagnostic, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n-use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n+use rustc_hir::{\n+    self as hir, GenericBound, GenericParamKind, Item, ItemKind, Lifetime, LifetimeName, Node,\n+    TyKind,\n+};\n use rustc_middle::ty::{\n     self, AssocItemContainer, StaticLifetimeVisitor, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n+use rustc_span::def_id::LocalDefId;\n use std::ops::ControlFlow;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -49,46 +57,32 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     }\n \n                     let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-                    let lifetime = if sup_r.has_name() {\n-                        format!(\"lifetime `{}`\", sup_r)\n-                    } else {\n-                        \"an anonymous lifetime `'_`\".to_string()\n+                    let simple_ident = param.param.pat.simple_ident();\n+\n+                    let (has_impl_path, impl_path) = match ctxt.assoc_item.container {\n+                        AssocItemContainer::TraitContainer => {\n+                            let id = ctxt.assoc_item.container_id(tcx);\n+                            (true, tcx.def_path_str(id))\n+                        }\n+                        AssocItemContainer::ImplContainer => (false, String::new()),\n                     };\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        cause.span,\n-                        E0772,\n-                        \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                         requirement\",\n-                        param\n-                            .param\n-                            .pat\n-                            .simple_ident()\n-                            .map(|s| format!(\"`{}`\", s))\n-                            .unwrap_or_else(|| \"`fn` parameter\".to_string()),\n-                        lifetime,\n-                        ctxt.assoc_item.name,\n-                    );\n-                    err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n-                    err.span_label(\n-                        cause.span,\n-                        &format!(\n-                            \"...is used and required to live as long as `'static` here \\\n-                             because of an implicit lifetime bound on the {}\",\n-                            match ctxt.assoc_item.container {\n-                                AssocItemContainer::TraitContainer => {\n-                                    let id = ctxt.assoc_item.container_id(tcx);\n-                                    format!(\"`impl` of `{}`\", tcx.def_path_str(id))\n-                                }\n-                                AssocItemContainer::ImplContainer => \"inherent `impl`\".to_string(),\n-                            },\n-                        ),\n-                    );\n+\n+                    let mut err = self.tcx().sess.create_err(ButCallingIntroduces {\n+                        param_ty_span: param.param_ty_span,\n+                        cause_span: cause.span,\n+                        has_param_name: simple_ident.is_some(),\n+                        param_name: simple_ident.map(|x| x.to_string()).unwrap_or_default(),\n+                        has_lifetime: sup_r.has_name(),\n+                        lifetime: sup_r.to_string(),\n+                        assoc_item: ctxt.assoc_item.name,\n+                        has_impl_path,\n+                        impl_path,\n+                    });\n                     if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n                         let reported = err.emit();\n                         return Some(reported);\n                     } else {\n-                        err.cancel();\n+                        err.cancel()\n                     }\n                 }\n                 return None;\n@@ -104,25 +98,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sp = var_origin.span();\n         let return_sp = sub_origin.span();\n         let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-        let (lifetime_name, lifetime) = if sup_r.has_name() {\n-            (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n-        } else {\n-            (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-        };\n-        let param_name = param\n-            .param\n-            .pat\n-            .simple_ident()\n-            .map(|s| format!(\"`{}`\", s))\n-            .unwrap_or_else(|| \"`fn` parameter\".to_string());\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            sp,\n-            E0759,\n-            \"{} has {} but it needs to satisfy a `'static` lifetime requirement\",\n-            param_name,\n-            lifetime,\n-        );\n+        let lifetime_name = if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n \n         let (mention_influencer, influencer_point) =\n             if sup_origin.span().overlaps(param.param_ty_span) {\n@@ -141,7 +117,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             } else {\n                 (!sup_origin.span().overlaps(return_sp), param.param_ty_span)\n             };\n-        err.span_label(influencer_point, &format!(\"this data with {}...\", lifetime));\n \n         debug!(\"try_report_static_impl_trait: param_info={:?}\", param);\n \n@@ -155,65 +130,70 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         spans.dedup_by_key(|span| (span.lo(), span.hi()));\n \n         // We try to make the output have fewer overlapping spans if possible.\n-        let require_msg = if spans.is_empty() {\n-            \"...is used and required to live as long as `'static` here\"\n-        } else {\n-            \"...and is required to live as long as `'static` here\"\n-        };\n         let require_span =\n             if sup_origin.span().overlaps(return_sp) { sup_origin.span() } else { return_sp };\n \n-        for span in &spans {\n-            err.span_label(*span, \"...is used here...\");\n-        }\n-\n-        if spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp) {\n-            // If any of the \"captured here\" labels appears on the same line or after\n-            // `require_span`, we put it on a note to ensure the text flows by appearing\n-            // always at the end.\n-            err.span_note(require_span, require_msg);\n+        let spans_empty = spans.is_empty();\n+        let require_as_note = spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp);\n+        let bound = if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n+            Some(*bound)\n         } else {\n-            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n-            err.span_label(require_span, require_msg);\n-        }\n+            None\n+        };\n+\n+        let mut subdiag = None;\n \n-        if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n-            err.span_note(*bound, \"`'static` lifetime requirement introduced by this bound\");\n-        }\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = sub_origin {\n             if let ObligationCauseCode::ReturnValue(hir_id)\n             | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n                 if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id.into()) {\n                     let mut span: MultiSpan = fn_decl.output.span().into();\n+                    let mut spans = Vec::new();\n                     let mut add_label = true;\n                     if let hir::FnRetTy::Return(ty) = fn_decl.output {\n                         let mut v = StaticLifetimeVisitor(vec![], tcx.hir());\n                         v.visit_ty(ty);\n                         if !v.0.is_empty() {\n                             span = v.0.clone().into();\n-                            for sp in v.0 {\n-                                span.push_span_label(sp, \"`'static` requirement introduced here\");\n-                            }\n+                            spans = v.0;\n                             add_label = false;\n                         }\n                     }\n-                    if add_label {\n-                        span.push_span_label(\n-                            fn_decl.output.span(),\n-                            \"requirement introduced by this return type\",\n-                        );\n-                    }\n-                    span.push_span_label(cause.span, \"because of this returned expression\");\n-                    err.span_note(\n+                    let fn_decl_span = fn_decl.output.span();\n+\n+                    subdiag = Some(ReqIntroducedLocations {\n                         span,\n-                        \"`'static` lifetime requirement introduced by the return type\",\n-                    );\n+                        spans,\n+                        fn_decl_span,\n+                        cause_span: cause.span,\n+                        add_label,\n+                    });\n                 }\n             }\n         }\n \n+        let diag = ButNeedsToSatisfy {\n+            sp,\n+            influencer_point,\n+            spans: spans.clone(),\n+            // If any of the \"captured here\" labels appears on the same line or after\n+            // `require_span`, we put it on a note to ensure the text flows by appearing\n+            // always at the end.\n+            require_span_as_note: require_as_note.then_some(require_span),\n+            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n+            require_span_as_label: (!require_as_note).then_some(require_span),\n+            req_introduces_loc: subdiag,\n+\n+            has_lifetime: sup_r.has_name(),\n+            lifetime: sup_r.to_string(),\n+            spans_empty,\n+            bound,\n+        };\n+\n+        let mut err = self.tcx().sess.create_err(diag);\n+\n         let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n \n         let mut override_error_code = None;\n@@ -239,20 +219,16 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut v = TraitObjectVisitor(FxIndexSet::default());\n             v.visit_ty(param.param_ty);\n             if let Some((ident, self_ty)) =\n-                self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n+                NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, item_def_id, &v.0)\n                 && self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty)\n             {\n                 override_error_code = Some(ident.name);\n             }\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {\n             // Provide a more targeted error code and description.\n-            err.code(rustc_errors::error_code!(E0772));\n-            err.set_primary_message(&format!(\n-                \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                requirement\",\n-                param_name, lifetime, ident,\n-            ));\n+            let retarget_subdiag = MoreTargeted { ident };\n+            retarget_subdiag.add_to_diagnostic(&mut err);\n         }\n \n         let arg = match param.param.pat.simple_ident() {\n@@ -268,6 +244,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             Some(arg),\n             captures,\n             Some((param.param_ty_span, param.param_ty.to_string())),\n+            Some(anon_reg_sup.def_id),\n         );\n \n         let reported = err.emit();\n@@ -283,6 +260,7 @@ pub fn suggest_new_region_bound(\n     arg: Option<String>,\n     captures: String,\n     param: Option<(Span, String)>,\n+    scope_def_id: Option<LocalDefId>,\n ) {\n     debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n     // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n@@ -309,19 +287,12 @@ pub fn suggest_new_region_bound(\n                 let did = item_id.owner_id.to_def_id();\n                 let ty = tcx.mk_opaque(did, ty::InternalSubsts::identity_for_item(tcx, did));\n \n-                if let Some(span) = opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime {\n-                            res: LifetimeName::Static,\n-                            ident,\n-                            ..\n-                        }) => Some(ident.span),\n-                        _ => None,\n-                    })\n-                    .next()\n-                {\n+                if let Some(span) = opaque.bounds.iter().find_map(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime {\n+                        res: LifetimeName::Static, ident, ..\n+                    }) => Some(ident.span),\n+                    _ => None,\n+                }) {\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n@@ -338,27 +309,78 @@ pub fn suggest_new_region_bound(\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n-                } else if opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime { ident, .. })\n-                            if ident.name.to_string() == lifetime_name =>\n-                        {\n-                            Some(ident.span)\n-                        }\n-                        _ => None,\n-                    })\n-                    .next()\n-                    .is_some()\n-                {\n+                } else if opaque.bounds.iter().any(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime { ident, .. })\n+                        if ident.name.to_string() == lifetime_name =>\n+                    {\n+                        true\n+                    }\n+                    _ => false,\n+                }) {\n                 } else {\n-                    err.span_suggestion_verbose(\n-                        fn_return.span.shrink_to_hi(),\n-                        &format!(\"{declare} `{ty}` {captures}, {explicit}\",),\n-                        &plus_lt,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    // get a lifetime name of existing named lifetimes if any\n+                    let existing_lt_name = if let Some(id) = scope_def_id\n+                        && let Some(generics) = tcx.hir().get_generics(id)\n+                        && let named_lifetimes = generics\n+                        .params\n+                        .iter()\n+                        .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }))\n+                        .map(|p| { if let hir::ParamName::Plain(name) = p.name {Some(name.to_string())} else {None}})\n+                        .filter(|n| ! matches!(n, None))\n+                        .collect::<Vec<_>>()\n+                        && named_lifetimes.len() > 0 {\n+                        named_lifetimes[0].clone()\n+                    } else {\n+                        None\n+                    };\n+                    let name = if let Some(name) = &existing_lt_name {\n+                        format!(\"{}\", name)\n+                    } else {\n+                        format!(\"'a\")\n+                    };\n+                    // if there are more than one elided lifetimes in inputs, the explicit `'_` lifetime cannot be used.\n+                    // introducing a new lifetime `'a` or making use of one from existing named lifetimes if any\n+                    if let Some(id) = scope_def_id\n+                        && let Some(generics) = tcx.hir().get_generics(id)\n+                        && let mut spans_suggs = generics\n+                            .params\n+                            .iter()\n+                            .filter(|p| p.is_elided_lifetime())\n+                            .map(|p|\n+                                  if p.span.hi() - p.span.lo() == rustc_span::BytePos(1) { // Ampersand (elided without '_)\n+                                      (p.span.shrink_to_hi(),format!(\"{name} \"))\n+                                  } else { // Underscore (elided with '_)\n+                                      (p.span, format!(\"{name}\"))\n+                                  }\n+                            )\n+                            .collect::<Vec<_>>()\n+                        && spans_suggs.len() > 1\n+                    {\n+                        let use_lt =\n+                        if existing_lt_name == None {\n+                            spans_suggs.push((generics.span.shrink_to_hi(), format!(\"<{name}>\")));\n+                            format!(\"you can introduce a named lifetime parameter `{name}`\")\n+                        } else {\n+                            // make use the existing named lifetime\n+                            format!(\"you can use the named lifetime parameter `{name}`\")\n+                        };\n+                        spans_suggs\n+                            .push((fn_return.span.shrink_to_hi(), format!(\" + {name} \")));\n+                        err.multipart_suggestion_verbose(\n+                            &format!(\n+                                \"{declare} `{ty}` {captures}, {use_lt}\",\n+                            ),\n+                            spans_suggs,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_suggestion_verbose(\n+                            fn_return.span.shrink_to_hi(),\n+                            &format!(\"{declare} `{ty}` {captures}, {explicit}\",),\n+                            &plus_lt,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 }\n             }\n             TyKind::TraitObject(_, lt, _) => {\n@@ -403,66 +425,54 @@ pub fn suggest_new_region_bound(\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n+    pub fn get_impl_ident_and_self_ty_from_trait(\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         trait_objects: &FxIndexSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.tcx();\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+        match tcx.hir().get_if_local(def_id)? {\n+            Node::ImplItem(impl_item) => {\n+                let impl_did = tcx.hir().get_parent_item(impl_item.hir_id());\n+                if let hir::OwnerNode::Item(Item {\n+                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                    ..\n+                }) = tcx.hir().owner(impl_did)\n                 {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n+                    Some((impl_item.ident, self_ty))\n+                } else {\n+                    None\n                 }\n             }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                            .next()\n-                        {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n+            Node::TraitItem(trait_item) => {\n+                let trait_id = tcx.hir().get_parent_item(trait_item.hir_id());\n+                debug_assert_eq!(tcx.def_kind(trait_id.def_id), hir::def::DefKind::Trait);\n+                // The method being called is defined in the `trait`, but the `'static`\n+                // obligation comes from the `impl`. Find that `impl` so that we can point\n+                // at it in the suggestion.\n+                let trait_did = trait_id.to_def_id();\n+                tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n+                    if let Node::Item(Item {\n+                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                        ..\n+                    }) = tcx.hir().find_by_def_id(impl_did)?\n+                        && trait_objects.iter().all(|did| {\n+                            // FIXME: we should check `self_ty` against the receiver\n+                            // type in the `UnifyReceiver` context, but for now, use\n+                            // this imperfect proxy. This will fail if there are\n+                            // multiple `impl`s for the same trait like\n+                            // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                            // In that case, only the first one will get suggestions.\n+                            let mut traits = vec![];\n+                            let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                            hir_v.visit_ty(self_ty);\n+                            !traits.is_empty()\n+                        })\n+                    {\n+                        Some((trait_item.ident, *self_ty))\n+                    } else {\n+                        None\n                     }\n-                    _ => None,\n-                }\n+                })\n             }\n             _ => None,\n         }\n@@ -493,7 +503,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n         // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n-        let Some((ident, self_ty)) = self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) else {\n+        let Some((ident, self_ty)) = NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &v.0) else {\n             return false;\n         };\n \n@@ -513,21 +523,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut traits = vec![];\n             let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n             hir_v.visit_ty(&self_ty);\n-            for span in &traits {\n-                let mut multi_span: MultiSpan = vec![*span].into();\n-                multi_span\n-                    .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n-                multi_span.push_span_label(\n-                    ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\",\n-                );\n-                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"consider relaxing the implicit `'static` requirement\",\n-                    \" + '_\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+            for &span in &traits {\n+                let subdiag = DynTraitConstraintSuggestion { span, ident };\n+                subdiag.add_to_diagnostic(err);\n                 suggested = true;\n             }\n         }"}, {"sha": "40c0c806e1ff8ea41e8e68de27980fe91e81f4cc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,15 +1,17 @@\n //! Error Reporting for `impl` items that do not match the obligations from their `trait`.\n \n+use crate::errors::{ConsiderBorrowingParamHelp, RelationshipHelp, TraitImplDiff};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::Subtype;\n+use crate::infer::{Subtype, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplItemObligation;\n-use rustc_errors::{ErrorGuaranteed, MultiSpan};\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n+use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor};\n use rustc_span::Span;\n@@ -22,22 +24,27 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let error = self.error.as_ref()?;\n         debug!(\"try_report_impl_not_conforming_to_trait {:?}\", error);\n         if let RegionResolutionError::SubSupConflict(\n-                _,\n-                var_origin,\n-                sub_origin,\n-                _sub,\n-                sup_origin,\n-                _sup,\n-                _,\n-            ) = error.clone()\n+            _,\n+            var_origin,\n+            sub_origin,\n+            _sub,\n+            sup_origin,\n+            _sup,\n+            _,\n+        ) = error.clone()\n             && let (Subtype(sup_trace), Subtype(sub_trace)) = (&sup_origin, &sub_origin)\n-            && let sub_expected_found @ Some((sub_expected, sub_found)) = sub_trace.values.ty()\n-            && let sup_expected_found @ Some(_) = sup_trace.values.ty()\n             && let CompareImplItemObligation { trait_item_def_id, .. } = sub_trace.cause.code()\n-            && sup_expected_found == sub_expected_found\n+            && sub_trace.values == sup_trace.values\n+            && let ValuePairs::Sigs(ExpectedFound { expected, found }) = sub_trace.values\n         {\n-            let guar =\n-                self.emit_err(var_origin.span(), sub_expected, sub_found, *trait_item_def_id);\n+            // FIXME(compiler-errors): Don't like that this needs `Ty`s, but\n+            // all of the region highlighting machinery only deals with those.\n+            let guar = self.emit_err(\n+                var_origin.span(),\n+                self.cx.tcx.mk_fn_ptr(ty::Binder::dummy(expected)),\n+                self.cx.tcx.mk_fn_ptr(ty::Binder::dummy(found)),\n+                *trait_item_def_id,\n+            );\n             return Some(guar);\n         }\n         None\n@@ -51,10 +58,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         trait_def_id: DefId,\n     ) -> ErrorGuaranteed {\n         let trait_sp = self.tcx().def_span(trait_def_id);\n-        let mut err = self\n-            .tcx()\n-            .sess\n-            .struct_span_err(sp, \"`impl` item signature doesn't match `trait` item signature\");\n \n         // Mark all unnamed regions in the type with a number.\n         // This diagnostic is called in response to lifetime errors, so be informative.\n@@ -91,9 +94,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let found =\n             self.cx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n \n-        err.span_label(sp, &format!(\"found `{}`\", found));\n-        err.span_label(trait_sp, &format!(\"expected `{}`\", expected));\n-\n         // Get the span of all the used type parameters in the method.\n         let assoc_item = self.tcx().associated_item(trait_def_id);\n         let mut visitor = TypeParamSpanVisitor { tcx: self.tcx(), types: vec![] };\n@@ -110,26 +110,18 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        let mut type_param_span: MultiSpan = visitor.types.to_vec().into();\n-        for &span in &visitor.types {\n-            type_param_span\n-                .push_span_label(span, \"consider borrowing this type parameter in the trait\");\n-        }\n \n-        err.note(&format!(\"expected `{}`\\n   found `{}`\", expected, found));\n-\n-        err.span_help(\n-            type_param_span,\n-            \"the lifetime requirements from the `impl` do not correspond to the requirements in \\\n-             the `trait`\",\n-        );\n-        if visitor.types.is_empty() {\n-            err.help(\n-                \"verify the lifetime relationships in the `trait` and `impl` between the `self` \\\n-                 argument, the other inputs and its output\",\n-            );\n-        }\n-        err.emit()\n+        let diag = TraitImplDiff {\n+            sp,\n+            trait_sp,\n+            note: (),\n+            param_help: ConsiderBorrowingParamHelp { spans: visitor.types.to_vec() },\n+            rel_help: visitor.types.is_empty().then_some(RelationshipHelp),\n+            expected,\n+            found,\n+        };\n+\n+        self.tcx().sess.emit_err(diag)\n     }\n }\n "}, {"sha": "7bb79d7bda8ddf5e2954803da34046a212a45a91", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -25,16 +25,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::Reborrow(span) => {\n                 RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n             }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_reborrow,\n-                    name: &var_name.to_string(),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n             infer::RelateObjectBound(span) => {\n                 RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n                     .add_to_diagnostic(err);\n@@ -162,33 +152,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 );\n                 err\n             }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n-                    var_name\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"...the borrowed pointer is valid for \",\n-                    sub,\n-                    \"...\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    &format!(\"...but `{}` is only valid for \", var_name),\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n             infer::RelateObjectBound(span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "5b02956a106c6cafa6775311a49921aafc355433", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -411,7 +411,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         span: Span,\n     ) {\n         let hir = self.tcx.hir();\n-        let fn_hir_id = hir.get_parent_node(cause.body_id);\n+        let fn_hir_id = hir.parent_id(cause.body_id);\n         if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n             let hir::Node::Item(hir::Item {\n                     kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n@@ -585,45 +585,42 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n             local.pat.walk(&mut find_compatible_candidates);\n         }\n-        match hir.find(hir.get_parent_node(blk.hir_id)) {\n-            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n-                match hir.find(hir.get_parent_node(*hir_id)) {\n-                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n-                        pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    Some(\n-                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n-                        | hir::Node::ImplItem(hir::ImplItem {\n-                            kind: hir::ImplItemKind::Fn(_, body),\n-                            ..\n-                        })\n-                        | hir::Node::TraitItem(hir::TraitItem {\n-                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n-                            ..\n-                        })\n-                        | hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n-                            ..\n-                        }),\n-                    ) => {\n-                        for param in hir.body(*body).params {\n-                            param.pat.walk(&mut find_compatible_candidates);\n-                        }\n-                    }\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind:\n-                            hir::ExprKind::If(\n-                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n-                                then_block,\n-                                _,\n-                            ),\n+        match hir.find_parent(blk.hir_id) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => match hir.find_parent(*hir_id) {\n+                Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                    pat.walk(&mut find_compatible_candidates);\n+                }\n+                Some(\n+                    hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                    | hir::Node::ImplItem(hir::ImplItem {\n+                        kind: hir::ImplItemKind::Fn(_, body), ..\n+                    })\n+                    | hir::Node::TraitItem(hir::TraitItem {\n+                        kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                        ..\n+                    })\n+                    | hir::Node::Expr(hir::Expr {\n+                        kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n                         ..\n-                    })) if then_block.hir_id == *hir_id => {\n-                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }),\n+                ) => {\n+                    for param in hir.body(*body).params {\n+                        param.pat.walk(&mut find_compatible_candidates);\n                     }\n-                    _ => {}\n                 }\n-            }\n+                Some(hir::Node::Expr(hir::Expr {\n+                    kind:\n+                        hir::ExprKind::If(\n+                            hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                            then_block,\n+                            _,\n+                        ),\n+                    ..\n+                })) if then_block.hir_id == *hir_id => {\n+                    let_.pat.walk(&mut find_compatible_candidates);\n+                }\n+                _ => {}\n+            },\n             _ => {}\n         }\n "}, {"sha": "a9de74d78cb61c18f716f4aaba98dbe7e2ae97f6", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -361,6 +361,7 @@ pub enum ValuePairs<'tcx> {\n     Terms(ExpectedFound<ty::Term<'tcx>>),\n     TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n+    Sigs(ExpectedFound<ty::FnSig<'tcx>>),\n }\n \n impl<'tcx> ValuePairs<'tcx> {\n@@ -409,9 +410,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n-    /// Creating a pointer `b` to contents of an upvar\n-    ReborrowUpvar(Span, ty::UpvarId),\n-\n     /// Data with type `Ty<'tcx>` was borrowed\n     DataBorrowed(Ty<'tcx>, Span),\n \n@@ -1954,7 +1952,6 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             RelateParamBound(a, ..) => a,\n             RelateRegionParamBound(a) => a,\n             Reborrow(a) => a,\n-            ReborrowUpvar(a, _) => a,\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n             CompareImplItemObligation { span, .. } => span,"}, {"sha": "749e960bfd03090876186167b6b6247b5eb44efc", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 .as_local()\n                 .map_or(false, |def_id| self.opaque_type_origin(def_id, span).is_some())\n         };\n-        let value = value.fold_with(&mut ty::fold::BottomUpFolder {\n+        let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n             lt_op: |lt| lt,\n             ct_op: |ct| ct,"}, {"sha": "7f761b005edd0946ce8e406282fa529f899268a5", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -90,8 +90,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n             .into_iter()\n             .map(|s| {\n                 let sess = ParseSess::with_silent_emitter(Some(format!(\n-                    \"this error occurred on the command line: `--cfg={}`\",\n-                    s\n+                    \"this error occurred on the command line: `--cfg={s}`\"\n                 )));\n                 let filename = FileName::cfg_spec_source_code(&s);\n \n@@ -150,8 +149,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n \n         'specs: for s in specs {\n             let sess = ParseSess::with_silent_emitter(Some(format!(\n-                \"this error occurred on the command line: `--check-cfg={}`\",\n-                s\n+                \"this error occurred on the command line: `--check-cfg={s}`\"\n             )));\n             let filename = FileName::cfg_spec_source_code(&s);\n "}, {"sha": "86d56385bc9630486eed68198343e07741555ae0", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -620,7 +620,7 @@ fn write_out_deps(\n         // prevents `make` from spitting out an error if a file is later\n         // deleted. For more info see #28735\n         for path in files {\n-            writeln!(file, \"{}:\", path)?;\n+            writeln!(file, \"{path}:\")?;\n         }\n \n         // Emit special comments with information about accessed environment variables.\n@@ -633,9 +633,9 @@ fn write_out_deps(\n             envs.sort_unstable();\n             writeln!(file)?;\n             for (k, v) in envs {\n-                write!(file, \"# env-dep:{}\", k)?;\n+                write!(file, \"# env-dep:{k}\")?;\n                 if let Some(v) = v {\n-                    write!(file, \"={}\", v)?;\n+                    write!(file, \"={v}\")?;\n                 }\n                 writeln!(file)?;\n             }"}, {"sha": "316e2e29cd8b31c107aaed69dcc00f04bb232e50", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -3,17 +3,17 @@ use crate::interface::parse_cfgspecs;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{emitter::HumanReadableErrorType, registry, ColorConfig};\n-use rustc_session::config::InstrumentCoverage;\n-use rustc_session::config::Strip;\n+use rustc_session::config::rustc_optgroups;\n+use rustc_session::config::TraitSolver;\n use rustc_session::config::{build_configuration, build_session_options, to_crate_config};\n-use rustc_session::config::{\n-    rustc_optgroups, ErrorOutputType, ExternLocation, LocationDetail, Options, Passes,\n-};\n use rustc_session::config::{\n     BranchProtection, Externs, OomStrategy, OutputType, OutputTypes, PAuthKey, PacRet,\n     ProcMacroExecutionStrategy, SymbolManglingVersion, WasiExecModel,\n };\n use rustc_session::config::{CFGuard, ExternEntry, LinkerPluginLto, LtoCli, SwitchWithOptPath};\n+use rustc_session::config::{DumpMonoStatsFormat, MirSpanview};\n+use rustc_session::config::{ErrorOutputType, ExternLocation, LocationDetail, Options, Strip};\n+use rustc_session::config::{InstrumentCoverage, Passes};\n use rustc_session::lint::Level;\n use rustc_session::search_paths::SearchPath;\n use rustc_session::utils::{CanonicalizedPath, NativeLib, NativeLibKind};\n@@ -647,6 +647,9 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(dump_mir_dir, String::from(\"abc\"));\n     untracked!(dump_mir_exclude_pass_number, true);\n     untracked!(dump_mir_graphviz, true);\n+    untracked!(dump_mir_spanview, Some(MirSpanview::Statement));\n+    untracked!(dump_mono_stats, SwitchWithOptPath::Enabled(Some(\"mono-items-dir/\".into())));\n+    untracked!(dump_mono_stats_format, DumpMonoStatsFormat::Json);\n     untracked!(dylib_lto, true);\n     untracked!(emit_stack_sizes, true);\n     untracked!(future_incompat_test, true);\n@@ -720,7 +723,6 @@ fn test_unstable_options_tracking_hash() {\n             pac_ret: Some(PacRet { leaf: true, key: PAuthKey::B })\n         })\n     );\n-    tracked!(chalk, true);\n     tracked!(codegen_backend, Some(\"abc\".to_string()));\n     tracked!(crate_attr, vec![\"abc\".to_string()]);\n     tracked!(debug_info_for_profiling, true);\n@@ -790,6 +792,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(thinlto, Some(true));\n     tracked!(thir_unsafeck, true);\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n+    tracked!(trait_solver, TraitSolver::Chalk);\n     tracked!(translate_remapped_path_to_local_path, false);\n     tracked!(trap_unreachable, Some(false));\n     tracked!(treat_err_as_bug, NonZeroUsize::new(1));"}, {"sha": "02a7756c8d4532077cde69573a8c3e49c1b6ba76", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -205,13 +205,13 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n \n fn load_backend_from_dylib(path: &Path) -> MakeBackendFn {\n     let lib = unsafe { Library::new(path) }.unwrap_or_else(|err| {\n-        let err = format!(\"couldn't load codegen backend {:?}: {}\", path, err);\n+        let err = format!(\"couldn't load codegen backend {path:?}: {err}\");\n         early_error(ErrorOutputType::default(), &err);\n     });\n \n     let backend_sym = unsafe { lib.get::<MakeBackendFn>(b\"__rustc_codegen_backend\") }\n         .unwrap_or_else(|e| {\n-            let err = format!(\"couldn't load codegen backend: {}\", e);\n+            let err = format!(\"couldn't load codegen backend: {e}\");\n             early_error(ErrorOutputType::default(), &err);\n         });\n \n@@ -304,8 +304,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n             .join(\"\\n* \");\n         let err = format!(\n             \"failed to find a `codegen-backends` folder \\\n-                           in the sysroot candidates:\\n* {}\",\n-            candidates\n+                           in the sysroot candidates:\\n* {candidates}\"\n         );\n         early_error(ErrorOutputType::default(), &err);\n     });\n@@ -325,7 +324,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n \n     let expected_names = &[\n         format!(\"rustc_codegen_{}-{}\", backend_name, env!(\"CFG_RELEASE\")),\n-        format!(\"rustc_codegen_{}\", backend_name),\n+        format!(\"rustc_codegen_{backend_name}\"),\n     ];\n     for entry in d.filter_map(|e| e.ok()) {\n         let path = entry.path();\n@@ -354,7 +353,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n     match file {\n         Some(ref s) => load_backend_from_dylib(s),\n         None => {\n-            let err = format!(\"unsupported builtin codegen backend `{}`\", backend_name);\n+            let err = format!(\"unsupported builtin codegen backend `{backend_name}`\");\n             early_error(ErrorOutputType::default(), &err);\n         }\n     }\n@@ -389,7 +388,7 @@ pub(crate) fn check_attr_crate_type(\n                             BuiltinLintDiagnostics::UnknownCrateTypes(\n                                 span,\n                                 \"did you mean\".to_string(),\n-                                format!(\"\\\"{}\\\"\", candidate),\n+                                format!(\"\\\"{candidate}\\\"\"),\n                             ),\n                         );\n                     } else {"}, {"sha": "d58168ff37721d71cde3c8b28a271f79920a2fe6", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1392,7 +1392,7 @@ declare_lint! {\n     ///\n     /// The attribute must be used in conjunction with the\n     /// [`closure_track_caller` feature flag]. Otherwise, the `#[track_caller]`\n-    /// annotation will function as as no-op.\n+    /// annotation will function as a no-op.\n     ///\n     /// [`closure_track_caller` feature flag]: https://doc.rust-lang.org/beta/unstable-book/language-features/closure-track-caller.html\n     UNGATED_ASYNC_FN_TRACK_CALLER,\n@@ -1526,7 +1526,7 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n         let map = cx.tcx.hir();\n-        if matches!(map.get(map.get_parent_node(field.hir_id)), Node::Variant(_)) {\n+        if matches!(map.get_parent(field.hir_id), Node::Variant(_)) {\n             return;\n         }\n         self.perform_lint(cx, \"field\", field.def_id, field.vis_span, false);"}, {"sha": "c18abaef8e2565e450bffb1959adfdf5dde7532b", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -29,7 +29,7 @@ macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n \n-/// Implements the AST traversal for early lint passes. `T` provides the the\n+/// Implements the AST traversal for early lint passes. `T` provides the\n /// `check_*` methods.\n pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n     context: EarlyContext<'a>,"}, {"sha": "48902cd05695c751a1c1173fdbe4f2f7f571eaa1", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n             TyKind::Path(QPath::Resolved(_, path)) => {\n                 if lint_ty_kind_usage(cx, &path.res) {\n                     let hir = cx.tcx.hir();\n-                    let span = match hir.find(hir.get_parent_node(ty.hir_id)) {\n+                    let span = match hir.find_parent(ty.hir_id) {\n                         Some(Node::Pat(Pat {\n                             kind:\n                                 PatKind::Path(qpath)"}, {"sha": "b2a2656746eec8b45849ec4faf9ce905ef15ec69", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -40,7 +40,7 @@ macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n \n-/// Implements the AST traversal for late lint passes. `T` provides the the\n+/// Implements the AST traversal for late lint passes. `T` provides the\n /// `check_*` methods.\n pub struct LateContextAndPass<'tcx, T: LateLintPass<'tcx>> {\n     context: LateContext<'tcx>,"}, {"sha": "f37d6e9a63d49f076c7ece809256944a18d6067d", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -444,8 +444,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n \n     fn check_pat(&mut self, cx: &LateContext<'_>, p: &hir::Pat<'_>) {\n         if let PatKind::Binding(_, hid, ident, _) = p.kind {\n-            if let hir::Node::PatField(field) = cx.tcx.hir().get(cx.tcx.hir().get_parent_node(hid))\n-            {\n+            if let hir::Node::PatField(field) = cx.tcx.hir().get_parent(hid) {\n                 if !field.is_shorthand {\n                     // Only check if a new name has been introduced, to avoid warning\n                     // on both the struct definition and this pattern."}, {"sha": "fa415243ba066c99cc897973023aebff1ddd2479", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -127,10 +127,9 @@ fn lint_overflowing_range_endpoint<'tcx>(\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n-    let par_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n+    let par_id = cx.tcx.hir().parent_id(expr.hir_id);\n     let Node::ExprField(field) = cx.tcx.hir().get(par_id) else { return false };\n-    let field_par_id = cx.tcx.hir().get_parent_node(field.hir_id);\n-    let Node::Expr(struct_expr) = cx.tcx.hir().get(field_par_id) else { return false };\n+    let Node::Expr(struct_expr) = cx.tcx.hir().get_parent(field.hir_id) else { return false };\n     if !is_range_literal(struct_expr) {\n         return false;\n     };\n@@ -404,7 +403,7 @@ fn lint_uint_literal<'tcx>(\n         _ => bug!(),\n     };\n     if lit_val < min || lit_val > max {\n-        let parent_id = cx.tcx.hir().get_parent_node(e.hir_id);\n+        let parent_id = cx.tcx.hir().parent_id(e.hir_id);\n         if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {"}, {"sha": "525079681ca5cec4eee3f16787df9760519508df", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -256,7 +256,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n                     )\n-                    .filter_map(|obligation| {\n+                    .find_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Clause(ty::Clause::Trait(\n                             ref poly_trait_predicate,\n@@ -270,22 +270,17 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         }\n                     })\n                     .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n-                    .next()\n                 }\n-                ty::Dynamic(binders, _, _) => binders\n-                    .iter()\n-                    .filter_map(|predicate| {\n-                        if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n-                            predicate.skip_binder()\n-                        {\n-                            let def_id = trait_ref.def_id;\n-                            is_def_must_use(cx, def_id, span)\n-                        } else {\n-                            None\n-                        }\n-                        .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n-                    })\n-                    .next(),\n+                ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n+                    if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()\n+                    {\n+                        let def_id = trait_ref.def_id;\n+                        is_def_must_use(cx, def_id, span)\n+                            .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n+                    } else {\n+                        None\n+                    }\n+                }),\n                 ty::Tuple(tys) => {\n                     let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {\n                         debug_assert_eq!(elem_exprs.len(), tys.len());"}, {"sha": "9fe59a1d8261b15a2871dddd3a9015ca5ef6e92c", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -58,7 +58,7 @@ fn restore_library_path() {\n /// Supposed to be used for all variables except those set for build scripts by cargo\n /// <https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts>\n fn tracked_env_var_os<K: AsRef<OsStr> + Display>(key: K) -> Option<OsString> {\n-    println!(\"cargo:rerun-if-env-changed={}\", key);\n+    println!(\"cargo:rerun-if-env-changed={key}\");\n     env::var_os(key)\n }\n \n@@ -84,7 +84,7 @@ fn output(cmd: &mut Command) -> String {\n     let output = match cmd.stderr(Stdio::inherit()).output() {\n         Ok(status) => status,\n         Err(e) => {\n-            println!(\"\\n\\nfailed to execute command: {:?}\\nerror: {}\\n\\n\", cmd, e);\n+            println!(\"\\n\\nfailed to execute command: {cmd:?}\\nerror: {e}\\n\\n\");\n             std::process::exit(1);\n         }\n     };\n@@ -100,7 +100,7 @@ fn output(cmd: &mut Command) -> String {\n \n fn main() {\n     for component in REQUIRED_COMPONENTS.iter().chain(OPTIONAL_COMPONENTS.iter()) {\n-        println!(\"cargo:rustc-check-cfg=values(llvm_component,\\\"{}\\\")\", component);\n+        println!(\"cargo:rustc-check-cfg=values(llvm_component,\\\"{component}\\\")\");\n     }\n \n     if tracked_env_var_os(\"RUST_CHECK\").is_some() {\n@@ -164,12 +164,12 @@ fn main() {\n \n     for component in REQUIRED_COMPONENTS {\n         if !components.contains(component) {\n-            panic!(\"require llvm component {} but wasn't found\", component);\n+            panic!(\"require llvm component {component} but wasn't found\");\n         }\n     }\n \n     for component in components.iter() {\n-        println!(\"cargo:rustc-cfg=llvm_component=\\\"{}\\\"\", component);\n+        println!(\"cargo:rustc-cfg=llvm_component=\\\"{component}\\\"\");\n     }\n \n     // Link in our own LLVM shims, compiled with the same flags as LLVM\n@@ -283,7 +283,7 @@ fn main() {\n         }\n \n         let kind = if name.starts_with(\"LLVM\") { llvm_kind } else { \"dylib\" };\n-        println!(\"cargo:rustc-link-lib={}={}\", kind, name);\n+        println!(\"cargo:rustc-link-lib={kind}={name}\");\n     }\n \n     // LLVM ldflags\n@@ -302,11 +302,11 @@ fn main() {\n                 println!(\"cargo:rustc-link-search=native={}\", stripped.replace(&host, &target));\n             }\n         } else if let Some(stripped) = lib.strip_prefix(\"-LIBPATH:\") {\n-            println!(\"cargo:rustc-link-search=native={}\", stripped);\n+            println!(\"cargo:rustc-link-search=native={stripped}\");\n         } else if let Some(stripped) = lib.strip_prefix(\"-l\") {\n-            println!(\"cargo:rustc-link-lib={}\", stripped);\n+            println!(\"cargo:rustc-link-lib={stripped}\");\n         } else if let Some(stripped) = lib.strip_prefix(\"-L\") {\n-            println!(\"cargo:rustc-link-search=native={}\", stripped);\n+            println!(\"cargo:rustc-link-search=native={stripped}\");\n         }\n     }\n \n@@ -318,9 +318,9 @@ fn main() {\n     if let Some(s) = llvm_linker_flags {\n         for lib in s.into_string().unwrap().split_whitespace() {\n             if let Some(stripped) = lib.strip_prefix(\"-l\") {\n-                println!(\"cargo:rustc-link-lib={}\", stripped);\n+                println!(\"cargo:rustc-link-lib={stripped}\");\n             } else if let Some(stripped) = lib.strip_prefix(\"-L\") {\n-                println!(\"cargo:rustc-link-search=native={}\", stripped);\n+                println!(\"cargo:rustc-link-search=native={stripped}\");\n             }\n         }\n     }\n@@ -359,14 +359,14 @@ fn main() {\n             let path = PathBuf::from(s);\n             println!(\"cargo:rustc-link-search=native={}\", path.parent().unwrap().display());\n             if target.contains(\"windows\") {\n-                println!(\"cargo:rustc-link-lib=static:-bundle={}\", stdcppname);\n+                println!(\"cargo:rustc-link-lib=static:-bundle={stdcppname}\");\n             } else {\n-                println!(\"cargo:rustc-link-lib=static={}\", stdcppname);\n+                println!(\"cargo:rustc-link-lib=static={stdcppname}\");\n             }\n         } else if cxxflags.contains(\"stdlib=libc++\") {\n             println!(\"cargo:rustc-link-lib=c++\");\n         } else {\n-            println!(\"cargo:rustc-link-lib={}\", stdcppname);\n+            println!(\"cargo:rustc-link-lib={stdcppname}\");\n         }\n     }\n "}, {"sha": "4cac88aff640e66dff6b89b5ac1feaca2f95bec7", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -114,8 +114,7 @@ impl Display for Error {\n         match self {\n             Error::InvalidColorValue(value) => write!(\n                 formatter,\n-                \"invalid log color value '{}': expected one of always, never, or auto\",\n-                value,\n+                \"invalid log color value '{value}': expected one of always, never, or auto\",\n             ),\n             Error::NonUnicodeColorValue => write!(\n                 formatter,"}, {"sha": "2d62d59316387695b2152d48a6e3ae45c9dad0c7", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -76,11 +76,11 @@ pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n     let span = attr.span().unwrap();\n     let path = path_to_string(&attr.path);\n     match meta {\n-        Meta::Path(_) => span_err(span, &format!(\"`#[{}]` is not a valid attribute\", path)),\n+        Meta::Path(_) => span_err(span, &format!(\"`#[{path}]` is not a valid attribute\")),\n         Meta::NameValue(_) => {\n-            span_err(span, &format!(\"`#[{} = ...]` is not a valid attribute\", path))\n+            span_err(span, &format!(\"`#[{path} = ...]` is not a valid attribute\"))\n         }\n-        Meta::List(_) => span_err(span, &format!(\"`#[{}(...)]` is not a valid attribute\", path)),\n+        Meta::List(_) => span_err(span, &format!(\"`#[{path}(...)]` is not a valid attribute\")),\n     }\n }\n \n@@ -107,21 +107,19 @@ pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diag\n     let meta = match nested {\n         syn::NestedMeta::Meta(meta) => meta,\n         syn::NestedMeta::Lit(_) => {\n-            return span_err(span, &format!(\"`#[{}(\\\"...\\\")]` is not a valid attribute\", name));\n+            return span_err(span, &format!(\"`#[{name}(\\\"...\\\")]` is not a valid attribute\"));\n         }\n     };\n \n     let span = meta.span().unwrap();\n     let path = path_to_string(meta.path());\n     match meta {\n         Meta::NameValue(..) => {\n-            span_err(span, &format!(\"`#[{}({} = ...)]` is not a valid attribute\", name, path))\n-        }\n-        Meta::Path(..) => {\n-            span_err(span, &format!(\"`#[{}({})]` is not a valid attribute\", name, path))\n+            span_err(span, &format!(\"`#[{name}({path} = ...)]` is not a valid attribute\"))\n         }\n+        Meta::Path(..) => span_err(span, &format!(\"`#[{name}({path})]` is not a valid attribute\")),\n         Meta::List(..) => {\n-            span_err(span, &format!(\"`#[{}({}(...))]` is not a valid attribute\", name, path))\n+            span_err(span, &format!(\"`#[{name}({path}(...))]` is not a valid attribute\"))\n         }\n     }\n }"}, {"sha": "32338f9dfc5e3893c833eb754769309379b6f1e9", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -178,7 +178,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                         opt: Default::default(),\n                     };\n                     let dl = DisplayList::from(snippet);\n-                    eprintln!(\"{}\\n\", dl);\n+                    eprintln!(\"{dl}\\n\");\n                 }\n                 continue;\n             }\n@@ -265,7 +265,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                         Diagnostic::spanned(\n                             path_span,\n                             Level::Error,\n-                            format!(\"overrides existing {}: `{}`\", kind, id),\n+                            format!(\"overrides existing {kind}: `{id}`\"),\n                         )\n                         .span_help(previous_defns[&id], \"previously defined in this resource\")\n                         .emit();"}, {"sha": "baffd3cec9c55394dfea79608bb7c3fe840e04c9", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -198,8 +198,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                 throw_span_err!(\n                     attr.span().unwrap(),\n                     &format!(\n-                        \"diagnostic slug must be first argument of a `#[{}(...)]` attribute\",\n-                        name\n+                        \"diagnostic slug must be first argument of a `#[{name}(...)]` attribute\"\n                     )\n                 );\n             };"}, {"sha": "6f52a3de1b151ad26c833937addc22fd38753038", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -322,7 +322,7 @@ pub(crate) trait HasFieldMap {\n                 None => {\n                     span_err(\n                         span.unwrap(),\n-                        &format!(\"`{}` doesn't refer to a field on this type\", field),\n+                        &format!(\"`{field}` doesn't refer to a field on this type\"),\n                     )\n                     .emit();\n                     quote! {\n@@ -603,8 +603,7 @@ impl SubdiagnosticKind {\n                     if suggestion_kind != SuggestionKind::Normal {\n                         invalid_attr(attr, &meta)\n                             .help(format!(\n-                                r#\"Use `#[suggestion(..., style = \"{}\")]` instead\"#,\n-                                suggestion_kind\n+                                r#\"Use `#[suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n                             .emit();\n                     }\n@@ -621,8 +620,7 @@ impl SubdiagnosticKind {\n                     if suggestion_kind != SuggestionKind::Normal {\n                         invalid_attr(attr, &meta)\n                             .help(format!(\n-                                r#\"Use `#[multipart_suggestion(..., style = \"{}\")]` instead\"#,\n-                                suggestion_kind\n+                                r#\"Use `#[multipart_suggestion(..., style = \"{suggestion_kind}\")]` instead\"#\n                             ))\n                             .emit();\n                     }"}, {"sha": "89ea89cf502e5e4c2723be0c371b2794c2ff84db", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -41,7 +41,7 @@ impl Parse for Newtype {\n                     };\n \n                     if let Some(old) = max.replace(literal.lit) {\n-                        panic!(\"Specified multiple max: {:?}\", old);\n+                        panic!(\"Specified multiple max: {old:?}\");\n                     }\n \n                     false\n@@ -52,7 +52,7 @@ impl Parse for Newtype {\n                     };\n \n                     if let Some(old) = debug_format.replace(literal.lit) {\n-                        panic!(\"Specified multiple debug format options: {:?}\", old);\n+                        panic!(\"Specified multiple debug format options: {old:?}\");\n                     }\n \n                     false"}, {"sha": "08e42a8a08f92b469ec6f1c64258351c9d0a1889", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -239,7 +239,7 @@ fn doc_comment_from_desc(list: &Punctuated<Expr, token::Comma>) -> Result<Attrib\n             .unwrap();\n         },\n     );\n-    let doc_string = format!(\"[query description - consider adding a doc-comment!] {}\", doc_string);\n+    let doc_string = format!(\"[query description - consider adding a doc-comment!] {doc_string}\");\n     Ok(parse_quote! { #[doc = #doc_string] })\n }\n "}, {"sha": "04facbf657d225d0b7c3bb9bcf62b6acaaaab691", "filename": "compiler/rustc_macros/src/symbols.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -134,7 +134,7 @@ fn symbols_with_errors(input: TokenStream) -> (TokenStream, Vec<syn::Error>) {\n \n     let mut check_dup = |span: Span, str: &str, errors: &mut Errors| {\n         if let Some(prev_span) = keys.get(str) {\n-            errors.error(span, format!(\"Symbol `{}` is duplicated\", str));\n+            errors.error(span, format!(\"Symbol `{str}` is duplicated\"));\n             errors.error(*prev_span, \"location of previous definition\".to_string());\n         } else {\n             keys.insert(str.to_string(), span);\n@@ -144,8 +144,8 @@ fn symbols_with_errors(input: TokenStream) -> (TokenStream, Vec<syn::Error>) {\n     let mut check_order = |span: Span, str: &str, errors: &mut Errors| {\n         if let Some((prev_span, ref prev_str)) = prev_key {\n             if str < prev_str {\n-                errors.error(span, format!(\"Symbol `{}` must precede `{}`\", str, prev_str));\n-                errors.error(prev_span, format!(\"location of previous symbol `{}`\", prev_str));\n+                errors.error(span, format!(\"Symbol `{str}` must precede `{prev_str}`\"));\n+                errors.error(prev_span, format!(\"location of previous symbol `{prev_str}`\"));\n             }\n         }\n         prev_key = Some((span, str.to_string()));"}, {"sha": "bd0c08a53c4f20eb2ce5b6a15a561091ce83d0a6", "filename": "compiler/rustc_macros/src/symbols/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -16,14 +16,13 @@ fn test_symbols() {\n     let m: &syn::ItemMacro = file\n         .items\n         .iter()\n-        .filter_map(|i| {\n+        .find_map(|i| {\n             if let syn::Item::Macro(m) = i {\n                 if m.mac.path == symbols_path { Some(m) } else { None }\n             } else {\n                 None\n             }\n         })\n-        .next()\n         .expect(\"did not find `symbols!` macro invocation.\");\n \n     let body_tokens = m.mac.tokens.clone();"}, {"sha": "653f2b39d3e74f646e22b01133ff4afe25f29bf4", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -112,7 +112,7 @@ impl<'a> std::fmt::Debug for CrateDump<'a> {\n         writeln!(fmt, \"resolved crates:\")?;\n         for (cnum, data) in self.0.iter_crate_data() {\n             writeln!(fmt, \"  name: {}\", data.name())?;\n-            writeln!(fmt, \"  cnum: {}\", cnum)?;\n+            writeln!(fmt, \"  cnum: {cnum}\")?;\n             writeln!(fmt, \"  hash: {}\", data.hash())?;\n             writeln!(fmt, \"  reqd: {:?}\", data.dep_kind())?;\n             let CrateSource { dylib, rlib, rmeta } = data.source();\n@@ -150,7 +150,7 @@ impl CStore {\n     pub(crate) fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n         let cdata = self.metas[cnum]\n             .as_ref()\n-            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum));\n+            .unwrap_or_else(|| panic!(\"Failed to get crate data for {cnum:?}\"));\n         CrateMetadataRef { cdata, cstore: self }\n     }\n "}, {"sha": "59869ee417377635ff55a3093aa64ebb3f2779ca", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -45,7 +45,7 @@ pub fn find_native_static_library(\n \n     for path in search_paths {\n         for (prefix, suffix) in &formats {\n-            let test = path.join(format!(\"{}{}{}\", prefix, name, suffix));\n+            let test = path.join(format!(\"{prefix}{name}{suffix}\"));\n             if test.exists() {\n                 return test;\n             }"}, {"sha": "143d8f2f1e18d1fca476640d18af792bcfecf2c1", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -462,7 +462,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n                 .root\n                 .syntax_contexts\n                 .get(cdata, id)\n-                .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n+                .unwrap_or_else(|| panic!(\"Missing SyntaxContext {id:?} for crate {cname:?}\"))\n                 .decode((cdata, sess))\n         })\n     }\n@@ -806,7 +806,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .def_span\n             .get(self, index)\n-            .unwrap_or_else(|| panic!(\"Missing span for {:?}\", index))\n+            .unwrap_or_else(|| panic!(\"Missing span for {index:?}\"))\n             .decode((self, sess))\n     }\n \n@@ -1249,7 +1249,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .proc_macro_quoted_spans\n             .get(self, index)\n-            .unwrap_or_else(|| panic!(\"Missing proc macro quoted span: {:?}\", index))\n+            .unwrap_or_else(|| panic!(\"Missing proc macro quoted span: {index:?}\"))\n             .decode((self, sess))\n     }\n "}, {"sha": "cb451931dfe179d51047b73036f80a9f16c14865", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -230,7 +230,7 @@ provide! { tcx, def_id, other, cdata,\n             .trait_impl_trait_tys\n             .get(cdata, def_id.index)\n             .map(|lazy| lazy.decode((cdata, tcx)))\n-            .process_decoded(tcx, || panic!(\"{:?} does not have trait_impl_trait_tys\", def_id)))\n+            .process_decoded(tcx, || panic!(\"{def_id:?} does not have trait_impl_trait_tys\")))\n      }\n \n     visibility => { cdata.get_visibility(def_id.index) }"}, {"sha": "a6133f1b417af89bea3b1526fcb2ad97edd164d0", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static>\n         let _ = d.read_raw_bytes(len);\n \n         let inner = odht::HashTable::from_raw_bytes(o).unwrap_or_else(|e| {\n-            panic!(\"decode error: {}\", e);\n+            panic!(\"decode error: {e}\");\n         });\n         DefPathHashMapRef::OwnedFromMetadata(inner)\n     }"}, {"sha": "0d9f216700fb1fc825eb704e388ed849a11652ee", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx, I, T> Encodable<EncodeContext<'a, 'tcx>> for LazyTable<I, T> {\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for CrateNum {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n         if *self != LOCAL_CRATE && s.is_proc_macro {\n-            panic!(\"Attempted to encode non-local CrateNum {:?} for proc-macro crate\", self);\n+            panic!(\"Attempted to encode non-local CrateNum {self:?} for proc-macro crate\");\n         }\n         s.emit_u32(self.as_u32());\n     }\n@@ -276,7 +276,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n                 // Introduce a new scope so that we drop the 'lock()' temporary\n                 match &*source_file.external_src.lock() {\n                     ExternalSource::Foreign { metadata_index, .. } => *metadata_index,\n-                    src => panic!(\"Unexpected external source {:?}\", src),\n+                    src => panic!(\"Unexpected external source {src:?}\"),\n                 }\n             };\n \n@@ -733,12 +733,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let prefix = \"meta-stats\";\n             let perc = |bytes| (bytes * 100) as f64 / total_bytes as f64;\n \n-            eprintln!(\"{} METADATA STATS\", prefix);\n+            eprintln!(\"{prefix} METADATA STATS\");\n             eprintln!(\"{} {:<23}{:>10}\", prefix, \"Section\", \"Size\");\n-            eprintln!(\n-                \"{} ----------------------------------------------------------------\",\n-                prefix\n-            );\n+            eprintln!(\"{prefix} ----------------------------------------------------------------\");\n             for (label, size) in stats {\n                 eprintln!(\n                     \"{} {:<23}{:>10} ({:4.1}%)\",\n@@ -748,18 +745,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     perc(size)\n                 );\n             }\n-            eprintln!(\n-                \"{} ----------------------------------------------------------------\",\n-                prefix\n-            );\n+            eprintln!(\"{prefix} ----------------------------------------------------------------\");\n             eprintln!(\n                 \"{} {:<23}{:>10} (of which {:.1}% are zero bytes)\",\n                 prefix,\n                 \"Total\",\n                 to_readable_str(total_bytes),\n                 perc(zero_bytes)\n             );\n-            eprintln!(\"{}\", prefix);\n+            eprintln!(\"{prefix}\");\n         }\n \n         root"}, {"sha": "883554f959ccb65240f9361f9af2a278fcf92f1d", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -69,7 +69,7 @@ impl<'hir> Iterator for ParentHirIterator<'hir> {\n         }\n         loop {\n             // There are nodes that do not have entries, so we need to skip them.\n-            let parent_id = self.map.get_parent_node(self.current_id);\n+            let parent_id = self.map.parent_id(self.current_id);\n \n             if parent_id == self.current_id {\n                 self.current_id = CRATE_HIR_ID;\n@@ -246,7 +246,7 @@ impl<'hir> Map<'hir> {\n             },\n             Node::Variant(_) => DefKind::Variant,\n             Node::Ctor(variant_data) => {\n-                let ctor_of = match self.find(self.get_parent_node(hir_id)) {\n+                let ctor_of = match self.find_parent(hir_id) {\n                     Some(Node::Item(..)) => def::CtorOf::Struct,\n                     Some(Node::Variant(..)) => def::CtorOf::Variant,\n                     _ => unreachable!(),\n@@ -257,7 +257,7 @@ impl<'hir> Map<'hir> {\n                 }\n             }\n             Node::AnonConst(_) => {\n-                let inline = match self.find(self.get_parent_node(hir_id)) {\n+                let inline = match self.find_parent(hir_id) {\n                     Some(Node::Expr(&Expr {\n                         kind: ExprKind::ConstBlock(ref anon_const), ..\n                     })) if anon_const.hir_id == hir_id => true,\n@@ -298,7 +298,7 @@ impl<'hir> Map<'hir> {\n     /// Finds the id of the parent node to this one.\n     ///\n     /// If calling repeatedly and iterating over parents, prefer [`Map::parent_iter`].\n-    pub fn find_parent_node(self, id: HirId) -> Option<HirId> {\n+    pub fn opt_parent_id(self, id: HirId) -> Option<HirId> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             Some(self.tcx.hir_owner_parent(id.owner))\n         } else {\n@@ -312,11 +312,19 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[track_caller]\n-    pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n-        self.find_parent_node(hir_id)\n+    pub fn parent_id(self, hir_id: HirId) -> HirId {\n+        self.opt_parent_id(hir_id)\n             .unwrap_or_else(|| bug!(\"No parent for node {:?}\", self.node_to_string(hir_id)))\n     }\n \n+    pub fn get_parent(self, hir_id: HirId) -> Node<'hir> {\n+        self.get(self.parent_id(hir_id))\n+    }\n+\n+    pub fn find_parent(self, hir_id: HirId) -> Option<Node<'hir>> {\n+        self.find(self.opt_parent_id(hir_id)?)\n+    }\n+\n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(self, id: HirId) -> Option<Node<'hir>> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n@@ -414,7 +422,7 @@ impl<'hir> Map<'hir> {\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n-        let parent = self.get_parent_node(hir_id);\n+        let parent = self.parent_id(hir_id);\n         assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)), \"{hir_id:?}\");\n         parent\n     }\n@@ -642,29 +650,29 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n-    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    /// until the crate root is reached. Prefer this over your own loop using `parent_id`.\n     #[inline]\n     pub fn parent_id_iter(self, current_id: HirId) -> impl Iterator<Item = HirId> + 'hir {\n         ParentHirIterator { current_id, map: self }\n     }\n \n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n-    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    /// until the crate root is reached. Prefer this over your own loop using `parent_id`.\n     #[inline]\n     pub fn parent_iter(self, current_id: HirId) -> impl Iterator<Item = (HirId, Node<'hir>)> {\n         self.parent_id_iter(current_id).filter_map(move |id| Some((id, self.find(id)?)))\n     }\n \n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n-    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    /// until the crate root is reached. Prefer this over your own loop using `parent_id`.\n     #[inline]\n     pub fn parent_owner_iter(self, current_id: HirId) -> ParentOwnerIterator<'hir> {\n         ParentOwnerIterator { current_id, map: self }\n     }\n \n     /// Checks if the node is left-hand side of an assignment.\n     pub fn is_lhs(self, id: HirId) -> bool {\n-        match self.find(self.get_parent_node(id)) {\n+        match self.find_parent(id) {\n             Some(Node::Expr(expr)) => match expr.kind {\n                 ExprKind::Assign(lhs, _rhs, _span) => lhs.hir_id == id,\n                 _ => false,\n@@ -892,7 +900,7 @@ impl<'hir> Map<'hir> {\n             Node::Pat(&Pat { kind: PatKind::Binding(_, _, ident, _), .. }) => Some(ident),\n             // A `Ctor` doesn't have an identifier itself, but its parent\n             // struct/variant does. Compare with `hir::Map::opt_span`.\n-            Node::Ctor(..) => match self.find(self.get_parent_node(id))? {\n+            Node::Ctor(..) => match self.find_parent(id)? {\n                 Node::Item(item) => Some(item.ident),\n                 Node::Variant(variant) => Some(variant.ident),\n                 _ => unreachable!(),\n@@ -1021,7 +1029,7 @@ impl<'hir> Map<'hir> {\n                 ForeignItemKind::Fn(decl, _, _) => until_within(item.span, decl.output.span()),\n                 _ => named_span(item.span, item.ident, None),\n             },\n-            Node::Ctor(_) => return self.opt_span(self.get_parent_node(hir_id)),\n+            Node::Ctor(_) => return self.opt_span(self.parent_id(hir_id)),\n             Node::Expr(Expr {\n                 kind: ExprKind::Closure(Closure { fn_decl_span, .. }),\n                 span,\n@@ -1063,7 +1071,7 @@ impl<'hir> Map<'hir> {\n             Node::PatField(field) => field.span,\n             Node::Arm(arm) => arm.span,\n             Node::Block(block) => block.span,\n-            Node::Ctor(..) => self.span_with_body(self.get_parent_node(hir_id)),\n+            Node::Ctor(..) => self.span_with_body(self.parent_id(hir_id)),\n             Node::Lifetime(lifetime) => lifetime.ident.span,\n             Node::GenericParam(param) => param.span,\n             Node::Infer(i) => i.span,\n@@ -1093,7 +1101,7 @@ impl<'hir> Map<'hir> {\n     /// Returns the HirId of `N` in `struct Foo<const N: usize = { ... }>` when\n     /// called with the HirId for the `{ ... }` anon const\n     pub fn opt_const_param_default_param_def_id(self, anon_const: HirId) -> Option<LocalDefId> {\n-        match self.get(self.get_parent_node(anon_const)) {\n+        match self.get_parent(anon_const) {\n             Node::GenericParam(GenericParam {\n                 def_id: param_id,\n                 kind: GenericParamKind::Const { .. },"}, {"sha": "eb48b325e84ebd22be75e0fc1951dd7514b32af0", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -182,7 +182,7 @@ impl TyCtxt<'_> {\n             if hir.attrs(id).iter().any(|attr| Level::from_attr(attr).is_some()) {\n                 return id;\n             }\n-            let next = hir.get_parent_node(id);\n+            let next = hir.parent_id(id);\n             if next == id {\n                 bug!(\"lint traversal reached the root of the crate\");\n             }"}, {"sha": "5ca4d260179ceff29f982033a0a3cb4e171e089d", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,3 +1,13 @@\n+/// A macro for triggering an ICE.\n+/// Calling `bug` instead of panicking will result in a nicer error message and should\n+/// therefore be prefered over `panic`/`unreachable` or others.\n+///\n+/// If you have a span available, you should use [`span_bug`] instead.\n+///\n+/// If the bug should only be emitted when compilation didn't fail, [`Session::delay_span_bug`] may be useful.\n+///\n+/// [`Session::delay_span_bug`]: rustc_session::Session::delay_span_bug\n+/// [`span_bug`]: crate::span_bug\n #[macro_export]\n macro_rules! bug {\n     () => ( $crate::bug!(\"impossible case reached\") );\n@@ -8,6 +18,14 @@ macro_rules! bug {\n     });\n }\n \n+/// A macro for triggering an ICE with a span.\n+/// Calling `span_bug!` instead of panicking will result in a nicer error message and point\n+/// at the code the compiler was compiling when it ICEd. This is the preferred way to trigger\n+/// ICEs.\n+///\n+/// If the bug should only be emitted when compilation didn't fail, [`Session::delay_span_bug`] may be useful.\n+///\n+/// [`Session::delay_span_bug`]: rustc_session::Session::delay_span_bug\n #[macro_export]\n macro_rules! span_bug {\n     ($span:expr, $msg:expr) => ({ $crate::util::bug::span_bug_fmt($span, ::std::format_args!($msg)) });"}, {"sha": "14bdff4568f5e65f8e1fd4c6355bdaf89a4ae4d2", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2506,7 +2506,7 @@ impl<'tcx> ConstantKind<'tcx> {\n         }\n \n         let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-        let parent_substs = if let Some(parent_hir_id) = tcx.hir().find_parent_node(hir_id) {\n+        let parent_substs = if let Some(parent_hir_id) = tcx.hir().opt_parent_id(hir_id) {\n             if let Some(parent_did) = tcx.hir().opt_local_def_id(parent_hir_id) {\n                 InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n             } else {"}, {"sha": "1a264d2d5af9a0d6ab1d8eebc2aaba14b9bde5ed", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -3,15 +3,15 @@\n //! ## Overview\n //!\n //! There are two visitors, one for immutable and one for mutable references,\n-//! but both are generated by the following macro. The code is written according\n-//! to the following conventions:\n+//! but both are generated by the `make_mir_visitor` macro.\n+//! The code is written according to the following conventions:\n //!\n //! - introduce a `visit_foo` and a `super_foo` method for every MIR type\n //! - `visit_foo`, by default, calls `super_foo`\n //! - `super_foo`, by default, destructures the `foo` and calls `visit_foo`\n //!\n-//! This allows you as a user to override `visit_foo` for types are\n-//! interested in, and invoke (within that method) call\n+//! This allows you to override `visit_foo` for types you are\n+//! interested in, and invoke (within that method call)\n //! `self.super_foo` to get the default behavior. Just as in an OO\n //! language, you should never call `super` methods ordinarily except\n //! in that circumstance."}, {"sha": "9e4f90caab0b5957b2469fc6520d7771bd3b096d", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -21,7 +21,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         // If there's nothing to erase avoid performing the query at all\n-        if !value.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND | TypeFlags::HAS_FREE_REGIONS) {\n+        if !value.has_type_flags(TypeFlags::HAS_LATE_BOUND | TypeFlags::HAS_FREE_REGIONS) {\n             return value;\n         }\n         debug!(\"erase_regions({:?})\", value);"}, {"sha": "50554cf9a82c85e7e53112ae0da4e6a3bb723f6e", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -457,7 +457,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .def_id\n                             .as_local()\n                             .map(|id| hir.local_def_id_to_hir_id(id))\n-                            .and_then(|id| self.hir().find(self.hir().get_parent_node(id)))\n+                            .and_then(|id| self.hir().find_parent(id))\n                             .as_ref()\n                             .and_then(|node| node.generics())\n                         {"}, {"sha": "b7eafc4b437385ac986f29b2c0ef8d09f4972246", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -59,8 +59,18 @@ impl FlagComputation {\n     {\n         let mut computation = FlagComputation::new();\n \n-        if !value.bound_vars().is_empty() {\n-            computation.flags = computation.flags | TypeFlags::HAS_RE_LATE_BOUND;\n+        for bv in value.bound_vars() {\n+            match bv {\n+                ty::BoundVariableKind::Ty(_) => {\n+                    computation.flags |= TypeFlags::HAS_TY_LATE_BOUND;\n+                }\n+                ty::BoundVariableKind::Region(_) => {\n+                    computation.flags |= TypeFlags::HAS_RE_LATE_BOUND;\n+                }\n+                ty::BoundVariableKind::Const => {\n+                    computation.flags |= TypeFlags::HAS_CT_LATE_BOUND;\n+                }\n+            }\n         }\n \n         f(&mut computation, value.skip_binder());\n@@ -131,6 +141,7 @@ impl FlagComputation {\n \n             &ty::Bound(debruijn, _) => {\n                 self.add_bound_var(debruijn);\n+                self.add_flags(TypeFlags::HAS_TY_LATE_BOUND);\n             }\n \n             &ty::Placeholder(..) => {\n@@ -303,6 +314,7 @@ impl FlagComputation {\n             }\n             ty::ConstKind::Bound(debruijn, _) => {\n                 self.add_bound_var(debruijn);\n+                self.add_flags(TypeFlags::HAS_CT_LATE_BOUND);\n             }\n             ty::ConstKind::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_CT_PARAM);"}, {"sha": "00f53afd6632854f824eb5df0d8256d61407ba18", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -670,29 +670,50 @@ where\n                         });\n                     }\n \n-                    match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n-                        ty::Slice(_) | ty::Str => TyMaybeWithLayout::Ty(tcx.types.usize),\n-                        ty::Dynamic(_, _, ty::Dyn) => {\n-                            TyMaybeWithLayout::Ty(tcx.mk_imm_ref(\n-                                tcx.lifetimes.re_static,\n-                                tcx.mk_array(tcx.types.usize, 3),\n-                            ))\n-                            /* FIXME: use actual fn pointers\n-                            Warning: naively computing the number of entries in the\n-                            vtable by counting the methods on the trait + methods on\n-                            all parent traits does not work, because some methods can\n-                            be not object safe and thus excluded from the vtable.\n-                            Increase this counter if you tried to implement this but\n-                            failed to do it without duplicating a lot of code from\n-                            other places in the compiler: 2\n-                            tcx.mk_tup(&[\n-                                tcx.mk_array(tcx.types.usize, 3),\n-                                tcx.mk_array(Option<fn()>),\n-                            ])\n-                            */\n+                    let mk_dyn_vtable = || {\n+                        tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.usize, 3))\n+                        /* FIXME: use actual fn pointers\n+                        Warning: naively computing the number of entries in the\n+                        vtable by counting the methods on the trait + methods on\n+                        all parent traits does not work, because some methods can\n+                        be not object safe and thus excluded from the vtable.\n+                        Increase this counter if you tried to implement this but\n+                        failed to do it without duplicating a lot of code from\n+                        other places in the compiler: 2\n+                        tcx.mk_tup(&[\n+                            tcx.mk_array(tcx.types.usize, 3),\n+                            tcx.mk_array(Option<fn()>),\n+                        ])\n+                        */\n+                    };\n+\n+                    let metadata = if let Some(metadata_def_id) = tcx.lang_items().metadata_type() {\n+                        let metadata = tcx.normalize_erasing_regions(\n+                            cx.param_env(),\n+                            tcx.mk_projection(metadata_def_id, [pointee]),\n+                        );\n+\n+                        // Map `Metadata = DynMetadata<dyn Trait>` back to a vtable, since it\n+                        // offers better information than `std::ptr::metadata::VTable`,\n+                        // and we rely on this layout information to trigger a panic in\n+                        // `std::mem::uninitialized::<&dyn Trait>()`, for example.\n+                        if let ty::Adt(def, substs) = metadata.kind()\n+                            && Some(def.did()) == tcx.lang_items().dyn_metadata()\n+                            && substs.type_at(0).is_trait()\n+                        {\n+                            mk_dyn_vtable()\n+                        } else {\n+                            metadata\n                         }\n-                        _ => bug!(\"TyAndLayout::field({:?}): not applicable\", this),\n-                    }\n+                    } else {\n+                        match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n+                            ty::Slice(_) | ty::Str => tcx.types.usize,\n+                            ty::Dynamic(_, _, ty::Dyn) => mk_dyn_vtable(),\n+                            _ => bug!(\"TyAndLayout::field({:?}): not applicable\", this),\n+                        }\n+                    };\n+\n+                    TyMaybeWithLayout::Ty(metadata)\n                 }\n \n                 // Arrays and slices."}, {"sha": "ca445558131380e364370ea518fb37a69a4c7bfa", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -165,6 +165,14 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n     fn has_late_bound_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND)\n     }\n+    /// True if there are any late-bound non-region variables\n+    fn has_non_region_late_bound(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_LATE_BOUND - TypeFlags::HAS_RE_LATE_BOUND)\n+    }\n+    /// True if there are any late-bound variables\n+    fn has_late_bound_vars(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_LATE_BOUND)\n+    }\n \n     /// Indicates whether this value still has parameters/placeholders/inference variables\n     /// which could be replaced later, in a way that would change the results of `impl`"}, {"sha": "b73ae593905353a8d99c97dff746f4db9c375870", "filename": "compiler/rustc_middle/src/util/bug.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Futil%2Fbug.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -35,8 +35,7 @@ fn opt_span_bug_fmt<S: Into<MultiSpan>>(\n             (Some(tcx), None) => tcx.sess.diagnostic().bug(&msg),\n             (None, _) => panic_any(msg),\n         }\n-    });\n-    unreachable!();\n+    })\n }\n \n /// A query to trigger a `delay_span_bug`. Clearly, if one has a `tcx` one can already trigger a"}, {"sha": "03a7f2d70faebb1127bcf952ce28cab88b633923", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::thir::visit::{self, Visitor};\n use rustc_hir as hir;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::thir::*;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n@@ -524,17 +525,19 @@ impl UnsafeOpKind {\n         hir_id: hir::HirId,\n         span: Span,\n     ) {\n+        // FIXME: ideally we would want to trim the def paths, but this is not\n+        // feasible with the current lint emission API (see issue #106126).\n         match self {\n-            CallToUnsafeFunction(did) if did.is_some() => tcx.emit_spanned_lint(\n+            CallToUnsafeFunction(Some(did)) => tcx.emit_spanned_lint(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 hir_id,\n                 span,\n                 UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafe {\n                     span,\n-                    function: &tcx.def_path_str(did.unwrap()),\n+                    function: &with_no_trimmed_paths!(tcx.def_path_str(*did)),\n                 },\n             ),\n-            CallToUnsafeFunction(..) => tcx.emit_spanned_lint(\n+            CallToUnsafeFunction(None) => tcx.emit_spanned_lint(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 hir_id,\n                 span,\n@@ -594,7 +597,7 @@ impl UnsafeOpKind {\n                 span,\n                 UnsafeOpInUnsafeFnCallToFunctionWithRequiresUnsafe {\n                     span,\n-                    function: &tcx.def_path_str(*did),\n+                    function: &with_no_trimmed_paths!(tcx.def_path_str(*did)),\n                 },\n             ),\n         }\n@@ -607,24 +610,24 @@ impl UnsafeOpKind {\n         unsafe_op_in_unsafe_fn_allowed: bool,\n     ) {\n         match self {\n-            CallToUnsafeFunction(did) if did.is_some() && unsafe_op_in_unsafe_fn_allowed => {\n+            CallToUnsafeFunction(Some(did)) if unsafe_op_in_unsafe_fn_allowed => {\n                 tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n                     span,\n-                    function: &tcx.def_path_str(did.unwrap()),\n+                    function: &tcx.def_path_str(*did),\n                 });\n             }\n-            CallToUnsafeFunction(did) if did.is_some() => {\n+            CallToUnsafeFunction(Some(did)) => {\n                 tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafe {\n                     span,\n-                    function: &tcx.def_path_str(did.unwrap()),\n+                    function: &tcx.def_path_str(*did),\n                 });\n             }\n-            CallToUnsafeFunction(..) if unsafe_op_in_unsafe_fn_allowed => {\n+            CallToUnsafeFunction(None) if unsafe_op_in_unsafe_fn_allowed => {\n                 tcx.sess.emit_err(\n                     CallToUnsafeFunctionRequiresUnsafeNamelessUnsafeOpInUnsafeFnAllowed { span },\n                 );\n             }\n-            CallToUnsafeFunction(..) => {\n+            CallToUnsafeFunction(None) => {\n                 tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeNameless { span });\n             }\n             UseOfInlineAssembly if unsafe_op_in_unsafe_fn_allowed => {"}, {"sha": "e7ee0d9e908e0556746b5f01fc413d1a5f731256", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -247,14 +247,14 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n     fn check_let_chain(&mut self, cx: &mut MatchCheckCtxt<'p, 'tcx>, pat_id: HirId) -> bool {\n         let hir = self.tcx.hir();\n-        let parent = hir.get_parent_node(pat_id);\n+        let parent = hir.parent_id(pat_id);\n \n         // First, figure out if the given pattern is part of a let chain,\n         // and if so, obtain the top node of the chain.\n         let mut top = parent;\n         let mut part_of_chain = false;\n         loop {\n-            let new_top = hir.get_parent_node(top);\n+            let new_top = hir.parent_id(top);\n             if let hir::Node::Expr(\n                 hir::Expr {\n                     kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n@@ -1054,7 +1054,7 @@ pub enum LetSource {\n fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n     let hir = tcx.hir();\n \n-    let parent = hir.get_parent_node(pat_id);\n+    let parent = hir.parent_id(pat_id);\n     let_source_parent(tcx, parent, Some(pat_id))\n }\n \n@@ -1073,7 +1073,7 @@ fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> L\n         _ => {}\n     }\n \n-    let parent_parent = hir.get_parent_node(parent);\n+    let parent_parent = hir.parent_id(parent);\n     let parent_parent_node = hir.get(parent_parent);\n     match parent_parent_node {\n         hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(_), .. }) => {\n@@ -1085,8 +1085,8 @@ fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> L\n         _ => {}\n     }\n \n-    let parent_parent_parent = hir.get_parent_node(parent_parent);\n-    let parent_parent_parent_parent = hir.get_parent_node(parent_parent_parent);\n+    let parent_parent_parent = hir.parent_id(parent_parent);\n+    let parent_parent_parent_parent = hir.parent_id(parent_parent_parent);\n     let parent_parent_parent_parent_node = hir.get(parent_parent_parent_parent);\n \n     if let hir::Node::Expr(hir::Expr {"}, {"sha": "077a21fc8afc03fa1faa2886643ffc2c90665be8", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -287,7 +287,7 @@ impl Direction for Backward {\n                 | mir::TerminatorKind::InlineAsm { cleanup: Some(unwind), .. }\n                     if unwind == bb =>\n                 {\n-                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n+                    if dead_unwinds.map_or(true, |dead| !dead.contains(pred)) {\n                         propagate(pred, exit_state);\n                     }\n                 }"}, {"sha": "490be166a91d9269926ed46249b010c04087ddaf", "filename": "compiler/rustc_mir_dataflow/src/framework/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Ffmt.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -143,7 +143,7 @@ where\n             \", \"\n         };\n \n-        write!(f, \"{}\", delim)?;\n+        write!(f, \"{delim}\")?;\n         idx.fmt_with(ctxt, f)?;\n         first = false;\n     }\n@@ -164,7 +164,7 @@ where\n             \", \"\n         };\n \n-        write!(f, \"{}\", delim)?;\n+        write!(f, \"{delim}\")?;\n         idx.fmt_with(ctxt, f)?;\n         first = false;\n     }"}, {"sha": "96c42894b697e77358f997e24e847342aaa76354", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -71,7 +71,7 @@ where\n \n     fn graph_id(&self) -> dot::Id<'_> {\n         let name = graphviz_safe_def_name(self.body.source.def_id());\n-        dot::Id::new(format!(\"graph_for_def_id_{}\", name)).unwrap()\n+        dot::Id::new(format!(\"graph_for_def_id_{name}\")).unwrap()\n     }\n \n     fn node_id(&self, n: &Self::Node) -> dot::Id<'_> {\n@@ -190,7 +190,7 @@ where\n             \" cellpadding=\\\"3\\\"\",\n             \" sides=\\\"rb\\\"\",\n         );\n-        write!(w, r#\"<table{fmt}>\"#, fmt = table_fmt)?;\n+        write!(w, r#\"<table{table_fmt}>\"#)?;\n \n         // A + B: Block header\n         match self.style {\n@@ -372,7 +372,7 @@ where\n         write!(w, concat!(\"<tr>\", r#\"<td colspan=\"2\" {fmt}>MIR</td>\"#,), fmt = fmt,)?;\n \n         for name in state_column_names {\n-            write!(w, \"<td {fmt}>{name}</td>\", fmt = fmt, name = name)?;\n+            write!(w, \"<td {fmt}>{name}</td>\")?;\n         }\n \n         write!(w, \"</tr>\")\n@@ -394,18 +394,18 @@ where\n         };\n \n         for (i, statement) in body[block].statements.iter().enumerate() {\n-            let statement_str = format!(\"{:?}\", statement);\n-            let index_str = format!(\"{}\", i);\n+            let statement_str = format!(\"{statement:?}\");\n+            let index_str = format!(\"{i}\");\n \n             let after = next_in_dataflow_order(&mut afters);\n             let before = befores.as_mut().map(next_in_dataflow_order);\n \n             self.write_row(w, &index_str, &statement_str, |_this, w, fmt| {\n                 if let Some(before) = before {\n-                    write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = before)?;\n+                    write!(w, r#\"<td {fmt} align=\"left\">{before}</td>\"#)?;\n                 }\n \n-                write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = after)\n+                write!(w, r#\"<td {fmt} align=\"left\">{after}</td>\"#)\n             })?;\n         }\n \n@@ -421,10 +421,10 @@ where\n \n         self.write_row(w, \"T\", &terminator_str, |_this, w, fmt| {\n             if let Some(before) = before {\n-                write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = before)?;\n+                write!(w, r#\"<td {fmt} align=\"left\">{before}</td>\"#)?;\n             }\n \n-            write!(w, r#\"<td {fmt} align=\"left\">{diff}</td>\"#, fmt = fmt, diff = after)\n+            write!(w, r#\"<td {fmt} align=\"left\">{after}</td>\"#)\n         })\n     }\n "}, {"sha": "5f22a418de863bbca88665d1389490cbee8b6764", "filename": "compiler/rustc_mir_dataflow/src/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -129,13 +129,13 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n     fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(w, \"MovePath {{\")?;\n         if let Some(parent) = self.parent {\n-            write!(w, \" parent: {:?},\", parent)?;\n+            write!(w, \" parent: {parent:?},\")?;\n         }\n         if let Some(first_child) = self.first_child {\n-            write!(w, \" first_child: {:?},\", first_child)?;\n+            write!(w, \" first_child: {first_child:?},\")?;\n         }\n         if let Some(next_sibling) = self.next_sibling {\n-            write!(w, \" next_sibling: {:?}\", next_sibling)?;\n+            write!(w, \" next_sibling: {next_sibling:?}\")?;\n         }\n         write!(w, \" place: {:?} }}\", self.place)\n     }"}, {"sha": "0522c657939f5e100c7827dd319862ce3eedaf09", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -920,7 +920,7 @@ fn debug_with_context<V: Debug + Eq>(\n ) -> std::fmt::Result {\n     for (local, place) in map.locals.iter_enumerated() {\n         if let Some(place) = place {\n-            debug_with_context_rec(*place, &format!(\"{:?}\", local), new, old, map, f)?;\n+            debug_with_context_rec(*place, &format!(\"{local:?}\"), new, old, map, f)?;\n         }\n     }\n     Ok(())"}, {"sha": "09546330cec92672a2a5c906ba1d1847c108e7ed", "filename": "compiler/rustc_mir_transform/src/dead_store_elimination.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdead_store_elimination.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -71,7 +71,7 @@ pub fn eliminate<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, borrowed: &BitS\n         bbs[block].statements[statement_index].make_nop();\n     }\n \n-    crate::simplify::SimplifyLocals.run_pass(tcx, body)\n+    crate::simplify::simplify_locals(body, tcx)\n }\n \n pub struct DeadStoreElimination;"}, {"sha": "16b8a901f36512140a87c147910aeabcec5eadfe", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -524,11 +524,8 @@ fn run_runtime_lowering_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n /// Returns the sequence of passes that do the initial cleanup of runtime MIR.\n fn run_runtime_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let passes: &[&dyn MirPass<'tcx>] = &[\n-        &elaborate_box_derefs::ElaborateBoxDerefs,\n-        &lower_intrinsics::LowerIntrinsics,\n-        &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n-    ];\n+    let passes: &[&dyn MirPass<'tcx>] =\n+        &[&lower_intrinsics::LowerIntrinsics, &simplify::SimplifyCfg::new(\"elaborate-drops\")];\n \n     pm::run_passes(tcx, body, passes, Some(MirPhase::Runtime(RuntimePhase::PostCleanup)));\n }\n@@ -560,6 +557,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &multiple_return_terminators::MultipleReturnTerminators,\n             &instcombine::InstCombine,\n             &separate_const_switch::SeparateConstSwitch,\n+            &simplify::SimplifyLocals::new(\"before-const-prop\"),\n             //\n             // FIXME(#70073): This pass is responsible for both optimization as well as some lints.\n             &const_prop::ConstProp,\n@@ -578,7 +576,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &o1(remove_noop_landing_pads::RemoveNoopLandingPads),\n             &o1(simplify::SimplifyCfg::new(\"final\")),\n             &nrvo::RenameReturnPlace,\n-            &simplify::SimplifyLocals,\n+            &simplify::SimplifyLocals::new(\"final\"),\n             &multiple_return_terminators::MultipleReturnTerminators,\n             &deduplicate_blocks::DeduplicateBlocks,\n             // Some cleanup necessary at least for LLVM and potentially other codegen backends."}, {"sha": "8f6abe7a912feefefadb5ac24abbc8dbe97c3af9", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -379,9 +379,21 @@ fn save_unreachable_coverage(\n     ));\n }\n \n-pub struct SimplifyLocals;\n+pub struct SimplifyLocals {\n+    label: String,\n+}\n+\n+impl SimplifyLocals {\n+    pub fn new(label: &str) -> SimplifyLocals {\n+        SimplifyLocals { label: format!(\"SimplifyLocals-{}\", label) }\n+    }\n+}\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n+    fn name(&self) -> &str {\n+        &self.label\n+    }\n+\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n         sess.mir_opt_level() > 0\n     }\n@@ -557,6 +569,7 @@ fn remove_unused_definitions(used_locals: &mut UsedLocals, body: &mut Body<'_>)\n \n                     StatementKind::SetDiscriminant { ref place, .. }\n                     | StatementKind::Deinit(ref place) => used_locals.is_used(place.local),\n+                    StatementKind::Nop => false,\n                     _ => true,\n                 };\n "}, {"sha": "c8af10576b42fcf4526aafc92e2985774d9d2680", "filename": "compiler/rustc_monomorphize/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -6,6 +6,8 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n+serde = \"1\"\n+serde_json = \"1\"\n smallvec = { version = \"1.8.1\", features = [ \"union\", \"may_dangle\" ] }\n tracing = \"0.1\"\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "b573df4325051306236920cdbdc7f273e3a13395", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -526,7 +526,7 @@ fn collect_items_rec<'tcx>(\n         let formatted_item = with_no_trimmed_paths!(starting_point.node.to_string());\n         tcx.sess.span_note_without_error(\n             starting_point.span,\n-            &format!(\"the above error was encountered while instantiating `{}`\", formatted_item),\n+            &format!(\"the above error was encountered while instantiating `{formatted_item}`\"),\n         );\n     }\n     inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);"}, {"sha": "aa3227cac2de4ac6dd09c269019a3ab5a915d208", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -50,7 +50,7 @@ impl IntoDiagnostic<'_> for UnusedGenericParams {\n             // FIXME: I can figure out how to do a label with a fluent string with a fixed message,\n             // or a label with a dynamic value in a hard-coded string, but I haven't figured out\n             // how to combine the two. \ud83d\ude22\n-            diag.span_label(span, format!(\"generic parameter `{}` is unused\", name));\n+            diag.span_label(span, format!(\"generic parameter `{name}` is unused\"));\n         }\n         diag\n     }"}, {"sha": "fd6bcad18983a334d5b3e59eb6af2e98f4d3bacb", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -102,14 +102,14 @@ use std::path::{Path, PathBuf};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync;\n-use rustc_hir::def_id::DefIdSet;\n+use rustc_hir::def_id::{DefIdSet, LOCAL_CRATE};\n use rustc_middle::mir;\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::SwitchWithOptPath;\n+use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n use rustc_span::symbol::Symbol;\n \n use crate::collector::InliningMap;\n@@ -285,7 +285,7 @@ where\n         use std::fmt::Write;\n \n         let s = &mut String::new();\n-        let _ = writeln!(s, \"{}\", label);\n+        let _ = writeln!(s, \"{label}\");\n         for cgu in cgus {\n             let _ =\n                 writeln!(s, \"CodegenUnit {} estimated size {} :\", cgu.name(), cgu.size_estimate());\n@@ -355,9 +355,8 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n             } else {\n                 if mode_string != \"lazy\" {\n                     let message = format!(\n-                        \"Unknown codegen-item collection mode '{}'. \\\n-                                           Falling back to 'lazy' mode.\",\n-                        mode_string\n+                        \"Unknown codegen-item collection mode '{mode_string}'. \\\n+                                           Falling back to 'lazy' mode.\"\n                     );\n                     tcx.sess.warn(&message);\n                 }\n@@ -417,7 +416,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n     // Output monomorphization stats per def_id\n     if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n         if let Err(err) =\n-            dump_mono_items_stats(tcx, &codegen_units, path, tcx.sess.opts.crate_name.as_deref())\n+            dump_mono_items_stats(tcx, &codegen_units, path, tcx.crate_name(LOCAL_CRATE))\n         {\n             tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n         }\n@@ -470,7 +469,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n         item_keys.sort();\n \n         for item in item_keys {\n-            println!(\"MONO_ITEM {}\", item);\n+            println!(\"MONO_ITEM {item}\");\n         }\n     }\n \n@@ -483,7 +482,7 @@ fn dump_mono_items_stats<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     codegen_units: &[CodegenUnit<'tcx>],\n     output_directory: &Option<PathBuf>,\n-    crate_name: Option<&str>,\n+    crate_name: Symbol,\n ) -> Result<(), Box<dyn std::error::Error>> {\n     let output_directory = if let Some(ref directory) = output_directory {\n         fs::create_dir_all(directory)?;\n@@ -492,9 +491,11 @@ fn dump_mono_items_stats<'tcx>(\n         Path::new(\".\")\n     };\n \n-    let filename = format!(\"{}.mono_items.md\", crate_name.unwrap_or(\"unknown-crate\"));\n+    let format = tcx.sess.opts.unstable_opts.dump_mono_stats_format;\n+    let ext = format.extension();\n+    let filename = format!(\"{crate_name}.mono_items.{ext}\");\n     let output_path = output_directory.join(&filename);\n-    let file = File::create(output_path)?;\n+    let file = File::create(&output_path)?;\n     let mut file = BufWriter::new(file);\n \n     // Gather instantiated mono items grouped by def_id\n@@ -508,30 +509,44 @@ fn dump_mono_items_stats<'tcx>(\n         }\n     }\n \n+    #[derive(serde::Serialize)]\n+    struct MonoItem {\n+        name: String,\n+        instantiation_count: usize,\n+        size_estimate: usize,\n+        total_estimate: usize,\n+    }\n+\n     // Output stats sorted by total instantiated size, from heaviest to lightest\n     let mut stats: Vec<_> = items_per_def_id\n         .into_iter()\n         .map(|(def_id, items)| {\n+            let name = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n             let instantiation_count = items.len();\n             let size_estimate = items[0].size_estimate(tcx);\n             let total_estimate = instantiation_count * size_estimate;\n-            (def_id, instantiation_count, size_estimate, total_estimate)\n+            MonoItem { name, instantiation_count, size_estimate, total_estimate }\n         })\n         .collect();\n-    stats.sort_unstable_by_key(|(_, _, _, total_estimate)| cmp::Reverse(*total_estimate));\n+    stats.sort_unstable_by_key(|item| cmp::Reverse(item.total_estimate));\n \n     if !stats.is_empty() {\n-        writeln!(\n-            file,\n-            \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n-        )?;\n-        writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n-        for (def_id, instantiation_count, size_estimate, total_estimate) in stats {\n-            let item = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n-            writeln!(\n-                file,\n-                \"| {item} | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n-            )?;\n+        match format {\n+            DumpMonoStatsFormat::Json => serde_json::to_writer(file, &stats)?,\n+            DumpMonoStatsFormat::Markdown => {\n+                writeln!(\n+                    file,\n+                    \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n+                )?;\n+                writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n+\n+                for MonoItem { name, instantiation_count, size_estimate, total_estimate } in stats {\n+                    writeln!(\n+                        file,\n+                        \"| `{name}` | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n+                    )?;\n+                }\n+            }\n         }\n     }\n \n@@ -580,6 +595,6 @@ pub fn provide(providers: &mut Providers) {\n         let (_, all) = tcx.collect_and_partition_mono_items(());\n         all.iter()\n             .find(|cgu| cgu.name() == name)\n-            .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n+            .unwrap_or_else(|| panic!(\"failed to find cgu with name {name:?}\"))\n     };\n }"}, {"sha": "33e1f6ce3428e96559564a6c369c34ca3cc2d2c5", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -40,12 +40,12 @@ pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: In\n         let new_size = tcx\n             .layout_of(param_env.and(after_feature_tys))\n             .map(|l| format!(\"{:?}\", l.size.bytes()))\n-            .unwrap_or_else(|e| format!(\"Failed {:?}\", e));\n+            .unwrap_or_else(|e| format!(\"Failed {e:?}\"));\n \n         let old_size = tcx\n             .layout_of(param_env.and(before_feature_tys))\n             .map(|l| format!(\"{:?}\", l.size.bytes()))\n-            .unwrap_or_else(|e| format!(\"Failed {:?}\", e));\n+            .unwrap_or_else(|e| format!(\"Failed {e:?}\"));\n \n         let closure_span = tcx.def_span(closure_def_id);\n         let src_file = tcx.sess.source_map().span_to_filename(closure_span);\n@@ -54,7 +54,7 @@ pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: In\n             .source_map()\n             .span_to_lines(closure_span)\n             .map(|l| format!(\"{:?} {:?}\", l.lines.first(), l.lines.last()))\n-            .unwrap_or_else(|e| format!(\"{:?}\", e));\n+            .unwrap_or_else(|e| format!(\"{e:?}\"));\n \n         if let Err(e) = writeln!(\n             file,\n@@ -64,7 +64,7 @@ pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: In\n             src_file.prefer_local(),\n             line_nos\n         ) {\n-            eprintln!(\"Error writing to file {}\", e)\n+            eprintln!(\"Error writing to file {e}\")\n         }\n     }\n }"}, {"sha": "d9fa3e31db97226cdb4bebcf81cb0d24042c3387", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1104,7 +1104,11 @@ impl<'a> Parser<'a> {\n                     return if token::ModSep == self.token.kind {\n                         // We have some certainty that this was a bad turbofish at this point.\n                         // `foo< bar >::`\n-                        err.suggest_turbofish = Some(op.span.shrink_to_lo());\n+                        if let ExprKind::Binary(o, ..) = inner_op.kind && o.node == BinOpKind::Lt {\n+                            err.suggest_turbofish = Some(op.span.shrink_to_lo());\n+                        } else {\n+                            err.help_turbofish = Some(());\n+                        }\n \n                         let snapshot = self.create_snapshot_for_diagnostic();\n                         self.bump(); // `::`\n@@ -1130,7 +1134,11 @@ impl<'a> Parser<'a> {\n                     } else if token::OpenDelim(Delimiter::Parenthesis) == self.token.kind {\n                         // We have high certainty that this was a bad turbofish at this point.\n                         // `foo< bar >(`\n-                        err.suggest_turbofish = Some(op.span.shrink_to_lo());\n+                        if let ExprKind::Binary(o, ..) = inner_op.kind && o.node == BinOpKind::Lt {\n+                            err.suggest_turbofish = Some(op.span.shrink_to_lo());\n+                        } else {\n+                            err.help_turbofish = Some(());\n+                        }\n                         // Consume the fn call arguments.\n                         match self.consume_fn_args() {\n                             Err(()) => Err(err.into_diagnostic(&self.sess.span_diagnostic)),"}, {"sha": "9f436783ceda6f03fd89c208361f4f767c4e0e61", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1503,12 +1503,13 @@ impl<'a> Parser<'a> {\n                 prior_type_ascription: self.last_type_ascription,\n             });\n             (lo.to(self.prev_token.span), ExprKind::MacCall(mac))\n-        } else if self.check(&token::OpenDelim(Delimiter::Brace)) &&\n-            let Some(expr) = self.maybe_parse_struct_expr(&qself, &path) {\n-                if qself.is_some() {\n-                    self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n-                }\n-                return expr;\n+        } else if self.check(&token::OpenDelim(Delimiter::Brace))\n+            && let Some(expr) = self.maybe_parse_struct_expr(&qself, &path)\n+        {\n+            if qself.is_some() {\n+                self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n+            }\n+            return expr;\n         } else {\n             (path.span, ExprKind::Path(qself, path))\n         };"}, {"sha": "1eb227503f24236971e95f3f978f19054b7d9796", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -447,7 +447,7 @@ impl<'a> Parser<'a> {\n                 Some(pos)\n             } else {\n                 let pos = self.to_span_index(pos);\n-                let description = format!(\"expected `'}}'`, found `{:?}`\", maybe);\n+                let description = format!(\"expected `'}}'`, found `{maybe:?}`\");\n                 let label = \"expected `}`\".to_owned();\n                 let (note, secondary_label) = if c == '}' {\n                     (\n@@ -471,12 +471,12 @@ impl<'a> Parser<'a> {\n                 None\n             }\n         } else {\n-            let description = format!(\"expected `{:?}` but string was terminated\", c);\n+            let description = format!(\"expected `{c:?}` but string was terminated\");\n             // point at closing `\"`\n             let pos = self.input.len() - if self.append_newline { 1 } else { 0 };\n             let pos = self.to_span_index(pos);\n             if c == '}' {\n-                let label = format!(\"expected `{:?}`\", c);\n+                let label = format!(\"expected `{c:?}`\");\n                 let (note, secondary_label) = if c == '}' {\n                     (\n                         Some(\n@@ -497,7 +497,7 @@ impl<'a> Parser<'a> {\n                     should_be_replaced_with_positional_argument: false,\n                 });\n             } else {\n-                self.err(description, format!(\"expected `{:?}`\", c), pos.to(pos));\n+                self.err(description, format!(\"expected `{c:?}`\"), pos.to(pos));\n             }\n             None\n         }"}, {"sha": "8fe47d862e77dc9a329df9abdd960f690068f4b1", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -915,7 +915,7 @@ impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n                     if level != Level::Direct {\n                         error_msg.push_str(\", \");\n                     }\n-                    error_msg.push_str(&format!(\"{:?}: {}\", level, vis_str));\n+                    error_msg.push_str(&format!(\"{level:?}: {vis_str}\"));\n                 }\n             } else {\n                 error_msg.push_str(\"not in the table\");\n@@ -1223,19 +1223,22 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 self.tcx.types.never,\n             );\n \n-            for (trait_predicate, _, _) in bounds.trait_bounds {\n-                if self.visit_trait(trait_predicate.skip_binder()).is_break() {\n-                    return;\n-                }\n-            }\n-\n-            for (poly_predicate, _) in bounds.projection_bounds {\n-                let pred = poly_predicate.skip_binder();\n-                let poly_pred_term = self.visit(pred.term);\n-                if poly_pred_term.is_break()\n-                    || self.visit_projection_ty(pred.projection_ty).is_break()\n-                {\n-                    return;\n+            for (pred, _) in bounds.predicates() {\n+                match pred.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n+                        if self.visit_trait(trait_predicate.trait_ref).is_break() {\n+                            return;\n+                        }\n+                    }\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) => {\n+                        let term = self.visit(proj_predicate.term);\n+                        if term.is_break()\n+                            || self.visit_projection_ty(proj_predicate.projection_ty).is_break()\n+                        {\n+                            return;\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n@@ -2141,7 +2144,7 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n             if !old_error_set_ancestry.insert(id) {\n                 break;\n             }\n-            let parent = tcx.hir().get_parent_node(id);\n+            let parent = tcx.hir().parent_id(id);\n             if parent == id {\n                 break;\n             }"}, {"sha": "46e77626479c83ed7a09df9867c8eac3285674a2", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n+\n \n [dependencies]\n measureme = \"10.0.0\""}, {"sha": "70c481fb0ee2e0a48d0cb83ac13e85804e7bf157", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -787,7 +787,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n         d.tcx.def_path_hash_to_def_id(def_path_hash, &mut || {\n-            panic!(\"Failed to convert DefPathHash {:?}\", def_path_hash)\n+            panic!(\"Failed to convert DefPathHash {def_path_hash:?}\")\n         })\n     }\n }"}, {"sha": "6125ad4eff11835e9329ce36c20cdb7f1ce4db35", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -321,7 +321,7 @@ pub(crate) fn create_query_frame<\n         ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n     );\n     let description =\n-        if tcx.sess.verbose() { format!(\"{} [{:?}]\", description, name) } else { description };\n+        if tcx.sess.verbose() { format!(\"{description} [{name:?}]\") } else { description };\n     let span = if kind == dep_graph::DepKind::def_span {\n         // The `def_span` query is used to calculate `default_span`,\n         // so exit to avoid infinite recursion."}, {"sha": "4743170e9bfd8a450f2049e45699e1e4ff44baae", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -111,7 +111,7 @@ impl<T: Debug> IntoSelfProfilingString for T {\n         &self,\n         builder: &mut QueryKeyStringBuilder<'_, '_>,\n     ) -> StringId {\n-        let s = format!(\"{:?}\", self);\n+        let s = format!(\"{self:?}\");\n         builder.profiler.alloc_string(&s[..])\n     }\n }"}, {"sha": "c2c9600f5552cb4a4d7d872c477389ea6986352e", "filename": "compiler/rustc_query_system/src/dep_graph/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -29,7 +29,7 @@ impl DepNodeFilter {\n \n     /// Tests whether `node` meets the filter, returning true if so.\n     pub fn test<K: DepKind>(&self, node: &DepNode<K>) -> bool {\n-        let debug_str = format!(\"{:?}\", node);\n+        let debug_str = format!(\"{node:?}\");\n         self.text.split('&').map(|s| s.trim()).all(|f| debug_str.contains(f))\n     }\n }\n@@ -46,7 +46,7 @@ impl<K: DepKind> EdgeFilter<K> {\n     pub fn new(test: &str) -> Result<EdgeFilter<K>, Box<dyn Error>> {\n         let parts: Vec<_> = test.split(\"->\").collect();\n         if parts.len() != 2 {\n-            Err(format!(\"expected a filter like `a&b -> c&d`, not `{}`\", test).into())\n+            Err(format!(\"expected a filter like `a&b -> c&d`, not `{test}`\").into())\n         } else {\n             Ok(EdgeFilter {\n                 source: DepNodeFilter::new(parts[0]),"}, {"sha": "9e1ca6ab515d846e1f444252dcc4a7ac2ac8120a", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -120,7 +120,7 @@ pub trait DepNodeParams<Tcx: DepContext>: fmt::Debug + Sized {\n     }\n \n     fn to_debug_str(&self, _: Tcx) -> String {\n-        format!(\"{:?}\", self)\n+        format!(\"{self:?}\")\n     }\n \n     /// This method tries to recover the query key from the given `DepNode`,"}, {"sha": "53c9da15737183b0120bce2be2d1667e9bb364da", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -316,10 +316,8 @@ impl<K: DepKind> DepGraph<K> {\n         assert!(\n             !self.dep_node_exists(&key),\n             \"forcing query with already existing `DepNode`\\n\\\n-                 - query-key: {:?}\\n\\\n-                 - dep-node: {:?}\",\n-            arg,\n-            key\n+                 - query-key: {arg:?}\\n\\\n+                 - dep-node: {key:?}\"\n         );\n \n         let task_deps = if cx.dep_context().is_eval_always(key.kind) {\n@@ -365,8 +363,7 @@ impl<K: DepKind> DepGraph<K> {\n             debug_assert!(\n                 data.colors.get(prev_index).is_none(),\n                 \"DepGraph::with_task() - Duplicate DepNodeColor \\\n-                            insertion for {:?}\",\n-                key\n+                            insertion for {key:?}\"\n             );\n \n             data.colors.insert(prev_index, color);\n@@ -447,7 +444,7 @@ impl<K: DepKind> DepGraph<K> {\n                     TaskDepsRef::Allow(deps) => deps.lock(),\n                     TaskDepsRef::Ignore => return,\n                     TaskDepsRef::Forbid => {\n-                        panic!(\"Illegal read of: {:?}\", dep_node_index)\n+                        panic!(\"Illegal read of: {dep_node_index:?}\")\n                     }\n                 };\n                 let task_deps = &mut *task_deps;\n@@ -824,8 +821,7 @@ impl<K: DepKind> DepGraph<K> {\n         debug_assert!(\n             data.colors.get(prev_dep_node_index).is_none(),\n             \"DepGraph::try_mark_previous_green() - Duplicate DepNodeColor \\\n-                      insertion for {:?}\",\n-            dep_node\n+                      insertion for {dep_node:?}\"\n         );\n \n         if !side_effects.is_empty() {\n@@ -1164,7 +1160,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             if let Some(fingerprint) = fingerprint {\n                 if fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n                     if print_status {\n-                        eprintln!(\"[task::green] {:?}\", key);\n+                        eprintln!(\"[task::green] {key:?}\");\n                     }\n \n                     // This is a green node: it existed in the previous compilation,\n@@ -1186,7 +1182,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n                     if print_status {\n-                        eprintln!(\"[task::red] {:?}\", key);\n+                        eprintln!(\"[task::red] {key:?}\");\n                     }\n \n                     // This is a red node: it existed in the previous compilation, its query\n@@ -1209,7 +1205,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 }\n             } else {\n                 if print_status {\n-                    eprintln!(\"[task::unknown] {:?}\", key);\n+                    eprintln!(\"[task::unknown] {key:?}\");\n                 }\n \n                 // This is a red node, effectively: it existed in the previous compilation\n@@ -1234,7 +1230,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             }\n         } else {\n             if print_status {\n-                eprintln!(\"[task::new] {:?}\", key);\n+                eprintln!(\"[task::new] {key:?}\");\n             }\n \n             let fingerprint = fingerprint.unwrap_or(Fingerprint::ZERO);"}, {"sha": "dfc1344f85c70cabbeb86f452cbd8abc704203dc", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -270,25 +270,22 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n \n             eprintln!(\"[incremental]\");\n             eprintln!(\"[incremental] DepGraph Statistics\");\n-            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"{SEPARATOR}\");\n             eprintln!(\"[incremental]\");\n             eprintln!(\"[incremental] Total Node Count: {}\", status.total_node_count);\n             eprintln!(\"[incremental] Total Edge Count: {}\", status.total_edge_count);\n \n             if cfg!(debug_assertions) {\n-                eprintln!(\"[incremental] Total Edge Reads: {}\", total_read_count);\n-                eprintln!(\n-                    \"[incremental] Total Duplicate Edge Reads: {}\",\n-                    total_duplicate_read_count\n-                );\n+                eprintln!(\"[incremental] Total Edge Reads: {total_read_count}\");\n+                eprintln!(\"[incremental] Total Duplicate Edge Reads: {total_duplicate_read_count}\");\n             }\n \n             eprintln!(\"[incremental]\");\n             eprintln!(\n                 \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n                 \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n             );\n-            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"{SEPARATOR}\");\n \n             for stat in stats {\n                 let node_kind_ratio =\n@@ -304,7 +301,7 @@ impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n                 );\n             }\n \n-            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"{SEPARATOR}\");\n             eprintln!(\"[incremental]\");\n         }\n     }"}, {"sha": "b3b939eae88dce04c1e1efa8bb3a6bcc19a9910a", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -549,8 +549,7 @@ where\n         // can be forced from `DepNode`.\n         debug_assert!(\n             !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n-            \"missing on-disk cache entry for {:?}\",\n-            dep_node\n+            \"missing on-disk cache entry for {dep_node:?}\"\n         );\n     }\n \n@@ -589,8 +588,7 @@ where\n {\n     assert!(\n         tcx.dep_graph().is_green(dep_node),\n-        \"fingerprint for green query instance not loaded from cache: {:?}\",\n-        dep_node,\n+        \"fingerprint for green query instance not loaded from cache: {dep_node:?}\",\n     );\n \n     let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n@@ -669,16 +667,16 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n         sess.emit_err(crate::error::Reentrant);\n     } else {\n         let run_cmd = if let Some(crate_name) = &sess.opts.crate_name {\n-            format!(\"`cargo clean -p {}` or `cargo clean`\", crate_name)\n+            format!(\"`cargo clean -p {crate_name}` or `cargo clean`\")\n         } else {\n             \"`cargo clean`\".to_string()\n         };\n \n         sess.emit_err(crate::error::IncrementCompilation {\n             run_cmd,\n-            dep_node: format!(\"{:?}\", dep_node),\n+            dep_node: format!(\"{dep_node:?}\"),\n         });\n-        panic!(\"Found unstable fingerprints for {:?}: {:?}\", dep_node, result);\n+        panic!(\"Found unstable fingerprints for {dep_node:?}: {result:?}\");\n     }\n \n     INSIDE_VERIFY_PANIC.with(|in_panic| in_panic.set(old_in_panic));"}, {"sha": "e41fe325b811cb42cf118565782a00e1f75df0eb", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -820,13 +820,12 @@ impl<'a> Resolver<'a> {\n             // binding if it exists. What we really want here is having two separate scopes in\n             // a module - one for non-globs and one for globs, but until that's done use this\n             // hack to avoid inconsistent resolution ICEs during import validation.\n-            let binding = [resolution.binding, resolution.shadowed_glob]\n-                .into_iter()\n-                .filter_map(|binding| match (binding, ignore_binding) {\n+            let binding = [resolution.binding, resolution.shadowed_glob].into_iter().find_map(\n+                |binding| match (binding, ignore_binding) {\n                     (Some(binding), Some(ignored)) if ptr::eq(binding, ignored) => None,\n                     _ => binding,\n-                })\n-                .next();\n+                },\n+            );\n             let Some(binding) = binding else {\n                 return Err((Determined, Weak::No));\n             };"}, {"sha": "ca43762aa214ec63c846c738a8a8aabe90d86e64", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1515,7 +1515,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             count: 1,\n         };\n         let elision_candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n-        for rib in self.lifetime_ribs.iter().rev() {\n+        for (i, rib) in self.lifetime_ribs.iter().enumerate().rev() {\n             debug!(?rib.kind);\n             match rib.kind {\n                 LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n@@ -1532,16 +1532,31 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     } else {\n                         (\"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\")\n                     };\n-                    rustc_errors::struct_span_err!(\n+                    let mut diag = rustc_errors::struct_span_err!(\n                         self.r.session,\n                         lifetime.ident.span,\n                         E0637,\n                         \"{}\",\n                         msg,\n-                    )\n-                    .span_label(lifetime.ident.span, note)\n-                    .emit();\n-\n+                    );\n+                    diag.span_label(lifetime.ident.span, note);\n+                    if elided {\n+                        for rib in self.lifetime_ribs[i..].iter().rev() {\n+                            if let LifetimeRibKind::Generics {\n+                                span,\n+                                kind: LifetimeBinderKind::PolyTrait | LifetimeBinderKind::WhereBound,\n+                                ..\n+                            } = &rib.kind\n+                            {\n+                                diag.span_help(\n+                                    *span,\n+                                    \"consider introducing a higher-ranked lifetime here with `for<'a>`\",\n+                                );\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    diag.emit();\n                     self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n                     return;\n                 }"}, {"sha": "a8d82de02b7548836d5b8e3a7e70ae07caab06a2", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -600,7 +600,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 if seg.res != Res::Err {\n                     seg.res\n                 } else {\n-                    let parent_node = self.tcx.hir().get_parent_node(hir_id);\n+                    let parent_node = self.tcx.hir().parent_id(hir_id);\n                     self.get_path_res(parent_node)\n                 }\n             }"}, {"sha": "1ccfc59f7a9d61e86b5b9f245cf0f8303f465e6b", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -35,6 +35,7 @@ use std::hash::Hash;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::str::{self, FromStr};\n+use std::sync::LazyLock;\n \n pub mod sigpipe;\n \n@@ -554,6 +555,16 @@ pub enum PrintRequest {\n     SplitDebuginfo,\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub enum TraitSolver {\n+    /// Classic trait solver in `rustc_trait_selection::traits::select`\n+    Classic,\n+    /// Chalk trait solver\n+    Chalk,\n+    /// Experimental trait solver in `rustc_trait_selection::solve`\n+    Next,\n+}\n+\n pub enum Input {\n     /// Load source code from a file.\n     File(PathBuf),\n@@ -1312,7 +1323,12 @@ mod opt {\n         unstable(longer(a, b), move |opts| opts.optmulti(a, b, c, d))\n     }\n }\n-\n+static EDITION_STRING: LazyLock<String> = LazyLock::new(|| {\n+    format!(\n+        \"Specify which edition of the compiler to use when compiling code. \\\n+The default is {DEFAULT_EDITION} and the latest stable edition is {LATEST_STABLE_EDITION}.\"\n+    )\n+});\n /// Returns the \"short\" subset of the rustc command line options,\n /// including metadata for each option, such as whether the option is\n /// part of the stable long-term interface for rustc.\n@@ -1345,7 +1361,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n         opt::opt_s(\n             \"\",\n             \"edition\",\n-            \"Specify which edition of the compiler to use when compiling code.\",\n+            &*EDITION_STRING,\n             EDITION_NAME_LIST,\n         ),\n         opt::multi_s(\n@@ -2761,7 +2777,7 @@ pub(crate) mod dep_tracking {\n         BranchProtection, CFGuard, CFProtection, CrateType, DebugInfo, ErrorOutputType,\n         InstrumentCoverage, LdImpl, LinkerPluginLto, LocationDetail, LtoCli, OomStrategy, OptLevel,\n         OutputType, OutputTypes, Passes, SourceFileHashAlgorithm, SplitDwarfKind,\n-        SwitchWithOptPath, SymbolManglingVersion, TrimmedDefPaths,\n+        SwitchWithOptPath, SymbolManglingVersion, TraitSolver, TrimmedDefPaths,\n     };\n     use crate::lint;\n     use crate::options::WasiExecModel;\n@@ -2861,6 +2877,7 @@ pub(crate) mod dep_tracking {\n         BranchProtection,\n         OomStrategy,\n         LanguageIdentifier,\n+        TraitSolver,\n     );\n \n     impl<T1, T2> DepTrackingHash for (T1, T2)\n@@ -2981,3 +2998,21 @@ pub enum ProcMacroExecutionStrategy {\n     /// Run the proc-macro code on a different thread.\n     CrossThread,\n }\n+\n+/// Which format to use for `-Z dump-mono-stats`\n+#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+pub enum DumpMonoStatsFormat {\n+    /// Pretty-print a markdown table\n+    Markdown,\n+    /// Emit structured JSON\n+    Json,\n+}\n+\n+impl DumpMonoStatsFormat {\n+    pub fn extension(self) -> &'static str {\n+        match self {\n+            Self::Markdown => \"md\",\n+            Self::Json => \"json\",\n+        }\n+    }\n+}"}, {"sha": "f5a72573d58cd00d8d1cc5c4fbafb5e6ed0e9333", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -260,9 +260,11 @@ pub(crate) struct InvalidFloatLiteralSuffix {\n \n #[derive(Diagnostic)]\n #[diag(session_int_literal_too_large)]\n+#[note]\n pub(crate) struct IntLiteralTooLarge {\n     #[primary_span]\n     pub span: Span,\n+    pub limit: String,\n }\n \n #[derive(Diagnostic)]\n@@ -361,8 +363,15 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n                 _ => unreachable!(),\n             };\n         }\n-        LitError::IntTooLarge => {\n-            sess.emit_err(IntLiteralTooLarge { span });\n+        LitError::IntTooLarge(base) => {\n+            let max = u128::MAX;\n+            let limit = match base {\n+                2 => format!(\"{max:#b}\"),\n+                8 => format!(\"{max:#o}\"),\n+                16 => format!(\"{max:#x}\"),\n+                _ => format!(\"{max}\"),\n+            };\n+            sess.emit_err(IntLiteralTooLarge { span, limit });\n         }\n     }\n }"}, {"sha": "043a60a1c5310c7247ad0fe286c681d7269d2226", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -377,10 +377,13 @@ mod desc {\n     pub const parse_linker_flavor: &str = ::rustc_target::spec::LinkerFlavorCli::one_of();\n     pub const parse_optimization_fuel: &str = \"crate=integer\";\n     pub const parse_mir_spanview: &str = \"`statement` (default), `terminator`, or `block`\";\n+    pub const parse_dump_mono_stats: &str = \"`markdown` (default) or `json`\";\n     pub const parse_instrument_coverage: &str =\n         \"`all` (default), `except-unused-generics`, `except-unused-functions`, or `off`\";\n     pub const parse_unpretty: &str = \"`string` or `string=string`\";\n     pub const parse_treat_err_as_bug: &str = \"either no value or a number bigger than 0\";\n+    pub const parse_trait_solver: &str =\n+        \"one of the supported solver modes (`classic`, `chalk`, or `next`)\";\n     pub const parse_lto: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, `fat`, or omitted\";\n     pub const parse_linker_plugin_lto: &str =\n@@ -820,6 +823,21 @@ mod parse {\n         true\n     }\n \n+    pub(crate) fn parse_dump_mono_stats(slot: &mut DumpMonoStatsFormat, v: Option<&str>) -> bool {\n+        match v {\n+            None => true,\n+            Some(\"json\") => {\n+                *slot = DumpMonoStatsFormat::Json;\n+                true\n+            }\n+            Some(\"markdown\") => {\n+                *slot = DumpMonoStatsFormat::Markdown;\n+                true\n+            }\n+            Some(_) => false,\n+        }\n+    }\n+\n     pub(crate) fn parse_instrument_coverage(\n         slot: &mut Option<InstrumentCoverage>,\n         v: Option<&str>,\n@@ -864,6 +882,18 @@ mod parse {\n         }\n     }\n \n+    pub(crate) fn parse_trait_solver(slot: &mut TraitSolver, v: Option<&str>) -> bool {\n+        match v {\n+            Some(\"classic\") => *slot = TraitSolver::Classic,\n+            Some(\"chalk\") => *slot = TraitSolver::Chalk,\n+            Some(\"next\") => *slot = TraitSolver::Next,\n+            // default trait solver is subject to change..\n+            Some(\"default\") => *slot = TraitSolver::Classic,\n+            _ => return false,\n+        }\n+        true\n+    }\n+\n     pub(crate) fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n@@ -1233,8 +1263,6 @@ options! {\n         \"instrument control-flow architecture protection\"),\n     cgu_partitioning_strategy: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the codegen unit partitioning strategy to use\"),\n-    chalk: bool = (false, parse_bool, [TRACKED],\n-        \"enable the experimental Chalk-based trait solving engine\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n     combine_cgu: bool = (false, parse_bool, [TRACKED],\n@@ -1295,7 +1323,9 @@ options! {\n         an additional `.html` file showing the computed coverage spans.\"),\n     dump_mono_stats: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n         parse_switch_with_opt_path, [UNTRACKED],\n-        \"output statistics about monomorphization collection (format: markdown)\"),\n+        \"output statistics about monomorphization collection\"),\n+    dump_mono_stats_format: DumpMonoStatsFormat = (DumpMonoStatsFormat::Markdown, parse_dump_mono_stats, [UNTRACKED],\n+        \"the format to use for -Z dump-mono-stats (`markdown` (default) or `json`)\"),\n     dwarf_version: Option<u32> = (None, parse_opt_number, [TRACKED],\n         \"version of DWARF debug information to emit (default: 2 or 4, depending on platform)\"),\n     dylib_lto: bool = (false, parse_bool, [UNTRACKED],\n@@ -1591,6 +1621,8 @@ options! {\n         \"for every macro invocation, print its name and arguments (default: no)\"),\n     track_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n         \"tracks where in rustc a diagnostic was emitted\"),\n+    trait_solver: TraitSolver = (TraitSolver::Classic, parse_trait_solver, [TRACKED],\n+        \"specify the trait solver mode used by rustc (default: classic)\"),\n     // Diagnostics are considered side-effects of a query (see `QuerySideEffects`) and are saved\n     // alongside query results and changes to translation options can affect diagnostics - so\n     // translation options should be tracked."}, {"sha": "1b2e8d9dc707bdd60673f4b2d859057899227588", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -590,7 +590,19 @@ impl Session {\n     pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().warn(msg)\n     }\n-    /// Delay a span_bug() call until abort_if_errors()\n+\n+    /// Ensures that compilation cannot succeed.\n+    ///\n+    /// If this function has been called but no errors have been emitted and\n+    /// compilation succeeds, it will cause an internal compiler error (ICE).\n+    ///\n+    /// This can be used in code paths that should never run on successful compilations.\n+    /// For example, it can be used to create an [`ErrorGuaranteed`]\n+    /// (but you should prefer threading through the [`ErrorGuaranteed`] from an error emission directly).\n+    ///\n+    /// If no span is available, use [`DUMMY_SP`].\n+    ///\n+    /// [`DUMMY_SP`]: rustc_span::DUMMY_SP\n     #[track_caller]\n     pub fn delay_span_bug<S: Into<MultiSpan>>(\n         &self,"}, {"sha": "7c5e1427d1ed72e9e7a8f45ad2c2e70cb8eef90e", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -303,7 +303,7 @@ impl DefId {\n         // i.e. don't use closures.\n         match self.as_local() {\n             Some(local_def_id) => local_def_id,\n-            None => panic!(\"DefId::expect_local: `{:?}` isn't local\", self),\n+            None => panic!(\"DefId::expect_local: `{self:?}` isn't local\"),\n         }\n     }\n "}, {"sha": "b43183916bca542bcf7a7092a0583ce75f339dbe", "filename": "compiler/rustc_span/src/edition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedition.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -44,7 +44,7 @@ impl fmt::Display for Edition {\n             Edition::Edition2021 => \"2021\",\n             Edition::Edition2024 => \"2024\",\n         };\n-        write!(f, \"{}\", s)\n+        write!(f, \"{s}\")\n     }\n }\n "}, {"sha": "a9a9a3fbf9d8061c54dbd6fc05d8894d0a339da7", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -110,7 +110,7 @@ fn assert_default_hashing_controls<CTX: HashStableContext>(ctx: &CTX, msg: &str)\n         // Such configuration must not be used for metadata.\n         HashingControls { hash_spans }\n             if hash_spans == !ctx.unstable_opts_incremental_ignore_spans() => {}\n-        other => panic!(\"Attempted hashing of {msg} with non-default HashingControls: {:?}\", other),\n+        other => panic!(\"Attempted hashing of {msg} with non-default HashingControls: {other:?}\"),\n     }\n }\n \n@@ -629,7 +629,7 @@ pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symb\n pub fn debug_hygiene_data(verbose: bool) -> String {\n     HygieneData::with(|data| {\n         if verbose {\n-            format!(\"{:#?}\", data)\n+            format!(\"{data:#?}\")\n         } else {\n             let mut s = String::from(\"Expansions:\");\n             let mut debug_expn_data = |(id, expn_data): (&ExpnId, &ExpnData)| {\n@@ -1067,9 +1067,9 @@ impl ExpnKind {\n         match *self {\n             ExpnKind::Root => kw::PathRoot.to_string(),\n             ExpnKind::Macro(macro_kind, name) => match macro_kind {\n-                MacroKind::Bang => format!(\"{}!\", name),\n-                MacroKind::Attr => format!(\"#[{}]\", name),\n-                MacroKind::Derive => format!(\"#[derive({})]\", name),\n+                MacroKind::Bang => format!(\"{name}!\"),\n+                MacroKind::Attr => format!(\"#[{name}]\"),\n+                MacroKind::Derive => format!(\"#[derive({name})]\"),\n             },\n             ExpnKind::AstPass(kind) => kind.descr().to_string(),\n             ExpnKind::Desugaring(kind) => format!(\"desugaring of {}\", kind.descr()),\n@@ -1466,11 +1466,7 @@ impl<D: Decoder> Decodable<D> for SyntaxContext {\n /// collisions are only possible between `ExpnId`s within the same crate.\n fn update_disambiguator(expn_data: &mut ExpnData, mut ctx: impl HashStableContext) -> ExpnHash {\n     // This disambiguator should not have been set yet.\n-    assert_eq!(\n-        expn_data.disambiguator, 0,\n-        \"Already set disambiguator for ExpnData: {:?}\",\n-        expn_data\n-    );\n+    assert_eq!(expn_data.disambiguator, 0, \"Already set disambiguator for ExpnData: {expn_data:?}\");\n     assert_default_hashing_controls(&ctx, \"ExpnData (disambiguator)\");\n     let mut expn_hash = expn_data.hash_expn(&mut ctx);\n "}, {"sha": "7e61f2f9f73c0a3d5c27ceb4eb3fe2d457558b5b", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -329,7 +329,7 @@ impl fmt::Display for FileNameDisplay<'_> {\n             ProcMacroSourceCode(_) => write!(fmt, \"<proc-macro source code>\"),\n             CfgSpec(_) => write!(fmt, \"<cfgspec>\"),\n             CliCrateAttr(_) => write!(fmt, \"<crate attribute>\"),\n-            Custom(ref s) => write!(fmt, \"<{}>\", s),\n+            Custom(ref s) => write!(fmt, \"<{s}>\"),\n             DocTest(ref path, _) => write!(fmt, \"{}\", path.display()),\n             InlineAsm(_) => write!(fmt, \"<inline asm>\"),\n         }\n@@ -1074,7 +1074,7 @@ impl NonNarrowChar {\n             0 => NonNarrowChar::ZeroWidth(pos),\n             2 => NonNarrowChar::Wide(pos),\n             4 => NonNarrowChar::Tab(pos),\n-            _ => panic!(\"width {} given for non-narrow character\", width),\n+            _ => panic!(\"width {width} given for non-narrow character\"),\n         }\n     }\n "}, {"sha": "0ab890b9f01217ca2693b0fd97e1af4488603589", "filename": "compiler/rustc_span/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fprofiling.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -27,7 +27,7 @@ impl SpannedEventArgRecorder for EventArgRecorder<'_> {\n             if let Some(source_map) = &*session_globals.source_map.borrow() {\n                 source_map.span_to_embeddable_string(span)\n             } else {\n-                format!(\"{:?}\", span)\n+                format!(\"{span:?}\")\n             }\n         });\n         self.record_arg(span_arg);"}, {"sha": "5d5f8d6d65405c5fd00d57f741d95c39dd12b4a7", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -193,6 +193,7 @@ symbols! {\n         FromIterator,\n         FromResidual,\n         Future,\n+        FutureOutput,\n         FxHashMap,\n         FxHashSet,\n         GlobalAlloc,"}, {"sha": "23ff6b333f0dd7626a397f3c1445e27a058e063e", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -175,7 +175,7 @@ impl SymbolPath {\n     fn finish(mut self, hash: u64) -> String {\n         self.finalize_pending_component();\n         // E = end name-sequence\n-        let _ = write!(self.result, \"17h{:016x}E\", hash);\n+        let _ = write!(self.result, \"17h{hash:016x}E\");\n         self.result\n     }\n }\n@@ -227,7 +227,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n                 self = self.print_type(ty)?;\n                 self.write_str(\"; \")?;\n                 if let Some(size) = size.kind().try_to_bits(self.tcx().data_layout.pointer_size) {\n-                    write!(self, \"{}\", size)?\n+                    write!(self, \"{size}\")?\n                 } else if let ty::ConstKind::Param(param) = size.kind() {\n                     self = param.print(self)?\n                 } else {"}, {"sha": "547a5907660236f130ce94ea3d7a2ace3536d30c", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -269,8 +269,7 @@ fn compute_symbol_name<'tcx>(\n \n     debug_assert!(\n         rustc_demangle::try_demangle(&symbol).is_ok(),\n-        \"compute_symbol_name: `{}` cannot be demangled\",\n-        symbol\n+        \"compute_symbol_name: `{symbol}` cannot be demangled\"\n     );\n \n     symbol"}, {"sha": "c6899f8f244ef929d536b951ef969a25093aae3e", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -74,7 +74,7 @@ impl SymbolNamesTest<'_> {\n                 tcx.sess.emit_err(TestOutput {\n                     span: attr.span,\n                     kind: Kind::DemanglingAlt,\n-                    content: format!(\"{:#}\", demangling),\n+                    content: format!(\"{demangling:#}\"),\n                 });\n             }\n         }"}, {"sha": "0759b95bd94c8f5e4d930f7d5f50224ef30e5611", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -126,11 +126,11 @@ fn encode_const<'tcx>(\n         if value < zero {\n             s.push('n')\n         };\n-        let _ = write!(s, \"{}\", value);\n+        let _ = write!(s, \"{value}\");\n     }\n \n     fn push_unsigned_value<T: Display>(s: &mut String, value: T) {\n-        let _ = write!(s, \"{}\", value);\n+        let _ = write!(s, \"{value}\");\n     }\n \n     if let Some(scalar_int) = c.kind().try_to_scalar_int() {"}, {"sha": "0d446d654dc5ce99ede511fb1a4c6f7fc149f279", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -206,6 +206,7 @@ impl<'tcx> SymbolMangler<'tcx> {\n     where\n         T: TypeVisitable<'tcx>,\n     {\n+        // FIXME(non-lifetime-binders): What to do here?\n         let regions = if value.has_late_bound_regions() {\n             self.tcx.collect_referenced_late_bound_regions(value)\n         } else {\n@@ -609,7 +610,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                     bits = val.unsigned_abs();\n                 }\n \n-                let _ = write!(self.out, \"{:x}_\", bits);\n+                let _ = write!(self.out, \"{bits:x}_\");\n             }\n \n             // FIXME(valtrees): Remove the special case for `str`\n@@ -637,7 +638,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n                                 // FIXME(eddyb) use a specialized hex-encoding loop.\n                                 for byte in s.bytes() {\n-                                    let _ = write!(self.out, \"{:02x}\", byte);\n+                                    let _ = write!(self.out, \"{byte:02x}\");\n                                 }\n \n                                 self.push(\"_\");"}, {"sha": "3b8c867d35ba37b3a06e41b64b90123c19f514d6", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -71,12 +71,7 @@ mod attr_impl {\n             const NonNull   = 1 << 3;\n             const ReadOnly  = 1 << 4;\n             const InReg     = 1 << 5;\n-            // Due to past miscompiles in LLVM, we use a separate attribute for\n-            // &mut arguments, so that the codegen backend can decide whether\n-            // or not to actually emit the attribute. It can also be controlled\n-            // with the `-Zmutable-noalias` debugging option.\n-            const NoAliasMutRef = 1 << 6;\n-            const NoUndef = 1 << 7;\n+            const NoUndef = 1 << 6;\n         }\n     }\n }\n@@ -177,12 +172,12 @@ impl Reg {\n                 17..=32 => dl.i32_align.abi,\n                 33..=64 => dl.i64_align.abi,\n                 65..=128 => dl.i128_align.abi,\n-                _ => panic!(\"unsupported integer: {:?}\", self),\n+                _ => panic!(\"unsupported integer: {self:?}\"),\n             },\n             RegKind::Float => match self.size.bits() {\n                 32 => dl.f32_align.abi,\n                 64 => dl.f64_align.abi,\n-                _ => panic!(\"unsupported float: {:?}\", self),\n+                _ => panic!(\"unsupported float: {self:?}\"),\n             },\n             RegKind::Vector => dl.vector_align(self.size).abi,\n         }\n@@ -642,7 +637,7 @@ impl fmt::Display for AdjustForForeignAbiError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Self::Unsupported { arch, abi } => {\n-                write!(f, \"target architecture {:?} does not support `extern {}` ABI\", arch, abi)\n+                write!(f, \"target architecture {arch:?} does not support `extern {abi}` ABI\")\n             }\n         }\n     }\n@@ -760,7 +755,7 @@ impl FromStr for Conv {\n             \"AmdGpuKernel\" => Ok(Conv::AmdGpuKernel),\n             \"AvrInterrupt\" => Ok(Conv::AvrInterrupt),\n             \"AvrNonBlockingInterrupt\" => Ok(Conv::AvrNonBlockingInterrupt),\n-            _ => Err(format!(\"'{}' is not a valid value for entry function call convetion.\", s)),\n+            _ => Err(format!(\"'{s}' is not a valid value for entry function call convetion.\")),\n         }\n     }\n }"}, {"sha": "28493c7700ffca27cb77fb5b0f0c5343ff5d6cc2", "filename": "compiler/rustc_target/src/asm/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Faarch64.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -195,6 +195,6 @@ impl AArch64InlineAsmReg {\n             (modifier.unwrap_or('v'), self as u32 - Self::v0 as u32)\n         };\n         assert!(index < 32);\n-        write!(out, \"{}{}\", prefix, index)\n+        write!(out, \"{prefix}{index}\")\n     }\n }"}, {"sha": "ec7429a306554c868c8d8f28ce804a9bb72904e6", "filename": "compiler/rustc_target/src/asm/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Farm.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -249,7 +249,7 @@ impl ArmInlineAsmReg {\n             let index = self as u32 - Self::q0 as u32;\n             assert!(index < 16);\n             let index = index * 2 + (modifier == 'f') as u32;\n-            write!(out, \"d{}\", index)\n+            write!(out, \"d{index}\")\n         } else {\n             out.write_str(self.name())\n         }"}, {"sha": "7f01f33d39c6cace7bfcb13e9fccd35963ae45f1", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -679,13 +679,13 @@ impl fmt::Display for InlineAsmType {\n             Self::I128 => f.write_str(\"i128\"),\n             Self::F32 => f.write_str(\"f32\"),\n             Self::F64 => f.write_str(\"f64\"),\n-            Self::VecI8(n) => write!(f, \"i8x{}\", n),\n-            Self::VecI16(n) => write!(f, \"i16x{}\", n),\n-            Self::VecI32(n) => write!(f, \"i32x{}\", n),\n-            Self::VecI64(n) => write!(f, \"i64x{}\", n),\n-            Self::VecI128(n) => write!(f, \"i128x{}\", n),\n-            Self::VecF32(n) => write!(f, \"f32x{}\", n),\n-            Self::VecF64(n) => write!(f, \"f64x{}\", n),\n+            Self::VecI8(n) => write!(f, \"i8x{n}\"),\n+            Self::VecI16(n) => write!(f, \"i16x{n}\"),\n+            Self::VecI32(n) => write!(f, \"i32x{n}\"),\n+            Self::VecI64(n) => write!(f, \"i64x{n}\"),\n+            Self::VecI128(n) => write!(f, \"i128x{n}\"),\n+            Self::VecF32(n) => write!(f, \"f32x{n}\"),\n+            Self::VecF64(n) => write!(f, \"f64x{n}\"),\n         }\n     }\n }"}, {"sha": "5eae07f141fc00b515cc8256cb6a7593fea3bbf3", "filename": "compiler/rustc_target/src/asm/x86.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fx86.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -357,28 +357,28 @@ impl X86InlineAsmReg {\n         if self as u32 <= Self::dx as u32 {\n             let root = ['a', 'b', 'c', 'd'][self as usize - Self::ax as usize];\n             match modifier.unwrap_or(reg_default_modifier) {\n-                'l' => write!(out, \"{}l\", root),\n-                'h' => write!(out, \"{}h\", root),\n-                'x' => write!(out, \"{}x\", root),\n-                'e' => write!(out, \"e{}x\", root),\n-                'r' => write!(out, \"r{}x\", root),\n+                'l' => write!(out, \"{root}l\"),\n+                'h' => write!(out, \"{root}h\"),\n+                'x' => write!(out, \"{root}x\"),\n+                'e' => write!(out, \"e{root}x\"),\n+                'r' => write!(out, \"r{root}x\"),\n                 _ => unreachable!(),\n             }\n         } else if self as u32 <= Self::di as u32 {\n             let root = self.name();\n             match modifier.unwrap_or(reg_default_modifier) {\n-                'l' => write!(out, \"{}l\", root),\n-                'x' => write!(out, \"{}\", root),\n-                'e' => write!(out, \"e{}\", root),\n-                'r' => write!(out, \"r{}\", root),\n+                'l' => write!(out, \"{root}l\"),\n+                'x' => write!(out, \"{root}\"),\n+                'e' => write!(out, \"e{root}\"),\n+                'r' => write!(out, \"r{root}\"),\n                 _ => unreachable!(),\n             }\n         } else if self as u32 <= Self::r15 as u32 {\n             let root = self.name();\n             match modifier.unwrap_or(reg_default_modifier) {\n-                'l' => write!(out, \"{}b\", root),\n-                'x' => write!(out, \"{}w\", root),\n-                'e' => write!(out, \"{}d\", root),\n+                'l' => write!(out, \"{root}b\"),\n+                'x' => write!(out, \"{root}w\"),\n+                'e' => write!(out, \"{root}d\"),\n                 'r' => out.write_str(root),\n                 _ => unreachable!(),\n             }\n@@ -387,15 +387,15 @@ impl X86InlineAsmReg {\n         } else if self as u32 <= Self::xmm15 as u32 {\n             let prefix = modifier.unwrap_or('x');\n             let index = self as u32 - Self::xmm0 as u32;\n-            write!(out, \"{}{}\", prefix, index)\n+            write!(out, \"{prefix}{index}\")\n         } else if self as u32 <= Self::ymm15 as u32 {\n             let prefix = modifier.unwrap_or('y');\n             let index = self as u32 - Self::ymm0 as u32;\n-            write!(out, \"{}{}\", prefix, index)\n+            write!(out, \"{prefix}{index}\")\n         } else if self as u32 <= Self::zmm31 as u32 {\n             let prefix = modifier.unwrap_or('z');\n             let index = self as u32 - Self::zmm0 as u32;\n-            write!(out, \"{}{}\", prefix, index)\n+            write!(out, \"{prefix}{index}\")\n         } else {\n             out.write_str(self.name())\n         }"}, {"sha": "da493f0c2603c0e7104a2b213a4613fc32ec1ec3", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_fuchsia.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_fuchsia.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2,7 +2,7 @@ use crate::spec::{SanitizerSet, Target, TargetOptions};\n \n pub fn target() -> Target {\n     Target {\n-        llvm_target: \"aarch64-fuchsia\".into(),\n+        llvm_target: \"aarch64-unknown-fuchsia\".into(),\n         pointer_width: 64,\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".into(),\n         arch: \"aarch64\".into(),", "previous_filename": "compiler/rustc_target/src/spec/aarch64_fuchsia.rs"}, {"sha": "5c6dcc0aba9c354e8c3dc6ad8b398050935436c3", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -76,7 +76,7 @@ impl Arch {\n \n fn pre_link_args(os: &'static str, arch: Arch, abi: &'static str) -> LinkArgs {\n     let platform_name: StaticCow<str> = match abi {\n-        \"sim\" => format!(\"{}-simulator\", os).into(),\n+        \"sim\" => format!(\"{os}-simulator\").into(),\n         \"macabi\" => \"mac-catalyst\".into(),\n         _ => os.into(),\n     };\n@@ -193,7 +193,7 @@ fn macos_deployment_target(arch: Arch) -> (u32, u32) {\n \n fn macos_lld_platform_version(arch: Arch) -> String {\n     let (major, minor) = macos_deployment_target(arch);\n-    format!(\"{}.{}\", major, minor)\n+    format!(\"{major}.{minor}\")\n }\n \n pub fn macos_llvm_target(arch: Arch) -> String {\n@@ -252,7 +252,7 @@ pub fn ios_llvm_target(arch: Arch) -> String {\n \n fn ios_lld_platform_version() -> String {\n     let (major, minor) = ios_deployment_target();\n-    format!(\"{}.{}\", major, minor)\n+    format!(\"{major}.{minor}\")\n }\n \n pub fn ios_sim_llvm_target(arch: Arch) -> String {\n@@ -266,7 +266,7 @@ fn tvos_deployment_target() -> (u32, u32) {\n \n fn tvos_lld_platform_version() -> String {\n     let (major, minor) = tvos_deployment_target();\n-    format!(\"{}.{}\", major, minor)\n+    format!(\"{major}.{minor}\")\n }\n \n fn watchos_deployment_target() -> (u32, u32) {\n@@ -275,7 +275,7 @@ fn watchos_deployment_target() -> (u32, u32) {\n \n fn watchos_lld_platform_version() -> String {\n     let (major, minor) = watchos_deployment_target();\n-    format!(\"{}.{}\", major, minor)\n+    format!(\"{major}.{minor}\")\n }\n \n pub fn watchos_sim_llvm_target(arch: Arch) -> String {"}, {"sha": "ebd2cca25ea9a1be8117301a25795aa5006e6ddc", "filename": "compiler/rustc_target/src/spec/armv7_sony_vita_newlibeabihf.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_sony_vita_newlibeabihf.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -0,0 +1,40 @@\n+use crate::abi::Endian;\n+use crate::spec::{cvs, Cc, LinkerFlavor, Lld, PanicStrategy, RelocModel, Target, TargetOptions};\n+\n+/// A base target for PlayStation Vita devices using the VITASDK toolchain (using newlib).\n+///\n+/// Requires the VITASDK toolchain on the host system.\n+\n+pub fn target() -> Target {\n+    let pre_link_args = TargetOptions::link_args(LinkerFlavor::Gnu(Cc::Yes, Lld::No), &[\"-Wl,-q\"]);\n+\n+    Target {\n+        llvm_target: \"armv7a-vita-newlibeabihf\".into(),\n+        pointer_width: 32,\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".into(),\n+        arch: \"arm\".into(),\n+\n+        options: TargetOptions {\n+            os: \"vita\".into(),\n+            endian: Endian::Little,\n+            c_int_width: \"32\".into(),\n+            dynamic_linking: false,\n+            env: \"newlib\".into(),\n+            vendor: \"sony\".into(),\n+            abi: \"eabihf\".into(),\n+            linker_flavor: LinkerFlavor::Gnu(Cc::Yes, Lld::No),\n+            no_default_libraries: false,\n+            cpu: \"cortex-a9\".into(),\n+            executables: true,\n+            families: cvs![\"unix\"],\n+            linker: Some(\"arm-vita-eabi-gcc\".into()),\n+            relocation_model: RelocModel::Static,\n+            features: \"+v7,+neon\".into(),\n+            pre_link_args,\n+            exe_suffix: \".elf\".into(),\n+            panic_strategy: PanicStrategy::Abort,\n+            max_atomic_width: Some(32),\n+            ..Default::default()\n+        },\n+    }\n+}"}, {"sha": "0fafa52a45b66aa155323f8835b23f7031adf75f", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -840,7 +840,7 @@ impl fmt::Display for SanitizerSet {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut first = true;\n         for s in *self {\n-            let name = s.as_str().unwrap_or_else(|| panic!(\"unrecognized sanitizer {:?}\", s));\n+            let name = s.as_str().unwrap_or_else(|| panic!(\"unrecognized sanitizer {s:?}\"));\n             if !first {\n                 f.write_str(\", \")?;\n             }\n@@ -1109,8 +1109,8 @@ supported_targets! {\n     (\"x86_64-apple-darwin\", x86_64_apple_darwin),\n     (\"i686-apple-darwin\", i686_apple_darwin),\n \n-    (\"aarch64-fuchsia\", aarch64_fuchsia),\n-    (\"x86_64-fuchsia\", x86_64_fuchsia),\n+    (\"aarch64-unknown-fuchsia\", aarch64_unknown_fuchsia),\n+    (\"x86_64-unknown-fuchsia\", x86_64_unknown_fuchsia),\n \n     (\"avr-unknown-gnu-atmega328\", avr_unknown_gnu_atmega328),\n \n@@ -1241,6 +1241,8 @@ supported_targets! {\n \n     (\"aarch64-nintendo-switch-freestanding\", aarch64_nintendo_switch_freestanding),\n \n+    (\"armv7-sony-vita-newlibeabihf\", armv7_sony_vita_newlibeabihf),\n+\n     (\"armv7-unknown-linux-uclibceabi\", armv7_unknown_linux_uclibceabi),\n     (\"armv7-unknown-linux-uclibceabihf\", armv7_unknown_linux_uclibceabihf),\n \n@@ -2072,7 +2074,7 @@ impl Target {\n         let mut get_req_field = |name: &str| {\n             obj.remove(name)\n                 .and_then(|j| j.as_str().map(str::to_string))\n-                .ok_or_else(|| format!(\"Field {} in target specification is required\", name))\n+                .ok_or_else(|| format!(\"Field {name} in target specification is required\"))\n         };\n \n         let mut base = Target {\n@@ -2478,7 +2480,7 @@ impl Target {\n             if let Some(s) = fp.as_str() {\n                 base.frame_pointer = s\n                     .parse()\n-                    .map_err(|()| format!(\"'{}' is not a valid value for frame-pointer\", s))?;\n+                    .map_err(|()| format!(\"'{s}' is not a valid value for frame-pointer\"))?;\n             } else {\n                 incorrect_type.push(\"frame-pointer\".into())\n             }\n@@ -2670,7 +2672,7 @@ impl Target {\n                     return load_file(&p);\n                 }\n \n-                Err(format!(\"Could not find specification for target {:?}\", target_triple))\n+                Err(format!(\"Could not find specification for target {target_triple:?}\"))\n             }\n             TargetTriple::TargetJson { ref contents, .. } => {\n                 let obj = serde_json::from_str(contents).map_err(|e| e.to_string())?;\n@@ -2934,7 +2936,7 @@ impl TargetTriple {\n         let contents = std::fs::read_to_string(&canonicalized_path).map_err(|err| {\n             io::Error::new(\n                 io::ErrorKind::InvalidInput,\n-                format!(\"target path {:?} is not a valid file: {}\", canonicalized_path, err),\n+                format!(\"target path {canonicalized_path:?} is not a valid file: {err}\"),\n             )\n         })?;\n         let triple = canonicalized_path\n@@ -2969,7 +2971,7 @@ impl TargetTriple {\n                 let mut hasher = DefaultHasher::new();\n                 content.hash(&mut hasher);\n                 let hash = hasher.finish();\n-                format!(\"{}-{}\", triple, hash)\n+                format!(\"{triple}-{hash}\")\n             }\n         }\n     }"}, {"sha": "eaf72b7616c7160ee6d01ec9fd52e27c34e475e7", "filename": "compiler/rustc_target/src/spec/solid_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsolid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsolid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsolid_base.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -3,7 +3,7 @@ use crate::spec::TargetOptions;\n \n pub fn opts(kernel: &str) -> TargetOptions {\n     TargetOptions {\n-        os: format!(\"solid_{}\", kernel).into(),\n+        os: format!(\"solid_{kernel}\").into(),\n         vendor: \"kmc\".into(),\n         executables: false,\n         frame_pointer: FramePointer::NonLeaf,"}, {"sha": "a3231d19f4c7253a5c16749e2ac653223317a6d3", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_fuchsia.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_fuchsia.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -8,7 +8,7 @@ pub fn target() -> Target {\n     base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::CFI;\n \n     Target {\n-        llvm_target: \"x86_64-fuchsia\".into(),\n+        llvm_target: \"x86_64-unknown-fuchsia\".into(),\n         pointer_width: 64,\n         data_layout: \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .into(),", "previous_filename": "compiler/rustc_target/src/spec/x86_64_fuchsia.rs"}, {"sha": "fdd6adb681be4cba1aa43187d323db65e864b3b4", "filename": "compiler/rustc_trait_selection/src/solve/overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -36,7 +36,7 @@ impl OverflowData {\n \n     #[inline]\n     pub(super) fn has_overflow(&self, depth: usize) -> bool {\n-        self.current_limit.value_within_limit(depth + self.additional_depth)\n+        !self.current_limit.value_within_limit(depth + self.additional_depth)\n     }\n \n     /// Updating the current limit when hitting overflow."}, {"sha": "bc6d9d4b922d87c27a6dd159416157aadae0dd64", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -3,6 +3,7 @@ use std::fmt::Debug;\n \n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n+use crate::solve::FulfillmentCtxt as NextFulfillmentCtxt;\n use crate::traits::NormalizeExt;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -20,6 +21,7 @@ use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::config::TraitSolver;\n use rustc_span::Span;\n \n pub trait TraitEngineExt<'tcx> {\n@@ -29,18 +31,18 @@ pub trait TraitEngineExt<'tcx> {\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        if tcx.sess.opts.unstable_opts.chalk {\n-            Box::new(ChalkFulfillmentContext::new())\n-        } else {\n-            Box::new(FulfillmentContext::new())\n+        match tcx.sess.opts.unstable_opts.trait_solver {\n+            TraitSolver::Classic => Box::new(FulfillmentContext::new()),\n+            TraitSolver::Chalk => Box::new(ChalkFulfillmentContext::new()),\n+            TraitSolver::Next => Box::new(NextFulfillmentCtxt::new()),\n         }\n     }\n \n     fn new_in_snapshot(tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        if tcx.sess.opts.unstable_opts.chalk {\n-            Box::new(ChalkFulfillmentContext::new_in_snapshot())\n-        } else {\n-            Box::new(FulfillmentContext::new_in_snapshot())\n+        match tcx.sess.opts.unstable_opts.trait_solver {\n+            TraitSolver::Classic => Box::new(FulfillmentContext::new_in_snapshot()),\n+            TraitSolver::Chalk => Box::new(ChalkFulfillmentContext::new_in_snapshot()),\n+            TraitSolver::Next => Box::new(NextFulfillmentCtxt::new()),\n         }\n     }\n }"}, {"sha": "9c098e1a2fc12b6beaee3ce595e38a714b367a41", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -33,13 +33,14 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n-use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n     self, SubtypePredicate, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n     TypeVisitable,\n };\n+use rustc_session::config::TraitSolver;\n use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::symbol::sym;\n@@ -770,7 +771,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 ),\n                             }\n                         };\n-\n+                        self.check_for_binding_assigned_block_without_tail_expression(\n+                            &obligation,\n+                            &mut err,\n+                            trait_predicate,\n+                        );\n                         if self.suggest_add_reference_to_arg(\n                             &obligation,\n                             &mut err,\n@@ -868,6 +873,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n+                        if self.suggest_add_clone_to_arg(&obligation, &mut err, trait_predicate) {\n+                            err.emit();\n+                            return;\n+                        }\n+\n                         if self.suggest_impl_trait(&mut err, span, &obligation, trait_predicate) {\n                             err.emit();\n                             return;\n@@ -1167,7 +1177,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n \n                     ty::PredicateKind::WellFormed(ty) => {\n-                        if !self.tcx.sess.opts.unstable_opts.chalk {\n+                        if self.tcx.sess.opts.unstable_opts.trait_solver == TraitSolver::Classic {\n                             // WF predicates cannot themselves make\n                             // errors. They can only block due to\n                             // ambiguity; otherwise, they always\n@@ -1179,7 +1189,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             // which bounds actually failed to hold.\n                             self.tcx.sess.struct_span_err(\n                                 span,\n-                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n+                                &format!(\"the type `{}` is not well-formed\", ty),\n                             )\n                         }\n                     }\n@@ -1215,6 +1225,25 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n \n+            OutputTypeParameterMismatch(\n+                found_trait_ref,\n+                expected_trait_ref,\n+                terr @ TypeError::CyclicTy(_),\n+            ) => {\n+                let self_ty = found_trait_ref.self_ty().skip_binder();\n+                let (cause, terr) = if let ty::Closure(def_id, _) = self_ty.kind() {\n+                    (\n+                        ObligationCause::dummy_with_span(tcx.def_span(def_id)),\n+                        TypeError::CyclicTy(self_ty),\n+                    )\n+                } else {\n+                    (obligation.cause.clone(), terr)\n+                };\n+                self.report_and_explain_type_error(\n+                    TypeTrace::poly_trait_refs(&cause, true, expected_trait_ref, found_trait_ref),\n+                    terr,\n+                )\n+            }\n             OutputTypeParameterMismatch(found_trait_ref, expected_trait_ref, _) => {\n                 let found_trait_ref = self.resolve_vars_if_possible(found_trait_ref);\n                 let expected_trait_ref = self.resolve_vars_if_possible(expected_trait_ref);\n@@ -1387,7 +1416,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         self.note_obligation_cause(&mut err, &obligation);\n         self.point_at_returns_when_relevant(&mut err, &obligation);\n-\n         err.emit();\n     }\n }\n@@ -2247,23 +2275,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let (Some(body_id), Some(ty::subst::GenericArgKind::Type(_))) =\n                     (body_id, subst.map(|subst| subst.unpack()))\n                 {\n-                    struct FindExprBySpan<'hir> {\n-                        span: Span,\n-                        result: Option<&'hir hir::Expr<'hir>>,\n-                    }\n-\n-                    impl<'v> hir::intravisit::Visitor<'v> for FindExprBySpan<'v> {\n-                        fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-                            if self.span == ex.span {\n-                                self.result = Some(ex);\n-                            } else {\n-                                hir::intravisit::walk_expr(self, ex);\n-                            }\n-                        }\n-                    }\n-\n-                    let mut expr_finder = FindExprBySpan { span, result: None };\n-\n+                    let mut expr_finder = FindExprBySpan::new(span);\n                     expr_finder.visit_expr(&self.tcx.hir().body(body_id).value);\n \n                     if let Some(hir::Expr {\n@@ -2750,6 +2762,36 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n }\n \n+/// Crude way of getting back an `Expr` from a `Span`.\n+pub struct FindExprBySpan<'hir> {\n+    pub span: Span,\n+    pub result: Option<&'hir hir::Expr<'hir>>,\n+    pub ty_result: Option<&'hir hir::Ty<'hir>>,\n+}\n+\n+impl<'hir> FindExprBySpan<'hir> {\n+    fn new(span: Span) -> Self {\n+        Self { span, result: None, ty_result: None }\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for FindExprBySpan<'v> {\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        if self.span == ex.span {\n+            self.result = Some(ex);\n+        } else {\n+            hir::intravisit::walk_expr(self, ex);\n+        }\n+    }\n+    fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n+        if self.span == ty.span {\n+            self.ty_result = Some(ty);\n+        } else {\n+            hir::intravisit::walk_ty(self, ty);\n+        }\n+    }\n+}\n+\n /// Look for type `param` in an ADT being used only through a reference to confirm that suggesting\n /// `param: ?Sized` would be a valid constraint.\n struct FindTypeParam {"}, {"sha": "b0a730c8ad16865d3b6f7c8a12dd688edf42ed85", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 Some(if movability.is_some() { \"an async closure\" } else { \"a closure\" })\n             }),\n             hir::Node::Expr(hir::Expr { .. }) => {\n-                let parent_hid = hir.get_parent_node(hir_id);\n+                let parent_hid = hir.parent_id(hir_id);\n                 if parent_hid != hir_id { self.describe_enclosure(parent_hid) } else { None }\n             }\n             _ => None,"}, {"sha": "c52365ae3b7c7309cc90bd44db5de64e07573482", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 149, "deletions": 17, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,13 +1,16 @@\n // ignore-tidy-filelength\n \n-use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation};\n+use super::{\n+    DefIdOrName, FindExprBySpan, Obligation, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n+};\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n use crate::traits::{NormalizeExt, ObligationCtxt};\n \n use hir::def::CtorOf;\n-use hir::HirId;\n+use hir::{Expr, HirId};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{\n@@ -196,6 +199,20 @@ pub trait TypeErrCtxtExt<'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    );\n+\n+    fn suggest_add_clone_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    ) -> bool;\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -248,7 +265,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut Diagnostic,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n@@ -838,8 +855,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         let hir = self.tcx.hir();\n         let hir_id = hir.local_def_id_to_hir_id(def_id.as_local()?);\n-        let parent_node = hir.get_parent_node(hir_id);\n-        match hir.find(parent_node) {\n+        match hir.find_parent(hir_id) {\n             Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n                 get_name(err, &local.pat.kind)\n             }\n@@ -1033,6 +1049,115 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         true\n     }\n \n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    ) {\n+        let mut span = obligation.cause.span;\n+        while span.from_expansion() {\n+            // Remove all the desugaring and macro contexts.\n+            span.remove_mark();\n+        }\n+        let mut expr_finder = FindExprBySpan::new(span);\n+        let Some(hir::Node::Expr(body)) = self.tcx.hir().find(obligation.cause.body_id) else { return; };\n+        expr_finder.visit_expr(&body);\n+        let Some(expr) = expr_finder.result else { return; };\n+        let Some(typeck) = &self.typeck_results else { return; };\n+        let Some(ty) = typeck.expr_ty_adjusted_opt(expr) else { return; };\n+        if !ty.is_unit() {\n+            return;\n+        };\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind else { return; };\n+        let hir::def::Res::Local(hir_id) = path.res else { return; };\n+        let Some(hir::Node::Pat(pat)) = self.tcx.hir().find(hir_id) else {\n+            return;\n+        };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = self.tcx.hir().find_parent(pat.hir_id) else { return; };\n+        let hir::ExprKind::Block(block, None) = init.kind else { return; };\n+        if block.expr.is_some() {\n+            return;\n+        }\n+        let [.., stmt] = block.stmts else {\n+            err.span_label(block.span, \"this empty block is missing a tail expression\");\n+            return;\n+        };\n+        let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n+        let Some(ty) = typeck.expr_ty_opt(tail_expr) else {\n+            err.span_label(block.span, \"this block is missing a tail expression\");\n+            return;\n+        };\n+        let ty = self.resolve_numeric_literals_with_default(self.resolve_vars_if_possible(ty));\n+        let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, ty));\n+\n+        let new_obligation =\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred_and_self);\n+        if self.predicate_must_hold_modulo_regions(&new_obligation) {\n+            err.span_suggestion_short(\n+                stmt.span.with_lo(tail_expr.span.hi()),\n+                \"remove this semicolon\",\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            err.span_label(block.span, \"this block is missing a tail expression\");\n+        }\n+    }\n+\n+    fn suggest_add_clone_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    ) -> bool {\n+        let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n+        let ty = self.tcx.erase_late_bound_regions(self_ty);\n+        let owner = self.tcx.hir().get_parent_item(obligation.cause.body_id);\n+        let Some(generics) = self.tcx.hir().get_generics(owner.def_id) else { return false };\n+        let ty::Ref(_, inner_ty, hir::Mutability::Not) = ty.kind() else { return false };\n+        let ty::Param(param) = inner_ty.kind() else { return false };\n+        let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code() else { return false };\n+        let arg_node = self.tcx.hir().get(*arg_hir_id);\n+        let Node::Expr(Expr { kind: hir::ExprKind::Path(_), ..}) = arg_node else { return false };\n+\n+        let clone_trait = self.tcx.require_lang_item(LangItem::Clone, None);\n+        let has_clone = |ty| {\n+            self.type_implements_trait(clone_trait, [ty], obligation.param_env)\n+                .must_apply_modulo_regions()\n+        };\n+\n+        let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n+            obligation.param_env,\n+            trait_pred.map_bound(|trait_pred| (trait_pred, *inner_ty)),\n+        );\n+\n+        if self.predicate_may_hold(&new_obligation) && has_clone(ty) {\n+            if !has_clone(param.to_ty(self.tcx)) {\n+                suggest_constraining_type_param(\n+                    self.tcx,\n+                    generics,\n+                    err,\n+                    param.name.as_str(),\n+                    \"Clone\",\n+                    Some(clone_trait),\n+                );\n+            }\n+            err.span_suggestion_verbose(\n+                obligation.cause.span.shrink_to_hi(),\n+                \"consider using clone here\",\n+                \".clone()\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            return true;\n+        }\n+        false\n+    }\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1421,7 +1546,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let parent_node = hir.parent_id(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n         if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. })) = node\n             && let hir::ExprKind::Block(blk, _) = &hir.body(*body_id).value.kind\n@@ -1458,7 +1583,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span> {\n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let parent_node = hir.parent_id(obligation.cause.body_id);\n         let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, ..), .. })) = hir.find(parent_node) else {\n             return None;\n         };\n@@ -1483,7 +1608,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-        let fn_hir_id = hir.get_parent_node(obligation.cause.body_id);\n+        let fn_hir_id = hir.parent_id(obligation.cause.body_id);\n         let node = hir.find(fn_hir_id);\n         let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(sig, _, body_id),\n@@ -1686,7 +1811,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n     fn point_at_returns_when_relevant(\n         &self,\n-        err: &mut Diagnostic,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         match obligation.cause.code().peel_derives() {\n@@ -1695,7 +1820,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let parent_node = hir.parent_id(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n         if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) =\n             node\n@@ -1708,7 +1833,15 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             for expr in &visitor.returns {\n                 if let Some(returned_ty) = typeck_results.node_type_opt(expr.hir_id) {\n                     let ty = self.resolve_vars_if_possible(returned_ty);\n-                    err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n+                    if ty.references_error() {\n+                        // don't print out the [type error] here\n+                        err.delay_as_bug();\n+                    } else {\n+                        err.span_label(\n+                            expr.span,\n+                            &format!(\"this returned value is of type `{}`\", ty),\n+                        );\n+                    }\n                 }\n             }\n         }\n@@ -2291,7 +2424,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         let expr = hir.expect_expr(expr_id);\n                         debug!(\"target_ty evaluated from {:?}\", expr);\n \n-                        let parent = hir.get_parent_node(expr_id);\n+                        let parent = hir.parent_id(expr_id);\n                         if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n                             let parent_span = hir.span(parent);\n                             let parent_did = parent.owner.to_def_id();\n@@ -2512,7 +2645,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::VariableType(hir_id) => {\n-                let parent_node = self.tcx.hir().get_parent_node(hir_id);\n+                let parent_node = self.tcx.hir().parent_id(hir_id);\n                 match self.tcx.hir().find(parent_node) {\n                     Some(Node::Local(hir::Local { ty: Some(ty), .. })) => {\n                         err.span_suggestion_verbose(\n@@ -2992,7 +3125,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         span: Span,\n     ) {\n         let body_hir_id = obligation.cause.body_id;\n-        let item_id = self.tcx.hir().get_parent_node(body_hir_id);\n+        let item_id = self.tcx.hir().parent_id(body_hir_id);\n \n         if let Some(body_id) =\n             self.tcx.hir().maybe_body_owned_by(self.tcx.hir().local_def_id(item_id))\n@@ -3219,7 +3352,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n                 && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n                 && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n-                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                && let parent_hir_id = self.tcx.hir().parent_id(binding.hir_id)\n                 && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n                 && let Some(binding_expr) = local.init\n             {\n@@ -3287,8 +3420,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n                 && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n                 && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n-                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n-                && let Some(parent) = self.tcx.hir().find(parent_hir_id)\n+                && let Some(parent) = self.tcx.hir().find_parent(binding.hir_id)\n             {\n                 // We've reached the root of the method call chain...\n                 if let hir::Node::Local(local) = parent"}, {"sha": "15526b34ed2d851a6f357b67e220e281b23cf52d", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::{\n     self, Binder, GenericArg, GenericArgKind, GenericParamDefKind, InternalSubsts, SubstsRef,\n     ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt,\n };\n+use rustc_session::config::TraitSolver;\n use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n@@ -767,8 +768,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?closure_def_id, ?trait_ref, ?nested, \"confirm closure candidate obligations\");\n \n         // FIXME: Chalk\n-\n-        if !self.tcx().sess.opts.unstable_opts.chalk {\n+        if self.tcx().sess.opts.unstable_opts.trait_solver != TraitSolver::Chalk {\n             nested.push(obligation.with(\n                 self.tcx(),\n                 ty::Binder::dummy(ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)),"}, {"sha": "3f14491f8032ffa069742c9b506c72feb58e3891", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -755,7 +755,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // contain the \"'static\" lifetime (any other lifetime\n                     // would either be late-bound or local), so it is guaranteed\n                     // to outlive any other lifetime\n-                    if pred.0.is_global() && !pred.0.has_late_bound_regions() {\n+                    if pred.0.is_global() && !pred.0.has_late_bound_vars() {\n                         Ok(EvaluatedToOk)\n                     } else {\n                         Ok(EvaluatedToOkModuloRegions)\n@@ -1785,9 +1785,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Check if a bound would previously have been removed when normalizing\n         // the param_env so that it can be given the lowest priority. See\n         // #50825 for the motivation for this.\n-        let is_global = |cand: &ty::PolyTraitPredicate<'tcx>| {\n-            cand.is_global() && !cand.has_late_bound_regions()\n-        };\n+        let is_global =\n+            |cand: &ty::PolyTraitPredicate<'tcx>| cand.is_global() && !cand.has_late_bound_vars();\n \n         // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,\n         // `DiscriminantKindCandidate`, `ConstDestructCandidate`"}, {"sha": "481b56e111ea0a6d74099f0017f166fa7e5afad2", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -189,7 +189,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n \n                 tcx.sess.delay_span_bug(\n                     span,\n-                    &format!(\"upvar_tys for closure not found. Expected capture information for closure {}\", ty,),\n+                    &format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n                 );\n                 return Err(NoSolution);\n             }\n@@ -231,7 +231,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n                 // be fully resolved.\n                 tcx.sess.delay_span_bug(\n                     span,\n-                    &format!(\"upvar_tys for generator not found. Expected capture information for generator {}\", ty,),\n+                    &format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n                 );\n                 return Err(NoSolution);\n             }"}, {"sha": "5cad2c2ccb0f7f562f2ebd5efd43c3767736ee79", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -47,7 +47,7 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n             // us a test case.\n             debug_assert_eq!(normalized_value, resolved_value);\n             let erased = infcx.tcx.erase_regions(resolved_value);\n-            debug_assert!(!erased.needs_infer(), \"{:?}\", erased);\n+            debug_assert!(!erased.needs_infer(), \"{erased:?}\");\n             Ok(erased)\n         }\n         Err(NoSolution) => Err(NoSolution),"}, {"sha": "f8d05bc89d26d1f96f826c1e3d3b838392e422e0", "filename": "compiler/rustc_transmute/src/layout/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -24,7 +24,7 @@ impl fmt::Debug for Byte {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match &self {\n             Self::Uninit => f.write_str(\"??u8\"),\n-            Self::Init(b) => write!(f, \"{:#04x}u8\", b),\n+            Self::Init(b) => write!(f, \"{b:#04x}u8\"),\n         }\n     }\n }"}, {"sha": "f8a5691f29de0b0626d207779af0c2ccd997ee47", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -256,22 +256,21 @@ fn adjust_for_rust_scalar<'tcx>(\n             // See https://github.com/rust-lang/unsafe-code-guidelines/issues/326\n             let noalias_for_box = cx.tcx.sess.opts.unstable_opts.box_noalias.unwrap_or(true);\n \n+            // LLVM prior to version 12 had known miscompiles in the presence of noalias attributes\n+            // (see #54878), so it was conditionally disabled, but we don't support earlier\n+            // versions at all anymore. We still support turning it off using -Zmutable-noalias.\n+            let noalias_mut_ref = cx.tcx.sess.opts.unstable_opts.mutable_noalias.unwrap_or(true);\n+\n             // `&mut` pointer parameters never alias other parameters,\n             // or mutable global data\n             //\n             // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n             // and can be marked as both `readonly` and `noalias`, as\n             // LLVM's definition of `noalias` is based solely on memory\n             // dependencies rather than pointer equality\n-            //\n-            // Due to past miscompiles in LLVM, we apply a separate NoAliasMutRef attribute\n-            // for UniqueBorrowed arguments, so that the codegen backend can decide whether\n-            // or not to actually emit the attribute. It can also be controlled with the\n-            // `-Zmutable-noalias` debugging option.\n             let no_alias = match kind {\n-                PointerKind::SharedMutable\n-                | PointerKind::UniqueBorrowed\n-                | PointerKind::UniqueBorrowedPinned => false,\n+                PointerKind::SharedMutable | PointerKind::UniqueBorrowedPinned => false,\n+                PointerKind::UniqueBorrowed => noalias_mut_ref,\n                 PointerKind::UniqueOwned => noalias_for_box,\n                 PointerKind::Frozen => true,\n             };\n@@ -284,10 +283,6 @@ fn adjust_for_rust_scalar<'tcx>(\n             if kind == PointerKind::Frozen && !is_return {\n                 attrs.set(ArgAttribute::ReadOnly);\n             }\n-\n-            if kind == PointerKind::UniqueBorrowed && !is_return {\n-                attrs.set(ArgAttribute::NoAliasMutRef);\n-            }\n         }\n     }\n }"}, {"sha": "6aa016133ca598926fffa1b2823962b11332da92", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -155,17 +155,37 @@ fn layout_of_uncached<'tcx>(\n             }\n \n             let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n-            let metadata = match unsized_part.kind() {\n-                ty::Foreign(..) => {\n+\n+            let metadata = if let Some(metadata_def_id) = tcx.lang_items().metadata_type() {\n+                let metadata_ty = tcx.normalize_erasing_regions(\n+                    param_env,\n+                    tcx.mk_projection(metadata_def_id, [pointee]),\n+                );\n+                let metadata_layout = cx.layout_of(metadata_ty)?;\n+                // If the metadata is a 1-zst, then the pointer is thin.\n+                if metadata_layout.is_zst() && metadata_layout.align.abi.bytes() == 1 {\n                     return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n                 }\n-                ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n-                ty::Dynamic(..) => {\n-                    let mut vtable = scalar_unit(Pointer);\n-                    vtable.valid_range_mut().start = 1;\n-                    vtable\n+\n+                let Abi::Scalar(metadata) = metadata_layout.abi else {\n+                    return Err(LayoutError::Unknown(unsized_part));\n+                };\n+                metadata\n+            } else {\n+                match unsized_part.kind() {\n+                    ty::Foreign(..) => {\n+                        return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n+                    }\n+                    ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n+                    ty::Dynamic(..) => {\n+                        let mut vtable = scalar_unit(Pointer);\n+                        vtable.valid_range_mut().start = 1;\n+                        vtable\n+                    }\n+                    _ => {\n+                        return Err(LayoutError::Unknown(unsized_part));\n+                    }\n                 }\n-                _ => return Err(LayoutError::Unknown(unsized_part)),\n             };\n \n             // Effectively a (ptr, meta) tuple."}, {"sha": "87923ebbe4bc948502d1fefca6a13935867bf864", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2,6 +2,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt};\n+use rustc_session::config::TraitSolver;\n use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n@@ -121,7 +122,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // are any errors at that point, so outside of type inference you can be\n     // sure that this will succeed without errors anyway.\n \n-    if tcx.sess.opts.unstable_opts.chalk {\n+    if tcx.sess.opts.unstable_opts.trait_solver == TraitSolver::Chalk {\n         let environment = well_formed_types_in_env(tcx, def_id);\n         predicates.extend(environment);\n     }\n@@ -161,7 +162,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n                 kind: hir::ImplItemKind::Type(..) | hir::ImplItemKind::Fn(..),\n                 ..\n             }) => {\n-                let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n+                let parent_hir_id = tcx.hir().parent_id(hir_id);\n                 match tcx.hir().get(parent_hir_id) {\n                     hir::Node::Item(hir::Item {\n                         kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),"}, {"sha": "44004cb0be1e9dbf9ae4c4e6b850a0fe677d894a", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -241,22 +241,30 @@ bitflags! {\n         /// Basically anything but `ReLateBound` and `ReErased`.\n         const HAS_FREE_REGIONS            = 1 << 14;\n \n-        /// Does this have any `ReLateBound` regions? Used to check\n-        /// if a global bound is safe to evaluate.\n+        /// Does this have any `ReLateBound` regions?\n         const HAS_RE_LATE_BOUND           = 1 << 15;\n+        /// Does this have any `Bound` types?\n+        const HAS_TY_LATE_BOUND           = 1 << 16;\n+        /// Does this have any `ConstKind::Bound` consts?\n+        const HAS_CT_LATE_BOUND           = 1 << 17;\n+        /// Does this have any bound variables?\n+        /// Used to check if a global bound is safe to evaluate.\n+        const HAS_LATE_BOUND              = TypeFlags::HAS_RE_LATE_BOUND.bits\n+                                          | TypeFlags::HAS_TY_LATE_BOUND.bits\n+                                          | TypeFlags::HAS_CT_LATE_BOUND.bits;\n \n         /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED               = 1 << 16;\n+        const HAS_RE_ERASED               = 1 << 18;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n+        const STILL_FURTHER_SPECIALIZABLE = 1 << 19;\n \n         /// Does this value have `InferTy::FreshTy/FreshIntTy/FreshFloatTy`?\n-        const HAS_TY_FRESH                = 1 << 18;\n+        const HAS_TY_FRESH                = 1 << 20;\n \n         /// Does this value have `InferConst::Fresh`?\n-        const HAS_CT_FRESH                = 1 << 19;\n+        const HAS_CT_FRESH                = 1 << 21;\n     }\n }\n \n@@ -718,9 +726,9 @@ impl fmt::Debug for InferTy {\n             TyVar(ref v) => v.fmt(f),\n             IntVar(ref v) => v.fmt(f),\n             FloatVar(ref v) => v.fmt(f),\n-            FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-            FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-            FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n+            FreshTy(v) => write!(f, \"FreshTy({v:?})\"),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({v:?})\"),\n+            FreshFloatTy(v) => write!(f, \"FreshFloatTy({v:?})\"),\n         }\n     }\n }\n@@ -743,9 +751,9 @@ impl fmt::Display for InferTy {\n             TyVar(_) => write!(f, \"_\"),\n             IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n             FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-            FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-            FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-            FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v),\n+            FreshTy(v) => write!(f, \"FreshTy({v})\"),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({v})\"),\n+            FreshFloatTy(v) => write!(f, \"FreshFloatTy({v})\"),\n         }\n     }\n }"}, {"sha": "b944cbd698d13598de404d3f6291718cb7259dfe", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1028,10 +1028,10 @@ impl<I: Interner> hash::Hash for RegionKind<I> {\n impl<I: Interner> fmt::Debug for RegionKind<I> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            ReEarlyBound(data) => write!(f, \"ReEarlyBound({:?})\", data),\n+            ReEarlyBound(data) => write!(f, \"ReEarlyBound({data:?})\"),\n \n             ReLateBound(binder_id, bound_region) => {\n-                write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n+                write!(f, \"ReLateBound({binder_id:?}, {bound_region:?})\")\n             }\n \n             ReFree(fr) => fr.fmt(f),\n@@ -1040,7 +1040,7 @@ impl<I: Interner> fmt::Debug for RegionKind<I> {\n \n             ReVar(vid) => vid.fmt(f),\n \n-            RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n+            RePlaceholder(placeholder) => write!(f, \"RePlaceholder({placeholder:?})\"),\n \n             ReErased => f.write_str(\"ReErased\"),\n         }"}, {"sha": "95c07abf73106647bc3a6c3f3909caff11cce0ed", "filename": "library/alloc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -13,8 +13,8 @@ core = { path = \"../core\" }\n compiler_builtins = { version = \"0.1.40\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n-rand = \"0.7\"\n-rand_xorshift = \"0.2\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\"alloc\"] }\n+rand_xorshift = \"0.3.0\"\n \n [[test]]\n name = \"collectionstests\""}, {"sha": "b62be9d39a1cd393a330deb7f3df688f6137d120", "filename": "library/alloc/benches/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fslice.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,6 +1,6 @@\n use std::{mem, ptr};\n \n-use rand::distributions::{Alphanumeric, Standard};\n+use rand::distributions::{Alphanumeric, DistString, Standard};\n use rand::Rng;\n use test::{black_box, Bencher};\n \n@@ -218,7 +218,7 @@ fn gen_strings(len: usize) -> Vec<String> {\n     let mut v = vec![];\n     for _ in 0..len {\n         let n = rng.gen::<usize>() % 20 + 1;\n-        v.push((&mut rng).sample_iter(&Alphanumeric).take(n).collect());\n+        v.push(Alphanumeric.sample_string(&mut rng, n));\n     }\n     v\n }"}, {"sha": "fe6de1cf879b2e2395173f1d4e5d3c80ea2a1fe9", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -402,7 +402,20 @@ pub mod __alloc_error_handler {\n     // `#[alloc_error_handler]`.\n     #[rustc_std_internal_symbol]\n     pub unsafe fn __rdl_oom(size: usize, _align: usize) -> ! {\n-        panic!(\"memory allocation of {size} bytes failed\")\n+        extern \"Rust\" {\n+            // This symbol is emitted by rustc next to __rust_alloc_error_handler.\n+            // Its value depends on the -Zoom={panic,abort} compiler option.\n+            static __rust_alloc_error_handler_should_panic: u8;\n+        }\n+\n+        #[allow(unused_unsafe)]\n+        if unsafe { __rust_alloc_error_handler_should_panic != 0 } {\n+            panic!(\"memory allocation of {size} bytes failed\")\n+        } else {\n+            core::panicking::panic_nounwind_fmt(format_args!(\n+                \"memory allocation of {size} bytes failed\"\n+            ))\n+        }\n     }\n }\n "}, {"sha": "c1a82e452f6c361d9c1d2cd900fd85bb2e5cb697", "filename": "library/alloc/src/boxed/thin.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -226,24 +226,45 @@ impl<H> WithHeader<H> {\n     // - Assumes that either `value` can be dereferenced, or is the\n     //   `NonNull::dangling()` we use when both `T` and `H` are ZSTs.\n     unsafe fn drop<T: ?Sized>(&self, value: *mut T) {\n+        struct DropGuard<H> {\n+            ptr: NonNull<u8>,\n+            value_layout: Layout,\n+            _marker: PhantomData<H>,\n+        }\n+\n+        impl<H> Drop for DropGuard<H> {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    // SAFETY: Layout must have been computable if we're in drop\n+                    let (layout, value_offset) =\n+                        WithHeader::<H>::alloc_layout(self.value_layout).unwrap_unchecked();\n+\n+                    // Note: Don't deallocate if the layout size is zero, because the pointer\n+                    // didn't come from the allocator.\n+                    if layout.size() != 0 {\n+                        alloc::dealloc(self.ptr.as_ptr().sub(value_offset), layout);\n+                    } else {\n+                        debug_assert!(\n+                            value_offset == 0\n+                                && mem::size_of::<H>() == 0\n+                                && self.value_layout.size() == 0\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n         unsafe {\n-            let value_layout = Layout::for_value_raw(value);\n-            // SAFETY: Layout must have been computable if we're in drop\n-            let (layout, value_offset) = Self::alloc_layout(value_layout).unwrap_unchecked();\n+            // `_guard` will deallocate the memory when dropped, even if `drop_in_place` unwinds.\n+            let _guard = DropGuard {\n+                ptr: self.0,\n+                value_layout: Layout::for_value_raw(value),\n+                _marker: PhantomData::<H>,\n+            };\n \n             // We only drop the value because the Pointee trait requires that the metadata is copy\n             // aka trivially droppable.\n             ptr::drop_in_place::<T>(value);\n-\n-            // Note: Don't deallocate if the layout size is zero, because the pointer\n-            // didn't come from the allocator.\n-            if layout.size() != 0 {\n-                alloc::dealloc(self.0.as_ptr().sub(value_offset), layout);\n-            } else {\n-                debug_assert!(\n-                    value_offset == 0 && mem::size_of::<H>() == 0 && value_layout.size() == 0\n-                );\n-            }\n         }\n     }\n "}, {"sha": "59c516374c0e2790d6c2357b6ed1566afa7c2344", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -465,7 +465,7 @@ fn test_retain() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn panic_safe() {\n-    use rand::{seq::SliceRandom, thread_rng};\n+    use rand::seq::SliceRandom;\n     use std::cmp;\n     use std::panic::{self, AssertUnwindSafe};\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -490,7 +490,7 @@ fn panic_safe() {\n             self.0.partial_cmp(&other.0)\n         }\n     }\n-    let mut rng = thread_rng();\n+    let mut rng = crate::test_helpers::test_rng();\n     const DATASZ: usize = 32;\n     // Miri is too slow\n     let ntest = if cfg!(miri) { 1 } else { 10 };"}, {"sha": "04594d55b6abf1834eea51ac3f19ee0e2039a123", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -5,7 +5,7 @@ use crate::vec::Vec;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::thread;\n \n-use rand::{thread_rng, RngCore};\n+use rand::RngCore;\n \n #[test]\n fn test_basic() {\n@@ -481,12 +481,12 @@ fn test_split_off_2() {\n     }\n }\n \n-fn fuzz_test(sz: i32) {\n+fn fuzz_test(sz: i32, rng: &mut impl RngCore) {\n     let mut m: LinkedList<_> = LinkedList::new();\n     let mut v = vec![];\n     for i in 0..sz {\n         check_links(&m);\n-        let r: u8 = thread_rng().next_u32() as u8;\n+        let r: u8 = rng.next_u32() as u8;\n         match r % 6 {\n             0 => {\n                 m.pop_back();\n@@ -521,11 +521,12 @@ fn fuzz_test(sz: i32) {\n \n #[test]\n fn test_fuzz() {\n+    let mut rng = crate::test_helpers::test_rng();\n     for _ in 0..25 {\n-        fuzz_test(3);\n-        fuzz_test(16);\n+        fuzz_test(3, &mut rng);\n+        fuzz_test(16, &mut rng);\n         #[cfg(not(miri))] // Miri is too slow\n-        fuzz_test(189);\n+        fuzz_test(189, &mut rng);\n     }\n }\n "}, {"sha": "451e4936bc50eb8c29b6580ea37e8bc641f25acd", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -636,6 +636,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n+    /// buf.push_back(6);\n     /// assert_eq!(buf.get(1), Some(&4));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -661,10 +662,11 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n+    /// buf.push_back(6);\n+    /// assert_eq!(buf[1], 4);\n     /// if let Some(elem) = buf.get_mut(1) {\n     ///     *elem = 7;\n     /// }\n-    ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2821,9 +2823,9 @@ impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// In its current implementation, this is a very cheap\n-    /// conversion. This isn't yet a guarantee though, and\n-    /// shouldn't be relied on.\n+    /// This conversion is guaranteed to run in *O*(1) time\n+    /// and to not re-allocate the `Vec`'s buffer or allocate\n+    /// any additional memory.\n     #[inline]\n     fn from(other: Vec<T, A>) -> Self {\n         let (ptr, len, cap, alloc) = other.into_raw_parts_with_alloc();"}, {"sha": "4e812529c2cc846d7934672a05202a0eb9db7218", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -110,6 +110,7 @@\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_refs_to_cell)]\n #![feature(core_intrinsics)]\n+#![feature(core_panic)]\n #![feature(const_eval_select)]\n #![feature(const_pin)]\n #![feature(const_waker)]\n@@ -191,6 +192,7 @@\n #![feature(unsized_fn_params)]\n #![feature(c_unwind)]\n #![feature(with_negative_coherence)]\n+#![cfg_attr(test, feature(panic_update_hook))]\n //\n // Rustdoc features:\n #![feature(doc_cfg)]\n@@ -254,3 +256,20 @@ pub mod vec;\n pub mod __export {\n     pub use core::format_args;\n }\n+\n+#[cfg(test)]\n+#[allow(dead_code)] // Not used in all configurations\n+pub(crate) mod test_helpers {\n+    /// Copied from `std::test_helpers::test_rng`, since these tests rely on the\n+    /// seed not being the same for every RNG invocation too.\n+    pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+        use std::hash::{BuildHasher, Hash, Hasher};\n+        let mut hasher = std::collections::hash_map::RandomState::new().build_hasher();\n+        std::panic::Location::caller().hash(&mut hasher);\n+        let hc64 = hasher.finish();\n+        let seed_vec =\n+            hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<crate::vec::Vec<u8>>();\n+        let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+}"}, {"sha": "c1d853ed652160149e6911c5577e8cc93891f1a9", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2561,7 +2561,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n-impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n+impl<T: ?Sized> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }"}, {"sha": "e9886fc5717990ec4a93feafa5901aa4235ca9fd", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -28,6 +28,9 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[unstable(feature = \"slice_range\", issue = \"76393\")]\n pub use core::slice::range;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]"}, {"sha": "f674530aaa54c1934518243a1726ac0fd794598b", "filename": "library/alloc/src/slice/tests.rs", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fslice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fslice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -0,0 +1,359 @@\n+use crate::borrow::ToOwned;\n+use crate::rc::Rc;\n+use crate::string::ToString;\n+use crate::test_helpers::test_rng;\n+use crate::vec::Vec;\n+\n+use core::cell::Cell;\n+use core::cmp::Ordering::{self, Equal, Greater, Less};\n+use core::convert::identity;\n+use core::fmt;\n+use core::mem;\n+use core::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+use rand::{distributions::Standard, prelude::*, Rng, RngCore};\n+use std::panic;\n+\n+macro_rules! do_test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| {\n+            count += 1;\n+            a.cmp(b)\n+        });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n+\n+            let v = $input.to_owned();\n+            let _ = std::panic::catch_unwind(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            });\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e., the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1, \"found drop count == {} for i == {}, len == {}\", count, i, len);\n+            }\n+\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n+        }\n+    };\n+}\n+\n+const MAX_LEN: usize = 80;\n+\n+static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n+    // FIXME(RFC 1109): AtomicUsize is not Copy.\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+    AtomicUsize::new(0),\n+];\n+\n+static VERSIONS: AtomicUsize = AtomicUsize::new(0);\n+\n+#[derive(Clone, Eq)]\n+struct DropCounter {\n+    x: u32,\n+    id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n+}\n+\n+impl Drop for DropCounter {\n+    fn drop(&mut self) {\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n+    }\n+}\n+\n+std::thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n+fn panic_safe() {\n+    panic::update_hook(move |prev, info| {\n+        if !SILENCE_PANIC.with(|s| s.get()) {\n+            prev(info);\n+        }\n+    });\n+\n+    let mut rng = test_rng();\n+\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (1..10).chain(0..0) } else { (1..20).chain(70..MAX_LEN) };\n+    let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n+\n+    for len in lens {\n+        for &modulus in moduli {\n+            for &has_runs in &[false, true] {\n+                let mut input = (0..len)\n+                    .map(|id| DropCounter {\n+                        x: rng.next_u32() % modulus,\n+                        id: id,\n+                        version: Cell::new(0),\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n+                }\n+\n+                do_test!(input, sort_by);\n+                do_test!(input, sort_unstable_by);\n+            }\n+        }\n+    }\n+\n+    // Set default panic hook again.\n+    drop(panic::take_hook());\n+}\n+\n+#[test]\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n+fn test_sort() {\n+    let mut rng = test_rng();\n+\n+    for len in (2..25).chain(500..510) {\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..10 {\n+                let orig: Vec<_> = (&mut rng)\n+                    .sample_iter::<i32, _>(&Standard)\n+                    .map(|x| x % modulus)\n+                    .take(len)\n+                    .collect();\n+\n+                // Sort in default order.\n+                let mut v = orig.clone();\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| a.cmp(b));\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| b.cmp(a));\n+                assert!(v.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Sort in lexicographic order.\n+                let mut v1 = orig.clone();\n+                let mut v2 = orig.clone();\n+                v1.sort_by_key(|x| x.to_string());\n+                v2.sort_by_cached_key(|x| x.to_string());\n+                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n+                assert!(v1 == v2);\n+\n+                // Sort with many pre-sorted runs.\n+                let mut v = orig.clone();\n+                v.sort();\n+                v.reverse();\n+                for _ in 0..5 {\n+                    let a = rng.gen::<usize>() % len;\n+                    let b = rng.gen::<usize>() % len;\n+                    if a < b {\n+                        v[a..b].reverse();\n+                    } else {\n+                        v.swap(a, b);\n+                    }\n+                }\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n+        }\n+    }\n+\n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    let mut v = [0; 500];\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_by(|_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n+    v.sort();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n+    // Should not panic.\n+    [0i32; 0].sort();\n+    [(); 10].sort();\n+    [(); 100].sort();\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.sort();\n+    assert!(v == [0xDEADBEEF]);\n+}\n+\n+#[test]\n+fn test_sort_stability() {\n+    // Miri is too slow\n+    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    let rounds = if cfg!(miri) { 1 } else { 10 };\n+\n+    let mut rng = test_rng();\n+    for len in (2..25).chain(large_range) {\n+        for _ in 0..rounds {\n+            let mut counts = [0; 10];\n+\n+            // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n+            // where the first item of each tuple is random, but\n+            // the second item represents which occurrence of that\n+            // number this element is, i.e., the second elements\n+            // will occur in sorted order.\n+            let orig: Vec<_> = (0..len)\n+                .map(|_| {\n+                    let n = rng.gen::<usize>() % 10;\n+                    counts[n] += 1;\n+                    (n, counts[n])\n+                })\n+                .collect();\n+\n+            let mut v = orig.clone();\n+            // Only sort on the first element, so an unstable sort\n+            // may mix up the counts.\n+            v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n+\n+            // This comparison includes the count (the second item\n+            // of the tuple), so elements with equal first items\n+            // will need to be ordered with increasing\n+            // counts... i.e., exactly asserting that this sort is\n+            // stable.\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+            let mut v = orig.clone();\n+            v.sort_by_cached_key(|&(x, _)| x);\n+            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+        }\n+    }\n+}"}, {"sha": "d833d4d1dfbd327a5f53b606498e5e717cbcae69", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -312,7 +312,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Weak<U>> for Weak<T> {}\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n+impl<T: ?Sized> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }"}, {"sha": "36cfac8ee9e17da0dde403e785c0a09efd324898", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -490,6 +490,8 @@ impl<T> Vec<T> {\n     /// This is highly unsafe, due to the number of invariants that aren't\n     /// checked:\n     ///\n+    /// * `ptr` must have been allocated using the global allocator, such as via\n+    ///   the [`alloc::alloc`] function.\n     /// * `T` needs to have the same alignment as what `ptr` was allocated with.\n     ///   (`T` having a less strict alignment is not sufficient, the alignment really\n     ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n@@ -526,6 +528,7 @@ impl<T> Vec<T> {\n     /// function.\n     ///\n     /// [`String`]: crate::string::String\n+    /// [`alloc::alloc`]: crate::alloc::alloc\n     /// [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n     ///\n     /// # Examples\n@@ -681,6 +684,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// This is highly unsafe, due to the number of invariants that aren't\n     /// checked:\n     ///\n+    /// * `ptr` must be [*currently allocated*] via the given allocator `alloc`.\n     /// * `T` needs to have the same alignment as what `ptr` was allocated with.\n     ///   (`T` having a less strict alignment is not sufficient, the alignment really\n     ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n@@ -714,6 +718,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     ///\n     /// [`String`]: crate::string::String\n     /// [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n+    /// [*currently allocated*]: crate::alloc::Allocator#currently-allocated-memory\n     /// [*fit*]: crate::alloc::Allocator#memory-fitting\n     ///\n     /// # Examples"}, {"sha": "0693beb48c402130a58f7ce54c18291d660bde0f", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 1, "deletions": 348, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,15 +1,9 @@\n-use std::cell::Cell;\n-use std::cmp::Ordering::{self, Equal, Greater, Less};\n+use std::cmp::Ordering::{Equal, Greater, Less};\n use std::convert::identity;\n use std::fmt;\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n-use std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n-\n-use rand::distributions::Standard;\n-use rand::seq::SliceRandom;\n-use rand::{thread_rng, Rng, RngCore};\n \n fn square(n: usize) -> usize {\n     n * n\n@@ -388,123 +382,6 @@ fn test_reverse() {\n     assert_eq!(v, (-50..51i16).rev().collect::<Vec<_>>());\n }\n \n-#[test]\n-#[cfg_attr(miri, ignore)] // Miri is too slow\n-fn test_sort() {\n-    let mut rng = thread_rng();\n-\n-    for len in (2..25).chain(500..510) {\n-        for &modulus in &[5, 10, 100, 1000] {\n-            for _ in 0..10 {\n-                let orig: Vec<_> =\n-                    rng.sample_iter::<i32, _>(&Standard).map(|x| x % modulus).take(len).collect();\n-\n-                // Sort in default order.\n-                let mut v = orig.clone();\n-                v.sort();\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in ascending order.\n-                let mut v = orig.clone();\n-                v.sort_by(|a, b| a.cmp(b));\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in descending order.\n-                let mut v = orig.clone();\n-                v.sort_by(|a, b| b.cmp(a));\n-                assert!(v.windows(2).all(|w| w[0] >= w[1]));\n-\n-                // Sort in lexicographic order.\n-                let mut v1 = orig.clone();\n-                let mut v2 = orig.clone();\n-                v1.sort_by_key(|x| x.to_string());\n-                v2.sort_by_cached_key(|x| x.to_string());\n-                assert!(v1.windows(2).all(|w| w[0].to_string() <= w[1].to_string()));\n-                assert!(v1 == v2);\n-\n-                // Sort with many pre-sorted runs.\n-                let mut v = orig.clone();\n-                v.sort();\n-                v.reverse();\n-                for _ in 0..5 {\n-                    let a = rng.gen::<usize>() % len;\n-                    let b = rng.gen::<usize>() % len;\n-                    if a < b {\n-                        v[a..b].reverse();\n-                    } else {\n-                        v.swap(a, b);\n-                    }\n-                }\n-                v.sort();\n-                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-            }\n-        }\n-    }\n-\n-    // Sort using a completely random comparison function.\n-    // This will reorder the elements *somehow*, but won't panic.\n-    let mut v = [0; 500];\n-    for i in 0..v.len() {\n-        v[i] = i as i32;\n-    }\n-    v.sort_by(|_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n-    v.sort();\n-    for i in 0..v.len() {\n-        assert_eq!(v[i], i as i32);\n-    }\n-\n-    // Should not panic.\n-    [0i32; 0].sort();\n-    [(); 10].sort();\n-    [(); 100].sort();\n-\n-    let mut v = [0xDEADBEEFu64];\n-    v.sort();\n-    assert!(v == [0xDEADBEEF]);\n-}\n-\n-#[test]\n-fn test_sort_stability() {\n-    // Miri is too slow\n-    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n-    let rounds = if cfg!(miri) { 1 } else { 10 };\n-\n-    for len in (2..25).chain(large_range) {\n-        for _ in 0..rounds {\n-            let mut counts = [0; 10];\n-\n-            // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n-            // where the first item of each tuple is random, but\n-            // the second item represents which occurrence of that\n-            // number this element is, i.e., the second elements\n-            // will occur in sorted order.\n-            let orig: Vec<_> = (0..len)\n-                .map(|_| {\n-                    let n = thread_rng().gen::<usize>() % 10;\n-                    counts[n] += 1;\n-                    (n, counts[n])\n-                })\n-                .collect();\n-\n-            let mut v = orig.clone();\n-            // Only sort on the first element, so an unstable sort\n-            // may mix up the counts.\n-            v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n-\n-            // This comparison includes the count (the second item\n-            // of the tuple), so elements with equal first items\n-            // will need to be ordered with increasing\n-            // counts... i.e., exactly asserting that this sort is\n-            // stable.\n-            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-            let mut v = orig.clone();\n-            v.sort_by_cached_key(|&(x, _)| x);\n-            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-        }\n-    }\n-}\n-\n #[test]\n fn test_rotate_left() {\n     let expected: Vec<_> = (0..13).collect();\n@@ -1608,230 +1485,6 @@ fn test_copy_from_slice_dst_shorter() {\n     dst.copy_from_slice(&src);\n }\n \n-const MAX_LEN: usize = 80;\n-\n-static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n-    // FIXME(RFC 1109): AtomicUsize is not Copy.\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-    AtomicUsize::new(0),\n-];\n-\n-static VERSIONS: AtomicUsize = AtomicUsize::new(0);\n-\n-#[derive(Clone, Eq)]\n-struct DropCounter {\n-    x: u32,\n-    id: usize,\n-    version: Cell<usize>,\n-}\n-\n-impl PartialEq for DropCounter {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other) == Some(Ordering::Equal)\n-    }\n-}\n-\n-impl PartialOrd for DropCounter {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.version.set(self.version.get() + 1);\n-        other.version.set(other.version.get() + 1);\n-        VERSIONS.fetch_add(2, Relaxed);\n-        self.x.partial_cmp(&other.x)\n-    }\n-}\n-\n-impl Ord for DropCounter {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other).unwrap()\n-    }\n-}\n-\n-impl Drop for DropCounter {\n-    fn drop(&mut self) {\n-        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n-        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n-    }\n-}\n-\n-macro_rules! test {\n-    ($input:ident, $func:ident) => {\n-        let len = $input.len();\n-\n-        // Work out the total number of comparisons required to sort\n-        // this array...\n-        let mut count = 0usize;\n-        $input.to_owned().$func(|a, b| {\n-            count += 1;\n-            a.cmp(b)\n-        });\n-\n-        // ... and then panic on each and every single one.\n-        for panic_countdown in 0..count {\n-            // Refresh the counters.\n-            VERSIONS.store(0, Relaxed);\n-            for i in 0..len {\n-                DROP_COUNTS[i].store(0, Relaxed);\n-            }\n-\n-            let v = $input.to_owned();\n-            let _ = std::panic::catch_unwind(move || {\n-                let mut v = v;\n-                let mut panic_countdown = panic_countdown;\n-                v.$func(|a, b| {\n-                    if panic_countdown == 0 {\n-                        SILENCE_PANIC.with(|s| s.set(true));\n-                        panic!();\n-                    }\n-                    panic_countdown -= 1;\n-                    a.cmp(b)\n-                })\n-            });\n-\n-            // Check that the number of things dropped is exactly\n-            // what we expect (i.e., the contents of `v`).\n-            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n-                let count = c.load(Relaxed);\n-                assert!(count == 1, \"found drop count == {} for i == {}, len == {}\", count, i, len);\n-            }\n-\n-            // Check that the most recent versions of values were dropped.\n-            assert_eq!(VERSIONS.load(Relaxed), 0);\n-        }\n-    };\n-}\n-\n-thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n-\n-#[test]\n-#[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-fn panic_safe() {\n-    panic::update_hook(move |prev, info| {\n-        if !SILENCE_PANIC.with(|s| s.get()) {\n-            prev(info);\n-        }\n-    });\n-\n-    let mut rng = thread_rng();\n-\n-    // Miri is too slow (but still need to `chain` to make the types match)\n-    let lens = if cfg!(miri) { (1..10).chain(0..0) } else { (1..20).chain(70..MAX_LEN) };\n-    let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n-\n-    for len in lens {\n-        for &modulus in moduli {\n-            for &has_runs in &[false, true] {\n-                let mut input = (0..len)\n-                    .map(|id| DropCounter {\n-                        x: rng.next_u32() % modulus,\n-                        id: id,\n-                        version: Cell::new(0),\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                if has_runs {\n-                    for c in &mut input {\n-                        c.x = c.id as u32;\n-                    }\n-\n-                    for _ in 0..5 {\n-                        let a = rng.gen::<usize>() % len;\n-                        let b = rng.gen::<usize>() % len;\n-                        if a < b {\n-                            input[a..b].reverse();\n-                        } else {\n-                            input.swap(a, b);\n-                        }\n-                    }\n-                }\n-\n-                test!(input, sort_by);\n-                test!(input, sort_unstable_by);\n-            }\n-        }\n-    }\n-\n-    // Set default panic hook again.\n-    drop(panic::take_hook());\n-}\n-\n #[test]\n fn repeat_generic_slice() {\n     assert_eq!([1, 2].repeat(2), vec![1, 2, 1, 2]);"}, {"sha": "3dc8c84e0bfde0837d4623c05fdd33e604c5a308", "filename": "library/core/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -24,8 +24,8 @@ path = \"benches/lib.rs\"\n test = true\n \n [dev-dependencies]\n-rand = \"0.7\"\n-rand_xorshift = \"0.2\"\n+rand = { version = \"0.8.5\", default-features = false }\n+rand_xorshift = { version = \"0.3.0\", default-features = false }\n \n [features]\n # Make panics and failed asserts immediately abort without formatting any message"}, {"sha": "bb61224b5baadc15acdeb163d084657009b9726f", "filename": "library/core/benches/num/int_log/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fnum%2Fint_log%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -21,7 +21,7 @@ macro_rules! int_log_bench {\n             /* Exponentially distributed random numbers from the whole range of the type.  */\n             let numbers: Vec<$t> = (0..256)\n                 .map(|_| {\n-                    let x = rng.gen::<$t>() >> rng.gen_range(0, <$t>::BITS);\n+                    let x = rng.gen::<$t>() >> rng.gen_range(0..<$t>::BITS);\n                     if x != 0 { x } else { 1 }\n                 })\n                 .collect();\n@@ -38,7 +38,7 @@ macro_rules! int_log_bench {\n             /* Exponentially distributed random numbers from the range 0..256.  */\n             let numbers: Vec<$t> = (0..256)\n                 .map(|_| {\n-                    let x = (rng.gen::<u8>() >> rng.gen_range(0, u8::BITS)) as $t;\n+                    let x = (rng.gen::<u8>() >> rng.gen_range(0..u8::BITS)) as $t;\n                     if x != 0 { x } else { 1 }\n                 })\n                 .collect();"}, {"sha": "8c7111cb3ff0b875f22a2369480d03aed05d26ce", "filename": "library/core/src/future/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Ffuture.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -37,6 +37,7 @@ use crate::task::{Context, Poll};\n pub trait Future {\n     /// The type of value produced on completion.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+    #[rustc_diagnostic_item = \"FutureOutput\"]\n     type Output;\n \n     /// Attempt to resolve the future to a final value, registering"}, {"sha": "080ae27a30fcf976dd3e483e8fe6b14d8f3f65e4", "filename": "library/core/src/iter/sources/once_with.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,3 +1,4 @@\n+use crate::fmt;\n use crate::iter::{FusedIterator, TrustedLen};\n \n /// Creates an iterator that lazily generates a value exactly once by invoking\n@@ -66,12 +67,23 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n ///\n /// This `struct` is created by the [`once_with()`] function.\n /// See its documentation for more.\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n #[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n pub struct OnceWith<F> {\n     gen: Option<F>,\n }\n \n+#[stable(feature = \"iter_once_with_debug\", since = \"CURRENT_RUSTC_VERSION\")]\n+impl<F> fmt::Debug for OnceWith<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.gen.is_some() {\n+            f.write_str(\"OnceWith(Some(_))\")\n+        } else {\n+            f.write_str(\"OnceWith(None)\")\n+        }\n+    }\n+}\n+\n #[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n     type Item = A;"}, {"sha": "dc61d6065b8edaae5c11cc055aedc98c3ef7be36", "filename": "library/core/src/iter/sources/repeat_n.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -126,7 +126,7 @@ impl<A: Clone> Iterator for RepeatN<A> {\n             // zero so it won't be dropped later, and thus it's okay to take it here.\n             unsafe { ManuallyDrop::take(&mut self.element) }\n         } else {\n-            A::clone(&mut self.element)\n+            A::clone(&self.element)\n         })\n     }\n "}, {"sha": "20420a3ad8e02a83df814e758b5cc9e8481f83a2", "filename": "library/core/src/iter/sources/repeat_with.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,3 +1,4 @@\n+use crate::fmt;\n use crate::iter::{FusedIterator, TrustedLen};\n use crate::ops::Try;\n \n@@ -71,12 +72,19 @@ pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n ///\n /// This `struct` is created by the [`repeat_with()`] function.\n /// See its documentation for more.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n pub struct RepeatWith<F> {\n     repeater: F,\n }\n \n+#[stable(feature = \"iterator_repeat_with_debug\", since = \"CURRENT_RUSTC_VERSION\")]\n+impl<F> fmt::Debug for RepeatWith<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"RepeatWith\").finish_non_exhaustive()\n+    }\n+}\n+\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n     type Item = A;"}, {"sha": "9e0d7cab63e5c1d3efc36e508955cc9b8eb3dd89", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -158,6 +158,7 @@\n #![feature(const_unsafecell_get_mut)]\n #![feature(const_waker)]\n #![feature(core_panic)]\n+#![feature(char_indices_offset)]\n #![feature(duration_consts_float)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(ptr_alignment_type)]\n@@ -166,6 +167,8 @@\n #![feature(slice_ptr_get)]\n #![feature(slice_split_at_unchecked)]\n #![feature(str_internals)]\n+#![feature(str_split_remainder)]\n+#![feature(str_split_inclusive_remainder)]\n #![feature(strict_provenance)]\n #![feature(utf16_extra)]\n #![feature(utf16_extra_const)]"}, {"sha": "3b026bc0e0f381bd23b847f3c9ecd0fcf0ca315b", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1315,22 +1315,41 @@ pub(crate) mod builtin {\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n-    /// The file is located relative to the current file (similarly to how\n-    /// modules are found). The provided path is interpreted in a platform-specific\n-    /// way at compile time. So, for instance, an invocation with a Windows path\n-    /// containing backslashes `\\` would not compile correctly on Unix.\n+    /// **Warning**: For multi-file Rust projects, the `include!` macro is probably not what you\n+    /// are looking for. Usually, multi-file Rust projects use\n+    /// [modules](https://doc.rust-lang.org/reference/items/modules.html). Multi-file projects and\n+    /// modules are explained in the Rust-by-Example book\n+    /// [here](https://doc.rust-lang.org/rust-by-example/mod/split.html) and the module system is\n+    /// explained in the Rust Book\n+    /// [here](https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html).\n+    ///\n+    /// The included file is placed in the surrounding code\n+    /// [unhygienically](https://doc.rust-lang.org/reference/macros-by-example.html#hygiene). If\n+    /// the included file is parsed as an expression and variables or functions share names across\n+    /// both files, it could result in variables or functions being different from what the\n+    /// included file expected.\n+    ///\n+    /// The included file is located relative to the current file (similarly to how modules are\n+    /// found). The provided path is interpreted in a platform-specific way at compile time. So,\n+    /// for instance, an invocation with a Windows path containing backslashes `\\` would not\n+    /// compile correctly on Unix.\n     ///\n-    /// Using this macro is often a bad idea, because if the file is\n-    /// parsed as an expression, it is going to be placed in the\n-    /// surrounding code unhygienically. This could result in variables\n-    /// or functions being different from what the file expected if\n-    /// there are variables or functions that have the same name in\n-    /// the current file.\n+    /// # Uses\n+    ///\n+    /// The `include!` macro is primarily used for two purposes. It is used to include\n+    /// documentation that is written in a separate file and it is used to include [build artifacts\n+    /// usually as a result from the `build.rs`\n+    /// script](https://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script).\n+    ///\n+    /// When using the `include` macro to include stretches of documentation, remember that the\n+    /// included file still needs to be a valid rust syntax. It is also possible to\n+    /// use the [`include_str`] macro as `#![doc = include_str!(\"...\")]` (at the module level) or\n+    /// `#[doc = include_str!(\"...\")]` (at the item level) to include documentation from a plain\n+    /// text or markdown file.\n     ///\n     /// # Examples\n     ///\n-    /// Assume there are two files in the same directory with the following\n-    /// contents:\n+    /// Assume there are two files in the same directory with the following contents:\n     ///\n     /// File 'monkeys.in':\n     ///"}, {"sha": "1326fc9ab096f03d6edde634db009dc697c17c15", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -623,6 +623,12 @@ impl<T: ?Sized> !Sync for *mut T {}\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n ///\n+/// ## Layout\n+///\n+/// For all `T`, the following are guaranteed:\n+/// * `size_of::<PhantomData<T>>() == 0`\n+/// * `align_of::<PhantomData<T>>() == 1`\n+///\n /// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "48e90e6d794005e7b9bde41b4ac440a93ade37f5", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -64,13 +64,17 @@ pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n     unsafe { panic_impl(&pi) }\n }\n \n-/// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.\n-/// (No `fmt` variant as a `fmt::Arguments` needs more space to be passed.)\n+/// Like `panic_fmt`, but for non-unwinding panics.\n+///\n+/// Has to be a separate function so that it can carry the `rustc_nounwind` attribute.\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cfg_attr(not(bootstrap), lang = \"panic_nounwind\")] // needed by codegen for non-unwinding panics\n+#[track_caller]\n+// This attribute has the key side-effect that if the panic handler ignores `can_unwind`\n+// and unwinds anyway, we will hit the \"unwinding out of nounwind function\" guard,\n+// which causes a \"panic in a function that cannot unwind\".\n #[rustc_nounwind]\n-pub fn panic_nounwind(msg: &'static str) -> ! {\n+pub fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         super::intrinsics::abort()\n     }\n@@ -83,8 +87,6 @@ pub fn panic_nounwind(msg: &'static str) -> ! {\n     }\n \n     // PanicInfo with the `can_unwind` flag set to false forces an abort.\n-    let pieces = [msg];\n-    let fmt = fmt::Arguments::new_v1(&pieces, &[]);\n     let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller(), false);\n \n     // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n@@ -112,6 +114,15 @@ pub const fn panic(expr: &'static str) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n }\n \n+/// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n+#[cfg_attr(not(bootstrap), lang = \"panic_nounwind\")] // needed by codegen for non-unwinding panics\n+#[rustc_nounwind]\n+pub fn panic_nounwind(expr: &'static str) -> ! {\n+    panic_nounwind_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+}\n+\n #[inline]\n #[track_caller]\n #[rustc_diagnostic_item = \"panic_str\"]"}, {"sha": "d969475aa484fd5a740a2f2c6895f0a24c2b7e3d", "filename": "library/core/src/str/iter.rs", "status": "modified", "additions": 101, "deletions": 84, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -585,16 +585,17 @@ where\n impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     #[inline]\n     fn get_end(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n+        if !self.finished {\n             self.finished = true;\n-            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n-            unsafe {\n-                let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n-                Some(string)\n+\n+            if self.allow_trailing_empty || self.end - self.start > 0 {\n+                // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n+                let string = unsafe { self.matcher.haystack().get_unchecked(self.start..self.end) };\n+                return Some(string);\n             }\n-        } else {\n-            None\n         }\n+\n+        None\n     }\n \n     #[inline]\n@@ -716,14 +717,14 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     }\n \n     #[inline]\n-    fn as_str(&self) -> &'a str {\n+    fn remainder(&self) -> Option<&'a str> {\n         // `Self::get_end` doesn't change `self.start`\n         if self.finished {\n-            return \"\";\n+            return None;\n         }\n \n         // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n-        unsafe { self.matcher.haystack().get_unchecked(self.start..self.end) }\n+        Some(unsafe { self.matcher.haystack().get_unchecked(self.start..self.end) })\n     }\n }\n \n@@ -746,44 +747,48 @@ generate_pattern_iterators! {\n }\n \n impl<'a, P: Pattern<'a>> Split<'a, P> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_as_str)]\n+    /// #![feature(str_split_remainder)]\n     /// let mut split = \"Mary had a little lamb\".split(' ');\n-    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little lamb\"));\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"had a little lamb\"));\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.0.as_str()\n+    #[unstable(feature = \"str_split_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.0.remainder()\n     }\n }\n \n impl<'a, P: Pattern<'a>> RSplit<'a, P> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_as_str)]\n+    /// #![feature(str_split_remainder)]\n     /// let mut split = \"Mary had a little lamb\".rsplit(' ');\n-    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little lamb\"));\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"Mary had a little\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little\"));\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.0.as_str()\n+    #[unstable(feature = \"str_split_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.0.remainder()\n     }\n }\n \n@@ -806,44 +811,48 @@ generate_pattern_iterators! {\n }\n \n impl<'a, P: Pattern<'a>> SplitTerminator<'a, P> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_as_str)]\n+    /// #![feature(str_split_remainder)]\n     /// let mut split = \"A..B..\".split_terminator('.');\n-    /// assert_eq!(split.as_str(), \"A..B..\");\n+    /// assert_eq!(split.remainder(), Some(\"A..B..\"));\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \".B..\");\n+    /// assert_eq!(split.remainder(), Some(\".B..\"));\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.0.as_str()\n+    #[unstable(feature = \"str_split_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.0.remainder()\n     }\n }\n \n impl<'a, P: Pattern<'a>> RSplitTerminator<'a, P> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_as_str)]\n+    /// #![feature(str_split_remainder)]\n     /// let mut split = \"A..B..\".rsplit_terminator('.');\n-    /// assert_eq!(split.as_str(), \"A..B..\");\n+    /// assert_eq!(split.remainder(), Some(\"A..B..\"));\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"A..B\");\n+    /// assert_eq!(split.remainder(), Some(\"A..B\"));\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.0.as_str()\n+    #[unstable(feature = \"str_split_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.0.remainder()\n     }\n }\n \n@@ -905,8 +914,8 @@ impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n     }\n \n     #[inline]\n-    fn as_str(&self) -> &'a str {\n-        self.iter.as_str()\n+    fn remainder(&self) -> Option<&'a str> {\n+        self.iter.remainder()\n     }\n }\n \n@@ -929,44 +938,48 @@ generate_pattern_iterators! {\n }\n \n impl<'a, P: Pattern<'a>> SplitN<'a, P> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_as_str)]\n+    /// #![feature(str_split_remainder)]\n     /// let mut split = \"Mary had a little lamb\".splitn(3, ' ');\n-    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little lamb\"));\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"had a little lamb\"));\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.0.as_str()\n+    #[unstable(feature = \"str_split_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.0.remainder()\n     }\n }\n \n impl<'a, P: Pattern<'a>> RSplitN<'a, P> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_as_str)]\n+    /// #![feature(str_split_remainder)]\n     /// let mut split = \"Mary had a little lamb\".rsplitn(3, ' ');\n-    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little lamb\"));\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"Mary had a little\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little\"));\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.0.as_str()\n+    #[unstable(feature = \"str_split_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.0.remainder()\n     }\n }\n \n@@ -1239,22 +1252,22 @@ impl<'a> SplitWhitespace<'a> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_whitespace_as_str)]\n+    /// #![feature(str_split_whitespace_remainder)]\n     ///\n     /// let mut split = \"Mary had a little lamb\".split_whitespace();\n-    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little lamb\"));\n     ///\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"had a little lamb\"));\n     ///\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n     #[must_use]\n-    #[unstable(feature = \"str_split_whitespace_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.inner.iter.as_str()\n+    #[unstable(feature = \"str_split_whitespace_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.inner.iter.remainder()\n     }\n }\n \n@@ -1290,32 +1303,34 @@ impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n impl FusedIterator for SplitAsciiWhitespace<'_> {}\n \n impl<'a> SplitAsciiWhitespace<'a> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_whitespace_as_str)]\n+    /// #![feature(str_split_whitespace_remainder)]\n     ///\n     /// let mut split = \"Mary had a little lamb\".split_ascii_whitespace();\n-    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little lamb\"));\n     ///\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"had a little lamb\"));\n     ///\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n     #[must_use]\n-    #[unstable(feature = \"str_split_whitespace_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n+    #[unstable(feature = \"str_split_whitespace_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n         if self.inner.iter.iter.finished {\n-            return \"\";\n+            return None;\n         }\n \n         // SAFETY: Slice is created from str.\n-        unsafe { crate::str::from_utf8_unchecked(&self.inner.iter.iter.v) }\n+        Some(unsafe { crate::str::from_utf8_unchecked(&self.inner.iter.iter.v) })\n     }\n }\n \n@@ -1358,23 +1373,25 @@ impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n \n impl<'a, P: Pattern<'a>> SplitInclusive<'a, P> {\n-    /// Returns remainder of the split string\n+    /// Returns remainder of the split string.\n+    ///\n+    /// If the iterator is empty, returns `None`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(str_split_inclusive_as_str)]\n+    /// #![feature(str_split_inclusive_remainder)]\n     /// let mut split = \"Mary had a little lamb\".split_inclusive(' ');\n-    /// assert_eq!(split.as_str(), \"Mary had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"Mary had a little lamb\"));\n     /// split.next();\n-    /// assert_eq!(split.as_str(), \"had a little lamb\");\n+    /// assert_eq!(split.remainder(), Some(\"had a little lamb\"));\n     /// split.by_ref().for_each(drop);\n-    /// assert_eq!(split.as_str(), \"\");\n+    /// assert_eq!(split.remainder(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"str_split_inclusive_as_str\", issue = \"77998\")]\n-    pub fn as_str(&self) -> &'a str {\n-        self.0.as_str()\n+    #[unstable(feature = \"str_split_inclusive_remainder\", issue = \"77998\")]\n+    pub fn remainder(&self) -> Option<&'a str> {\n+        self.0.remainder()\n     }\n }\n "}, {"sha": "c910cb65c55def0f32dc6c9fb7294965d79b2d54", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -155,3 +155,16 @@ mod time;\n mod tuple;\n mod unicode;\n mod waker;\n+\n+/// Copied from `std::test_helpers::test_rng`, see that function for rationale.\n+#[track_caller]\n+#[allow(dead_code)] // Not used in all configurations.\n+pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+    use core::hash::{BuildHasher, Hash, Hasher};\n+    let mut hasher = std::collections::hash_map::RandomState::new().build_hasher();\n+    core::panic::Location::caller().hash(&mut hasher);\n+    let hc64 = hasher.finish();\n+    let seed_vec = hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<Vec<u8>>();\n+    let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+    rand::SeedableRng::from_seed(seed)\n+}"}, {"sha": "0084c1c814e2d6470faae5b04090525c741aa38e", "filename": "library/core/tests/num/flt2dec/random.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -9,8 +9,6 @@ use core::num::flt2dec::MAX_SIG_DIGITS;\n use core::num::flt2dec::{decode, DecodableFloat, Decoded, FullDecoded};\n \n use rand::distributions::{Distribution, Uniform};\n-use rand::rngs::StdRng;\n-use rand::SeedableRng;\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n@@ -92,7 +90,7 @@ where\n     if cfg!(target_os = \"emscripten\") {\n         return; // using rng pulls in i128 support, which doesn't work\n     }\n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n     let f32_range = Uniform::new(0x0000_0001u32, 0x7f80_0000);\n     iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n         let x = f32::from_bits(f32_range.sample(&mut rng));\n@@ -108,7 +106,7 @@ where\n     if cfg!(target_os = \"emscripten\") {\n         return; // using rng pulls in i128 support, which doesn't work\n     }\n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n     let f64_range = Uniform::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n     iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n         let x = f64::from_bits(f64_range.sample(&mut rng));"}, {"sha": "fd35d96c3fef814bd7952fb8b13afbcd7f31354f", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1805,15 +1805,15 @@ fn brute_force_rotate_test_1() {\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n-    use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n+    use rand::{seq::SliceRandom, Rng};\n \n     // Miri is too slow (but still need to `chain` to make the types match)\n     let lens = if cfg!(miri) { (2..20).chain(0..0) } else { (2..25).chain(500..510) };\n     let rounds = if cfg!(miri) { 1 } else { 100 };\n \n     let mut v = [0; 600];\n     let mut tmp = [0; 600];\n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n \n     for len in lens {\n         let v = &mut v[0..len];\n@@ -1879,11 +1879,10 @@ fn sort_unstable() {\n #[cfg_attr(miri, ignore)] // Miri is too slow\n fn select_nth_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n-    use rand::rngs::StdRng;\n     use rand::seq::SliceRandom;\n-    use rand::{Rng, SeedableRng};\n+    use rand::Rng;\n \n-    let mut rng = StdRng::from_entropy();\n+    let mut rng = crate::test_rng();\n \n     for len in (2..21).chain(500..501) {\n         let mut orig = vec![0; len];"}, {"sha": "adf521d9b94a124544268303b51f52e8e5ef2c05", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -33,7 +33,8 @@ default-features = false\n features = ['read_core', 'elf', 'macho', 'pe', 'unaligned', 'archive']\n \n [dev-dependencies]\n-rand = \"0.7\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\"alloc\"] }\n+rand_xorshift = \"0.3.0\"\n \n [target.'cfg(any(all(target_family = \"wasm\", not(target_os = \"emscripten\")), all(target_vendor = \"fortanix\", target_env = \"sgx\")))'.dependencies]\n dlmalloc = { version = \"0.2.3\", features = ['rustc-dep-of-std'] }"}, {"sha": "c5a5991cc81c47d340a3b7b113c56339671acd7e", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -338,7 +338,7 @@ fn default_alloc_error_hook(layout: Layout) {\n \n     #[allow(unused_unsafe)]\n     if unsafe { __rust_alloc_error_handler_should_panic != 0 } {\n-        panic!(\"memory allocation of {} bytes failed\\n\", layout.size());\n+        panic!(\"memory allocation of {} bytes failed\", layout.size());\n     } else {\n         rtprintpanic!(\"memory allocation of {} bytes failed\\n\", layout.size());\n     }"}, {"sha": "6b89518e2e26cd69bdb606b44dfc38815c09cab3", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -3,7 +3,8 @@ use super::HashMap;\n use super::RandomState;\n use crate::assert_matches::assert_matches;\n use crate::cell::RefCell;\n-use rand::{thread_rng, Rng};\n+use crate::test_helpers::test_rng;\n+use rand::Rng;\n use realstd::collections::TryReserveErrorKind::*;\n \n // https://github.com/rust-lang/rust/issues/62301\n@@ -710,16 +711,16 @@ fn test_entry_take_doesnt_corrupt() {\n     }\n \n     let mut m = HashMap::new();\n-    let mut rng = thread_rng();\n+    let mut rng = test_rng();\n \n     // Populate the map with some items.\n     for _ in 0..50 {\n-        let x = rng.gen_range(-10, 10);\n+        let x = rng.gen_range(-10..10);\n         m.insert(x, ());\n     }\n \n     for _ in 0..1000 {\n-        let x = rng.gen_range(-10, 10);\n+        let x = rng.gen_range(-10..10);\n         match m.entry(x) {\n             Vacant(_) => {}\n             Occupied(e) => {"}, {"sha": "b59f89d321c47ad93f61b53950127157304e8a63", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -317,7 +317,7 @@ impl<T, S> HashSet<T, S> {\n     ///\n     /// let mut set = HashSet::from([1, 2, 3, 4, 5, 6]);\n     /// set.retain(|&k| k % 2 == 0);\n-    /// assert_eq!(set.len(), 3);\n+    /// assert_eq!(set, HashSet::from([2, 4, 6]));\n     /// ```\n     ///\n     /// # Performance"}, {"sha": "eb582be012bd54d72940ab3c694d99c769e0b236", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -10,7 +10,7 @@ use crate::sys_common::io::test::{tmpdir, TempDir};\n use crate::thread;\n use crate::time::{Duration, Instant};\n \n-use rand::{rngs::StdRng, RngCore, SeedableRng};\n+use rand::RngCore;\n \n #[cfg(unix)]\n use crate::os::unix::fs::symlink as symlink_dir;\n@@ -1181,7 +1181,7 @@ fn _assert_send_sync() {\n #[test]\n fn binary_file() {\n     let mut bytes = [0; 1024];\n-    StdRng::from_entropy().fill_bytes(&mut bytes);\n+    crate::test_helpers::test_rng().fill_bytes(&mut bytes);\n \n     let tmpdir = tmpdir();\n \n@@ -1194,7 +1194,7 @@ fn binary_file() {\n #[test]\n fn write_then_read() {\n     let mut bytes = [0; 1024];\n-    StdRng::from_entropy().fill_bytes(&mut bytes);\n+    crate::test_helpers::test_rng().fill_bytes(&mut bytes);\n \n     let tmpdir = tmpdir();\n "}, {"sha": "a7e13f5b866b53058f0f995f5818e739c47c09de", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -14,7 +14,7 @@\n //! # How to read this documentation\n //!\n //! If you already know the name of what you are looking for, the fastest way to\n-//! find it is to use the <a href=\"#\" onclick=\"focusSearchBar();\">search\n+//! find it is to use the <a href=\"#\" onclick=\"window.searchState.focus();\">search\n //! bar</a> at the top of the page.\n //!\n //! Otherwise, you may want to jump to one of these useful sections:\n@@ -652,3 +652,30 @@ mod sealed {\n     #[unstable(feature = \"sealed\", issue = \"none\")]\n     pub trait Sealed {}\n }\n+\n+#[cfg(test)]\n+#[allow(dead_code)] // Not used in all configurations.\n+pub(crate) mod test_helpers {\n+    /// Test-only replacement for `rand::thread_rng()`, which is unusable for\n+    /// us, as we want to allow running stdlib tests on tier-3 targets which may\n+    /// not have `getrandom` support.\n+    ///\n+    /// Does a bit of a song and dance to ensure that the seed is different on\n+    /// each call (as some tests sadly rely on this), but doesn't try that hard.\n+    ///\n+    /// This is duplicated in the `core`, `alloc` test suites (as well as\n+    /// `std`'s integration tests), but figuring out a mechanism to share these\n+    /// seems far more painful than copy-pasting a 7 line function a couple\n+    /// times, given that even under a perma-unstable feature, I don't think we\n+    /// want to expose types from `rand` from `std`.\n+    #[track_caller]\n+    pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+        use core::hash::{BuildHasher, Hash, Hasher};\n+        let mut hasher = crate::collections::hash_map::RandomState::new().build_hasher();\n+        core::panic::Location::caller().hash(&mut hasher);\n+        let hc64 = hasher.finish();\n+        let seed_vec = hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<Vec<u8>>();\n+        let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+        rand::SeedableRng::from_seed(seed)\n+    }\n+}"}, {"sha": "fcc5cfafd808d0cc2066366fe12d0c9cb55dbb7c", "filename": "library/std/src/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmacros.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -3,6 +3,7 @@\n //! This module contains a set of macros which are exported from the standard\n //! library. Each macro is available for use when linking against the standard\n //! library.\n+// ignore-tidy-dbg\n \n #[doc = include_str!(\"../../core/src/macros/panic.md\")]\n #[macro_export]"}, {"sha": "82d68369312f9d09d6fd867c4c422c720246d076", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -271,7 +271,7 @@ pub const MAIN_SEPARATOR: char = crate::sys::path::MAIN_SEP;\n /// The primary separator of path components for the current platform.\n ///\n /// For example, `/` on Unix and `\\` on Windows.\n-#[unstable(feature = \"main_separator_str\", issue = \"94071\")]\n+#[stable(feature = \"main_separator_str\", since = \"CURRENT_RUSTC_VERSION\")]\n pub const MAIN_SEPARATOR_STR: &str = crate::sys::path::MAIN_SEP_STR;\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "1a9d3d3f12f3cea109c9fa772edbfe128f44afe6", "filename": "library/std/src/sync/rwlock/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2,7 +2,7 @@ use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sync::mpsc::channel;\n use crate::sync::{Arc, RwLock, RwLockReadGuard, TryLockError};\n use crate::thread;\n-use rand::{self, Rng};\n+use rand::Rng;\n \n #[derive(Eq, PartialEq, Debug)]\n struct NonCopy(i32);\n@@ -28,7 +28,7 @@ fn frob() {\n         let tx = tx.clone();\n         let r = r.clone();\n         thread::spawn(move || {\n-            let mut rng = rand::thread_rng();\n+            let mut rng = crate::test_helpers::test_rng();\n             for _ in 0..M {\n                 if rng.gen_bool(1.0 / (N as f64)) {\n                     drop(r.write().unwrap());"}, {"sha": "4a42ff3c618ce4c744cb2d9f479ea86926faffa8", "filename": "library/std/src/sys_common/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -39,9 +39,10 @@ pub mod test {\n         }\n     }\n \n+    #[track_caller] // for `test_rng`\n     pub fn tmpdir() -> TempDir {\n         let p = env::temp_dir();\n-        let mut r = rand::thread_rng();\n+        let mut r = crate::test_helpers::test_rng();\n         let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n         fs::create_dir(&ret).unwrap();\n         TempDir(ret)"}, {"sha": "aae2c49d8982e8a10de8ca331b26b6df9d3381bf", "filename": "library/std/tests/env.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Ftests%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Fstd%2Ftests%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Fenv.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,12 +1,24 @@\n use std::env::*;\n use std::ffi::{OsStr, OsString};\n \n-use rand::distributions::Alphanumeric;\n-use rand::{thread_rng, Rng};\n+use rand::distributions::{Alphanumeric, DistString};\n+\n+/// Copied from `std::test_helpers::test_rng`, since these tests rely on the\n+/// seed not being the same for every RNG invocation too.\n+#[track_caller]\n+pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n+    use core::hash::{BuildHasher, Hash, Hasher};\n+    let mut hasher = std::collections::hash_map::RandomState::new().build_hasher();\n+    core::panic::Location::caller().hash(&mut hasher);\n+    let hc64 = hasher.finish();\n+    let seed_vec = hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<Vec<u8>>();\n+    let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n+    rand::SeedableRng::from_seed(seed)\n+}\n \n+#[track_caller]\n fn make_rand_name() -> OsString {\n-    let rng = thread_rng();\n-    let n = format!(\"TEST{}\", rng.sample_iter(&Alphanumeric).take(10).collect::<String>());\n+    let n = format!(\"TEST{}\", Alphanumeric.sample_string(&mut test_rng(), 10));\n     let n = OsString::from(n);\n     assert!(var_os(&n).is_none());\n     n"}, {"sha": "24cbe035f2fa7e3e9082d38a6c44355dd47711da", "filename": "library/test/src/console.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -147,7 +147,7 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n     let mut ntest = 0;\n     let mut nbench = 0;\n \n-    for test in filter_tests(&opts, tests).into_iter() {\n+    for test in filter_tests(opts, tests).into_iter() {\n         use crate::TestFn::*;\n \n         let TestDescAndFn { desc: TestDesc { name, .. }, testfn } = test;\n@@ -244,7 +244,7 @@ fn on_test_event(\n             let stdout = &completed_test.stdout;\n \n             st.write_log_result(test, result, exec_time.as_ref())?;\n-            out.write_result(test, result, exec_time.as_ref(), &*stdout, st)?;\n+            out.write_result(test, result, exec_time.as_ref(), stdout, st)?;\n             handle_test_result(st, completed_test);\n         }\n     }\n@@ -262,7 +262,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n \n     let max_name_len = tests\n         .iter()\n-        .max_by_key(|t| len_if_padded(*t))\n+        .max_by_key(|t| len_if_padded(t))\n         .map(|t| t.desc.name.as_slice().len())\n         .unwrap_or(0);\n "}, {"sha": "95d2faf25060fcb0f49ef11d5b66daa895d66406", "filename": "library/test/src/formatters/json.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -40,20 +40,20 @@ impl<T: Write> JsonFormatter<T> {\n         extra: Option<&str>,\n     ) -> io::Result<()> {\n         // A doc test's name includes a filename which must be escaped for correct json.\n-        self.write_message(&*format!(\n+        self.write_message(&format!(\n             r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n             ty,\n             EscapedString(name),\n             evt\n         ))?;\n         if let Some(exec_time) = exec_time {\n-            self.write_message(&*format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64()))?;\n+            self.write_message(&format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64()))?;\n         }\n         if let Some(stdout) = stdout {\n-            self.write_message(&*format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout)))?;\n+            self.write_message(&format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout)))?;\n         }\n         if let Some(extra) = extra {\n-            self.write_message(&*format!(r#\", {extra}\"#))?;\n+            self.write_message(&format!(r#\", {extra}\"#))?;\n         }\n         self.writeln_message(\" }\")\n     }\n@@ -66,13 +66,13 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n         } else {\n             String::new()\n         };\n-        self.writeln_message(&*format!(\n+        self.writeln_message(&format!(\n             r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {test_count}{shuffle_seed_json} }}\"#\n         ))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.writeln_message(&*format!(\n+        self.writeln_message(&format!(\n             r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n             EscapedString(desc.name.as_slice())\n         ))\n@@ -151,20 +151,20 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                     mbps\n                 );\n \n-                self.writeln_message(&*line)\n+                self.writeln_message(&line)\n             }\n         }\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.writeln_message(&*format!(\n+        self.writeln_message(&format!(\n             r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n             EscapedString(desc.name.as_slice())\n         ))\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-        self.write_message(&*format!(\n+        self.write_message(&format!(\n             \"{{ \\\"type\\\": \\\"suite\\\", \\\n              \\\"event\\\": \\\"{}\\\", \\\n              \\\"passed\\\": {}, \\"}, {"sha": "7a40ce33cb741bd3866738a074fa2ee1a594874a", "filename": "library/test/src/formatters/junit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -64,7 +64,7 @@ impl<T: Write> OutputFormatter for JunitFormatter<T> {\n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n         self.write_message(\"<testsuites>\")?;\n \n-        self.write_message(&*format!(\n+        self.write_message(&format!(\n             \"<testsuite name=\\\"test\\\" package=\\\"test\\\" id=\\\"0\\\" \\\n              errors=\\\"0\\\" \\\n              failures=\\\"{}\\\" \\\n@@ -73,12 +73,12 @@ impl<T: Write> OutputFormatter for JunitFormatter<T> {\n              >\",\n             state.failed, state.total, state.ignored\n         ))?;\n-        for (desc, result, duration) in std::mem::replace(&mut self.results, Vec::new()) {\n+        for (desc, result, duration) in std::mem::take(&mut self.results) {\n             let (class_name, test_name) = parse_class_name(&desc);\n             match result {\n                 TestResult::TrIgnored => { /* no-op */ }\n                 TestResult::TrFailed => {\n-                    self.write_message(&*format!(\n+                    self.write_message(&format!(\n                         \"<testcase classname=\\\"{}\\\" \\\n                          name=\\\"{}\\\" time=\\\"{}\\\">\",\n                         class_name,\n@@ -90,19 +90,19 @@ impl<T: Write> OutputFormatter for JunitFormatter<T> {\n                 }\n \n                 TestResult::TrFailedMsg(ref m) => {\n-                    self.write_message(&*format!(\n+                    self.write_message(&format!(\n                         \"<testcase classname=\\\"{}\\\" \\\n                          name=\\\"{}\\\" time=\\\"{}\\\">\",\n                         class_name,\n                         test_name,\n                         duration.as_secs_f64()\n                     ))?;\n-                    self.write_message(&*format!(\"<failure message=\\\"{m}\\\" type=\\\"assert\\\"/>\"))?;\n+                    self.write_message(&format!(\"<failure message=\\\"{m}\\\" type=\\\"assert\\\"/>\"))?;\n                     self.write_message(\"</testcase>\")?;\n                 }\n \n                 TestResult::TrTimedFail => {\n-                    self.write_message(&*format!(\n+                    self.write_message(&format!(\n                         \"<testcase classname=\\\"{}\\\" \\\n                          name=\\\"{}\\\" time=\\\"{}\\\">\",\n                         class_name,\n@@ -114,15 +114,15 @@ impl<T: Write> OutputFormatter for JunitFormatter<T> {\n                 }\n \n                 TestResult::TrBench(ref b) => {\n-                    self.write_message(&*format!(\n+                    self.write_message(&format!(\n                         \"<testcase classname=\\\"benchmark::{}\\\" \\\n                          name=\\\"{}\\\" time=\\\"{}\\\" />\",\n                         class_name, test_name, b.ns_iter_summ.sum\n                     ))?;\n                 }\n \n                 TestResult::TrOk => {\n-                    self.write_message(&*format!(\n+                    self.write_message(&format!(\n                         \"<testcase classname=\\\"{}\\\" \\\n                          name=\\\"{}\\\" time=\\\"{}\\\"/>\",\n                         class_name,"}, {"sha": "247778e515f0dedd3f34840df9cdcae0c55bb2a3", "filename": "library/test/src/formatters/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -134,7 +134,7 @@ impl<T: Write> PrettyFormatter<T> {\n \n         let mut results = Vec::new();\n         let mut stdouts = String::new();\n-        for &(ref f, ref stdout) in inputs {\n+        for (f, stdout) in inputs {\n             results.push(f.name.to_string());\n             if !stdout.is_empty() {\n                 stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n@@ -171,9 +171,9 @@ impl<T: Write> PrettyFormatter<T> {\n     fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n         let name = desc.padded_name(self.max_name_len, desc.name.padding());\n         if let Some(test_mode) = desc.test_mode() {\n-            self.write_plain(&format!(\"test {name} - {test_mode} ... \"))?;\n+            self.write_plain(format!(\"test {name} - {test_mode} ... \"))?;\n         } else {\n-            self.write_plain(&format!(\"test {name} ... \"))?;\n+            self.write_plain(format!(\"test {name} ... \"))?;\n         }\n \n         Ok(())\n@@ -188,7 +188,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         } else {\n             String::new()\n         };\n-        self.write_plain(&format!(\"\\nrunning {test_count} {noun}{shuffle_seed_msg}\\n\"))\n+        self.write_plain(format!(\"\\nrunning {test_count} {noun}{shuffle_seed_msg}\\n\"))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n@@ -221,7 +221,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n             TestResult::TrIgnored => self.write_ignored(desc.ignore_message)?,\n             TestResult::TrBench(ref bs) => {\n                 self.write_bench()?;\n-                self.write_plain(&format!(\": {}\", fmt_bench_samples(bs)))?;\n+                self.write_plain(format!(\": {}\", fmt_bench_samples(bs)))?;\n             }\n             TestResult::TrTimedFail => self.write_time_failed()?,\n         }\n@@ -231,7 +231,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_plain(&format!(\n+        self.write_plain(format!(\n             \"test {} has been running for over {} seconds\\n\",\n             desc.name,\n             time::TEST_WARN_TIMEOUT_S\n@@ -267,11 +267,11 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n             state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n         );\n \n-        self.write_plain(&s)?;\n+        self.write_plain(s)?;\n \n         if let Some(ref exec_time) = state.exec_time {\n             let time_str = format!(\"; finished in {exec_time}\");\n-            self.write_plain(&time_str)?;\n+            self.write_plain(time_str)?;\n         }\n \n         self.write_plain(\"\\n\\n\")?;"}, {"sha": "0837ab16905130c18cd6c5086af909075c3d8feb", "filename": "library/test/src/formatters/terse.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -70,7 +70,7 @@ impl<T: Write> TerseFormatter<T> {\n             // screen when dealing with line-buffered output (e.g., piping to\n             // `stamp` in the rust CI).\n             let out = format!(\" {}/{}\\n\", self.test_count + 1, self.total_test_count);\n-            self.write_plain(&out)?;\n+            self.write_plain(out)?;\n         }\n \n         self.test_count += 1;\n@@ -106,7 +106,7 @@ impl<T: Write> TerseFormatter<T> {\n         self.write_plain(\"\\nsuccesses:\\n\")?;\n         let mut successes = Vec::new();\n         let mut stdouts = String::new();\n-        for &(ref f, ref stdout) in &state.not_failures {\n+        for (f, stdout) in &state.not_failures {\n             successes.push(f.name.to_string());\n             if !stdout.is_empty() {\n                 stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n@@ -132,7 +132,7 @@ impl<T: Write> TerseFormatter<T> {\n         self.write_plain(\"\\nfailures:\\n\")?;\n         let mut failures = Vec::new();\n         let mut fail_out = String::new();\n-        for &(ref f, ref stdout) in &state.failures {\n+        for (f, stdout) in &state.failures {\n             failures.push(f.name.to_string());\n             if !stdout.is_empty() {\n                 fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n@@ -157,9 +157,9 @@ impl<T: Write> TerseFormatter<T> {\n     fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n         let name = desc.padded_name(self.max_name_len, desc.name.padding());\n         if let Some(test_mode) = desc.test_mode() {\n-            self.write_plain(&format!(\"test {name} - {test_mode} ... \"))?;\n+            self.write_plain(format!(\"test {name} - {test_mode} ... \"))?;\n         } else {\n-            self.write_plain(&format!(\"test {name} ... \"))?;\n+            self.write_plain(format!(\"test {name} ... \"))?;\n         }\n \n         Ok(())\n@@ -175,7 +175,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         } else {\n             String::new()\n         };\n-        self.write_plain(&format!(\"\\nrunning {test_count} {noun}{shuffle_seed_msg}\\n\"))\n+        self.write_plain(format!(\"\\nrunning {test_count} {noun}{shuffle_seed_msg}\\n\"))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n@@ -209,13 +209,13 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n                     self.write_test_name(desc)?;\n                 }\n                 self.write_bench()?;\n-                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+                self.write_plain(format!(\": {}\\n\", fmt_bench_samples(bs)))\n             }\n         }\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_plain(&format!(\n+        self.write_plain(format!(\n             \"test {} has been running for over {} seconds\\n\",\n             desc.name,\n             time::TEST_WARN_TIMEOUT_S\n@@ -245,11 +245,11 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n             state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n         );\n \n-        self.write_plain(&s)?;\n+        self.write_plain(s)?;\n \n         if let Some(ref exec_time) = state.exec_time {\n             let time_str = format!(\"; finished in {exec_time}\");\n-            self.write_plain(&time_str)?;\n+            self.write_plain(time_str)?;\n         }\n \n         self.write_plain(\"\\n\\n\")?;"}, {"sha": "30dc4ff855315d2c0f0bca55669d580e50d7f92e", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -789,7 +789,7 @@ fn run_test_in_spawned_subprocess(\n         }\n     });\n     let record_result2 = record_result.clone();\n-    panic::set_hook(Box::new(move |info| record_result2(Some(&info))));\n+    panic::set_hook(Box::new(move |info| record_result2(Some(info))));\n     if let Err(message) = testfn() {\n         panic!(\"{}\", message);\n     }"}, {"sha": "67ba89410cd9974ed2cee345279100e6e2e68254", "filename": "library/test/src/term/terminfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -149,7 +149,7 @@ impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n         // are there any terminals that have color/attrs and not sgr0?\n         // Try falling back to sgr, then op\n         let cmd = match [\"sgr0\", \"sgr\", \"op\"].iter().find_map(|cap| self.ti.strings.get(*cap)) {\n-            Some(op) => match expand(&op, &[], &mut Variables::new()) {\n+            Some(op) => match expand(op, &[], &mut Variables::new()) {\n                 Ok(cmd) => cmd,\n                 Err(e) => return Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n             },\n@@ -180,12 +180,12 @@ impl<T: Write + Send> TerminfoTerminal<T> {\n     }\n \n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n-        if color >= self.num_colors && color >= 8 && color < 16 { color - 8 } else { color }\n+        if color >= self.num_colors && (8..16).contains(&color) { color - 8 } else { color }\n     }\n \n     fn apply_cap(&mut self, cmd: &str, params: &[Param]) -> io::Result<bool> {\n         match self.ti.strings.get(cmd) {\n-            Some(cmd) => match expand(&cmd, params, &mut Variables::new()) {\n+            Some(cmd) => match expand(cmd, params, &mut Variables::new()) {\n                 Ok(s) => self.out.write_all(&s).and(Ok(true)),\n                 Err(e) => Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n             },"}, {"sha": "2815f6cfc77fe5058d0c77d7bf7f5be27002faef", "filename": "library/test/src/term/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -282,14 +282,14 @@ pub(crate) fn expand(\n                 );\n             }\n             SetVar => {\n-                if cur >= 'A' && cur <= 'Z' {\n+                if cur.is_ascii_uppercase() {\n                     if let Some(arg) = stack.pop() {\n                         let idx = (cur as u8) - b'A';\n                         vars.sta_va[idx as usize] = arg;\n                     } else {\n                         return Err(\"stack is empty\".to_string());\n                     }\n-                } else if cur >= 'a' && cur <= 'z' {\n+                } else if cur.is_ascii_lowercase() {\n                     if let Some(arg) = stack.pop() {\n                         let idx = (cur as u8) - b'a';\n                         vars.dyn_va[idx as usize] = arg;\n@@ -301,10 +301,10 @@ pub(crate) fn expand(\n                 }\n             }\n             GetVar => {\n-                if cur >= 'A' && cur <= 'Z' {\n+                if cur.is_ascii_uppercase() {\n                     let idx = (cur as u8) - b'A';\n                     stack.push(vars.sta_va[idx as usize].clone());\n-                } else if cur >= 'a' && cur <= 'z' {\n+                } else if cur.is_ascii_lowercase() {\n                     let idx = (cur as u8) - b'a';\n                     stack.push(vars.dyn_va[idx as usize].clone());\n                 } else {"}, {"sha": "87b91f34498a37085fd81b98fbbe8e60f798e54f", "filename": "library/test/src/term/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n \n     if let Ok(dirs) = env::var(\"TERMINFO_DIRS\") {\n         for i in dirs.split(':') {\n-            if i == \"\" {\n+            if i.is_empty() {\n                 dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n             } else {\n                 dirs_to_search.push(PathBuf::from(i));\n@@ -49,7 +49,7 @@ pub(crate) fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     for mut p in dirs_to_search {\n         if fs::metadata(&p).is_ok() {\n             p.push(&first_char.to_string());\n-            p.push(&term);\n+            p.push(term);\n             if fs::metadata(&p).is_ok() {\n                 return Some(p);\n             }"}, {"sha": "1da238e3e8c0fbd3fd1b5e7cf89a04a95263fed6", "filename": "library/test/src/test_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Ftest_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Ftest_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftest_result.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -33,7 +33,7 @@ pub fn calc_result<'a>(\n ) -> TestResult {\n     let result = match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TestResult::TrOk,\n-        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n+        (&ShouldPanic::YesWithMessage(msg), Err(err)) => {\n             let maybe_panic_str = err\n                 .downcast_ref::<String>()\n                 .map(|e| &**e)\n@@ -52,7 +52,7 @@ pub fn calc_result<'a>(\n                     r#\"expected panic with string value,\n  found non-string value: `{:?}`\n      expected substring: `{:?}`\"#,\n-                    (**err).type_id(),\n+                    (*err).type_id(),\n                     msg\n                 ))\n             }"}, {"sha": "6f2e033095a37b9a7baacd89d3d4d6aae6401448", "filename": "library/test/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/library%2Ftest%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftypes.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -47,7 +47,7 @@ impl TestName {\n         match *self {\n             StaticTestName(s) => s,\n             DynTestName(ref s) => s,\n-            AlignedTestName(ref s, _) => &*s,\n+            AlignedTestName(ref s, _) => s,\n         }\n     }\n "}, {"sha": "4a0ba5925773e573e9862819ac10345f6c319cac", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -36,6 +36,7 @@ dependencies = [\n name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n+ \"build_helper\",\n  \"cc\",\n  \"cmake\",\n  \"fd-lock\",\n@@ -70,6 +71,10 @@ dependencies = [\n  \"regex-automata\",\n ]\n \n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"cc\"\n version = \"1.0.73\""}, {"sha": "22ceeca941e932872474ce0a3f549de91eece093", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -30,6 +30,7 @@ path = \"bin/sccache-plus-cl.rs\"\n test = false\n \n [dependencies]\n+build_helper = { path = \"../tools/build_helper\" }\n cmake = \"0.1.38\"\n fd-lock = \"3.0.8\"\n filetime = \"0.2\""}, {"sha": "f3998e98583ecd32d564590389104cb35d95d3ff", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -934,8 +934,7 @@ def main():\n     if len(sys.argv) > 1 and sys.argv[1] == 'help':\n         sys.argv = [sys.argv[0], '-h'] + sys.argv[2:]\n \n-    help_triggered = (\n-        '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n+    help_triggered = len(sys.argv) == 1 or any(x in [\"-h\", \"--help\", \"--version\"] for x in sys.argv)\n     try:\n         bootstrap(help_triggered)\n         if not help_triggered:"}, {"sha": "68215790bed177e3fdd3b4376da622b612bc689a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2067,6 +2067,9 @@ impl Step for RustDev {\n \n         builder.ensure(crate::native::Llvm { target });\n \n+        // We want to package `lld` to use it with `download-ci-llvm`.\n+        builder.ensure(crate::native::Lld { target });\n+\n         let src_bindir = builder.llvm_out(target).join(\"bin\");\n         // If updating this list, you likely want to change\n         // src/bootstrap/download-ci-llvm-stamp as well, otherwise local users"}, {"sha": "94630e40f3c4ca5a68e3bd5e149fa190fd265b15", "filename": "src/bootstrap/download-ci-llvm-stamp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload-ci-llvm-stamp?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,4 +1,4 @@\n Change this file to make users of the `download-ci-llvm` configuration download\n a new version of LLVM from CI, even if the LLVM submodule hasn\u2019t changed.\n \n-Last change is for: https://github.com/rust-lang/rust/pull/102790\n+Last change is for: https://github.com/rust-lang/rust/pull/104748"}, {"sha": "bfc57a85cdb42bdd106098ae9e4fc3bc707904de", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 34, "deletions": 44, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,7 +1,8 @@\n //! Runs rustfmt on the repository.\n \n use crate::builder::Builder;\n-use crate::util::{output, program_out_of_date, t};\n+use crate::util::{output, output_result, program_out_of_date, t};\n+use build_helper::git::updated_master_branch;\n use ignore::WalkBuilder;\n use std::collections::VecDeque;\n use std::path::{Path, PathBuf};\n@@ -78,50 +79,24 @@ fn update_rustfmt_version(build: &Builder<'_>) {\n /// rust-lang/master and what is now on the disk.\n ///\n /// Returns `None` if all files should be formatted.\n-fn get_modified_rs_files(build: &Builder<'_>) -> Option<Vec<String>> {\n-    let Ok(remote) = get_rust_lang_rust_remote() else { return None; };\n+fn get_modified_rs_files(build: &Builder<'_>) -> Result<Option<Vec<String>>, String> {\n+    let Ok(updated_master) = updated_master_branch(Some(&build.config.src)) else { return Ok(None); };\n+\n     if !verify_rustfmt_version(build) {\n-        return None;\n+        return Ok(None);\n     }\n \n     let merge_base =\n-        output(build.config.git().arg(\"merge-base\").arg(&format!(\"{remote}/master\")).arg(\"HEAD\"));\n-    Some(\n-        output(build.config.git().arg(\"diff-index\").arg(\"--name-only\").arg(merge_base.trim()))\n-            .lines()\n-            .map(|s| s.trim().to_owned())\n-            .filter(|f| Path::new(f).extension().map_or(false, |ext| ext == \"rs\"))\n-            .collect(),\n-    )\n-}\n-\n-/// Finds the remote for rust-lang/rust.\n-/// For example for these remotes it will return `upstream`.\n-/// ```text\n-/// origin  https://github.com/Nilstrieb/rust.git (fetch)\n-/// origin  https://github.com/Nilstrieb/rust.git (push)\n-/// upstream        https://github.com/rust-lang/rust (fetch)\n-/// upstream        https://github.com/rust-lang/rust (push)\n-/// ```\n-fn get_rust_lang_rust_remote() -> Result<String, String> {\n-    let mut git = Command::new(\"git\");\n-    git.args([\"config\", \"--local\", \"--get-regex\", \"remote\\\\..*\\\\.url\"]);\n-\n-    let output = git.output().map_err(|err| format!(\"{err:?}\"))?;\n-    if !output.status.success() {\n-        return Err(\"failed to execute git config command\".to_owned());\n-    }\n-\n-    let stdout = String::from_utf8(output.stdout).map_err(|err| format!(\"{err:?}\"))?;\n-\n-    let rust_lang_remote = stdout\n+        output_result(build.config.git().arg(\"merge-base\").arg(&updated_master).arg(\"HEAD\"))?;\n+    Ok(Some(\n+        output_result(\n+            build.config.git().arg(\"diff-index\").arg(\"--name-only\").arg(merge_base.trim()),\n+        )?\n         .lines()\n-        .find(|remote| remote.contains(\"rust-lang\"))\n-        .ok_or_else(|| \"rust-lang/rust remote not found\".to_owned())?;\n-\n-    let remote_name =\n-        rust_lang_remote.split('.').nth(1).ok_or_else(|| \"remote name not found\".to_owned())?;\n-    Ok(remote_name.into())\n+        .map(|s| s.trim().to_owned())\n+        .filter(|f| Path::new(f).extension().map_or(false, |ext| ext == \"rs\"))\n+        .collect(),\n+    ))\n }\n \n #[derive(serde::Deserialize)]\n@@ -158,6 +133,9 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n         Ok(status) => status.success(),\n         Err(_) => false,\n     };\n+\n+    let mut paths = paths.to_vec();\n+\n     if git_available {\n         let in_working_tree = match build\n             .config\n@@ -191,10 +169,21 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n                 ignore_fmt.add(&format!(\"!/{}\", untracked_path)).expect(&untracked_path);\n             }\n             if !check && paths.is_empty() {\n-                if let Some(files) = get_modified_rs_files(build) {\n-                    for file in files {\n-                        println!(\"formatting modified file {file}\");\n-                        ignore_fmt.add(&format!(\"/{file}\")).expect(&file);\n+                match get_modified_rs_files(build) {\n+                    Ok(Some(files)) => {\n+                        for file in files {\n+                            println!(\"formatting modified file {file}\");\n+                            ignore_fmt.add(&format!(\"/{file}\")).expect(&file);\n+                        }\n+                    }\n+                    Ok(None) => {}\n+                    Err(err) => {\n+                        println!(\n+                            \"WARN: Something went wrong when running git commands:\\n{err}\\n\\\n+                            Falling back to formatting all files.\"\n+                        );\n+                        // Something went wrong when getting the version. Just format all the files.\n+                        paths.push(\".\".into());\n                     }\n                 }\n             }\n@@ -204,6 +193,7 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n     } else {\n         println!(\"Could not find usable git. Skipping git-aware format checks\");\n     }\n+\n     let ignore_fmt = ignore_fmt.build().unwrap();\n \n     let rustfmt_path = build.initial_rustfmt().unwrap_or_else(|| {"}, {"sha": "d44b96cfb991ece07a53944f225a0624737b2921", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -113,6 +113,7 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n \n+use build_helper::ci::CiEnv;\n use channel::GitInfo;\n use config::{DryRun, Target};\n use filetime::FileTime;\n@@ -121,7 +122,7 @@ use once_cell::sync::OnceCell;\n use crate::builder::Kind;\n use crate::config::{LlvmLibunwind, TargetSelection};\n use crate::util::{\n-    exe, libdir, mtime, output, run, run_suppressed, symlink_dir, try_run_suppressed, CiEnv,\n+    exe, libdir, mtime, output, run, run_suppressed, symlink_dir, try_run_suppressed,\n };\n \n mod bolt;"}, {"sha": "89bb2b770f90deba19893bf5b5a193b887a97ffa", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -24,6 +24,8 @@ use crate::util::get_clang_cl_resource_dir;\n use crate::util::{self, exe, output, t, up_to_date};\n use crate::{CLang, GitRepo};\n \n+use build_helper::ci::CiEnv;\n+\n #[derive(Clone)]\n pub struct LlvmResult {\n     /// Path to llvm-config binary.\n@@ -63,13 +65,13 @@ impl LdFlags {\n     }\n }\n \n-// This returns whether we've already previously built LLVM.\n-//\n-// It's used to avoid busting caches during x.py check -- if we've already built\n-// LLVM, it's fine for us to not try to avoid doing so.\n-//\n-// This will return the llvm-config if it can get it (but it will not build it\n-// if not).\n+/// This returns whether we've already previously built LLVM.\n+///\n+/// It's used to avoid busting caches during x.py check -- if we've already built\n+/// LLVM, it's fine for us to not try to avoid doing so.\n+///\n+/// This will return the llvm-config if it can get it (but it will not build it\n+/// if not).\n pub fn prebuilt_llvm_config(\n     builder: &Builder<'_>,\n     target: TargetSelection,\n@@ -217,7 +219,7 @@ pub(crate) fn is_ci_llvm_available(config: &Config, asserts: bool) -> bool {\n         return false;\n     }\n \n-    if crate::util::CiEnv::is_ci() {\n+    if CiEnv::is_ci() {\n         // We assume we have access to git, so it's okay to unconditionally pass\n         // `true` here.\n         let llvm_sha = detect_llvm_sha(config, true);\n@@ -823,8 +825,21 @@ impl Step for Lld {\n         }\n         let target = self.target;\n \n-        let LlvmResult { llvm_config, llvm_cmake_dir } =\n-            builder.ensure(Llvm { target: self.target });\n+        let LlvmResult { llvm_config, llvm_cmake_dir } = builder.ensure(Llvm { target });\n+\n+        // The `dist` step packages LLD next to LLVM's binaries for download-ci-llvm. The root path\n+        // we usually expect here is `./build/$triple/ci-llvm/`, with the binaries in its `bin`\n+        // subfolder. We check if that's the case, and if LLD's binary already exists there next to\n+        // `llvm-config`: if so, we can use it instead of building LLVM/LLD from source.\n+        let ci_llvm_bin = llvm_config.parent().unwrap();\n+        if ci_llvm_bin.is_dir() && ci_llvm_bin.file_name().unwrap() == \"bin\" {\n+            let lld_path = ci_llvm_bin.join(exe(\"lld\", target));\n+            if lld_path.exists() {\n+                // The following steps copying `lld` as `rust-lld` to the sysroot, expect it in the\n+                // `bin` subfolder of this step's out dir.\n+                return ci_llvm_bin.parent().unwrap().to_path_buf();\n+            }\n+        }\n \n         let out_dir = builder.lld_out(target);\n         let done_stamp = out_dir.join(\"lld-finished-building\");\n@@ -1072,12 +1087,12 @@ fn supported_sanitizers(\n \n     match &*target.triple {\n         \"aarch64-apple-darwin\" => darwin_libs(\"osx\", &[\"asan\", \"lsan\", \"tsan\"]),\n-        \"aarch64-fuchsia\" => common_libs(\"fuchsia\", \"aarch64\", &[\"asan\"]),\n+        \"aarch64-unknown-fuchsia\" => common_libs(\"fuchsia\", \"aarch64\", &[\"asan\"]),\n         \"aarch64-unknown-linux-gnu\" => {\n             common_libs(\"linux\", \"aarch64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\", \"hwasan\"])\n         }\n         \"x86_64-apple-darwin\" => darwin_libs(\"osx\", &[\"asan\", \"lsan\", \"tsan\"]),\n-        \"x86_64-fuchsia\" => common_libs(\"fuchsia\", \"x86_64\", &[\"asan\"]),\n+        \"x86_64-unknown-fuchsia\" => common_libs(\"fuchsia\", \"x86_64\", &[\"asan\"]),\n         \"x86_64-unknown-freebsd\" => common_libs(\"freebsd\", \"x86_64\", &[\"asan\", \"msan\", \"tsan\"]),\n         \"x86_64-unknown-netbsd\" => {\n             common_libs(\"netbsd\", \"x86_64\", &[\"asan\", \"lsan\", \"msan\", \"tsan\"])"}, {"sha": "e0280854541a0d95b6979a84b2157c8e1966e55f", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -105,6 +105,7 @@ impl Step for BumpStage0 {\n \n     fn run(self, builder: &Builder<'_>) -> Self::Output {\n         let mut cmd = builder.tool_cmd(Tool::BumpStage0);\n+        cmd.args(builder.config.cmd.args());\n         builder.run(&mut cmd);\n     }\n }"}, {"sha": "ca4feac6fac70f21e9bbc0accdcc4aee9e910074", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -351,7 +351,7 @@ pub fn interactive_path() -> io::Result<Profile> {\n     Ok(template)\n }\n \n-// install a git hook to automatically run tidy --bless, if they want\n+// install a git hook to automatically run tidy, if they want\n fn install_git_hook_maybe(config: &Config) -> io::Result<()> {\n     let git = t!(config.git().args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(|output| {\n         assert!(output.status.success(), \"failed to run `git`\");\n@@ -367,7 +367,7 @@ fn install_git_hook_maybe(config: &Config) -> io::Result<()> {\n     println!();\n     println!(\n         \"Rust's CI will automatically fail if it doesn't pass `tidy`, the internal tool for ensuring code quality.\n-If you'd like, x.py can install a git hook for you that will automatically run `tidy --bless` before\n+If you'd like, x.py can install a git hook for you that will automatically run `test tidy` before\n pushing your code to ensure your code is up to par. If you decide later that this behavior is\n undesirable, simply delete the `pre-push` file from .git/hooks.\"\n     );"}, {"sha": "93e53d383cd39daa00485a0f46dd9277056d918d", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -255,35 +255,6 @@ pub enum CiEnv {\n     GitHubActions,\n }\n \n-impl CiEnv {\n-    /// Obtains the current CI environment.\n-    pub fn current() -> CiEnv {\n-        if env::var(\"TF_BUILD\").map_or(false, |e| e == \"True\") {\n-            CiEnv::AzurePipelines\n-        } else if env::var(\"GITHUB_ACTIONS\").map_or(false, |e| e == \"true\") {\n-            CiEnv::GitHubActions\n-        } else {\n-            CiEnv::None\n-        }\n-    }\n-\n-    pub fn is_ci() -> bool {\n-        Self::current() != CiEnv::None\n-    }\n-\n-    /// If in a CI environment, forces the command to run with colors.\n-    pub fn force_coloring_in_ci(self, cmd: &mut Command) {\n-        if self != CiEnv::None {\n-            // Due to use of stamp/docker, the output stream of rustbuild is not\n-            // a TTY in CI, so coloring is by-default turned off.\n-            // The explicit `TERM=xterm` environment is needed for\n-            // `--color always` to actually work. This env var was lost when\n-            // compiling through the Makefile. Very strange.\n-            cmd.env(\"TERM\", \"xterm\").args(&[\"--color\", \"always\"]);\n-        }\n-    }\n-}\n-\n pub fn forcing_clang_based_tests() -> bool {\n     if let Some(var) = env::var_os(\"RUSTBUILD_FORCE_CLANG_BASED_TESTS\") {\n         match &var.to_string_lossy().to_lowercase()[..] {\n@@ -441,6 +412,23 @@ pub fn output(cmd: &mut Command) -> String {\n     String::from_utf8(output.stdout).unwrap()\n }\n \n+pub fn output_result(cmd: &mut Command) -> Result<String, String> {\n+    let output = match cmd.stderr(Stdio::inherit()).output() {\n+        Ok(status) => status,\n+        Err(e) => return Err(format!(\"failed to run command: {:?}: {}\", cmd, e)),\n+    };\n+    if !output.status.success() {\n+        return Err(format!(\n+            \"command did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n{}\",\n+            cmd,\n+            output.status,\n+            String::from_utf8(output.stderr).map_err(|err| format!(\"{err:?}\"))?\n+        ));\n+    }\n+    Ok(String::from_utf8(output.stdout).map_err(|err| format!(\"{err:?}\"))?)\n+}\n+\n /// Returns the last-modified time for `path`, or zero if it doesn't exist.\n pub fn mtime(path: &Path) -> SystemTime {\n     fs::metadata(path).and_then(|f| f.modified()).unwrap_or(UNIX_EPOCH)"}, {"sha": "0f5df95a0dd4bce79eb176e51646271f8fd25f14", "filename": "src/ci/docker/host-x86_64/dist-various-2/Dockerfile", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -30,18 +30,18 @@ RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7\n RUN add-apt-repository -y 'deb https://apt.dilos.org/dilos dilos2 main'\n \n ENV \\\n-    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n-    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n-    CFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n-    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n-    CXXFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n-    LDFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot -L/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/lib\" \\\n-    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n-    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n-    CFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n-    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n-    CXXFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n-    LDFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot -L/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/lib\" \\\n+    AR_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-ar \\\n+    CC_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang \\\n+    CFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n+    CXX_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang++ \\\n+    CXXFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n+    LDFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot -L/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/lib\" \\\n+    AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n+    CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n+    CFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n+    CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++ \\\n+    CXXFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot -I/usr/local/core-linux-amd64-fuchsia-sdk/pkg/fdio/include\" \\\n+    LDFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot -L/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/lib\" \\\n     AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n     CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n     CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n@@ -99,19 +99,19 @@ RUN /tmp/freebsd-toolchain.sh i686\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n-ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n+ENV CARGO_TARGET_X86_64_UNKNOWN_FUCHSIA_AR /usr/local/bin/llvm-ar\n+ENV CARGO_TARGET_X86_64_UNKNOWN_FUCHSIA_RUSTFLAGS \\\n -C link-arg=--sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot \\\n -Lnative=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/sysroot/lib \\\n -Lnative=/usr/local/core-linux-amd64-fuchsia-sdk/arch/x64/lib\n-ENV CARGO_TARGET_AARCH64_FUCHSIA_AR /usr/local/bin/llvm-ar\n-ENV CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS \\\n+ENV CARGO_TARGET_AARCH64_UNKNOWN_FUCHSIA_AR /usr/local/bin/llvm-ar\n+ENV CARGO_TARGET_AARCH64_UNKNOWN_FUCHSIA_RUSTFLAGS \\\n -C link-arg=--sysroot=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot \\\n -Lnative=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/sysroot/lib \\\n -Lnative=/usr/local/core-linux-amd64-fuchsia-sdk/arch/arm64/lib\n \n-ENV TARGETS=x86_64-fuchsia\n-ENV TARGETS=$TARGETS,aarch64-fuchsia\n+ENV TARGETS=x86_64-unknown-fuchsia\n+ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n ENV TARGETS=$TARGETS,wasm32-wasi\n ENV TARGETS=$TARGETS,sparcv9-sun-solaris"}, {"sha": "d762b4672c62ec0e49b8ecbd23cc378cc37a8ffd", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-fuchsia-toolchain.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -29,9 +29,9 @@ install_clang() {\n   # CFLAGS and CXXFLAGS env variables in main Dockerfile handle sysroot linking\n   for arch in x86_64 aarch64; do\n     for tool in clang clang++; do\n-      ln -s /usr/local/bin/${tool} /usr/local/bin/${arch}-fuchsia-${tool}\n+      ln -s /usr/local/bin/${tool} /usr/local/bin/${arch}-unknown-fuchsia-${tool}\n     done\n-    ln -s /usr/local/bin/llvm-ar /usr/local/bin/${arch}-fuchsia-ar\n+    ln -s /usr/local/bin/llvm-ar /usr/local/bin/${arch}-unknown-fuchsia-ar\n   done\n \n   popd > /dev/null"}, {"sha": "c39e9c5fbc9d6e0e02eeb4fe453d25ea3e11ff21", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1 +1 @@\n-0.13.4\n\\ No newline at end of file\n+0.14.1\n\\ No newline at end of file"}, {"sha": "c8d1ff9aefb7e49c96b5c151edb1f351afa88193", "filename": "src/ci/docker/scripts/fuchsia-test-runner.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -4,7 +4,7 @@\n The Rust toolchain test runner for Fuchsia.\n \n For instructions on running the compiler test suite, see\n-https://doc.rust-lang.org/stable/rustc/platform-support/fuchsia.html#aarch64-fuchsia-and-x86_64-fuchsia\n+https://doc.rust-lang.org/stable/rustc/platform-support/fuchsia.html#aarch64-unknown-fuchsia-and-x86_64-unknown-fuchsia\n \"\"\"\n \n import argparse\n@@ -110,9 +110,9 @@ def repo_dir(self):\n \n     def rustlib_dir(self):\n         if self.target_arch == \"x64\":\n-            return \"x86_64-fuchsia\"\n+            return \"x86_64-unknown-fuchsia\"\n         if self.target_arch == \"arm64\":\n-            return \"aarch64-fuchsia\"\n+            return \"aarch64-unknown-fuchsia\"\n         raise Exception(f\"Unrecognized target architecture {self.target_arch}\")\n \n     def libs_dir(self):"}, {"sha": "752f1cc4aba0304675f7b0e4bb49a1df67c069f7", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -22,10 +22,11 @@\n     - [armv4t-none-eabi](platform-support/armv4t-none-eabi.md)\n     - [armv5te-none-eabi](platform-support/armv5te-none-eabi.md)\n     - [armv6k-nintendo-3ds](platform-support/armv6k-nintendo-3ds.md)\n+    - [armv7-sony-vita-newlibeabihf](platform-support/armv7-sony-vita-newlibeabihf.md)\n     - [armv7-unknown-linux-uclibceabi](platform-support/armv7-unknown-linux-uclibceabi.md)\n     - [armv7-unknown-linux-uclibceabihf](platform-support/armv7-unknown-linux-uclibceabihf.md)\n     - [\\*-android and \\*-androideabi](platform-support/android.md)\n-    - [\\*-fuchsia](platform-support/fuchsia.md)\n+    - [\\*-unknown-fuchsia](platform-support/fuchsia.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n     - [m68k-unknown-linux-gnu](platform-support/m68k-unknown-linux-gnu.md)\n     - [mips64-openwrt-linux-musl](platform-support/mips64-openwrt-linux-musl.md)"}, {"sha": "7ff26e420f1b3bdaec0684f812babc2d978e84cf", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -124,7 +124,7 @@ target | std | notes\n -------|:---:|-------\n `aarch64-apple-ios` | \u2713 | ARM64 iOS\n [`aarch64-apple-ios-sim`](platform-support/aarch64-apple-ios-sim.md) | \u2713 | Apple iOS Simulator on ARM64\n-`aarch64-fuchsia` | \u2713 | ARM64 Fuchsia\n+`aarch64-unknown-fuchsia` | \u2713 | ARM64 Fuchsia\n [`aarch64-linux-android`](platform-support/android.md) | \u2713 | ARM64 Android\n `aarch64-unknown-none-softfloat` | * | Bare ARM64, softfloat\n `aarch64-unknown-none` | * | Bare ARM64, hardfloat\n@@ -177,7 +177,7 @@ target | std | notes\n `wasm32-wasi` | \u2713 | WebAssembly with WASI\n `x86_64-apple-ios` | \u2713 | 64-bit x86 iOS\n [`x86_64-fortanix-unknown-sgx`](platform-support/x86_64-fortanix-unknown-sgx.md) | \u2713 | [Fortanix ABI] for 64-bit Intel SGX\n-`x86_64-fuchsia` | \u2713 | 64-bit Fuchsia\n+`x86_64-unknown-fuchsia` | \u2713 | 64-bit Fuchsia\n [`x86_64-linux-android`](platform-support/android.md) | \u2713 | 64-bit x86 Android\n `x86_64-pc-solaris` | \u2713 | 64-bit Solaris 10/11, illumos\n `x86_64-unknown-linux-gnux32` | \u2713 | 64-bit Linux (x32 ABI) (kernel 4.15, glibc 2.27)\n@@ -235,6 +235,7 @@ target | std | host | notes\n `armv6-unknown-netbsd-eabihf` | ? |  |\n [`armv6k-nintendo-3ds`](platform-support/armv6k-nintendo-3ds.md) | ? |  | ARMv6K Nintendo 3DS, Horizon (Requires devkitARM toolchain)\n `armv7-apple-ios` | \u2713 |  | ARMv7 iOS, Cortex-a8\n+[`armv7-sony-vita-newlibeabihf`](platform-support/armv7-sony-vita-newlibeabihf.md) | ? |  | ARM Cortex-A9 Sony PlayStation Vita (requires VITASDK toolchain)\n [`armv7-unknown-linux-uclibceabi`](platform-support/armv7-unknown-linux-uclibceabi.md) | \u2713 | \u2713 | ARMv7 Linux with uClibc, softfloat\n [`armv7-unknown-linux-uclibceabihf`](platform-support/armv7-unknown-linux-uclibceabihf.md) | \u2713 | ? | ARMv7 Linux with uClibc, hardfloat\n `armv7-unknown-freebsd` | \u2713 | \u2713 | ARMv7 FreeBSD"}, {"sha": "6619c90b849d829f172825008397cfebda86384f", "filename": "src/doc/rustc/src/platform-support/armv7-sony-vita-eabihf.md", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-eabihf.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-eabihf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Farmv7-sony-vita-eabihf.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -0,0 +1,127 @@\n+# armv7-sony-vita-eabihf\n+\n+**Tier: 3**\n+\n+This tier supports the ARM Cortex A9 processor running on a PlayStation Vita console. `armv7-vita-newlibeabihf` aims to have support for `std` crate using `newlib` as a bridge.\n+\n+## Designated Developers\n+\n+* [@amg98](https://github.com/amg98)\n+\n+## Requirements\n+\n+This target is cross compiled, and requires installing [VITASDK](https://vitasdk.org/) toolchain on your system.\n+\n+## Building\n+\n+You can build Rust with support for the target by adding it to the `target`\n+list in `config.toml`:\n+\n+```toml\n+[build]\n+build-stage = 1\n+target = [\"armv7-sony-vita-newlibeabihf\"]\n+```\n+\n+## Cross-compilation\n+\n+This target can be cross-compiled from `x86_64` on either Windows, MacOS or Linux systems. Other hosts are not supported for cross-compilation.\n+\n+## Testing\n+\n+Currently there is no support to run the rustc test suite for this target.\n+\n+## Building and Running Rust Programs\n+\n+To test your developed rust programs for PlayStation Vita, first you have to prepare a proper executable for the device using the resulting ELF file you get from compilation step. The needed steps can be automated using tools like `cargo-make`. Use the example below as a template for your project:\n+\n+```toml\n+[env]\n+TITLE = \"Rust Hello World\"\n+TITLEID = \"RUST00001\"\n+# At least a \"sce_sys\" folder should be place there for app metadata (title, icons, description...)\n+# You can find sample assets for that on $VITASDK/share/gcc-arm-vita-eabi/samples/hello_world/sce_sys/\n+STATIC_DIR = \"static\"   # Folder where static assets should be placed (sce_sys folder is at $STATIC_DIR/sce_sys)\n+CARGO_TARGET_DIR = { script = [\"echo ${CARGO_TARGET_DIR:=target}\"] }\n+RUST_TARGET_PATH = { script = [\"echo $(pwd)\"]}\n+RUST_TARGET = \"armv7-sony-vita-newlibeabihf\"\n+CARGO_OUT_DIR = \"${CARGO_TARGET_DIR}/${RUST_TARGET}/release\"\n+\n+[tasks.xbuild]\n+# This is the command where you get the ELF executable file (e.g. call to cargo build)\n+\n+[tasks.strip]\n+description = \"Strip the produced ELF executable.\"\n+dependencies = [\"xbuild\"]\n+command = \"arm-vita-eabi-strip\"\n+args = [\"-g\", '${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_FS_NAME}.elf']\n+\n+[tasks.velf]\n+description = \"Build an VELF executable from the obtained ELF file.\"\n+dependencies = [\"strip\"]\n+command = \"vita-elf-create\"\n+args = ['${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_NAME}.elf', '${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_NAME}.velf']\n+\n+[tasks.eboot-bin]\n+description = \"Build an `eboot.bin` file from the obtained VELF file.\"\n+dependencies = [\"velf\"]\n+command = \"vita-make-fself\"\n+args = [\"-s\", '${CARGO_OUT_DIR}/${CARGO_MAKE_CRATE_NAME}.velf', '${CARGO_OUT_DIR}/eboot.bin']\n+\n+[tasks.param-sfo]\n+description = \"Build the `param.sfo` manifest using with given TITLE and TITLEID.\"\n+command = \"vita-mksfoex\"\n+args = [\"-s\", 'TITLE_ID=${TITLEID}', '${TITLE}', '${CARGO_OUT_DIR}/param.sfo']\n+\n+[tasks.manifest]\n+description = \"List all static resources into a manifest file.\"\n+script = [\n+  'mkdir -p \"${CARGO_OUT_DIR}\"',\n+  '''\n+  if [ -d \"${STATIC_DIR}\" ]; then\n+    find \"${STATIC_DIR}\" -type f > \"${CARGO_OUT_DIR}/MANIFEST\"\n+  else\n+    touch \"${CARGO_OUT_DIR}/MANIFEST\"\n+  fi\n+  '''\n+]\n+\n+[tasks.vpk]\n+description = \"Build a VPK distribution of the project executable and resources.\"\n+dependencies = [\"eboot-bin\", \"param-sfo\", \"manifest\"]\n+script_runner = \"@rust\"\n+script = [\n+    '''\n+    use std::io::BufRead;\n+    use std::fs::File;\n+\n+    fn main() {\n+\n+      let crate_name = env!(\"CARGO_MAKE_CRATE_NAME\");\n+      let static_dir = env!(\"STATIC_DIR\");\n+      let out_dir = std::path::PathBuf::from(env!(\"CARGO_OUT_DIR\"));\n+\n+      let mut cmd = ::std::process::Command::new(\"vita-pack-vpk\");\n+      cmd.arg(\"-s\").arg(out_dir.join(\"param.sfo\"));\n+      cmd.arg(\"-b\").arg(out_dir.join(\"eboot.bin\"));\n+\n+      // Add files from MANIFEST\n+      if let Ok(file) = File::open(out_dir.join(\"MANIFEST\")) {\n+          let mut reader = ::std::io::BufReader::new(file);\n+          let mut lines = reader.lines();\n+          while let Some(Ok(line)) = lines.next() {\n+              let p1 = ::std::path::PathBuf::from(line);            // path on FS\n+              let p2 = p1.strip_prefix(static_dir).unwrap();        // path in VPK\n+              cmd.arg(\"--add\").arg(format!(\"{}={}\", p1.display(), p2.display()));\n+          }\n+      }\n+\n+      cmd.arg(out_dir.join(format!(\"{}.vpk\", crate_name)))\n+        .output()\n+        .expect(\"command failed.\");\n+    }\n+    '''\n+]\n+```\n+\n+After running the above script, you should be able to get a *.vpk file in the same folder your *.elf executable resides. Now you can pick it and install it on your own PlayStation Vita using, for example, [VitaShell](https://github.com/TheOfficialFloW/VitaShell/releases) or you can use an emulator. For the time being, the most mature emulator for PlayStation Vita is [Vita3K](https://vita3k.org/), although I personally recommend testing your programs in real hardware, as the emulator is quite experimental."}, {"sha": "95c242cc161e9a388525c8a5a281e8c78d1559b1", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,4 +1,4 @@\n-# `aarch64-fuchsia` and `x86_64-fuchsia`\n+# `aarch64-unknown-fuchsia` and `x86_64-unknown-fuchsia`\n \n **Tier: 2**\n \n@@ -67,7 +67,7 @@ This walkthrough will cover:\n 1. Building a Fuchsia package.\n 1. Publishing and running a Fuchsia package to a Fuchsia emulator.\n \n-For the purposes of this walkthrough, we will only target `x86_64-fuchsia`.\n+For the purposes of this walkthrough, we will only target `x86_64-unknown-fuchsia`.\n \n ## Compiling a Rust binary targeting Fuchsia\n \n@@ -83,8 +83,8 @@ to handle the installation of Fuchsia targets for you. This can be done by issui\n the following commands:\n \n ```sh\n-rustup target add x86_64-fuchsia\n-rustup target add aarch64-fuchsia\n+rustup target add x86_64-unknown-fuchsia\n+rustup target add aarch64-unknown-fuchsia\n ```\n \n After installing our Fuchsia targets, we can now compile a Rust binary that targets\n@@ -127,7 +127,7 @@ during compilation:\n \n **`.cargo/config.toml`**\n ```txt\n-[target.x86_64-fuchsia]\n+[target.x86_64-unknown-fuchsia]\n \n rustflags = [\n     \"-Lnative=<SDK_PATH>/arch/x64/lib\",\n@@ -159,10 +159,10 @@ hello_fuchsia/\n Finally, we can build our rust binary as:\n \n ```sh\n-cargo build --target x86_64-fuchsia\n+cargo build --target x86_64-unknown-fuchsia\n ```\n \n-Now we have a Rust binary at `target/x86_64-fuchsia/debug/hello_fuchsia`,\n+Now we have a Rust binary at `target/x86_64-unknown-fuchsia/debug/hello_fuchsia`,\n targeting our desired Fuchsia target.\n \n **Current directory structure**\n@@ -171,7 +171,7 @@ hello_fuchsia/\n \u2523\u2501 src/\n \u2503  \u2517\u2501 main.rs\n \u2523\u2501 target/\n-\u2503  \u2517\u2501 x86_64-fuchsia/\n+\u2503  \u2517\u2501 x86_64-unknown-fuchsia/\n \u2503     \u2517\u2501 debug/\n \u2503        \u2517\u2501 hello_fuchsia\n \u2523\u2501 Cargo.toml\n@@ -193,16 +193,19 @@ configuration in `config.toml`:\n \n ```toml\n [build]\n-target = [\"<host_platform>\", \"aarch64-fuchsia\", \"x86_64-fuchsia\"]\n+target = [\"<host_platform>\", \"aarch64-unknown-fuchsia\", \"x86_64-unknown-fuchsia\"]\n \n [rust]\n lld = true\n \n-[target.x86_64-fuchsia]\n+[llvm]\n+download-ci-llvm = false\n+\n+[target.x86_64-unknown-fuchsia]\n cc = \"clang\"\n cxx = \"clang++\"\n \n-[target.aarch64-fuchsia]\n+[target.aarch64-unknown-fuchsia]\n cc = \"clang\"\n cxx = \"clang++\"\n ```\n@@ -233,14 +236,14 @@ a script we name `config-env.sh`:\n # Configure this environment variable to be the path to the downloaded SDK\n export SDK_PATH=\"<SDK path goes here>\"\n \n-export CFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n-export CXXFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n-export LDFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -L${SDK_PATH}/arch/arm64/lib\"\n-export CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/arm64/sysroot -Lnative=${SDK_PATH}/arch/arm64/sysroot/lib -Lnative=${SDK_PATH}/arch/arm64/lib\"\n-export CFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n-export CXXFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n-export LDFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -L${SDK_PATH}/arch/x64/lib\"\n-export CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/x64/sysroot -Lnative=${SDK_PATH}/arch/x64/sysroot/lib -Lnative=${SDK_PATH}/arch/x64/lib\"\n+export CFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export CXXFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export LDFLAGS_aarch64_unknown_fuchsia=\"--target=aarch64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -L${SDK_PATH}/arch/arm64/lib\"\n+export CARGO_TARGET_AARCH64_UNKNOWN_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/arm64/sysroot -Lnative=${SDK_PATH}/arch/arm64/sysroot/lib -Lnative=${SDK_PATH}/arch/arm64/lib\"\n+export CFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export CXXFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export LDFLAGS_x86_64_unknown_fuchsia=\"--target=x86_64-unknown-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -L${SDK_PATH}/arch/x64/lib\"\n+export CARGO_TARGET_X86_64_UNKNOWN_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/x64/sysroot -Lnative=${SDK_PATH}/arch/x64/sysroot/lib -Lnative=${SDK_PATH}/arch/x64/lib\"\n ```\n \n Finally, the Rust compiler can be built and installed:\n@@ -285,7 +288,7 @@ hello_fuchsia/\n Using your freshly installed `rustc`, you can compile a binary for Fuchsia using\n the following options:\n \n-* `--target x86_64-fuchsia`/`--target aarch64-fuchsia`: Targets the Fuchsia\n+* `--target x86_64-unknown-fuchsia`/`--target aarch64-unknown-fuchsia`: Targets the Fuchsia\n   platform of your choice\n * `-Lnative ${SDK_PATH}/arch/${ARCH}/lib`: Link against Fuchsia libraries from\n   the SDK\n@@ -296,7 +299,7 @@ Putting it all together:\n \n ```sh\n # Configure these for the Fuchsia target of your choice\n-TARGET_ARCH=\"<x86_64-fuchsia|aarch64-fuchsia>\"\n+TARGET_ARCH=\"<x86_64-unknown-fuchsia|aarch64-unknown-fuchsia>\"\n ARCH=\"<x64|aarch64>\"\n \n rustc \\\n@@ -322,16 +325,16 @@ Before moving on, double check your directory structure:\n **Current directory structure**\n ```txt\n hello_fuchsia/\n-\u2523\u2501 src/                     (if using rustc)\n-\u2503   \u2517\u2501 hello_fuchsia.rs     ...\n-\u2523\u2501 bin/                     ...\n-\u2503  \u2517\u2501 hello_fuchsia         ...\n-\u2523\u2501 src/                     (if using cargo)\n-\u2503  \u2517\u2501 main.rs               ...\n-\u2517\u2501 target/                  ...\n-   \u2517\u2501 x86_64-fuchsia/       ...\n-      \u2517\u2501 debug/             ...\n-         \u2517\u2501 hello_fuchsia   ...\n+\u2523\u2501 src/                         (if using rustc)\n+\u2503   \u2517\u2501 hello_fuchsia.rs         ...\n+\u2523\u2501 bin/                         ...\n+\u2503  \u2517\u2501 hello_fuchsia             ...\n+\u2523\u2501 src/                         (if using cargo)\n+\u2503  \u2517\u2501 main.rs                   ...\n+\u2517\u2501 target/                      ...\n+   \u2517\u2501 x86_64-unknown-fuchsia/   ...\n+      \u2517\u2501 debug/                 ...\n+         \u2517\u2501 hello_fuchsia       ...\n ```\n \n With our Rust binary built, we can move to creating a Fuchsia package.\n@@ -368,7 +371,7 @@ package must contain one.\n \n **`pkg/hello_fuchsia.manifest` if using cargo**\n ```txt\n-bin/hello_fuchsia=target/x86_64-fuchsia/debug/hello_fuchsia\n+bin/hello_fuchsia=target/x86_64-unknown-fuchsia/debug/hello_fuchsia\n lib/ld.so.1=<SDK_PATH>/arch/x64/sysroot/dist/lib/ld.so.1\n lib/libfdio.so=<SDK_PATH>/arch/x64/dist/libfdio.so\n meta/package=pkg/meta/package\n@@ -543,16 +546,16 @@ structure will look like:\n **Final directory structure**\n ```txt\n hello_fuchsia/\n-\u2523\u2501 src/                     (if using rustc)\n-\u2503   \u2517\u2501 hello_fuchsia.rs     ...\n-\u2523\u2501 bin/                     ...\n-\u2503  \u2517\u2501 hello_fuchsia         ...\n-\u2523\u2501 src/                     (if using cargo)\n-\u2503  \u2517\u2501 main.rs               ...\n-\u2523\u2501 target/                  ...\n-\u2503  \u2517\u2501 x86_64-fuchsia/       ...\n-\u2503     \u2517\u2501 debug/             ...\n-\u2503        \u2517\u2501 hello_fuchsia   ...\n+\u2523\u2501 src/                         (if using rustc)\n+\u2503   \u2517\u2501 hello_fuchsia.rs         ...\n+\u2523\u2501 bin/                         ...\n+\u2503  \u2517\u2501 hello_fuchsia             ...\n+\u2523\u2501 src/                         (if using cargo)\n+\u2503  \u2517\u2501 main.rs                   ...\n+\u2523\u2501 target/                      ...\n+\u2503  \u2517\u2501 x86_64-unknown-fuchsia/   ...\n+\u2503     \u2517\u2501 debug/                 ...\n+\u2503        \u2517\u2501 hello_fuchsia       ...\n \u2517\u2501 pkg/\n    \u2523\u2501 meta/\n    \u2503  \u2523\u2501 package\n@@ -641,8 +644,8 @@ Tests can be run in the same way as a regular binary.\n \n * If using `cargo`, you can simply pass `test --no-run`\n to the `cargo` invocation and then repackage and rerun the Fuchsia package. From our previous example,\n-this would look like `cargo test --target x86_64-fuchsia --no-run`, and moving the executable\n-binary path found from the line `Executable unittests src/main.rs (target/x86_64-fuchsia/debug/deps/hello_fuchsia-<HASH>)`\n+this would look like `cargo test --target x86_64-unknown-fuchsia --no-run`, and moving the executable\n+binary path found from the line `Executable unittests src/main.rs (target/x86_64-unknown-fuchsia/debug/deps/hello_fuchsia-<HASH>)`\n into `pkg/hello_fuchsia.manifest`.\n \n * If using the compiled `rustc`, you can simply pass `--test`\n@@ -711,7 +714,7 @@ run the full `src/test/ui` test suite:\n     --config config.toml                                                      \\\n     --stage=2                                                                 \\\n     test src/test/ui                                                          \\\n-    --target x86_64-fuchsia                                                   \\\n+    --target x86_64-unknown-fuchsia                                           \\\n     --run=always --jobs 1                                                     \\\n     --test-args --target-rustcflags                                           \\\n     --test-args -L                                                            \\\n@@ -755,7 +758,7 @@ directory to launch `zxdb`:\n **In separate terminal**\n ```sh\n ${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \\\n-    --symbol-path target/x86_64-fuchsia/debug\n+    --symbol-path target/x86_64-unknown-fuchsia/debug\n ```\n \n * `--symbol-path` gets required symbol paths, which are\n@@ -851,7 +854,7 @@ source code:\n \n ```sh\n ${SDK_PATH}/tools/${ARCH}/ffx debug connect -- \\\n-    --symbol-path target/x86_64-fuchsia/debug \\\n+    --symbol-path target/x86_64-unknown-fuchsia/debug \\\n     --build-dir ${RUST_SRC_PATH}/rust \\\n     --build-dir ${FUCHSIA_SRC_PATH}/fuchsia/out/default\n ```"}, {"sha": "a497a75261fede1f681c1c163b6453ae2289420a", "filename": "src/doc/unstable-book/src/compiler-flags/dump-mono-stats-format.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats-format.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats-format.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats-format.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -0,0 +1,6 @@\n+# `dump-mono-stats-format`\n+\n+--------------------\n+\n+The `-Z dump-mono-stats-format` compiler flag controls what file format to use for `-Z dump-mono-stats`.\n+The default is markdown; currently JSON is also supported. JSON can be useful for programatically manipulating the results (e.g. to find the item that took the longest to compile)."}, {"sha": "4c8bc8b457898e59c693170a1e75c7846393256c", "filename": "src/doc/unstable-book/src/compiler-flags/dump-mono-stats.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fdump-mono-stats.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -0,0 +1,14 @@\n+# `dump-mono-stats`\n+\n+--------------------\n+\n+The `-Z dump-mono-stats` compiler flag generates a file with a list of the monomorphized items in the current crate.\n+It is useful for investigating compile times.\n+\n+It accepts an optional directory where the file will be located. If no directory is specified, the file will be placed in the current directory.\n+\n+See also `-Z dump-mono-stats-format` and `-Z print-mono-items`. Unlike `print-mono-items`,\n+`dump-mono-stats` aggregates monomorphized items by definition and includes a size estimate of how\n+large the item is when codegened.\n+\n+See <https://rustc-dev-guide.rust-lang.org/backend/monomorph.html> for an overview of monomorphized items."}, {"sha": "70c3a445b864f17e825141ec5a1ecebec5f794b2", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -50,10 +50,10 @@ with runtime flag `ASAN_OPTIONS=detect_leaks=1` on macOS.\n AddressSanitizer is supported on the following targets:\n \n * `aarch64-apple-darwin`\n-* `aarch64-fuchsia`\n+* `aarch64-unknown-fuchsia`\n * `aarch64-unknown-linux-gnu`\n * `x86_64-apple-darwin`\n-* `x86_64-fuchsia`\n+* `x86_64-unknown-fuchsia`\n * `x86_64-unknown-freebsd`\n * `x86_64-unknown-linux-gnu`\n "}, {"sha": "7a846d44ad6a8e9484b51aaf41705683feef5742", "filename": "src/etc/pre-push.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fetc%2Fpre-push.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Fetc%2Fpre-push.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpre-push.sh?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,6 +1,6 @@\n #!/usr/bin/env bash\n #\n-# Call `tidy --bless` before git push\n+# Call `tidy` before git push\n # Copy this script to .git/hooks to activate,\n # and remove it from .git/hooks to deactivate.\n #"}, {"sha": "025a4379f45a31a289177d6daad62200c3aa6302", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1960,7 +1960,6 @@ pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocCont\n             variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n         ),\n         None => VariantKind::Struct(VariantStruct {\n-            ctor_kind: None,\n             fields: variant.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n         }),\n     };\n@@ -1985,7 +1984,6 @@ fn clean_variant_data<'tcx>(\n \n     let kind = match variant {\n         hir::VariantData::Struct(..) => VariantKind::Struct(VariantStruct {\n-            ctor_kind: None,\n             fields: variant.fields().iter().map(|x| clean_field(x, cx)).collect(),\n         }),\n         hir::VariantData::Tuple(..) => {"}, {"sha": "827afafbba3b62ca6c2833b5b4b66119c3d9879d", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -2111,7 +2111,6 @@ impl Union {\n /// only as a variant in an enum.\n #[derive(Clone, Debug)]\n pub(crate) struct VariantStruct {\n-    pub(crate) ctor_kind: Option<CtorKind>,\n     pub(crate) fields: Vec<Item>,\n }\n \n@@ -2495,6 +2494,17 @@ impl Import {\n     pub(crate) fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n         Self { kind: ImportKind::Glob, source, should_be_displayed }\n     }\n+\n+    pub(crate) fn imported_item_is_doc_hidden(&self, tcx: TyCtxt<'_>) -> bool {\n+        match self.source.did {\n+            Some(did) => tcx\n+                .get_attrs(did, sym::doc)\n+                .filter_map(ast::Attribute::meta_item_list)\n+                .flatten()\n+                .has_word(sym::hidden),\n+            None => false,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "c8899ee62b5f9c7456c96eacc3eaa44600c5a6e8", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -309,7 +309,7 @@ impl<'tcx> Context<'tcx> {\n \n     pub(crate) fn href_from_span(&self, span: clean::Span, with_lines: bool) -> Option<String> {\n         let mut root = self.root_path();\n-        let mut path = String::new();\n+        let mut path: String;\n         let cnum = span.cnum(self.sess());\n \n         // We can safely ignore synthetic `SourceFile`s.\n@@ -340,10 +340,24 @@ impl<'tcx> Context<'tcx> {\n                 ExternalLocation::Unknown => return None,\n             };\n \n-            sources::clean_path(&src_root, file, false, |component| {\n-                path.push_str(&component.to_string_lossy());\n+            let href = RefCell::new(PathBuf::new());\n+            sources::clean_path(\n+                &src_root,\n+                file,\n+                |component| {\n+                    href.borrow_mut().push(component);\n+                },\n+                || {\n+                    href.borrow_mut().pop();\n+                },\n+            );\n+\n+            path = href.into_inner().to_string_lossy().to_string();\n+\n+            if let Some(c) = path.as_bytes().last() && *c != b'/' {\n                 path.push('/');\n-            });\n+            }\n+\n             let mut fname = file.file_name().expect(\"source has no filename\").to_os_string();\n             fname.push(\".html\");\n             path.push_str(&fname.to_string_lossy());"}, {"sha": "c16d6477fc37978c736e7c7ddf296be56f98311e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1229,16 +1229,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                                 w.write_str(\")\");\n                             }\n                             clean::VariantKind::Struct(ref s) => {\n-                                render_struct(\n-                                    w,\n-                                    v,\n-                                    None,\n-                                    s.ctor_kind,\n-                                    &s.fields,\n-                                    \"    \",\n-                                    false,\n-                                    cx,\n-                                );\n+                                render_struct(w, v, None, None, &s.fields, \"    \", false, cx);\n                             }\n                         },\n                         _ => unreachable!(),"}, {"sha": "3ea4c4bea8828fbc4fbfdb8738b76b6501d9726a", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -1,8 +1,9 @@\n+use std::cell::RefCell;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Component, Path};\n-use std::rc::Rc;\n+use std::rc::{Rc, Weak};\n \n use itertools::Itertools;\n use rustc_data_structures::flock;\n@@ -184,23 +185,26 @@ pub(super) fn write_shared(\n \n     use std::ffi::OsString;\n \n-    #[derive(Debug)]\n+    #[derive(Debug, Default)]\n     struct Hierarchy {\n+        parent: Weak<Self>,\n         elem: OsString,\n-        children: FxHashMap<OsString, Hierarchy>,\n-        elems: FxHashSet<OsString>,\n+        children: RefCell<FxHashMap<OsString, Rc<Self>>>,\n+        elems: RefCell<FxHashSet<OsString>>,\n     }\n \n     impl Hierarchy {\n-        fn new(elem: OsString) -> Hierarchy {\n-            Hierarchy { elem, children: FxHashMap::default(), elems: FxHashSet::default() }\n+        fn with_parent(elem: OsString, parent: &Rc<Self>) -> Self {\n+            Self { elem, parent: Rc::downgrade(parent), ..Self::default() }\n         }\n \n         fn to_json_string(&self) -> String {\n-            let mut subs: Vec<&Hierarchy> = self.children.values().collect();\n+            let borrow = self.children.borrow();\n+            let mut subs: Vec<_> = borrow.values().collect();\n             subs.sort_unstable_by(|a, b| a.elem.cmp(&b.elem));\n             let mut files = self\n                 .elems\n+                .borrow()\n                 .iter()\n                 .map(|s| format!(\"\\\"{}\\\"\", s.to_str().expect(\"invalid osstring conversion\")))\n                 .collect::<Vec<_>>();\n@@ -220,36 +224,52 @@ pub(super) fn write_shared(\n                 files = files\n             )\n         }\n-    }\n \n-    if cx.include_sources {\n-        let mut hierarchy = Hierarchy::new(OsString::new());\n-        for source in cx\n-            .shared\n-            .local_sources\n-            .iter()\n-            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n-        {\n-            let mut h = &mut hierarchy;\n-            let mut elems = source\n+        fn add_path(self: &Rc<Self>, path: &Path) {\n+            let mut h = Rc::clone(&self);\n+            let mut elems = path\n                 .components()\n                 .filter_map(|s| match s {\n                     Component::Normal(s) => Some(s.to_owned()),\n+                    Component::ParentDir => Some(OsString::from(\"..\")),\n                     _ => None,\n                 })\n                 .peekable();\n             loop {\n                 let cur_elem = elems.next().expect(\"empty file path\");\n+                if cur_elem == \"..\" {\n+                    if let Some(parent) = h.parent.upgrade() {\n+                        h = parent;\n+                    }\n+                    continue;\n+                }\n                 if elems.peek().is_none() {\n-                    h.elems.insert(cur_elem);\n+                    h.elems.borrow_mut().insert(cur_elem);\n                     break;\n                 } else {\n-                    let e = cur_elem.clone();\n-                    h = h.children.entry(cur_elem.clone()).or_insert_with(|| Hierarchy::new(e));\n+                    let entry = Rc::clone(\n+                        h.children\n+                            .borrow_mut()\n+                            .entry(cur_elem.clone())\n+                            .or_insert_with(|| Rc::new(Self::with_parent(cur_elem, &h))),\n+                    );\n+                    h = entry;\n                 }\n             }\n         }\n+    }\n \n+    if cx.include_sources {\n+        let hierarchy = Rc::new(Hierarchy::default());\n+        for source in cx\n+            .shared\n+            .local_sources\n+            .iter()\n+            .filter_map(|p| p.0.strip_prefix(&cx.shared.src_root).ok())\n+        {\n+            hierarchy.add_path(source);\n+        }\n+        let hierarchy = Rc::try_unwrap(hierarchy).unwrap();\n         let dst = cx.dst.join(&format!(\"source-files{}.js\", cx.shared.resource_suffix));\n         let make_sources = || {\n             let (mut all_sources, _krates) ="}, {"sha": "799c497d13709a00d95c7fcf6a07dc2fc482f8c4", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d61d359d5ef5e3192611297805dbfbb52c55de8f/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=d61d359d5ef5e3192611297805dbfbb52c55de8f", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::source_map::FileName;\n \n+use std::cell::RefCell;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n@@ -72,12 +73,22 @@ impl LocalSourcesCollector<'_, '_> {\n             return;\n         }\n \n-        let mut href = String::new();\n-        clean_path(self.src_root, &p, false, |component| {\n-            href.push_str(&component.to_string_lossy());\n-            href.push('/');\n-        });\n+        let href = RefCell::new(PathBuf::new());\n+        clean_path(\n+            &self.src_root,\n+            &p,\n+            |component| {\n+                href.borrow_mut().push(component);\n+            },\n+            || {\n+                href.borrow_mut().pop();\n+            },\n+        );\n \n+        let mut href = href.into_inner().to_string_lossy().to_string();\n+        if let Some(c) = href.as_bytes().last() && *c != b'/' {\n+            href.push('/');\n+        }\n         let mut src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n         src_fname.push(\".html\");\n         href.push_str(&src_fname.to_string_lossy());\n@@ -180,13 +191,28 @@ impl SourceCollector<'_, '_> {\n \n         let shared = Rc::clone(&self.cx.shared);\n         // Create the intermediate directories\n-        let mut cur = self.dst.clone();\n-        let mut root_path = String::from(\"../../\");\n-        clean_path(&shared.src_root, &p, false, |component| {\n-            cur.push(component);\n-            root_path.push_str(\"../\");\n-        });\n+        let cur = RefCell::new(PathBuf::new());\n+        let root_path = RefCell::new(PathBuf::new());\n+\n+        clean_path(\n+            &shared.src_root,\n+            &p,\n+            |component| {\n+                cur.borrow_mut().push(component);\n+                root_path.borrow_mut().push(\"..\");\n+            },\n+            || {\n+                cur.borrow_mut().pop();\n+                root_path.borrow_mut().pop();\n+            },\n+        );\n \n+        let root_path = PathBuf::from(\"../../\").join(root_path.into_inner());\n+        let mut root_path = root_path.to_string_lossy();\n+        if let Some(c) = root_path.as_bytes().last() && *c != b'/' {\n+            root_path += \"/\";\n+        }\n+        let mut cur = self.dst.join(cur.into_inner());\n         shared.ensure_dir(&cur)?;\n \n         let src_fname = p.file_name().expect(\"source has no filename\").to_os_string();\n@@ -232,24 +258,26 @@ impl SourceCollector<'_, '_> {\n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree. Each component in the cleaned path will be passed as an\n-/// argument to `f`. The very last component of the path (ie the file name) will\n-/// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-pub(crate) fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+/// argument to `f`. The very last component of the path (ie the file name) is ignored.\n+/// If a `..` is encountered, the `parent` closure will be called to allow the callee to\n+/// handle it.\n+pub(crate) fn clean_path<F, P>(src_root: &Path, p: &Path, mut f: F, mut parent: P)\n where\n     F: FnMut(&OsStr),\n+    P: FnMut(),\n {\n     // make it relative, if possible\n     let p = p.strip_prefix(src_root).unwrap_or(p);\n \n     let mut iter = p.components().peekable();\n \n     while let Some(c) = iter.next() {\n-        if !keep_filename && iter.peek().is_none() {\n+        if iter.peek().is_none() {\n             break;\n         }\n \n         match c {\n-            Component::ParentDir => f(\"up\".as_ref()),\n+            Component::ParentDir => parent(),\n             Component::Normal(c) => f(c),\n             _ => continue,\n         }"}]}