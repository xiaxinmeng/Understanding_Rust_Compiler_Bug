{"sha": "789e78e72ed5c6db874ff3446a4817a4bf017990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OWU3OGU3MmVkNWM2ZGI4NzRmZjM0NDZhNDgxN2E0YmYwMTc5OTA=", "commit": {"author": {"name": "Zaki Manian", "email": "zaki@manian.org", "date": "2017-09-03T03:36:24Z"}, "committer": {"name": "Zaki Manian", "email": "zaki@manian.org", "date": "2017-09-03T03:36:24Z"}, "message": "Improved spans for lints and support match expressions", "tree": {"sha": "11a2793ad9f9e4de7095fd40e71908e5a7297c3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11a2793ad9f9e4de7095fd40e71908e5a7297c3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/789e78e72ed5c6db874ff3446a4817a4bf017990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/789e78e72ed5c6db874ff3446a4817a4bf017990", "html_url": "https://github.com/rust-lang/rust/commit/789e78e72ed5c6db874ff3446a4817a4bf017990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/789e78e72ed5c6db874ff3446a4817a4bf017990/comments", "author": {"login": "zmanian", "id": 93434, "node_id": "MDQ6VXNlcjkzNDM0", "avatar_url": "https://avatars.githubusercontent.com/u/93434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zmanian", "html_url": "https://github.com/zmanian", "followers_url": "https://api.github.com/users/zmanian/followers", "following_url": "https://api.github.com/users/zmanian/following{/other_user}", "gists_url": "https://api.github.com/users/zmanian/gists{/gist_id}", "starred_url": "https://api.github.com/users/zmanian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zmanian/subscriptions", "organizations_url": "https://api.github.com/users/zmanian/orgs", "repos_url": "https://api.github.com/users/zmanian/repos", "events_url": "https://api.github.com/users/zmanian/events{/privacy}", "received_events_url": "https://api.github.com/users/zmanian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zmanian", "id": 93434, "node_id": "MDQ6VXNlcjkzNDM0", "avatar_url": "https://avatars.githubusercontent.com/u/93434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zmanian", "html_url": "https://github.com/zmanian", "followers_url": "https://api.github.com/users/zmanian/followers", "following_url": "https://api.github.com/users/zmanian/following{/other_user}", "gists_url": "https://api.github.com/users/zmanian/gists{/gist_id}", "starred_url": "https://api.github.com/users/zmanian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zmanian/subscriptions", "organizations_url": "https://api.github.com/users/zmanian/orgs", "repos_url": "https://api.github.com/users/zmanian/repos", "events_url": "https://api.github.com/users/zmanian/events{/privacy}", "received_events_url": "https://api.github.com/users/zmanian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34edc3f782a7929fb72efc82929bb070ea74e020", "url": "https://api.github.com/repos/rust-lang/rust/commits/34edc3f782a7929fb72efc82929bb070ea74e020", "html_url": "https://github.com/rust-lang/rust/commit/34edc3f782a7929fb72efc82929bb070ea74e020"}], "stats": {"total": 87, "additions": 40, "deletions": 47}, "files": [{"sha": "c919c49a3266421f0a1526b47c05b141dffa31e8", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/789e78e72ed5c6db874ff3446a4817a4bf017990/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789e78e72ed5c6db874ff3446a4817a4bf017990/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=789e78e72ed5c6db874ff3446a4817a4bf017990", "patch": "@@ -1,8 +1,8 @@\n use rustc::lint::*;\n use syntax::ast::*;\n-use syntax::codemap::Spanned;\n-use utils::{span_lint_and_sugg, snippet};\n use std::ops::Deref;\n+use syntax::ext::quote::rt::Span;\n+\n \n /// **What it does:** Checks for \n ///  - () being assigned to a variable\n@@ -35,42 +35,21 @@ impl LintPass for UnitExpr {\n impl EarlyLintPass for UnitExpr {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         if let ExprKind::Assign(ref _left, ref right) = expr.node {\n-            if is_unit_expr(right){\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNIT_EXPR,\n-                    right.span,\n-                    \"trailing semicolons can be tricky\",\n-                    \"remove the last semicolon\",\n-                    \"TODO\".to_owned()\n-                )\n+            if let Some(span) = is_unit_expr(right){\n+                    cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n             }\n         }\n         if let ExprKind::MethodCall(ref _left, ref args) = expr.node {\n             for ref arg in args{\n-                if is_unit_expr(arg){\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNIT_EXPR,\n-                        arg.span,\n-                        \"trailing semicolons can be tricky\",\n-                        \"remove the last semicolon\",\n-                        \"TODO\".to_owned()\n-                    )\n+                if let Some(span) = is_unit_expr(arg){\n+                    cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n                 }            \n             }\n         }\n         if let ExprKind::Call( _, ref args) = expr.node{\n             for ref arg in args{\n-                if is_unit_expr(arg){\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNIT_EXPR,\n-                        arg.span,\n-                        \"trailing semicolons can be tricky\",\n-                        \"remove the last semicolon\",\n-                        \"TODO\".to_owned()\n-                    )\n+                if let Some(span) = is_unit_expr(arg){\n+                       cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");\n                 }            \n             }        \n         }\n@@ -80,34 +59,48 @@ impl EarlyLintPass for UnitExpr {\n         if let StmtKind::Local(ref local) = stmt.node{\n             if local.pat.node == PatKind::Wild {return;}\n             if let Some(ref expr) = local.init{\n-                if is_unit_expr(expr){\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNIT_EXPR,\n-                        local.span,\n-                        \"trailing semicolons can be tricky\",\n-                        \"remove the last semicolon\",\n-                        \"TODO\".to_owned()\n-                    )\n-                }\n-            }        \n+                if let Some(span) = is_unit_expr(expr){\n+                    cx.span_lint(UNIT_EXPR, span, \"Consider removing the trailing semicolon\");  \n             }\n     }\n }\n-\n-fn is_unit_expr(expr: &Expr)->bool{\n+}\n+}\n+fn is_unit_expr(expr: &Expr)->Option<Span>{\n     match expr.node{\n          ExprKind::Block(ref block) => {\n-             return check_last_stmt_in_block(block);\n+             if check_last_stmt_in_block(block){\n+                 return Some(block.stmts[block.stmts.len()-1].span.clone());\n+             } else{\n+                 return None;\n+             }\n         },\n         ExprKind::If(_, ref then, ref else_)=>{\n             let check_then = check_last_stmt_in_block(then);\n             if let Some(ref else_) = *else_{\n-                return check_then && is_unit_expr(else_.deref());\n+                let check_else = is_unit_expr(*else_);\n+                if let Some(ref expr_else) = check_else{\n+                    return Some(expr_else.clone());\n+                }else{\n+                    return Some(expr.span.clone());\n+                }\n             } \n-            return check_then;\n+            if check_then { \n+                return Some(expr.span.clone());\n+\n+            } else{\n+                return Some(expr.span.clone());\n+            }\n+        },\n+        ExprKind::Match(ref _pattern, ref arms ) =>{\n+            for ref arm in arms{\n+                if let Some(expr) = is_unit_expr(&arm.body){\n+                    return Some(expr);\n+                }\n+            }\n+            return None;\n         }\n-        _ => return false,\n+        _ => return None,\n     }\n }\n \n@@ -117,6 +110,6 @@ fn check_last_stmt_in_block(block: &Block)->bool{\n                 return false;\n             }\n             else{\n-                return true;\n+              return true; \n             }\n }\n\\ No newline at end of file"}]}