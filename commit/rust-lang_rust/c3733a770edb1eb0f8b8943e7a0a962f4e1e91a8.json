{"sha": "c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNzMzYTc3MGVkYjFlYjBmOGI4OTQzZTdhMGE5NjJmNGUxZTkxYTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T09:50:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T09:50:54Z"}, "message": "Auto merge of #50528 - whitfin:issue-50508, r=michaelwoerister\n\nRemove attribute_cache from CrateMetadata\n\nThis PR will fix #50508 by removing the `attribute_cache` from the `CrateMetadata` struct. Seeing as performance was referenced in the original issue, I also cleaned up a `self.entry(node_id);` call which might have occasionally happened redundantly.\n\nr? @michaelwoerister", "tree": {"sha": "dc8ba9d188e17a846d71843998fe12d6f5c6b5d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc8ba9d188e17a846d71843998fe12d6f5c6b5d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "html_url": "https://github.com/rust-lang/rust/commit/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6", "html_url": "https://github.com/rust-lang/rust/commit/531e4ab7bc1a9064ae0b77ba16a9cd46832194e6"}, {"sha": "d95ba305b474a724e041df6d7ffd74bf3199d296", "url": "https://api.github.com/repos/rust-lang/rust/commits/d95ba305b474a724e041df6d7ffd74bf3199d296", "html_url": "https://github.com/rust-lang/rust/commit/d95ba305b474a724e041df6d7ffd74bf3199d296"}], "stats": {"total": 239, "additions": 86, "deletions": 153}, "files": [{"sha": "1549ef5e928c7ef4c581ce77d3890b04d69e2463", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -453,16 +453,20 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         out\n     }\n \n-    fn dep_nodes(&self, labels: &Labels, def_id: DefId) -> Vec<DepNode> {\n-        let mut out = Vec::with_capacity(labels.len());\n+    fn dep_nodes<'l>(\n+        &self,\n+        labels: &'l Labels,\n+        def_id: DefId\n+    ) -> impl Iterator<Item = DepNode> + 'l {\n         let def_path_hash = self.tcx.def_path_hash(def_id);\n-        for label in labels.iter() {\n-            match DepNode::from_label_string(label, def_path_hash) {\n-                Ok(dep_node) => out.push(dep_node),\n-                Err(()) => unreachable!(),\n-            }\n-        }\n-        out\n+        labels\n+            .iter()\n+            .map(move |label| {\n+                match DepNode::from_label_string(label, def_path_hash) {\n+                    Ok(dep_node) => dep_node,\n+                    Err(()) => unreachable!(),\n+                }\n+            })\n     }\n \n     fn dep_node_str(&self, dep_node: &DepNode) -> String {"}, {"sha": "c0ccbd67a31605e395f330b7464e6b651f2d252d", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -28,7 +28,6 @@ pub fn copy_cgu_workproducts_to_incr_comp_cache_dir(\n     if sess.opts.incremental.is_none() {\n         return None\n     }\n-    let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n \n     let saved_files: Option<Vec<_>> =\n         files.iter()\n@@ -63,6 +62,7 @@ pub fn copy_cgu_workproducts_to_incr_comp_cache_dir(\n         saved_files,\n     };\n \n+    let work_product_id = WorkProductId::from_cgu_name(cgu_name);\n     Some((work_product_id, work_product))\n }\n "}, {"sha": "2467d5cf97c1742917c10fb7413ee3231e38baa4", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -58,9 +58,9 @@ pub struct CrateLoader<'a> {\n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n     cstore.iter_crate_data(|_, data| {\n-        info!(\"  name: {}\", data.name());\n+        info!(\"  name: {}\", data.root.name);\n         info!(\"  cnum: {}\", data.cnum);\n-        info!(\"  hash: {}\", data.hash());\n+        info!(\"  hash: {}\", data.root.hash);\n         info!(\"  reqd: {:?}\", *data.dep_kind.lock());\n         let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n         dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n@@ -113,7 +113,7 @@ impl<'a> CrateLoader<'a> {\n             if data.name != name { return }\n \n             match hash {\n-                Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n+                Some(hash) if *hash == data.root.hash => { ret = Some(cnum); return }\n                 Some(..) => return,\n                 None => {}\n             }\n@@ -172,9 +172,9 @@ impl<'a> CrateLoader<'a> {\n \n         // Check for conflicts with any crate loaded so far\n         self.cstore.iter_crate_data(|_, other| {\n-            if other.name() == root.name && // same crate-name\n-               other.disambiguator() == root.disambiguator &&  // same crate-disambiguator\n-               other.hash() != root.hash { // but different SVH\n+            if other.root.name == root.name && // same crate-name\n+               other.root.disambiguator == root.disambiguator &&  // same crate-disambiguator\n+               other.root.hash != root.hash { // but different SVH\n                 span_fatal!(self.sess, span, E0523,\n                         \"found two different crates with name `{}` that are \\\n                          not distinguished by differing `-C metadata`. This \\\n@@ -214,7 +214,6 @@ impl<'a> CrateLoader<'a> {\n         let root = if root.is_some() { root } else { &crate_paths };\n \n         let Library { dylib, rlib, rmeta, metadata } = lib;\n-\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n@@ -243,13 +242,12 @@ impl<'a> CrateLoader<'a> {\n             cnum,\n             dependencies: Lock::new(dependencies),\n             codemap_import_info: RwLock::new(vec![]),\n-            attribute_cache: Lock::new([Vec::new(), Vec::new()]),\n             dep_kind: Lock::new(dep_kind),\n             source: cstore::CrateSource {\n                 dylib,\n                 rlib,\n                 rmeta,\n-            },\n+            }\n         };\n \n         let cmeta = Lrc::new(cmeta);\n@@ -345,7 +343,7 @@ impl<'a> CrateLoader<'a> {\n         if locate_ctxt.triple == &self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n-                if data.name() == root.name && root.hash == data.hash() {\n+                if data.root.name == root.name && root.hash == data.root.hash {\n                     assert!(locate_ctxt.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n@@ -642,15 +640,14 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n \n-        let sess = self.sess;\n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n-                                  data.needs_panic_runtime(sess);\n-            if data.is_panic_runtime(sess) {\n+                                  data.root.needs_panic_runtime;\n+            if data.root.panic_runtime {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime(sess));\n+                                          &|data| data.root.needs_panic_runtime);\n                 runtime_found = runtime_found || *data.dep_kind.lock() == DepKind::Explicit;\n             }\n         });\n@@ -687,19 +684,19 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime(self.sess) {\n+        if !data.root.panic_runtime {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n-        if data.panic_strategy() != desired_strategy {\n+        if data.root.panic_strategy != desired_strategy {\n             self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n                                     strategy `{}`\",\n                                    name, desired_strategy.desc()));\n         }\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime(self.sess));\n+                                  &|data| data.root.needs_panic_runtime);\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -794,7 +791,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime(self.sess) {\n+                if !data.root.sanitizer_runtime {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -817,7 +814,7 @@ impl<'a> CrateLoader<'a> {\n                                    PathKind::Crate, dep_kind);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.is_profiler_runtime(self.sess) {\n+            if !data.root.profiler_runtime {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n@@ -834,7 +831,7 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       \"needs_allocator\");\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator(self.sess);\n+            needs_allocator = needs_allocator || data.root.needs_allocator;\n         });\n         if !needs_allocator {\n             self.sess.injected_allocator.set(None);\n@@ -876,7 +873,7 @@ impl<'a> CrateLoader<'a> {\n             None\n         };\n         self.cstore.iter_crate_data(|_, data| {\n-            if !data.has_global_allocator() {\n+            if !data.root.has_global_allocator {\n                 return\n             }\n             match global_allocator {\n@@ -885,14 +882,14 @@ impl<'a> CrateLoader<'a> {\n                                             conflicts with this global \\\n                                             allocator in: {}\",\n                                            other_crate,\n-                                           data.name()));\n+                                           data.root.name));\n                 }\n                 Some(None) => {\n                     self.sess.err(&format!(\"the #[global_allocator] in this \\\n                                             crate conflicts with global \\\n-                                            allocator in: {}\", data.name()));\n+                                            allocator in: {}\", data.root.name));\n                 }\n-                None => global_allocator = Some(Some(data.name())),\n+                None => global_allocator = Some(Some(data.root.name)),\n             }\n         });\n         if global_allocator.is_some() {\n@@ -954,7 +951,7 @@ impl<'a> CrateLoader<'a> {\n             // error.\n             let mut allocator = None;\n             self.cstore.iter_crate_data(|_, data| {\n-                if allocator.is_none() && data.has_default_lib_allocator() {\n+                if allocator.is_none() && data.root.has_default_lib_allocator {\n                     allocator = Some(data.clone());\n                 }\n             });\n@@ -1030,9 +1027,9 @@ impl<'a> CrateLoader<'a> {\n                 self.sess.err(&format!(\"the crate `{}` cannot depend \\\n                                         on a crate that needs {}, but \\\n                                         it depends on `{}`\",\n-                                       self.cstore.get_crate_data(krate).name(),\n+                                       self.cstore.get_crate_data(krate).root.name,\n                                        what,\n-                                       data.name()));\n+                                       data.root.name));\n             }\n         }\n "}, {"sha": "763563eabe0e98bd87bd2cb881a32410f9d00fa7", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 70, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -13,18 +13,14 @@\n \n use schema;\n \n-use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex};\n+use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n-use rustc::session::{Session, CrateDisambiguator};\n-use rustc_target::spec::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, NodeMap};\n \n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n-use syntax::{ast, attr};\n-use syntax::edition::Edition;\n+use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos;\n@@ -69,7 +65,6 @@ pub struct CrateMetadata {\n     pub cnum: CrateNum,\n     pub dependencies: Lock<Vec<CrateNum>>,\n     pub codemap_import_info: RwLock<Vec<ImportedFileMap>>,\n-    pub attribute_cache: Lock<[Vec<Option<Lrc<[ast::Attribute]>>>; 2]>,\n \n     pub root: schema::CrateRoot,\n \n@@ -177,66 +172,3 @@ impl CStore {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n }\n-\n-impl CrateMetadata {\n-    pub fn name(&self) -> Symbol {\n-        self.root.name\n-    }\n-    pub fn hash(&self) -> Svh {\n-        self.root.hash\n-    }\n-    pub fn disambiguator(&self) -> CrateDisambiguator {\n-        self.root.disambiguator\n-    }\n-\n-    pub fn needs_allocator(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"needs_allocator\")\n-    }\n-\n-    pub fn has_global_allocator(&self) -> bool {\n-        self.root.has_global_allocator.clone()\n-    }\n-\n-    pub fn has_default_lib_allocator(&self) -> bool {\n-        self.root.has_default_lib_allocator.clone()\n-    }\n-\n-    pub fn is_panic_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"panic_runtime\")\n-    }\n-\n-    pub fn needs_panic_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"needs_panic_runtime\")\n-    }\n-\n-    pub fn is_compiler_builtins(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"compiler_builtins\")\n-    }\n-\n-    pub fn is_sanitizer_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"sanitizer_runtime\")\n-    }\n-\n-    pub fn is_profiler_runtime(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"profiler_runtime\")\n-    }\n-\n-    pub fn is_no_builtins(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_name(&attrs, \"no_builtins\")\n-    }\n-\n-    pub fn panic_strategy(&self) -> PanicStrategy {\n-        self.root.panic_strategy.clone()\n-    }\n-\n-    pub fn edition(&self) -> Edition {\n-        self.root.edition\n-    }\n-}"}, {"sha": "4691027e3b1d2ac15c2107bb36d7e2e6e055776b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -170,17 +170,17 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { Lrc::new(cdata.get_dylib_dependency_formats()) }\n-    is_panic_runtime => { cdata.is_panic_runtime(tcx.sess) }\n-    is_compiler_builtins => { cdata.is_compiler_builtins(tcx.sess) }\n-    has_global_allocator => { cdata.has_global_allocator() }\n-    is_sanitizer_runtime => { cdata.is_sanitizer_runtime(tcx.sess) }\n-    is_profiler_runtime => { cdata.is_profiler_runtime(tcx.sess) }\n-    panic_strategy => { cdata.panic_strategy() }\n+    is_panic_runtime => { cdata.root.panic_runtime }\n+    is_compiler_builtins => { cdata.root.compiler_builtins }\n+    has_global_allocator => { cdata.root.has_global_allocator }\n+    is_sanitizer_runtime => { cdata.root.sanitizer_runtime }\n+    is_profiler_runtime => { cdata.root.profiler_runtime }\n+    panic_strategy => { cdata.root.panic_strategy }\n     extern_crate => {\n         let r = Lrc::new(*cdata.extern_crate.lock());\n         r\n     }\n-    is_no_builtins => { cdata.is_no_builtins(tcx.sess) }\n+    is_no_builtins => { cdata.root.no_builtins }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n     reachable_non_generics => {\n         let reachable_non_generics = tcx\n@@ -209,9 +209,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             DefId { krate: def_id.krate, index }\n         })\n     }\n-    crate_disambiguator => { cdata.disambiguator() }\n-    crate_hash => { cdata.hash() }\n-    original_crate_name => { cdata.name() }\n+    crate_disambiguator => { cdata.root.disambiguator }\n+    crate_hash => { cdata.root.hash }\n+    original_crate_name => { cdata.root.name }\n \n     extra_filename => { cdata.root.extra_filename.clone() }\n \n@@ -457,17 +457,17 @@ impl CrateStore for cstore::CStore {\n \n     fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> CrateDisambiguator\n     {\n-        self.get_crate_data(cnum).disambiguator()\n+        self.get_crate_data(cnum).root.disambiguator\n     }\n \n     fn crate_hash_untracked(&self, cnum: CrateNum) -> hir::svh::Svh\n     {\n-        self.get_crate_data(cnum).hash()\n+        self.get_crate_data(cnum).root.hash\n     }\n \n     fn crate_edition_untracked(&self, cnum: CrateNum) -> Edition\n     {\n-        self.get_crate_data(cnum).edition()\n+        self.get_crate_data(cnum).root.edition\n     }\n \n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n@@ -519,7 +519,7 @@ impl CrateStore for cstore::CStore {\n         } else if data.name == \"proc_macro\" &&\n                   self.get_crate_data(id.krate).item_name(id.index) == \"quote\" {\n             let ext = SyntaxExtension::ProcMacro(Box::new(::proc_macro::__internal::Quoter),\n-                                                 data.edition());\n+                                                 data.root.edition);\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }\n "}, {"sha": "8af4649ed5f40e625a2c41428c1e1f389fd00990", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -557,12 +557,14 @@ impl<'a, 'tcx> CrateMetadata {\n                        -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n-        let kind = match item.kind {\n-            EntryKind::Enum(_) => ty::AdtKind::Enum,\n-            EntryKind::Struct(_, _) => ty::AdtKind::Struct,\n-            EntryKind::Union(_, _) => ty::AdtKind::Union,\n+\n+        let (kind, repr) = match item.kind {\n+            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n+            EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n+            EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n+\n         let variants = if let ty::AdtKind::Enum = kind {\n             item.children\n                 .decode(self)\n@@ -573,12 +575,6 @@ impl<'a, 'tcx> CrateMetadata {\n         } else {\n             vec![self.get_variant(&item, item_id)]\n         };\n-        let (kind, repr) = match item.kind {\n-            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n-            EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n-            EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n-            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n-        };\n \n         tcx.alloc_adt_def(did, kind, variants, repr)\n     }\n@@ -880,34 +876,22 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        let (node_as, node_index) =\n-            (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n             return Lrc::new([]);\n         }\n \n-        if let Some(&Some(ref val)) =\n-            self.attribute_cache.borrow()[node_as].get(node_index) {\n-            return val.clone();\n-        }\n-\n         // The attributes for a tuple struct are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n-        let mut item = self.entry(node_id);\n         let def_key = self.def_key(node_id);\n-        if def_key.disambiguated_data.data == DefPathData::StructCtor {\n-            item = self.entry(def_key.parent.unwrap());\n-        }\n-        let result: Lrc<[ast::Attribute]> = Lrc::from(self.get_attributes(&item, sess));\n-        let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n-        if vec_.len() < node_index + 1 {\n-            vec_.resize(node_index + 1, None);\n-        }\n-        // This can overwrite the result produced by another thread, but the value\n-        // written should be the same\n-        vec_[node_index] = Some(result.clone());\n-        result\n+        let item_id = if def_key.disambiguated_data.data == DefPathData::StructCtor {\n+            def_key.parent.unwrap()\n+        } else {\n+            node_id\n+        };\n+\n+        let item = self.entry(item_id);\n+        Lrc::from(self.get_attributes(&item, sess))\n     }\n \n     pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {"}, {"sha": "ab30ff7f072b7f065e4e631dd1fee02982e5b7d9", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -483,10 +483,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let index = items.write_index(&mut self.opaque.cursor);\n         let index_bytes = self.position() - i;\n \n+        let attrs = tcx.hir.krate_attrs();\n         let link_meta = self.link_meta;\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n-        let has_default_lib_allocator =\n-            attr::contains_name(tcx.hir.krate_attrs(), \"default_lib_allocator\");\n+        let has_default_lib_allocator = attr::contains_name(&attrs, \"default_lib_allocator\");\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n \n         let root = self.lazy(&CrateRoot {\n@@ -510,6 +510,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 None\n             },\n \n+            compiler_builtins: attr::contains_name(&attrs, \"compiler_builtins\"),\n+            needs_allocator: attr::contains_name(&attrs, \"needs_allocator\"),\n+            needs_panic_runtime: attr::contains_name(&attrs, \"needs_panic_runtime\"),\n+            no_builtins: attr::contains_name(&attrs, \"no_builtins\"),\n+            panic_runtime: attr::contains_name(&attrs, \"panic_runtime\"),\n+            profiler_runtime: attr::contains_name(&attrs, \"profiler_runtime\"),\n+            sanitizer_runtime: attr::contains_name(&attrs, \"sanitizer_runtime\"),\n+\n             crate_deps,\n             dylib_dependency_formats,\n             lang_items,"}, {"sha": "2e89ea6d2c1213bc7899cd49300738b6c4246245", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "patch": "@@ -210,6 +210,14 @@ pub struct CrateRoot {\n     pub interpret_alloc_index: LazySeq<u32>,\n \n     pub index: LazySeq<index::Index>,\n+\n+    pub compiler_builtins: bool,\n+    pub needs_allocator: bool,\n+    pub needs_panic_runtime: bool,\n+    pub no_builtins: bool,\n+    pub panic_runtime: bool,\n+    pub profiler_runtime: bool,\n+    pub sanitizer_runtime: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}]}