{"sha": "862c195fa176f476354727817ea0370e9ddc664b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MmMxOTVmYTE3NmY0NzYzNTQ3Mjc4MTdlYTAzNzBlOWRkYzY2NGI=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-17T05:44:39Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-17T05:44:39Z"}, "message": "Merge pull request #337 from Manishearth/indentfix\n\nfix indentation", "tree": {"sha": "e41fbd769f700725a189b5bfbd7348c98ac5c450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e41fbd769f700725a189b5bfbd7348c98ac5c450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/862c195fa176f476354727817ea0370e9ddc664b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/862c195fa176f476354727817ea0370e9ddc664b", "html_url": "https://github.com/rust-lang/rust/commit/862c195fa176f476354727817ea0370e9ddc664b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/862c195fa176f476354727817ea0370e9ddc664b/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acc83c0b02fcf5c8f7b9bd93d7571117f2b5284a", "url": "https://api.github.com/repos/rust-lang/rust/commits/acc83c0b02fcf5c8f7b9bd93d7571117f2b5284a", "html_url": "https://github.com/rust-lang/rust/commit/acc83c0b02fcf5c8f7b9bd93d7571117f2b5284a"}, {"sha": "58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "url": "https://api.github.com/repos/rust-lang/rust/commits/58fee220a9ec3bd904aa7c8e84b6643b51e88f76", "html_url": "https://github.com/rust-lang/rust/commit/58fee220a9ec3bd904aa7c8e84b6643b51e88f76"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "d22fc4817f3637e4828d85b54c5dcfa6c0bb7b3d", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/862c195fa176f476354727817ea0370e9ddc664b/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862c195fa176f476354727817ea0370e9ddc664b/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=862c195fa176f476354727817ea0370e9ddc664b", "patch": "@@ -34,9 +34,9 @@ impl LintPass for CollapsibleIf {\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-\t\tif !in_macro(cx, expr.span) {\n-\t\t\tcheck_if(cx, expr)\n-\t\t}\n+        if !in_macro(cx, expr.span) {\n+            check_if(cx, expr)\n+        }\n     }\n }\n "}, {"sha": "6c0fe97c983c875ae99c0f94b0987b1bdd454f9e", "filename": "src/utils.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/862c195fa176f476354727817ea0370e9ddc664b/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862c195fa176f476354727817ea0370e9ddc664b/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=862c195fa176f476354727817ea0370e9ddc664b", "patch": "@@ -29,34 +29,34 @@ pub fn in_macro(cx: &Context, span: Span) -> bool {\n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n pub fn in_external_macro(cx: &Context, span: Span) -> bool {\n-\t/// invokes in_macro with the expansion info of the given span\n-\t/// slightly heavy, try to use this after other checks have already happened\n-\tfn in_macro_ext(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n-\t\t// no ExpnInfo = no macro\n-\t\topt_info.map_or(false, |info| {\n-\t\t\tmatch info.callee.format {\n-\t\t\t\tExpnFormat::CompilerExpansion(..) => {\n-\t\t\t\t\tif info.callee.name() == \"closure expansion\" {\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\t\t\t\tExpnFormat::MacroAttribute(..) => {\n-\t\t\t\t\t// these are all plugins\n-\t\t\t\t\treturn true;\n-\t\t\t\t},\n-\t\t\t\t_ => (),\n-\t\t\t}\n-\t\t\t// no span for the callee = external macro\n-\t\t\tinfo.callee.span.map_or(true, |span| {\n-\t\t\t\t// no snippet = external macro or compiler-builtin expansion\n-\t\t\t\tcx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n-\t\t\t\t\t// macro doesn't start with \"macro_rules\"\n-\t\t\t\t\t// = compiler plugin\n-\t\t\t\t\t!code.starts_with(\"macro_rules\")\n-\t\t\t\t)\n-\t\t\t})\n-\t\t})\n-\t}\n+    /// invokes in_macro with the expansion info of the given span\n+    /// slightly heavy, try to use this after other checks have already happened\n+    fn in_macro_ext(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n+        // no ExpnInfo = no macro\n+        opt_info.map_or(false, |info| {\n+            match info.callee.format {\n+                ExpnFormat::CompilerExpansion(..) => {\n+                    if info.callee.name() == \"closure expansion\" {\n+                        return false;\n+                    }\n+                },\n+                ExpnFormat::MacroAttribute(..) => {\n+                    // these are all plugins\n+                    return true;\n+                },\n+                _ => (),\n+            }\n+            // no span for the callee = external macro\n+            info.callee.span.map_or(true, |span| {\n+                // no snippet = external macro or compiler-builtin expansion\n+                cx.sess().codemap().span_to_snippet(span).ok().map_or(true, |code|\n+                    // macro doesn't start with \"macro_rules\"\n+                    // = compiler plugin\n+                    !code.starts_with(\"macro_rules\")\n+                )\n+            })\n+        })\n+    }\n \n     cx.sess().codemap().with_expn_info(span.expn_id,\n             |info| in_macro_ext(cx, info))"}]}