{"sha": "e82c08f58e18078361a1d404cefebc3ed4c9d24a", "node_id": "C_kwDOAAsO6NoAKGU4MmMwOGY1OGUxODA3ODM2MWExZDQwNGNlZmViYzNlZDRjOWQyNGE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-06T18:14:20Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-13T14:05:12Z"}, "message": "Refactor rustc_hir_typeck::closure.", "tree": {"sha": "a7fcd3b2c36034000a288f71edb690245e322283", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7fcd3b2c36034000a288f71edb690245e322283"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e82c08f58e18078361a1d404cefebc3ed4c9d24a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e82c08f58e18078361a1d404cefebc3ed4c9d24a", "html_url": "https://github.com/rust-lang/rust/commit/e82c08f58e18078361a1d404cefebc3ed4c9d24a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e82c08f58e18078361a1d404cefebc3ed4c9d24a/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c4b0b29cf5bcfe6f2d21be5f5ad27d832eb85f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4b0b29cf5bcfe6f2d21be5f5ad27d832eb85f3", "html_url": "https://github.com/rust-lang/rust/commit/2c4b0b29cf5bcfe6f2d21be5f5ad27d832eb85f3"}], "stats": {"total": 132, "additions": 58, "deletions": 74}, "files": [{"sha": "1578cddd490e766bf4197d160108c2abe6444127", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=e82c08f58e18078361a1d404cefebc3ed4c9d24a", "patch": "@@ -26,10 +26,12 @@ pub(super) fn check_fn<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     fn_sig: ty::FnSig<'tcx>,\n     decl: &'tcx hir::FnDecl<'tcx>,\n-    fn_id: hir::HirId,\n+    fn_def_id: LocalDefId,\n     body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n+    let fn_id = inherited.tcx.hir().local_def_id_to_hir_id(fn_def_id);\n+\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);"}, {"sha": "74bedcf1b1e99fe1bba42e9e235d932f8fd9813a", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 44, "deletions": 61, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=e82c08f58e18078361a1d404cefebc3ed4c9d24a", "patch": "@@ -4,7 +4,7 @@ use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use hir::def::DefKind;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -41,18 +41,14 @@ struct ClosureSignatures<'tcx> {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    #[instrument(skip(self, expr, _capture, decl, body_id), level = \"debug\")]\n+    #[instrument(skip(self, closure), level = \"debug\")]\n     pub fn check_expr_closure(\n         &self,\n-        expr: &hir::Expr<'_>,\n-        _capture: hir::CaptureBy,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n-        body_id: hir::BodyId,\n-        gen: Option<hir::Movability>,\n+        closure: &hir::Closure<'tcx>,\n+        expr_span: Span,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        trace!(\"decl = {:#?}\", decl);\n-        trace!(\"expr = {:#?}\", expr);\n+        trace!(\"decl = {:#?}\", closure.fn_decl);\n \n         // It's always helpful for inference if we know the kind of\n         // closure sooner rather than later, so first examine the expected\n@@ -61,37 +57,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n             None => (None, None),\n         };\n-        let body = self.tcx.hir().body(body_id);\n-        self.check_closure(expr, expected_kind, decl, body, gen, expected_sig)\n+        let body = self.tcx.hir().body(closure.body);\n+        self.check_closure(closure, expr_span, expected_kind, body, expected_sig)\n     }\n \n-    #[instrument(skip(self, expr, body, decl), level = \"debug\", ret)]\n+    #[instrument(skip(self, closure, body), level = \"debug\", ret)]\n     fn check_closure(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        closure: &hir::Closure<'tcx>,\n+        expr_span: Span,\n         opt_kind: Option<ty::ClosureKind>,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n         body: &'tcx hir::Body<'tcx>,\n-        gen: Option<hir::Movability>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n-        trace!(\"decl = {:#?}\", decl);\n-        let expr_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n+        trace!(\"decl = {:#?}\", closure.fn_decl);\n+        let expr_def_id = closure.def_id;\n         debug!(?expr_def_id);\n \n         let ClosureSignatures { bound_sig, liberated_sig } =\n-            self.sig_of_closure(expr.hir_id, expr_def_id.to_def_id(), decl, body, expected_sig);\n+            self.sig_of_closure(expr_def_id, closure.fn_decl, body, expected_sig);\n \n         debug!(?bound_sig, ?liberated_sig);\n \n         let generator_types = check_fn(\n             self,\n             self.param_env.without_const(),\n             liberated_sig,\n-            decl,\n-            expr.hir_id,\n+            closure.fn_decl,\n+            expr_def_id,\n             body,\n-            gen,\n+            closure.movability,\n         )\n         .1;\n \n@@ -102,7 +97,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tupled_upvars_ty = self.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::ClosureSynthetic,\n-            span: self.tcx.hir().span(expr.hir_id),\n+            span: self.tcx.def_span(expr_def_id),\n         });\n \n         if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n@@ -148,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => self.next_ty_var(TypeVariableOrigin {\n                 // FIXME(eddyb) distinguish closure kind inference variables from the rest.\n                 kind: TypeVariableOriginKind::ClosureSynthetic,\n-                span: expr.span,\n+                span: expr_span,\n             }),\n         };\n \n@@ -342,30 +337,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn sig_of_closure(\n         &self,\n-        hir_id: hir::HirId,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n-            self.sig_of_closure_with_expectation(hir_id, expr_def_id, decl, body, e)\n+            self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n         } else {\n-            self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body)\n+            self.sig_of_closure_no_expectation(expr_def_id, decl, body)\n         }\n     }\n \n     /// If there is no expected signature, then we will convert the\n     /// types that the user gave into a signature.\n-    #[instrument(skip(self, hir_id, expr_def_id, decl, body), level = \"debug\")]\n+    #[instrument(skip(self, expr_def_id, decl, body), level = \"debug\")]\n     fn sig_of_closure_no_expectation(\n         &self,\n-        hir_id: hir::HirId,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ClosureSignatures<'tcx> {\n-        let bound_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n+        let bound_sig = self.supplied_sig_of_closure(expr_def_id, decl, body);\n \n         self.closure_sigs(expr_def_id, body, bound_sig)\n     }\n@@ -411,17 +404,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// # Arguments\n     ///\n-    /// - `expr_def_id`: the `DefId` of the closure expression\n+    /// - `expr_def_id`: the `LocalDefId` of the closure expression\n     /// - `decl`: the HIR declaration of the closure\n     /// - `body`: the body of the closure\n     /// - `expected_sig`: the expected signature (if any). Note that\n     ///   this is missing a binder: that is, there may be late-bound\n     ///   regions with depth 1, which are bound then by the closure.\n-    #[instrument(skip(self, hir_id, expr_def_id, decl, body), level = \"debug\")]\n+    #[instrument(skip(self, expr_def_id, decl, body), level = \"debug\")]\n     fn sig_of_closure_with_expectation(\n         &self,\n-        hir_id: hir::HirId,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n@@ -430,7 +422,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // expectation if things don't see to match up with what we\n         // expect.\n         if expected_sig.sig.c_variadic() != decl.c_variadic {\n-            return self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body);\n+            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n         } else if expected_sig.sig.skip_binder().inputs_and_output.len() != decl.inputs.len() + 1 {\n             return self.sig_of_closure_with_mismatched_number_of_arguments(\n                 expr_def_id,\n@@ -466,27 +458,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Along the way, it also writes out entries for types that the user\n         // wrote into our typeck results, which are then later used by the privacy\n         // check.\n-        match self.merge_supplied_sig_with_expectation(\n-            hir_id,\n-            expr_def_id,\n-            decl,\n-            body,\n-            closure_sigs,\n-        ) {\n+        match self.merge_supplied_sig_with_expectation(expr_def_id, decl, body, closure_sigs) {\n             Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n-            Err(_) => self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body),\n+            Err(_) => self.sig_of_closure_no_expectation(expr_def_id, decl, body),\n         }\n     }\n \n     fn sig_of_closure_with_mismatched_number_of_arguments(\n         &self,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n         let hir = self.tcx.hir();\n-        let expr_map_node = hir.get_if_local(expr_def_id).unwrap();\n+        let expr_map_node = hir.get_by_def_id(expr_def_id);\n         let expected_args: Vec<_> = expected_sig\n             .sig\n             .skip_binder()\n@@ -499,7 +485,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => (None, Vec::new()),\n         };\n         let expected_span =\n-            expected_sig.cause_span.unwrap_or_else(|| hir.span_if_local(expr_def_id).unwrap());\n+            expected_sig.cause_span.unwrap_or_else(|| self.tcx.def_span(expr_def_id));\n         self.report_arg_count_mismatch(\n             expected_span,\n             closure_span,\n@@ -517,11 +503,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Enforce the user's types against the expectation. See\n     /// `sig_of_closure_with_expectation` for details on the overall\n     /// strategy.\n-    #[instrument(level = \"debug\", skip(self, hir_id, expr_def_id, decl, body, expected_sigs))]\n+    #[instrument(level = \"debug\", skip(self, expr_def_id, decl, body, expected_sigs))]\n     fn merge_supplied_sig_with_expectation(\n         &self,\n-        hir_id: hir::HirId,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         mut expected_sigs: ClosureSignatures<'tcx>,\n@@ -530,7 +515,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // (See comment on `sig_of_closure_with_expectation` for the\n         // meaning of these letters.)\n-        let supplied_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n+        let supplied_sig = self.supplied_sig_of_closure(expr_def_id, decl, body);\n \n         debug!(?supplied_sig);\n \n@@ -610,8 +595,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(skip(self, decl, body), level = \"debug\", ret)]\n     fn supplied_sig_of_closure(\n         &self,\n-        hir_id: hir::HirId,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ty::PolyFnSig<'tcx> {\n@@ -620,6 +604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         trace!(\"decl = {:#?}\", decl);\n         debug!(?body.generator_kind);\n \n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(expr_def_id);\n         let bound_vars = self.tcx.late_bound_vars(hir_id);\n \n         // First, convert the types that the user supplied (if any).\n@@ -664,10 +649,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let result = self.normalize_associated_types_in(self.tcx.hir().span(hir_id), result);\n \n         let c_result = self.inh.infcx.canonicalize_response(result);\n-        self.typeck_results\n-            .borrow_mut()\n-            .user_provided_sigs\n-            .insert(expr_def_id.expect_local(), c_result);\n+        self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n \n         result\n     }\n@@ -681,7 +663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\", ret)]\n     fn deduce_future_output_from_obligations(\n         &self,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         body_id: hir::HirId,\n     ) -> Option<Ty<'tcx>> {\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n@@ -830,14 +812,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn closure_sigs(\n         &self,\n-        expr_def_id: DefId,\n+        expr_def_id: LocalDefId,\n         body: &hir::Body<'_>,\n         bound_sig: ty::PolyFnSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let liberated_sig = self.tcx().liberate_late_bound_regions(expr_def_id, bound_sig);\n+        let liberated_sig =\n+            self.tcx().liberate_late_bound_regions(expr_def_id.to_def_id(), bound_sig);\n         let liberated_sig = self.inh.normalize_associated_types_in(\n             body.value.span,\n-            body.value.hir_id,\n+            self.tcx.hir().local_def_id_to_hir_id(expr_def_id),\n             self.param_env,\n             liberated_sig,\n         );"}, {"sha": "13a03b33de815bad406e8aa0b52ceb7d6e3c74e5", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=e82c08f58e18078361a1d404cefebc3ed4c9d24a", "patch": "@@ -30,7 +30,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{Closure, ExprKind, HirId, QPath};\n+use rustc_hir::{ExprKind, HirId, QPath};\n use rustc_hir_analysis::astconv::AstConv as _;\n use rustc_hir_analysis::check::ty_kind_suggestion;\n use rustc_infer::infer;\n@@ -324,9 +324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Match(discrim, arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            ExprKind::Closure(&Closure { capture_clause, fn_decl, body, movability, .. }) => {\n-                self.check_expr_closure(expr, capture_clause, &fn_decl, body, movability, expected)\n-            }\n+            ExprKind::Closure(closure) => self.check_expr_closure(closure, expr.span, expected),\n             ExprKind::Block(body, _) => self.check_block_with_expected(&body, expected),\n             ExprKind::Call(callee, args) => self.check_call(expr, &callee, args, expected),\n             ExprKind::MethodCall(segment, receiver, args, _) => {"}, {"sha": "275f7d12148c952c7c7b23d17011aa93da921199", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=e82c08f58e18078361a1d404cefebc3ed4c9d24a", "patch": "@@ -352,8 +352,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(base);\n             }\n \n-            hir::ExprKind::Closure { .. } => {\n-                self.walk_captures(expr);\n+            hir::ExprKind::Closure(closure) => {\n+                self.walk_captures(closure);\n             }\n \n             hir::ExprKind::Box(ref base) => {\n@@ -745,7 +745,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     ///\n     /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n     /// closure as the DefId.\n-    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n+    fn walk_captures(&mut self, closure_expr: &hir::Closure<'_>) {\n         fn upvar_is_local_variable<'tcx>(\n             upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n             upvar_id: hir::HirId,\n@@ -757,7 +757,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let tcx = self.tcx();\n-        let closure_def_id = tcx.hir().local_def_id(closure_expr.hir_id);\n+        let closure_def_id = closure_expr.def_id;\n         let upvars = tcx.upvars_mentioned(self.body_owner);\n \n         // For purposes of this function, generator and closures are equivalent.\n@@ -829,10 +829,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         // be a local variable\n                         PlaceBase::Local(*var_hir_id)\n                     };\n+                    let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id);\n                     let place_with_id = PlaceWithHirId::new(\n-                        capture_info.path_expr_id.unwrap_or(\n-                            capture_info.capture_kind_expr_id.unwrap_or(closure_expr.hir_id),\n-                        ),\n+                        capture_info\n+                            .path_expr_id\n+                            .unwrap_or(capture_info.capture_kind_expr_id.unwrap_or(closure_hir_id)),\n                         place.base_ty,\n                         place_base,\n                         place.projections.clone(),"}, {"sha": "6fd609aeaa060f781220c9f96d63326b7d09bdd7", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82c08f58e18078361a1d404cefebc3ed4c9d24a/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=e82c08f58e18078361a1d404cefebc3ed4c9d24a", "patch": "@@ -251,7 +251,7 @@ fn typeck_with_fallback<'tcx>(\n                 param_env,\n                 fn_sig,\n             );\n-            check_fn(&inh, param_env, fn_sig, decl, id, body, None).0\n+            check_fn(&inh, param_env, fn_sig, decl, def_id, body, None).0\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = body_ty"}]}