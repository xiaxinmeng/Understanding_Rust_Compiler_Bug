{"sha": "7d69837bd263f334aa9dea4235698c006f7b1ce8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNjk4MzdiZDI2M2YzMzRhYTlkZWE0MjM1Njk4YzAwNmY3YjFjZTg=", "commit": {"author": {"name": "Ziad Hatahet", "email": "hatahet@gmail.com", "date": "2013-10-23T17:09:06Z"}, "committer": {"name": "Ziad Hatahet", "email": "hatahet@gmail.com", "date": "2013-10-23T17:09:06Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "b43315adfc734b0ab480b40674721c99902f3eb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b43315adfc734b0ab480b40674721c99902f3eb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d69837bd263f334aa9dea4235698c006f7b1ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d69837bd263f334aa9dea4235698c006f7b1ce8", "html_url": "https://github.com/rust-lang/rust/commit/7d69837bd263f334aa9dea4235698c006f7b1ce8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d69837bd263f334aa9dea4235698c006f7b1ce8/comments", "author": {"login": "hatahet", "id": 877713, "node_id": "MDQ6VXNlcjg3NzcxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/877713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hatahet", "html_url": "https://github.com/hatahet", "followers_url": "https://api.github.com/users/hatahet/followers", "following_url": "https://api.github.com/users/hatahet/following{/other_user}", "gists_url": "https://api.github.com/users/hatahet/gists{/gist_id}", "starred_url": "https://api.github.com/users/hatahet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hatahet/subscriptions", "organizations_url": "https://api.github.com/users/hatahet/orgs", "repos_url": "https://api.github.com/users/hatahet/repos", "events_url": "https://api.github.com/users/hatahet/events{/privacy}", "received_events_url": "https://api.github.com/users/hatahet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hatahet", "id": 877713, "node_id": "MDQ6VXNlcjg3NzcxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/877713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hatahet", "html_url": "https://github.com/hatahet", "followers_url": "https://api.github.com/users/hatahet/followers", "following_url": "https://api.github.com/users/hatahet/following{/other_user}", "gists_url": "https://api.github.com/users/hatahet/gists{/gist_id}", "starred_url": "https://api.github.com/users/hatahet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hatahet/subscriptions", "organizations_url": "https://api.github.com/users/hatahet/orgs", "repos_url": "https://api.github.com/users/hatahet/repos", "events_url": "https://api.github.com/users/hatahet/events{/privacy}", "received_events_url": "https://api.github.com/users/hatahet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60245b9290388671edac86d6db1619f60a9ccb68", "url": "https://api.github.com/repos/rust-lang/rust/commits/60245b9290388671edac86d6db1619f60a9ccb68", "html_url": "https://github.com/rust-lang/rust/commit/60245b9290388671edac86d6db1619f60a9ccb68"}, {"sha": "a4ec8af4c549bd806522826b756e18fbf0b5c47b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4ec8af4c549bd806522826b756e18fbf0b5c47b", "html_url": "https://github.com/rust-lang/rust/commit/a4ec8af4c549bd806522826b756e18fbf0b5c47b"}], "stats": {"total": 2678, "additions": 1957, "deletions": 721}, "files": [{"sha": "40a3bc12798f75e390a647171587048d46266a2e", "filename": "doc/rust.md", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -3168,7 +3168,7 @@ Raw pointers (`*`)\n   : Raw pointers are pointers without safety or liveness guarantees.\n     Raw pointers are written `*content`,\n     for example `*int` means a raw pointer to an integer.\n-    Copying or dropping a raw pointer is has no effect on the lifecycle of any other value.\n+    Copying or dropping a raw pointer has no effect on the lifecycle of any other value.\n     Dereferencing a raw pointer or converting it to any other pointer type is an [`unsafe` operation](#unsafe-functions).\n     Raw pointers are generally discouraged in Rust code;\n     they exist to support interoperability with foreign code,\n@@ -3395,16 +3395,23 @@ a [temporary](#lvalues-rvalues-and-temporaries), or a local variable.\n A _local variable_ (or *stack-local* allocation) holds a value directly,\n allocated within the stack's memory. The value is a part of the stack frame.\n \n-Local variables are immutable unless declared with `let mut`.  The\n-`mut` keyword applies to all local variables declared within that\n-declaration (so `let mut (x, y) = ...` declares two mutable variables, `x` and\n-`y`).\n+Local variables are immutable unless declared otherwise like: `let mut x = ...`.\n \n Function parameters are immutable unless declared with `mut`. The\n `mut` keyword applies only to the following parameter (so `|mut x, y|`\n and `fn f(mut x: ~int, y: ~int)` declare one mutable variable `x` and\n one immutable variable `y`).\n \n+Methods that take either `self` or `~self` can optionally place them in a\n+mutable slot by prefixing them with `mut` (similar to regular arguments):\n+\n+~~~\n+trait Changer {\n+    fn change(mut self) -> Self;\n+    fn modify(mut ~self) -> ~Self;\n+}\n+~~~\n+\n Local variables are not initialized when allocated; the entire frame worth of\n local variables are allocated at once, on frame-entry, in an uninitialized\n state. Subsequent statements within a function may or may not initialize the"}, {"sha": "7451919c5becf3e37cd26aae1b72b2df0b861b41", "filename": "doc/tutorial.md", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -151,22 +151,6 @@ declaration to appear at the top level of the file: all statements must\n live inside a function.  Rust programs can also be compiled as\n libraries, and included in other programs.\n \n-## Using the rust tool\n-\n-While using `rustc` directly to generate your executables, and then\n-running them manually is a perfectly valid way to test your code,\n-for smaller projects, prototypes, or if you're a beginner, it might be\n-more convenient to use the `rust` tool.\n-\n-The `rust` tool provides central access to the other rust tools,\n-as well as handy shortcuts for directly running source files.\n-For example, if you have a file `foo.rs` in your current directory,\n-`rust run foo.rs` would attempt to compile it and, if successful,\n-directly run the resulting binary.\n-\n-To get a list of all available commands, simply call `rust` without any\n-argument.\n-\n ## Editing Rust code\n \n There are vim highlighting and indentation scripts in the Rust source"}, {"sha": "d6fc5ecb8e5af118f5f23269823aff546ed1a7b3", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -370,6 +370,7 @@ $(3)/stage$(1)/test/rustpkgtest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2)) \\\n+\t\t$$(HBIN$(1)_H_$(3))/rustpkg$$(X_$(2)) \\\n \t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$$(X_$(2)) \\\n \t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X_$(2))\n \t@$$(call E, compile_and_link: $$@)"}, {"sha": "1ce52d1d2784a61b82cca5443b47e64109bcf4e5", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -521,15 +521,15 @@ fn borrow_rwlock<T:Freeze + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n \n /// The \"write permission\" token used for RWArc.write_downgrade().\n pub struct RWWriteMode<'self, T> {\n-    data: &'self mut T,\n-    token: sync::RWLockWriteMode<'self>,\n-    poison: PoisonOnFail,\n+    priv data: &'self mut T,\n+    priv token: sync::RWLockWriteMode<'self>,\n+    priv poison: PoisonOnFail,\n }\n \n /// The \"read permission\" token used for RWArc.write_downgrade().\n pub struct RWReadMode<'self, T> {\n-    data: &'self T,\n-    token: sync::RWLockReadMode<'self>,\n+    priv data: &'self T,\n+    priv token: sync::RWLockReadMode<'self>,\n }\n \n impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {"}, {"sha": "032de0b5f4a7f9ca0bf2752179d0616799e0a9ac", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -22,11 +22,11 @@ pub enum CharacterSet {\n /// Contains configuration parameters for `to_base64`.\n pub struct Config {\n     /// Character set to use\n-    char_set: CharacterSet,\n+    priv char_set: CharacterSet,\n     /// True to pad output with `=` characters\n-    pad: bool,\n+    priv pad: bool,\n     /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n-    line_length: Option<uint>\n+    priv line_length: Option<uint>\n }\n \n /// Configuration for RFC 4648 standard base64 encoding\n@@ -318,7 +318,7 @@ mod test {\n         use std::vec;\n \n         do 1000.times {\n-            let times = task_rng().gen_integer_range(1u, 100);\n+            let times = task_rng().gen_range(1u, 100);\n             let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }"}, {"sha": "96123ad75b250603a7dfa877773f33c25c833741", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -226,9 +226,9 @@ enum Op {Union, Intersect, Assign, Difference}\n #[deriving(Clone)]\n pub struct Bitv {\n     /// Internal representation of the bit vector (small or large)\n-    rep: BitvVariant,\n+    priv rep: BitvVariant,\n     /// The number of valid bits in the internal representation\n-    nbits: uint\n+    priv nbits: uint\n }\n \n fn die() -> ! {"}, {"sha": "bb3524a7d490263f0c138e02266886f91505deed", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -365,7 +365,7 @@ pub mod test {\n         digest.reset();\n \n         while count < total_size {\n-            let next: uint = rng.gen_integer_range(0, 2 * blocksize + 1);\n+            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n             let remaining = total_size - count;\n             let size = if next > remaining { remaining } else { next };\n             digest.input(buffer.slice_to(size));"}, {"sha": "34515a2b955cb0b7ebe600fa38c5511821bd9f47", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -50,7 +50,7 @@ impl Doc {\n }\n \n pub struct TaggedDoc {\n-    tag: uint,\n+    priv tag: uint,\n     doc: Doc,\n }\n "}, {"sha": "49072dab6d025c76ada29125361f0d86affecf8e", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -155,7 +155,7 @@ struct FileInput_ {\n // \"self.fi\" -> \"self.\" and renaming FileInput_. Documentation above\n // will likely have to be updated to use `let mut in = ...`.\n pub struct FileInput  {\n-    fi: @mut FileInput_\n+    priv fi: @mut FileInput_\n }\n \n impl FileInput {"}, {"sha": "3f3b588e8bc183a04701a81ba76d1a0932b38dff", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -113,7 +113,7 @@ mod tests {\n         let mut r = rand::rng();\n         let mut words = ~[];\n         do 20.times {\n-            let range = r.gen_integer_range(1u, 10);\n+            let range = r.gen_range(1u, 10);\n             words.push(r.gen_vec::<u8>(range));\n         }\n         do 20.times {"}, {"sha": "38b4d83fe0be42afc400d32f57afcc2e079e1c4b", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -119,7 +119,7 @@ pub struct Opt {\n     /// How often it can occur\n     occur: Occur,\n     /// Which options it aliases\n-    aliases: ~[Opt],\n+    priv aliases: ~[Opt],\n }\n \n /// Describes wether an option is given at all or has a value.\n@@ -134,9 +134,9 @@ enum Optval {\n #[deriving(Clone, Eq)]\n pub struct Matches {\n     /// Options that matched\n-    opts: ~[Opt],\n+    priv opts: ~[Opt],\n     /// Values of the Options that matched\n-    vals: ~[~[Optval]],\n+    priv vals: ~[~[Optval]],\n     /// Free string fragments\n     free: ~[~str]\n }"}, {"sha": "5297b48b0e156719c83ccb3a127128cf66b5b1b2", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -480,21 +480,21 @@ pub struct MatchOptions {\n      * currently only considers upper/lower case relationships between ASCII characters,\n      * but in future this might be extended to work with Unicode.\n      */\n-    case_sensitive: bool,\n+    priv case_sensitive: bool,\n \n     /**\n      * If this is true then path-component separator characters (e.g. `/` on Posix)\n      * must be matched by a literal `/`, rather than by `*` or `?` or `[...]`\n      */\n-    require_literal_separator: bool,\n+    priv require_literal_separator: bool,\n \n     /**\n      * If this is true then paths that contain components that start with a `.` will\n      * not match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\n      * will not match. This is useful because such files are conventionally considered\n      * hidden on Unix systems and it might be desirable to skip them when listing files.\n      */\n-    require_literal_leading_dot: bool\n+    priv require_literal_leading_dot: bool\n }\n \n impl MatchOptions {"}, {"sha": "27a09be3a625b81fd1122fcc236317daeca59652", "filename": "src/libextra/io_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -17,9 +17,9 @@ use std::cast;\n /// An implementation of the io::Reader interface which reads a buffer of bytes\n pub struct BufReader {\n     /// The buffer of bytes to read\n-    buf: ~[u8],\n+    priv buf: ~[u8],\n     /// The current position in the buffer of bytes\n-    pos: @mut uint\n+    priv pos: @mut uint\n }\n \n impl BufReader {"}, {"sha": "90260282e4b5b87beedda504f0add0c56ea214e8", "filename": "src/libextra/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -49,11 +49,11 @@ pub type Object = TreeMap<~str, Json>;\n /// returned\n pub struct Error {\n     /// The line number at which the error occurred\n-    line: uint,\n+    priv line: uint,\n     /// The column number at which the error occurred\n-    col: uint,\n+    priv col: uint,\n     /// A message describing the type of the error\n-    msg: @~str,\n+    priv msg: @~str,\n }\n \n fn escape_str(s: &str) -> ~str {"}, {"sha": "bdec950c87bca5a176f048520ad1bd31987c1c37", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -20,8 +20,8 @@ use super::bigint::BigInt;\n #[deriving(Clone)]\n #[allow(missing_doc)]\n pub struct Ratio<T> {\n-    numer: T,\n-    denom: T\n+    priv numer: T,\n+    priv denom: T\n }\n \n /// Alias for a `Ratio` of machine-sized integers."}, {"sha": "02c35000ce3a4320bf280376492d7e8fe6290d0e", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -71,17 +71,17 @@ impl ToStr for Identifier {\n #[deriving(Clone, Eq)]\n pub struct Version {\n     /// The major version, to be incremented on incompatible changes.\n-    major: uint,\n+    priv major: uint,\n     /// The minor version, to be incremented when functionality is added in a\n     /// backwards-compatible manner.\n-    minor: uint,\n+    priv minor: uint,\n     /// The patch version, to be incremented when backwards-compatible bug\n     /// fixes are made.\n-    patch: uint,\n+    priv patch: uint,\n     /// The pre-release version identifier, if one exists.\n-    pre: ~[Identifier],\n+    priv pre: ~[Identifier],\n     /// The build metadata, ignored when determining version precedence.\n-    build: ~[Identifier],\n+    priv build: ~[Identifier],\n }\n \n impl ToStr for Version {"}, {"sha": "2a456f8de3ebe42c58d1da94af58369fcfc229fe", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -1069,8 +1069,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_integer_range(0u, n);\n-                let i2 = rng.gen_integer_range(0u, n);\n+                let i1 = rng.gen_range(0u, n);\n+                let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1088,7 +1088,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_integer_range(0u, n);\n+                let idx = rng.gen_range(0u, n);\n                 arr[idx] = rng.gen();\n             }\n             tim_sort(arr);\n@@ -1141,8 +1141,8 @@ mod big_tests {\n             isSorted(arr);\n \n             do 3.times {\n-                let i1 = rng.gen_integer_range(0u, n);\n-                let i2 = rng.gen_integer_range(0u, n);\n+                let i1 = rng.gen_range(0u, n);\n+                let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n             }\n             tim_sort(arr); // 3sort\n@@ -1160,7 +1160,7 @@ mod big_tests {\n             isSorted(arr);\n \n             do (n/100).times {\n-                let idx = rng.gen_integer_range(0u, n);\n+                let idx = rng.gen_range(0u, n);\n                 arr[idx] = @rng.gen();\n             }\n             tim_sort(arr);"}, {"sha": "40f99716ca796832054a69181e0df72f333a1980", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -105,18 +105,23 @@ pub trait Stats {\n #[deriving(Clone, Eq)]\n #[allow(missing_doc)]\n pub struct Summary {\n-    sum: f64,\n+    priv sum: f64,\n+    // public\n     min: f64,\n+    // public\n     max: f64,\n-    mean: f64,\n+    priv mean: f64,\n+    // public\n     median: f64,\n-    var: f64,\n-    std_dev: f64,\n-    std_dev_pct: f64,\n+    priv var: f64,\n+    priv std_dev: f64,\n+    priv std_dev_pct: f64,\n+    // public\n     median_abs_dev: f64,\n+    // public\n     median_abs_dev_pct: f64,\n-    quartiles: (f64,f64,f64),\n-    iqr: f64,\n+    priv quartiles: (f64,f64,f64),\n+    priv iqr: f64,\n }\n \n impl Summary {"}, {"sha": "131cf063d1d356f9e82f26779e9a56bfb27b2979", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -376,8 +376,8 @@ impl Semaphore {\n  * A task which fails while holding a mutex will unlock the mutex as it\n  * unwinds.\n  */\n-pub struct Mutex { priv sem: Sem<~[WaitQueue]> }\n \n+pub struct Mutex { priv sem: Sem<~[WaitQueue]> }\n impl Clone for Mutex {\n     /// Create a new handle to the mutex.\n     fn clone(&self) -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n@@ -663,8 +663,8 @@ impl RWLock {\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-pub struct RWLockWriteMode<'self> { priv lock: &'self RWLock, priv token: NonCopyable }\n \n+pub struct RWLockWriteMode<'self> { priv lock: &'self RWLock, priv token: NonCopyable }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n pub struct RWLockReadMode<'self> { priv lock: &'self RWLock,\n                                    priv token: NonCopyable }"}, {"sha": "f7db66dc4e0c491253d5342b7b304c6b00a08024", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -28,8 +28,8 @@ enum Msg<T> {\n }\n \n pub struct TaskPool<T> {\n-    channels: ~[Chan<Msg<T>>],\n-    next_index: uint,\n+    priv channels: ~[Chan<Msg<T>>],\n+    priv next_index: uint,\n }\n \n #[unsafe_destructor]"}, {"sha": "878224890e619f3bc05d463d261e2945cfaaf0d2", "filename": "src/libextra/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -95,14 +95,14 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n \n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n-    num_colors: u16,\n+    priv num_colors: u16,\n     priv out: @io::Writer,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n pub struct Terminal {\n-    num_colors: u16,\n+    priv num_colors: u16,\n     priv out: @io::Writer,\n }\n "}, {"sha": "c0a5d9d53aa9eb915d8818ad1c6b077d4e72daa3", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -48,9 +48,9 @@ pub enum Param {\n /// Container for static and dynamic variable arrays\n pub struct Variables {\n     /// Static variables A-Z\n-    sta: [Param, ..26],\n+    priv sta: [Param, ..26],\n     /// Dynamic variables a-z\n-    dyn: [Param, ..26]\n+    priv dyn: [Param, ..26]\n }\n \n impl Variables {"}, {"sha": "06bf6e47c329107bd7651e0c215805e467bce4eb", "filename": "src/libextra/terminfo/terminfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fterminfo%2Fterminfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fterminfo.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -15,9 +15,9 @@ use std::hashmap::HashMap;\n /// A parsed terminfo entry.\n pub struct TermInfo {\n     /// Names for the terminal\n-    names: ~[~str],\n+    priv names: ~[~str],\n     /// Map of capability name to boolean value\n-    bools: HashMap<~str, bool>,\n+    priv bools: HashMap<~str, bool>,\n     /// Map of capability name to numeric value\n     numbers: HashMap<~str, u16>,\n     /// Map of capability name to raw (unexpanded) string"}, {"sha": "f95c7aa22b7f0407f8c511d2e66dc1be38e70edc", "filename": "src/libextra/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -102,9 +102,9 @@ impl TestFn {\n \n // Structure passed to BenchFns\n pub struct BenchHarness {\n-    iterations: u64,\n-    ns_start: u64,\n-    ns_end: u64,\n+    priv iterations: u64,\n+    priv ns_start: u64,\n+    priv ns_end: u64,\n     bytes: u64\n }\n \n@@ -124,8 +124,8 @@ pub struct TestDescAndFn {\n \n #[deriving(Clone, Encodable, Decodable, Eq)]\n pub struct Metric {\n-    value: f64,\n-    noise: f64\n+    priv value: f64,\n+    priv noise: f64\n }\n \n #[deriving(Eq)]\n@@ -322,8 +322,8 @@ pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n \n #[deriving(Clone, Eq)]\n pub struct BenchSamples {\n-    ns_iter_summ: stats::Summary,\n-    mb_s: uint\n+    priv ns_iter_summ: stats::Summary,\n+    priv mb_s: uint\n }\n \n #[deriving(Clone, Eq)]"}, {"sha": "71569be3a8192e622540ffa89ffcdbc307066274", "filename": "src/libextra/time.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -31,9 +31,10 @@ pub mod rustrt {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-#[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n-pub struct Timespec { sec: i64, nsec: i32 }\n \n+\n+#[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n+pub struct Timespec { priv sec: i64, priv nsec: i32 }\n /*\n  * Timespec assumes that pre-epoch Timespecs have negative sec and positive\n  * nsec fields. Darwin's and Linux's struct timespec functions handle pre-\n@@ -105,18 +106,18 @@ pub fn tzset() {\n \n #[deriving(Clone, DeepClone, Eq, Encodable, Decodable)]\n pub struct Tm {\n-    tm_sec: i32, // seconds after the minute ~[0-60]\n-    tm_min: i32, // minutes after the hour ~[0-59]\n-    tm_hour: i32, // hours after midnight ~[0-23]\n-    tm_mday: i32, // days of the month ~[1-31]\n-    tm_mon: i32, // months since January ~[0-11]\n-    tm_year: i32, // years since 1900\n-    tm_wday: i32, // days since Sunday ~[0-6]\n-    tm_yday: i32, // days since January 1 ~[0-365]\n-    tm_isdst: i32, // Daylight Savings Time flag\n-    tm_gmtoff: i32, // offset from UTC in seconds\n-    tm_zone: ~str, // timezone abbreviation\n-    tm_nsec: i32, // nanoseconds\n+    priv tm_sec: i32, // seconds after the minute ~[0-60]\n+    priv tm_min: i32, // minutes after the hour ~[0-59]\n+    priv tm_hour: i32, // hours after midnight ~[0-23]\n+    priv tm_mday: i32, // days of the month ~[1-31]\n+    priv tm_mon: i32, // months since January ~[0-11]\n+    priv tm_year: i32, // years since 1900\n+    priv tm_wday: i32, // days since Sunday ~[0-6]\n+    priv tm_yday: i32, // days since January 1 ~[0-365]\n+    priv tm_isdst: i32, // Daylight Savings Time flag\n+    priv tm_gmtoff: i32, // offset from UTC in seconds\n+    priv tm_zone: ~str, // timezone abbreviation\n+    priv tm_nsec: i32, // nanoseconds\n }\n \n pub fn empty_tm() -> Tm {"}, {"sha": "7ef9ba76b995d481e57edd6507b790457f91ac13", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -1028,7 +1028,7 @@ mod test_treemap {\n             }\n \n             do 30.times {\n-                let r = rng.gen_integer_range(0, ctrl.len());\n+                let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);"}, {"sha": "4d79b2059db5cd94b14d3d94418050563337d700", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -128,8 +128,8 @@ impl WorkMap {\n }\n \n pub struct Database {\n-    db_filename: Path,\n-    db_cache: TreeMap<~str, ~str>,\n+    priv db_filename: Path,\n+    priv db_cache: TreeMap<~str, ~str>,\n     db_dirty: bool\n }\n \n@@ -209,7 +209,7 @@ impl Drop for Database {\n \n pub struct Logger {\n     // FIXME #4432: Fill in\n-    a: ()\n+    priv a: ()\n }\n \n impl Logger {\n@@ -228,26 +228,26 @@ pub type FreshnessMap = TreeMap<~str,extern fn(&str,&str)->bool>;\n #[deriving(Clone)]\n pub struct Context {\n     db: RWArc<Database>,\n-    logger: RWArc<Logger>,\n-    cfg: Arc<json::Object>,\n+    priv logger: RWArc<Logger>,\n+    priv cfg: Arc<json::Object>,\n     /// Map from kinds (source, exe, url, etc.) to a freshness function.\n     /// The freshness function takes a name (e.g. file path) and value\n     /// (e.g. hash of file contents) and determines whether it's up-to-date.\n     /// For example, in the file case, this would read the file off disk,\n     /// hash it, and return the result of comparing the given hash and the\n     /// read hash for equality.\n-    freshness: Arc<FreshnessMap>\n+    priv freshness: Arc<FreshnessMap>\n }\n \n pub struct Prep<'self> {\n-    ctxt: &'self Context,\n-    fn_name: &'self str,\n-    declared_inputs: WorkMap,\n+    priv ctxt: &'self Context,\n+    priv fn_name: &'self str,\n+    priv declared_inputs: WorkMap,\n }\n \n pub struct Exec {\n-    discovered_inputs: WorkMap,\n-    discovered_outputs: WorkMap\n+    priv discovered_inputs: WorkMap,\n+    priv discovered_outputs: WorkMap\n }\n \n enum Work<'self, T> {"}, {"sha": "10232730329427165e7221a768cc2228ea6727f0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -975,9 +975,9 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n     let explicit_self_kind = string[0];\n     match explicit_self_kind as char {\n         's' => { return ast::sty_static; }\n-        'v' => { return ast::sty_value; }\n+        'v' => { return ast::sty_value(get_mutability(string[1])); }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n-        '~' => { return ast::sty_uniq; }\n+        '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n         '&' => {\n             // FIXME(#4846) expl. region\n             return ast::sty_region(None, get_mutability(string[1]));"}, {"sha": "bae0dcc2a5203e576c8a1f7cdfa9085749d0f3cb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -662,8 +662,9 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explic\n         sty_static => {\n             ebml_w.writer.write(&[ 's' as u8 ]);\n         }\n-        sty_value => {\n+        sty_value(m) => {\n             ebml_w.writer.write(&[ 'v' as u8 ]);\n+            encode_mutability(ebml_w, m);\n         }\n         sty_region(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n@@ -674,8 +675,9 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explic\n             ebml_w.writer.write(&[ '@' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n-        sty_uniq => {\n+        sty_uniq(m) => {\n             ebml_w.writer.write(&[ '~' as u8 ]);\n+            encode_mutability(ebml_w, m);\n         }\n     }\n "}, {"sha": "3d7f28b8b30b1503fa57df1d27e84ca6ddce9efd", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -410,7 +410,7 @@ impl tr for ast::Def {\n             ast::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n           }\n           ast::DefSelfTy(nid) => { ast::DefSelfTy(xcx.tr_id(nid)) }\n-          ast::DefSelf(nid) => { ast::DefSelf(xcx.tr_id(nid)) }\n+          ast::DefSelf(nid, m) => { ast::DefSelf(xcx.tr_id(nid), m) }\n           ast::DefMod(did) => { ast::DefMod(did.tr(xcx)) }\n           ast::DefForeignMod(did) => { ast::DefForeignMod(did.tr(xcx)) }\n           ast::DefStatic(did, m) => { ast::DefStatic(did.tr(xcx), m) }"}, {"sha": "71934c9f2a7ed93db87d3a2cd125009c32d4f400", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -392,7 +392,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n     match *fk {\n         visit::fk_method(_, _, method) => {\n             match method.explicit_self.node {\n-                sty_value | sty_region(*) | sty_box(_) | sty_uniq => {\n+                sty_value(_) | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));\n                 }"}, {"sha": "eb03027ad71ffd3b0c1bcc0693e338230e6ac3b6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -488,12 +488,12 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::DefSelf(self_id) => {\n+          ast::DefSelf(self_id, mutbl) => {\n             @cmt_ {\n                 id:id,\n                 span:span,\n                 cat:cat_self(self_id),\n-                mutbl: McImmutable,\n+                mutbl: if mutbl { McDeclared } else { McImmutable },\n                 ty:expr_ty\n             }\n           }"}, {"sha": "5001614647a88993af475cc9f2d8e6b41ad1b7a3", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -227,7 +227,7 @@ pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n       DefBinding(nid, _) |\n       DefArg(nid, _) |\n       DefLocal(nid, _) |\n-      DefSelf(nid) => Some(nid),\n+      DefSelf(nid, _) => Some(nid),\n \n       _ => None\n     }"}, {"sha": "ee36b807ac79c358311f26e9524d3efc4ca0853b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -150,7 +150,7 @@ enum Mutability {\n \n enum SelfBinding {\n     NoSelfBinding,\n-    HasSelfBinding(NodeId)\n+    HasSelfBinding(NodeId, explicit_self)\n }\n \n impl Visitor<()> for Resolver {\n@@ -3799,8 +3799,12 @@ impl Resolver {\n                 NoSelfBinding => {\n                     // Nothing to do.\n                 }\n-                HasSelfBinding(self_node_id) => {\n-                    let def_like = DlDef(DefSelf(self_node_id));\n+                HasSelfBinding(self_node_id, explicit_self) => {\n+                    let mutable = match explicit_self.node {\n+                        sty_uniq(m) | sty_value(m) if m == MutMutable => true,\n+                        _ => false\n+                    };\n+                    let def_like = DlDef(DefSelf(self_node_id, mutable));\n                     *function_value_rib.self_binding = Some(def_like);\n                 }\n             }\n@@ -3937,7 +3941,7 @@ impl Resolver {\n         // we only have self ty if it is a non static method\n         let self_binding = match method.explicit_self.node {\n           sty_static => { NoSelfBinding }\n-          _ => { HasSelfBinding(method.self_id) }\n+          _ => { HasSelfBinding(method.self_id, method.explicit_self) }\n         };\n \n         self.resolve_function(rib_kind,"}, {"sha": "56f1e0478410264a2ad13ab01b99894237dc9eeb", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -1099,7 +1099,7 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n         ast::DefLocal(nid, _) | ast::DefBinding(nid, _) => {\n             take_local(bcx, bcx.fcx.lllocals, nid)\n         }\n-        ast::DefSelf(nid) => {\n+        ast::DefSelf(nid, _) => {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n                 Some(ref self_info) => *self_info,\n                 None => {"}, {"sha": "d9f7cdeeb2ef11877ea3a68c0143df639bdcf7b2", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -144,7 +144,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n                       debug!(\"calling inline trans_fn with self_ty {}\",\n                              ty_to_str(ccx.tcx, self_ty));\n                       match mth.explicit_self.node {\n-                          ast::sty_value => impl_self(self_ty, ty::ByRef),\n+                          ast::sty_value(_) => impl_self(self_ty, ty::ByRef),\n                           _ => impl_self(self_ty, ty::ByCopy),\n                       }\n                   }"}, {"sha": "61384c72efa259ec2d5fd8b452bc96171165f6e2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -120,7 +120,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n         debug!(\"calling trans_fn with self_ty {}\",\n                self_ty.repr(ccx.tcx));\n         match method.explicit_self.node {\n-          ast::sty_value => impl_self(self_ty, ty::ByRef),\n+          ast::sty_value(_) => impl_self(self_ty, ty::ByRef),\n           _ => impl_self(self_ty, ty::ByCopy),\n         }\n       }"}, {"sha": "dd0c6c12a69aacf3077fdf7f683562ef7ab956ae", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -672,7 +672,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     {\n         match self_info.explicit_self.node {\n             ast::sty_static => None,\n-            ast::sty_value => {\n+            ast::sty_value(_) => {\n                 Some(self_info.untransformed_self_ty)\n             }\n             ast::sty_region(ref lifetime, mutability) => {\n@@ -689,7 +689,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n                                 ty::mt {ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability}))\n             }\n-            ast::sty_uniq => {\n+            ast::sty_uniq(_) => {\n                 Some(ty::mk_uniq(this.tcx(),\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: ast::MutImmutable}))"}, {"sha": "af1d5ce3cc608afc5b62ea8944b027566d468921", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -1082,7 +1082,7 @@ impl<'self> LookupContext<'self> {\n             ast::sty_static => {\n                 self.bug(~\"static method for object type receiver\");\n             }\n-            ast::sty_value => {\n+            ast::sty_value(_) => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n             ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {\n@@ -1141,7 +1141,7 @@ impl<'self> LookupContext<'self> {\n                      through an object\");\n             }\n \n-            ast::sty_value => { // reason (a) above\n+            ast::sty_value(_) => { // reason (a) above\n                 self.tcx().sess.span_err(\n                     self.expr.span,\n                     \"cannot call a method with a by-value receiver \\\n@@ -1198,7 +1198,7 @@ impl<'self> LookupContext<'self> {\n                 false\n             }\n \n-            sty_value => {\n+            sty_value(_) => {\n                 rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n             }\n \n@@ -1236,7 +1236,7 @@ impl<'self> LookupContext<'self> {\n                 }\n             }\n \n-            sty_uniq => {\n+            sty_uniq(_) => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n@@ -1369,7 +1369,7 @@ impl<'self> LookupContext<'self> {\n \n pub fn get_mode_from_explicit_self(explicit_self: ast::explicit_self_) -> SelfMode {\n     match explicit_self {\n-        sty_value => ty::ByRef,\n+        sty_value(_) => ty::ByRef,\n         _ => ty::ByCopy,\n     }\n }"}, {"sha": "4514564ff1f6c98f806193841e3e62c099d8dbb5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -3254,7 +3254,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n                                       defn: ast::Def)\n                                    -> ty_param_bounds_and_ty {\n     match defn {\n-      ast::DefArg(nid, _) | ast::DefLocal(nid, _) | ast::DefSelf(nid) |\n+      ast::DefArg(nid, _) | ast::DefLocal(nid, _) | ast::DefSelf(nid, _) |\n       ast::DefBinding(nid, _) => {\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);"}, {"sha": "09fc7b5c15c34f96abc49fcefc734d64b672fe2e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -58,7 +58,7 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         DefLocal(node_id, _) | DefArg(node_id, _) |\n-        DefSelf(node_id) | DefBinding(node_id, _) => {\n+        DefSelf(node_id, _) | DefBinding(node_id, _) => {\n             tcx.region_maps.encl_region(node_id)\n         }\n         DefUpvar(_, subdef, closure_id, body_id) => {"}, {"sha": "dd1ad8263da860c2d1eb6d9864f6ffc2a8244855", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -388,8 +388,8 @@ impl Clean<SelfTy> for ast::explicit_self {\n     fn clean(&self) -> SelfTy {\n         match self.node {\n             ast::sty_static => SelfStatic,\n-            ast::sty_value => SelfValue,\n-            ast::sty_uniq => SelfOwned,\n+            ast::sty_value(_) => SelfValue,\n+            ast::sty_uniq(_) => SelfOwned,\n             ast::sty_region(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n             ast::sty_box(mt) => SelfManaged(mt.clean()),\n         }\n@@ -1171,7 +1171,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n \n     let (def_id, kind) = match *d {\n         ast::DefFn(i, _) => (i, TypeFunction),\n-        ast::DefSelf(i) | ast::DefSelfTy(i) => return Self(i),\n+        ast::DefSelf(i, _) | ast::DefSelfTy(i) => return Self(i),\n         ast::DefTy(i) => (i, TypeEnum),\n         ast::DefTrait(i) => {\n             debug!(\"saw DefTrait in def_to_id\");"}, {"sha": "c67b6f52c7e399cff7bed8dd1fa44f91dfbf408c", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 86, "deletions": 10, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -12,22 +12,35 @@ use context::*;\n use crate::*;\n use package_id::*;\n use package_source::*;\n+use path_util::{platform_library_name, target_build_dir};\n use target::*;\n use version::Version;\n+use workspace::pkg_parent_workspaces;\n use workcache_support::*;\n+pub use path_util::default_workspace;\n \n pub use source_control::{safe_git_clone, git_clone_url};\n \n-use std::os;\n+use std::{os, run};\n use extra::arc::{Arc,RWArc};\n use extra::workcache;\n use extra::workcache::{Database, Logger, FreshnessMap};\n use extra::treemap::TreeMap;\n \n+// A little sad -- duplicated from rustc::back::*\n+#[cfg(target_arch = \"arm\")]\n+fn cc_args() -> ~[~str] { ~[~\"-marm\"] }\n+#[cfg(target_arch = \"mips\")]\n+fn cc_args() -> ~[~str] { ~[] }\n+#[cfg(target_arch = \"x86\")]\n+fn cc_args() -> ~[~str] { ~[~\"-m32\"] }\n+#[cfg(target_arch = \"x86_64\")]\n+fn cc_args() -> ~[~str] { ~[~\"-m64\"] }\n+\n /// Convenience functions intended for calling from pkg.rs\n /// p is where to put the cache file for dependencies\n-pub fn default_context(p: Path) -> BuildContext {\n-    new_default_context(new_workcache_context(&p), p)\n+pub fn default_context(sysroot: Path, p: Path) -> BuildContext {\n+    new_default_context(new_workcache_context(&p), sysroot)\n }\n \n pub fn new_default_context(c: workcache::Context, p: Path) -> BuildContext {\n@@ -68,7 +81,7 @@ pub fn new_workcache_context(p: &Path) -> workcache::Context {\n \n pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n                  lib: Path) {\n-    let cx = default_context(sysroot);\n+    let cx = default_context(sysroot, root.clone());\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n@@ -81,12 +94,12 @@ pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Version,\n         tests: ~[],\n         benchs: ~[]\n     };\n-    pkg_src.build(&cx, ~[]);\n+    pkg_src.build(&cx, ~[], []);\n }\n \n pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n                  main: Path) {\n-    let cx = default_context(sysroot);\n+    let cx = default_context(sysroot, root.clone());\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n@@ -100,13 +113,76 @@ pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Version,\n         benchs: ~[]\n     };\n \n-    pkg_src.build(&cx, ~[]);\n+    pkg_src.build(&cx, ~[], []);\n }\n \n-pub fn install_pkg(sysroot: Path, workspace: Path, name: ~str, version: Version) {\n-    let cx = default_context(sysroot);\n+pub fn install_pkg(cx: &BuildContext,\n+                   workspace: Path,\n+                   name: ~str,\n+                   version: Version,\n+                   // For now, these inputs are assumed to be inputs to each of the crates\n+                   more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n     let pkgid = PkgId{ version: version, ..PkgId::new(name)};\n-    cx.install(PkgSrc::new(workspace.clone(), workspace, false, pkgid), &Everything);\n+    cx.install(PkgSrc::new(workspace.clone(), workspace, false, pkgid),\n+               &WhatToBuild{ build_type: Inferred,\n+                             inputs_to_discover: more_inputs,\n+                             sources: Everything });\n+}\n+\n+/// Builds an arbitrary library whose short name is `output`,\n+/// by invoking `tool` with arguments `args` plus \"-o %s\", where %s\n+/// is the platform-specific library name for `output`.\n+/// Returns that platform-specific name.\n+pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n+                                  context: &mut Context,\n+                                  package_name: &str,\n+                                  tool: &str,\n+                                  flags: &[~str],\n+                                  paths: &[~str],\n+                                  output: &str) -> ~str {\n+    use command_failed = conditions::command_failed::cond;\n+\n+    let workspace = my_workspace(context, package_name);\n+    let workspace_build_dir = target_build_dir(&workspace);\n+    let out_name = workspace_build_dir.join_many([package_name.to_str(),\n+                                                  platform_library_name(output)]);\n+    // make paths absolute\n+    let pkgid = PkgId::new(package_name);\n+    let absolute_paths = paths.map(|s| {\n+            let whatever = workspace.join_many([~\"src\",\n+                                pkgid.to_str(),\n+                                s.to_owned()]);\n+            whatever.as_str().unwrap().to_owned()\n+        });\n+\n+    let cc_args = cc_args();\n+\n+    let all_args = flags + absolute_paths + cc_args +\n+         ~[~\"-o\", out_name.as_str().unwrap().to_owned()];\n+    let exit_code = run::process_status(tool, all_args);\n+    if exit_code != 0 {\n+        command_failed.raise((tool.to_owned(), all_args, exit_code))\n+    }\n+    else {\n+        let out_name_str = out_name.as_str().unwrap().to_owned();\n+        exec.discover_output(\"binary\",\n+                             out_name_str,\n+                             digest_only_date(&out_name));\n+        context.add_library_path(out_name.dir_path());\n+        out_name_str\n+    }\n+}\n+\n+pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n+    use bad_pkg_id     = conditions::bad_pkg_id::cond;\n+\n+    // (this assumes no particular version is requested)\n+    let pkgid = PkgId::new(package_name);\n+    let workspaces = pkg_parent_workspaces(context, &pkgid);\n+    if workspaces.is_empty() {\n+        bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));\n+    }\n+    workspaces[0]\n }\n \n fn mk_crate(p: Path) -> Crate {"}, {"sha": "91edc27582641925e12aeb7fe925bc13c6c502c8", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -53,3 +53,9 @@ condition! {\n condition! {\n     pub git_checkout_failed: (~str, Path) -> ();\n }\n+\n+condition! {\n+    // str is output of applying the command (first component)\n+    // to the args (second component)\n+    pub command_failed: (~str, ~[~str], int) -> ~str;\n+}"}, {"sha": "72197219fc5aecd477c1e20c249f7cc44dad8866", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -54,6 +54,15 @@ impl BuildContext {\n     pub fn compile_upto(&self) -> StopBefore {\n         self.context.compile_upto()\n     }\n+\n+    pub fn add_library_path(&mut self, p: Path) {\n+        debug!(\"Adding library path: {}\", p.display());\n+        self.context.add_library_path(p);\n+    }\n+\n+    pub fn additional_library_paths(&self) -> ~[Path] {\n+        self.context.rustc_flags.additional_library_paths.clone()\n+    }\n }\n \n /*\n@@ -85,6 +94,9 @@ pub struct RustcFlags {\n     target: Option<~str>,\n     // Target CPU (defaults to rustc's default target CPU)\n     target_cpu: Option<~str>,\n+    // Additional library directories, which get passed with the -L flag\n+    // This can't be set with a rustpkg flag, only from package scripts\n+    additional_library_paths: ~[Path],\n     // Any -Z features\n     experimental_features: Option<~[~str]>\n }\n@@ -99,6 +111,7 @@ impl Clone for RustcFlags {\n             save_temps: self.save_temps,\n             target: self.target.clone(),\n             target_cpu: self.target_cpu.clone(),\n+            additional_library_paths: self.additional_library_paths.clone(),\n             experimental_features: self.experimental_features.clone()\n         }\n     }\n@@ -148,6 +161,10 @@ impl Context {\n     pub fn compile_upto(&self) -> StopBefore {\n         self.rustc_flags.compile_upto\n     }\n+\n+    pub fn add_library_path(&mut self, p: Path) {\n+        self.rustc_flags.additional_library_paths.push(p);\n+    }\n }\n \n /// We assume that if ../../rustc exists, then we're running\n@@ -210,6 +227,7 @@ impl RustcFlags {\n             save_temps: false,\n             target: None,\n             target_cpu: None,\n+            additional_library_paths: ~[],\n             experimental_features: None\n         }\n     }"}, {"sha": "17ba79862e0cab0966fba99bafdc378348ed0f63", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -23,7 +23,7 @@ use path_util::{find_dir_using_rust_path_hack, make_dir_rwx_recursive, default_w\n use path_util::{target_build_dir, versionize, dir_has_crate_file};\n use util::{compile_crate, DepMap};\n use workcache_support;\n-use workcache_support::crate_tag;\n+use workcache_support::{digest_only_date, digest_file_with_date, crate_tag};\n use extra::workcache;\n use extra::treemap::TreeMap;\n \n@@ -390,7 +390,8 @@ impl PkgSrc {\n                     deps: &mut DepMap,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n-                    what: OutputType) {\n+                    what: OutputType,\n+                    inputs_to_discover: &[(~str, Path)]) {\n         for crate in crates.iter() {\n             let path = self.start_dir.join(&crate.file);\n             debug!(\"build_crates: compiling {}\", path.display());\n@@ -408,7 +409,19 @@ impl PkgSrc {\n                 let sub_dir = self.build_workspace().clone();\n                 let sub_flags = crate.flags.clone();\n                 let sub_deps = deps.clone();\n+                let inputs = inputs_to_discover.map(|&(ref k, ref p)|\n+                                                    (k.clone(), p.as_str().unwrap().to_owned()));\n                 do prep.exec |exec| {\n+                    for &(ref kind, ref p) in inputs.iter() {\n+                        let pth = Path::new(p.clone());\n+                        exec.discover_input(*kind, *p, if *kind == ~\"file\" {\n+                                digest_file_with_date(&pth)\n+                            } else if *kind == ~\"binary\" {\n+                                digest_only_date(&Path::new(p.clone()))\n+                            } else {\n+                                fail!(\"Bad kind in build_crates\")\n+                            });\n+                    }\n                     let result = compile_crate(&subcx,\n                                                exec,\n                                                &id,\n@@ -452,22 +465,43 @@ impl PkgSrc {\n                  build_context: &BuildContext,\n                  // DepMap is a map from str (crate name) to (kind, name) --\n                  // it tracks discovered dependencies per-crate\n-                 cfgs: ~[~str]) -> DepMap {\n+                 cfgs: ~[~str],\n+                 inputs_to_discover: &[(~str, Path)]) -> DepMap {\n         let mut deps = TreeMap::new();\n-\n         let libs = self.libs.clone();\n         let mains = self.mains.clone();\n         let tests = self.tests.clone();\n         let benchs = self.benchs.clone();\n         debug!(\"Building libs in {}, destination = {}\",\n-               self.source_workspace.display(), self.build_workspace().display());\n-        self.build_crates(build_context, &mut deps, libs, cfgs, Lib);\n+               self.destination_workspace.display(),\n+               self.destination_workspace.display());\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          libs,\n+                          cfgs,\n+                          Lib,\n+                          inputs_to_discover);\n         debug!(\"Building mains\");\n-        self.build_crates(build_context, &mut deps, mains, cfgs, Main);\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          mains,\n+                          cfgs,\n+                          Main,\n+                          inputs_to_discover);\n         debug!(\"Building tests\");\n-        self.build_crates(build_context, &mut deps, tests, cfgs, Test);\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          tests,\n+                          cfgs,\n+                          Test,\n+                          inputs_to_discover);\n         debug!(\"Building benches\");\n-        self.build_crates(build_context, &mut deps, benchs, cfgs, Bench);\n+        self.build_crates(build_context,\n+                          &mut deps,\n+                          benchs,\n+                          cfgs,\n+                          Bench,\n+                          inputs_to_discover);\n         deps\n     }\n "}, {"sha": "a48ef23115ccf71c3ebe832cc646270cae4e75cf", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -461,7 +461,6 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n     p.with_filename(q)\n }\n \n-\n #[cfg(target_os = \"win32\")]\n pub fn chmod_read_only(p: &Path) -> bool {\n     #[fixed_stack_segment];\n@@ -483,3 +482,6 @@ pub fn chmod_read_only(p: &Path) -> bool {\n     }\n }\n \n+pub fn platform_library_name(s: &str) -> ~str {\n+    format!(\"{}{}{}\", os::consts::DLL_PREFIX, s, os::consts::DLL_SUFFIX)\n+}"}, {"sha": "37a5a2ea711329b9b369a17178dc467b7476fd20", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 66, "deletions": 47, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -33,7 +33,6 @@ use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n-use util::*;\n use messages::{error, warn, note};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n use path_util::{U_RWX, in_rust_path};\n@@ -47,15 +46,16 @@ use context::{Context, BuildContext,\n                        LLVMAssemble, LLVMCompileBitcode};\n use package_id::PkgId;\n use package_source::PkgSrc;\n-use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench, Tests};\n+use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n+use target::{Tests, MaybeCustom, Inferred, JustOne};\n use workcache_support::digest_only_date;\n use exit_codes::{COPY_FAILED_CODE, BAD_FLAG_CODE};\n \n pub mod api;\n mod conditions;\n-mod context;\n+pub mod context;\n mod crate;\n-mod exit_codes;\n+pub mod exit_codes;\n mod installed_packages;\n mod messages;\n mod package_id;\n@@ -67,7 +67,7 @@ mod target;\n #[cfg(test)]\n mod tests;\n mod util;\n-mod version;\n+pub mod version;\n pub mod workcache_support;\n mod workspace;\n \n@@ -96,7 +96,7 @@ impl<'self> PkgScript<'self> {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute\n-    fn parse<'a>(sysroot: @Path,\n+    fn parse<'a>(sysroot: Path,\n                  script: Path,\n                  workspace: &Path,\n                  id: &'a PkgId) -> PkgScript<'a> {\n@@ -107,7 +107,7 @@ impl<'self> PkgScript<'self> {\n         debug!(\"pkgscript parse: {}\", sysroot.display());\n         let options = @session::options {\n             binary: binary,\n-            maybe_sysroot: Some(sysroot),\n+            maybe_sysroot: Some(@sysroot),\n             crate_type: session::bin_crate,\n             .. (*session::basic_options()).clone()\n         };\n@@ -132,12 +132,7 @@ impl<'self> PkgScript<'self> {\n         }\n     }\n \n-    /// Run the contents of this package script, where <what>\n-    /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n-    /// Returns a pair of an exit code and list of configs (obtained by\n-    /// calling the package script's configs() function if it exists\n-    fn run_custom(&mut self, exec: &mut workcache::Exec,\n-                  sysroot: &Path) -> (~[~str], ExitCode) {\n+    fn build_custom(&mut self, exec: &mut workcache::Exec) -> ~str {\n         let sess = self.sess;\n \n         debug!(\"Working directory = {}\", self.build_dir.display());\n@@ -152,24 +147,36 @@ impl<'self> PkgScript<'self> {\n                                        &self.build_dir,\n                                        sess,\n                                        crate);\n-        debug!(\"Running program: {} {} {}\", exe.display(),\n-               sysroot.display(), \"install\");\n         // Discover the output\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        exec.discover_output(\"binary\", exe.as_str().unwrap(), digest_only_date(&exe));\n+        // Discover the output\n+        exec.discover_output(\"binary\", exe.as_str().unwrap().to_owned(), digest_only_date(&exe));\n+        exe.as_str().unwrap().to_owned()\n+    }\n+\n+\n+    /// Run the contents of this package script, where <what>\n+    /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n+    /// Returns a pair of an exit code and list of configs (obtained by\n+    /// calling the package script's configs() function if it exists\n+    fn run_custom(exe: &Path, sysroot: &Path) -> (~[~str], int) {\n+        debug!(\"Running program: {} {} {}\", exe.as_str().unwrap().to_owned(),\n+               sysroot.display(), \"install\");\n         // FIXME #7401 should support commands besides `install`\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let status = run::process_status(exe.as_str().unwrap(),\n                                          [sysroot.as_str().unwrap().to_owned(), ~\"install\"]);\n         if status != 0 {\n-            return (~[], status);\n+            debug!(\"run_custom: first pkg command failed with {:?}\", status);\n+            (~[], status)\n         }\n         else {\n             debug!(\"Running program (configs): {} {} {}\",\n                    exe.display(), sysroot.display(), \"configs\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let output = run::process_output(exe.as_str().unwrap(),\n                                              [sysroot.as_str().unwrap().to_owned(), ~\"configs\"]);\n+            debug!(\"run_custom: second pkg command did {:?}\", output.status);\n             // Run the configs() function to get the configs\n             let cfgs = str::from_utf8_slice(output.output).word_iter()\n                 .map(|w| w.to_owned()).collect();\n@@ -263,7 +270,7 @@ impl CtxMethods for BuildContext {\n         let cwd = os::getcwd();\n         match cmd {\n             \"build\" => {\n-                self.build_args(args, &Everything);\n+                self.build_args(args, &WhatToBuild::new(MaybeCustom, Everything));\n             }\n             \"clean\" => {\n                 if args.len() < 1 {\n@@ -301,12 +308,14 @@ impl CtxMethods for BuildContext {\n                             let inferred_pkgid =\n                                 PkgId::new(cwd.filename_str().unwrap());\n                             self.install(PkgSrc::new(cwd, default_workspace(),\n-                                                     true, inferred_pkgid), &Everything);\n+                                                     true, inferred_pkgid),\n+                                         &WhatToBuild::new(MaybeCustom, Everything));\n                         }\n                         None  => { usage::install(); return; }\n                         Some((ws, pkgid))                => {\n                             let pkg_src = PkgSrc::new(ws.clone(), ws.clone(), false, pkgid);\n-                            self.install(pkg_src, &Everything);\n+                            self.install(pkg_src, &WhatToBuild::new(MaybeCustom,\n+                                                                    Everything));\n                       }\n                   }\n                 }\n@@ -320,7 +329,7 @@ impl CtxMethods for BuildContext {\n                     if workspaces.is_empty() {\n                         let d = default_workspace();\n                         let src = PkgSrc::new(d.clone(), d, false, pkgid.clone());\n-                        self.install(src, &Everything);\n+                        self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                     }\n                     else {\n                         for workspace in workspaces.iter() {\n@@ -331,7 +340,7 @@ impl CtxMethods for BuildContext {\n                                                   dest,\n                                                   self.context.use_rust_path_hack,\n                                                   pkgid.clone());\n-                            self.install(src, &Everything);\n+                            self.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n                         };\n                     }\n                 }\n@@ -354,7 +363,8 @@ impl CtxMethods for BuildContext {\n             }\n             \"test\" => {\n                 // Build the test executable\n-                let maybe_id_and_workspace = self.build_args(args, &Tests);\n+                let maybe_id_and_workspace = self.build_args(args,\n+                                                             &WhatToBuild::new(MaybeCustom, Tests));\n                 match maybe_id_and_workspace {\n                     Some((pkg_id, workspace)) => {\n                         // Assuming it's built, run the tests\n@@ -420,6 +430,7 @@ impl CtxMethods for BuildContext {\n                 pkgid = {} pkgsrc start_dir = {}\", workspace.display(),\n                in_rust_path(&workspace), is_git_dir(&workspace.join(&pkgid.path)),\n                pkgid.to_str(), pkg_src.start_dir.display());\n+        debug!(\"build: what to build = {:?}\", what_to_build);\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n@@ -448,27 +459,27 @@ impl CtxMethods for BuildContext {\n         debug!(\"Package source directory = {}\", pkg_src.to_str());\n         let opt = pkg_src.package_script_option();\n         debug!(\"Calling pkg_script_option on {:?}\", opt);\n-        let cfgs = match pkg_src.package_script_option() {\n-            Some(package_script_path) => {\n+        let cfgs = match (pkg_src.package_script_option(), what_to_build.build_type) {\n+            (Some(package_script_path), MaybeCustom)  => {\n                 let sysroot = self.sysroot_to_use();\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let pkg_script_path_str = package_script_path.as_str().unwrap();\n-                let (cfgs, hook_result) =\n-                    do self.workcache_context.with_prep(pkg_script_path_str) |prep| {\n-                    let sub_sysroot = sysroot.clone();\n-                    let package_script_path_clone = package_script_path.clone();\n-                    let sub_ws = workspace.clone();\n-                    let sub_id = pkgid.clone();\n-                    declare_package_script_dependency(prep, &*pkg_src);\n+                // Build the package script if needed\n+                let script_build = format!(\"build_package_script({})\",\n+                                           package_script_path.display());\n+                let pkg_exe = do self.workcache_context.with_prep(script_build) |prep| {\n+                    let subsysroot = sysroot.clone();\n+                    let psp = package_script_path.clone();\n+                    let ws = workspace.clone();\n+                    let pid = pkgid.clone();\n                     do prep.exec |exec| {\n-                        let mut pscript = PkgScript::parse(@sub_sysroot.clone(),\n-                                                          package_script_path_clone.clone(),\n-                                                          &sub_ws,\n-                                                          &sub_id);\n-\n-                        pscript.run_custom(exec, &sub_sysroot)\n+                        let mut pscript = PkgScript::parse(subsysroot.clone(),\n+                                                           psp.clone(),\n+                                                           &ws,\n+                                                           &pid);\n+                        pscript.build_custom(exec)\n                     }\n                 };\n+                // We always *run* the package script\n+                let (cfgs, hook_result) = PkgScript::run_custom(&Path::new(pkg_exe), &sysroot);\n                 debug!(\"Command return code = {:?}\", hook_result);\n                 if hook_result != 0 {\n                     fail!(\"Error running custom build command\")\n@@ -477,7 +488,11 @@ impl CtxMethods for BuildContext {\n                 // otherwise, the package script succeeded\n                 cfgs\n             }\n-            None => {\n+            (Some(_), Inferred) => {\n+                debug!(\"There is a package script, but we're ignoring it\");\n+                ~[]\n+            }\n+            (None, _) => {\n                 debug!(\"No package script, continuing\");\n                 ~[]\n             }\n@@ -486,13 +501,13 @@ impl CtxMethods for BuildContext {\n         // If there was a package script, it should have finished\n         // the build already. Otherwise...\n         if !custom {\n-            match what_to_build {\n+            match what_to_build.sources {\n                 // Find crates inside the workspace\n-                &Everything => pkg_src.find_crates(),\n+                Everything => pkg_src.find_crates(),\n                 // Find only tests\n-                &Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::new(s)) }),\n+                Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path::new(s)) }),\n                 // Don't infer any crates -- just build the one that was requested\n-                &JustOne(ref p) => {\n+                JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n                     // so check that assumption\n                     debug!(\"JustOne: p = {}\", p.display());\n@@ -512,7 +527,7 @@ impl CtxMethods for BuildContext {\n                 }\n             }\n             // Build it!\n-            pkg_src.build(self, cfgs);\n+            pkg_src.build(self, cfgs, []);\n         }\n     }\n \n@@ -551,6 +566,8 @@ impl CtxMethods for BuildContext {\n         // just means inferring all the crates in it, then building each one.\n         self.build(&mut pkg_src, what);\n \n+        debug!(\"Done building package source {}\", pkg_src.to_str());\n+\n         let to_do = ~[pkg_src.libs.clone(), pkg_src.mains.clone(),\n                       pkg_src.tests.clone(), pkg_src.benchs.clone()];\n         debug!(\"In declare inputs for {}\", id.to_str());\n@@ -823,6 +840,7 @@ pub fn main_args(args: &[~str]) -> int {\n         save_temps: save_temps,\n         target: target,\n         target_cpu: target_cpu,\n+        additional_library_paths: ~[], // No way to set this from the rustpkg command line\n         experimental_features: experimental_features\n     };\n \n@@ -895,7 +913,8 @@ pub fn main_args(args: &[~str]) -> int {\n                 use_rust_path_hack: use_rust_path_hack,\n                 sysroot: sroot.clone(), // Currently, only tests override this\n             },\n-            workcache_context: api::default_context(default_workspace()).workcache_context\n+            workcache_context: api::default_context(sroot.clone(),\n+                                                    default_workspace()).workcache_context\n         }.run(sub_cmd, rm_args.clone())\n     };\n     // FIXME #9262: This is using the same error code for all errors,"}, {"sha": "9863fd0a89ee9357fb2dd9c8fb95f2df14c6dda7", "filename": "src/librustpkg/target.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -23,7 +23,31 @@ pub enum Target {\n }\n \n #[deriving(Eq, Clone)]\n-pub enum WhatToBuild {\n+pub struct WhatToBuild {\n+    build_type: BuildType, // Whether or not to ignore the pkg.rs file\n+    sources: SourceType, // Which crates to build\n+    inputs_to_discover: ~[(~str, Path)] // Inputs to these crates to be discovered\n+        // (For now all of these inputs will be taken as discovered inputs\n+        // for all of the crates)\n+        // (Paired with their kinds)\n+}\n+\n+impl WhatToBuild {\n+    pub fn new(build_type: BuildType, sources: SourceType) -> WhatToBuild {\n+        WhatToBuild { build_type: build_type,\n+                      sources: sources,\n+                      inputs_to_discover: ~[] }\n+    }\n+}\n+\n+#[deriving(Eq, Clone)]\n+pub enum BuildType {\n+    Inferred, // Ignore the pkg.rs file even if one exists\n+    MaybeCustom // Use the pkg.rs file if it exists\n+}\n+\n+#[deriving(Eq, Clone)]\n+pub enum SourceType {\n     /// Build just one lib.rs file in `path`, which is relative to the active workspace's src/ dir\n     JustOne(Path),\n     /// Build any test.rs files that can be recursively found in the active workspace"}, {"sha": "16e13f700921246d932a0b018e44db84be392d42", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 109, "deletions": 12, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -28,7 +28,7 @@ use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                library_in_workspace, installed_library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace, target_build_dir,\n-               chmod_read_only};\n+               chmod_read_only, platform_library_name};\n use rustc::back::link::get_cc_prog;\n use rustc::metadata::filesearch::rust_path;\n use rustc::driver::driver::{build_session, build_session_options, host_triple, optgroups};\n@@ -299,12 +299,6 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n                     cmd, args, str::from_utf8(output.output),\n                    str::from_utf8(output.error),\n                    output.status);\n-/*\n-By the way, rustpkg *won't* return a nonzero exit code if it fails --\n-see #4547\n-So tests that use this need to check the existence of a file\n-to make sure the command succeeded\n-*/\n     if output.status != 0 {\n         debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n@@ -600,7 +594,7 @@ fn test_install_valid() {\n                           temp_workspace.clone(),\n                           false,\n                           temp_pkg_id.clone());\n-    ctxt.install(src, &Everything);\n+    ctxt.install(src, &WhatToBuild::new(MaybeCustom, Everything));\n     // Check that all files exist\n     let exec = target_executable_in_workspace(&temp_pkg_id, temp_workspace);\n     debug!(\"exec = {}\", exec.display());\n@@ -639,7 +633,7 @@ fn test_install_invalid() {\n                                   temp_workspace.clone(),\n                                   false,\n                                   pkgid.clone());\n-        ctxt.install(pkg_src, &Everything);\n+        ctxt.install(pkg_src, &WhatToBuild::new(MaybeCustom, Everything));\n     };\n     // Not the best test -- doesn't test that we failed in the right way.\n     // Best we can do for now.\n@@ -897,22 +891,25 @@ fn rustpkg_local_pkg() {\n }\n \n #[test]\n-#[ignore (reason = \"test makes bogus assumptions about build directory layout: issue #8690\")]\n fn package_script_with_default_build() {\n     let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n     let dir = dir.path();\n     debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n     source.pop(); source.pop();\n-    source.push_many([\"src\", \"librustpkg\", \"testsuite\", \"pass\", \"src\", \"fancy-lib\", \"pkg.rs\"]);\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n     if !os::copy_file(&source,\n                       &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"])) {\n         fail!(\"Couldn't copy file\");\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&target_build_dir(dir).join_many([\"fancy-lib\", \"generated.rs\"])));\n+    assert!(os::path_exists(&target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"])));\n+    let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n+    debug!(\"generated path = {}\", generated_path.display());\n+    assert!(os::path_exists(&generated_path));\n }\n \n #[test]\n@@ -2251,6 +2248,106 @@ fn find_sources_in_cwd() {\n     assert_executable_exists(&source_dir.join(\".rust\"), \"foo\");\n }\n \n+#[test]\n+fn test_c_dependency_ok() {\n+    // Pkg has a custom build script that adds a single C file as a dependency, and\n+    // registers a hook to build it if it's not fresh\n+    // After running `build`, test that the C library built\n+\n+    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = dir.path();\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n+              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n+\n+    debug!(\"dir = {}\", dir.display());\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n+    if !os::copy_file(&source,\n+                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n+        fail!(\"Couldn't copy file\");\n+    }\n+    command_line_test([~\"build\", ~\"cdep\"], dir);\n+    assert_executable_exists(dir, \"cdep\");\n+    let out_dir = target_build_dir(dir).join(\"cdep\");\n+    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n+    debug!(\"c library path: {}\", c_library_path.display());\n+    assert!(os::path_exists(&c_library_path));\n+}\n+\n+#[test]\n+fn test_c_dependency_no_rebuilding() {\n+    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = dir.path();\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n+              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]), \"void f() {}\");\n+\n+    debug!(\"dir = {}\", dir.display());\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n+    if !os::copy_file(&source,\n+                      &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"])) {\n+        fail!(\"Couldn't copy file\");\n+    }\n+    command_line_test([~\"build\", ~\"cdep\"], dir);\n+    assert_executable_exists(dir, \"cdep\");\n+    let out_dir = target_build_dir(dir).join(\"cdep\");\n+    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n+    debug!(\"c library path: {}\", c_library_path.display());\n+    assert!(os::path_exists(&c_library_path));\n+\n+    // Now, make it read-only so rebuilding will fail\n+    assert!(chmod_read_only(&c_library_path));\n+\n+    match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n+        Success(*) => (), // ok\n+        Fail(status) if status == 65 => fail!(\"test_c_dependency_no_rebuilding failed: \\\n+                                              it tried to rebuild foo.c\"),\n+        Fail(_) => fail!(\"test_c_dependency_no_rebuilding failed for some other reason\")\n+    }\n+}\n+\n+#[test]\n+fn test_c_dependency_yes_rebuilding() {\n+    let dir = create_local_package(&PkgId::new(\"cdep\"));\n+    let dir = dir.path();\n+    writeFile(&dir.join_many([\"src\", \"cdep-0.1\", \"main.rs\"]),\n+              \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n+              \\n#[fixed_stack_segment]\\nfn main() { unsafe { f(); } }\");\n+    let c_file_name = dir.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n+    writeFile(&c_file_name, \"void f() {}\");\n+\n+    let source = Path::new(file!()).dir_path().join_many(\n+        [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n+    let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n+    debug!(\"Copying {} -> {}\", source.display(), target.display());\n+    if !os::copy_file(&source, &target) {\n+        fail!(\"Couldn't copy file\");\n+    }\n+    command_line_test([~\"build\", ~\"cdep\"], dir);\n+    assert_executable_exists(dir, \"cdep\");\n+    let out_dir = target_build_dir(dir).join(\"cdep\");\n+    let c_library_path = out_dir.join(platform_library_name(\"foo\"));\n+    debug!(\"c library path: {}\", c_library_path.display());\n+    assert!(os::path_exists(&c_library_path));\n+\n+    // Now, make the Rust library read-only so rebuilding will fail\n+    match built_library_in_workspace(&PkgId::new(\"cdep\"), dir) {\n+        Some(ref pth) => assert!(chmod_read_only(pth)),\n+        None => assert_built_library_exists(dir, \"cdep\")\n+    }\n+\n+    match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n+        Success(*) => fail!(\"test_c_dependency_yes_rebuilding failed: \\\n+                            it didn't rebuild and should have\"),\n+        Fail(status) if status == 65 => (),\n+        Fail(_) => fail!(\"test_c_dependency_yes_rebuilding failed for some other reason\")\n+    }\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/bar.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fbar.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn assert_true() {\n+    assert!(true);\n+}"}, {"sha": "542a6af402d055053afffe3c366fb145e51c4b83", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/foo.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Ffoo.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn do_nothing() {\n+}\n\\ No newline at end of file"}, {"sha": "bd1cb240a34cb88f3b2bb6a4df568aa797dece35", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/lib.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Flib.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod std;\n+\n+pub mod foo;\n+pub mod bar;"}, {"sha": "b667dc0a576fdf7e5f1ac2cf3968514e97c0adc7", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod rustpkg;\n+extern mod rustc;\n+\n+use std::{io, os, task};\n+use rustpkg::api;\n+use rustpkg::version::NoVersion;\n+use rustpkg::workcache_support::digest_file_with_date;\n+use rustpkg::exit_codes::COPY_FAILED_CODE;\n+\n+pub fn main() {\n+    let args = os::args();\n+\n+// by convention, first arg is sysroot\n+    if args.len() < 2 {\n+        fail!(\"Package script requires a directory where rustc libraries live as the first \\\n+               argument\");\n+    }\n+\n+    let path_for_db = api::default_workspace();\n+    debug!(\"path_for_db = {}\", path_for_db.display());\n+\n+    let sysroot_arg = args[1].clone();\n+    let sysroot = Path::new(sysroot_arg);\n+    if !os::path_exists(&sysroot) {\n+        fail!(\"Package script requires a sysroot that exists; {} doesn't\", sysroot.display());\n+    }\n+\n+    if args[2] != ~\"install\" {\n+        io::println(format!(\"Warning: I don't know how to {}\", args[2]));\n+        return;\n+    }\n+\n+    let mut context = api::default_context(sysroot, path_for_db);\n+    let my_workspace = api::my_workspace(&context.context, \"cdep\");\n+    let foo_c_name = my_workspace.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n+\n+    let out_lib_path = do context.workcache_context.with_prep(\"foo.c\") |prep| {\n+        let sub_cx = context.context.clone();\n+        debug!(\"foo_c_name = {}\", foo_c_name.display());\n+        prep.declare_input(\"file\",\n+                           foo_c_name.as_str().unwrap().to_owned(),\n+                           digest_file_with_date(&foo_c_name));\n+        let out_path = do prep.exec |exec| {\n+            let out_path = api::build_library_in_workspace(exec,\n+                                                           &mut sub_cx.clone(),\n+                                                           \"cdep\",\n+                                                           \"gcc\",\n+                                                           [~\"-c\"],\n+                                                           [~\"foo.c\"],\n+                                                           \"foo\");\n+            let out_p = Path::new(out_path);\n+            out_p.as_str().unwrap().to_owned()\n+        };\n+        out_path\n+    };\n+    let out_lib_path = Path::new(out_lib_path);\n+    debug!(\"out_lib_path = {}\", out_lib_path.display());\n+    context.add_library_path(out_lib_path.dir_path());\n+\n+    let context_clone = context.clone();\n+    let task_res = do task::try {\n+        let mut cc = context_clone.clone();\n+        api::install_pkg(&mut cc,\n+                         os::getcwd(),\n+                         ~\"cdep\",\n+                         NoVersion,\n+                         ~[(~\"binary\", out_lib_path.clone()), (~\"file\", foo_c_name.clone())]);\n+    };\n+\n+    if task_res.is_err() {\n+        os::set_exit_status(COPY_FAILED_CODE);\n+    }\n+}"}, {"sha": "17386cd03c22b605a6edd3c6f758005bbcb67d00", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Flib.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -21,4 +21,4 @@ extern mod std;\n \n pub mod foo;\n pub mod bar;\n-#[path = \"../../build/fancy_lib/generated.rs\"] pub mod generated;\n+#[path = \"../../build/fancy-lib/generated.rs\"] pub mod generated;"}, {"sha": "0b838b3e0f9e34547e207d6313113fb6d14e0a98", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -15,42 +15,37 @@ use std::{io, os};\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n \n-use rustc::metadata::filesearch;\n-\n pub fn main() {\n-    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n     let args = os::args();\n \n // by convention, first arg is sysroot\n     if args.len() < 2 {\n+        debug!(\"Failing, arg len\");\n         fail!(\"Package script requires a directory where rustc libraries live as the first \\\n                argument\");\n     }\n \n     let sysroot_arg = args[1].clone();\n-    let sysroot = Path(sysroot_arg);\n+    let sysroot = Path::new(sysroot_arg);\n     if !os::path_exists(&sysroot) {\n-        fail!(\"Package script requires a sysroot that exists; %s doesn't\", sysroot.to_str());\n+        debug!(\"Failing, sysroot\");\n+        fail!(\"Package script requires a sysroot that exists;{} doesn't\", sysroot.display());\n     }\n \n     if args[2] != ~\"install\" {\n+        debug!(\"Failing, weird command\");\n         println!(\"Warning: I don't know how to {}\", args[2]);\n         return;\n     }\n \n-    let out_path = Path(\"build/fancy-lib\");\n-    if !os::path_exists(&out_path) {\n-        assert!(os::make_dir(&out_path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    }\n-\n-    let file = io::file_writer(&out_path.push(\"generated.rs\"),\n-                               [io::Create]).unwrap();\n-    file.write_str(\"pub fn wheeeee() { for [1, 2, 3].each() |_| { assert!(true); } }\");\n-\n+    debug!(\"Checking self_exe_path\");\n+    let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n \n-    debug!(\"api_____install_____lib, my sysroot:\");\n-    debug!(sysroot.to_str());\n+    debug!(\"Writing file\");\n+    let file = io::file_writer(&out_path.join(\"generated.rs\"), [io::Create]).unwrap();\n+    file.write_str(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n+                   for _ in xs.iter() { assert!(true); } }\");\n \n-    api::install_lib(@sysroot, os::getcwd(), ~\"fancy-lib\", Path(\"lib.rs\"),\n-                     NoVersion);\n+    let context = api::default_context(sysroot, api::default_workspace());\n+    api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", NoVersion, ~[]);\n }"}, {"sha": "3824f6d38def9dfd6f4ad0aaeb4fdbc29efcd5cb", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -27,11 +27,13 @@ use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n-use path_util::{U_RWX, system_library, target_build_dir};\n+use path_util::{system_library, target_build_dir};\n use path_util::{default_workspace, built_library_in_workspace};\n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n pub use target::{Target, Build, Install};\n use extra::treemap::TreeMap;\n+use path_util::U_RWX;\n+pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n use workcache_support::{digest_file_with_date, digest_only_date};\n \n // It would be nice to have the list of commands in just one place -- for example,\n@@ -233,19 +235,23 @@ pub fn compile_input(context: &BuildContext,\n         Nothing => link::output_type_exe\n     };\n \n+    debug!(\"Output type = {:?}\", output_type);\n+\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n         maybe_sysroot: Some(sysroot_to_use),\n-        addl_lib_search_paths: @mut (~[]),\n+        addl_lib_search_paths: @mut context.additional_library_paths(),\n         output_type: output_type,\n         .. (*driver::build_session_options(binary,\n                                            &matches,\n                                            @diagnostic::DefaultEmitter as\n                                             @diagnostic::Emitter)).clone()\n     };\n \n+    debug!(\"Created options...\");\n+\n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n@@ -258,16 +264,22 @@ pub fn compile_input(context: &BuildContext,\n         }\n     }\n \n+    debug!(\"About to build session...\");\n+\n     let sess = driver::build_session(options,\n                                      @diagnostic::DefaultEmitter as\n                                         @diagnostic::Emitter);\n \n+    debug!(\"About to build config...\");\n+\n     // Infer dependencies that rustpkg needs to build, by scanning for\n     // `extern mod` directives.\n     let cfg = driver::build_configuration(sess);\n     let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n \n+    debug!(\"About to call find_and_install_dependencies...\");\n+\n     find_and_install_dependencies(context, pkg_id, in_file, sess, exec, &crate, deps,\n                                   |p| {\n                                       debug!(\"a dependency: {}\", p.display());\n@@ -377,7 +389,6 @@ pub fn compile_crate_from_input(input: &Path,\n \n     debug!(\"Built {}, date = {:?}\", outputs.out_filename.display(),\n            datestamp(&outputs.out_filename));\n-\n     Some(outputs.out_filename)\n }\n \n@@ -431,7 +442,9 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                 };\n                 debug!(\"Finding and installing... {}\", lib_name);\n                 // Check standard Rust library path first\n-                match system_library(&self.context.sysroot(), lib_name) {\n+                let whatever = system_library(&self.context.sysroot(), lib_name);\n+                debug!(\"system library returned {:?}\", whatever);\n+                match whatever {\n                     Some(ref installed_path) => {\n                         debug!(\"It exists: {}\", installed_path.display());\n                         // Say that [path for c] has a discovered dependency on\n@@ -478,7 +491,10 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                                   self.context.context.use_rust_path_hack,\n                                                   pkg_id.clone());\n                         let (outputs_disc, inputs_disc) =\n-                            self.context.install(pkg_src, &JustOne(Path::new(lib_crate_filename)));\n+                            self.context.install(\n+                                pkg_src,\n+                                &WhatToBuild::new(Inferred,\n+                                                  JustOne(Path::new(lib_crate_filename))));\n                         debug!(\"Installed {}, returned {:?} dependencies and \\\n                                {:?} transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());"}, {"sha": "9d5c9c1a5cd66fe9df469b2a16123e81b87ffdc7", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -490,7 +490,6 @@ pub struct Formatter<'self> {\n \n     /// Output buffer.\n     buf: &'self mut io::Writer,\n-\n     priv curarg: vec::VecIterator<'self, Argument<'self>>,\n     priv args: &'self [Argument<'self>],\n }"}, {"sha": "4e55c5fe60eb50c8741a59698039eeb7b85d959d", "filename": "src/libstd/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -1009,7 +1009,7 @@ impl<R:Reader,C> Reader for Wrapper<R, C> {\n }\n \n pub struct FILERes {\n-    f: *libc::FILE,\n+    priv f: *libc::FILE,\n }\n \n impl FILERes {\n@@ -1282,7 +1282,7 @@ impl Writer for fd_t {\n }\n \n pub struct FdRes {\n-    fd: fd_t,\n+    priv fd: fd_t,\n }\n \n impl FdRes {\n@@ -1792,7 +1792,7 @@ pub mod fsync {\n \n     // Artifacts that need to fsync on destruction\n     pub struct Res<t> {\n-        arg: Arg<t>,\n+        priv arg: Arg<t>,\n     }\n \n     impl <t> Res<t> {\n@@ -1815,9 +1815,9 @@ pub mod fsync {\n     }\n \n     pub struct Arg<t> {\n-        val: t,\n-        opt_level: Option<Level>,\n-        fsync_fn: extern \"Rust\" fn(f: &t, Level) -> int,\n+        priv val: t,\n+        priv opt_level: Option<Level>,\n+        priv fsync_fn: extern \"Rust\" fn(f: &t, Level) -> int,\n     }\n \n     // fsync file after executing blk"}, {"sha": "771be3b2a134fc375856af6a50aa0a93bcc827ac", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -1790,9 +1790,9 @@ impl<'self, A, St> Iterator<A> for Unfold<'self, A, St> {\n #[deriving(Clone)]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n-    state: A,\n+    priv state: A,\n     /// The amount that this iterator is stepping by\n-    step: A\n+    priv step: A\n }\n \n /// Creates a new counter with the specified start/step"}, {"sha": "e7bcf8ce5d3a71d0c0d14e41b6199cc0a1093c3a", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 481, "deletions": 41, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -8,38 +8,226 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Sampling from random distributions\n+/*!\n+Sampling from random distributions.\n \n-// Some implementations use the Ziggurat method\n-// https://en.wikipedia.org/wiki/Ziggurat_algorithm\n-//\n-// The version used here is ZIGNOR [Doornik 2005, \"An Improved\n-// Ziggurat Method to Generate Normal Random Samples\"] which is slower\n-// (about double, it generates an extra random number) than the\n-// canonical version [Marsaglia & Tsang 2000, \"The Ziggurat Method for\n-// Generating Random Variables\"], but more robust. If one wanted, one\n-// could implement VIZIGNOR the ZIGNOR paper for more speed.\n+This is a generalization of `Rand` to allow parameters to control the\n+exact properties of the generated values, e.g. the mean and standard\n+deviation of a normal distribution. The `Sample` trait is the most\n+general, and allows for generating values that change some state\n+internally. The `IndependentSample` trait is for generating values\n+that do not need to record state.\n+\n+*/\n \n+use iter::range;\n+use option::{Some, None};\n use num;\n use rand::{Rng,Rand};\n+use clone::Clone;\n+\n+pub use self::range::Range;\n+\n+pub mod range;\n+\n+/// Types that can be used to create a random instance of `Support`.\n+pub trait Sample<Support> {\n+    /// Generate a random value of `Support`, using `rng` as the\n+    /// source of randomness.\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Support;\n+}\n+\n+/// `Sample`s that do not require keeping track of state.\n+///\n+/// Since no state is recored, each sample is (statistically)\n+/// independent of all others, assuming the `Rng` used has this\n+/// property.\n+// XXX maybe having this separate is overkill (the only reason is to\n+// take &self rather than &mut self)? or maybe this should be the\n+// trait called `Sample` and the other should be `DependentSample`.\n+pub trait IndependentSample<Support>: Sample<Support> {\n+    /// Generate a random value.\n+    fn ind_sample<R: Rng>(&self, &mut R) -> Support;\n+}\n+\n+/// A wrapper for generating types that implement `Rand` via the\n+/// `Sample` & `IndependentSample` traits.\n+pub struct RandSample<Sup>;\n+\n+impl<Sup: Rand> Sample<Sup> for RandSample<Sup> {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n+}\n+\n+impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n+        rng.gen()\n+    }\n+}\n+\n+/// A value with a particular weight for use with `WeightedChoice`.\n+pub struct Weighted<T> {\n+    /// The numerical weight of this item\n+    weight: uint,\n+    /// The actual item which is being weighted\n+    item: T,\n+}\n+\n+/// A distribution that selects from a finite collection of weighted items.\n+///\n+/// Each item has an associated weight that influences how likely it\n+/// is to be chosen: higher weight is more likely.\n+///\n+/// The `Clone` restriction is a limitation of the `Sample` and\n+/// `IndepedentSample` traits. Note that `&T` is (cheaply) `Clone` for\n+/// all `T`, as is `uint`, so one can store references or indices into\n+/// another vector.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{Weighted, WeightedChoice, IndepedentSample};\n+///\n+/// fn main() {\n+///     let wc = WeightedChoice::new(~[Weighted { weight: 2, item: 'a' },\n+///                                    Weighted { weight: 4, item: 'b' },\n+///                                    Weighted { weight: 1, item: 'c' }]);\n+///     let rng = rand::task_rng();\n+///     for _ in range(0, 16) {\n+///          // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n+///          println!(\"{}\", wc.ind_sample(rng));\n+///     }\n+/// }\n+/// ```\n+pub struct WeightedChoice<T> {\n+    priv items: ~[Weighted<T>],\n+    priv weight_range: Range<uint>\n+}\n+\n+impl<T: Clone> WeightedChoice<T> {\n+    /// Create a new `WeightedChoice`.\n+    ///\n+    /// Fails if:\n+    /// - `v` is empty\n+    /// - the total weight is 0\n+    /// - the total weight is larger than a `uint` can contain.\n+    pub fn new(mut items: ~[Weighted<T>]) -> WeightedChoice<T> {\n+        // strictly speaking, this is subsumed by the total weight == 0 case\n+        assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n+\n+        let mut running_total = 0u;\n+\n+        // we convert the list from individual weights to cumulative\n+        // weights so we can binary search. This *could* drop elements\n+        // with weight == 0 as an optimisation.\n+        for item in items.mut_iter() {\n+            running_total = running_total.checked_add(&item.weight)\n+                .expect(\"WeightedChoice::new called with a total weight larger \\\n+                        than a uint can contain\");\n+\n+            item.weight = running_total;\n+        }\n+        assert!(running_total != 0, \"WeightedChoice::new called with a total weight of 0\");\n+\n+        WeightedChoice {\n+            items: items,\n+            // we're likely to be generating numbers in this range\n+            // relatively often, so might as well cache it\n+            weight_range: Range::new(0, running_total)\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Sample<T> for WeightedChoice<T> {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> T { self.ind_sample(rng) }\n+}\n+\n+impl<T: Clone> IndependentSample<T> for WeightedChoice<T> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> T {\n+        // we want to find the first element that has cumulative\n+        // weight > sample_weight, which we do by binary since the\n+        // cumulative weights of self.items are sorted.\n+\n+        // choose a weight in [0, total_weight)\n+        let sample_weight = self.weight_range.ind_sample(rng);\n+\n+        // short circuit when it's the first item\n+        if sample_weight < self.items[0].weight {\n+            return self.items[0].item.clone();\n+        }\n+\n+        let mut idx = 0;\n+        let mut modifier = self.items.len();\n+\n+        // now we know that every possibility has an element to the\n+        // left, so we can just search for the last element that has\n+        // cumulative weight <= sample_weight, then the next one will\n+        // be \"it\". (Note that this greatest element will never be the\n+        // last element of the vector, since sample_weight is chosen\n+        // in [0, total_weight) and the cumulative weight of the last\n+        // one is exactly the total weight.)\n+        while modifier > 1 {\n+            let i = idx + modifier / 2;\n+            if self.items[i].weight <= sample_weight {\n+                // we're small, so look to the right, but allow this\n+                // exact element still.\n+                idx = i;\n+                // we need the `/ 2` to round up otherwise we'll drop\n+                // the trailing elements when `modifier` is odd.\n+                modifier += 1;\n+            } else {\n+                // otherwise we're too big, so go left. (i.e. do\n+                // nothing)\n+            }\n+            modifier /= 2;\n+        }\n+        return self.items[idx + 1].item.clone();\n+    }\n+}\n \n mod ziggurat_tables;\n \n-// inlining should mean there is no performance penalty for this\n-#[inline]\n+/// Sample a random number using the Ziggurat method (specifically the\n+/// ZIGNOR variant from Doornik 2005). Most of the arguments are\n+/// directly from the paper:\n+///\n+/// * `rng`: source of randomness\n+/// * `symmetric`: whether this is a symmetric distribution, or one-sided with P(x < 0) = 0.\n+/// * `X`: the $x_i$ abscissae.\n+/// * `F`: precomputed values of the PDF at the $x_i$, (i.e. $f(x_i)$)\n+/// * `F_DIFF`: precomputed values of $f(x_i) - f(x_{i+1})$\n+/// * `pdf`: the probability density function\n+/// * `zero_case`: manual sampling from the tail when we chose the\n+///    bottom box (i.e. i == 0)\n+\n+// the perf improvement (25-50%) is definitely worth the extra code\n+// size from force-inlining.\n+#[inline(always)]\n fn ziggurat<R:Rng>(rng: &mut R,\n-                   center_u: bool,\n+                   symmetric: bool,\n                    X: ziggurat_tables::ZigTable,\n                    F: ziggurat_tables::ZigTable,\n                    F_DIFF: ziggurat_tables::ZigTable,\n-                   pdf: &'static fn(f64) -> f64, // probability density function\n+                   pdf: &'static fn(f64) -> f64,\n                    zero_case: &'static fn(&mut R, f64) -> f64) -> f64 {\n+    static SCALE: f64 = (1u64 << 53) as f64;\n     loop {\n-        let u = if center_u {2.0 * rng.gen() - 1.0} else {rng.gen()};\n-        let i: uint = rng.gen::<uint>() & 0xff;\n+        // reimplement the f64 generation as an optimisation suggested\n+        // by the Doornik paper: we have a lot of precision-space\n+        // (i.e. there are 11 bits of the 64 of a u64 to use after\n+        // creating a f64), so we might as well reuse some to save\n+        // generating a whole extra random number. (Seems to be 15%\n+        // faster.)\n+        let bits: u64 = rng.gen();\n+        let i = (bits & 0xff) as uint;\n+        let f = (bits >> 11) as f64 / SCALE;\n+\n+        // u is either U(-1, 1) or U(0, 1) depending on if this is a\n+        // symmetric distribution or not.\n+        let u = if symmetric {2.0 * f - 1.0} else {f};\n         let x = u * X[i];\n \n-        let test_x = if center_u {num::abs(x)} else {x};\n+        let test_x = if symmetric {num::abs(x)} else {x};\n \n         // algebraically equivalent to |u| < X[i+1]/X[i] (or u < X[i+1]/X[i])\n         if test_x < X[i + 1] {\n@@ -49,30 +237,25 @@ fn ziggurat<R:Rng>(rng: &mut R,\n             return zero_case(rng, u);\n         }\n         // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1\n-        if F[i+1] + F_DIFF[i+1] * rng.gen() < pdf(x) {\n+        if F[i + 1] + F_DIFF[i + 1] * rng.gen() < pdf(x) {\n             return x;\n         }\n     }\n }\n \n-/// A wrapper around an `f64` to generate N(0, 1) random numbers (a.k.a.  a\n-/// standard normal, or Gaussian). Multiplying the generated values by the\n-/// desired standard deviation `sigma` then adding the desired mean `mu` will\n-/// give N(mu, sigma^2) distributed random numbers.\n+/// A wrapper around an `f64` to generate N(0, 1) random numbers\n+/// (a.k.a.  a standard normal, or Gaussian).\n ///\n-/// Note that this has to be unwrapped before use as an `f64` (using either\n-/// `*` or `cast::transmute` is safe).\n+/// See `Normal` for the general normal distribution. That this has to\n+/// be unwrapped before use as an `f64` (using either `*` or\n+/// `cast::transmute` is safe).\n ///\n-/// # Example\n+/// Implemented via the ZIGNOR variant[1] of the Ziggurat method.\n ///\n-/// ```\n-/// use std::rand::distributions::StandardNormal;\n-///\n-/// fn main() {\n-///     let normal = 2.0 + (*rand::random::<StandardNormal>()) * 3.0;\n-///     println!(\"{} is from a N(2, 9) distribution\", normal)\n-/// }\n-/// ```\n+/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n+/// Generate Normal Random\n+/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n+/// College, Oxford\n pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n@@ -110,23 +293,62 @@ impl Rand for StandardNormal {\n     }\n }\n \n-/// A wrapper around an `f64` to generate Exp(1) random numbers. Dividing by\n-/// the desired rate `lambda` will give Exp(lambda) distributed random\n-/// numbers.\n+/// The normal distribution `N(mean, std_dev**2)`.\n ///\n-/// Note that this has to be unwrapped before use as an `f64` (using either\n-/// `*` or `cast::transmute` is safe).\n+/// This uses the ZIGNOR variant of the Ziggurat method, see\n+/// `StandardNormal` for more details.\n ///\n /// # Example\n ///\n /// ```\n-/// use std::rand::distributions::Exp1;\n+/// use std::rand;\n+/// use std::rand::distributions::{Normal, IndependentSample};\n ///\n /// fn main() {\n-///     let exp2 = (*rand::random::<Exp1>()) * 0.5;\n-///     println!(\"{} is from a Exp(2) distribution\", exp2);\n+///     let normal = Normal::new(2.0, 3.0);\n+///     let v = normal.ind_sample(rand::task_rng());\n+///     println!(\"{} is from a N(2, 9) distribution\", v)\n /// }\n /// ```\n+pub struct Normal {\n+    priv mean: f64,\n+    priv std_dev: f64\n+}\n+\n+impl Normal {\n+    /// Construct a new `Normal` distribution with the given mean and\n+    /// standard deviation. Fails if `std_dev < 0`.\n+    pub fn new(mean: f64, std_dev: f64) -> Normal {\n+        assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n+        Normal {\n+            mean: mean,\n+            std_dev: std_dev\n+        }\n+    }\n+}\n+impl Sample<f64> for Normal {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Normal {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        self.mean + self.std_dev * (*rng.gen::<StandardNormal>())\n+    }\n+}\n+\n+/// A wrapper around an `f64` to generate Exp(1) random numbers.\n+///\n+/// See `Exp` for the general exponential distribution.Note that this\n+ // has to be unwrapped before use as an `f64` (using either\n+/// `*` or `cast::transmute` is safe).\n+///\n+/// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n+/// exact description in the paper was adjusted to use tables for the\n+/// exponential distribution rather than normal.\n+///\n+/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n+/// Generate Normal Random\n+/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n+/// College, Oxford\n pub struct Exp1(f64);\n \n // This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n@@ -148,3 +370,221 @@ impl Rand for Exp1 {\n                       pdf, zero_case))\n     }\n }\n+\n+/// The exponential distribution `Exp(lambda)`.\n+///\n+/// This distribution has density function: `f(x) = lambda *\n+/// exp(-lambda * x)` for `x > 0`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::rand;\n+/// use std::rand::distributions::{Exp, IndependentSample};\n+///\n+/// fn main() {\n+///     let exp = Exp::new(2.0);\n+///     let v = exp.ind_sample(rand::task_rng());\n+///     println!(\"{} is from a Exp(2) distribution\", v);\n+/// }\n+/// ```\n+pub struct Exp {\n+    /// `lambda` stored as `1/lambda`, since this is what we scale by.\n+    priv lambda_inverse: f64\n+}\n+\n+impl Exp {\n+    /// Construct a new `Exp` with the given shape parameter\n+    /// `lambda`. Fails if `lambda <= 0`.\n+    pub fn new(lambda: f64) -> Exp {\n+        assert!(lambda > 0.0, \"Exp::new called with `lambda` <= 0\");\n+        Exp { lambda_inverse: 1.0 / lambda }\n+    }\n+}\n+\n+impl Sample<f64> for Exp {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Exp {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        (*rng.gen::<Exp1>()) * self.lambda_inverse\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rand::*;\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+\n+    struct ConstRand(uint);\n+    impl Rand for ConstRand {\n+        fn rand<R: Rng>(_: &mut R) -> ConstRand {\n+            ConstRand(0)\n+        }\n+    }\n+\n+    // 0, 1, 2, 3, ...\n+    struct CountingRng { i: u32 }\n+    impl Rng for CountingRng {\n+        fn next_u32(&mut self) -> u32 {\n+            self.i += 1;\n+            self.i - 1\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            self.next_u32() as u64\n+        }\n+    }\n+\n+    #[test]\n+    fn test_rand_sample() {\n+        let mut rand_sample = RandSample::<ConstRand>;\n+\n+        assert_eq!(*rand_sample.sample(task_rng()), 0);\n+        assert_eq!(*rand_sample.ind_sample(task_rng()), 0);\n+    }\n+\n+    #[test]\n+    fn test_normal() {\n+        let mut norm = Normal::new(10.0, 10.0);\n+        let rng = task_rng();\n+        for _ in range(0, 1000) {\n+            norm.sample(rng);\n+            norm.ind_sample(rng);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_normal_invalid_sd() {\n+        Normal::new(10.0, -1.0);\n+    }\n+\n+    #[test]\n+    fn test_exp() {\n+        let mut exp = Exp::new(10.0);\n+        let rng = task_rng();\n+        for _ in range(0, 1000) {\n+            assert!(exp.sample(rng) >= 0.0);\n+            assert!(exp.ind_sample(rng) >= 0.0);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_zero() {\n+        Exp::new(0.0);\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_neg() {\n+        Exp::new(-10.0);\n+    }\n+\n+    #[test]\n+    fn test_weighted_choice() {\n+        // this makes assumptions about the internal implementation of\n+        // WeightedChoice, specifically: it doesn't reorder the items,\n+        // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n+        // 1, internally; modulo a modulo operation).\n+\n+        macro_rules! t (\n+            ($items:expr, $expected:expr) => {{\n+                let wc = WeightedChoice::new($items);\n+                let expected = $expected;\n+\n+                let mut rng = CountingRng { i: 0 };\n+\n+                for &val in expected.iter() {\n+                    assert_eq!(wc.ind_sample(&mut rng), val)\n+                }\n+            }}\n+        );\n+\n+        t!(~[Weighted { weight: 1, item: 10}], ~[10]);\n+\n+        // skip some\n+        t!(~[Weighted { weight: 0, item: 20},\n+             Weighted { weight: 2, item: 21},\n+             Weighted { weight: 0, item: 22},\n+             Weighted { weight: 1, item: 23}],\n+           ~[21,21, 23]);\n+\n+        // different weights\n+        t!(~[Weighted { weight: 4, item: 30},\n+             Weighted { weight: 3, item: 31}],\n+           ~[30,30,30,30, 31,31,31]);\n+\n+        // check that we're binary searching\n+        // correctly with some vectors of odd\n+        // length.\n+        t!(~[Weighted { weight: 1, item: 40},\n+             Weighted { weight: 1, item: 41},\n+             Weighted { weight: 1, item: 42},\n+             Weighted { weight: 1, item: 43},\n+             Weighted { weight: 1, item: 44}],\n+           ~[40, 41, 42, 43, 44]);\n+        t!(~[Weighted { weight: 1, item: 50},\n+             Weighted { weight: 1, item: 51},\n+             Weighted { weight: 1, item: 52},\n+             Weighted { weight: 1, item: 53},\n+             Weighted { weight: 1, item: 54},\n+             Weighted { weight: 1, item: 55},\n+             Weighted { weight: 1, item: 56}],\n+           ~[50, 51, 52, 53, 54, 55, 56]);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_no_items() {\n+        WeightedChoice::<int>::new(~[]);\n+    }\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_zero_weight() {\n+        WeightedChoice::new(~[Weighted { weight: 0, item: 0},\n+                              Weighted { weight: 0, item: 1}]);\n+    }\n+    #[test] #[should_fail]\n+    fn test_weighted_choice_weight_overflows() {\n+        let x = (-1) as uint / 2; // x + x + 2 is the overflow\n+        WeightedChoice::new(~[Weighted { weight: x, item: 0 },\n+                              Weighted { weight: 1, item: 1 },\n+                              Weighted { weight: x, item: 2 },\n+                              Weighted { weight: 1, item: 3 }]);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use rand::*;\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+    use mem::size_of;\n+\n+    static N: u64 = 100;\n+\n+    #[bench]\n+    fn rand_normal(bh: &mut BenchHarness) {\n+        let mut rng = XorShiftRng::new();\n+        let mut normal = Normal::new(-2.71828, 3.14159);\n+\n+        do bh.iter {\n+            for _ in range(0, N) {\n+                normal.sample(&mut rng);\n+            }\n+        }\n+        bh.bytes = size_of::<f64>() as u64 * N;\n+    }\n+    #[bench]\n+    fn rand_exp(bh: &mut BenchHarness) {\n+        let mut rng = XorShiftRng::new();\n+        let mut exp = Exp::new(2.71828 * 3.14159);\n+\n+        do bh.iter {\n+            for _ in range(0, N) {\n+                exp.sample(&mut rng);\n+            }\n+        }\n+        bh.bytes = size_of::<f64>() as u64 * N;\n+    }\n+}"}, {"sha": "42254b211a17c1318749ff772a08cca3b25c8323", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 51, "deletions": 32, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -10,18 +10,24 @@\n \n //! The ISAAC random number generator.\n \n-use cast;\n use rand::{Rng, SeedableRng, OSRng};\n use iter::{Iterator, range, range_step, Repeat};\n use option::{None, Some};\n+use vec::raw;\n+use mem;\n \n static RAND_SIZE_LEN: u32 = 8;\n static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n \n-/// A random number generator that uses the [ISAAC\n-/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+/// A random number generator that uses the ISAAC algorithm[1].\n ///\n-/// The ISAAC algorithm is suitable for cryptographic purposes.\n+/// The ISAAC algorithm is generally accepted as suitable for\n+/// cryptographic purposes, but this implementation has not be\n+/// verified as such. Prefer a generator like `OSRng` that defers to\n+/// the operating system for cases that need high security.\n+///\n+/// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number\n+/// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n pub struct IsaacRng {\n     priv cnt: u32,\n     priv rsl: [u32, .. RAND_SIZE],\n@@ -42,9 +48,12 @@ impl IsaacRng {\n     pub fn new() -> IsaacRng {\n         let mut rng = EMPTY;\n \n-        {\n-            let bytes = unsafe {cast::transmute::<&mut [u32], &mut [u8]>(rng.rsl)};\n-            OSRng::new().fill_bytes(bytes);\n+        unsafe {\n+            let ptr = raw::to_mut_ptr(rng.rsl);\n+\n+            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+                OSRng::new().fill_bytes(slice);\n+            }\n         }\n \n         rng.init(true);\n@@ -212,11 +221,16 @@ impl<'self> SeedableRng<&'self [u32]> for IsaacRng {\n static RAND_SIZE_64_LEN: uint = 8;\n static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n \n-/// A random number generator that uses the 64-bit variant of the\n-/// [ISAAC\n-/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+/// A random number generator that uses ISAAC-64[1], the 64-bit\n+/// variant of the ISAAC algorithm.\n+///\n+/// The ISAAC algorithm is generally accepted as suitable for\n+/// cryptographic purposes, but this implementation has not be\n+/// verified as such. Prefer a generator like `OSRng` that defers to\n+/// the operating system for cases that need high security.\n ///\n-/// The ISAAC algorithm is suitable for cryptographic purposes.\n+/// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number\n+/// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n pub struct Isaac64Rng {\n     priv cnt: uint,\n     priv rsl: [u64, .. RAND_SIZE_64],\n@@ -238,10 +252,15 @@ impl Isaac64Rng {\n     /// seed.\n     pub fn new() -> Isaac64Rng {\n         let mut rng = EMPTY_64;\n-        {\n-            let bytes = unsafe {cast::transmute::<&mut [u64], &mut [u8]>(rng.rsl)};\n-            OSRng::new().fill_bytes(bytes);\n+\n+        unsafe {\n+            let ptr = raw::to_mut_ptr(rng.rsl);\n+\n+            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+                OSRng::new().fill_bytes(slice);\n+            }\n         }\n+\n         rng.init(true);\n         rng\n     }\n@@ -434,14 +453,14 @@ mod test {\n \n     #[test]\n     fn test_rng_32_seeded() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n     #[test]\n     fn test_rng_64_seeded() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n@@ -472,46 +491,46 @@ mod test {\n \n     #[test]\n     fn test_rng_32_true_values() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = vec::from_fn(10, |_| ra.next_u32());\n         assert_eq!(v,\n-                   ~[447462228, 2081944040, 3163797308, 2379916134, 2377489184,\n-                     1132373754, 536342443, 2995223415, 1265094839, 345325140]);\n+                   ~[2558573138, 873787463, 263499565, 2103644246, 3595684709,\n+                     4203127393, 264982119, 2765226902, 2737944514, 3900253796]);\n \n-        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u32(); }\n \n         let v = vec::from_fn(10, |_| rb.next_u32());\n         assert_eq!(v,\n-                   ~[612373032, 292987903, 1819311337, 3141271980, 422447569,\n-                     310096395, 1083172510, 867909094, 2478664230, 2073577855]);\n+                   ~[3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n+                     1576568959, 3507990155, 179069555, 141456972, 2478885421]);\n     }\n     #[test]\n     fn test_rng_64_true_values() {\n-        let seed = &[2, 32, 4, 32, 51];\n+        let seed = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n         let v = vec::from_fn(10, |_| ra.next_u64());\n         assert_eq!(v,\n-                   ~[15015576812873463115, 12461067598045625862, 14818626436142668771,\n-                     5562406406765984441, 11813289907965514161, 13443797187798420053,\n-                     6935026941854944442, 7750800609318664042, 14428747036317928637,\n-                     14028894460301215947]);\n+                   ~[547121783600835980, 14377643087320773276, 17351601304698403469,\n+                     1238879483818134882, 11952566807690396487, 13970131091560099343,\n+                     4469761996653280935, 15552757044682284409, 6860251611068737823,\n+                     13722198873481261842]);\n \n-        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let seed = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n         for _ in range(0, 10000) { rb.next_u64(); }\n \n         let v = vec::from_fn(10, |_| rb.next_u64());\n         assert_eq!(v,\n-                   ~[13557216323596688637, 17060829581390442094, 4927582063811333743,\n-                     2699639759356482270, 4819341314392384881, 6047100822963614452,\n-                     11086255989965979163, 11901890363215659856, 5370800226050011580,\n-                     16496463556025356451]);\n+                   ~[18143823860592706164, 8491801882678285927, 2699425367717515619,\n+                     17196852593171130876, 2606123525235546165, 15790932315217671084,\n+                     596345674630742204, 9947027391921273664, 11788097613744130851,\n+                     10391409374914919106]);\n     }\n }"}, {"sha": "a6efdfc66db2e2f66bc5aed36f2f914abc779b44", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 122, "deletions": 225, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -28,6 +28,23 @@ from an operating-system source of randomness, e.g. `/dev/urandom` on\n Unix systems, and will automatically reseed itself from this source\n after generating 32 KiB of random data.\n \n+# Cryptographic security\n+\n+An application that requires random numbers for cryptographic purposes\n+should prefer `OSRng`, which reads randomness from one of the source\n+that the operating system provides (e.g. `/dev/urandom` on\n+Unixes). The other random number generators provided by this module\n+are either known to be insecure (`XorShiftRng`), or are not verified\n+to be secure (`IsaacRng`, `Isaac64Rng` and `StdRng`).\n+\n+*Note*: on Linux, `/dev/random` is more secure than `/dev/urandom`,\n+but it is a blocking RNG, and will wait until it has determined that\n+it has collected enough entropy to fulfill a request for random\n+data. It can be used with the `Rng` trait provided by this module by\n+opening the file and passing it to `reader::ReaderRng`. Since it\n+blocks, `/dev/random` should only be used to retrieve small amounts of\n+randomness.\n+\n # Examples\n \n ```rust\n@@ -52,20 +69,21 @@ fn main () {\n  ```\n */\n \n-use mem::size_of;\n-use unstable::raw::Slice;\n use cast;\n+use cmp::Ord;\n use container::Container;\n use iter::{Iterator, range};\n use local_data;\n use prelude::*;\n use str;\n-use u64;\n use vec;\n \n pub use self::isaac::{IsaacRng, Isaac64Rng};\n pub use self::os::OSRng;\n \n+use self::distributions::{Range, IndependentSample};\n+use self::distributions::range::SampleRange;\n+\n pub mod distributions;\n pub mod isaac;\n pub mod os;\n@@ -80,14 +98,6 @@ pub trait Rand {\n     fn rand<R: Rng>(rng: &mut R) -> Self;\n }\n \n-/// A value with a particular weight compared to other values\n-pub struct Weighted<T> {\n-    /// The numerical weight of this item\n-    weight: uint,\n-    /// The actual item which is being weighted\n-    item: T,\n-}\n-\n /// A random number generator\n pub trait Rng {\n     /// Return the next random u32. This rarely needs to be called\n@@ -136,46 +146,26 @@ pub trait Rng {\n     /// }\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n-        let mut slice: Slice<u64> = unsafe { cast::transmute_copy(&dest) };\n-        slice.len /= size_of::<u64>();\n-        let as_u64: &mut [u64] = unsafe { cast::transmute(slice) };\n-        for dest in as_u64.mut_iter() {\n-            *dest = self.next_u64();\n-        }\n-\n-        // the above will have filled up the vector as much as\n-        // possible in multiples of 8 bytes.\n-        let mut remaining = dest.len() % 8;\n-\n-        // space for a u32\n-        if remaining >= 4 {\n-            let mut slice: Slice<u32> = unsafe { cast::transmute_copy(&dest) };\n-            slice.len /= size_of::<u32>();\n-            let as_u32: &mut [u32] = unsafe { cast::transmute(slice) };\n-            as_u32[as_u32.len() - 1] = self.next_u32();\n-            remaining -= 4;\n-        }\n-        // exactly filled\n-        if remaining == 0 { return }\n-\n-        // now we know we've either got 1, 2 or 3 spots to go,\n-        // i.e. exactly one u32 is enough.\n-        let rand = self.next_u32();\n-        let remaining_index = dest.len() - remaining;\n-        match dest.mut_slice_from(remaining_index) {\n-            [ref mut a] => {\n-                *a = rand as u8;\n-            }\n-            [ref mut a, ref mut b] => {\n-                *a = rand as u8;\n-                *b = (rand >> 8) as u8;\n-            }\n-            [ref mut a, ref mut b, ref mut c] => {\n-                *a = rand as u8;\n-                *b = (rand >> 8) as u8;\n-                *c = (rand >> 16) as u8;\n+        // this could, in theory, be done by transmuting dest to a\n+        // [u64], but this is (1) likely to be undefined behaviour for\n+        // LLVM, (2) has to be very careful about alignment concerns,\n+        // (3) adds more `unsafe` that needs to be checked, (4)\n+        // probably doesn't give much performance gain if\n+        // optimisations are on.\n+        let mut count = 0;\n+        let mut num = 0;\n+        for byte in dest.mut_iter() {\n+            if count == 0 {\n+                // we could micro-optimise here by generating a u32 if\n+                // we only need a few more bytes to fill the vector\n+                // (i.e. at most 4).\n+                num = self.next_u64();\n+                count = 8;\n             }\n-            _ => fail!(\"Rng.fill_bytes: the impossible occurred: remaining != 1, 2 or 3\")\n+\n+            *byte = (num & 0xff) as u8;\n+            num >>= 8;\n+            count -= 1;\n         }\n     }\n \n@@ -218,14 +208,14 @@ pub trait Rng {\n         vec::from_fn(len, |_| self.gen())\n     }\n \n-    /// Generate a random primitive integer in the range [`low`,\n-    /// `high`). Fails if `low >= high`.\n+    /// Generate a random value in the range [`low`, `high`). Fails if\n+    /// `low >= high`.\n     ///\n-    /// This gives a uniform distribution (assuming this RNG is itself\n-    /// uniform), even for edge cases like `gen_integer_range(0u8,\n-    /// 170)`, which a naive modulo operation would return numbers\n-    /// less than 85 with double the probability to those greater than\n-    /// 85.\n+    /// This is a convenience wrapper around\n+    /// `distributions::Range`. If this function will be called\n+    /// repeatedly with the same arguments, one should use `Range`, as\n+    /// that will amortize the computations that allow for perfect\n+    /// uniformity, as they only happen on initialization.\n     ///\n     /// # Example\n     ///\n@@ -235,22 +225,15 @@ pub trait Rng {\n     ///\n     /// fn main() {\n     ///    let mut rng = rand::task_rng();\n-    ///    let n: uint = rng.gen_integer_range(0u, 10);\n+    ///    let n: uint = rng.gen_range(0u, 10);\n     ///    println!(\"{}\", n);\n-    ///    let m: int = rng.gen_integer_range(-40, 400);\n+    ///    let m: float = rng.gen_range(-40.0, 1.3e5);\n     ///    println!(\"{}\", m);\n     /// }\n     /// ```\n-    fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n-        assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n-        let range = (high - low).to_u64().unwrap();\n-        let accept_zone = u64::max_value - u64::max_value % range;\n-        loop {\n-            let rand = self.gen::<u64>();\n-            if rand < accept_zone {\n-                return low + NumCast::from(rand % range).unwrap();\n-            }\n-        }\n+    fn gen_range<T: Ord + SampleRange>(&mut self, low: T, high: T) -> T {\n+        assert!(low < high, \"Rng.gen_range called with low >= high\");\n+        Range::new(low, high).ind_sample(self)\n     }\n \n     /// Return a bool with a 1 in n chance of true\n@@ -267,7 +250,7 @@ pub trait Rng {\n     /// }\n     /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n-        n == 0 || self.gen_integer_range(0, n) == 0\n+        n == 0 || self.gen_range(0, n) == 0\n     }\n \n     /// Return a random string of the specified length composed of\n@@ -317,93 +300,8 @@ pub trait Rng {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(&values[self.gen_integer_range(0u, values.len())])\n-        }\n-    }\n-\n-    /// Choose an item respecting the relative weights, failing if the sum of\n-    /// the weights is 0\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{}\", rng.choose_weighted(x));\n-    /// }\n-    /// ```\n-    fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n-        self.choose_weighted_option(v).expect(\"Rng.choose_weighted: total weight is 0\")\n-    }\n-\n-    /// Choose Some(item) respecting the relative weights, returning none if\n-    /// the sum of the weights is 0\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{:?}\", rng.choose_weighted_option(x));\n-    /// }\n-    /// ```\n-    fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n-                                       -> Option<T> {\n-        let mut total = 0u;\n-        for item in v.iter() {\n-            total += item.weight;\n-        }\n-        if total == 0u {\n-            return None;\n-        }\n-        let chosen = self.gen_integer_range(0u, total);\n-        let mut so_far = 0u;\n-        for item in v.iter() {\n-            so_far += item.weight;\n-            if so_far > chosen {\n-                return Some(item.item.clone());\n-            }\n+            Some(&values[self.gen_range(0u, values.len())])\n         }\n-        unreachable!();\n-    }\n-\n-    /// Return a vec containing copies of the items, in order, where\n-    /// the weight of the item determines how many copies there are\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n-    ///\n-    /// fn main() {\n-    ///     let mut rng = rand::rng();\n-    ///     let x = [rand::Weighted {weight: 4, item: 'a'},\n-    ///              rand::Weighted {weight: 2, item: 'b'},\n-    ///              rand::Weighted {weight: 2, item: 'c'}];\n-    ///     println!(\"{}\", rng.weighted_vec(x));\n-    /// }\n-    /// ```\n-    fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n-        let mut r = ~[];\n-        for item in v.iter() {\n-            for _ in range(0u, item.weight) {\n-                r.push(item.item.clone());\n-            }\n-        }\n-        r\n     }\n \n     /// Shuffle a vec\n@@ -447,7 +345,7 @@ pub trait Rng {\n             // invariant: elements with index >= i have been locked in place.\n             i -= 1u;\n             // lock element i in place.\n-            values.swap(i, self.gen_integer_range(0u, i + 1u));\n+            values.swap(i, self.gen_range(0u, i + 1u));\n         }\n     }\n \n@@ -473,7 +371,7 @@ pub trait Rng {\n                 continue\n             }\n \n-            let k = self.gen_integer_range(0, i + 1);\n+            let k = self.gen_range(0, i + 1);\n             if k < reservoir.len() {\n                 reservoir[k] = elem\n             }\n@@ -520,8 +418,8 @@ pub trait SeedableRng<Seed>: Rng {\n \n /// Create a random number generator with a default algorithm and seed.\n ///\n-/// It returns the cryptographically-safest `Rng` algorithm currently\n-/// available in Rust. If you require a specifically seeded `Rng` for\n+/// It returns the strongest `Rng` algorithm currently implemented in\n+/// pure Rust. If you require a specifically seeded `Rng` for\n /// consistency over time you should pick one algorithm and create the\n /// `Rng` yourself.\n ///\n@@ -596,12 +494,16 @@ pub fn weak_rng() -> XorShiftRng {\n     XorShiftRng::new()\n }\n \n-/// An [Xorshift random number\n-/// generator](http://en.wikipedia.org/wiki/Xorshift).\n+/// An Xorshift[1] random number\n+/// generator.\n ///\n /// The Xorshift algorithm is not suitable for cryptographic purposes\n /// but is very fast. If you do not know for sure that it fits your\n-/// requirements, use a more secure one such as `IsaacRng`.\n+/// requirements, use a more secure one such as `IsaacRng` or `OSRng`.\n+///\n+/// [1]: Marsaglia, George (July 2003). [\"Xorshift\n+/// RNGs\"](http://www.jstatsoft.org/v08/i14/paper). *Journal of\n+/// Statistical Software*. Vol. 8 (Issue 14).\n pub struct XorShiftRng {\n     priv x: u32,\n     priv y: u32,\n@@ -749,47 +651,68 @@ pub fn random<T: Rand>() -> T {\n mod test {\n     use iter::{Iterator, range};\n     use option::{Option, Some};\n+    use vec;\n     use super::*;\n \n+    struct ConstRng { i: u64 }\n+    impl Rng for ConstRng {\n+        fn next_u32(&mut self) -> u32 { self.i as u32 }\n+        fn next_u64(&mut self) -> u64 { self.i }\n+\n+        // no fill_bytes on purpose\n+    }\n+\n     #[test]\n     fn test_fill_bytes_default() {\n-        let mut r = weak_rng();\n-\n-        let mut v = [0u8, .. 100];\n-        r.fill_bytes(v);\n+        let mut r = ConstRng { i: 0x11_22_33_44_55_66_77_88 };\n+\n+        // check every remainder mod 8, both in small and big vectors.\n+        let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n+                       80, 81, 82, 83, 84, 85, 86, 87];\n+        for &n in lengths.iter() {\n+            let mut v = vec::from_elem(n, 0u8);\n+            r.fill_bytes(v);\n+\n+            // use this to get nicer error messages.\n+            for (i, &byte) in v.iter().enumerate() {\n+                if byte == 0 {\n+                    fail!(\"byte {} of {} is zero\", i, n)\n+                }\n+            }\n+        }\n     }\n \n     #[test]\n-    fn test_gen_integer_range() {\n+    fn test_gen_range() {\n         let mut r = rng();\n         for _ in range(0, 1000) {\n-            let a = r.gen_integer_range(-3i, 42);\n+            let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n-            assert_eq!(r.gen_integer_range(0, 1), 0);\n-            assert_eq!(r.gen_integer_range(-12, -11), -12);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(-12, -11), -12);\n         }\n \n         for _ in range(0, 1000) {\n-            let a = r.gen_integer_range(10, 42);\n+            let a = r.gen_range(10, 42);\n             assert!(a >= 10 && a < 42);\n-            assert_eq!(r.gen_integer_range(0, 1), 0);\n-            assert_eq!(r.gen_integer_range(3_000_000u, 3_000_001), 3_000_000);\n+            assert_eq!(r.gen_range(0, 1), 0);\n+            assert_eq!(r.gen_range(3_000_000u, 3_000_001), 3_000_000);\n         }\n \n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_integer_range_fail_int() {\n+    fn test_gen_range_fail_int() {\n         let mut r = rng();\n-        r.gen_integer_range(5i, -2);\n+        r.gen_range(5i, -2);\n     }\n \n     #[test]\n     #[should_fail]\n-    fn test_gen_integer_range_fail_uint() {\n+    fn test_gen_range_fail_uint() {\n         let mut r = rng();\n-        r.gen_integer_range(5u, 2u);\n+        r.gen_range(5u, 2u);\n     }\n \n     #[test]\n@@ -843,44 +766,6 @@ mod test {\n         assert_eq!(r.choose_option(v), Some(&i));\n     }\n \n-    #[test]\n-    fn test_choose_weighted() {\n-        let mut r = rng();\n-        assert!(r.choose_weighted([\n-            Weighted { weight: 1u, item: 42 },\n-        ]) == 42);\n-        assert!(r.choose_weighted([\n-            Weighted { weight: 0u, item: 42 },\n-            Weighted { weight: 1u, item: 43 },\n-        ]) == 43);\n-    }\n-\n-    #[test]\n-    fn test_choose_weighted_option() {\n-        let mut r = rng();\n-        assert!(r.choose_weighted_option([\n-            Weighted { weight: 1u, item: 42 },\n-        ]) == Some(42));\n-        assert!(r.choose_weighted_option([\n-            Weighted { weight: 0u, item: 42 },\n-            Weighted { weight: 1u, item: 43 },\n-        ]) == Some(43));\n-        let v: Option<int> = r.choose_weighted_option([]);\n-        assert!(v.is_none());\n-    }\n-\n-    #[test]\n-    fn test_weighted_vec() {\n-        let mut r = rng();\n-        let empty: ~[int] = ~[];\n-        assert_eq!(r.weighted_vec([]), empty);\n-        assert!(r.weighted_vec([\n-            Weighted { weight: 0u, item: 3u },\n-            Weighted { weight: 1u, item: 2u },\n-            Weighted { weight: 2u, item: 1u },\n-        ]) == ~[2u, 1u, 1u]);\n-    }\n-\n     #[test]\n     fn test_shuffle() {\n         let mut r = rng();\n@@ -894,7 +779,7 @@ mod test {\n         let mut r = task_rng();\n         r.gen::<int>();\n         assert_eq!(r.shuffle(~[1, 1, 1]), ~[1, 1, 1]);\n-        assert_eq!(r.gen_integer_range(0u, 1u), 0u);\n+        assert_eq!(r.gen_range(0u, 1u), 0u);\n     }\n \n     #[test]\n@@ -953,41 +838,53 @@ mod bench {\n     use extra::test::BenchHarness;\n     use rand::*;\n     use mem::size_of;\n+    use iter::range;\n+    use option::{Some, None};\n+\n+    static N: u64 = 100;\n \n     #[bench]\n     fn rand_xorshift(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]\n     fn rand_isaac(bh: &mut BenchHarness) {\n         let mut rng = IsaacRng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]\n     fn rand_isaac64(bh: &mut BenchHarness) {\n         let mut rng = Isaac64Rng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]\n     fn rand_std(bh: &mut BenchHarness) {\n         let mut rng = StdRng::new();\n         do bh.iter {\n-            rng.gen::<uint>();\n+            for _ in range(0, N) {\n+                rng.gen::<uint>();\n+            }\n         }\n-        bh.bytes = size_of::<uint>() as u64;\n+        bh.bytes = size_of::<uint>() as u64 * N;\n     }\n \n     #[bench]"}, {"sha": "5ed8d6b10d1be2f364eafde183d59b37ce936f30", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -30,17 +30,25 @@ type HCRYPTPROV = c_long;\n // assume they work when we call them.\n \n /// A random number generator that retrieves randomness straight from\n-/// the operating system. On Unix-like systems this reads from\n-/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+/// the operating system. Platform sources:\n+///\n+/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+///   `/dev/urandom`.\n+/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+///   service provider with the `PROV_RSA_FULL` type.\n ///\n /// This does not block.\n #[cfg(unix)]\n pub struct OSRng {\n     priv inner: ReaderRng<file::FileStream>\n }\n /// A random number generator that retrieves randomness straight from\n-/// the operating system. On Unix-like systems this reads from\n-/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+/// the operating system. Platform sources:\n+///\n+/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+///   `/dev/urandom`.\n+/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+///   service provider with the `PROV_RSA_FULL` type.\n ///\n /// This does not block.\n #[cfg(windows)]"}, {"sha": "1b805a0b8f7638a57fb71c9f500651d112df1572", "filename": "src/libstd/rand/range.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frand%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frange.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,235 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generating numbers between two others.\n+\n+// this is surprisingly complicated to be both generic & correct\n+\n+use cmp::Ord;\n+use num::Bounded;\n+use rand::Rng;\n+use rand::distributions::{Sample, IndependentSample};\n+\n+/// Sample values uniformly between two bounds.\n+///\n+/// This gives a uniform distribution (assuming the RNG used to sample\n+/// it is itself uniform & the `SampleRange` implementation for the\n+/// given type is correct), even for edge cases like `low = 0u8`,\n+/// `high = 170u8`, for which a naive modulo operation would return\n+/// numbers less than 85 with double the probability to those greater\n+/// than 85.\n+///\n+/// Types should attempt to sample in `[low, high)`, i.e., not\n+/// including `high`, but this may be very difficult. All the\n+/// primitive integer types satisfy this property, and the float types\n+/// normally satisfy it, but rounding may mean `high` can occur.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{IndependentSample, Range};\n+///\n+/// fn main() {\n+///     let between = Range::new(10u, 10000u);\n+///     let rng = rand::task_rng();\n+///     let mut sum = 0;\n+///     for _ in range(0, 1000) {\n+///         sum += between.ind_sample(rng);\n+///     }\n+///     println!(\"{}\", sum);\n+/// }\n+/// ```\n+pub struct Range<X> {\n+    priv low: X,\n+    priv range: X,\n+    priv accept_zone: X\n+}\n+\n+impl<X: SampleRange + Ord> Range<X> {\n+    /// Create a new `Range` instance that samples uniformly from\n+    /// `[low, high)`. Fails if `low >= high`.\n+    pub fn new(low: X, high: X) -> Range<X> {\n+        assert!(low < high, \"Range::new called with `low >= high`\");\n+        SampleRange::construct_range(low, high)\n+    }\n+}\n+\n+impl<Sup: SampleRange> Sample<Sup> for Range<Sup> {\n+    #[inline]\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup { self.ind_sample(rng) }\n+}\n+impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n+        SampleRange::sample_range(self, rng)\n+    }\n+}\n+\n+/// The helper trait for types that have a sensible way to sample\n+/// uniformly between two values. This should not be used directly,\n+/// and is only to facilitate `Range`.\n+pub trait SampleRange {\n+    /// Construct the `Range` object that `sample_range`\n+    /// requires. This should not ever be called directly, only via\n+    /// `Range::new`, which will check that `low < high`, so this\n+    /// function doesn't have to repeat the check.\n+    fn construct_range(low: Self, high: Self) -> Range<Self>;\n+\n+    /// Sample a value from the given `Range` with the given `Rng` as\n+    /// a source of randomness.\n+    fn sample_range<R: Rng>(r: &Range<Self>, rng: &mut R) -> Self;\n+}\n+\n+macro_rules! integer_impl {\n+    ($ty:ty, $unsigned:ty) => {\n+        impl SampleRange for $ty {\n+            // we play free and fast with unsigned vs signed here\n+            // (when $ty is signed), but that's fine, since the\n+            // contract of this macro is for $ty and $unsigned to be\n+            // \"bit-equal\", so casting between them is a no-op & a\n+            // bijection.\n+\n+            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n+                let range = high as $unsigned - low as $unsigned;\n+                let unsigned_max: $unsigned = Bounded::max_value();\n+\n+                // this is the largest number that fits into $unsigned\n+                // that `range` divides evenly, so, if we've sampled\n+                // `n` uniformly from this region, then `n % range` is\n+                // uniform in [0, range)\n+                let zone = unsigned_max - unsigned_max % range;\n+\n+                Range {\n+                    low: low,\n+                    range: range as $ty,\n+                    accept_zone: zone as $ty\n+                }\n+            }\n+            #[inline]\n+            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n+                loop {\n+                    // rejection sample\n+                    let v = rng.gen::<$unsigned>();\n+                    // until we find something that fits into the\n+                    // region which r.range evenly divides (this will\n+                    // be uniformly distributed)\n+                    if v < r.accept_zone as $unsigned {\n+                        // and return it, with some adjustments\n+                        return r.low + (v % r.range as $unsigned) as $ty;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+integer_impl! { i8, u8 }\n+integer_impl! { i16, u16 }\n+integer_impl! { i32, u32 }\n+integer_impl! { i64, u64 }\n+integer_impl! { int, uint }\n+integer_impl! { u8, u8 }\n+integer_impl! { u16, u16 }\n+integer_impl! { u32, u32 }\n+integer_impl! { u64, u64 }\n+integer_impl! { uint, uint }\n+\n+macro_rules! float_impl {\n+    ($ty:ty) => {\n+        impl SampleRange for $ty {\n+            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n+                Range {\n+                    low: low,\n+                    range: high - low,\n+                    accept_zone: 0.0 // unused\n+                }\n+            }\n+            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n+                r.low + r.range * rng.gen()\n+            }\n+        }\n+    }\n+}\n+\n+float_impl! { f32 }\n+float_impl! { f64 }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use rand::*;\n+    use num::Bounded;\n+    use iter::range;\n+    use option::{Some, None};\n+    use vec::ImmutableVector;\n+\n+    #[should_fail]\n+    #[test]\n+    fn test_range_bad_limits_equal() {\n+        Range::new(10, 10);\n+    }\n+    #[should_fail]\n+    #[test]\n+    fn test_range_bad_limits_flipped() {\n+        Range::new(10, 5);\n+    }\n+\n+    #[test]\n+    fn test_integers() {\n+        let rng = task_rng();\n+        macro_rules! t (\n+            ($($ty:ty),*) => {{\n+                $(\n+                   let v: &[($ty, $ty)] = [(0, 10),\n+                                           (10, 127),\n+                                           (Bounded::min_value(), Bounded::max_value())];\n+                   for &(low, high) in v.iter() {\n+                        let mut sampler: Range<$ty> = Range::new(low, high);\n+                        for _ in range(0, 1000) {\n+                            let v = sampler.sample(rng);\n+                            assert!(low <= v && v < high);\n+                            let v = sampler.ind_sample(rng);\n+                            assert!(low <= v && v < high);\n+                        }\n+                    }\n+                 )*\n+            }}\n+        );\n+        t!(i8, i16, i32, i64, int,\n+           u8, u16, u32, u64, uint)\n+    }\n+\n+    #[test]\n+    fn test_floats() {\n+        let rng = task_rng();\n+        macro_rules! t (\n+            ($($ty:ty),*) => {{\n+                $(\n+                   let v: &[($ty, $ty)] = [(0.0, 100.0),\n+                                           (-1e35, -1e25),\n+                                           (1e-35, 1e-25),\n+                                           (-1e35, 1e35)];\n+                   for &(low, high) in v.iter() {\n+                        let mut sampler: Range<$ty> = Range::new(low, high);\n+                        for _ in range(0, 1000) {\n+                            let v = sampler.sample(rng);\n+                            assert!(low <= v && v < high);\n+                            let v = sampler.ind_sample(rng);\n+                            assert!(low <= v && v < high);\n+                        }\n+                    }\n+                 )*\n+            }}\n+        );\n+\n+        t!(f32, f64)\n+    }\n+\n+}"}, {"sha": "d63b14f982d403a6dd845a2afc0555a6fcd84a85", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -41,7 +41,7 @@ pub fn align(size: uint, align: uint) -> uint {\n \n /// Adaptor to wrap around visitors implementing MovePtr.\n pub struct MovePtrAdaptor<V> {\n-    inner: V\n+    priv inner: V\n }\n pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n     MovePtrAdaptor { inner: v }"}, {"sha": "d03621eb60d2f216aee918d48808512fe2d63edf", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -98,10 +98,10 @@ enum VariantState {\n }\n \n pub struct ReprVisitor<'self> {\n-    ptr: *c_void,\n-    ptr_stk: ~[*c_void],\n-    var_stk: ~[VariantState],\n-    writer: &'self mut io::Writer\n+    priv ptr: *c_void,\n+    priv ptr_stk: ~[*c_void],\n+    priv var_stk: ~[VariantState],\n+    priv writer: &'self mut io::Writer\n }\n \n pub fn ReprVisitor<'a>(ptr: *c_void,"}, {"sha": "4426a3eafe1e864b11157bd23b6e886ee51d6a9a", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -29,9 +29,9 @@ static ALL_BITS: uint = FROZEN_BIT | MUT_BIT;\n \n #[deriving(Eq)]\n pub struct BorrowRecord {\n-    box: *mut raw::Box<()>,\n+    priv box: *mut raw::Box<()>,\n     file: *c_char,\n-    line: size_t\n+    priv line: size_t\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {"}, {"sha": "6319fdead17da442e186c925838ad12d06bfb6f0", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -48,14 +48,14 @@ struct Packet<T> {\n \n // A one-shot channel.\n pub struct ChanOne<T> {\n-    void_packet: *mut Void,\n-    suppress_finalize: bool\n+    priv void_packet: *mut Void,\n+    priv suppress_finalize: bool\n }\n \n /// A one-shot port.\n pub struct PortOne<T> {\n-    void_packet: *mut Void,\n-    suppress_finalize: bool\n+    priv void_packet: *mut Void,\n+    priv suppress_finalize: bool\n }\n \n pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n@@ -1117,7 +1117,7 @@ mod test {\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n             do total.times {\n-                let msgs = rng.gen_integer_range(0u, 10);\n+                let msgs = rng.gen_range(0u, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n                 do spawntask_random {"}, {"sha": "b86dbfd6fb05f8345def93da97b85677cee145e4", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -25,11 +25,11 @@ pub static RED_ZONE: uint = 20 * 1024;\n // then misalign the regs again.\n pub struct Context {\n     /// The context entry point, saved here for later destruction\n-    start: Option<~~fn()>,\n+    priv start: Option<~~fn()>,\n     /// Hold the registers while the task or scheduler is suspended\n-    regs: ~Registers,\n+    priv regs: ~Registers,\n     /// Lower bound and upper bound for the stack\n-    stack_bounds: Option<(uint, uint)>,\n+    priv stack_bounds: Option<(uint, uint)>,\n }\n \n impl Context {\n@@ -391,58 +391,54 @@ pub unsafe fn record_sp_limit(limit: uint) {\n /// As with the setter, this function does not have a __morestack header and can\n /// therefore be called in a \"we're out of stack\" situation.\n #[inline(always)]\n-// NOTE: after the next snapshot, can remove the initialization before inline\n-//       assembly due to an improvement in how it's handled, then this specific\n-//       allow directive should get removed.\n-#[allow(dead_assignment)]\n pub unsafe fn get_sp_limit() -> uint {\n     return target_get_sp_limit();\n \n     // x86-64\n     #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let mut limit: uint = 0;\n+        let limit;\n         asm!(\"movq $$0x60+90*8, %rsi\n               movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n         return limit;\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let mut limit: uint = 0;\n+        let limit;\n         asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let mut limit: uint = 0;\n+        let limit;\n         asm!(\"movq %gs:0x28, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n     #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let mut limit: uint = 0;\n+        let limit;\n         asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n \n     // x86\n     #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let mut limit: uint = 0;\n+        let limit;\n         asm!(\"movl $$0x48+90*4, %eax\n               movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n         return limit;\n     }\n     #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n     #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let mut limit: uint = 0;\n+        let limit;\n         asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n     #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n-        let mut limit: uint = 0;\n+        let limit;\n         asm!(\"movl %fs:0x14, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }"}, {"sha": "dd71426938dc45e1444f9a022fdf80c368f6e6c4", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -26,9 +26,9 @@ pub struct ModEntry<'self> {\n }\n \n pub struct CrateMap<'self> {\n-    version: i32,\n-    entries: &'self [ModEntry<'self>],\n-    children: &'self [&'self CrateMap<'self>]\n+     priv version: i32,\n+     priv entries: &'self [ModEntry<'self>],\n+     priv children: &'self [&'self CrateMap<'self>]\n }\n \n #[cfg(not(windows))]"}, {"sha": "a43bcd8142e1804e142ed480d049ae6f6335de17", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -362,8 +362,8 @@ impl Seek for FileWriter {\n /// For this reason, it is best to use the access-constrained wrappers that are\n /// exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n pub struct FileStream {\n-    fd: ~RtioFileStream,\n-    last_nread: int,\n+    priv fd: ~RtioFileStream,\n+    priv last_nread: int,\n }\n \n /// a `std::rt::io::Reader` trait impl for file I/O."}, {"sha": "8a5aa171eb805d55c7dcb00f284580acf242313e", "filename": "src/libstd/rt/io/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fflate.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -17,7 +17,7 @@ use super::*;\n \n /// A Writer decorator that compresses using the 'deflate' scheme\n pub struct DeflateWriter<W> {\n-    inner_writer: W\n+    priv inner_writer: W\n }\n \n impl<W: Writer> DeflateWriter<W> {\n@@ -56,7 +56,7 @@ impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n \n /// A Reader decorator that decompresses using the 'deflate' scheme\n pub struct InflateReader<R> {\n-    inner_reader: R\n+    priv inner_reader: R\n }\n \n impl<R: Reader> InflateReader<R> {"}, {"sha": "44709c7b7b686321e21716bf99cb2a2452c6de7b", "filename": "src/libstd/rt/io/mock.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmock.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -13,7 +13,7 @@ use rt::io::{Reader, Writer};\n \n pub struct MockReader {\n     read: ~fn(buf: &mut [u8]) -> Option<uint>,\n-    eof: ~fn() -> bool\n+    priv eof: ~fn() -> bool\n }\n \n impl MockReader {\n@@ -31,8 +31,8 @@ impl Reader for MockReader {\n }\n \n pub struct MockWriter {\n-    write: ~fn(buf: &[u8]),\n-    flush: ~fn()\n+    priv write: ~fn(buf: &[u8]),\n+    priv flush: ~fn()\n }\n \n impl MockWriter {"}, {"sha": "a80c1aab3988987e8ca9a042c3195ba46dff13ef", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -12,8 +12,8 @@\n \n This module defines the Rust interface for synchronous I/O.\n It models byte-oriented input and output with the Reader and Writer traits.\n-Types that implement both `Reader` and `Writer` and called 'streams',\n-and automatically implement trait `Stream`.\n+Types that implement both `Reader` and `Writer` are called 'streams',\n+and automatically implement the `Stream` trait.\n Implementations are provided for common I/O streams like\n file, TCP, UDP, Unix domain sockets.\n Readers and Writers may be composed to add capabilities like string"}, {"sha": "19f17ca966d2d551fd088e45683429e058df7926", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -219,17 +219,17 @@ pub struct Death {\n     // might kill it. This is optional so we can take it by-value at exit time.\n     kill_handle:     Option<KillHandle>,\n     // Handle to a watching parent, if we have one, for exit code propagation.\n-    watching_parent: Option<KillHandle>,\n+    priv watching_parent: Option<KillHandle>,\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n     on_exit:         Option<~fn(bool)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n-    unkillable:      int,\n+    priv unkillable:      int,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n-    wont_sleep:      int,\n+    priv wont_sleep:      int,\n     // A \"spare\" handle to the kill flag inside the kill handle. Used during\n     // blocking/waking as an optimization to avoid two xadds on the refcount.\n-    spare_kill_flag: Option<KillFlagHandle>,\n+    priv spare_kill_flag: Option<KillFlagHandle>,\n }\n \n impl Drop for KillFlag {"}, {"sha": "14df292343e9f496ca5cdbe2d94f3576a947252c", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -32,8 +32,8 @@ pub type OpaqueBox = c_void;\n pub type TypeDesc = c_void;\n \n pub struct LocalHeap {\n-    memory_region: *MemoryRegion,\n-    boxed_region: *BoxedRegion\n+    priv memory_region: *MemoryRegion,\n+    priv boxed_region: *BoxedRegion\n }\n \n impl LocalHeap {"}, {"sha": "2699dab6d38a871586762b7f331092b32fbc2d6b", "filename": "src/libstd/rt/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frc.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -24,7 +24,7 @@ use libc::c_void;\n use cast;\n \n pub struct RC<T> {\n-    p: *c_void // ~(uint, T)\n+    priv p: *c_void // ~(uint, T)\n }\n \n impl<T> RC<T> {"}, {"sha": "501def8b0607903f82f7fc33d1346e224a9dad00", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -66,7 +66,7 @@ pub struct FileOpenConfig {\n     /// Flags for file access mode (as per open(2))\n     flags: int,\n     /// File creation mode, ignored unless O_CREAT is passed as part of flags\n-    mode: int\n+    priv mode: int\n }\n \n pub trait IoFactory {"}, {"sha": "ee163bab3c062c8a8beead2016ab55604423a243", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -66,26 +66,26 @@ pub struct Scheduler {\n     event_loop: ~EventLoopObject,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n-    sched_task: Option<~Task>,\n+    priv sched_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n-    cleanup_job: Option<CleanupJob>,\n+    priv cleanup_job: Option<CleanupJob>,\n     /// Should this scheduler run any task, or only pinned tasks?\n     run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n     /// them to.\n-    friend_handle: Option<SchedHandle>,\n+    priv friend_handle: Option<SchedHandle>,\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A toggleable idle callback\n-    idle_callback: Option<~PausibleIdleCallback>,\n+    priv idle_callback: Option<~PausibleIdleCallback>,\n     /// A countdown that starts at a random value and is decremented\n     /// every time a yield check is performed. When it hits 0 a task\n     /// will yield.\n-    yield_check_count: uint,\n+    priv yield_check_count: uint,\n     /// A flag to tell the scheduler loop it needs to do some stealing\n     /// in order to introduce randomness as part of a yield\n-    steal_for_yield: bool\n+    priv steal_for_yield: bool\n }\n \n /// An indication of how hard to work on a given operation, the difference\n@@ -431,7 +431,7 @@ impl Scheduler {\n     fn try_steals(&mut self) -> Option<~Task> {\n         let work_queues = &mut self.work_queues;\n         let len = work_queues.len();\n-        let start_index = self.rng.gen_integer_range(0, len);\n+        let start_index = self.rng.gen_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n             match work_queues[index].steal() {\n                 Some(task) => {"}, {"sha": "55bd4b0732a6f3d16cbed7d898dcb061b6296851", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -15,8 +15,8 @@ use ops::Drop;\n use libc::{c_uint, uintptr_t};\n \n pub struct StackSegment {\n-    buf: ~[u8],\n-    valgrind_id: c_uint\n+    priv buf: ~[u8],\n+    priv valgrind_id: c_uint\n }\n \n impl StackSegment {"}, {"sha": "c4f352501a08bfe621ce6ac2ca6596bd6c656365", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -44,7 +44,7 @@ use send_str::SendStr;\n \n pub struct Task {\n     heap: LocalHeap,\n-    gc: GarbageCollector,\n+    priv gc: GarbageCollector,\n     storage: LocalStorage,\n     logger: StdErrLogger,\n     unwinder: Unwinder,\n@@ -69,7 +69,7 @@ pub struct Coroutine {\n     /// The segment of stack on which the task is currently running or\n     /// if the task is blocked, on which the task will resume\n     /// execution.\n-    current_stack_segment: StackSegment,\n+    priv current_stack_segment: StackSegment,\n     /// Always valid if the task is alive and not running.\n     saved_context: Context\n }"}, {"sha": "949d73ecc4fcfaf63b58045be2fcb7c2245dc589", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -18,9 +18,9 @@ use uint;\n type raw_thread = libc::c_void;\n \n pub struct Thread {\n-    main: ~fn(),\n-    raw_thread: *raw_thread,\n-    joined: bool,\n+    priv main: ~fn(),\n+    priv raw_thread: *raw_thread,\n+    priv joined: bool\n }\n \n impl Thread {"}, {"sha": "16fd3fa38eae9454ba69c47333e23ce519988456", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -28,7 +28,7 @@ struct TubeState<T> {\n }\n \n pub struct Tube<T> {\n-    p: RC<TubeState<T>>\n+    priv p: RC<TubeState<T>>\n }\n \n impl<T> Tube<T> {"}, {"sha": "f2abcd3aca7e35a5be7bd2059d76a47c705674fc", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -25,7 +25,7 @@ type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &UvAddrInfo, Option<UvError>)\n pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n \n pub struct RequestData {\n-    getaddrinfo_cb: Option<GetAddrInfoCallback>,\n+    priv getaddrinfo_cb: Option<GetAddrInfoCallback>,\n }\n \n impl GetAddrInfoRequest {"}, {"sha": "5d64ca4d755ce5ede9682590d31a994e401d8fa0", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -25,7 +25,7 @@ pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest {}\n \n pub struct RequestData {\n-    complete_cb: Option<FsCallback>\n+    priv complete_cb: Option<FsCallback>\n }\n \n impl FsRequest {"}, {"sha": "3a6a3acbc5342bb50830155a86611c12d5f33f1b", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -80,7 +80,7 @@ pub mod pipe;\n /// with dtors may not be destructured, but tuple structs can,\n /// but the results are not correct.\n pub struct Loop {\n-    handle: *uvll::uv_loop_t\n+    priv handle: *uvll::uv_loop_t\n }\n \n /// The trait implemented by uv 'watchers' (handles). Watchers are"}, {"sha": "8dd0f8a6b106e85ceb4484251688c979abcb89cf", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -180,7 +180,7 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n \n // Obviously an Event Loop is always home.\n pub struct UvEventLoop {\n-    uvio: UvIoFactory\n+    priv uvio: UvIoFactory\n }\n \n impl UvEventLoop {\n@@ -240,9 +240,9 @@ impl EventLoop for UvEventLoop {\n }\n \n pub struct UvPausibleIdleCallback {\n-    watcher: IdleWatcher,\n-    idle_flag: bool,\n-    closed: bool\n+    priv watcher: IdleWatcher,\n+    priv idle_flag: bool,\n+    priv closed: bool\n }\n \n impl UvPausibleIdleCallback {\n@@ -294,10 +294,10 @@ fn test_callback_run_once() {\n // The entire point of async is to call into a loop from other threads so it does not need to home.\n pub struct UvRemoteCallback {\n     // The uv async handle for triggering the callback\n-    async: AsyncWatcher,\n+    priv async: AsyncWatcher,\n     // A flag to tell the callback to exit, set from the dtor. This is\n     // almost never contested - only in rare races with the dtor.\n-    exit_flag: Exclusive<bool>\n+    priv exit_flag: Exclusive<bool>\n }\n \n impl UvRemoteCallback {\n@@ -804,8 +804,8 @@ impl IoFactory for UvIoFactory {\n }\n \n pub struct UvTcpListener {\n-    watcher : TcpWatcher,\n-    home: SchedHandle,\n+    priv watcher : TcpWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvTcpListener {\n@@ -866,8 +866,8 @@ impl RtioTcpListener for UvTcpListener {\n }\n \n pub struct UvTcpAcceptor {\n-    listener: UvTcpListener,\n-    incoming: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+    priv listener: UvTcpListener,\n+    priv incoming: Tube<Result<~RtioTcpStreamObject, IoError>>,\n }\n \n impl HomingIO for UvTcpAcceptor {\n@@ -991,7 +991,7 @@ fn write_stream(mut watcher: StreamWatcher,\n \n pub struct UvUnboundPipe {\n     pipe: Pipe,\n-    home: SchedHandle,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvUnboundPipe {\n@@ -1043,8 +1043,8 @@ impl RtioPipe for UvPipeStream {\n }\n \n pub struct UvTcpStream {\n-    watcher: TcpWatcher,\n-    home: SchedHandle,\n+    priv watcher: TcpWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvTcpStream {\n@@ -1143,8 +1143,8 @@ impl RtioTcpStream for UvTcpStream {\n }\n \n pub struct UvUdpSocket {\n-    watcher: UdpWatcher,\n-    home: SchedHandle,\n+    priv watcher: UdpWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvUdpSocket {\n@@ -1353,8 +1353,8 @@ impl RtioUdpSocket for UvUdpSocket {\n }\n \n pub struct UvTimer {\n-    watcher: timer::TimerWatcher,\n-    home: SchedHandle,\n+    priv watcher: timer::TimerWatcher,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvTimer {\n@@ -1400,10 +1400,10 @@ impl RtioTimer for UvTimer {\n }\n \n pub struct UvFileStream {\n-    loop_: Loop,\n-    fd: c_int,\n-    close_on_drop: bool,\n-    home: SchedHandle\n+    priv loop_: Loop,\n+    priv fd: c_int,\n+    priv close_on_drop: bool,\n+    priv home: SchedHandle\n }\n \n impl HomingIO for UvFileStream {\n@@ -1533,11 +1533,11 @@ impl RtioFileStream for UvFileStream {\n }\n \n pub struct UvProcess {\n-    process: process::Process,\n+    priv process: process::Process,\n \n     // Sadly, this structure must be created before we return it, so in that\n     // brief interim the `home` is None.\n-    home: Option<SchedHandle>,\n+    priv home: Option<SchedHandle>,\n \n     // All None until the process exits (exit_error may stay None)\n     priv exit_status: Option<int>,"}, {"sha": "96c5dd068d0b2c1b67e383d7ed6e47b3ff86f9d0", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -134,26 +134,26 @@ pub type uv_pipe_t = c_void;\n \n pub struct uv_timespec_t {\n     tv_sec: libc::c_long,\n-    tv_nsec: libc::c_long\n+    priv tv_nsec: libc::c_long\n }\n \n pub struct uv_stat_t {\n-    st_dev: libc::uint64_t,\n+    priv st_dev: libc::uint64_t,\n     st_mode: libc::uint64_t,\n-    st_nlink: libc::uint64_t,\n-    st_uid: libc::uint64_t,\n-    st_gid: libc::uint64_t,\n-    st_rdev: libc::uint64_t,\n-    st_ino: libc::uint64_t,\n+    priv st_nlink: libc::uint64_t,\n+    priv st_uid: libc::uint64_t,\n+    priv st_gid: libc::uint64_t,\n+    priv st_rdev: libc::uint64_t,\n+    priv st_ino: libc::uint64_t,\n     st_size: libc::uint64_t,\n-    st_blksize: libc::uint64_t,\n-    st_blocks: libc::uint64_t,\n-    st_flags: libc::uint64_t,\n-    st_gen: libc::uint64_t,\n+    priv st_blksize: libc::uint64_t,\n+    priv st_blocks: libc::uint64_t,\n+    priv st_flags: libc::uint64_t,\n+    priv st_gen: libc::uint64_t,\n     st_atim: uv_timespec_t,\n     st_mtim: uv_timespec_t,\n     st_ctim: uv_timespec_t,\n-    st_birthtim: uv_timespec_t\n+    priv st_birthtim: uv_timespec_t\n }\n \n impl uv_stat_t {\n@@ -231,37 +231,37 @@ pub type socklen_t = c_int;\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"linux\")]\n pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n+    priv ai_flags: c_int,\n+    priv ai_family: c_int,\n+    priv ai_socktype: c_int,\n+    priv ai_protocol: c_int,\n+    priv ai_addrlen: socklen_t,\n     ai_addr: *sockaddr,\n-    ai_canonname: *char,\n+    priv ai_canonname: *char,\n     ai_next: *addrinfo\n }\n \n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n-    ai_canonname: *char,\n+    priv ai_flags: c_int,\n+    priv ai_family: c_int,\n+    priv ai_socktype: c_int,\n+    priv ai_protocol: c_int,\n+    priv ai_addrlen: socklen_t,\n+    priv ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n }\n \n #[cfg(windows)]\n pub struct addrinfo {\n-    ai_flags: c_int,\n-    ai_family: c_int,\n-    ai_socktype: c_int,\n-    ai_protocol: c_int,\n-    ai_addrlen: size_t,\n-    ai_canonname: *char,\n+    priv ai_flags: c_int,\n+    priv ai_family: c_int,\n+    priv ai_socktype: c_int,\n+    priv ai_protocol: c_int,\n+    priv ai_addrlen: size_t,\n+    priv ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n }\n@@ -960,8 +960,8 @@ pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n }\n \n pub struct uv_err_data {\n-    err_name: ~str,\n-    err_msg: ~str,\n+    priv err_name: ~str,\n+    priv err_msg: ~str,\n }\n \n extern {"}, {"sha": "c4cb8be2061f904917f83f69639523e90c426039", "filename": "src/libstd/run.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -34,7 +34,6 @@ pub struct Process {\n \n /// Options that can be given when starting a Process.\n pub struct ProcessOptions<'self> {\n-\n     /**\n      * If this is None then the new process will have the same initial\n      * environment as the parent process.\n@@ -99,7 +98,6 @@ impl <'self> ProcessOptions<'self> {\n \n /// The output of a finished process.\n pub struct ProcessOutput {\n-\n     /// The status (exit code) of the process.\n     status: int,\n "}, {"sha": "f134788942cdb316bf0345e0567373936ac86eb0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -998,7 +998,6 @@ pub fn utf8_char_width(b: u8) -> uint {\n pub struct CharRange {\n     /// Current `char`\n     ch: char,\n-\n     /// Index of the first byte of the next `char`\n     next: uint\n }"}, {"sha": "30c99c628853fed6114c2cd3d3dd37889069f784", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -108,7 +108,7 @@ pub enum SchedMode {\n  *\n  */\n pub struct SchedOpts {\n-    mode: SchedMode,\n+    priv mode: SchedMode,\n }\n \n /**\n@@ -144,11 +144,11 @@ pub struct SchedOpts {\n  *           scheduler other tasks will be impeded or even blocked indefinitely.\n  */\n pub struct TaskOpts {\n-    linked: bool,\n-    supervised: bool,\n-    watched: bool,\n-    indestructible: bool,\n-    notify_chan: Option<Chan<TaskResult>>,\n+    priv linked: bool,\n+    priv supervised: bool,\n+    priv watched: bool,\n+    priv indestructible: bool,\n+    priv notify_chan: Option<Chan<TaskResult>>,\n     name: Option<SendStr>,\n     sched: SchedOpts,\n     stack_size: Option<uint>\n@@ -170,9 +170,9 @@ pub struct TaskOpts {\n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n-    gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n-    can_not_copy: Option<util::NonCopyable>,\n-    consumed: bool,\n+    priv gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n+    priv can_not_copy: Option<util::NonCopyable>,\n+    priv consumed: bool,\n }\n \n /**"}, {"sha": "dec13eded3983873a8d4511224a707873b18684e", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -308,10 +308,10 @@ fn each_ancestor(list:        &mut AncestorList,\n // One of these per task.\n pub struct Taskgroup {\n     // List of tasks with whose fates this one's is intertwined.\n-    tasks:      TaskGroupArc, // 'none' means the group has failed.\n+    priv tasks:      TaskGroupArc, // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n-    ancestors:  AncestorList,\n-    notifier:   Option<AutoNotify>,\n+    priv ancestors:  AncestorList,\n+    priv notifier:   Option<AutoNotify>,\n }\n \n impl Drop for Taskgroup {"}, {"sha": "ee44bf4d9964a396a0f20adfcc259d5812bca230", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -49,23 +49,23 @@ pub struct TyDesc {\n     align: uint,\n \n     // Called on a copy of a value of type `T` *after* memcpy\n-    take_glue: GlueFn,\n+    priv take_glue: GlueFn,\n \n     // Called when a value of type `T` is no longer needed\n     drop_glue: GlueFn,\n \n     // Called by drop glue when a value of type `T` can be freed\n-    free_glue: GlueFn,\n+    priv free_glue: GlueFn,\n \n     // Called by reflection visitor to visit a value of type `T`\n-    visit_glue: GlueFn,\n+    priv visit_glue: GlueFn,\n \n     // If T represents a box pointer (`@U` or `~U`), then\n     // `borrow_offset` is the amount that the pointer must be adjusted\n     // to find the payload.  This is always derivable from the type\n     // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n     // `U` is unknown.\n-    borrow_offset: uint,\n+    priv borrow_offset: uint,\n \n     // Name corresponding to the type\n     name: &'static str"}, {"sha": "b5d7cc47fdc55a1d16a721cbe48f4c14389f4a71", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -15,7 +15,7 @@ use unstable::intrinsics::TyDesc;\n pub struct Box<T> {\n     ref_count: uint,\n     type_desc: *TyDesc,\n-    prev: *Box<T>,\n+    priv prev: *Box<T>,\n     next: *Box<T>,\n     data: T\n }"}, {"sha": "9d15dd031e0dce2b51573cd5a0aabe78c3b9e5cf", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -304,7 +304,7 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n type rust_little_lock = *libc::c_void;\n \n pub struct LittleLock {\n-    l: rust_little_lock,\n+    priv l: rust_little_lock,\n }\n \n impl Drop for LittleLock {\n@@ -353,7 +353,7 @@ struct ExData<T> {\n  * need to block or deschedule while accessing shared state, use extra::sync::RWArc.\n  */\n pub struct Exclusive<T> {\n-    x: UnsafeArc<ExData<T>>\n+    priv x: UnsafeArc<ExData<T>>\n }\n \n impl<T:Send> Clone for Exclusive<T> {"}, {"sha": "372f1950c1de0047979beff35f0f4eb80999cb83", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -227,7 +227,7 @@ pub enum MethodProvenance {\n pub enum Def {\n     DefFn(DefId, purity),\n     DefStaticMethod(/* method */ DefId, MethodProvenance, purity),\n-    DefSelf(NodeId),\n+    DefSelf(NodeId, bool /* is_mutbl */),\n     DefSelfTy(/* trait id */ NodeId),\n     DefMod(DefId),\n     DefForeignMod(DefId),\n@@ -921,10 +921,10 @@ pub enum ret_style {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum explicit_self_ {\n     sty_static,                                // no self\n-    sty_value,                                 // `self`\n-    sty_region(Option<Lifetime>, Mutability), // `&'lt self`\n+    sty_value(Mutability),                     // `self`\n+    sty_region(Option<Lifetime>, Mutability),  // `&'lt self`\n     sty_box(Mutability),                       // `@self`\n-    sty_uniq                                   // `~self`\n+    sty_uniq(Mutability)                       // `~self`\n }\n \n pub type explicit_self = Spanned<explicit_self_>;"}, {"sha": "1d9d5512ff424b960b414c09a4021b1413ca102a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -66,7 +66,7 @@ pub fn def_id_of_def(d: Def) -> DefId {\n       DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n         id\n       }\n-      DefArg(id, _) | DefLocal(id, _) | DefSelf(id) | DefSelfTy(id)\n+      DefArg(id, _) | DefLocal(id, _) | DefSelf(id, _) | DefSelfTy(id)\n       | DefUpvar(id, _, _, _) | DefBinding(id, _) | DefRegion(id)\n       | DefTyParamBinder(id) | DefLabel(id) => {\n         local_def(id)"}, {"sha": "c60259304aef23cac3baea73919089ceff543ee4", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -240,13 +240,13 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::sty_value))\n+            (self_path, respan(span, ast::sty_value(ast::MutImmutable)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Send => ast::sty_uniq,\n+                    Send => ast::sty_uniq(ast::MutImmutable),\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s)));"}, {"sha": "605e259cf0c2b2e89e18cada2eecd75b9b436296", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -3438,15 +3438,11 @@ impl Parser {\n \n     // parse the argument list and result type of a function\n     // that may have a self type.\n-    fn parse_fn_decl_with_self(\n-        &self,\n-        parse_arg_fn:\n-        &fn(&Parser) -> arg\n-    ) -> (explicit_self, fn_decl) {\n-        fn maybe_parse_explicit_self(\n-            cnstr: &fn(v: Mutability) -> ast::explicit_self_,\n-            p: &Parser\n-        ) -> ast::explicit_self_ {\n+    fn parse_fn_decl_with_self(&self, parse_arg_fn: &fn(&Parser) -> arg)\n+        -> (explicit_self, fn_decl) {\n+\n+        fn maybe_parse_explicit_self(cnstr: &fn(v: Mutability) -> ast::explicit_self_,\n+                                     p: &Parser) -> ast::explicit_self_ {\n             // We need to make sure it isn't a type\n             if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n                 ((p.look_ahead(1, |t| token::is_keyword(keywords::Const, t)) ||\n@@ -3524,25 +3520,39 @@ impl Parser {\n                     self.span_err(*self.last_span,\n                                   \"mutability declaration not allowed here\");\n                 }\n-                sty_uniq\n+                sty_uniq(MutImmutable)\n             }, self)\n           }\n           token::IDENT(*) if self.is_self_ident() => {\n             self.bump();\n-            sty_value\n+            sty_value(MutImmutable)\n           }\n           token::BINOP(token::STAR) => {\n             // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n             // emitting cryptic \"unexpected token\" errors.\n             self.bump();\n-            if self.token_is_mutability(self.token) {\n-                self.bump();\n-            }\n+            let mutability = if self.token_is_mutability(self.token) {\n+                self.parse_mutability()\n+            } else { MutImmutable };\n             if self.is_self_ident() {\n                 self.span_err(*self.span, \"cannot pass self by unsafe pointer\");\n                 self.bump();\n             }\n-            sty_value\n+            sty_value(mutability)\n+          }\n+          _ if self.token_is_mutability(self.token) &&\n+               self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n+            let mutability = self.parse_mutability();\n+            self.expect_self_ident();\n+            sty_value(mutability)\n+          }\n+          _ if self.token_is_mutability(self.token) &&\n+               self.look_ahead(1, |t| *t == token::TILDE) &&\n+               self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n+            let mutability = self.parse_mutability();\n+            self.bump();\n+            self.expect_self_ident();\n+            sty_uniq(mutability)\n           }\n           _ => {\n             sty_static"}, {"sha": "0e330da31e6235915279d8a1b062ea05d9709c9d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -1686,8 +1686,14 @@ pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_in\n pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n     match explicit_self {\n         ast::sty_static => { return false; }\n-        ast::sty_value => { word(s.s, \"self\"); }\n-        ast::sty_uniq => { word(s.s, \"~self\"); }\n+        ast::sty_value(m) => {\n+            print_mutability(s, m);\n+            word(s.s, \"self\");\n+        }\n+        ast::sty_uniq(m) => {\n+            print_mutability(s, m);\n+            word(s.s, \"~self\");\n+        }\n         ast::sty_region(ref lt, m) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, lt);"}, {"sha": "77020537661600115a4e2565895f243257626c53", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -672,6 +672,8 @@ extern \"C\" CDECL void\n rust_win32_rand_acquire(HCRYPTPROV* phProv) {\n     win32_require\n         (_T(\"CryptAcquireContext\"),\n+         // changes to the parameters here should be reflected in the docs of\n+         // std::rand::os::OSRng\n          CryptAcquireContext(phProv, NULL, NULL, PROV_RSA_FULL,\n                              CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n "}, {"sha": "dbd1edffe7827ce09960d51bd631814574ad70e7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -90,7 +90,7 @@ fn vec_plus() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all_move(rv);\n         } else {\n@@ -106,7 +106,7 @@ fn vec_append() {\n     let mut v = ~[];\n     let mut i = 0;\n     while i < 1500 {\n-        let rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v = vec::append(v, rv);\n         }\n@@ -122,7 +122,7 @@ fn vec_push_all() {\n \n     let mut v = ~[];\n     for i in range(0u, 1500) {\n-        let mut rv = vec::from_elem(r.gen_integer_range(0u, i + 1), i);\n+        let mut rv = vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n             v.push_all(rv);\n         }"}, {"sha": "9f88ba72f059aff0fd5c1554f11f59946d3c1005", "filename": "src/test/compile-fail/issue-5216.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() { }\n+struct S(&fn()); //~ ERROR Illegal anonymous lifetime\n+pub static C: S = S(f); //~ ERROR Illegal anonymous lifetime\n+\n+\n+fn g() { }\n+type T = &fn(); //~ ERROR Illegal anonymous lifetime\n+pub static D: T = g; //~ ERROR Illegal anonymous lifetime\n+\n+fn main() {}"}, {"sha": "f709aadf4ac8e8d282008d1b2f2c9c40b244a3ce", "filename": "src/test/compile-fail/issue-5500-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+\n+struct TrieMapIterator<'self> {\n+    priv node: &'self uint\n+}\n+\n+fn main() {\n+    let a = 5;\n+    let _iter = TrieMapIterator{node: &a};  //~ ERROR bad\n+    _iter.node = &\n+    fail!()\n+}"}, {"sha": "7bf20037f5abdbfdb356ed80d311350c7bccff54", "filename": "src/test/compile-fail/issue-5500.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fcompile-fail%2Fissue-5500.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Fcompile-fail%2Fissue-5500.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5500.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+\n+fn main() { &fail!() } //~ ERROR bad"}, {"sha": "aa88004cd11994a6a82ed20887f8d09484b9d0af", "filename": "src/test/run-pass/by-value-self-in-mut-slot.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Fby-value-self-in-mut-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Fby-value-self-in-mut-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fby-value-self-in-mut-slot.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct X {\n+    a: int\n+}\n+\n+trait Changer {\n+    fn change(mut self) -> Self;\n+}\n+\n+impl Changer for X {\n+    fn change(mut self) -> X {\n+        self.a = 55;\n+        self\n+    }\n+}\n+\n+pub fn main() {\n+    let x = X { a: 32 };\n+    let new_x = x.change();\n+    assert_eq!(new_x.a, 55);\n+}"}, {"sha": "740a2212726d6705a44868cbe112404eaf544b44", "filename": "src/test/run-pass/issue-6334.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Fissue-6334.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Fissue-6334.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6334.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+\n+// Tests that everything still compiles and runs fine even when\n+// we reorder the bounds.\n+\n+trait A {\n+    fn a(&self) -> uint;\n+}\n+\n+trait B {\n+    fn b(&self) -> uint;\n+}\n+\n+trait C {\n+    fn combine<T:A+B>(&self, t: &T) -> uint;\n+}\n+\n+struct Foo;\n+\n+impl A for Foo {\n+    fn a(&self) -> uint { 1 }\n+}\n+\n+impl B for Foo {\n+    fn b(&self) -> uint { 2 }\n+}\n+\n+struct Bar;\n+\n+impl C for Bar {\n+    // Note below: bounds in impl decl are in reverse order.\n+    fn combine<T:B+A>(&self, t: &T) -> uint {\n+        (t.a() * 100) + t.b()\n+    }\n+}\n+\n+fn use_c<S:C, T:B+A>(s: &S, t: &T) -> uint {\n+    s.combine(t)\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+    let bar = Bar;\n+    let r = use_c(&bar, &foo);\n+    assert_eq!(r, 102);\n+}"}, {"sha": "08d10fd11703b062b3637524042c7b2eca1d316d", "filename": "src/test/run-pass/self-in-mut-slot-default-method.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-default-method.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct X {\n+    a: int\n+}\n+\n+trait Changer {\n+    fn change(mut self) -> Self {\n+        self.set_to(55);\n+        self\n+    }\n+\n+    fn change_again(mut ~self) -> ~Self {\n+        self.set_to(45);\n+        self\n+    }\n+\n+    fn set_to(&mut self, a: int);\n+}\n+\n+impl Changer for X {\n+    fn set_to(&mut self, a: int) {\n+        self.a = a;\n+    }\n+}\n+\n+pub fn main() {\n+    let x = X { a: 32 };\n+    let new_x = x.change();\n+    assert_eq!(new_x.a, 55);\n+\n+    let x = ~new_x;\n+    let new_x = x.change_again();\n+    assert_eq!(new_x.a, 45);\n+}"}, {"sha": "7c2f52211761f1c3de9bf3e6b1ef3559c2fc06c8", "filename": "src/test/run-pass/uniq-self-in-mut-slot.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d69837bd263f334aa9dea4235698c006f7b1ce8/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-self-in-mut-slot.rs?ref=7d69837bd263f334aa9dea4235698c006f7b1ce8", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct X {\n+    a: int\n+}\n+\n+trait Changer {\n+    fn change(mut ~self) -> ~Self;\n+}\n+\n+impl Changer for X {\n+    fn change(mut ~self) -> ~X {\n+        self.a = 55;\n+        self\n+    }\n+}\n+\n+pub fn main() {\n+    let x = ~X { a: 32 };\n+    let new_x = x.change();\n+    assert_eq!(new_x.a, 55);\n+}"}]}