{"sha": "8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMjdiNWFmYWZkZTdjZGQ2ZmQ0ZTkzOWQ5YThmZTEyZjc2NTAzZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-18T07:59:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-18T07:59:32Z"}, "message": "Auto merge of #37429 - camlorn:univariant_layout_optimization, r=eddyb\n\nstruct field reordering and optimization\n\nThis is work in progress.  The goal is to divorce the order of fields in source code from the order of fields in the LLVM IR, then optimize structs (and tuples/enum variants)by always ordering fields from least to most aligned.  It does not work yet.  I intend to check compiler memory usage as a benchmark, and a crater run will probably be required.\n\nI don't know enough of the compiler to complete this work unaided.  If you see places that still need updating, please mention them.  The only one I know of currently is debuginfo, which I'm putting off intentionally until a bit later.\n\nr? @eddyb", "tree": {"sha": "950ad46079b3258847e8452903faff3d9d715a93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/950ad46079b3258847e8452903faff3d9d715a93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "html_url": "https://github.com/rust-lang/rust/commit/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54e72317998cfe1df90256ad0669dd193cf2f66", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54e72317998cfe1df90256ad0669dd193cf2f66", "html_url": "https://github.com/rust-lang/rust/commit/d54e72317998cfe1df90256ad0669dd193cf2f66"}, {"sha": "ff59474ed356d69d75447af79278bdd28db16710", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff59474ed356d69d75447af79278bdd28db16710", "html_url": "https://github.com/rust-lang/rust/commit/ff59474ed356d69d75447af79278bdd28db16710"}], "stats": {"total": 770, "additions": 538, "deletions": 232}, "files": [{"sha": "a042b2abf3a298a3179f45df69a3b8f910ece145", "filename": "src/librustc/session/code_stats.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -142,7 +142,12 @@ impl CodeStats {\n                 max_variant_size = cmp::max(max_variant_size, size);\n \n                 let mut min_offset = discr_size;\n-                for field in fields {\n+\n+                // We want to print fields by increasing offset.\n+                let mut fields = fields.clone();\n+                fields.sort_by_key(|f| f.offset);\n+\n+                for field in fields.iter() {\n                     let FieldInfo { ref name, offset, size, align } = *field;\n \n                     // Include field alignment in output only if it caused padding injection"}, {"sha": "53ed103ad914106c27847f2277b867c7d2bb91c8", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 306, "deletions": 124, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -24,6 +24,7 @@ use syntax_pos::DUMMY_SP;\n use std::cmp;\n use std::fmt;\n use std::i64;\n+use std::iter;\n \n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n@@ -415,7 +416,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: TyCtxt, ty: Ty, hint: attr::ReprAttr, min: i64, max: i64)\n+    fn repr_discr(tcx: TyCtxt, ty: Ty, hints: &[attr::ReprAttr], min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -424,34 +425,41 @@ impl Integer {\n         let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u64, max as u64));\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n-        let at_least = match hint {\n-            attr::ReprInt(ity) => {\n-                let discr = Integer::from_attr(&tcx.data_layout, ity);\n-                let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n-                if discr < fit {\n-                    bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n-                          discriminant range of enum `{}\", ty)\n+        let mut min_from_extern = None;\n+        let min_default = I8;\n+\n+        for &r in hints.iter() {\n+            match r {\n+                attr::ReprInt(ity) => {\n+                    let discr = Integer::from_attr(&tcx.data_layout, ity);\n+                    let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+                    if discr < fit {\n+                        bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                              discriminant range of enum `{}\", ty)\n+                    }\n+                    return (discr, ity.is_signed());\n                 }\n-                return (discr, ity.is_signed());\n-            }\n-            attr::ReprExtern => {\n-                match &tcx.sess.target.target.arch[..] {\n-                    // WARNING: the ARM EABI has two variants; the one corresponding\n-                    // to `at_least == I32` appears to be used on Linux and NetBSD,\n-                    // but some systems may use the variant corresponding to no\n-                    // lower bound.  However, we don't run on those yet...?\n-                    \"arm\" => I32,\n-                    _ => I32,\n+                attr::ReprExtern => {\n+                    match &tcx.sess.target.target.arch[..] {\n+                        // WARNING: the ARM EABI has two variants; the one corresponding\n+                        // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                        // but some systems may use the variant corresponding to no\n+                        // lower bound.  However, we don't run on those yet...?\n+                        \"arm\" => min_from_extern = Some(I32),\n+                        _ => min_from_extern = Some(I32),\n+                    }\n+                }\n+                attr::ReprAny => {},\n+                attr::ReprPacked => {\n+                    bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n+                }\n+                attr::ReprSimd => {\n+                    bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n                 }\n             }\n-            attr::ReprAny => I8,\n-            attr::ReprPacked => {\n-                bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n-            }\n-            attr::ReprSimd => {\n-                bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n-            }\n-        };\n+        }\n+\n+        let at_least = min_from_extern.unwrap_or(min_default);\n \n         // If there are no negative values, we can use the unsigned fit.\n         if min >= 0 {\n@@ -511,70 +519,158 @@ pub struct Struct {\n     /// If true, the size is exact, otherwise it's only a lower bound.\n     pub sized: bool,\n \n-    /// Offsets for the first byte of each field.\n+    /// Offsets for the first byte of each field, ordered to match the source definition order.\n+    /// This vector does not go in increasing order.\n     /// FIXME(eddyb) use small vector optimization for the common case.\n     pub offsets: Vec<Size>,\n \n+    /// Maps source order field indices to memory order indices, depending how fields were permuted.\n+    /// FIXME (camlorn) also consider small vector  optimization here.\n+    pub memory_index: Vec<u32>,\n+\n     pub min_size: Size,\n }\n \n+// Info required to optimize struct layout.\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n+enum StructKind {\n+    // A tuple, closure, or univariant which cannot be coerced to unsized.\n+    AlwaysSizedUnivariant,\n+    // A univariant, the last field of which may be coerced to unsized.\n+    MaybeUnsizedUnivariant,\n+    // A univariant, but part of an enum.\n+    EnumVariant,\n+}\n+\n impl<'a, 'gcx, 'tcx> Struct {\n-    pub fn new(dl: &TargetDataLayout, packed: bool) -> Struct {\n-        Struct {\n+    // FIXME(camlorn): reprs need a better representation to deal with multiple reprs on one type.\n+    fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n+                  reprs: &[attr::ReprAttr], kind: StructKind,\n+                  scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n+        let packed = reprs.contains(&attr::ReprPacked);\n+        let mut ret = Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n             sized: true,\n             offsets: vec![],\n+            memory_index: vec![],\n             min_size: Size::from_bytes(0),\n+        };\n+\n+        // Anything with ReprExtern or ReprPacked doesn't optimize.\n+        // Neither do  1-member and 2-member structs.\n+        // In addition, code in trans assume that 2-element structs can become pairs.\n+        // It's easier to just short-circuit here.\n+        let mut can_optimize = fields.len() > 2 || StructKind::EnumVariant == kind;\n+        if can_optimize {\n+            // This exhaustive match makes new reprs force the adder to modify this function.\n+            // Otherwise, things can silently break.\n+            // Note the inversion, return true to stop optimizing.\n+            can_optimize = !reprs.iter().any(|r| {\n+                match *r {\n+                    attr::ReprAny | attr::ReprInt(_) => false,\n+                    attr::ReprExtern | attr::ReprPacked => true,\n+                    attr::ReprSimd => bug!(\"Simd  vectors should be represented as layout::Vector\")\n+                }\n+            });\n         }\n-    }\n \n-    /// Extend the Struct with more fields.\n-    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n-                     fields: I,\n-                     scapegoat: Ty<'gcx>)\n-                     -> Result<(), LayoutError<'gcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n-        self.offsets.reserve(fields.size_hint().0);\n+        let (optimize, sort_ascending) = match kind {\n+            StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n+            StructKind::MaybeUnsizedUnivariant => (can_optimize, false),\n+            StructKind::EnumVariant => {\n+                assert!(fields.len() >= 1, \"Enum variants must have discriminants.\");\n+                (can_optimize && fields[0].size(dl).bytes() == 1, true)\n+            }\n+        };\n \n-        let mut offset = self.min_size;\n+        ret.offsets = vec![Size::from_bytes(0); fields.len()];\n+        let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n-        for field in fields {\n-            if !self.sized {\n-                bug!(\"Struct::extend: field #{} of `{}` comes after unsized field\",\n-                     self.offsets.len(), scapegoat);\n+        if optimize {\n+            let start = if let StructKind::EnumVariant = kind { 1 } else { 0 };\n+            let end = if let StructKind::MaybeUnsizedUnivariant = kind {\n+                fields.len() - 1\n+            } else {\n+                fields.len()\n+            };\n+            if end > start {\n+                let optimizing  = &mut inverse_memory_index[start..end];\n+                if sort_ascending {\n+                    optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n+                } else {\n+                    optimizing.sort_by(| &a, &b | {\n+                        let a = fields[a as usize].align(dl).abi();\n+                        let b = fields[b as usize].align(dl).abi();\n+                        b.cmp(&a)\n+                    });\n+                }\n+            }\n+        }\n+\n+        // inverse_memory_index holds field indices by increasing memory offset.\n+        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+        // We now write field offsets to the corresponding offset slot;\n+        // field 5 with offset 0 puts 0 in offsets[5].\n+        // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n+\n+        if let StructKind::EnumVariant = kind {\n+            assert_eq!(inverse_memory_index[0], 0,\n+              \"Enum variant discriminants must have the lowest offset.\");\n+        }\n+\n+        let mut offset = Size::from_bytes(0);\n+\n+        for i in inverse_memory_index.iter() {\n+            let field = fields[*i as usize];\n+            if !ret.sized {\n+                bug!(\"Struct::new: field #{} of `{}` comes after unsized field\",\n+                     ret.offsets.len(), scapegoat);\n             }\n \n-            let field = field?;\n             if field.is_unsized() {\n-                self.sized = false;\n+                ret.sized = false;\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            if !self.packed {\n+            if !ret.packed {\n                 let align = field.align(dl);\n-                self.align = self.align.max(align);\n+                ret.align = ret.align.max(align);\n                 offset = offset.abi_align(align);\n             }\n \n-            self.offsets.push(offset);\n-\n-            debug!(\"Struct::extend offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n+            debug!(\"Struct::new offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n+            ret.offsets[*i as usize] = offset;\n \n             offset = offset.checked_add(field.size(dl), dl)\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n-        debug!(\"Struct::extend min_size: {:?}\", offset);\n \n-        self.min_size = offset;\n+        debug!(\"Struct::new min_size: {:?}\", offset);\n+        ret.min_size = offset;\n \n-        Ok(())\n-    }\n+        // As stated above, inverse_memory_index holds field indices by increasing offset.\n+        // This makes it an already-sorted view of the offsets vec.\n+        // To invert it, consider:\n+        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+        // Field 5 would be the first element, so memory_index is i:\n+        // Note: if we didn't optimize, it's already right.\n \n-    /// Get the size without trailing alignment padding.\n+        if optimize {\n+            ret.memory_index = vec![0; inverse_memory_index.len()];\n \n-    /// Get the size with trailing aligment padding.\n+            for i in 0..inverse_memory_index.len() {\n+                ret.memory_index[inverse_memory_index[i] as usize]  = i as u32;\n+            }\n+        } else {\n+            ret.memory_index = inverse_memory_index;\n+        }\n+\n+        Ok(ret)\n+    }\n+\n+    /// Get the size with trailing alignment padding.\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n@@ -592,18 +688,45 @@ impl<'a, 'gcx, 'tcx> Struct {\n         Ok(true)\n     }\n \n+    /// Get indices of the tys that made this struct by increasing offset.\n+    #[inline]\n+    pub fn field_index_by_increasing_offset<'b>(&'b self) -> impl iter::Iterator<Item=usize>+'b {\n+        let mut inverse_small = [0u8; 64];\n+        let mut inverse_big = vec![];\n+        let use_small = self.memory_index.len() <= inverse_small.len();\n+\n+        // We have to write this logic twice in order to keep the array small.\n+        if use_small {\n+            for i in 0..self.memory_index.len() {\n+                inverse_small[self.memory_index[i] as usize] = i as u8;\n+            }\n+        } else {\n+            inverse_big = vec![0; self.memory_index.len()];\n+            for i in 0..self.memory_index.len() {\n+                inverse_big[self.memory_index[i] as usize] = i as u32;\n+            }\n+        }\n+\n+        (0..self.memory_index.len()).map(move |i| {\n+            if use_small { inverse_small[i] as usize }\n+            else { inverse_big[i] as usize }\n+        })\n+    }\n+\n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given type and recursing through aggregates.\n+    /// The tuple is `(path, source_path)`,\n+    /// where `path` is in memory order and `source_path` in source order.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    pub fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  ty: Ty<'gcx>)\n-                                  -> Result<Option<FieldPath>, LayoutError<'gcx>> {\n+    fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                               ty: Ty<'gcx>)\n+                               -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>> {\n         let tcx = infcx.tcx.global_tcx();\n         match (ty.layout(infcx)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) |\n-            (&CEnum { non_zero: true, .. }, _) => Ok(Some(vec![])),\n+            (&CEnum { non_zero: true, .. }, _) => Ok(Some((vec![], vec![]))),\n             (&FatPointer { non_zero: true, .. }, _) => {\n-                Ok(Some(vec![FAT_PTR_ADDR as u32]))\n+                Ok(Some((vec![FAT_PTR_ADDR as u32], vec![FAT_PTR_ADDR as u32])))\n             }\n \n             // Is this the NonZero lang item wrapping a pointer or integer type?\n@@ -614,38 +737,42 @@ impl<'a, 'gcx, 'tcx> Struct {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: Int(_), non_zero: false } |\n                     Scalar { value: Pointer, non_zero: false } => {\n-                        Ok(Some(vec![0]))\n+                        Ok(Some((vec![0], vec![0])))\n                     }\n                     FatPointer { non_zero: false, .. } => {\n-                        Ok(Some(vec![FAT_PTR_ADDR as u32, 0]))\n+                        let tmp = vec![FAT_PTR_ADDR as u32, 0];\n+                        Ok(Some((tmp.clone(), tmp)))\n                     }\n                     _ => Ok(None)\n                 }\n             }\n \n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n-            (_, &ty::TyAdt(def, substs)) if def.is_struct() => {\n-                Struct::non_zero_field_path(infcx, def.struct_variant().fields\n+            (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n+                Struct::non_zero_field_paths(infcx, def.struct_variant().fields\n                                                       .iter().map(|field| {\n                     field.ty(tcx, substs)\n-                }))\n+                }),\n+                Some(&variant.memory_index[..]))\n             }\n \n             // Perhaps one of the upvars of this closure is non-zero\n-            // Let's recurse and find out!\n-            (_, &ty::TyClosure(def_id, ref substs)) => {\n-                Struct::non_zero_field_path(infcx, substs.upvar_tys(def_id, tcx))\n+            (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n+                let upvar_tys = substs.upvar_tys(def, tcx);\n+                Struct::non_zero_field_paths(infcx, upvar_tys,\n+                    Some(&variant.memory_index[..]))\n             }\n             // Can we use one of the fields in this tuple?\n-            (_, &ty::TyTuple(tys)) => {\n-                Struct::non_zero_field_path(infcx, tys.iter().cloned())\n+            (&Univariant { ref variant, .. }, &ty::TyTuple(tys)) => {\n+                Struct::non_zero_field_paths(infcx, tys.iter().cloned(),\n+                    Some(&variant.memory_index[..]))\n             }\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n             (_, &ty::TyArray(ety, d)) if d > 0 => {\n-                Struct::non_zero_field_path(infcx, Some(ety).into_iter())\n+                Struct::non_zero_field_paths(infcx, Some(ety).into_iter(), None)\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n@@ -663,14 +790,23 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n-    pub fn non_zero_field_path<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  fields: I)\n-                                  -> Result<Option<FieldPath>, LayoutError<'gcx>>\n+    /// Returns Some((path, source_path)) on success.\n+    /// `path` is translated to memory order. `source_path` is not.\n+    fn non_zero_field_paths<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                  fields: I,\n+                                  permutation: Option<&[u32]>)\n+                                  -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>>\n     where I: Iterator<Item=Ty<'gcx>> {\n         for (i, ty) in fields.enumerate() {\n-            if let Some(mut path) = Struct::non_zero_field_in_type(infcx, ty)? {\n-                path.push(i as u32);\n-                return Ok(Some(path));\n+            if let Some((mut path, mut source_path)) = Struct::non_zero_field_in_type(infcx, ty)? {\n+                source_path.push(i as u32);\n+                let index = if let Some(p) = permutation {\n+                    p[i] as usize\n+                } else {\n+                    i\n+                };\n+                path.push(index as u32);\n+                return Ok(Some((path, source_path)));\n             }\n         }\n         Ok(None)\n@@ -723,7 +859,7 @@ impl<'a, 'gcx, 'tcx> Union {\n         Ok(())\n     }\n \n-    /// Get the size with trailing aligment padding.\n+    /// Get the size with trailing alignment padding.\n     pub fn stride(&self) -> Size {\n         self.min_size.abi_align(self.align)\n     }\n@@ -833,7 +969,9 @@ pub enum Layout {\n         nndiscr: u64,\n         nonnull: Struct,\n         // N.B. There is a 0 at the start, for LLVM GEP through a pointer.\n-        discrfield: FieldPath\n+        discrfield: FieldPath,\n+        // Like discrfield, but in source order. For debuginfo.\n+        discrfield_source: FieldPath\n     }\n }\n \n@@ -887,6 +1025,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n+\n         let layout = match ty.sty {\n             // Basic scalars.\n             ty::TyBool => Scalar { value: Int(I1), non_zero: false },\n@@ -908,7 +1047,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFnPtr(_) => Scalar { value: Pointer, non_zero: true },\n \n             // The never type.\n-            ty::TyNever => Univariant { variant: Struct::new(dl, false), non_zero: false },\n+            ty::TyNever => Univariant {\n+                variant: Struct::new(dl, &vec![], &[],\n+                  StructKind::AlwaysSizedUnivariant, ty)?,\n+                non_zero: false\n+            },\n \n             // Potentially-fat pointers.\n             ty::TyBox(pointee) |\n@@ -959,27 +1102,36 @@ impl<'a, 'gcx, 'tcx> Layout {\n             // Odd unit types.\n             ty::TyFnDef(..) => {\n                 Univariant {\n-                    variant: Struct::new(dl, false),\n+                    variant: Struct::new(dl, &vec![],\n+                      &[], StructKind::AlwaysSizedUnivariant, ty)?,\n                     non_zero: false\n                 }\n             }\n             ty::TyDynamic(..) => {\n-                let mut unit = Struct::new(dl, false);\n+                let mut unit = Struct::new(dl, &vec![], &[],\n+                  StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }\n             }\n \n             // Tuples and closures.\n             ty::TyClosure(def_id, ref substs) => {\n-                let mut st = Struct::new(dl, false);\n                 let tys = substs.upvar_tys(def_id, tcx);\n-                st.extend(dl, tys.map(|ty| ty.layout(infcx)), ty)?;\n+                let st = Struct::new(dl,\n+                    &tys.map(|ty| ty.layout(infcx))\n+                      .collect::<Result<Vec<_>, _>>()?,\n+                    &[],\n+                    StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n             ty::TyTuple(tys) => {\n-                let mut st = Struct::new(dl, false);\n-                st.extend(dl, tys.iter().map(|ty| ty.layout(infcx)), ty)?;\n+                // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n+                // See the univariant case below to learn how.\n+                let st = Struct::new(dl,\n+                    &tys.iter().map(|ty| ty.layout(infcx))\n+                      .collect::<Result<Vec<_>, _>>()?,\n+                    &[], StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n@@ -1003,16 +1155,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                let hint = *tcx.lookup_repr_hints(def.did).get(0)\n-                    .unwrap_or(&attr::ReprAny);\n+                let hints = &tcx.lookup_repr_hints(def.did)[..];\n \n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hint, attr::ReprAny);\n+                    assert_eq!(hints.len(), 0);\n \n                     return success(Univariant {\n-                        variant: Struct::new(dl, false),\n+                        variant: Struct::new(dl, &vec![],\n+                          &hints[..], StructKind::AlwaysSizedUnivariant, ty)?,\n                         non_zero: false\n                     });\n                 }\n@@ -1027,7 +1179,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, hint, min, max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..], min, max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1037,21 +1189,35 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n-                if !def.is_enum() || def.variants.len() == 1 && hint == attr::ReprAny {\n+                if !def.is_enum() || def.variants.len() == 1 && hints.is_empty() {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n+                    let kind = if def.is_enum() || def.variants[0].fields.len() == 0{\n+                        StructKind::AlwaysSizedUnivariant\n+                    } else {\n+                        use middle::region::ROOT_CODE_EXTENT;\n+                        let param_env = tcx.construct_parameter_environment(DUMMY_SP,\n+                          def.did, ROOT_CODE_EXTENT);\n+                        let fields = &def.variants[0].fields;\n+                        let last_field = &fields[fields.len()-1];\n+                        let always_sized = last_field.ty(tcx, param_env.free_substs)\n+                          .is_sized(tcx, &param_env, DUMMY_SP);\n+                        if !always_sized { StructKind::MaybeUnsizedUnivariant }\n+                        else { StructKind::AlwaysSizedUnivariant }\n+                    };\n+\n                     let fields = def.variants[0].fields.iter().map(|field| {\n                         field.ty(tcx, substs).layout(infcx)\n-                    });\n+                    }).collect::<Result<Vec<_>, _>>()?;\n                     let packed = tcx.lookup_packed(def.did);\n                     let layout = if def.is_union() {\n                         let mut un = Union::new(dl, packed);\n-                        un.extend(dl, fields, ty)?;\n+                        un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n-                        let mut st = Struct::new(dl, packed);\n-                        st.extend(dl, fields, ty)?;\n+                        let st = Struct::new(dl, &fields, &hints[..],\n+                          kind, ty)?;\n                         let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n                     };\n@@ -1073,7 +1239,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if variants.len() == 2 && hint == attr::ReprAny {\n+                if variants.len() == 2 && hints.is_empty() {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1082,9 +1248,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if !Struct::would_be_zero_sized(dl, other_fields)? {\n                             continue;\n                         }\n-                        let path = Struct::non_zero_field_path(infcx,\n-                            variants[discr].iter().cloned())?;\n-                        let mut path = if let Some(p) = path { p } else { continue };\n+                        let paths = Struct::non_zero_field_paths(infcx,\n+                            variants[discr].iter().cloned(),\n+                            None)?;\n+                        let (mut path, mut path_source) = if let Some(p) = paths { p }\n+                          else { continue };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if path == &[0] && variants[discr].len() == 1 {\n@@ -1101,22 +1269,33 @@ impl<'a, 'gcx, 'tcx> Layout {\n                             });\n                         }\n \n+                        let st = Struct::new(dl,\n+                            &variants[discr].iter().map(|ty| ty.layout(infcx))\n+                              .collect::<Result<Vec<_>, _>>()?,\n+                            &hints[..], StructKind::AlwaysSizedUnivariant, ty)?;\n+\n+                        // We have to fix the last element of path here.\n+                        let mut i = *path.last().unwrap();\n+                        i = st.memory_index[i as usize];\n+                        *path.last_mut().unwrap() = i;\n                         path.push(0); // For GEP through a pointer.\n                         path.reverse();\n-                        let mut st = Struct::new(dl, false);\n-                        st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n+                        path_source.push(0);\n+                        path_source.reverse();\n+\n                         return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n-                            discrfield: path\n+                            discrfield: path,\n+                            discrfield_source: path_source\n                         });\n                     }\n                 }\n \n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, hint, 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n@@ -1126,24 +1305,26 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                 // Create the set of structs that represent each variant\n                 // Use the minimum integer type we figured out above\n-                let discr = Some(Scalar { value: Int(min_ity), non_zero: false });\n+                let discr = Scalar { value: Int(min_ity), non_zero: false };\n                 let mut variants = variants.into_iter().map(|fields| {\n-                    let mut found_start = false;\n-                    let fields = fields.into_iter().map(|field| {\n-                        let field = field.layout(infcx)?;\n-                        if !found_start {\n-                            // Find the first field we can't move later\n-                            // to make room for a larger discriminant.\n-                            let field_align = field.align(dl);\n-                            if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n-                                start_align = start_align.min(field_align);\n-                                found_start = true;\n-                            }\n+                    let mut fields = fields.into_iter().map(|field| {\n+                        field.layout(infcx)\n+                    }).collect::<Result<Vec<_>, _>>()?;\n+                    fields.insert(0, &discr);\n+                    let st = Struct::new(dl,\n+                        &fields,\n+                        &hints[..], StructKind::EnumVariant, ty)?;\n+                    // Find the first field we can't move later\n+                    // to make room for a larger discriminant.\n+                    // It is important to skip the first field.\n+                    for i in st.field_index_by_increasing_offset().skip(1) {\n+                        let field = fields[i];\n+                        let field_align = field.align(dl);\n+                        if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n+                            start_align = start_align.min(field_align);\n+                            break;\n                         }\n-                        Ok(field)\n-                    });\n-                    let mut st = Struct::new(dl, false);\n-                    st.extend(dl, discr.iter().map(Ok).chain(fields), ty)?;\n+                    }\n                     size = cmp::max(size, st.min_size);\n                     align = align.max(st.align);\n                     Ok(st)\n@@ -1177,11 +1358,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let old_ity_size = Int(min_ity).size(dl);\n                     let new_ity_size = Int(ity).size(dl);\n                     for variant in &mut variants {\n-                        for offset in &mut variant.offsets[1..] {\n-                            if *offset > old_ity_size {\n-                                break;\n+                        for i in variant.offsets.iter_mut() {\n+                            // The first field is the discrimminant, at offset 0.\n+                            // These aren't in order, and we need to skip it.\n+                            if *i <= old_ity_size && *i > Size::from_bytes(0) {\n+                                *i = new_ity_size;\n                             }\n-                            *offset = new_ity_size;\n                         }\n                         // We might be making the struct larger.\n                         if variant.min_size <= old_ity_size {"}, {"sha": "33d71ba86264388ed9e329b41620448d1aa06a8a", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -31,6 +31,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_type: libc::c_short,\n             pub l_whence: libc::c_short,\n@@ -53,6 +54,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_start: libc::off_t,\n             pub l_len: libc::off_t,\n@@ -76,6 +78,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_start: libc::off_t,\n             pub l_len: libc::off_t,\n@@ -98,6 +101,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_type: libc::c_short,\n             pub l_whence: libc::c_short,\n@@ -119,6 +123,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_start: libc::off_t,\n             pub l_len: libc::off_t,\n@@ -141,6 +146,7 @@ mod imp {\n     mod os {\n         use libc;\n \n+        #[repr(C)]\n         pub struct flock {\n             pub l_type: libc::c_short,\n             pub l_whence: libc::c_short,"}, {"sha": "751c9c3440f66326a06454204416c9cf237f388f", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -750,7 +750,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n                     let discr_size = Primitive::Int(discr).size(&cx.tcx.data_layout).bytes();\n \n-                    debug!(\"enum `{}` is {} bytes large\", t, size.bytes());\n+                    debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n+                      t, size.bytes(), layout);\n \n                     let (largest, slargest, largest_index) = enum_definition.variants\n                         .iter()"}, {"sha": "9c82e2507737116939a63bdab2ae85ea534349c9", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -151,14 +151,14 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         | layout::UntaggedUnion { .. } | layout::RawNullablePointer { .. } => { }\n         layout::Univariant { ..}\n         | layout::StructWrappedNullablePointer { .. } => {\n-            let (nonnull_variant, packed) = match *l {\n-                layout::Univariant { ref variant, .. } => (0, variant.packed),\n+            let (nonnull_variant_index, nonnull_variant, packed) = match *l {\n+                layout::Univariant { ref variant, .. } => (0, variant, variant.packed),\n                 layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } =>\n-                    (nndiscr, nonnull.packed),\n+                    (nndiscr, nonnull, nonnull.packed),\n                 _ => unreachable!()\n             };\n-            let fields = compute_fields(cx, t, nonnull_variant as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, false, false),\n+            let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n+            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant, false, false),\n                                  packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n@@ -188,7 +188,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, sizing, dst),\n+                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull, sizing, dst),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n@@ -203,7 +203,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, &fields, sizing, dst);\n+                    let fields = struct_llfields(cx, &fields, &variant, sizing, dst);\n                     Type::struct_(cx, &fields, variant.packed)\n                 }\n                 Some(name) => {\n@@ -291,12 +291,14 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n \n \n fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n+                             variant: &layout::Struct,\n                              sizing: bool, dst: bool) -> Vec<Type> {\n+    let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n     if sizing {\n-        fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n-            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n+        fields.filter(|ty| !dst || type_is_sized(cx.tcx(), *ty))\n+            .map(|ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        fields.iter().map(|&ty| type_of::in_memory_type_of(cx, ty)).collect()\n+        fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n     }\n }\n \n@@ -564,16 +566,16 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                                 st: &layout::Struct, fields: &Vec<Ty<'tcx>>, val: MaybeSizedValue,\n                                 ix: usize, needs_cast: bool) -> ValueRef {\n-    let ccx = bcx.ccx();\n     let fty = fields[ix];\n+    let ccx = bcx.ccx();\n     let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n     if bcx.is_unreachable() {\n         return C_undef(ll_fty.ptr_to());\n     }\n \n     let ptr_val = if needs_cast {\n-        let fields = fields.iter().map(|&ty| {\n-            type_of::in_memory_type_of(ccx, ty)\n+        let fields = st.field_index_by_increasing_offset().map(|i| {\n+            type_of::in_memory_type_of(ccx, fields[i])\n         }).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n         bcx.pointercast(val.value, real_ty.ptr_to())\n@@ -585,15 +587,15 @@ fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     //   * First field - Always aligned properly\n     //   * Packed struct - There is no alignment padding\n     //   * Field is sized - pointer is properly aligned already\n-    if ix == 0 || st.packed || type_is_sized(bcx.tcx(), fty) {\n-        return bcx.struct_gep(ptr_val, ix);\n+    if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed || type_is_sized(bcx.tcx(), fty) {\n+        return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n     }\n \n     // If the type of the last field is [T] or str, then we don't need to do\n     // any adjusments\n     match fty.sty {\n         ty::TySlice(..) | ty::TyStr => {\n-            return bcx.struct_gep(ptr_val, ix);\n+            return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n         }\n         _ => ()\n     }\n@@ -755,8 +757,12 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // offset of current value\n     let mut offset = 0;\n     let mut cfields = Vec::new();\n-    let offsets = st.offsets.iter().map(|i| i.bytes());\n-    for (&val, target_offset) in vals.iter().zip(offsets) {\n+    cfields.reserve(st.offsets.len()*2);\n+\n+    let parts = st.field_index_by_increasing_offset().map(|i| {\n+        (&vals[i], st.offsets[i].bytes())\n+    });\n+    for (&val, target_offset) in parts {\n         if offset < target_offset {\n             cfields.push(padding(ccx, target_offset - offset));\n             offset = target_offset;\n@@ -807,14 +813,11 @@ pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let l = ccx.layout_of(t);\n     match *l {\n         layout::CEnum { .. } => bug!(\"element access in C-like enum const\"),\n-        layout::Univariant { .. } | layout::Vector { .. } => const_struct_field(val, ix),\n+        layout::Univariant { ref variant, .. } => {\n+            const_struct_field(val, variant.memory_index[ix] as usize)\n+        }\n+        layout::Vector { .. } => const_struct_field(val, ix),\n         layout::UntaggedUnion { .. } => const_struct_field(val, 0),\n-        layout::General { .. } => const_struct_field(val, ix + 1),\n-        layout::RawNullablePointer { .. } => {\n-            assert_eq!(ix, 0);\n-            val\n-        },\n-        layout::StructWrappedNullablePointer{ .. } => const_struct_field(val, ix),\n         _ => bug!(\"{} does not have fields.\", t)\n     }\n }"}, {"sha": "c7f21427a0ceb656c5e6731acbc635dd25ba80cb", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -827,7 +827,9 @@ pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n         }\n     }\n     DebugLoc::None.apply(cx.fcx);\n-    Alloca(cx, ty, name)\n+    let result = Alloca(cx, ty, name);\n+    debug!(\"alloca({:?}) = {:?}\", name, result);\n+    result\n }\n \n impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n@@ -1868,7 +1870,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         match **layout {\n             Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n                                                    nndiscr,\n-                                                   discrfield: _ } => {\n+                                                   discrfield: _,\n+                                                   discrfield_source: _ } => {\n                 debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n                        ty, nndiscr, variant_layout);\n                 let variant_def = &adt_def.variants[nndiscr as usize];"}, {"sha": "511c9d3c13f91ad33a65bc47e733754a024962aa", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -870,25 +870,28 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n+    ty: Ty<'tcx>,\n     variant: &'tcx ty::VariantDef,\n     substs: &'tcx Substs<'tcx>,\n-    is_simd: bool,\n     span: Span,\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        let field_size = if self.is_simd {\n-            let fty = monomorphize::field_ty(cx.tcx(),\n-                                             self.substs,\n-                                             &self.variant.fields[0]);\n-            Some(machine::llsize_of_alloc(\n-                cx,\n-                type_of::type_of(cx, fty)\n-            ) as usize)\n-        } else {\n-            None\n+        let layout = cx.layout_of(self.ty);\n+\n+        let tmp;\n+        let offsets = match *layout {\n+            layout::Univariant { ref variant, .. } => &variant.offsets,\n+            layout::Vector { element, count } => {\n+                let element_size = element.size(&cx.tcx().data_layout).bytes();\n+                tmp = (0..count).\n+                  map(|i| layout::Size::from_bytes(i*element_size))\n+                  .collect::<Vec<layout::Size>>();\n+                &tmp\n+            }\n+            _ => bug!(\"{} is not a struct\", self.ty)\n         };\n \n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n@@ -899,11 +902,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             };\n             let fty = monomorphize::field_ty(cx.tcx(), self.substs, f);\n \n-            let offset = if self.is_simd {\n-                FixedMemberOffset { bytes: i * field_size.unwrap() }\n-            } else {\n-                ComputedMemberOffset\n-            };\n+            let offset = FixedMemberOffset { bytes: offsets[i].bytes() as usize};\n \n             MemberDescription {\n                 name: name,\n@@ -945,9 +944,9 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         struct_metadata_stub,\n         struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n+            ty: struct_type,\n             variant: variant,\n             substs: substs,\n-            is_simd: struct_type.is_simd(),\n             span: span,\n         })\n     )\n@@ -959,13 +958,21 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n // Creates MemberDescriptions for the fields of a tuple\n struct TupleMemberDescriptionFactory<'tcx> {\n+    ty: Ty<'tcx>,\n     component_types: Vec<Ty<'tcx>>,\n     span: Span,\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n+        let layout = cx.layout_of(self.ty);\n+        let offsets = if let layout::Univariant { ref variant, .. } = *layout {\n+            &variant.offsets\n+        } else {\n+            bug!(\"{} is not a tuple\", self.ty);\n+        };\n+\n         self.component_types\n             .iter()\n             .enumerate()\n@@ -974,7 +981,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n                 name: format!(\"__{}\", i),\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n-                offset: ComputedMemberOffset,\n+                offset: FixedMemberOffset { bytes: offsets[i].bytes() as usize },\n                 flags: DIFlags::FlagZero,\n             }\n         }).collect()\n@@ -1001,6 +1008,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                            NO_SCOPE_METADATA),\n         tuple_llvm_type,\n         TupleMDF(TupleMemberDescriptionFactory {\n+            ty: tuple_type,\n             component_types: component_types.to_vec(),\n             span: span,\n         })\n@@ -1239,7 +1247,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             },\n             layout::StructWrappedNullablePointer { nonnull: ref struct_def,\n                                                 nndiscr,\n-                                                ref discrfield, ..} => {\n+                                                ref discrfield_source, ..} => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n@@ -1262,12 +1270,12 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as usize;\n                 let null_variant_name = adt.variants[null_variant_index].name;\n-                let discrfield = discrfield.iter()\n+                let discrfield_source = discrfield_source.iter()\n                                            .skip(1)\n                                            .map(|x| x.to_string())\n                                            .collect::<Vec<_>>().join(\"$\");\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n-                                                discrfield,\n+                                                discrfield_source,\n                                                 null_variant_name);\n \n                 // Create the (singleton) list of descriptions of union members.\n@@ -1289,6 +1297,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory<'tcx> {\n+    // Cloned from the layout::Struct describing the variant.\n+    offsets: &'tcx [layout::Size],\n     args: Vec<(String, Ty<'tcx>)>,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n@@ -1305,7 +1315,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n                     Some(metadata) if i == 0 => metadata,\n                     _ => type_metadata(cx, ty, self.span)\n                 },\n-                offset: ComputedMemberOffset,\n+                offset: FixedMemberOffset { bytes: self.offsets[i].bytes() as usize },\n                 flags: DIFlags::FlagZero\n             }\n         }).collect()\n@@ -1325,7 +1335,7 @@ enum EnumDiscriminantInfo {\n // full RecursiveTypeDescription.\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n-                                   struct_def: &layout::Struct,\n+                                   struct_def: &'tcx layout::Struct,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n@@ -1409,6 +1419,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_description_factory =\n         VariantMDF(VariantMemberDescriptionFactory {\n+            offsets: &struct_def.offsets[..],\n             args: args,\n             discriminant_type_metadata: match discriminant_info {\n                 RegularDiscriminant(discriminant_type_metadata) => {"}, {"sha": "fe087bc495121c3d7460cf5a26c6c5690c67123e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n-use rustc::ty;\n+use rustc::ty::{self, layout};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n@@ -722,8 +722,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             }\n             Immediate(llval) => {\n+                let l = bcx.ccx().layout_of(tuple.ty);\n+                let v = if let layout::Univariant { ref variant, .. } = *l {\n+                    variant\n+                } else {\n+                    bug!(\"Not a tuple.\");\n+                };\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(llval, n);\n+                    let mut elem = bcx.extract_value(llval, v.memory_index[n] as usize);\n                     // Truncate bools to i1, if needed\n                     if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx()) {\n                         elem = bcx.trunc(elem, Type::i1(bcx.ccx()));"}, {"sha": "83e1d03c689abda4ebfd9b438fe4ee47a60f2fa9", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -246,7 +246,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>)\n     {\n-        debug!(\"store_operand: operand={:?}\", operand);\n+        debug!(\"store_operand: operand={:?} lldest={:?}\", operand, lldest);\n         bcx.with_block(|bcx| self.store_operand_direct(bcx, lldest, operand))\n     }\n "}, {"sha": "2ee49db477864d02abeea9964b67e53ba10b30bd", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -133,13 +133,25 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     },\n                     _ => {\n+                        // If this is a tuple or closure, we need to translate GEP indices.\n+                        let layout = bcx.ccx().layout_of(dest.ty.to_ty(bcx.tcx()));\n+                        let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n+                            Some(&variant.memory_index)\n+                        } else {\n+                            None\n+                        };\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 // Note: perhaps this should be StructGep, but\n                                 // note that in some cases the values here will\n                                 // not be structs but arrays.\n+                                let i = if let Some(ref t) = translation {\n+                                    t[i] as usize\n+                                } else {\n+                                    i\n+                                };\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, op);\n                             }"}, {"sha": "f34fc3b20d2beed8034cd7c2b13246f6c4a7c45c", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -18,11 +18,11 @@\n // gdb-command:run\n \n // gdb-command:print *the_a_ref\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n // gdbr-check:$1 = borrowed_enum::ABC::TheA{x: 0, y: 8970181431921507452}\n \n // gdb-command:print *the_b_ref\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, x = 0, y = 1229782938247303441}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n // gdbr-check:$2 = borrowed_enum::ABC::TheB(0, 286331153, 286331153)\n \n // gdb-command:print *univariant_ref"}, {"sha": "0fe08c3a22731b0ac9fcb32cb546a61615ac2aeb", "filename": "src/test/debuginfo/by-value-non-immediate-argument.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -42,7 +42,7 @@\n // gdb-command:continue\n \n // gdb-command:print x\n-// gdbg-check:$7 = {{RUST$ENUM$DISR = Case1, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbg-check:$7 = {{RUST$ENUM$DISR = Case1, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$7 = by_value_non_immediate_argument::Enum::Case1{x: 0, y: 8970181431921507452}\n // gdb-command:continue\n "}, {"sha": "a328eec689394afbdbbe008101518ca5111f0dcd", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -17,15 +17,15 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, a = 0, b = 2088533116, c = 2088533116}, {RUST$ENUM$DISR = Case1, a = 0, b = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = generic_struct_style_enum::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, a = 0, b = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n // gdbr-check:$2 = generic_struct_style_enum::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {RUST$ENUM$DISR = Case3, a = 0, b = 1499027801, c = 1499027801}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n // gdbr-check:$3 = generic_struct_style_enum::Regular::Case3{a: 0, b: 6438275382588823897}\n \n // gdb-command:print univariant"}, {"sha": "9ada5fdeff7889ec36390136b134c01acab61ef2", "filename": "src/test/debuginfo/generic-tuple-style-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -19,15 +19,15 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = generic_tuple_style_enum::Regular::Case1(0, 31868, 31868, 31868, 31868)\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = 4369, __2 = 4369, __3 = 4369, __4 = 4369}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n // gdbr-check:$2 = generic_tuple_style_enum::Regular::Case2(0, 286331153, 286331153)\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, __0 = 0, __1 = 22873, __2 = 22873, __3 = 22873, __4 = 22873}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 1499027801, __2 = 1499027801}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n // gdbr-check:$3 = generic_tuple_style_enum::Regular::Case3(0, 6438275382588823897)\n \n // gdb-command:print univariant"}, {"sha": "ffd36ae14ad7cd75d3a2659e099d740281d0e8cd", "filename": "src/test/debuginfo/struct-in-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-in-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -19,11 +19,11 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = {x = 2088533116, y = 2088533116, z = 31868}}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452, __2 = 31868}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = {x = 2088533116, y = 2088533116, z = 31868}}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = struct_in_enum::Regular::Case1(0, struct_in_enum::Struct {x: 2088533116, y: 2088533116, z: 31868})\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = {x = 286331153, y = 286331153, z = 4369}}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441, __2 = 4369}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441, __2 = 4369}}\n // gdbr-check:$2 = struct_in_enum::Regular::Case2(0, 1229782938247303441, 4369)\n \n // gdb-command:print univariant"}, {"sha": "b6196daaa4656ff5c5c6ecdaaa1fe99d80f90883", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -19,15 +19,15 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, a = 0, b = 2088533116, c = 2088533116}, {RUST$ENUM$DISR = Case1, a = 0, b = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = struct_style_enum::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, a = 0, b = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n // gdbr-check:$2 = struct_style_enum::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {RUST$ENUM$DISR = Case3, a = 0, b = 1499027801, c = 1499027801}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n // gdbr-check:$3 = struct_style_enum::Regular::Case3{a: 0, b: 6438275382588823897}\n \n // gdb-command:print univariant"}, {"sha": "988f223b3bc4f935d14a2cd44c2bc966bc33ad69", "filename": "src/test/debuginfo/tuple-style-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -19,15 +19,15 @@\n // gdb-command:run\n \n // gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 2088533116, __2 = 2088533116}, {RUST$ENUM$DISR = Case1, __0 = 0, __1 = 8970181431921507452}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n // gdbr-check:$1 = tuple_style_enum::Regular::Case1(0, 31868, 31868, 31868, 31868)\n \n // gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, __0 = 0, __1 = 4369, __2 = 4369, __3 = 4369, __4 = 4369}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 1229782938247303441}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n // gdbr-check:$2 = tuple_style_enum::Regular::Case2(0, 286331153, 286331153)\n \n // gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, __0 = 0, __1 = 22873, __2 = 22873, __3 = 22873, __4 = 22873}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 1499027801, __2 = 1499027801}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n+// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n // gdbr-check:$3 = tuple_style_enum::Regular::Case3(0, 6438275382588823897)\n \n // gdb-command:print univariant"}, {"sha": "cf8d90e30f169732ad2ae0bf8f044210aa8be775", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -18,11 +18,11 @@\n // gdb-command:run\n \n // gdb-command:print *the_a\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, __0 = 0, __1 = 2088533116, __2 = 2088533116}}\n+// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n // gdbr-check:$1 = unique_enum::ABC::TheA{x: 0, y: 8970181431921507452}\n \n // gdb-command:print *the_b\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, x = 0, y = 1229782938247303441}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n+// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n // gdbr-check:$2 = unique_enum::ABC::TheB(0, 286331153, 286331153)\n \n // gdb-command:print *univariant"}, {"sha": "e566c10583597520efbe53d8dae22a67ffb26402", "filename": "src/test/run-pass/closure-immediate.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fclosure-immediate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fclosure-immediate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-immediate.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// After the work to reoptimize structs, it became possible for immediate logic to fail.\n+// This test verifies that it actually works.\n+\n+fn main() {\n+    let c = |a: u8, b: u16, c: u8| {\n+        assert_eq!(a, 1);\n+        assert_eq!(b, 2);\n+        assert_eq!(c, 3);\n+    };\n+    c(1, 2, 3);\n+}"}, {"sha": "a3e95a153418dbd3116fceacc3aa23614930a3bd", "filename": "src/test/run-pass/enum-size-variance.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -11,6 +11,9 @@\n #![warn(variant_size_differences)]\n #![allow(dead_code)]\n \n+// Note that the following test works because all fields of the enum variants are of the same size.\n+// If this test is modified and the reordering logic in librustc/ty/layout.rs kicks in, it fails.\n+\n enum Enum1 { }\n \n enum Enum2 { A, B, C }"}, {"sha": "2606c92868004715a1fe621fc17b7c8a153a6b1a", "filename": "src/test/run-pass/extern-pass-empty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fextern-pass-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fextern-pass-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-empty.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -14,11 +14,13 @@\n // ignore-msvc\n // ignore-emscripten\n \n+#[repr(C)]\n struct TwoU8s {\n     one: u8,\n     two: u8,\n }\n \n+#[repr(C)]\n struct ManyInts {\n     arg1: i8,\n     arg2: i16,\n@@ -28,6 +30,7 @@ struct ManyInts {\n     arg6: TwoU8s,\n }\n \n+#[repr(C)]\n struct Empty;\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]"}, {"sha": "c2fe943eed85ad65f617bf88194f9fb266f42630", "filename": "src/test/run-pass/multiple-reprs.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultiple-reprs.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use std::mem::size_of;\n+\n+// The two enums that follow are designed so that bugs trigger layout optimization.\n+// Specifically, if either of the following reprs used here is not detected by the compiler,\n+// then the sizes will be wrong.\n+\n+#[repr(C, u8)]\n+enum E1 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+#[repr(u8, C)]\n+enum E2 {\n+    A(u8, u16, u8),\n+    B(u8, u16, u8)\n+}\n+\n+// From pr 37429\n+\n+#[repr(C,packed)]\n+pub struct p0f_api_query {\n+    pub magic: u32,\n+    pub addr_type: u8,\n+    pub addr: [u8; 16],\n+}\n+\n+pub fn main() {\n+    assert_eq!(size_of::<E1>(), 6);\n+    assert_eq!(size_of::<E2>(), 6);\n+    assert_eq!(size_of::<p0f_api_query>(), 21);\n+}"}, {"sha": "fc92c9df9f7ef0cf7b6eeb2b550d9ffc62b58fa9", "filename": "src/test/run-pass/nonzero-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fnonzero-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fnonzero-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnonzero-enum.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -26,8 +26,7 @@ fn main() {\n     assert_eq!(size_of::<E>(), 1);\n     assert_eq!(size_of::<Option<E>>(), 1);\n     assert_eq!(size_of::<Result<E, ()>>(), 1);\n-    assert_eq!(size_of::<S>(), 4);\n-    assert_eq!(size_of::<Option<S>>(), 4);\n+    assert_eq!(size_of::<Option<S>>(), size_of::<S>());\n     let enone = None::<E>;\n     let esome = Some(E::A);\n     if let Some(..) = enone {"}, {"sha": "ed618cea98ac0a2be5f7cd2a5a2840eb9b3def84", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n //\n \n+#[repr(C)]\n #[derive(Copy, Clone)]\n pub struct Quad { a: u64, b: u64, c: u64, d: u64 }\n \n+#[repr(C)]\n #[derive(Copy, Clone)]\n pub struct Floats { a: f64, b: u8, c: f64 }\n "}, {"sha": "6614a76107f8539cd7f3d261e8c165afcf9654b2", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -26,10 +26,15 @@ enum e2 {\n     a(u32), b\n }\n \n+#[repr(C, u8)]\n enum e3 {\n     a([u16; 0], u8), b\n }\n \n+// Test struct field reordering to make sure it actually reorders.\n+struct WillOptimize1(u8, u16, u8);\n+struct WillOptimize2 { a: u8, b: u16, c: u8}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as usize);\n     assert_eq!(size_of::<u32>(), 4 as usize);\n@@ -53,4 +58,7 @@ pub fn main() {\n     assert_eq!(size_of::<e1>(), 8 as usize);\n     assert_eq!(size_of::<e2>(), 8 as usize);\n     assert_eq!(size_of::<e3>(), 4 as usize);\n+\n+    assert_eq!(size_of::<WillOptimize1>(), 4);\n+    assert_eq!(size_of::<WillOptimize2>(), 4);\n }"}, {"sha": "830678f174f88cf38e0d76836bac2cc7c9a9ee96", "filename": "src/test/ui/print_type_sizes/nullable.stdout", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -1,25 +1,22 @@\n-print-type-size type: `IndirectNonZero<u32>`: 20 bytes, alignment: 4 bytes\n-print-type-size     field `.pre`: 1 bytes\n-print-type-size     padding: 3 bytes\n-print-type-size     field `.nested`: 12 bytes, alignment: 4 bytes\n+print-type-size type: `IndirectNonZero<u32>`: 12 bytes, alignment: 4 bytes\n+print-type-size     field `.nested`: 8 bytes\n print-type-size     field `.post`: 2 bytes\n-print-type-size     end padding: 2 bytes\n-print-type-size type: `MyOption<IndirectNonZero<u32>>`: 20 bytes, alignment: 4 bytes\n-print-type-size     variant `Some`: 20 bytes\n-print-type-size         field `.0`: 20 bytes\n-print-type-size type: `EmbeddedDiscr`: 12 bytes, alignment: 4 bytes\n-print-type-size     variant `Record`: 10 bytes\n-print-type-size         field `.pre`: 1 bytes\n-print-type-size         padding: 3 bytes\n-print-type-size         field `.val`: 4 bytes, alignment: 4 bytes\n-print-type-size         field `.post`: 2 bytes\n-print-type-size     end padding: 2 bytes\n-print-type-size type: `NestedNonZero<u32>`: 12 bytes, alignment: 4 bytes\n print-type-size     field `.pre`: 1 bytes\n-print-type-size     padding: 3 bytes\n-print-type-size     field `.val`: 4 bytes, alignment: 4 bytes\n+print-type-size     end padding: 1 bytes\n+print-type-size type: `MyOption<IndirectNonZero<u32>>`: 12 bytes, alignment: 4 bytes\n+print-type-size     variant `Some`: 12 bytes\n+print-type-size         field `.0`: 12 bytes\n+print-type-size type: `EmbeddedDiscr`: 8 bytes, alignment: 4 bytes\n+print-type-size     variant `Record`: 7 bytes\n+print-type-size         field `.val`: 4 bytes\n+print-type-size         field `.post`: 2 bytes\n+print-type-size         field `.pre`: 1 bytes\n+print-type-size     end padding: 1 bytes\n+print-type-size type: `NestedNonZero<u32>`: 8 bytes, alignment: 4 bytes\n+print-type-size     field `.val`: 4 bytes\n print-type-size     field `.post`: 2 bytes\n-print-type-size     end padding: 2 bytes\n+print-type-size     field `.pre`: 1 bytes\n+print-type-size     end padding: 1 bytes\n print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `Some`: 4 bytes\n print-type-size         field `.0`: 4 bytes"}, {"sha": "83fd333c9c7fc45dba547de22add55c477521ef9", "filename": "src/test/ui/print_type_sizes/packed.stdout", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -1,13 +1,11 @@\n-print-type-size type: `Padded`: 16 bytes, alignment: 4 bytes\n+print-type-size type: `Padded`: 12 bytes, alignment: 4 bytes\n+print-type-size     field `.g`: 4 bytes\n+print-type-size     field `.h`: 2 bytes\n print-type-size     field `.a`: 1 bytes\n print-type-size     field `.b`: 1 bytes\n-print-type-size     padding: 2 bytes\n-print-type-size     field `.g`: 4 bytes, alignment: 4 bytes\n print-type-size     field `.c`: 1 bytes\n-print-type-size     padding: 1 bytes\n-print-type-size     field `.h`: 2 bytes, alignment: 2 bytes\n print-type-size     field `.d`: 1 bytes\n-print-type-size     end padding: 3 bytes\n+print-type-size     end padding: 2 bytes\n print-type-size type: `Packed`: 10 bytes, alignment: 1 bytes\n print-type-size     field `.a`: 1 bytes\n print-type-size     field `.b`: 1 bytes"}, {"sha": "0eaff7118b35c38a528dab7052d2cd498acb15aa", "filename": "src/test/ui/print_type_sizes/padding.stdout", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8327b5afafde7cdd6fd4e939d9a8fe12f76503ef/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.stdout?ref=8327b5afafde7cdd6fd4e939d9a8fe12f76503ef", "patch": "@@ -1,10 +1,12 @@\n print-type-size type: `E1`: 12 bytes, alignment: 4 bytes\n-print-type-size     discriminant: 4 bytes\n-print-type-size     variant `A`: 5 bytes\n-print-type-size         field `.0`: 4 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `A`: 7 bytes\n print-type-size         field `.1`: 1 bytes\n-print-type-size     variant `B`: 8 bytes\n-print-type-size         field `.0`: 8 bytes\n+print-type-size         padding: 2 bytes\n+print-type-size         field `.0`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `B`: 11 bytes\n+print-type-size         padding: 3 bytes\n+print-type-size         field `.0`: 8 bytes, alignment: 4 bytes\n print-type-size type: `E2`: 12 bytes, alignment: 4 bytes\n print-type-size     discriminant: 1 bytes\n print-type-size     variant `A`: 7 bytes\n@@ -15,7 +17,7 @@ print-type-size     variant `B`: 11 bytes\n print-type-size         padding: 3 bytes\n print-type-size         field `.0`: 8 bytes, alignment: 4 bytes\n print-type-size type: `S`: 8 bytes, alignment: 4 bytes\n+print-type-size     field `.g`: 4 bytes\n print-type-size     field `.a`: 1 bytes\n print-type-size     field `.b`: 1 bytes\n-print-type-size     padding: 2 bytes\n-print-type-size     field `.g`: 4 bytes, alignment: 4 bytes\n+print-type-size     end padding: 2 bytes"}]}