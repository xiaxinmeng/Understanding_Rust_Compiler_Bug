{"sha": "9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "node_id": "C_kwDOAAsO6NoAKDliZTliNWUwOWFkODM0ZTJiYTlmMjU3MWNhMTcwNTllMThmODliNzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-12T08:39:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-12T08:39:19Z"}, "message": "Auto merge of #107614 - compiler-errors:allow-elaborator-to-filter-only-super-traits, r=oli-obk\n\nSplit implied and super predicate queries, then allow elaborator to filter only supertraits\n\nSplit the `super_predicates_of` query into a new `implied_predicates_of` query. The former now only returns the *real* supertraits of a trait alias, and the latter now returns the implied predicates (which include all of the `where` clauses of the trait alias). The behavior of these queries is identical for regular traits.\n\nNow that the two queries are split, we can add a new filter method to the elaborator, `filter_only_self()`, which can be used in instances that we need only the *supertrait* predicates, such as during the elaboration used in closure signature deduction. This toggles the usage of `super_predicates_of` instead of `implied_predicates_of` during elaboration of a trait predicate.\n\nThis supersedes #104745, and fixes the four independent bugs identified in that PR.\nFixes #104719\nFixes #106238\nFixes #110023\nFixes #109514\n\nr? types", "tree": {"sha": "8c56a32b9bdc1026a4d12a0ea5810252ae6fcdd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c56a32b9bdc1026a4d12a0ea5810252ae6fcdd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "html_url": "https://github.com/rust-lang/rust/commit/9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d7ed3ba8445452013dd873dc9abcad41a3d82b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7ed3ba8445452013dd873dc9abcad41a3d82b2", "html_url": "https://github.com/rust-lang/rust/commit/0d7ed3ba8445452013dd873dc9abcad41a3d82b2"}, {"sha": "7ec72efe10df28fcf5c6ec13c2a487572041be59", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec72efe10df28fcf5c6ec13c2a487572041be59", "html_url": "https://github.com/rust-lang/rust/commit/7ec72efe10df28fcf5c6ec13c2a487572041be59"}], "stats": {"total": 458, "additions": 308, "deletions": 150}, "files": [{"sha": "8cb95610da08005eb2fd7c6af76b42394f1e48fa", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1663,39 +1663,45 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n         });\n \n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|mut b| {\n-                assert_eq!(b.projection_ty.self_ty(), dummy_self);\n-\n-                // Like for trait refs, verify that `dummy_self` did not leak inside default type\n-                // parameters.\n-                let references_self = b.projection_ty.substs.iter().skip(1).any(|arg| {\n-                    if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                        return true;\n+        let existential_projections = projection_bounds\n+            .iter()\n+            // We filter out traits that don't have `Self` as their self type above,\n+            // we need to do the same for projections.\n+            .filter(|(bound, _)| bound.skip_binder().self_ty() == dummy_self)\n+            .map(|(bound, _)| {\n+                bound.map_bound(|mut b| {\n+                    assert_eq!(b.projection_ty.self_ty(), dummy_self);\n+\n+                    // Like for trait refs, verify that `dummy_self` did not leak inside default type\n+                    // parameters.\n+                    let references_self = b.projection_ty.substs.iter().skip(1).any(|arg| {\n+                        if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                            return true;\n+                        }\n+                        false\n+                    });\n+                    if references_self {\n+                        let guar = tcx.sess.delay_span_bug(\n+                            span,\n+                            \"trait object projection bounds reference `Self`\",\n+                        );\n+                        let substs: Vec<_> = b\n+                            .projection_ty\n+                            .substs\n+                            .iter()\n+                            .map(|arg| {\n+                                if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                                    return tcx.ty_error(guar).into();\n+                                }\n+                                arg\n+                            })\n+                            .collect();\n+                        b.projection_ty.substs = tcx.mk_substs(&substs);\n                     }\n-                    false\n-                });\n-                if references_self {\n-                    let guar = tcx\n-                        .sess\n-                        .delay_span_bug(span, \"trait object projection bounds reference `Self`\");\n-                    let substs: Vec<_> = b\n-                        .projection_ty\n-                        .substs\n-                        .iter()\n-                        .map(|arg| {\n-                            if arg.walk().any(|arg| arg == dummy_self.into()) {\n-                                return tcx.ty_error(guar).into();\n-                            }\n-                            arg\n-                        })\n-                        .collect();\n-                    b.projection_ty.substs = tcx.mk_substs(&substs);\n-                }\n \n-                ty::ExistentialProjection::erase_self_ty(tcx, b)\n-            })\n-        });\n+                    ty::ExistentialProjection::erase_self_ty(tcx, b)\n+                })\n+            });\n \n         let regular_trait_predicates = existential_trait_refs\n             .map(|trait_ref| trait_ref.map_bound(ty::ExistentialPredicate::Trait));"}, {"sha": "cbbaf8f857dac3ef82b0250d81a933f5d1ba293e", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -64,6 +64,7 @@ pub fn provide(providers: &mut Providers) {\n         predicates_defined_on,\n         explicit_predicates_of: predicates_of::explicit_predicates_of,\n         super_predicates_of: predicates_of::super_predicates_of,\n+        implied_predicates_of: predicates_of::implied_predicates_of,\n         super_predicates_that_define_assoc_type:\n             predicates_of::super_predicates_that_define_assoc_type,\n         trait_explicit_predicates_and_bounds: predicates_of::trait_explicit_predicates_and_bounds,\n@@ -596,6 +597,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         }\n         hir::ItemKind::TraitAlias(..) => {\n             tcx.ensure().generics_of(def_id);\n+            tcx.at(it.span).implied_predicates_of(def_id);\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n         }"}, {"sha": "9358ed612921f5e76dce6c7d8df516ed93017e24", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -125,7 +125,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Gen\n     // on a trait we need to add in the supertrait bounds and bounds found on\n     // associated types.\n     if let Some(_trait_ref) = is_trait {\n-        predicates.extend(tcx.super_predicates_of(def_id).predicates.iter().cloned());\n+        predicates.extend(tcx.implied_predicates_of(def_id).predicates.iter().cloned());\n     }\n \n     // In default impls, we can assume that the self type implements\n@@ -534,31 +534,62 @@ pub(super) fn explicit_predicates_of<'tcx>(\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum PredicateFilter {\n+    /// All predicates may be implied by the trait\n+    All,\n+\n+    /// Only traits that reference `Self: ..` are implied by the trait\n+    SelfOnly,\n+\n+    /// Only traits that reference `Self: ..` and define an associated type\n+    /// with the given ident are implied by the trait\n+    SelfThatDefines(Ident),\n+}\n+\n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n pub(super) fn super_predicates_of(\n     tcx: TyCtxt<'_>,\n     trait_def_id: LocalDefId,\n ) -> ty::GenericPredicates<'_> {\n-    tcx.super_predicates_that_define_assoc_type((trait_def_id.to_def_id(), None))\n+    implied_predicates_with_filter(tcx, trait_def_id.to_def_id(), PredicateFilter::SelfOnly)\n+}\n+\n+pub(super) fn super_predicates_that_define_assoc_type(\n+    tcx: TyCtxt<'_>,\n+    (trait_def_id, assoc_name): (DefId, Ident),\n+) -> ty::GenericPredicates<'_> {\n+    implied_predicates_with_filter(tcx, trait_def_id, PredicateFilter::SelfThatDefines(assoc_name))\n+}\n+\n+pub(super) fn implied_predicates_of(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: LocalDefId,\n+) -> ty::GenericPredicates<'_> {\n+    if tcx.is_trait_alias(trait_def_id.to_def_id()) {\n+        implied_predicates_with_filter(tcx, trait_def_id.to_def_id(), PredicateFilter::All)\n+    } else {\n+        tcx.super_predicates_of(trait_def_id)\n+    }\n }\n \n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n-pub(super) fn super_predicates_that_define_assoc_type(\n+pub(super) fn implied_predicates_with_filter(\n     tcx: TyCtxt<'_>,\n-    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n+    trait_def_id: DefId,\n+    filter: PredicateFilter,\n ) -> ty::GenericPredicates<'_> {\n     let Some(trait_def_id) = trait_def_id.as_local() else {\n         // if `assoc_name` is None, then the query should've been redirected to an\n         // external provider\n-        assert!(assoc_name.is_some());\n+        assert!(matches!(filter, PredicateFilter::SelfThatDefines(_)));\n         return tcx.super_predicates_of(trait_def_id);\n     };\n \n-    debug!(\"local trait\");\n     let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id);\n \n     let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n@@ -573,48 +604,66 @@ pub(super) fn super_predicates_that_define_assoc_type(\n \n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n     let self_param_ty = tcx.types.self_param;\n-    let superbounds1 = if let Some(assoc_name) = assoc_name {\n-        icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name)\n-    } else {\n-        icx.astconv().compute_bounds(self_param_ty, bounds)\n+    let (superbounds, where_bounds_that_match) = match filter {\n+        PredicateFilter::All => (\n+            // Convert the bounds that follow the colon (or equal in trait aliases)\n+            icx.astconv().compute_bounds(self_param_ty, bounds),\n+            // Also include all where clause bounds\n+            icx.type_parameter_bounds_in_generics(\n+                generics,\n+                item.owner_id.def_id,\n+                self_param_ty,\n+                OnlySelfBounds(false),\n+                None,\n+            ),\n+        ),\n+        PredicateFilter::SelfOnly => (\n+            // Convert the bounds that follow the colon (or equal in trait aliases)\n+            icx.astconv().compute_bounds(self_param_ty, bounds),\n+            // Include where clause bounds for `Self`\n+            icx.type_parameter_bounds_in_generics(\n+                generics,\n+                item.owner_id.def_id,\n+                self_param_ty,\n+                OnlySelfBounds(true),\n+                None,\n+            ),\n+        ),\n+        PredicateFilter::SelfThatDefines(assoc_name) => (\n+            // Convert the bounds that follow the colon (or equal) that reference the associated name\n+            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name),\n+            // Include where clause bounds for `Self` that reference the associated name\n+            icx.type_parameter_bounds_in_generics(\n+                generics,\n+                item.owner_id.def_id,\n+                self_param_ty,\n+                OnlySelfBounds(true),\n+                Some(assoc_name),\n+            ),\n+        ),\n     };\n \n-    let superbounds1 = superbounds1.predicates();\n-\n-    // Convert any explicit superbounds in the where-clause,\n-    // e.g., `trait Foo where Self: Bar`.\n-    // In the case of trait aliases, however, we include all bounds in the where-clause,\n-    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-    // as one of its \"superpredicates\".\n-    let is_trait_alias = tcx.is_trait_alias(trait_def_id.to_def_id());\n-    let superbounds2 = icx.type_parameter_bounds_in_generics(\n-        generics,\n-        item.owner_id.def_id,\n-        self_param_ty,\n-        OnlySelfBounds(!is_trait_alias),\n-        assoc_name,\n-    );\n-\n     // Combine the two lists to form the complete set of superbounds:\n-    let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n-    debug!(?superbounds);\n+    let implied_bounds = &*tcx\n+        .arena\n+        .alloc_from_iter(superbounds.predicates().into_iter().chain(where_bounds_that_match));\n+    debug!(?implied_bounds);\n \n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n-    if assoc_name.is_none() {\n+    if matches!(filter, PredicateFilter::SelfOnly) {\n         // Now require that immediate supertraits are converted,\n         // which will, in turn, reach indirect supertraits.\n-        for &(pred, span) in superbounds {\n+        for &(pred, span) in implied_bounds {\n             debug!(\"superbound: {:?}\", pred);\n             if let ty::PredicateKind::Clause(ty::Clause::Trait(bound)) = pred.kind().skip_binder() {\n                 tcx.at(span).super_predicates_of(bound.def_id());\n             }\n         }\n     }\n \n-    ty::GenericPredicates { parent: None, predicates: superbounds }\n+    ty::GenericPredicates { parent: None, predicates: implied_bounds }\n }\n \n /// Returns the predicates defined on `item_def_id` of the form"}, {"sha": "e758fe95d9c294248759d03c532858c539a47bbd", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1749,8 +1749,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n             if trait_defines_associated_type_named(def_id) {\n                 break Some(bound_vars.into_iter().collect());\n             }\n-            let predicates =\n-                tcx.super_predicates_that_define_assoc_type((def_id, Some(assoc_name)));\n+            let predicates = tcx.super_predicates_that_define_assoc_type((def_id, assoc_name));\n             let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n                 let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {"}, {"sha": "8c2495e1dd8c51dc6da052d86071aac955f3c081", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -210,7 +210,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // and we want to keep inference generally in the same order of\n             // the registered obligations.\n             predicates.rev(),\n-        ) {\n+        )\n+        // We only care about self bounds\n+        .filter_only_self()\n+        {\n             debug!(?pred);\n             let bound_predicate = pred.kind();\n "}, {"sha": "ef01d5d513bbc456a95df15a7976d2adbb0b8af3", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -69,6 +69,7 @@ impl<'tcx> Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n pub struct Elaborator<'tcx, O> {\n     stack: Vec<O>,\n     visited: PredicateSet<'tcx>,\n+    only_self: bool,\n }\n \n /// Describes how to elaborate an obligation into a sub-obligation.\n@@ -170,7 +171,8 @@ pub fn elaborate<'tcx, O: Elaboratable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     obligations: impl IntoIterator<Item = O>,\n ) -> Elaborator<'tcx, O> {\n-    let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n+    let mut elaborator =\n+        Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx), only_self: false };\n     elaborator.extend_deduped(obligations);\n     elaborator\n }\n@@ -185,14 +187,25 @@ impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n         self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate())));\n     }\n \n+    /// Filter to only the supertraits of trait predicates, i.e. only the predicates\n+    /// that have `Self` as their self type, instead of all implied predicates.\n+    pub fn filter_only_self(mut self) -> Self {\n+        self.only_self = true;\n+        self\n+    }\n+\n     fn elaborate(&mut self, elaboratable: &O) {\n         let tcx = self.visited.tcx;\n \n         let bound_predicate = elaboratable.predicate().kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n-                // Get predicates declared on the trait.\n-                let predicates = tcx.super_predicates_of(data.def_id());\n+                // Get predicates implied by the trait, or only super predicates if we only care about self predicates.\n+                let predicates = if self.only_self {\n+                    tcx.super_predicates_of(data.def_id())\n+                } else {\n+                    tcx.implied_predicates_of(data.def_id())\n+                };\n \n                 let obligations =\n                     predicates.predicates.iter().enumerate().map(|(index, &(mut pred, span))| {\n@@ -350,18 +363,16 @@ pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    let pred: ty::Predicate<'tcx> = trait_ref.to_predicate(tcx);\n-    FilterToTraits::new(elaborate(tcx, [pred]))\n+    elaborate(tcx, [trait_ref.to_predicate(tcx)]).filter_only_self().filter_to_traits()\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n ) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n-    FilterToTraits::new(elaborate(\n-        tcx,\n-        trait_refs.map(|trait_ref| -> ty::Predicate<'tcx> { trait_ref.to_predicate(tcx) }),\n-    ))\n+    elaborate(tcx, trait_refs.map(|trait_ref| trait_ref.to_predicate(tcx)))\n+        .filter_only_self()\n+        .filter_to_traits()\n }\n \n /// A specialized variant of `elaborate` that only elaborates trait references that may\n@@ -381,10 +392,8 @@ pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n         while let Some(trait_ref) = stack.pop() {\n             let anon_trait_ref = tcx.anonymize_bound_vars(trait_ref);\n             if visited.insert(anon_trait_ref) {\n-                let super_predicates = tcx.super_predicates_that_define_assoc_type((\n-                    trait_ref.def_id(),\n-                    Some(assoc_name),\n-                ));\n+                let super_predicates =\n+                    tcx.super_predicates_that_define_assoc_type((trait_ref.def_id(), assoc_name));\n                 for (super_predicate, _) in super_predicates.predicates {\n                     let subst_predicate = super_predicate.subst_supertrait(tcx, &trait_ref);\n                     if let Some(binder) = subst_predicate.to_opt_poly_trait_pred() {\n@@ -404,18 +413,18 @@ pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n // Other\n ///////////////////////////////////////////////////////////////////////////\n \n+impl<'tcx> Elaborator<'tcx, ty::Predicate<'tcx>> {\n+    fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits { base_iterator: self }\n+    }\n+}\n+\n /// A filter around an iterator of predicates that makes it yield up\n /// just trait references.\n pub struct FilterToTraits<I> {\n     base_iterator: I,\n }\n \n-impl<I> FilterToTraits<I> {\n-    fn new(base: I) -> FilterToTraits<I> {\n-        FilterToTraits { base_iterator: base }\n-    }\n-}\n-\n impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n "}, {"sha": "1159d11e5c0c8411f7a8089fcaac4c43e9a448e0", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -255,6 +255,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n                 ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n                     elaborate(cx.tcx, cx.tcx.explicit_item_bounds(def).iter().cloned())\n+                        // We only care about self bounds for the impl-trait\n+                        .filter_only_self()\n                         .find_map(|(pred, _span)| {\n                             // We only look at the `DefId`, so it is safe to skip the binder here.\n                             if let ty::PredicateKind::Clause(ty::Clause::Trait("}, {"sha": "31798afb852c5da3e26e791223b6ad13ebe3dc09", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -253,7 +253,19 @@ provide! { tcx, def_id, other, cdata,\n             .get(cdata, def_id.index)\n             .map(|lazy| lazy.decode((cdata, tcx)))\n             .process_decoded(tcx, || panic!(\"{def_id:?} does not have trait_impl_trait_tys\")))\n-     }\n+    }\n+    implied_predicates_of => {\n+        cdata\n+            .root\n+            .tables\n+            .implied_predicates_of\n+            .get(cdata, def_id.index)\n+            .map(|lazy| lazy.decode((cdata, tcx)))\n+            .unwrap_or_else(|| {\n+                debug_assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n+                tcx.super_predicates_of(def_id)\n+            })\n+    }\n \n     associated_types_for_impl_traits_in_associated_fn => { table_defaulted_array }\n "}, {"sha": "dc8fa1ab7d31d7169fe0e2a57e94bff861bf0f46", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1316,9 +1316,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let default = self.tcx.object_lifetime_default(def_id);\n                 record!(self.tables.object_lifetime_default[def_id] <- default);\n             }\n-            if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n+            if let DefKind::Trait = def_kind {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n+            if let DefKind::TraitAlias = def_kind {\n+                record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n+                record!(self.tables.implied_predicates_of[def_id] <- self.tcx.implied_predicates_of(def_id));\n+            }\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n                 self.encode_info_for_adt(def_id);\n             }"}, {"sha": "569fd20fdfe63b86998b14f819f1801bc60a5627", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -372,6 +372,9 @@ define_tables! {\n     explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n+    // As an optimization, we only store this for trait aliases,\n+    // since it's identical to super_predicates_of for traits.\n+    implied_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     type_of: Table<DefIndex, LazyValue<ty::EarlyBinder<Ty<'static>>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n     fn_sig: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::PolyFnSig<'static>>>>,\n@@ -383,7 +386,6 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_generator_witnesses: Table<DefIndex, LazyValue<mir::GeneratorLayout<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n-    // FIXME(compiler-errors): Why isn't this a LazyArray?\n     thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,"}, {"sha": "3b0eec683de0e67bbc526047901ed032e49af012", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -230,7 +230,7 @@ impl Key for (LocalDefId, LocalDefId) {\n     }\n }\n \n-impl Key for (DefId, Option<Ident>) {\n+impl Key for (DefId, Ident) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {"}, {"sha": "2f6b7a3c860b7ea9c1c7484c0752f3ee793e49a4", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -627,14 +627,20 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query implied_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n+        desc { |tcx| \"computing the implied predicates of `{}`\", tcx.def_path_str(key) }\n+        cache_on_disk_if { key.is_local() }\n+        separate_provide_extern\n+    }\n+\n     /// The `Option<Ident>` is the name of an associated type. If it is `None`, then this query\n     /// returns the full set of predicates. If `Some<Ident>`, then the query returns only the\n     /// subset of super-predicates that reference traits that define the given associated type.\n     /// This is used to avoid cycles in resolving types like `T::Item`.\n-    query super_predicates_that_define_assoc_type(key: (DefId, Option<rustc_span::symbol::Ident>)) -> ty::GenericPredicates<'tcx> {\n-        desc { |tcx| \"computing the super traits of `{}`{}\",\n+    query super_predicates_that_define_assoc_type(key: (DefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n+        desc { |tcx| \"computing the super traits of `{}` with associated type name `{}`\",\n             tcx.def_path_str(key.0),\n-            if let Some(assoc_name) = key.1 { format!(\" with associated type name `{}`\", assoc_name) } else { \"\".to_string() },\n+            key.1\n         }\n     }\n "}, {"sha": "7f0ceb6646cebfba5b182aceb81a1dc6c3959d02", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -505,7 +505,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let tcx = self.tcx();\n         let own_bounds: FxIndexSet<_> =\n             bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n-        for assumption in elaborate(tcx, own_bounds.iter().copied()) {\n+        for assumption in elaborate(tcx, own_bounds.iter().copied())\n+            // we only care about bounds that match the `Self` type\n+            .filter_only_self()\n+        {\n             // FIXME: Predicates are fully elaborated in the object type's existential bounds\n             // list. We want to only consider these pre-elaborated projections, and not other\n             // projection predicates that we reach by elaborating the principal trait ref,"}, {"sha": "60630979b34e4203c42263c73de54568245293cf", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n         }\n \n         // Get components of trait alias.\n-        let predicates = tcx.super_predicates_of(trait_ref.def_id());\n+        let predicates = tcx.implied_predicates_of(trait_ref.def_id());\n         debug!(?predicates);\n \n         let items = predicates.predicates.iter().rev().filter_map(|(pred, span)| {"}, {"sha": "575b00e09b02c6c076c484cc353e7505774a9de4", "filename": "tests/ui/associated-type-bounds/ambiguous-associated-type2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -5,7 +5,7 @@ LL | trait Baz: Foo + Bar<Self::Item> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: ...which immediately requires computing the super traits of `Baz` with associated type name `Item` again\n-note: cycle used when computing the super traits of `Baz`\n+note: cycle used when computing the super predicates of `Baz`\n   --> $DIR/ambiguous-associated-type2.rs:7:1\n    |\n LL | trait Baz: Foo + Bar<Self::Item> {}"}, {"sha": "c4dea68b884a2576b47a9a2b51bf78c341995572", "filename": "tests/ui/associated-types/issue-20825.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fassociated-types%2Fissue-20825.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fassociated-types%2Fissue-20825.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fissue-20825.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -5,7 +5,7 @@ LL | pub trait Processor: Subscriber<Input = Self::Input> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: ...which immediately requires computing the super traits of `Processor` with associated type name `Input` again\n-note: cycle used when computing the super traits of `Processor`\n+note: cycle used when computing the super predicates of `Processor`\n   --> $DIR/issue-20825.rs:5:1\n    |\n LL | pub trait Processor: Subscriber<Input = Self::Input> {"}, {"sha": "f4f1cea6b81769e3922e9101da5ebb282e01698b", "filename": "tests/ui/closures/self-supertrait-bounds.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fclosures%2Fself-supertrait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fclosures%2Fself-supertrait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2Fself-supertrait-bounds.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+// Makes sure that we only consider `Self` supertrait predicates while\n+// elaborating during closure signature deduction.\n+\n+#![feature(trait_alias)]\n+\n+trait Confusing<F> = Fn(i32) where F: Fn(u32);\n+\n+fn alias<T: Confusing<F>, F>(_: T, _: F) {}\n+\n+fn main() {\n+    alias(|_| {}, |_| {});\n+}"}, {"sha": "e2b2aac05ac948eac3132860cc560d32ba60b087", "filename": "tests/ui/cycle-trait/cycle-trait-supertrait-direct.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1,15 +1,10 @@\n error[E0391]: cycle detected when computing the super predicates of `Chromosome`\n-  --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n-   |\n-LL | trait Chromosome: Chromosome {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `Chromosome`...\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:19\n    |\n LL | trait Chromosome: Chromosome {\n    |                   ^^^^^^^^^^\n-   = note: ...which again requires computing the super predicates of `Chromosome`, completing the cycle\n+   |\n+   = note: ...which immediately requires computing the super predicates of `Chromosome` again\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n    |"}, {"sha": "c903e114657688d13b9592fe8d8d83dbc04f1187", "filename": "tests/ui/cycle-trait/cycle-trait-supertrait-indirect.stderr", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1,26 +1,16 @@\n error[E0391]: cycle detected when computing the super predicates of `B`\n-  --> $DIR/cycle-trait-supertrait-indirect.rs:7:1\n-   |\n-LL | trait B: C {\n-   | ^^^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `B`...\n   --> $DIR/cycle-trait-supertrait-indirect.rs:7:10\n    |\n LL | trait B: C {\n    |          ^\n-note: ...which requires computing the super predicates of `C`...\n-  --> $DIR/cycle-trait-supertrait-indirect.rs:11:1\n    |\n-LL | trait C: B { }\n-   | ^^^^^^^^^^\n-note: ...which requires computing the super traits of `C`...\n+note: ...which requires computing the super predicates of `C`...\n   --> $DIR/cycle-trait-supertrait-indirect.rs:11:10\n    |\n LL | trait C: B { }\n    |          ^\n    = note: ...which again requires computing the super predicates of `B`, completing the cycle\n-note: cycle used when computing the super traits of `A`\n+note: cycle used when computing the super predicates of `A`\n   --> $DIR/cycle-trait-supertrait-indirect.rs:4:10\n    |\n LL | trait A: B {"}, {"sha": "683987b4943da1d5c2e1db32f6f90e3ab3cda2f2", "filename": "tests/ui/infinite/infinite-trait-alias-recursion.stderr", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Finfinite%2Finfinite-trait-alias-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Finfinite%2Finfinite-trait-alias-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite%2Finfinite-trait-alias-recursion.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1,30 +1,15 @@\n error[E0391]: cycle detected when computing the super predicates of `T1`\n-  --> $DIR/infinite-trait-alias-recursion.rs:3:1\n-   |\n-LL | trait T1 = T2;\n-   | ^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `T1`...\n   --> $DIR/infinite-trait-alias-recursion.rs:3:12\n    |\n LL | trait T1 = T2;\n    |            ^^\n-note: ...which requires computing the super predicates of `T2`...\n-  --> $DIR/infinite-trait-alias-recursion.rs:6:1\n    |\n-LL | trait T2 = T3;\n-   | ^^^^^^^^\n-note: ...which requires computing the super traits of `T2`...\n+note: ...which requires computing the super predicates of `T2`...\n   --> $DIR/infinite-trait-alias-recursion.rs:6:12\n    |\n LL | trait T2 = T3;\n    |            ^^\n note: ...which requires computing the super predicates of `T3`...\n-  --> $DIR/infinite-trait-alias-recursion.rs:8:1\n-   |\n-LL | trait T3 = T1 + T3;\n-   | ^^^^^^^^\n-note: ...which requires computing the super traits of `T3`...\n   --> $DIR/infinite-trait-alias-recursion.rs:8:12\n    |\n LL | trait T3 = T1 + T3;"}, {"sha": "558aad10946eca0c407253013f239032333e8dd3", "filename": "tests/ui/issues/issue-12511.stderr", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fissues%2Fissue-12511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fissues%2Fissue-12511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-12511.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1,20 +1,10 @@\n error[E0391]: cycle detected when computing the super predicates of `T1`\n-  --> $DIR/issue-12511.rs:1:1\n-   |\n-LL | trait T1 : T2 {\n-   | ^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `T1`...\n   --> $DIR/issue-12511.rs:1:12\n    |\n LL | trait T1 : T2 {\n    |            ^^\n-note: ...which requires computing the super predicates of `T2`...\n-  --> $DIR/issue-12511.rs:5:1\n    |\n-LL | trait T2 : T1 {\n-   | ^^^^^^^^^^^^^\n-note: ...which requires computing the super traits of `T2`...\n+note: ...which requires computing the super predicates of `T2`...\n   --> $DIR/issue-12511.rs:5:12\n    |\n LL | trait T2 : T1 {"}, {"sha": "416fd8c062fa3afe77654ba41fc227d5ebf5c68f", "filename": "tests/ui/issues/issue-20772.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fissues%2Fissue-20772.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Fissues%2Fissue-20772.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-20772.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -5,7 +5,7 @@ LL | trait T : Iterator<Item=Self::Item>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: ...which immediately requires computing the super traits of `T` with associated type name `Item` again\n-note: cycle used when computing the super traits of `T`\n+note: cycle used when computing the super predicates of `T`\n   --> $DIR/issue-20772.rs:1:1\n    |\n LL | trait T : Iterator<Item=Self::Item>"}, {"sha": "46f00c06bf1cadaab75c767128e0ce6f53ccb1ca", "filename": "tests/ui/lint/unused/trait-alias-supertrait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Flint%2Funused%2Ftrait-alias-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Flint%2Funused%2Ftrait-alias-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Ftrait-alias-supertrait.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+// Make sure that we only consider *Self* supertrait predicates\n+// in the `unused_must_use` lint.\n+\n+#![feature(trait_alias)]\n+#![deny(unused_must_use)]\n+\n+trait Foo<T> = Sized where T: Iterator;\n+\n+fn test<T: Iterator>() -> impl Foo<T> {}\n+\n+fn main() {\n+    test::<std::iter::Once<()>>();\n+}"}, {"sha": "4f9eaacb8ed068bc3896385f095ec5ae936eff46", "filename": "tests/ui/traits/alias/dont-elaborate-non-self.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -0,0 +1,10 @@\n+#![feature(trait_alias)]\n+\n+use std::future::Future;\n+\n+trait F<Fut: Future<Output = usize>> = Fn() -> Fut;\n+\n+fn f<Fut>(a: dyn F<Fut>) {}\n+//~^ ERROR the size for values of type `(dyn Fn() -> Fut + 'static)` cannot be known at compilation time\n+\n+fn main() {}"}, {"sha": "247a4f8128073a0a8b487babc3e7f204b6b569cf", "filename": "tests/ui/traits/alias/dont-elaborate-non-self.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Falias%2Fdont-elaborate-non-self.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -0,0 +1,20 @@\n+error[E0277]: the size for values of type `(dyn Fn() -> Fut + 'static)` cannot be known at compilation time\n+  --> $DIR/dont-elaborate-non-self.rs:7:11\n+   |\n+LL | fn f<Fut>(a: dyn F<Fut>) {}\n+   |           ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `(dyn Fn() -> Fut + 'static)`\n+   = help: unsized fn params are gated as an unstable feature\n+help: you can use `impl Trait` as the argument type\n+   |\n+LL | fn f<Fut>(a: impl F<Fut>) {}\n+   |              ~~~~\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL | fn f<Fut>(a: &dyn F<Fut>) {}\n+   |              +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4a5e445d1efbe0a7eb7dc0bfda9f6c0c10ef8c7e", "filename": "tests/ui/traits/trait-upcasting/alias-where-clause-isnt-supertrait.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.rs?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -0,0 +1,33 @@\n+#![feature(trait_upcasting)]\n+#![feature(trait_alias)]\n+\n+// Although we *elaborate* `T: Alias` to `i32: B`, we should\n+// not consider `B` to be a supertrait of the type.\n+trait Alias = A where i32: B;\n+\n+trait A {}\n+\n+trait B {\n+    fn test(&self);\n+}\n+\n+trait C: Alias {}\n+\n+impl A for () {}\n+\n+impl C for () {}\n+\n+impl B for i32 {\n+    fn test(&self) {\n+        println!(\"hi {self}\");\n+    }\n+}\n+\n+fn test(x: &dyn C) -> &dyn B {\n+    x\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {\n+    let x: &dyn C = &();\n+}"}, {"sha": "5574a0320895e0bd28c9c41eafdea51d468a7567", "filename": "tests/ui/traits/trait-upcasting/alias-where-clause-isnt-supertrait.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Falias-where-clause-isnt-supertrait.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/alias-where-clause-isnt-supertrait.rs:27:5\n+   |\n+LL | fn test(x: &dyn C) -> &dyn B {\n+   |                       ------ expected `&dyn B` because of return type\n+LL |     x\n+   |     ^ expected trait `B`, found trait `C`\n+   |\n+   = note: expected reference `&dyn B`\n+              found reference `&dyn C`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ca98e1831507e6733c904d1ef3243a6f4167c4a0", "filename": "tests/ui/traits/trait-upcasting/cyclic-trait-resolution.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9be9b5e09ad834e2ba9f2571ca17059e18f89b71/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Ftrait-upcasting%2Fcyclic-trait-resolution.stderr?ref=9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "patch": "@@ -1,15 +1,10 @@\n error[E0391]: cycle detected when computing the super predicates of `A`\n-  --> $DIR/cyclic-trait-resolution.rs:1:1\n-   |\n-LL | trait A: B + A {}\n-   | ^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing the super traits of `A`...\n   --> $DIR/cyclic-trait-resolution.rs:1:14\n    |\n LL | trait A: B + A {}\n    |              ^\n-   = note: ...which again requires computing the super predicates of `A`, completing the cycle\n+   |\n+   = note: ...which immediately requires computing the super predicates of `A` again\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cyclic-trait-resolution.rs:1:1\n    |"}]}