{"sha": "1528256fdc26199dd58b390e42e2d0dc53b9703d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MjgyNTZmZGMyNjE5OWRkNThiMzkwZTQyZTJkMGRjNTNiOTcwM2Q=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T21:41:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-18T21:43:16Z"}, "message": "rustc: Encode metadata unconditionally for impls/traits/classes. Closes #2945.", "tree": {"sha": "687ad465aa1fe4026f7448322e0718b6cee62d2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/687ad465aa1fe4026f7448322e0718b6cee62d2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1528256fdc26199dd58b390e42e2d0dc53b9703d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1528256fdc26199dd58b390e42e2d0dc53b9703d", "html_url": "https://github.com/rust-lang/rust/commit/1528256fdc26199dd58b390e42e2d0dc53b9703d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1528256fdc26199dd58b390e42e2d0dc53b9703d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c936ae515bdcebd184309c709540b512fc6f7c59", "url": "https://api.github.com/repos/rust-lang/rust/commits/c936ae515bdcebd184309c709540b512fc6f7c59", "html_url": "https://github.com/rust-lang/rust/commit/c936ae515bdcebd184309c709540b512fc6f7c59"}], "stats": {"total": 63, "additions": 37, "deletions": 26}, "files": [{"sha": "970be7ea53f40dbae9762cc000d7219108059cab", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1528256fdc26199dd58b390e42e2d0dc53b9703d/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1528256fdc26199dd58b390e42e2d0dc53b9703d/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=1528256fdc26199dd58b390e42e2d0dc53b9703d", "patch": "@@ -600,6 +600,8 @@ fn get_impls_for_mod(cdata: cmd,\n     do ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n         let did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n+        #debug(\"(get impls for mod) getting did %? for '%?'\",\n+               local_did, name);\n           // The impl may be defined in a different crate. Ask the caller\n           // to give us the metadata\n         let impl_cdata = get_cdata(local_did.crate);"}, {"sha": "4df1e0aa513ddba650bbb8dcbb009ade2350ac5d", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1528256fdc26199dd58b390e42e2d0dc53b9703d/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1528256fdc26199dd58b390e42e2d0dc53b9703d/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=1528256fdc26199dd58b390e42e2d0dc53b9703d", "patch": "@@ -396,32 +396,34 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     let impls = ecx.impl_map(id);\n     for impls.each |i| {\n         let (ident, did) = i;\n-        #debug(\"(encoding info for module) ... encoding impl %s (%?), \\\n+        #debug(\"(encoding info for module) ... encoding impl %s (%?/%?), \\\n                 exported? %?\",\n-               *ident, did, ast_util::is_exported(ident, md));\n-        if ast_util::is_exported(ident, md) {\n-            ebml_w.start_tag(tag_mod_impl);\n-            alt ecx.tcx.items.find(did.node) {\n-              some(ast_map::node_item(it@@{node: cl@item_class(*),_},_)) {\n-            /* If did stands for a trait\n-            ref, we need to map it to its parent class */\n-                ebml_w.wr_str(def_to_str(local_def(it.id)));\n-              }\n-              some(ast_map::node_item(@{node: item_impl(_,\n-                                                   some(ifce),_,_),_},_)) {\n-                ebml_w.wr_str(def_to_str(did));\n-              }\n-              some(_) {\n-                ebml_w.wr_str(def_to_str(did));\n-              }\n-              none {\n-                // Must be a re-export, then!\n-                // ...or an iface ref\n-                ebml_w.wr_str(def_to_str(did));\n-              }\n-            };\n-            ebml_w.end_tag();\n-        } // if\n+               *ident,\n+               did,\n+               ast_map::node_id_to_str(ecx.tcx.items, did.node),\n+               ast_util::is_exported(ident, md));\n+\n+        ebml_w.start_tag(tag_mod_impl);\n+        alt ecx.tcx.items.find(did.node) {\n+          some(ast_map::node_item(it@@{node: cl@item_class(*),_},_)) {\n+        /* If did stands for a trait\n+        ref, we need to map it to its parent class */\n+            ebml_w.wr_str(def_to_str(local_def(it.id)));\n+          }\n+          some(ast_map::node_item(@{node: item_impl(_,\n+                                               some(ifce),_,_),_},_)) {\n+            ebml_w.wr_str(def_to_str(did));\n+          }\n+          some(_) {\n+            ebml_w.wr_str(def_to_str(did));\n+          }\n+          none {\n+            // Must be a re-export, then!\n+            // ...or an iface ref\n+            ebml_w.wr_str(def_to_str(did));\n+          }\n+        };\n+        ebml_w.end_tag();\n     } // for\n \n     encode_path(ebml_w, path, ast_map::path_mod(name));\n@@ -552,7 +554,14 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n     let tcx = ecx.tcx;\n     let must_write =\n-        alt item.node { item_enum(_, _) { true } _ { false } };\n+        alt item.node {\n+            item_enum(_, _) | item_impl(*) | item_trait(*) | item_class(*) {\n+                true\n+            }\n+            _ {\n+                false\n+            }\n+        };\n     if !must_write && !reachable(ecx, item.id) { ret; }\n \n     fn add_to_index_(item: @item, ebml_w: ebml::writer,"}]}