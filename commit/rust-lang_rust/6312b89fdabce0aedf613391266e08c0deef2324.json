{"sha": "6312b89fdabce0aedf613391266e08c0deef2324", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMTJiODlmZGFiY2UwYWVkZjYxMzM5MTI2NmUwOGMwZGVlZjIzMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-08T01:34:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-08T01:34:53Z"}, "message": "Auto merge of #61649 - Centril:rollup-b4nx9k9, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #61223 (Document tuple's Ord behavior as sequential)\n - #61615 (syntax: Treat error literals in more principled way)\n - #61616 (parser: Remove `Deref` impl from `Parser`)\n - #61621 (Clarify when we run steps with ONLY_HOSTS)\n - #61627 (Add regression test for #61452.)\n - #61641 (Revert \"Make LocalAnalizer visitor iterate instead of recurse\")\n - #61647 (Use stable wrappers in f32/f64::signum)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "e83b9416488a0e17858bf4e24a51810c003c4712", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e83b9416488a0e17858bf4e24a51810c003c4712"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6312b89fdabce0aedf613391266e08c0deef2324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6312b89fdabce0aedf613391266e08c0deef2324", "html_url": "https://github.com/rust-lang/rust/commit/6312b89fdabce0aedf613391266e08c0deef2324", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6312b89fdabce0aedf613391266e08c0deef2324/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d132f544f9d74e3cc047ef211e57eae60b78e5c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d132f544f9d74e3cc047ef211e57eae60b78e5c5", "html_url": "https://github.com/rust-lang/rust/commit/d132f544f9d74e3cc047ef211e57eae60b78e5c5"}, {"sha": "b3bdc24a89de1b014490fed3394cd359430eec9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3bdc24a89de1b014490fed3394cd359430eec9f", "html_url": "https://github.com/rust-lang/rust/commit/b3bdc24a89de1b014490fed3394cd359430eec9f"}], "stats": {"total": 728, "additions": 378, "deletions": 350}, "files": [{"sha": "2281a45e014a9cb0d89ddb4004bc8ae01c274076", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -59,7 +59,7 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n \n     const DEFAULT: bool = false;\n \n-    /// Run this rule for all hosts without cross compiling.\n+    /// If true, then this rule should be skipped if --target was specified, but --host was not\n     const ONLY_HOSTS: bool = false;\n \n     /// Primary function to execute this rule. Can call `builder.ensure()`\n@@ -163,7 +163,7 @@ impl StepDescription {\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            if !builder.config.run_host_only {\n+            if builder.config.skip_only_host_steps {\n                 return; // don't run anything\n             } else {\n                 &builder.hosts\n@@ -1338,7 +1338,7 @@ mod __test {\n         let mut config = Config::default_opts();\n         // don't save toolstates\n         config.save_toolstates = None;\n-        config.run_host_only = true;\n+        config.skip_only_host_steps = false;\n         config.dry_run = true;\n         // try to avoid spurious failures in dist where we create/delete each others file\n         let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n@@ -1583,7 +1583,7 @@ mod __test {\n     #[test]\n     fn dist_with_target_flag() {\n         let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.run_host_only = false; // as-if --target=C was passed\n+        config.skip_only_host_steps = true; // as-if --target=C was passed\n         let build = Build::new(config);\n         let mut builder = Builder::new(&build);\n         builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n@@ -1831,7 +1831,7 @@ mod __test {\n     #[test]\n     fn build_with_target_flag() {\n         let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.run_host_only = false;\n+        config.skip_only_host_steps = true;\n         let build = Build::new(config);\n         let mut builder = Builder::new(&build);\n         builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);"}, {"sha": "66f504ea924e9b880b525ea47409d29db868286e", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -51,7 +51,7 @@ pub struct Config {\n     pub test_compare_mode: bool,\n     pub llvm_libunwind: bool,\n \n-    pub run_host_only: bool,\n+    pub skip_only_host_steps: bool,\n \n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n@@ -416,7 +416,9 @@ impl Config {\n         }\n \n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n-        config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n+        let has_hosts = !flags.host.is_empty();\n+        let has_targets = !flags.target.is_empty();\n+        config.skip_only_host_steps = !has_hosts && has_targets;\n \n         let toml = file.map(|file| {\n             let contents = t!(fs::read_to_string(&file));"}, {"sha": "f4f9d6261de4806c6e07d834a756eae729142987", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -1020,7 +1020,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprKind::Lit(_) => {}\n         ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n@@ -1093,7 +1092,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprKind::Yield(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n     }\n }\n "}, {"sha": "e0c01277801d45b7107f24b83e9ec3d25018aca4", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -170,14 +170,14 @@ impl_stable_hash_for!(struct ::syntax::ast::Lit {\n \n impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n     Str(value, style),\n-    Err(value),\n     ByteStr(value),\n     Byte(value),\n     Char(value),\n     Int(value, lit_int_type),\n     Float(value, float_ty),\n     FloatUnsuffixed(value),\n-    Bool(value)\n+    Bool(value),\n+    Err(value)\n });\n \n impl_stable_hash_for_spanned!(::syntax::ast::LitKind);"}, {"sha": "bb6a13ed15a52cdeb3f3485ac6c69b56825456e4", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -154,62 +154,51 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                    context: PlaceContext,\n                    location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n-        let mut context = context;\n         let cx = self.fx.cx;\n \n-        place.iterate(|place_base, place_projections| {\n-            for proj in place_projections {\n-                // Allow uses of projections that are ZSTs or from scalar fields.\n-                let is_consume = match context {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n-                    _ => false\n-                };\n-                if is_consume {\n-                    let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n-                    let base_ty = self.fx.monomorphize(&base_ty);\n-\n-                    // ZSTs don't require any actual memory access.\n-                    let elem_ty = base_ty\n-                        .projection_ty(cx.tcx(), &proj.elem)\n-                        .ty;\n-                    let elem_ty = self.fx.monomorphize(&elem_ty);\n-                    if cx.layout_of(elem_ty).is_zst() {\n-                        return;\n-                    }\n-\n-                    if let mir::ProjectionElem::Field(..) = proj.elem {\n-                        let layout = cx.layout_of(base_ty.ty);\n-                        if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n-                            // Recurse with the same context, instead of `Projection`,\n-                            // potentially stopping at non-operand projections,\n-                            // which would trigger `not_ssa` on locals.\n-                            continue;\n-                        }\n-                    }\n+        if let mir::Place::Projection(ref proj) = *place {\n+            // Allow uses of projections that are ZSTs or from scalar fields.\n+            let is_consume = match context {\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => true,\n+                _ => false\n+            };\n+            if is_consume {\n+                let base_ty = proj.base.ty(self.fx.mir, cx.tcx());\n+                let base_ty = self.fx.monomorphize(&base_ty);\n+\n+                // ZSTs don't require any actual memory access.\n+                let elem_ty = base_ty\n+                    .projection_ty(cx.tcx(), &proj.elem)\n+                    .ty;\n+                let elem_ty = self.fx.monomorphize(&elem_ty);\n+                if cx.layout_of(elem_ty).is_zst() {\n+                    return;\n                 }\n \n-                // A deref projection only reads the pointer, never needs the place.\n-                if let mir::ProjectionElem::Deref = proj.elem {\n-                    return self.visit_place(\n-                        &proj.base,\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                        location\n-                    );\n+                if let mir::ProjectionElem::Field(..) = proj.elem {\n+                    let layout = cx.layout_of(base_ty.ty);\n+                    if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n+                        // Recurse with the same context, instead of `Projection`,\n+                        // potentially stopping at non-operand projections,\n+                        // which would trigger `not_ssa` on locals.\n+                        self.visit_place(&proj.base, context, location);\n+                        return;\n+                    }\n                 }\n-\n-                context = if context.is_mutating_use() {\n-                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                } else {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                };\n             }\n \n-            // Default base visit behavior\n-            if let mir::PlaceBase::Local(local) = place_base {\n-                self.visit_local(local, context, location);\n+            // A deref projection only reads the pointer, never needs the place.\n+            if let mir::ProjectionElem::Deref = proj.elem {\n+                return self.visit_place(\n+                    &proj.base,\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                    location\n+                );\n             }\n-        });\n+        }\n+\n+        self.super_place(place, context, location);\n     }\n \n     fn visit_local(&mut self,"}, {"sha": "b5604f4cb0f8eda5cf1920641716852d95a3729d", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -34,15 +34,6 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         },\n-        LitKind::Err(ref s) => {\n-            let s = s.as_str();\n-            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes());\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            return Ok(tcx.mk_const(ty::Const {\n-                val: ConstValue::Slice{ data: allocation, start: 0, end: s.len() },\n-                ty: tcx.types.err,\n-            }));\n-        },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n@@ -66,6 +57,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n         }\n         LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n         LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n+        LitKind::Err(_) => unreachable!(),\n     };\n     Ok(tcx.mk_const(ty::Const { val: lit, ty }))\n }"}, {"sha": "7254c621611615c119cc736d6a9e9b970e155b7e", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -188,7 +188,7 @@ impl f32 {\n         if self.is_nan() {\n             NAN\n         } else {\n-            unsafe { intrinsics::copysignf32(1.0, self) }\n+            1.0_f32.copysign(self)\n         }\n     }\n "}, {"sha": "f8bb36ad0a89ed0fa4d6342d27a8af6152a0148f", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -166,7 +166,7 @@ impl f64 {\n         if self.is_nan() {\n             NAN\n         } else {\n-            unsafe { intrinsics::copysignf64(1.0, self) }\n+            1.0_f64.copysign(self)\n         }\n     }\n "}, {"sha": "42b64d2b5a5ff21c3e655a619bf008b5a7f0236e", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -683,6 +683,10 @@ mod prim_str { }\n /// assert_eq!(tuple.2, 'c');\n /// ```\n ///\n+/// The sequential nature of the tuple applies to its implementations of various\n+/// traits.  For example, in `PartialOrd` and `Ord`, the elements are compared\n+/// sequentially until the first non-equal set is found.\n+///\n /// For more about tuples, see [the book](../book/ch03-02-data-types.html#the-tuple-type).\n ///\n /// # Trait implementations"}, {"sha": "02fbcb14fa599a25b20811ffb92a922bb6f98294", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -1368,7 +1368,7 @@ pub enum LitKind {\n     FloatUnsuffixed(Symbol),\n     /// A boolean literal.\n     Bool(bool),\n-    /// A recovered character literal that contains mutliple `char`s, most likely a typo.\n+    /// Placeholder for a literal that wasn't well-formed in some way.\n     Err(Symbol),\n }\n \n@@ -1406,10 +1406,10 @@ impl LitKind {\n             | LitKind::ByteStr(..)\n             | LitKind::Byte(..)\n             | LitKind::Char(..)\n-            | LitKind::Err(..)\n             | LitKind::Int(_, LitIntType::Unsuffixed)\n             | LitKind::FloatUnsuffixed(..)\n-            | LitKind::Bool(..) => true,\n+            | LitKind::Bool(..)\n+            | LitKind::Err(..) => true,\n             // suffixed variants\n             LitKind::Int(_, LitIntType::Signed(..))\n             | LitKind::Int(_, LitIntType::Unsigned(..))"}, {"sha": "b5d9b761773b4223fcfad2c08969481195f5f0cf", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -735,9 +735,9 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n             raw_attr.clone(),\n         );\n \n-        let start_span = parser.span;\n+        let start_span = parser.token.span;\n         let (path, tokens) = panictry!(parser.parse_meta_item_unrestricted());\n-        let end_span = parser.span;\n+        let end_span = parser.token.span;\n         if parser.token != token::Eof {\n             parse_sess.span_diagnostic\n                 .span_err(start_span.to(end_span), \"invalid crate attribute\");"}, {"sha": "6123e95ccf8213ea31b8c0762f1d61bc14a74cba", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -121,7 +121,7 @@ impl<'a> StripUnconfigured<'a> {\n             let mut expanded_attrs = Vec::with_capacity(1);\n \n             while !parser.check(&token::CloseDelim(token::Paren)) {\n-                let lo = parser.span.lo();\n+                let lo = parser.token.span.lo();\n                 let (path, tokens) = parser.parse_meta_item_unrestricted()?;\n                 expanded_attrs.push((path, tokens, parser.prev_span.with_lo(lo)));\n                 parser.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Paren)])?;"}, {"sha": "9960539555332dd99bd18b638c5b33d3a49bc97d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -1041,7 +1041,7 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n             // Avoid emitting backtrace info twice.\n-            let def_site_span = self.span.with_ctxt(SyntaxContext::empty());\n+            let def_site_span = self.token.span.with_ctxt(SyntaxContext::empty());\n             let mut err = self.diagnostic().struct_span_err(def_site_span, &msg);\n             err.span_label(span, \"caused by the macro expansion here\");\n             let msg = format!("}, {"sha": "4e2aab46542d203030675f84fb5c3045157ffbb8", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -105,7 +105,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: &[tokenstrea\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n-                    None => self.p.diagnostic().span_fatal(self.p.span,\n+                    None => self.p.diagnostic().span_fatal(self.p.token.span,\n                                                            &format!(\"expected item, found `{}`\",\n                                                                     self.p.this_token_to_string()))\n                                                .raise()"}, {"sha": "f98e1433356c27fda1145e71fd7746ed9bad02fa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -675,7 +675,7 @@ pub fn parse(\n     //\n     // This MatcherPos instance is allocated on the stack. All others -- and\n     // there are frequently *no* others! -- are allocated on the heap.\n-    let mut initial = initial_matcher_pos(ms, parser.span);\n+    let mut initial = initial_matcher_pos(ms, parser.token.span);\n     let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];\n     let mut next_items = Vec::new();\n \n@@ -721,15 +721,15 @@ pub fn parse(\n                 return nameize(sess, ms, matches);\n             } else if eof_items.len() > 1 {\n                 return Error(\n-                    parser.span,\n+                    parser.token.span,\n                     \"ambiguity: multiple successful parses\".to_string(),\n                 );\n             } else {\n                 return Failure(\n-                    Token::new(token::Eof, if parser.span.is_dummy() {\n-                        parser.span\n+                    Token::new(token::Eof, if parser.token.span.is_dummy() {\n+                        parser.token.span\n                     } else {\n-                        sess.source_map().next_point(parser.span)\n+                        sess.source_map().next_point(parser.token.span)\n                     }),\n                     \"missing tokens in macro arguments\",\n                 );\n@@ -753,7 +753,7 @@ pub fn parse(\n                 .join(\" or \");\n \n             return Error(\n-                parser.span,\n+                parser.token.span,\n                 format!(\n                     \"local ambiguity: multiple parsing options: {}\",\n                     match next_items.len() {\n@@ -927,7 +927,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> Nonterminal {\n         sym::ty => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n         sym::ident => if let Some((name, is_raw)) = get_macro_name(&p.token) {\n-            let span = p.span;\n+            let span = p.token.span;\n             p.bump();\n             token::NtIdent(Ident::new(name, span), is_raw)\n         } else {"}, {"sha": "4998129fdee5113bcb8c66bd688e024d69a3573e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -47,7 +47,7 @@ impl<'a> ParserAnyMacro<'a> {\n         let fragment = panictry!(parser.parse_ast_fragment(kind, true).map_err(|mut e| {\n             if parser.token == token::Eof && e.message().ends_with(\", found `<eof>`\") {\n                 if !e.span.is_dummy() {  // early end of macro arm (#52866)\n-                    e.replace_span_with(parser.sess.source_map().next_point(parser.span));\n+                    e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n                 }\n                 let msg = &e.message[0];\n                 e.message[0] = (\n@@ -63,7 +63,7 @@ impl<'a> ParserAnyMacro<'a> {\n                 if parser.sess.source_map().span_to_filename(arm_span).is_real() {\n                     e.span_label(arm_span, \"in this macro arm\");\n                 }\n-            } else if !parser.sess.source_map().span_to_filename(parser.span).is_real() {\n+            } else if !parser.sess.source_map().span_to_filename(parser.token.span).is_real() {\n                 e.span_label(site_span, \"in this macro invocation\");\n             }\n             e"}, {"sha": "2889f8edfc64cc4d4cc9ea441c8c852f35d1b624", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -1101,7 +1101,6 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n             vis.visit_expr(rhs);\n         }\n         ExprKind::Unary(_unop, ohs) => vis.visit_expr(ohs),\n-        ExprKind::Lit(_lit) => {}\n         ExprKind::Cast(expr, ty) => {\n             vis.visit_expr(expr);\n             vis.visit_ty(ty);\n@@ -1225,7 +1224,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n         }\n         ExprKind::Try(expr) => vis.visit_expr(expr),\n         ExprKind::TryBlock(body) => vis.visit_block(body),\n-        ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n     }\n     vis.visit_id(id);\n     vis.visit_span(span);"}, {"sha": "77a87e26e60d596ff4543d5fc794a0d309b46ad6", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -39,7 +39,7 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.span);\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.token.span);\n                     if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -83,7 +83,7 @@ impl<'a> Parser<'a> {\n                self.token);\n         let (span, path, tokens, style) = match self.token.kind {\n             token::Pound => {\n-                let lo = self.span;\n+                let lo = self.token.span;\n                 self.bump();\n \n                 if let InnerAttributeParsePolicy::Permitted = inner_parse_policy {\n@@ -93,7 +93,7 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     if let InnerAttributeParsePolicy::NotPermitted { reason } = inner_parse_policy\n                     {\n-                        let span = self.span;\n+                        let span = self.token.span;\n                         self.diagnostic()\n                             .struct_span_err(span, reason)\n                             .note(\"inner attributes, like `#![no_std]`, annotate the item \\\n@@ -201,7 +201,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.span);\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.token.span);\n                     if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();\n@@ -249,7 +249,7 @@ impl<'a> Parser<'a> {\n             return Ok(meta);\n         }\n \n-        let lo = self.span;\n+        let lo = self.token.span;\n         let path = self.parse_path(PathStyle::Mod)?;\n         let node = self.parse_meta_item_kind()?;\n         let span = lo.to(self.prev_span);\n@@ -284,7 +284,7 @@ impl<'a> Parser<'a> {\n \n         let found = self.this_token_to_string();\n         let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n-        Err(self.diagnostic().struct_span_err(self.span, &msg))\n+        Err(self.diagnostic().struct_span_err(self.token.span, &msg))\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item_inner) )"}, {"sha": "c4db9a9df45a92973ef4c5ec2e941e44857f8b3f", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -162,7 +162,7 @@ impl RecoverQPath for Expr {\n \n impl<'a> Parser<'a> {\n     pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n-        self.span_fatal(self.span, m)\n+        self.span_fatal(self.token.span, m)\n     }\n \n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n@@ -174,7 +174,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn bug(&self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(self.span, m)\n+        self.sess.span_diagnostic.span_bug(self.token.span, m)\n     }\n \n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n@@ -199,26 +199,26 @@ impl<'a> Parser<'a> {\n \n     crate fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n         let mut err = self.struct_span_err(\n-            self.span,\n+            self.token.span,\n             &format!(\"expected identifier, found {}\", self.this_token_descr()),\n         );\n         if let token::Ident(name, false) = self.token.kind {\n-            if Ident::new(name, self.span).is_raw_guess() {\n+            if Ident::new(name, self.token.span).is_raw_guess() {\n                 err.span_suggestion(\n-                    self.span,\n+                    self.token.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n                     format!(\"r#{}\", name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n         }\n         if let Some(token_descr) = self.token_descr() {\n-            err.span_label(self.span, format!(\"expected identifier, found {}\", token_descr));\n+            err.span_label(self.token.span, format!(\"expected identifier, found {}\", token_descr));\n         } else {\n-            err.span_label(self.span, \"expected identifier\");\n+            err.span_label(self.token.span, \"expected identifier\");\n             if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n                 err.span_suggestion(\n-                    self.span,\n+                    self.token.span,\n                     \"remove this comma\",\n                     String::new(),\n                     Applicability::MachineApplicable,\n@@ -277,19 +277,19 @@ impl<'a> Parser<'a> {\n                 (self.sess.source_map().next_point(self.prev_span),\n                 format!(\"expected {} here\", expect)))\n         };\n-        self.last_unexpected_token_span = Some(self.span);\n+        self.last_unexpected_token_span = Some(self.token.span);\n         let mut err = self.fatal(&msg_exp);\n         if self.token.is_ident_named(sym::and) {\n             err.span_suggestion_short(\n-                self.span,\n+                self.token.span,\n                 \"use `&&` instead of `and` for the boolean operator\",\n                 \"&&\".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n         }\n         if self.token.is_ident_named(sym::or) {\n             err.span_suggestion_short(\n-                self.span,\n+                self.token.span,\n                 \"use `||` instead of `or` for the boolean operator\",\n                 \"||\".to_string(),\n                 Applicability::MaybeIncorrect,\n@@ -326,7 +326,7 @@ impl<'a> Parser<'a> {\n             self.token.is_keyword(kw::While)\n         );\n         let cm = self.sess.source_map();\n-        match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n+        match (cm.lookup_line(self.token.span.lo()), cm.lookup_line(sp.lo())) {\n             (Ok(ref a), Ok(ref b)) if a.line != b.line && is_semi_suggestable => {\n                 // The spans are in different lines, expected `;` and found `let` or `return`.\n                 // High likelihood that it is only a missing `;`.\n@@ -352,16 +352,16 @@ impl<'a> Parser<'a> {\n                 //   |                   -^^^^^ unexpected token\n                 //   |                   |\n                 //   |                   expected one of 8 possible tokens here\n-                err.span_label(self.span, label_exp);\n+                err.span_label(self.token.span, label_exp);\n             }\n             _ if self.prev_span == syntax_pos::DUMMY_SP => {\n                 // Account for macro context where the previous span might not be\n                 // available to avoid incorrect output (#54841).\n-                err.span_label(self.span, \"unexpected token\");\n+                err.span_label(self.token.span, \"unexpected token\");\n             }\n             _ => {\n                 err.span_label(sp, label_exp);\n-                err.span_label(self.span, \"unexpected token\");\n+                err.span_label(self.token.span, \"unexpected token\");\n             }\n         }\n         Err(err)\n@@ -429,7 +429,7 @@ impl<'a> Parser<'a> {\n \n         // Keep the span at the start so we can highlight the sequence of `>` characters to be\n         // removed.\n-        let lo = self.span;\n+        let lo = self.token.span;\n \n         // We need to look-ahead to see if we have `>` characters without moving the cursor forward\n         // (since we might have the field access case and the characters we're eating are\n@@ -474,7 +474,7 @@ impl<'a> Parser<'a> {\n             // Eat from where we started until the end token so that parsing can continue\n             // as if we didn't have those extra angle brackets.\n             self.eat_to_tokens(&[&end]);\n-            let span = lo.until(self.span);\n+            let span = lo.until(self.token.span);\n \n             let plural = number_of_gt > 1 || number_of_shr >= 1;\n             self.diagnostic()\n@@ -502,7 +502,7 @@ impl<'a> Parser<'a> {\n         match lhs.node {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n-                let op_span = op.span.to(self.span);\n+                let op_span = op.span.to(self.token.span);\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n                 if op.node == BinOpKind::Lt &&\n@@ -734,15 +734,15 @@ impl<'a> Parser<'a> {\n         let (prev_sp, sp) = match (&self.token.kind, self.subparser_name) {\n             // Point at the end of the macro call when reaching end of macro arguments.\n             (token::Eof, Some(_)) => {\n-                let sp = self.sess.source_map().next_point(self.span);\n+                let sp = self.sess.source_map().next_point(self.token.span);\n                 (sp, sp)\n             }\n             // We don't want to point at the following span after DUMMY_SP.\n             // This happens when the parser finds an empty TokenStream.\n-            _ if self.prev_span == DUMMY_SP => (self.span, self.span),\n+            _ if self.prev_span == DUMMY_SP => (self.token.span, self.token.span),\n             // EOF, don't want to point at the following char, but rather the last token.\n-            (token::Eof, None) => (self.prev_span, self.span),\n-            _ => (self.sess.source_map().next_point(self.prev_span), self.span),\n+            (token::Eof, None) => (self.prev_span, self.token.span),\n+            _ => (self.sess.source_map().next_point(self.prev_span), self.token.span),\n         };\n         let msg = format!(\n             \"expected `{}`, found {}\",\n@@ -789,7 +789,7 @@ impl<'a> Parser<'a> {\n             // interpreting `await { <expr> }?` as `<expr>?.await`.\n             self.parse_block_expr(\n                 None,\n-                self.span,\n+                self.token.span,\n                 BlockCheckMode::Default,\n                 ThinVec::new(),\n             )\n@@ -819,9 +819,9 @@ impl<'a> Parser<'a> {\n             self.look_ahead(1, |t| t == &token::CloseDelim(token::Paren))\n         {\n             // future.await()\n-            let lo = self.span;\n+            let lo = self.token.span;\n             self.bump(); // (\n-            let sp = lo.to(self.span);\n+            let sp = lo.to(self.token.span);\n             self.bump(); // )\n             self.struct_span_err(sp, \"incorrect use of `await`\")\n                 .span_suggestion(\n@@ -854,7 +854,7 @@ impl<'a> Parser<'a> {\n         next_sp: Span,\n         maybe_path: bool,\n     ) {\n-        err.span_label(self.span, \"expecting a type here because of type ascription\");\n+        err.span_label(self.token.span, \"expecting a type here because of type ascription\");\n         let cm = self.sess.source_map();\n         let next_pos = cm.lookup_char_pos(next_sp.lo());\n         let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n@@ -911,7 +911,7 @@ impl<'a> Parser<'a> {\n         // we want to use the last closing delim that would apply\n         for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n             if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n-                && Some(self.span) > unmatched.unclosed_span\n+                && Some(self.token.span) > unmatched.unclosed_span\n             {\n                 pos = Some(i);\n             }\n@@ -1070,28 +1070,28 @@ impl<'a> Parser<'a> {\n     crate fn expected_semi_or_open_brace(&mut self) -> PResult<'a, ast::TraitItem> {\n         let token_str = self.this_token_descr();\n         let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n-        err.span_label(self.span, \"expected `;` or `{`\");\n+        err.span_label(self.token.span, \"expected `;` or `{`\");\n         Err(err)\n     }\n \n     crate fn eat_incorrect_doc_comment(&mut self, applied_to: &str) {\n         if let token::DocComment(_) = self.token.kind {\n             let mut err = self.diagnostic().struct_span_err(\n-                self.span,\n+                self.token.span,\n                 &format!(\"documentation comments cannot be applied to {}\", applied_to),\n             );\n-            err.span_label(self.span, \"doc comments are not allowed here\");\n+            err.span_label(self.token.span, \"doc comments are not allowed here\");\n             err.emit();\n             self.bump();\n         } else if self.token == token::Pound && self.look_ahead(1, |t| {\n             *t == token::OpenDelim(token::Bracket)\n         }) {\n-            let lo = self.span;\n+            let lo = self.token.span;\n             // Skip every token until next possible arg.\n             while self.token != token::CloseDelim(token::Bracket) {\n                 self.bump();\n             }\n-            let sp = lo.to(self.span);\n+            let sp = lo.to(self.token.span);\n             self.bump();\n             let mut err = self.diagnostic().struct_span_err(\n                 sp,\n@@ -1217,16 +1217,16 @@ impl<'a> Parser<'a> {\n     crate fn expected_expression_found(&self) -> DiagnosticBuilder<'a> {\n         let (span, msg) = match (&self.token.kind, self.subparser_name) {\n             (&token::Eof, Some(origin)) => {\n-                let sp = self.sess.source_map().next_point(self.span);\n+                let sp = self.sess.source_map().next_point(self.token.span);\n                 (sp, format!(\"expected expression, found end of {}\", origin))\n             }\n-            _ => (self.span, format!(\n+            _ => (self.token.span, format!(\n                 \"expected expression, found {}\",\n                 self.this_token_descr(),\n             )),\n         };\n         let mut err = self.struct_span_err(span, &msg);\n-        let sp = self.sess.source_map().start_point(self.span);\n+        let sp = self.sess.source_map().start_point(self.token.span);\n         if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n             self.sess.expr_parentheses_needed(&mut err, *sp, None);\n         }"}, {"sha": "84f7386235fd3728bdcd339c2bad79a2fcb8d1b6", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -271,14 +271,13 @@ impl<'a> Parser<'a> {\n         let mut recovered = None;\n         if self.token == token::Dot {\n             // Attempt to recover `.4` as `0.4`.\n-            recovered = self.look_ahead(1, |t| {\n+            recovered = self.look_ahead(1, |next_token| {\n                 if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix })\n-                        = t.kind {\n-                    let next_span = self.look_ahead_span(1);\n-                    if self.span.hi() == next_span.lo() {\n+                        = next_token.kind {\n+                    if self.token.span.hi() == next_token.span.lo() {\n                         let s = String::from(\"0.\") + &symbol.as_str();\n                         let kind = TokenKind::lit(token::Float, Symbol::intern(&s), suffix);\n-                        return Some(Token::new(kind, self.span.to(next_span)));\n+                        return Some(Token::new(kind, self.token.span.to(next_token.span)));\n                     }\n                 }\n                 None\n@@ -311,7 +310,11 @@ impl<'a> Parser<'a> {\n                 let (lit, span) = (token.expect_lit(), token.span);\n                 self.bump();\n                 err.report(&self.sess.span_diagnostic, lit, span);\n-                let lit = token::Lit::new(token::Err, lit.symbol, lit.suffix);\n+                // Pack possible quotes and prefixes from the original literal into\n+                // the error literal's symbol so they can be pretty-printed faithfully.\n+                let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n+                let symbol = Symbol::intern(&pprust::literal_to_string(suffixless_lit));\n+                let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n                 Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n             }\n         }"}, {"sha": "1d708d39a1379ad5355ead28694f2803cebb765b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -239,8 +239,8 @@ fn maybe_source_file_to_parser(\n     let (stream, unclosed_delims) = maybe_file_to_stream(sess, source_file, None)?;\n     let mut parser = stream_to_parser(sess, stream, None);\n     parser.unclosed_delims = unclosed_delims;\n-    if parser.token == token::Eof && parser.span.is_dummy() {\n-        parser.token.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n+    if parser.token == token::Eof && parser.token.span.is_dummy() {\n+        parser.token.span = Span::new(end_pos, end_pos, parser.token.span.ctxt());\n     }\n \n     Ok(parser)"}, {"sha": "3acd7088145602860ed38ef00db3860ec829eb57", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 191, "deletions": 200, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -34,6 +34,7 @@ use crate::ast::{BinOpKind, UnOp};\n use crate::ast::{RangeEnd, RangeSyntax};\n use crate::{ast, attr};\n use crate::ext::base::DummyResult;\n+use crate::ext::hygiene::SyntaxContext;\n use crate::source_map::{self, SourceMap, Spanned, respan};\n use crate::parse::{SeqSep, classify, literal, token};\n use crate::parse::lexer::UnmatchedBrace;\n@@ -57,7 +58,6 @@ use log::debug;\n use std::borrow::Cow;\n use std::cmp;\n use std::mem;\n-use std::ops::Deref;\n use std::path::{self, Path, PathBuf};\n use std::slice;\n \n@@ -132,12 +132,16 @@ macro_rules! maybe_whole_expr {\n                 token::NtPath(path) => {\n                     let path = path.clone();\n                     $p.bump();\n-                    return Ok($p.mk_expr($p.span, ExprKind::Path(None, path), ThinVec::new()));\n+                    return Ok($p.mk_expr(\n+                        $p.token.span, ExprKind::Path(None, path), ThinVec::new()\n+                    ));\n                 }\n                 token::NtBlock(block) => {\n                     let block = block.clone();\n                     $p.bump();\n-                    return Ok($p.mk_expr($p.span, ExprKind::Block(block, None), ThinVec::new()));\n+                    return Ok($p.mk_expr(\n+                        $p.token.span, ExprKind::Block(block, None), ThinVec::new()\n+                    ));\n                 }\n                 _ => {},\n             };\n@@ -246,15 +250,6 @@ impl<'a> Drop for Parser<'a> {\n     }\n }\n \n-// FIXME: Parser uses `self.span` all the time.\n-// Remove this impl if you think that using `self.token.span` instead is acceptable.\n-impl Deref for Parser<'_> {\n-    type Target = Token;\n-    fn deref(&self) -> &Self::Target {\n-        &self.token\n-    }\n-}\n-\n #[derive(Clone)]\n crate struct TokenCursor {\n     crate frame: TokenCursorFrame,\n@@ -514,8 +509,9 @@ impl<'a> Parser<'a> {\n \n         if let Some(directory) = directory {\n             parser.directory = directory;\n-        } else if !parser.span.is_dummy() {\n-            if let FileName::Real(mut path) = sess.source_map().span_to_unmapped_path(parser.span) {\n+        } else if !parser.token.span.is_dummy() {\n+            if let FileName::Real(mut path) =\n+                    sess.source_map().span_to_unmapped_path(parser.token.span) {\n                 path.pop();\n                 parser.directory.path = Cow::from(path);\n             }\n@@ -596,7 +592,7 @@ impl<'a> Parser<'a> {\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n             Ok(false)\n-        } else if self.last_unexpected_token_span == Some(self.span) {\n+        } else if self.last_unexpected_token_span == Some(self.token.span) {\n             FatalError.raise();\n         } else {\n             self.expected_one_of_not_found(edible, inedible)\n@@ -632,7 +628,7 @@ impl<'a> Parser<'a> {\n                         return Err(err);\n                     }\n                 }\n-                let span = self.span;\n+                let span = self.token.span;\n                 self.bump();\n                 Ok(Ident::new(name, span))\n             }\n@@ -748,7 +744,7 @@ impl<'a> Parser<'a> {\n                 true\n             }\n             token::BinOpEq(token::Plus) => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 self.bump_with(token::Eq, span);\n                 true\n             }\n@@ -779,7 +775,7 @@ impl<'a> Parser<'a> {\n                 Ok(())\n             }\n             token::AndAnd => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 Ok(self.bump_with(token::BinOp(token::And), span))\n             }\n             _ => self.unexpected()\n@@ -796,7 +792,7 @@ impl<'a> Parser<'a> {\n                 Ok(())\n             }\n             token::OrOr => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 Ok(self.bump_with(token::BinOp(token::Or), span))\n             }\n             _ => self.unexpected()\n@@ -821,12 +817,12 @@ impl<'a> Parser<'a> {\n                 true\n             }\n             token::BinOp(token::Shl) => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 self.bump_with(token::Lt, span);\n                 true\n             }\n             token::LArrow => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 self.bump_with(token::BinOp(token::Minus), span);\n                 true\n             }\n@@ -861,15 +857,15 @@ impl<'a> Parser<'a> {\n                 Some(())\n             }\n             token::BinOp(token::Shr) => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 Some(self.bump_with(token::Gt, span))\n             }\n             token::BinOpEq(token::Shr) => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 Some(self.bump_with(token::Ge, span))\n             }\n             token::Ge => {\n-                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                let span = self.token.span.with_lo(self.token.span.lo() + BytePos(1));\n                 Some(self.bump_with(token::Eq, span))\n             }\n             _ => None,\n@@ -1018,7 +1014,7 @@ impl<'a> Parser<'a> {\n             self.bug(\"attempted to bump the parser past EOF (may be stuck in a loop)\");\n         }\n \n-        self.prev_span = self.meta_var_span.take().unwrap_or(self.span);\n+        self.prev_span = self.meta_var_span.take().unwrap_or(self.token.span);\n \n         // Record last token kind for possible error recovery.\n         self.prev_token_kind = match self.token.kind {\n@@ -1041,7 +1037,7 @@ impl<'a> Parser<'a> {\n     /// Advance the parser using provided token as a next one. Use this when\n     /// consuming a part of a token. For example a single `<` from `<<`.\n     fn bump_with(&mut self, next: TokenKind, span: Span) {\n-        self.prev_span = self.span.with_hi(span.lo());\n+        self.prev_span = self.token.span.with_hi(span.lo());\n         // It would be incorrect to record the kind of the current token, but\n         // fortunately for tokens currently using `bump_with`, the\n         // prev_token_kind will be of no use anyway.\n@@ -1068,18 +1064,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    crate fn look_ahead_span(&self, dist: usize) -> Span {\n-        if dist == 0 {\n-            return self.span\n-        }\n-\n-        match self.token_cursor.frame.tree_cursor.look_ahead(dist - 1) {\n-            Some(TokenTree::Token(token)) => token.span,\n-            Some(TokenTree::Delimited(span, ..)) => span.entire(),\n-            None => self.look_ahead_span(dist - 1),\n-        }\n-    }\n-\n     /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.\n     fn is_keyword_ahead(&self, dist: usize, kws: &[Symbol]) -> bool {\n         self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))\n@@ -1171,7 +1155,7 @@ impl<'a> Parser<'a> {\n     fn parse_trait_item_(&mut self,\n                          at_end: &mut bool,\n                          mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n-        let lo = self.span;\n+        let lo = self.token.span;\n         self.eat_bad_pub();\n         let (name, node, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_trait_item_assoc_ty()?\n@@ -1204,7 +1188,7 @@ impl<'a> Parser<'a> {\n                 // definition...\n \n                 // We don't allow argument names to be left off in edition 2018.\n-                p.parse_arg_general(p.span.rust_2018(), true, false)\n+                p.parse_arg_general(p.token.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n \n@@ -1268,7 +1252,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::RArrow) {\n             Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true, false)?))\n         } else {\n-            Ok(FunctionRetTy::Default(self.span.shrink_to_lo()))\n+            Ok(FunctionRetTy::Default(self.token.span.shrink_to_lo()))\n         }\n     }\n \n@@ -1292,7 +1276,7 @@ impl<'a> Parser<'a> {\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n         maybe_whole!(self, NtTy, |x| x);\n \n-        let lo = self.span;\n+        let lo = self.token.span;\n         let mut impl_dyn_multi = false;\n         let node = if self.eat(&token::OpenDelim(token::Paren)) {\n             // `(TYPE)` is a parenthesized type.\n@@ -1376,7 +1360,7 @@ impl<'a> Parser<'a> {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n-            let lo = self.span;\n+            let lo = self.token.span;\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n             if self.token_is_bare_fn_keyword() {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n@@ -1391,7 +1375,7 @@ impl<'a> Parser<'a> {\n             impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n             TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n         } else if self.check_keyword(kw::Dyn) &&\n-                  (self.span.rust_2018() ||\n+                  (self.token.span.rust_2018() ||\n                    self.look_ahead(1, |t| t.can_begin_bound() &&\n                                           !can_continue_type_after_non_fn_ident(t))) {\n             self.bump(); // `dyn`\n@@ -1604,9 +1588,9 @@ impl<'a> Parser<'a> {\n     crate fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n-        let minus_lo = self.span;\n+        let minus_lo = self.token.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n-        let lo = self.span;\n+        let lo = self.token.span;\n         let literal = self.parse_lit()?;\n         let hi = self.prev_span;\n         let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n@@ -1623,7 +1607,7 @@ impl<'a> Parser<'a> {\n     fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n             token::Ident(name, _) if name.is_path_segment_keyword() => {\n-                let span = self.span;\n+                let span = self.token.span;\n                 self.bump();\n                 Ok(Ident::new(name, span))\n             }\n@@ -1634,7 +1618,7 @@ impl<'a> Parser<'a> {\n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n             token::Ident(name, false) if name == kw::Underscore => {\n-                let span = self.span;\n+                let span = self.token.span;\n                 self.bump();\n                 Ok(Ident::new(name, span))\n             }\n@@ -1662,11 +1646,11 @@ impl<'a> Parser<'a> {\n         // span in the case of something like `<T>::Bar`.\n         let (mut path, path_span);\n         if self.eat_keyword(kw::As) {\n-            let path_lo = self.span;\n+            let path_lo = self.token.span;\n             path = self.parse_path(PathStyle::Type)?;\n             path_span = path_lo.to(self.prev_span);\n         } else {\n-            path_span = self.span.to(self.span);\n+            path_span = self.token.span.to(self.token.span);\n             path = ast::Path { segments: Vec::new(), span: path_span };\n         }\n \n@@ -1704,9 +1688,9 @@ impl<'a> Parser<'a> {\n             path\n         });\n \n-        let lo = self.meta_var_span.unwrap_or(self.span);\n+        let lo = self.meta_var_span.unwrap_or(self.token.span);\n         let mut segments = Vec::new();\n-        let mod_sep_ctxt = self.span.ctxt();\n+        let mod_sep_ctxt = self.token.span.ctxt();\n         if self.eat(&token::ModSep) {\n             segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n@@ -1797,7 +1781,7 @@ impl<'a> Parser<'a> {\n \n             // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n             self.eat(&token::ModSep);\n-            let lo = self.span;\n+            let lo = self.token.span;\n             let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n                 let (args, constraints) =\n@@ -1840,17 +1824,17 @@ impl<'a> Parser<'a> {\n     /// Parses a single lifetime `'a` or panics.\n     crate fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n-            let span = self.span;\n+            let span = self.token.span;\n             self.bump();\n             Lifetime { ident: Ident::new(ident.name, span), id: ast::DUMMY_NODE_ID }\n         } else {\n-            self.span_bug(self.span, \"not a lifetime\")\n+            self.span_bug(self.token.span, \"not a lifetime\")\n         }\n     }\n \n     fn eat_label(&mut self) -> Option<Label> {\n         if let Some(ident) = self.token.lifetime() {\n-            let span = self.span;\n+            let span = self.token.span;\n             self.bump();\n             Some(Label { ident: Ident::new(ident.name, span) })\n         } else {\n@@ -1870,7 +1854,7 @@ impl<'a> Parser<'a> {\n     fn parse_field_name(&mut self) -> PResult<'a, Ident> {\n         if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) =\n                 self.token.kind {\n-            self.expect_no_suffix(self.span, \"a tuple index\", suffix);\n+            self.expect_no_suffix(self.token.span, \"a tuple index\", suffix);\n             self.bump();\n             Ok(Ident::new(symbol, self.prev_span))\n         } else {\n@@ -1881,7 +1865,7 @@ impl<'a> Parser<'a> {\n     /// Parse ident (COLON expr)?\n     fn parse_field(&mut self) -> PResult<'a, Field> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span;\n+        let lo = self.token.span;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| {\n@@ -1893,9 +1877,9 @@ impl<'a> Parser<'a> {\n             // initialize a field with an eq rather than a colon.\n             if self.token == token::Eq {\n                 self.diagnostic()\n-                    .struct_span_err(self.span, \"expected `:`, found `=`\")\n+                    .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n                     .span_suggestion(\n-                        fieldname.span.shrink_to_hi().to(self.span),\n+                        fieldname.span.shrink_to_hi().to(self.token.span),\n                         \"replace equals symbol with a colon\",\n                         \":\".to_string(),\n                         Applicability::MachineApplicable,\n@@ -1947,7 +1931,7 @@ impl<'a> Parser<'a> {\n                     limits: RangeLimits)\n                     -> PResult<'a, ast::ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            Err(self.span_fatal_err(self.span, Error::InclusiveRangeWithNoEnd))\n+            Err(self.span_fatal_err(self.token.span, Error::InclusiveRangeWithNoEnd))\n         } else {\n             Ok(ExprKind::Range(start, end, limits))\n         }\n@@ -1964,7 +1948,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let msg = \"expected open delimiter\";\n                 let mut err = self.fatal(msg);\n-                err.span_label(self.span, msg);\n+                err.span_label(self.token.span, msg);\n                 return Err(err)\n             }\n         };\n@@ -1997,8 +1981,8 @@ impl<'a> Parser<'a> {\n         // attributes by giving them a empty \"already parsed\" list.\n         let mut attrs = ThinVec::new();\n \n-        let lo = self.span;\n-        let mut hi = self.span;\n+        let lo = self.token.span;\n+        let mut hi = self.token.span;\n \n         let ex: ExprKind;\n \n@@ -2127,7 +2111,7 @@ impl<'a> Parser<'a> {\n                     }\n                     let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n                     let mut err = self.fatal(msg);\n-                    err.span_label(self.span, msg);\n+                    err.span_label(self.token.span, msg);\n                     return Err(err);\n                 }\n                 if self.eat_keyword(kw::Loop) {\n@@ -2160,13 +2144,13 @@ impl<'a> Parser<'a> {\n                     return Err(db);\n                 }\n                 if self.is_try_block() {\n-                    let lo = self.span;\n+                    let lo = self.token.span;\n                     assert!(self.eat_keyword(kw::Try));\n                     return self.parse_try_block(lo, attrs);\n                 }\n \n                 // Span::rust_2018() is somewhat expensive; don't get it repeatedly.\n-                let is_span_rust_2018 = self.span.rust_2018();\n+                let is_span_rust_2018 = self.token.span.rust_2018();\n                 if is_span_rust_2018 && self.check_keyword(kw::Async) {\n                     return if self.is_async_block() { // check for `async {` and `async move {`\n                         self.parse_async_block(attrs)\n@@ -2206,7 +2190,7 @@ impl<'a> Parser<'a> {\n                     // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n-                    db.span_label(self.span, \"expected expression\");\n+                    db.span_label(self.token.span, \"expected expression\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n@@ -2247,7 +2231,7 @@ impl<'a> Parser<'a> {\n                         //   |             ^ expected expression\n                         // ```\n                         self.bump();\n-                        return Ok(self.mk_expr(self.span, ExprKind::Err, ThinVec::new()));\n+                        return Ok(self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()));\n                     }\n                     match self.parse_literal_maybe_minus() {\n                         Ok(expr) => {\n@@ -2360,7 +2344,7 @@ impl<'a> Parser<'a> {\n                         \"cannot use a comma after the base struct\",\n                     );\n                     err.span_suggestion_short(\n-                        self.span,\n+                        self.token.span,\n                         \"remove this comma\",\n                         String::new(),\n                         Applicability::MachineApplicable\n@@ -2377,9 +2361,9 @@ impl<'a> Parser<'a> {\n                 if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n                     // Use in case of error after field-looking code: `S { foo: () with a }`\n                     recovery_field = Some(ast::Field {\n-                        ident: Ident::new(name, self.span),\n-                        span: self.span,\n-                        expr: self.mk_expr(self.span, ExprKind::Err, ThinVec::new()),\n+                        ident: Ident::new(name, self.token.span),\n+                        span: self.token.span,\n+                        expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n                         is_shorthand: false,\n                         attrs: ThinVec::new(),\n                     });\n@@ -2422,7 +2406,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let span = lo.to(self.span);\n+        let span = lo.to(self.token.span);\n         self.expect(&token::CloseDelim(token::Brace))?;\n         return Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs));\n     }\n@@ -2498,7 +2482,7 @@ impl<'a> Parser<'a> {\n \n     // Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        if self.span.rust_2018() && self.eat_keyword(kw::Await) {\n+        if self.token.span.rust_2018() && self.eat_keyword(kw::Await) {\n             let span = lo.to(self.prev_span);\n             let await_expr = self.mk_expr(\n                 span,\n@@ -2555,7 +2539,7 @@ impl<'a> Parser<'a> {\n                         e = self.parse_dot_suffix(e, lo)?;\n                     }\n                     token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n-                        let span = self.span;\n+                        let span = self.token.span;\n                         self.bump();\n                         let field = ExprKind::Field(e, Ident::new(symbol, span));\n                         e = self.mk_expr(lo.to(span), field, ThinVec::new());\n@@ -2596,7 +2580,7 @@ impl<'a> Parser<'a> {\n                     _ => {\n                         // FIXME Could factor this out into non_fatal_unexpected or something.\n                         let actual = self.this_token_to_string();\n-                        self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n+                        self.span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual));\n                     }\n                 }\n                 continue;\n@@ -2623,7 +2607,7 @@ impl<'a> Parser<'a> {\n                 token::OpenDelim(token::Bracket) => {\n                     self.bump();\n                     let ix = self.parse_expr()?;\n-                    hi = self.span;\n+                    hi = self.token.span;\n                     self.expect(&token::CloseDelim(token::Bracket))?;\n                     let index = self.mk_index(e, ix);\n                     e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n@@ -2636,21 +2620,21 @@ impl<'a> Parser<'a> {\n \n     crate fn process_potential_macro_variable(&mut self) {\n         self.token = match self.token.kind {\n-            token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n+            token::Dollar if self.token.span.ctxt() != SyntaxContext::empty() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n                 let name = match self.token.kind {\n                     token::Ident(name, _) => name,\n                     _ => unreachable!()\n                 };\n                 let mut err = self.fatal(&format!(\"unknown macro variable `{}`\", name));\n-                err.span_label(self.span, \"unknown macro variable\");\n+                err.span_label(self.token.span, \"unknown macro variable\");\n                 err.emit();\n                 self.bump();\n                 return\n             }\n             token::Interpolated(ref nt) => {\n-                self.meta_var_span = Some(self.span);\n+                self.meta_var_span = Some(self.token.span);\n                 // Interpolated identifier and lifetime tokens are replaced with usual identifier\n                 // and lifetime tokens, so the former are never encountered during normal parsing.\n                 match **nt {\n@@ -2713,7 +2697,7 @@ impl<'a> Parser<'a> {\n                              already_parsed_attrs: Option<ThinVec<Attribute>>)\n                              -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.span;\n+        let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n         let (hi, ex) = match self.token.kind {\n             token::Not => {\n@@ -2785,13 +2769,13 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                     // Emit the error ...\n                     let mut err = self.diagnostic()\n-                        .struct_span_err(self.span,\n+                        .struct_span_err(self.token.span,\n                                          &format!(\"unexpected {} after identifier\",\n                                                   self.this_token_descr()));\n                     // span the `not` plus trailing whitespace to avoid\n                     // trailing whitespace after the `!` in our suggestion\n                     let to_replace = self.sess.source_map()\n-                        .span_until_non_whitespace(lo.to(self.span));\n+                        .span_until_non_whitespace(lo.to(self.token.span));\n                     err.span_suggestion_short(\n                         to_replace,\n                         \"use `!` to perform logical negation\",\n@@ -2860,7 +2844,7 @@ impl<'a> Parser<'a> {\n             // `if x { a } else { b } && if y { c } else { d }`\n             if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n                 // These cases are ambiguous and can't be identified in the parser alone\n-                let sp = self.sess.source_map().start_point(self.span);\n+                let sp = self.sess.source_map().start_point(self.token.span);\n                 self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n                 return Ok(lhs);\n             }\n@@ -2871,11 +2855,11 @@ impl<'a> Parser<'a> {\n                 // We've found an expression that would be parsed as a statement, but the next\n                 // token implies this should be parsed as an expression.\n                 // For example: `if let Some(x) = x { x } else { 0 } / 2`\n-                let mut err = self.sess.span_diagnostic.struct_span_err(self.span, &format!(\n+                let mut err = self.sess.span_diagnostic.struct_span_err(self.token.span, &format!(\n                     \"expected expression, found `{}`\",\n                     pprust::token_to_string(&self.token),\n                 ));\n-                err.span_label(self.span, \"expected expression\");\n+                err.span_label(self.token.span, \"expected expression\");\n                 self.sess.expr_parentheses_needed(\n                     &mut err,\n                     lhs.span,\n@@ -2898,7 +2882,7 @@ impl<'a> Parser<'a> {\n                 _ => lhs.span,\n             };\n \n-            let cur_op_span = self.span;\n+            let cur_op_span = self.token.span;\n             let restrictions = if op.is_assign_like() {\n                 self.restrictions & Restrictions::NO_STRUCT_LITERAL\n             } else {\n@@ -2910,7 +2894,7 @@ impl<'a> Parser<'a> {\n             }\n             // Check for deprecated `...` syntax\n             if self.token == token::DotDotDot && op == AssocOp::DotDotEq {\n-                self.err_dotdotdot_syntax(self.span);\n+                self.err_dotdotdot_syntax(self.token.span);\n             }\n \n             self.bump();\n@@ -2923,7 +2907,7 @@ impl<'a> Parser<'a> {\n                 continue\n             } else if op == AssocOp::Colon {\n                 let maybe_path = self.could_ascription_be_path(&lhs.node);\n-                let next_sp = self.span;\n+                let next_sp = self.token.span;\n \n                 lhs = match self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type) {\n                     Ok(lhs) => lhs,\n@@ -3068,10 +3052,12 @@ impl<'a> Parser<'a> {\n                         // in AST and continue parsing.\n                         let msg = format!(\"`<` is interpreted as a start of generic \\\n                                            arguments for `{}`, not a {}\", path, op_noun);\n-                        let mut err = self.sess.span_diagnostic.struct_span_err(self.span, &msg);\n-                        err.span_label(self.look_ahead_span(1).to(parser_snapshot_after_type.span),\n+                        let mut err =\n+                            self.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n+                        let span_after_type = parser_snapshot_after_type.token.span;\n+                        err.span_label(self.look_ahead(1, |t| t.span).to(span_after_type),\n                                        \"interpreted as generic arguments\");\n-                        err.span_label(self.span, format!(\"not interpreted as {}\", op_noun));\n+                        err.span_label(self.token.span, format!(\"not interpreted as {}\", op_noun));\n \n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,\n@@ -3108,16 +3094,16 @@ impl<'a> Parser<'a> {\n                                -> PResult<'a, P<Expr>> {\n         // Check for deprecated `...` syntax\n         if self.token == token::DotDotDot {\n-            self.err_dotdotdot_syntax(self.span);\n+            self.err_dotdotdot_syntax(self.token.span);\n         }\n \n         debug_assert!([token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token),\n                       \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotEq\",\n                       self.token);\n         let tok = self.token.clone();\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.span;\n-        let mut hi = self.span;\n+        let lo = self.token.span;\n+        let mut hi = self.token.span;\n         self.bump();\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than the dots.\n@@ -3212,13 +3198,13 @@ impl<'a> Parser<'a> {\n                              attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>>\n     {\n-        let lo = self.span;\n+        let lo = self.token.span;\n         let movability = if self.eat_keyword(kw::Static) {\n             Movability::Static\n         } else {\n             Movability::Movable\n         };\n-        let asyncness = if self.span.rust_2018() {\n+        let asyncness = if self.token.span.rust_2018() {\n             self.parse_asyncness()\n         } else {\n             IsAsync::NotAsync\n@@ -3238,7 +3224,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 // If an explicit return type is given, require a\n                 // block to appear (RFC 968).\n-                let body_lo = self.span;\n+                let body_lo = self.token.span;\n                 self.parse_block_expr(None, body_lo, BlockCheckMode::Default, ThinVec::new())?\n             }\n         };\n@@ -3267,7 +3253,7 @@ impl<'a> Parser<'a> {\n \n         let pat = self.parse_top_level_pat()?;\n         if !self.eat_keyword(kw::In) {\n-            let in_span = self.prev_span.between(self.span);\n+            let in_span = self.prev_span.between(self.token.span);\n             let mut err = self.sess.span_diagnostic\n                 .struct_span_err(in_span, \"missing `in` in `for` loop\");\n             err.span_suggestion_short(\n@@ -3329,7 +3315,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>)\n         -> PResult<'a, P<Expr>>\n     {\n-        let span_lo = self.span;\n+        let span_lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n         let capture_clause = if self.eat_keyword(kw::Move) {\n             CaptureBy::Value\n@@ -3387,31 +3373,31 @@ impl<'a> Parser<'a> {\n                     // Recover by skipping to the end of the block.\n                     e.emit();\n                     self.recover_stmt();\n-                    let span = lo.to(self.span);\n+                    let span = lo.to(self.token.span);\n                     if self.token == token::CloseDelim(token::Brace) {\n                         self.bump();\n                     }\n                     return Ok(self.mk_expr(span, ExprKind::Match(discriminant, arms), attrs));\n                 }\n             }\n         }\n-        let hi = self.span;\n+        let hi = self.token.span;\n         self.bump();\n         return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n     }\n \n     crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span;\n+        let lo = self.token.span;\n         let pats = self.parse_pats()?;\n         let guard = if self.eat_keyword(kw::If) {\n             Some(Guard::If(self.parse_expr()?))\n         } else {\n             None\n         };\n-        let arrow_span = self.span;\n+        let arrow_span = self.token.span;\n         self.expect(&token::FatArrow)?;\n-        let arm_start_span = self.span;\n+        let arm_start_span = self.token.span;\n \n         let expr = self.parse_expr_res(Restrictions::STMT_EXPR, None)\n             .map_err(|mut err| {\n@@ -3422,7 +3408,7 @@ impl<'a> Parser<'a> {\n         let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n             && self.token != token::CloseDelim(token::Brace);\n \n-        let hi = self.span;\n+        let hi = self.token.span;\n \n         if require_comma {\n             let cm = self.sess.source_map();\n@@ -3441,7 +3427,7 @@ impl<'a> Parser<'a> {\n                             //   |        |\n                             //   |        arrow_span\n                             // X |     &X => \"x\"\n-                            //   |      - ^^ self.span\n+                            //   |      - ^^ self.token.span\n                             //   |      |\n                             //   |      parsed until here as `\"y\" & X`\n                             err.span_suggestion_short(\n@@ -3520,10 +3506,10 @@ impl<'a> Parser<'a> {\n             pats.push(self.parse_top_level_pat()?);\n \n             if self.token == token::OrOr {\n-                let mut err = self.struct_span_err(self.span,\n+                let mut err = self.struct_span_err(self.token.span,\n                                                    \"unexpected token `||` after pattern\");\n                 err.span_suggestion(\n-                    self.span,\n+                    self.token.span,\n                     \"use a single `|` to specify multiple patterns\",\n                     \"|\".to_owned(),\n                     Applicability::MachineApplicable\n@@ -3672,7 +3658,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n             let is_box = self.eat_keyword(kw::Box);\n-            let boxed_span = self.span;\n+            let boxed_span = self.token.span;\n             let is_ref = self.eat_keyword(kw::Ref);\n             let is_mut = self.eat_keyword(kw::Mut);\n             let fieldname = self.parse_ident()?;\n@@ -3723,7 +3709,7 @@ impl<'a> Parser<'a> {\n \n         while self.token != token::CloseDelim(token::Brace) {\n             let attrs = self.parse_outer_attributes()?;\n-            let lo = self.span;\n+            let lo = self.token.span;\n \n             // check that a comma comes after every field\n             if !ate_comma {\n@@ -3737,14 +3723,14 @@ impl<'a> Parser<'a> {\n \n             if self.check(&token::DotDot) || self.token == token::DotDotDot {\n                 etc = true;\n-                let mut etc_sp = self.span;\n+                let mut etc_sp = self.token.span;\n \n                 if self.token == token::DotDotDot { // Issue #46718\n                     // Accept `...` as if it were `..` to avoid further errors\n-                    let mut err = self.struct_span_err(self.span,\n+                    let mut err = self.struct_span_err(self.token.span,\n                                                        \"expected field pattern, found `...`\");\n                     err.span_suggestion(\n-                        self.span,\n+                        self.token.span,\n                         \"to omit remaining fields, use one fewer `.`\",\n                         \"..\".to_owned(),\n                         Applicability::MachineApplicable\n@@ -3760,18 +3746,19 @@ impl<'a> Parser<'a> {\n                 let token_str = self.this_token_descr();\n                 let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n \n-                err.span_label(self.span, \"expected `}`\");\n+                err.span_label(self.token.span, \"expected `}`\");\n                 let mut comma_sp = None;\n                 if self.token == token::Comma { // Issue #49257\n-                    etc_sp = etc_sp.to(self.sess.source_map().span_until_non_whitespace(self.span));\n+                    let nw_span = self.sess.source_map().span_until_non_whitespace(self.token.span);\n+                    etc_sp = etc_sp.to(nw_span);\n                     err.span_label(etc_sp,\n                                    \"`..` must be at the end and cannot have a trailing comma\");\n-                    comma_sp = Some(self.span);\n+                    comma_sp = Some(self.token.span);\n                     self.bump();\n                     ate_comma = true;\n                 }\n \n-                etc_span = Some(etc_sp.until(self.span));\n+                etc_span = Some(etc_sp.until(self.token.span));\n                 if self.token == token::CloseDelim(token::Brace) {\n                     // If the struct looks otherwise well formed, recover and continue.\n                     if let Some(sp) = comma_sp {\n@@ -3821,7 +3808,7 @@ impl<'a> Parser<'a> {\n                     \"move the `..` to the end of the field list\",\n                     vec![\n                         (etc_span, String::new()),\n-                        (self.span, format!(\"{}.. }}\", if ate_comma { \"\" } else { \", \" })),\n+                        (self.token.span, format!(\"{}.. }}\", if ate_comma { \"\" } else { \", \" })),\n                     ],\n                     Applicability::MachineApplicable,\n                 );\n@@ -3833,7 +3820,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n         if self.token.is_path_start() {\n-            let lo = self.span;\n+            let lo = self.token.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n                 let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n@@ -3876,7 +3863,7 @@ impl<'a> Parser<'a> {\n             // parentheses in what should have been a tuple pattern; return a\n             // suggestion-enhanced error here rather than choking on the comma\n             // later.\n-            let comma_span = self.span;\n+            let comma_span = self.token.span;\n             self.bump();\n             if let Err(mut err) = self.parse_pat_list() {\n                 // We didn't expect this to work anyway; we just wanted\n@@ -3920,7 +3907,7 @@ impl<'a> Parser<'a> {\n         maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole!(self, NtPat, |x| x);\n \n-        let lo = self.span;\n+        let lo = self.token.span;\n         let pat;\n         match self.token.kind {\n             token::BinOp(token::And) | token::AndAnd => {\n@@ -3929,7 +3916,7 @@ impl<'a> Parser<'a> {\n                 let mutbl = self.parse_mutability();\n                 if let token::Lifetime(name) = self.token.kind {\n                     let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n-                    err.span_label(self.span, \"unexpected lifetime\");\n+                    err.span_label(self.token.span, \"unexpected lifetime\");\n                     return Err(err);\n                 }\n                 let subpat = self.parse_pat_with_range_pat(false, expected)?;\n@@ -3957,7 +3944,7 @@ impl<'a> Parser<'a> {\n                 pat = PatKind::Wild;\n             } else if self.eat_keyword(kw::Mut) {\n                 // Parse mut ident @ pat / mut ref ident @ pat\n-                let mutref_span = self.prev_span.to(self.span);\n+                let mutref_span = self.prev_span.to(self.token.span);\n                 let binding_mode = if self.eat_keyword(kw::Ref) {\n                     self.diagnostic()\n                         .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n@@ -4013,7 +4000,7 @@ impl<'a> Parser<'a> {\n                             _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n                                          (checked above)\"),\n                         };\n-                        let op_span = self.span;\n+                        let op_span = self.token.span;\n                         // Parse range\n                         let span = lo.to(self.prev_span);\n                         let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n@@ -4026,7 +4013,7 @@ impl<'a> Parser<'a> {\n                         if qself.is_some() {\n                             let msg = \"unexpected `{` after qualified path\";\n                             let mut err = self.fatal(msg);\n-                            err.span_label(self.span, msg);\n+                            err.span_label(self.token.span, msg);\n                             return Err(err);\n                         }\n                         // Parse struct pattern\n@@ -4043,7 +4030,7 @@ impl<'a> Parser<'a> {\n                         if qself.is_some() {\n                             let msg = \"unexpected `(` after qualified path\";\n                             let mut err = self.fatal(msg);\n-                            err.span_label(self.span, msg);\n+                            err.span_label(self.token.span, msg);\n                             return Err(err);\n                         }\n                         // Parse tuple struct or enum pattern\n@@ -4056,7 +4043,7 @@ impl<'a> Parser<'a> {\n                 // Try to parse everything else as literal with optional minus\n                 match self.parse_literal_maybe_minus() {\n                     Ok(begin) => {\n-                        let op_span = self.span;\n+                        let op_span = self.token.span;\n                         if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n                                 self.check(&token::DotDotDot) {\n                             let end_kind = if self.eat(&token::DotDotDot) {\n@@ -4085,8 +4072,8 @@ impl<'a> Parser<'a> {\n                             self.this_token_descr(),\n                         );\n                         let mut err = self.fatal(&msg);\n-                        err.span_label(self.span, format!(\"expected {}\", expected));\n-                        let sp = self.sess.source_map().start_point(self.span);\n+                        err.span_label(self.token.span, format!(\"expected {}\", expected));\n+                        let sp = self.sess.source_map().start_point(self.token.span);\n                         if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n                             self.sess.expr_parentheses_needed(&mut err, *sp, None);\n                         }\n@@ -4212,7 +4199,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         let hi = if self.token == token::Semi {\n-            self.span\n+            self.token.span\n         } else {\n             self.prev_span\n         };\n@@ -4300,7 +4287,7 @@ impl<'a> Parser<'a> {\n     fn is_try_block(&self) -> bool {\n         self.token.is_keyword(kw::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-        self.span.rust_2018() &&\n+        self.token.span.rust_2018() &&\n         // prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -4331,7 +4318,7 @@ impl<'a> Parser<'a> {\n \n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n                      -> PResult<'a, Option<P<Item>>> {\n-        let token_lo = self.span;\n+        let token_lo = self.token.span;\n         let (ident, def) = match self.token.kind {\n             token::Ident(name, false) if name == kw::Macro => {\n                 self.bump();\n@@ -4389,7 +4376,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtStmt, |x| Some(x));\n \n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span;\n+        let lo = self.token.span;\n \n         Ok(Some(if self.eat_keyword(kw::Let) {\n             Stmt {\n@@ -4465,7 +4452,7 @@ impl<'a> Parser<'a> {\n                     let mut err = self.fatal(&format!(\"expected {}`(` or `{{`, found {}\",\n                                                       ident_str,\n                                                       tok_str));\n-                    err.span_label(self.span, format!(\"expected {}`(` or `{{`\", ident_str));\n+                    err.span_label(self.token.span, format!(\"expected {}`(` or `{{`\", ident_str));\n                     return Err(err)\n                 },\n             }\n@@ -4552,7 +4539,9 @@ impl<'a> Parser<'a> {\n                             if s.prev_token_kind == PrevTokenKind::DocComment {\n                                 s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n                             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                                s.span_err(s.span, \"expected statement after outer attribute\");\n+                                s.span_err(\n+                                    s.token.span, \"expected statement after outer attribute\"\n+                                );\n                             }\n                         }\n                     };\n@@ -4592,26 +4581,26 @@ impl<'a> Parser<'a> {\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);\n \n-        let lo = self.span;\n+        let lo = self.token.span;\n \n         if !self.eat(&token::OpenDelim(token::Brace)) {\n-            let sp = self.span;\n+            let sp = self.token.span;\n             let tok = self.this_token_descr();\n             let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n             let do_not_suggest_help =\n                 self.token.is_keyword(kw::In) || self.token == token::Colon;\n \n             if self.token.is_ident_named(sym::and) {\n                 e.span_suggestion_short(\n-                    self.span,\n+                    self.token.span,\n                     \"use `&&` instead of `and` for the boolean operator\",\n                     \"&&\".to_string(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n             if self.token.is_ident_named(sym::or) {\n                 e.span_suggestion_short(\n-                    self.span,\n+                    self.token.span,\n                     \"use `||` instead of `or` for the boolean operator\",\n                     \"||\".to_string(),\n                     Applicability::MaybeIncorrect,\n@@ -4670,7 +4659,7 @@ impl<'a> Parser<'a> {\n     fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n-        let lo = self.span;\n+        let lo = self.token.span;\n         self.expect(&token::OpenDelim(token::Brace))?;\n         Ok((self.parse_inner_attributes()?,\n             self.parse_block_tail(lo, BlockCheckMode::Default)?))\n@@ -4687,8 +4676,8 @@ impl<'a> Parser<'a> {\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(Stmt {\n                         id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Expr(DummyResult::raw_expr(self.span, true)),\n-                        span: self.span,\n+                        node: StmtKind::Expr(DummyResult::raw_expr(self.token.span, true)),\n+                        span: self.token.span,\n                     })\n                 }\n                 Ok(stmt) => stmt,\n@@ -4753,7 +4742,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn warn_missing_semicolon(&self) {\n-        self.diagnostic().struct_span_warn(self.span, {\n+        self.diagnostic().struct_span_warn(self.token.span, {\n             &format!(\"expected `;`, found {}\", self.this_token_descr())\n         }).note({\n             \"This was erroneously allowed and will become a hard error in a future release\"\n@@ -4795,9 +4784,9 @@ impl<'a> Parser<'a> {\n                                  self.check_keyword(kw::For) ||\n                                  self.check(&token::OpenDelim(token::Paren));\n             if is_bound_start {\n-                let lo = self.span;\n+                let lo = self.token.span;\n                 let has_parens = self.eat(&token::OpenDelim(token::Paren));\n-                let inner_lo = self.span;\n+                let inner_lo = self.token.span;\n                 let is_negative = self.eat(&token::Not);\n                 let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n                 if self.token.is_lifetime() {\n@@ -5053,13 +5042,13 @@ impl<'a> Parser<'a> {\n     ///                  | ( < lifetimes , typaramseq ( , )? > )\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n-        let span_lo = self.span;\n+        let span_lo = self.token.span;\n         let (params, span) = if self.eat_lt() {\n             let params = self.parse_generic_params()?;\n             self.expect_gt()?;\n             (params, span_lo.to(self.prev_span))\n         } else {\n-            (vec![], self.prev_span.between(self.span))\n+            (vec![], self.prev_span.between(self.token.span))\n         };\n         Ok(ast::Generics {\n             params,\n@@ -5226,7 +5215,7 @@ impl<'a> Parser<'a> {\n         let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n         let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n \n-        let args_lo = self.span;\n+        let args_lo = self.token.span;\n \n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n@@ -5236,7 +5225,7 @@ impl<'a> Parser<'a> {\n             } else if self.check_ident() && self.look_ahead(1,\n                     |t| t == &token::Eq || t == &token::Colon) {\n                 // Parse associated type constraint.\n-                let lo = self.span;\n+                let lo = self.token.span;\n                 let ident = self.parse_ident()?;\n                 let kind = if self.eat(&token::Eq) {\n                     AssocTyConstraintKind::Equality {\n@@ -5260,7 +5249,9 @@ impl<'a> Parser<'a> {\n             } else if self.check_const_arg() {\n                 // Parse const argument.\n                 let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n-                    self.parse_block_expr(None, self.span, BlockCheckMode::Default, ThinVec::new())?\n+                    self.parse_block_expr(\n+                        None, self.token.span, BlockCheckMode::Default, ThinVec::new()\n+                    )?\n                 } else if self.token.is_ident() {\n                     // FIXME(const_generics): to distinguish between idents for types and consts,\n                     // we should introduce a GenericArg::Ident in the AST and distinguish when\n@@ -5345,7 +5336,7 @@ impl<'a> Parser<'a> {\n         }\n \n         loop {\n-            let lo = self.span;\n+            let lo = self.token.span;\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 let lifetime = self.expect_lifetime();\n                 // Bounds starting with a colon are mandatory, but possibly empty.\n@@ -5413,7 +5404,7 @@ impl<'a> Parser<'a> {\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n         self.expect(&token::OpenDelim(token::Paren))?;\n \n-        let sp = self.span;\n+        let sp = self.token.span;\n         let mut c_variadic = false;\n         let (args, recovered): (Vec<Option<Arg>>, bool) =\n             self.parse_seq_to_before_end(\n@@ -5433,7 +5424,7 @@ impl<'a> Parser<'a> {\n                             if let TyKind::CVarArgs = arg.ty.node {\n                                 c_variadic = true;\n                                 if p.token != token::CloseDelim(token::Paren) {\n-                                    let span = p.span;\n+                                    let span = p.token.span;\n                                     p.span_err(span,\n                                         \"`...` must be the last argument of a C-variadic function\");\n                                     Ok(None)\n@@ -5489,7 +5480,7 @@ impl<'a> Parser<'a> {\n         let expect_ident = |this: &mut Self| match this.token.kind {\n             // Preserve hygienic context.\n             token::Ident(name, _) =>\n-                { let span = this.span; this.bump(); Ident::new(name, span) }\n+                { let span = this.token.span; this.bump(); Ident::new(name, span) }\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n@@ -5500,7 +5491,7 @@ impl<'a> Parser<'a> {\n         // Parse optional `self` parameter of a method.\n         // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n-        let eself_lo = self.span;\n+        let eself_lo = self.token.span;\n         let (eself, eself_ident, eself_hi) = match self.token.kind {\n             token::BinOp(token::And) => {\n                 // `&self`\n@@ -5541,16 +5532,16 @@ impl<'a> Parser<'a> {\n                 let msg = \"cannot pass `self` by raw pointer\";\n                 (if isolated_self(self, 1) {\n                     self.bump();\n-                    self.struct_span_err(self.span, msg)\n-                        .span_label(self.span, msg)\n+                    self.struct_span_err(self.token.span, msg)\n+                        .span_label(self.token.span, msg)\n                         .emit();\n                     SelfKind::Value(Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_mutability()) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     self.bump();\n-                    self.struct_span_err(self.span, msg)\n-                        .span_label(self.span, msg)\n+                    self.struct_span_err(self.token.span, msg)\n+                        .span_label(self.token.span, msg)\n                         .emit();\n                     SelfKind::Value(Mutability::Immutable)\n                 } else {\n@@ -5768,7 +5759,7 @@ impl<'a> Parser<'a> {\n     fn parse_impl_item_(&mut self,\n                         at_end: &mut bool,\n                         mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n-        let lo = self.span;\n+        let lo = self.token.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness();\n         let (name, node, generics) = if let Some(type_) = self.eat_type() {\n@@ -5927,7 +5918,7 @@ impl<'a> Parser<'a> {\n                     if self.look_ahead(1,\n                     |tok| tok == &token::CloseDelim(token::Brace)) {\n                         let mut err = self.diagnostic().struct_span_err_with_code(\n-                            self.span,\n+                            self.token.span,\n                             \"found a documentation comment that doesn't document anything\",\n                             DiagnosticId::Error(\"E0584\".into()),\n                         );\n@@ -6029,7 +6020,7 @@ impl<'a> Parser<'a> {\n         let err_path = |span| ast::Path::from_ident(Ident::new(kw::Invalid, span));\n         let ty_first = if self.token.is_keyword(kw::For) &&\n                           self.look_ahead(1, |t| t != &token::Lt) {\n-            let span = self.prev_span.between(self.span);\n+            let span = self.prev_span.between(self.token.span);\n             self.struct_span_err(span, \"missing trait in a trait impl\").emit();\n             P(Ty { node: TyKind::Path(None, err_path(span)), span, id: ast::DUMMY_NODE_ID })\n         } else {\n@@ -6038,7 +6029,7 @@ impl<'a> Parser<'a> {\n \n         // If `for` is missing we try to recover.\n         let has_for = self.eat_keyword(kw::For);\n-        let missing_for_span = self.prev_span.between(self.span);\n+        let missing_for_span = self.prev_span.between(self.token.span);\n \n         let ty_second = if self.token == token::DotDot {\n             // We need to report this error after `cfg` expansion for compatibility reasons\n@@ -6153,7 +6144,7 @@ impl<'a> Parser<'a> {\n                 \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n                 token_str\n             ));\n-            err.span_label(self.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n+            err.span_label(self.token.span, \"expected `where`, `{`, `(`, or `;` after struct name\");\n             return Err(err);\n         };\n \n@@ -6177,7 +6168,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_descr();\n             let mut err = self.fatal(&format!(\n                 \"expected `where` or `{{` after union name, found {}\", token_str));\n-            err.span_label(self.span, \"expected `where` or `{` after union name\");\n+            err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n             return Err(err);\n         };\n \n@@ -6208,7 +6199,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_descr();\n             let mut err = self.fatal(&format!(\n                     \"expected `where`, or `{{` after struct name, found {}\", token_str));\n-            err.span_label(self.span, \"expected `where`, or `{` after struct name\");\n+            err.span_label(self.token.span, \"expected `where`, or `{` after struct name\");\n             return Err(err);\n         }\n \n@@ -6224,7 +6215,7 @@ impl<'a> Parser<'a> {\n             SeqSep::trailing_allowed(token::Comma),\n             |p| {\n                 let attrs = p.parse_outer_attributes()?;\n-                let lo = p.span;\n+                let lo = p.token.span;\n                 let vis = p.parse_visibility(true)?;\n                 let ty = p.parse_ty()?;\n                 Ok(StructField {\n@@ -6258,7 +6249,7 @@ impl<'a> Parser<'a> {\n             token::CloseDelim(token::Brace) => {}\n             token::DocComment(_) => {\n                 let previous_span = self.prev_span;\n-                let mut err = self.span_fatal_err(self.span, Error::UselessDocComment);\n+                let mut err = self.span_fatal_err(self.token.span, Error::UselessDocComment);\n                 self.bump(); // consume the doc comment\n                 let comma_after_doc_seen = self.eat(&token::Comma);\n                 // `seen_comma` is always false, because we are inside doc block\n@@ -6305,7 +6296,7 @@ impl<'a> Parser<'a> {\n     /// Parses an element of a struct declaration.\n     fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span;\n+        let lo = self.token.span;\n         let vis = self.parse_visibility(false)?;\n         self.parse_single_struct_field(lo, vis, attrs)\n     }\n@@ -6328,7 +6319,7 @@ impl<'a> Parser<'a> {\n             // We need a span for our `Spanned<VisibilityKind>`, but there's inherently no\n             // keyword to grab a span from for inherited visibility; an empty span at the\n             // beginning of the current token would seem to be the \"Schelling span\".\n-            return Ok(respan(self.span.shrink_to_lo(), VisibilityKind::Inherited))\n+            return Ok(respan(self.token.span.shrink_to_lo(), VisibilityKind::Inherited))\n         }\n         let lo = self.prev_span;\n \n@@ -6429,12 +6420,12 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_descr();\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n                 let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n-                err.span_label(self.span, \"expected item\");\n+                err.span_label(self.token.span, \"expected item\");\n                 return Err(err);\n             }\n         }\n \n-        let hi = if self.span.is_dummy() {\n+        let hi = if self.token.span.is_dummy() {\n             inner_lo\n         } else {\n             self.prev_span\n@@ -6473,7 +6464,7 @@ impl<'a> Parser<'a> {\n             (!self.cfg_mods || strip_unconfigured.in_cfg(&outer_attrs), outer_attrs)\n         };\n \n-        let id_span = self.span;\n+        let id_span = self.token.span;\n         let id = self.parse_ident()?;\n         if self.eat(&token::Semi) {\n             if in_cfg && self.recurse_into_file_modules {\n@@ -6510,7 +6501,7 @@ impl<'a> Parser<'a> {\n             self.push_directory(id, &outer_attrs);\n \n             self.expect(&token::OpenDelim(token::Brace))?;\n-            let mod_inner_lo = self.span;\n+            let mod_inner_lo = self.token.span;\n             let attrs = self.parse_inner_attributes()?;\n             let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n \n@@ -6722,7 +6713,7 @@ impl<'a> Parser<'a> {\n         let mut p0 =\n             new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n         p0.cfg_mods = self.cfg_mods;\n-        let mod_inner_lo = p0.span;\n+        let mod_inner_lo = p0.token.span;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let mut m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n         m0.inline = false;\n@@ -6738,7 +6729,7 @@ impl<'a> Parser<'a> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n         let decl = self.parse_fn_decl(true)?;\n         generics.where_clause = self.parse_where_clause()?;\n-        let hi = self.span;\n+        let hi = self.token.span;\n         self.expect(&token::Semi)?;\n         Ok(ast::ForeignItem {\n             ident,\n@@ -6758,7 +6749,7 @@ impl<'a> Parser<'a> {\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n-        let hi = self.span;\n+        let hi = self.token.span;\n         self.expect(&token::Semi)?;\n         Ok(ForeignItem {\n             ident,\n@@ -6776,7 +6767,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(kw::Type)?;\n \n         let ident = self.parse_ident()?;\n-        let hi = self.span;\n+        let hi = self.token.span;\n         self.expect(&token::Semi)?;\n         Ok(ast::ForeignItem {\n             ident: ident,\n@@ -6939,7 +6930,7 @@ impl<'a> Parser<'a> {\n         let mut any_disr = vec![];\n         while self.token != token::CloseDelim(token::Brace) {\n             let variant_attrs = self.parse_outer_attributes()?;\n-            let vlo = self.span;\n+            let vlo = self.token.span;\n \n             let struct_def;\n             let mut disr_expr = None;\n@@ -7019,7 +7010,7 @@ impl<'a> Parser<'a> {\n         match self.token.kind {\n             token::Literal(token::Lit { kind: token::Str, symbol, suffix }) |\n             token::Literal(token::Lit { kind: token::StrRaw(..), symbol, suffix }) => {\n-                let sp = self.span;\n+                let sp = self.token.span;\n                 self.expect_no_suffix(sp, \"an ABI spec\", suffix);\n                 self.bump();\n                 match abi::lookup(&symbol.as_str()) {\n@@ -7114,7 +7105,7 @@ impl<'a> Parser<'a> {\n             Some(P(item))\n         });\n \n-        let lo = self.span;\n+        let lo = self.token.span;\n \n         let visibility = self.parse_visibility(false)?;\n \n@@ -7224,7 +7215,7 @@ impl<'a> Parser<'a> {\n \n         // Parse `async unsafe? fn`.\n         if self.check_keyword(kw::Async) {\n-            let async_span = self.span;\n+            let async_span = self.token.span;\n             if self.is_keyword_ahead(1, &[kw::Fn])\n                 || self.is_keyword_ahead(2, &[kw::Fn])\n             {\n@@ -7247,7 +7238,7 @@ impl<'a> Parser<'a> {\n                                         item_,\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n-                if self.span.rust_2015() {\n+                if self.token.span.rust_2015() {\n                     self.diagnostic().struct_span_err_with_code(\n                         async_span,\n                         \"`async fn` is not permitted in the 2015 edition\",\n@@ -7433,9 +7424,9 @@ impl<'a> Parser<'a> {\n             //\n             //     pub   S {}\n             //        ^^^ `sp` points here\n-            let sp = self.prev_span.between(self.span);\n-            let full_sp = self.prev_span.to(self.span);\n-            let ident_sp = self.span;\n+            let sp = self.prev_span.between(self.token.span);\n+            let full_sp = self.prev_span.to(self.token.span);\n+            let ident_sp = self.token.span;\n             if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n                 // possible public struct definition where `struct` was forgotten\n                 let ident = self.parse_ident().unwrap();\n@@ -7532,17 +7523,17 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtForeignItem, |ni| ni);\n \n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span;\n+        let lo = self.token.span;\n         let visibility = self.parse_visibility(false)?;\n \n         // FOREIGN STATIC ITEM\n         // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n         if self.check_keyword(kw::Static) || self.token.is_keyword(kw::Const) {\n             if self.token.is_keyword(kw::Const) {\n                 self.diagnostic()\n-                    .struct_span_err(self.span, \"extern items cannot be `const`\")\n+                    .struct_span_err(self.token.span, \"extern items cannot be `const`\")\n                     .span_suggestion(\n-                        self.span,\n+                        self.token.span,\n                         \"try using a static value\",\n                         \"static\".to_owned(),\n                         Applicability::MachineApplicable\n@@ -7593,13 +7584,13 @@ impl<'a> Parser<'a> {\n         visibility: Visibility\n     ) -> PResult<'a, Option<P<Item>>> {\n         if macros_allowed && self.token.is_path_start() &&\n-                !(self.is_async_fn() && self.span.rust_2015()) {\n+                !(self.is_async_fn() && self.token.span.rust_2015()) {\n             // MACRO INVOCATION ITEM\n \n             let prev_span = self.prev_span;\n             self.complain_if_pub_macro(&visibility.node, prev_span);\n \n-            let mac_lo = self.span;\n+            let mac_lo = self.token.span;\n \n             // item macro.\n             let pth = self.parse_path(PathStyle::Mod)?;\n@@ -7644,9 +7635,9 @@ impl<'a> Parser<'a> {\n                                at_end: &mut bool) -> PResult<'a, Option<Mac>>\n     {\n         if self.token.is_path_start() &&\n-                !(self.is_async_fn() && self.span.rust_2015()) {\n+                !(self.is_async_fn() && self.token.span.rust_2015()) {\n             let prev_span = self.prev_span;\n-            let lo = self.span;\n+            let lo = self.token.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n \n             if pth.segments.len() == 1 {\n@@ -7753,14 +7744,14 @@ impl<'a> Parser<'a> {\n     ///            PATH [`as` IDENT]\n     /// ```\n     fn parse_use_tree(&mut self) -> PResult<'a, UseTree> {\n-        let lo = self.span;\n+        let lo = self.token.span;\n \n         let mut prefix = ast::Path { segments: Vec::new(), span: lo.shrink_to_lo() };\n         let kind = if self.check(&token::OpenDelim(token::Brace)) ||\n                       self.check(&token::BinOp(token::Star)) ||\n                       self.is_import_coupler() {\n             // `use *;` or `use ::*;` or `use {...};` or `use ::{...};`\n-            let mod_sep_ctxt = self.span.ctxt();\n+            let mod_sep_ctxt = self.token.span.ctxt();\n             if self.eat(&token::ModSep) {\n                 prefix.segments.push(\n                     PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt))\n@@ -7813,11 +7804,11 @@ impl<'a> Parser<'a> {\n \n     /// Parses a source module as a crate. This is the main entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n-        let lo = self.span;\n+        let lo = self.token.span;\n         let krate = Ok(ast::Crate {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n-            span: lo.to(self.span),\n+            span: lo.to(self.token.span),\n         });\n         krate\n     }\n@@ -7844,7 +7835,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let msg = \"expected string literal\";\n                 let mut err = self.fatal(msg);\n-                err.span_label(self.span, msg);\n+                err.span_label(self.token.span, msg);\n                 Err(err)\n             }\n         }"}, {"sha": "d922e1896cc9cf0dd3c95d0a7d03340423ba6940", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -168,9 +168,6 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     let mut out = match kind {\n         token::Byte          => format!(\"b'{}'\", symbol),\n         token::Char          => format!(\"'{}'\", symbol),\n-        token::Bool          |\n-        token::Float         |\n-        token::Integer       => symbol.to_string(),\n         token::Str           => format!(\"\\\"{}\\\"\", symbol),\n         token::StrRaw(n)     => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n                                         delim=\"#\".repeat(n as usize),\n@@ -179,7 +176,10 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n         token::ByteStrRaw(n) => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n                                         delim=\"#\".repeat(n as usize),\n                                         string=symbol),\n-        token::Err           => format!(\"'{}'\", symbol),\n+        token::Integer       |\n+        token::Float         |\n+        token::Bool          |\n+        token::Err           => symbol.to_string(),\n     };\n \n     if let Some(suffix) = suffix {"}, {"sha": "24b0c37247191efb3ae0b19bf7bfd70e7b186764", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -714,7 +714,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprKind::Lit(_) => {}\n         ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n@@ -826,7 +825,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::TryBlock(ref body) => {\n             visitor.visit_block(body)\n         }\n-        ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n     }\n \n     visitor.visit_expr_post(expression)"}, {"sha": "10d323ffb89f55b06cd4175912254d283421e048", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -85,7 +85,7 @@ fn parse_assert<'a>(\n     if parser.token == token::Semi {\n         let mut err = cx.struct_span_warn(sp, \"macro requires an expression as an argument\");\n         err.span_suggestion(\n-            parser.span,\n+            parser.token.span,\n             \"try removing semicolon\",\n             String::new(),\n             Applicability::MaybeIncorrect\n@@ -105,7 +105,7 @@ fn parse_assert<'a>(\n     // turned into an error.\n     let custom_message = if let token::Literal(token::Lit { kind: token::Str, .. })\n                                 = parser.token.kind {\n-        let mut err = cx.struct_span_warn(parser.span, \"unexpected string literal\");\n+        let mut err = cx.struct_span_warn(parser.token.span, \"unexpected string literal\");\n         let comma_span = cx.source_map().next_point(parser.prev_span);\n         err.span_suggestion_short(\n             comma_span,"}, {"sha": "68d5178372eba7b774b61dca11a1faa607937a4f", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -22,7 +22,6 @@ pub fn expand_syntax_ext(\n         match e.node {\n             ast::ExprKind::Lit(ref lit) => match lit.node {\n                 ast::LitKind::Str(ref s, _)\n-                | ast::LitKind::Err(ref s)\n                 | ast::LitKind::Float(ref s, _)\n                 | ast::LitKind::FloatUnsuffixed(ref s) => {\n                     accumulator.push_str(&s.as_str());\n@@ -41,6 +40,9 @@ pub fn expand_syntax_ext(\n                 ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..) => {\n                     cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n                 }\n+                ast::LitKind::Err(_) => {\n+                    has_errors = true;\n+                }\n             },\n             ast::ExprKind::Err => {\n                 has_errors = true;"}, {"sha": "377164728f42a2b7c01506332db4378d085a0b1f", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -142,7 +142,7 @@ fn parse_args<'a>(\n \n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n-            return Err(ecx.struct_span_err(p.span, \"expected token: `,`\"));\n+            return Err(ecx.struct_span_err(p.token.span, \"expected token: `,`\"));\n         }\n         if p.token == token::Eof {\n             break;\n@@ -154,7 +154,7 @@ fn parse_args<'a>(\n                 name\n             } else {\n                 return Err(ecx.struct_span_err(\n-                    p.span,\n+                    p.token.span,\n                     \"expected ident, positional arguments cannot follow named arguments\",\n                 ));\n             };"}, {"sha": "20b9b645daead855577be532382a2b6fd831cd87", "filename": "src/test/ui/async-await/issue-61452.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -0,0 +1,14 @@\n+// edition:2018\n+#![feature(async_await)]\n+\n+pub async fn f(x: Option<usize>) {\n+    x.take();\n+    //~^ ERROR cannot borrow `x` as mutable, as it is not declared as mutable [E0596]\n+}\n+\n+pub async fn g(x: usize) {\n+    x += 1;\n+    //~^ ERROR cannot assign twice to immutable variable `x` [E0384]\n+}\n+\n+fn main() {}"}, {"sha": "742490d8de43cf4cf79e5169a96417a0e7e8cbd2", "filename": "src/test/ui/async-await/issue-61452.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61452.stderr?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -0,0 +1,23 @@\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-61452.rs:5:5\n+   |\n+LL | pub async fn f(x: Option<usize>) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+LL |     x.take();\n+   |     ^ cannot borrow as mutable\n+\n+error[E0384]: cannot assign twice to immutable variable `x`\n+  --> $DIR/issue-61452.rs:10:5\n+   |\n+LL | pub async fn g(x: usize) {\n+   |                -\n+   |                |\n+   |                first assignment to `x`\n+   |                help: make this binding mutable: `mut x`\n+LL |     x += 1;\n+   |     ^^^^^^ cannot assign twice to immutable variable\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0384, E0596.\n+For more information about an error, try `rustc --explain E0384`."}, {"sha": "c3975f6b9255e657943b25ab39cd8c3a1720a1a5", "filename": "src/test/ui/extenv/issue-55897.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.rs?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -12,4 +12,9 @@ mod nonexistent_env {\n     //~^ ERROR environment variable `NON_EXISTENT` not defined\n }\n \n+mod erroneous_literal {\n+    include!(concat!(\"NON_EXISTENT\"suffix, \"/data.rs\"));\n+    //~^ ERROR suffixes on a string literal are invalid\n+}\n+\n fn main() {}"}, {"sha": "9d68131beabd7a7fe72f2406ec89a8edf69bbb35", "filename": "src/test/ui/extenv/issue-55897.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6312b89fdabce0aedf613391266e08c0deef2324/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr?ref=6312b89fdabce0aedf613391266e08c0deef2324", "patch": "@@ -4,6 +4,12 @@ error: environment variable `NON_EXISTENT` not defined\n LL |     include!(concat!(env!(\"NON_EXISTENT\"), \"/data.rs\"));\n    |                      ^^^^^^^^^^^^^^^^^^^^\n \n+error: suffixes on a string literal are invalid\n+  --> $DIR/issue-55897.rs:16:22\n+   |\n+LL |     include!(concat!(\"NON_EXISTENT\"suffix, \"/data.rs\"));\n+   |                      ^^^^^^^^^^^^^^^^^^^^ invalid suffix `suffix`\n+\n error[E0432]: unresolved import `prelude`\n   --> $DIR/issue-55897.rs:1:5\n    |\n@@ -21,6 +27,6 @@ LL |     include!(concat!(env!(\"NON_EXISTENT\"), \"/data.rs\"));\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0432`."}]}