{"sha": "ed9a09d40c7c12d87f8923fad5264beb69749d38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkOWEwOWQ0MGM3YzEyZDg3Zjg5MjNmYWQ1MjY0YmViNjk3NDlkMzg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-27T10:58:46Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-30T22:54:40Z"}, "message": "Support paths in macro invocations.", "tree": {"sha": "2acb12be1d6c62c2808f28875e43e74e1c88231c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2acb12be1d6c62c2808f28875e43e74e1c88231c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed9a09d40c7c12d87f8923fad5264beb69749d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed9a09d40c7c12d87f8923fad5264beb69749d38", "html_url": "https://github.com/rust-lang/rust/commit/ed9a09d40c7c12d87f8923fad5264beb69749d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed9a09d40c7c12d87f8923fad5264beb69749d38/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29791ada1ddfbb37c5ad90fc8149577f426cc995", "url": "https://api.github.com/repos/rust-lang/rust/commits/29791ada1ddfbb37c5ad90fc8149577f426cc995", "html_url": "https://github.com/rust-lang/rust/commit/29791ada1ddfbb37c5ad90fc8149577f426cc995"}], "stats": {"total": 169, "additions": 116, "deletions": 53}, "files": [{"sha": "47e6d21cd7d014a2731f4f3071af581c2b8816a8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ed9a09d40c7c12d87f8923fad5264beb69749d38", "patch": "@@ -783,6 +783,7 @@ pub struct ModuleS<'a> {\n \n     resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     legacy_macro_resolutions: RefCell<Vec<(Mark, Name, Span)>>,\n+    macro_resolutions: RefCell<Vec<(Box<[Ident]>, PathScope, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<Mark>>,\n@@ -811,6 +812,7 @@ impl<'a> ModuleS<'a> {\n             normal_ancestor_id: None,\n             resolutions: RefCell::new(FxHashMap()),\n             legacy_macro_resolutions: RefCell::new(Vec::new()),\n+            macro_resolutions: RefCell::new(Vec::new()),\n             unresolved_invocations: RefCell::new(FxHashSet()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n@@ -1316,6 +1318,7 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { resolver: self }.finalize_imports();\n         self.current_module = self.graph_root;\n+        self.finalize_current_module_macro_resolutions();\n         visit::walk_crate(self, krate);\n \n         check_unused::check_crate(self, krate);\n@@ -2359,10 +2362,13 @@ impl<'a> Resolver<'a> {\n \n             let binding = if let Some(module) = module {\n                 self.resolve_name_in_module(module, ident.name, ns, false, record_used)\n+            } else if opt_ns == Some(MacroNS) {\n+                self.resolve_lexical_macro_path_segment(ident.name, ns, record_used)\n             } else {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n-                    Some(LexicalScopeBinding::Def(def)) if opt_ns.is_some() => {\n+                    Some(LexicalScopeBinding::Def(def))\n+                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n                         return PathResult::NonModule(PathResolution {\n                             base_def: def,\n                             depth: path.len() - 1,\n@@ -2378,7 +2384,7 @@ impl<'a> Resolver<'a> {\n                         module = Some(next_module);\n                     } else if binding.def() == Def::Err {\n                         return PathResult::NonModule(err_path_resolution());\n-                    } else if opt_ns.is_some() {\n+                    } else if opt_ns.is_some() && !(opt_ns == Some(MacroNS) && !is_last) {\n                         return PathResult::NonModule(PathResolution {\n                             base_def: binding.def(),\n                             depth: path.len() - i - 1,\n@@ -3059,15 +3065,22 @@ impl<'a> Resolver<'a> {\n \n         for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n             if !reported_spans.insert(span) { continue }\n-            let msg1 = format!(\"`{}` could resolve to the name imported here\", name);\n-            let msg2 = format!(\"`{}` could also resolve to the name imported here\", name);\n+            let participle = |binding: &NameBinding| {\n+                if binding.is_import() { \"imported\" } else { \"defined\" }\n+            };\n+            let msg1 = format!(\"`{}` could resolve to the name {} here\", name, participle(b1));\n+            let msg2 = format!(\"`{}` could also resolve to the name {} here\", name, participle(b2));\n             self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n                 .span_note(b1.span, &msg1)\n                 .span_note(b2.span, &msg2)\n-                .note(&if lexical || !b1.is_glob_import() {\n-                    \"macro-expanded macro imports do not shadow\".to_owned()\n-                } else {\n+                .note(&if !lexical && b1.is_glob_import() {\n                     format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n+                } else if let Def::Macro(..) = b1.def() {\n+                    format!(\"macro-expanded {} do not shadow\",\n+                            if b1.is_import() { \"macro imports\" } else { \"macros\" })\n+                } else {\n+                    format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n+                            if b1.is_import() { \"imports\" } else { \"items\" })\n                 })\n                 .emit();\n         }"}, {"sha": "6c02967672d84f48d0ffbadef20e2b9a18dcf888", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 79, "deletions": 39, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ed9a09d40c7c12d87f8923fad5264beb69749d38", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {Module, ModuleKind, NameBinding, NameBindingKind, Resolver, AmbiguityError};\n+use {AmbiguityError, Resolver, ResolutionError, resolve_error};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathScope, PathResult};\n use Namespace::{self, MacroNS};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use resolve_imports::ImportResolver;\n@@ -25,6 +26,7 @@ use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::fold::Folder;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -207,75 +209,103 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n-            self.session.span_err(path.span, \"expected macro name without module separators\");\n+        let ast::Path { ref segments, global, span } = *path;\n+        if segments.iter().any(|segment| !segment.parameters.is_empty()) {\n+            let kind =\n+                if segments.last().unwrap().parameters.is_empty() { \"module\" } else { \"macro\" };\n+            let msg = format!(\"type parameters are not allowed on {}s\", kind);\n+            self.session.span_err(path.span, &msg);\n             return Err(Determinacy::Determined);\n         }\n-        let name = path.segments[0].identifier.name;\n \n+        let path_scope = if global { PathScope::Global } else { PathScope::Lexical };\n+        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n         let invocation = self.invocations[&scope];\n         self.current_module = invocation.module.get();\n-        let ext = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n-            Some(MacroBinding::Legacy(binding)) => binding.ext.clone(),\n-            Some(MacroBinding::Modern(binding)) => binding.get_macro(self),\n-            None => match self.resolve_in_item_lexical_scope(name, MacroNS, None) {\n-                Some(binding) => binding.get_macro(self),\n-                None => return Err(if force {\n+\n+        if path.len() > 1 || global {\n+            if !self.use_extern_macros {\n+                let msg = \"non-ident macro paths are experimental\";\n+                let feature = \"use_extern_macros\";\n+                emit_feature_err(&self.session.parse_sess, feature, span, GateIssue::Language, msg);\n+                return Err(Determinacy::Determined);\n+            }\n+\n+            let ext = match self.resolve_path(&path, path_scope, Some(MacroNS), None) {\n+                PathResult::NonModule(path_res) => Ok(self.get_macro(path_res.base_def)),\n+                PathResult::Module(..) => unreachable!(),\n+                PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n+                _ => Err(Determinacy::Determined),\n+            };\n+            self.current_module.macro_resolutions.borrow_mut()\n+                .push((path.into_boxed_slice(), path_scope, span));\n+            return ext;\n+        }\n+\n+        let name = path[0].name;\n+        let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n+            Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n+            Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n+            None => match self.resolve_lexical_macro_path_segment(name, MacroNS, None) {\n+                Ok(binding) => Ok(binding.get_macro(self)),\n+                Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n+                _ => {\n                     let msg = format!(\"macro undefined: '{}!'\", name);\n-                    let mut err = self.session.struct_span_err(path.span, &msg);\n+                    let mut err = self.session.struct_span_err(span, &msg);\n                     self.suggest_macro_name(&name.as_str(), &mut err);\n                     err.emit();\n-                    Determinacy::Determined\n-                } else {\n-                    Determinacy::Undetermined\n-                }),\n+                    return Err(Determinacy::Determined);\n+                },\n             },\n         };\n \n         if self.use_extern_macros {\n-            self.current_module.legacy_macro_resolutions.borrow_mut()\n-                .push((scope, name, path.span));\n+            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, name, span));\n         }\n-        Ok(ext)\n+        result\n     }\n }\n \n impl<'a> Resolver<'a> {\n-    // Resolve the name in the module's lexical scope, excluding non-items.\n-    fn resolve_in_item_lexical_scope(&mut self,\n-                                     name: Name,\n-                                     ns: Namespace,\n-                                     record_used: Option<Span>)\n-                                     -> Option<&'a NameBinding<'a>> {\n+    // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n+    pub fn resolve_lexical_macro_path_segment(&mut self,\n+                                              name: Name,\n+                                              ns: Namespace,\n+                                              record_used: Option<Span>)\n+                                              -> Result<&'a NameBinding<'a>, Determinacy> {\n         let mut module = self.current_module;\n-        let mut potential_expanded_shadower = None;\n+        let mut potential_expanded_shadower: Option<&NameBinding> = None;\n         loop {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n             match self.resolve_name_in_module(module, name, ns, true, record_used) {\n                 Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n-                        None => return Some(binding),\n+                        None => return Ok(binding),\n                     };\n-                    if let Some(shadower) = potential_expanded_shadower {\n-                        self.ambiguity_errors.push(AmbiguityError {\n-                            span: span, name: name, b1: shadower, b2: binding, lexical: true,\n-                        });\n-                        return Some(shadower);\n-                    } else if binding.expansion == Mark::root() {\n-                        return Some(binding);\n-                    } else {\n-                        potential_expanded_shadower = Some(binding);\n+                    match potential_expanded_shadower {\n+                        Some(shadower) if shadower.def() != binding.def() => {\n+                            self.ambiguity_errors.push(AmbiguityError {\n+                                span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                            });\n+                            return Ok(shadower);\n+                        }\n+                        _ if binding.expansion == Mark::root() => return Ok(binding),\n+                        _ => potential_expanded_shadower = Some(binding),\n                     }\n                 },\n-                Err(Determinacy::Undetermined) => return None,\n+                Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {}\n             }\n \n             match module.kind {\n                 ModuleKind::Block(..) => module = module.parent.unwrap(),\n-                ModuleKind::Def(..) => return potential_expanded_shadower,\n+                ModuleKind::Def(..) => return match potential_expanded_shadower {\n+                    Some(binding) => Ok(binding),\n+                    None if record_used.is_some() => Err(Determinacy::Determined),\n+                    None => Err(Determinacy::Undetermined),\n+                },\n             }\n         }\n     }\n@@ -343,12 +373,22 @@ impl<'a> Resolver<'a> {\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n+        for &(ref path, scope, span) in module.macro_resolutions.borrow().iter() {\n+            match self.resolve_path(path, scope, Some(MacroNS), Some(span)) {\n+                PathResult::NonModule(_) => {},\n+                PathResult::Failed(msg, _) => {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+\n         for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n-            let resolution = self.resolve_in_item_lexical_scope(name, MacroNS, Some(span));\n+            let resolution = self.resolve_lexical_macro_path_segment(name, MacroNS, Some(span));\n             let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n-                (Some(legacy_resolution), Some(resolution)) => (legacy_resolution, resolution),\n+                (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n                 _ => continue,\n             };\n             let (legacy_span, participle) = match legacy_resolution {"}, {"sha": "b634d57a842f65626078581a10021f2e47c4075f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ed9a09d40c7c12d87f8923fad5264beb69749d38", "patch": "@@ -10,7 +10,7 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {Module, PerNS};\n+use {AmbiguityError, Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError, ToNameBinding};\n use Resolver;\n@@ -73,6 +73,7 @@ pub struct NameResolution<'a> {\n     single_imports: SingleImports<'a>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n+    shadows_glob: Option<&'a NameBinding<'a>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -151,6 +152,18 @@ impl<'a> Resolver<'a> {\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n+                if let Some(shadowed_glob) = resolution.shadows_glob {\n+                    // If we ignore unresolved invocations, we must forbid\n+                    // expanded shadowing to avoid time travel.\n+                    if ignore_unresolved_invocations &&\n+                       binding.expansion != Mark::root() &&\n+                       ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n+                       binding.def() != shadowed_glob.def() {\n+                        self.ambiguity_errors.push(AmbiguityError {\n+                            span: span, name: name, lexical: false, b1: binding, b2: shadowed_glob,\n+                        });\n+                    }\n+                }\n                 if self.record_use(name, ns, binding, span) {\n                     return Ok(self.dummy_binding);\n                 }\n@@ -298,6 +311,7 @@ impl<'a> Resolver<'a> {\n                 if binding.is_glob_import() {\n                     if !old_binding.is_glob_import() &&\n                        !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n+                        resolution.shadows_glob = Some(binding);\n                     } else if binding.def() != old_binding.def() {\n                         resolution.binding = Some(this.ambiguity(old_binding, binding));\n                     } else if !old_binding.vis.is_at_least(binding.vis, this) {\n@@ -310,6 +324,7 @@ impl<'a> Resolver<'a> {\n                         resolution.binding = Some(this.ambiguity(binding, old_binding));\n                     } else {\n                         resolution.binding = Some(binding);\n+                        resolution.shadows_glob = Some(old_binding);\n                     }\n                 } else {\n                     return Err(old_binding);"}, {"sha": "4138acafac69af357fe898d62fac59ac704a5093", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed9a09d40c7c12d87f8923fad5264beb69749d38/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ed9a09d40c7c12d87f8923fad5264beb69749d38", "patch": "@@ -400,12 +400,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                           &self.cx.ecfg.features.unwrap());\n         }\n \n-        if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n-            self.cx.span_err(path.span, \"expected macro name without module separators\");\n-            return kind.dummy(span);\n-        }\n-\n-        let extname = path.segments[0].identifier.name;\n+        let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n         let opt_expanded = match *ext {"}]}