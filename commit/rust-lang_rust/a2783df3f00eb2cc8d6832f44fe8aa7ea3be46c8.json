{"sha": "a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNzgzZGYzZjAwZWIyY2M4ZDY4MzJmNDRmZThhYTdlYTNiZTQ2Yzg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-11T11:11:33Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-11T16:04:09Z"}, "message": "Look up impls by self type\n\nThis speeds up inference in analysis-stats by ~30% (even more with the recursive\nsolver).", "tree": {"sha": "168946c8e358b8b85388ed3e75c82b682888a9cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/168946c8e358b8b85388ed3e75c82b682888a9cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "html_url": "https://github.com/rust-lang/rust/commit/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bd14a34834919f2e8f329ef1eaf0b15ad4d9680", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bd14a34834919f2e8f329ef1eaf0b15ad4d9680", "html_url": "https://github.com/rust-lang/rust/commit/8bd14a34834919f2e8f329ef1eaf0b15ad4d9680"}], "stats": {"total": 79, "additions": 65, "deletions": 14}, "files": [{"sha": "33da16b487a9dfdf0c9aa4d2698c68695c3c30dd", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "patch": "@@ -11,7 +11,7 @@ use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n use ra_prof::profile;\n \n use crate::{\n-    method_resolution::CrateImplDefs,\n+    method_resolution::{CrateImplDefs, TyFingerprint},\n     traits::{chalk, AssocTyValue, Impl},\n     Binders, CallableDef, GenericPredicate, InferenceResult, PolyFnSig, Substs, TraitRef, Ty,\n     TyDefId, TypeCtor, ValueTyDefId,\n@@ -65,7 +65,12 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplDefs>;\n \n     #[salsa::invoke(crate::traits::impls_for_trait_query)]\n-    fn impls_for_trait(&self, krate: CrateId, trait_: TraitId) -> Arc<[ImplId]>;\n+    fn impls_for_trait(\n+        &self,\n+        krate: CrateId,\n+        trait_: TraitId,\n+        self_ty_fp: Option<TyFingerprint>,\n+    ) -> Arc<[ImplId]>;\n \n     // Interned IDs for Chalk integration\n     #[salsa::interned]"}, {"sha": "657284fd018ae3da455f24dbe946b8ad55a7e964", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "patch": "@@ -34,7 +34,7 @@ impl TyFingerprint {\n     /// Creates a TyFingerprint for looking up an impl. Only certain types can\n     /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n     /// `impl &S`. Hence, this will return `None` for reference types and such.\n-    fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n+    pub(crate) fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n         match ty {\n             Ty::Apply(a_ty) => Some(TyFingerprint::Apply(a_ty.ctor)),\n             _ => None,\n@@ -45,7 +45,7 @@ impl TyFingerprint {\n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplDefs {\n     impls: FxHashMap<TyFingerprint, Vec<ImplId>>,\n-    impls_by_trait: FxHashMap<TraitId, Vec<ImplId>>,\n+    impls_by_trait: FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>,\n }\n \n impl CrateImplDefs {\n@@ -59,7 +59,14 @@ impl CrateImplDefs {\n             for impl_id in module_data.scope.impls() {\n                 match db.impl_trait(impl_id) {\n                     Some(tr) => {\n-                        res.impls_by_trait.entry(tr.value.trait_).or_default().push(impl_id);\n+                        let self_ty = db.impl_self_ty(impl_id);\n+                        let self_ty_fp = TyFingerprint::for_impl(&self_ty.value);\n+                        res.impls_by_trait\n+                            .entry(tr.value.trait_)\n+                            .or_default()\n+                            .entry(self_ty_fp)\n+                            .or_default()\n+                            .push(impl_id);\n                     }\n                     None => {\n                         let self_ty = db.impl_self_ty(impl_id);\n@@ -79,11 +86,39 @@ impl CrateImplDefs {\n     }\n \n     pub fn lookup_impl_defs_for_trait(&self, tr: TraitId) -> impl Iterator<Item = ImplId> + '_ {\n-        self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n+        self.impls_by_trait\n+            .get(&tr)\n+            .into_iter()\n+            .flat_map(|m| m.values().flat_map(|v| v.iter().copied()))\n+    }\n+\n+    pub fn lookup_impl_defs_for_trait_and_ty(\n+        &self,\n+        tr: TraitId,\n+        fp: TyFingerprint,\n+    ) -> impl Iterator<Item = ImplId> + '_ {\n+        self.impls_by_trait\n+            .get(&tr)\n+            .and_then(|m| m.get(&Some(fp)))\n+            .into_iter()\n+            .flatten()\n+            .copied()\n+            .chain(\n+                self.impls_by_trait\n+                    .get(&tr)\n+                    .and_then(|m| m.get(&None))\n+                    .into_iter()\n+                    .flatten()\n+                    .copied(),\n+            )\n     }\n \n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplId> + 'a {\n-        self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n+        self.impls\n+            .values()\n+            .chain(self.impls_by_trait.values().flat_map(|m| m.values()))\n+            .flatten()\n+            .copied()\n     }\n }\n "}, {"sha": "43d8d1e802e1fdf7b7c2cba0a3153fefc83cdf6e", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "patch": "@@ -7,7 +7,7 @@ use ra_db::{impl_intern_key, salsa, CrateId};\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n-use crate::{db::HirDatabase, DebruijnIndex};\n+use crate::{db::HirDatabase, method_resolution::TyFingerprint, DebruijnIndex};\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n \n@@ -40,18 +40,26 @@ pub(crate) fn impls_for_trait_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n     trait_: TraitId,\n+    self_ty_fp: Option<TyFingerprint>,\n ) -> Arc<[ImplId]> {\n+    // FIXME: We could be a lot smarter here - because of the orphan rules and\n+    // the fact that the trait and the self type need to be in the dependency\n+    // tree of a crate somewhere for an impl to exist, we could skip looking in\n+    // a lot of crates completely\n     let mut impls = FxHashSet::default();\n     // We call the query recursively here. On the one hand, this means we can\n     // reuse results from queries for different crates; on the other hand, this\n     // will only ever get called for a few crates near the root of the tree (the\n     // ones the user is editing), so this may actually be a waste of memory. I'm\n     // doing it like this mainly for simplicity for now.\n     for dep in &db.crate_graph()[krate].dependencies {\n-        impls.extend(db.impls_for_trait(dep.crate_id, trait_).iter());\n+        impls.extend(db.impls_for_trait(dep.crate_id, trait_, self_ty_fp).iter());\n     }\n     let crate_impl_defs = db.impls_in_crate(krate);\n-    impls.extend(crate_impl_defs.lookup_impl_defs_for_trait(trait_));\n+    match self_ty_fp {\n+        Some(fp) => impls.extend(crate_impl_defs.lookup_impl_defs_for_trait_and_ty(trait_, fp)),\n+        None => impls.extend(crate_impl_defs.lookup_impl_defs_for_trait(trait_)),\n+    }\n     impls.into_iter().collect()\n }\n "}, {"sha": "e05fea8430f352ca19c21d1301b89896072b2573", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=a2783df3f00eb2cc8d6832f44fe8aa7ea3be46c8", "patch": "@@ -16,8 +16,8 @@ use ra_db::{\n \n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n-    db::HirDatabase, display::HirDisplay, utils::generics, ApplicationTy, GenericPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    db::HirDatabase, display::HirDisplay, method_resolution::TyFingerprint, utils::generics,\n+    ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n \n pub(super) mod tls;\n@@ -647,19 +647,22 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         debug!(\"impls_for_trait {:?}\", trait_id);\n         let trait_: hir_def::TraitId = from_chalk(self.db, trait_id);\n \n+        let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref(&Interner).clone());\n+\n+        let self_ty_fp = TyFingerprint::for_impl(&ty);\n+\n         // Note: Since we're using impls_for_trait, only impls where the trait\n         // can be resolved should ever reach Chalk. `impl_datum` relies on that\n         // and will panic if the trait can't be resolved.\n         let mut result: Vec<_> = self\n             .db\n-            .impls_for_trait(self.krate, trait_)\n+            .impls_for_trait(self.krate, trait_, self_ty_fp)\n             .iter()\n             .copied()\n             .map(Impl::ImplDef)\n             .map(|impl_| impl_.to_chalk(self.db))\n             .collect();\n \n-        let ty: Ty = from_chalk(self.db, parameters[0].assert_ty_ref(&Interner).clone());\n         let arg: Option<Ty> =\n             parameters.get(1).map(|p| from_chalk(self.db, p.assert_ty_ref(&Interner).clone()));\n "}]}