{"sha": "f1694eac74216da22b395a5589b8d080ccd5a2ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjk0ZWFjNzQyMTZkYTIyYjM5NWE1NTg5YjhkMDgwY2NkNWEyZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-27T16:54:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-27T16:54:28Z"}, "message": "Auto merge of #54533 - ljedrz:cleanup_librustc_typeck_check, r=davidtwco\n\nA few cleanups and minor improvements to typeck/check\n\n- turn a `loop` into a `while let`\n- turn a `push_back` loop into an `extend`\n- turn a few `push` loops into collected iterators\n- prefer `vec![x; n]` to `(0..n).map(|_| x).collect()`\n- combine two loops doing the same thing on 2 data sets using `chain`\n- use `unwrap_or` where applicable and readable\n- add a `potentially_plural_count` helper function to simplify several `format!()` calls\n- prefer `to_owned` to `to_string` for string literals\n- change `match` to `if let` where only one branch matters\n- a few other minor improvements\n- whitespace fixes", "tree": {"sha": "ea703853b6e83c9fa2e46cc788590b83230302ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea703853b6e83c9fa2e46cc788590b83230302ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1694eac74216da22b395a5589b8d080ccd5a2ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1694eac74216da22b395a5589b8d080ccd5a2ec", "html_url": "https://github.com/rust-lang/rust/commit/f1694eac74216da22b395a5589b8d080ccd5a2ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1694eac74216da22b395a5589b8d080ccd5a2ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9865b1c37f8cb8a257591e6ea0b32a5df1f3d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9865b1c37f8cb8a257591e6ea0b32a5df1f3d41", "html_url": "https://github.com/rust-lang/rust/commit/c9865b1c37f8cb8a257591e6ea0b32a5df1f3d41"}, {"sha": "3527276dba98a307976f58e269a5b193d6b8194b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3527276dba98a307976f58e269a5b193d6b8194b", "html_url": "https://github.com/rust-lang/rust/commit/3527276dba98a307976f58e269a5b193d6b8194b"}], "stats": {"total": 1031, "additions": 450, "deletions": 581}, "files": [{"sha": "88e2e02cf503f14725722f7f18e4968fc9ba52b1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -81,35 +81,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             //\n             // See the examples in `run-pass/match-defbm*.rs`.\n             let mut pat_adjustments = vec![];\n-            expected = loop {\n+            while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n                 debug!(\"inspecting {:?} with type {:?}\", exp_ty, exp_ty.sty);\n-                match exp_ty.sty {\n-                    ty::Ref(_, inner_ty, inner_mutability) => {\n-                        debug!(\"current discriminant is Ref, inserting implicit deref\");\n-                        // Preserve the reference type. We'll need it later during HAIR lowering.\n-                        pat_adjustments.push(exp_ty);\n-\n-                        exp_ty = inner_ty;\n-                        def_bm = match def_bm {\n-                            // If default binding mode is by value, make it `ref` or `ref mut`\n-                            // (depending on whether we observe `&` or `&mut`).\n-                            ty::BindByValue(_) =>\n-                                ty::BindByReference(inner_mutability),\n-\n-                            // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n-                            // the underlying value.\n-                            ty::BindByReference(hir::Mutability::MutImmutable) =>\n-                                ty::BindByReference(hir::Mutability::MutImmutable),\n-\n-                            // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n-                            // (on `&`).\n-                            ty::BindByReference(hir::Mutability::MutMutable) =>\n-                                ty::BindByReference(inner_mutability),\n-                        };\n-                    },\n-                    _ => break exp_ty,\n-                }\n-            };\n+\n+                debug!(\"current discriminant is Ref, inserting implicit deref\");\n+                // Preserve the reference type. We'll need it later during HAIR lowering.\n+                pat_adjustments.push(exp_ty);\n+\n+                exp_ty = inner_ty;\n+                def_bm = match def_bm {\n+                    // If default binding mode is by value, make it `ref` or `ref mut`\n+                    // (depending on whether we observe `&` or `&mut`).\n+                    ty::BindByValue(_) =>\n+                        ty::BindByReference(inner_mutability),\n+\n+                    // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n+                    // the underlying value.\n+                    ty::BindByReference(hir::Mutability::MutImmutable) =>\n+                        ty::BindByReference(hir::Mutability::MutImmutable),\n+\n+                    // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n+                    // (on `&`).\n+                    ty::BindByReference(hir::Mutability::MutMutable) =>\n+                        ty::BindByReference(inner_mutability),\n+                };\n+            }\n+            expected = exp_ty;\n+\n             if pat_adjustments.len() > 0 {\n                 debug!(\"default binding mode is now {:?}\", def_bm);\n                 self.inh.tables.borrow_mut()\n@@ -153,7 +151,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n                             if let ty::Slice(_) = r_ty.sty {\n                                 pat_ty = tcx.mk_imm_ref(tcx.types.re_static,\n-                                                         tcx.mk_slice(tcx.types.u8))\n+                                                        tcx.mk_slice(tcx.types.u8))\n                             }\n                         }\n                     }\n@@ -294,7 +292,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n                     // FIXME: MiscVariable for now, obtaining the span and name information\n-                    //       from all tuple elements isn't trivial.\n+                    //        from all tuple elements isn't trivial.\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n@@ -394,7 +392,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     tcx.sess, pat.span, E0527,\n                                     \"pattern requires {} elements but array has {}\",\n                                     min_len, size)\n-                                    .span_label(pat.span, format!(\"expected {} elements\",size))\n+                                    .span_label(pat.span, format!(\"expected {} elements\", size))\n                                     .emit();\n                             }\n                             (inner_ty, tcx.types.err)\n@@ -857,7 +855,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                              subpats.len(), subpats_ending, def.kind_name(),\n                              variant.fields.len(),  fields_ending)\n                 .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n-                                               variant.fields.len(), fields_ending, subpats.len()))\n+                                              variant.fields.len(), fields_ending, subpats.len()))\n                 .emit();\n             on_error();\n             return tcx.types.err;"}, {"sha": "de4293aaaeac79ef676869c4f1da015c0c8b291c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -166,34 +166,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => continue,\n             };\n \n-            match self.lookup_method_in_trait(call_expr.span,\n-                                              method_name,\n-                                              trait_def_id,\n-                                              adjusted_ty,\n-                                              None) {\n-                None => continue,\n-                Some(ok) => {\n-                    let method = self.register_infer_ok_obligations(ok);\n-                    let mut autoref = None;\n-                    if borrow {\n-                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n-                            let mutbl = match mutbl {\n-                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                    // For initial two-phase borrow\n-                                    // deployment, conservatively omit\n-                                    // overloaded function call ops.\n-                                    allow_two_phase_borrow: AllowTwoPhase::No,\n-                                }\n-                            };\n-                            autoref = Some(Adjustment {\n-                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                target: method.sig.inputs()[0]\n-                            });\n-                        }\n+            if let Some(ok) = self.lookup_method_in_trait(call_expr.span,\n+                                                          method_name,\n+                                                          trait_def_id,\n+                                                          adjusted_ty,\n+                                                          None) {\n+                let method = self.register_infer_ok_obligations(ok);\n+                let mut autoref = None;\n+                if borrow {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                        let mutbl = match mutbl {\n+                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                // For initial two-phase borrow\n+                                // deployment, conservatively omit\n+                                // overloaded function call ops.\n+                                allow_two_phase_borrow: AllowTwoPhase::No,\n+                            }\n+                        };\n+                        autoref = Some(Adjustment {\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                            target: method.sig.inputs()[0]\n+                        });\n                     }\n-                    return Some((autoref, method));\n                 }\n+                return Some((autoref, method));\n             }\n         }\n \n@@ -238,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     err.span_suggestion_with_applicability(\n                         call_expr.span,\n                         &format!(\"`{}` is a unit variant, you need to write it \\\n-                                 without the parenthesis\", path),\n+                                  without the parenthesis\", path),\n                         path.to_string(),\n                         Applicability::MachineApplicable\n                     );"}, {"sha": "564ecae15dc35ba9001ecddfb79cfa3dc120f233", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -219,11 +219,11 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 let cast_ty = fcx.ty_to_string(self.cast_ty);\n                 err.span_label(error_span,\n                                format!(\"cannot cast `{}` as `{}`\",\n-                                        fcx.ty_to_string(self.expr_ty),\n-                                        cast_ty));\n+                                       fcx.ty_to_string(self.expr_ty),\n+                                       cast_ty));\n                 if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr.span) {\n                     err.span_help(self.expr.span,\n-                                   &format!(\"did you mean `*{}`?\", snippet));\n+                        &format!(\"did you mean `*{}`?\", snippet));\n                 }\n                 err.emit();\n             }\n@@ -267,16 +267,16 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             }\n             CastError::CastToChar => {\n                 type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0604,\n-                                 \"only `u8` can be cast as `char`, not `{}`\", self.expr_ty).emit();\n+                    \"only `u8` can be cast as `char`, not `{}`\", self.expr_ty).emit();\n             }\n             CastError::NonScalar => {\n                 type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0605,\n-                                 \"non-primitive cast: `{}` as `{}`\",\n-                                 self.expr_ty,\n-                                 fcx.ty_to_string(self.cast_ty))\n-                                .note(\"an `as` expression can only be used to convert between \\\n-                                       primitive types. Consider using the `From` trait\")\n-                                .emit();\n+                                   \"non-primitive cast: `{}` as `{}`\",\n+                                   self.expr_ty,\n+                                   fcx.ty_to_string(self.cast_ty))\n+                                  .note(\"an `as` expression can only be used to convert between \\\n+                                         primitive types. Consider using the `From` trait\")\n+                                  .emit();\n             }\n             CastError::SizedUnsizedCast => {\n                 use structured_errors::{SizedUnsizedCastError, StructuredDiagnostic};\n@@ -445,7 +445,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                              self.expr_ty,\n                                              fcx.tcx.mk_fn_ptr(f),\n                                              AllowTwoPhase::No);\n-                    if !res.is_ok() {\n+                    if res.is_err() {\n                         return Err(CastError::NonScalar);\n                     }\n                     (FnPtr, t_cast)"}, {"sha": "202789d1d8af6edbef4b8d4fdb921fb6534dfef6", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -231,20 +231,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                match obligation.predicate {\n+                if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n-                    ty::Predicate::Projection(ref proj_predicate) => {\n-                        let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n-                        self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                            .and_then(|_| {\n-                                self.deduce_sig_from_projection(\n-                                    Some(obligation.cause.span),\n-                                    proj_predicate,\n-                                )\n-                            })\n-                    }\n-                    _ => None,\n+                    let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n+                    self.self_type_matches_expected_vid(trait_ref, expected_vid)\n+                        .and_then(|_| {\n+                            self.deduce_sig_from_projection(\n+                                Some(obligation.cause.span),\n+                                proj_predicate\n+                            )\n+                        })\n+                } else {\n+                    None\n                 }\n             })\n             .next();\n@@ -318,9 +317,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let input_tys = match arg_param_ty.sty {\n             ty::Tuple(tys) => tys.into_iter(),\n-            _ => {\n-                return None;\n-            }\n+            _ => return None\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;\n@@ -560,8 +557,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // The liberated version of this signature should be be a subtype\n             // of the liberated form of the expectation.\n             for ((hir_ty, &supplied_ty), expected_ty) in decl.inputs.iter()\n-                           .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n-                           .zip(expected_sigs.liberated_sig.inputs())\n+               .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n+               .zip(expected_sigs.liberated_sig.inputs())\n             // `liberated_sig` is E'.\n             {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n@@ -638,11 +635,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.types.err\n         });\n \n-        match decl.output {\n-            hir::Return(ref output) => {\n-                astconv.ast_ty_to_ty(&output);\n-            }\n-            hir::DefaultReturn(_) => {}\n+        if let hir::Return(ref output) = decl.output {\n+            astconv.ast_ty_to_ty(&output);\n         }\n \n         let result = ty::Binder::bind(self.tcx.mk_fn_sig("}, {"sha": "967c710ac34a1ae9392f799db16169e673820c5e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -144,8 +144,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n             if self.use_lub {\n-                self.at(&self.cause, self.fcx.param_env)\n-                    .lub(b, a)\n+                self.at(&self.cause, self.fcx.param_env).lub(b, a)\n             } else {\n                 self.at(&self.cause, self.fcx.param_env)\n                     .sup(b, a)\n@@ -256,8 +255,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                b: Ty<'tcx>,\n                                r_b: ty::Region<'tcx>,\n                                mt_b: TypeAndMut<'tcx>)\n-                               -> CoerceResult<'tcx> {\n-\n+                               -> CoerceResult<'tcx>\n+    {\n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n         // If we have a parameter of type `&M T_a` and the value\n@@ -591,9 +590,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 }\n \n                 Ok(Some(vtable)) => {\n-                    for obligation in vtable.nested_obligations() {\n-                        queue.push_back(obligation);\n-                    }\n+                    queue.extend(vtable.nested_obligations())\n                 }\n             }\n         }\n@@ -620,12 +617,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n               G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n     {\n         if let ty::FnPtr(fn_ty_b) = b.sty {\n-            match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n-                (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n-                    let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify_and(unsafe_a, b, to_unsafe);\n-                }\n-                _ => {}\n+            if let (hir::Unsafety::Normal, hir::Unsafety::Unsafe)\n+                = (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n+            {\n+                let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n+                return self.unify_and(unsafe_a, b, to_unsafe);\n             }\n         }\n         self.unify_and(a, b, normal)\n@@ -653,7 +649,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                            -> CoerceResult<'tcx> {\n         //! Attempts to coerce from the type of a Rust function item\n         //! into a closure or a `proc`.\n-        //!\n \n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n@@ -724,9 +719,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let (is_ref, mt_a) = match a.sty {\n             ty::Ref(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n             ty::RawPtr(mt) => (false, mt),\n-            _ => {\n-                return self.unify_and(a, b, identity);\n-            }\n+            _ => return self.unify_and(a, b, identity)\n         };\n \n         // Check that the types which they point at are compatible.\n@@ -896,10 +889,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if !noop {\n-                return self.commit_if_ok(|_| {\n+                return self.commit_if_ok(|_|\n                     self.at(cause, self.param_env)\n                         .lub(prev_ty, new_ty)\n-                }).map(|ok| self.register_infer_ok_obligations(ok));\n+                ).map(|ok| self.register_infer_ok_obligations(ok));\n             }\n         }\n \n@@ -909,10 +902,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(e) = first_error {\n                     Err(e)\n                 } else {\n-                    self.commit_if_ok(|_| {\n+                    self.commit_if_ok(|_|\n                         self.at(cause, self.param_env)\n                             .lub(prev_ty, new_ty)\n-                    }).map(|ok| self.register_infer_ok_obligations(ok))\n+                    ).map(|ok| self.register_infer_ok_obligations(ok))\n                 }\n             }\n             Ok(ok) => {\n@@ -1005,7 +998,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     /// needlessly cloning the slice.\n     pub fn with_coercion_sites(expected_ty: Ty<'tcx>,\n                                coercion_sites: &'exprs [E])\n-                      -> Self {\n+                               -> Self {\n         Self::make(expected_ty, Expressions::UpFront(coercion_sites))\n     }\n "}, {"sha": "29770dc12eb3349e9fa249ce118afa75efa3e21f", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 43, "deletions": 71, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -20,7 +20,7 @@ use errors::Applicability;\n \n use syntax_pos::Span;\n \n-use super::{Inherited, FnCtxt};\n+use super::{Inherited, FnCtxt, potentially_plural_count};\n \n /// Checks that a method from an impl conforms to the signature of\n /// the same method as declared in the trait.\n@@ -209,8 +209,8 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // We then register the obligations from the impl_m and check to see\n     // if all constraints hold.\n-    hybrid_preds.predicates\n-                .extend(trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n+    hybrid_preds.predicates.extend(\n+        trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n@@ -320,12 +320,12 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             trait_m.ident);\n             if let TypeError::Mutability = terr {\n                 if let Some(trait_err_span) = trait_err_span {\n-                    if let Ok(trait_err_str) = tcx.sess.source_map().\n-                                               span_to_snippet(trait_err_span) {\n+                    if let Ok(trait_err_str) = tcx.sess.source_map()\n+                                                       .span_to_snippet(trait_err_span) {\n                         diag.span_suggestion_with_applicability(\n                             impl_err_span,\n                             \"consider change the type to match the mutability in trait\",\n-                            format!(\"{}\", trait_err_str),\n+                            trait_err_str.to_string(),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n@@ -334,7 +334,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             infcx.note_type_err(&mut diag,\n                                 &cause,\n-                                trait_err_span.map(|sp| (sp, \"type in trait\".to_string())),\n+                                trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_fty,\n                                     found: impl_fty,\n@@ -408,7 +408,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return Err(ErrorReported);\n     }\n \n-    return Ok(());\n+    Ok(())\n }\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n@@ -470,14 +470,14 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                 impl_iter.zip(trait_iter)\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n-                         .filter_map(|(((&impl_arg_ty, &trait_arg_ty), impl_arg), trait_arg)| {\n+                         .filter_map(|(((&impl_arg_ty, &trait_arg_ty), impl_arg), trait_arg)|\n                              match infcx.at(&cause, param_env).sub(trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n                                  Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n                              }\n-                         })\n+                         )\n                          .next()\n-                         .unwrap_or_else(|| {\n+                         .unwrap_or_else(||\n                              if\n                                  infcx.at(&cause, param_env)\n                                       .sup(trait_sig.output(), impl_sig.output())\n@@ -487,7 +487,7 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                              } else {\n                                  (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id))\n                              }\n-                         })\n+                         )\n             } else {\n                 (cause.span(&tcx), tcx.hir.span_if_local(trait_m.def_id))\n             }\n@@ -526,9 +526,9 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             );\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n-                ExplicitSelf::ByValue => \"self\".to_string(),\n-                ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_string(),\n-                ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_string(),\n+                ExplicitSelf::ByValue => \"self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_owned(),\n                 _ => format!(\"self: {}\", self_arg_ty)\n             }\n         })\n@@ -591,6 +591,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.own_counts().types;\n     let num_trait_m_type_params = trait_m_generics.own_counts().types;\n+\n     if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n         let impl_m_item = tcx.hir.expect_impl_item(impl_m_node_id);\n@@ -600,43 +601,26 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             impl_m_item.generics.span\n         };\n \n-        let mut err = struct_span_err!(tcx.sess,\n-                                       span,\n-                                       E0049,\n-                                       \"method `{}` has {} type parameter{} but its trait \\\n-                                        declaration has {} type parameter{}\",\n-                                       trait_m.ident,\n-                                       num_impl_m_type_params,\n-                                       if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n-                                       num_trait_m_type_params,\n-                                       if num_trait_m_type_params == 1 {\n-                                           \"\"\n-                                       } else {\n-                                           \"s\"\n-                                       });\n+        let mut err = struct_span_err!(tcx.sess, span, E0049,\n+            \"method `{}` has {} but its trait declaration has {}\",\n+            trait_m.ident,\n+            potentially_plural_count(num_impl_m_type_params, \"type parameter\"),\n+            potentially_plural_count(num_trait_m_type_params, \"type parameter\")\n+        );\n \n         let mut suffix = None;\n \n         if let Some(span) = trait_item_span {\n-            err.span_label(span,\n-                           format!(\"expected {}\",\n-                                    &if num_trait_m_type_params != 1 {\n-                                        format!(\"{} type parameters\", num_trait_m_type_params)\n-                                    } else {\n-                                        format!(\"{} type parameter\", num_trait_m_type_params)\n-                                    }));\n+            err.span_label(span, format!(\"expected {}\",\n+                potentially_plural_count(num_trait_m_type_params, \"type parameter\")));\n         } else {\n             suffix = Some(format!(\", expected {}\", num_trait_m_type_params));\n         }\n \n         err.span_label(span,\n                        format!(\"found {}{}\",\n-                                &if num_impl_m_type_params != 1 {\n-                                    format!(\"{} type parameters\", num_impl_m_type_params)\n-                                } else {\n-                                    \"1 type parameter\".to_string()\n-                                },\n-                                suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n+                           potentially_plural_count(num_impl_m_type_params, \"type parameter\"),\n+                           suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n \n         err.emit();\n \n@@ -694,33 +678,21 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut err = struct_span_err!(tcx.sess,\n                                        impl_span,\n                                        E0050,\n-                                       \"method `{}` has {} parameter{} but the declaration in \\\n+                                       \"method `{}` has {} but the declaration in \\\n                                         trait `{}` has {}\",\n                                        trait_m.ident,\n-                                       impl_number_args,\n-                                       if impl_number_args == 1 { \"\" } else { \"s\" },\n+                                       potentially_plural_count(impl_number_args, \"parameter\"),\n                                        tcx.item_path_str(trait_m.def_id),\n                                        trait_number_args);\n         if let Some(trait_span) = trait_span {\n-            err.span_label(trait_span,\n-                           format!(\"trait requires {}\",\n-                                    &if trait_number_args != 1 {\n-                                        format!(\"{} parameters\", trait_number_args)\n-                                    } else {\n-                                        format!(\"{} parameter\", trait_number_args)\n-                                    }));\n+            err.span_label(trait_span, format!(\"trait requires {}\",\n+                potentially_plural_count(trait_number_args, \"parameter\")));\n         } else {\n             err.note_trait_signature(trait_m.ident.to_string(),\n                                      trait_m.signature(&tcx));\n         }\n-        err.span_label(impl_span,\n-                       format!(\"expected {}, found {}\",\n-                                &if trait_number_args != 1 {\n-                                    format!(\"{} parameters\", trait_number_args)\n-                                } else {\n-                                    format!(\"{} parameter\", trait_number_args)\n-                                },\n-                                impl_number_args));\n+        err.span_label(impl_span, format!(\"expected {}, found {}\",\n+            potentially_plural_count(trait_number_args, \"parameter\"), impl_number_args));\n         err.emit();\n         return Err(ErrorReported);\n     }\n@@ -750,8 +722,9 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             GenericParamDefKind::Lifetime => None,\n         }\n     });\n-    for ((impl_def_id, impl_synthetic),\n-         (trait_def_id, trait_synthetic)) in impl_m_type_params.zip(trait_m_type_params) {\n+    for ((impl_def_id, impl_synthetic), (trait_def_id, trait_synthetic))\n+        in impl_m_type_params.zip(trait_m_type_params)\n+    {\n         if impl_synthetic != trait_synthetic {\n             let impl_node_id = tcx.hir.as_local_node_id(impl_def_id).unwrap();\n             let impl_span = tcx.hir.span(impl_node_id);\n@@ -831,15 +804,14 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         impl<'v> hir::intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty) {\n                                 hir::intravisit::walk_ty(self, ty);\n-                                match ty.node {\n-                                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                                        if let hir::def::Def::TyParam(def_id) = path.def {\n-                                            if def_id == self.1 {\n-                                                self.0 = Some(ty.span);\n-                                            }\n+                                if let hir::TyKind::Path(\n+                                    hir::QPath::Resolved(None, ref path)) = ty.node\n+                                {\n+                                    if let hir::def::Def::TyParam(def_id) = path.def {\n+                                        if def_id == self.1 {\n+                                            self.0 = Some(ty.span);\n                                         }\n-                                    },\n-                                    _ => {}\n+                                    }\n                                 }\n                             }\n                             fn nested_visit_map<'this>(\n@@ -975,7 +947,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             infcx.note_type_err(&mut diag,\n                                 &cause,\n-                                trait_c_span.map(|span| (span, \"type in trait\".to_string())),\n+                                trait_c_span.map(|span| (span, \"type in trait\".to_owned())),\n                                 Some(infer::ValuePairs::Types(ExpectedFound {\n                                     expected: trait_ty,\n                                     found: impl_ty,"}, {"sha": "71c78e7f87c07613f09eb5537faa668ffb2074d2", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -115,19 +115,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // field is of the found type, suggest such variants. See Issue\n         // #42764.\n         if let ty::Adt(expected_adt, substs) = expected.sty {\n-            let mut compatible_variants = vec![];\n-            for variant in &expected_adt.variants {\n-                if variant.fields.len() == 1 {\n-                    let sole_field = &variant.fields[0];\n-                    let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                    if self.can_coerce(expr_ty, sole_field_ty) {\n-                        let mut variant_path = self.tcx.item_path_str(variant.did);\n-                        variant_path = variant_path.trim_left_matches(\"std::prelude::v1::\")\n-                            .to_string();\n-                        compatible_variants.push(variant_path);\n-                    }\n+            let compatible_variants = expected_adt.variants\n+                                                  .iter()\n+                                                  .filter(|variant| variant.fields.len() == 1)\n+                                                  .filter_map(|variant| {\n+                let sole_field = &variant.fields[0];\n+                let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                if self.can_coerce(expr_ty, sole_field_ty) {\n+                    let variant_path = self.tcx.item_path_str(variant.did);\n+                    Some(variant_path.trim_left_matches(\"std::prelude::v1::\").to_string())\n+                } else {\n+                    None\n                 }\n-            }\n+            }).collect::<Vec<_>>();\n+\n             if !compatible_variants.is_empty() {\n                 let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n                 let suggestions = compatible_variants.iter()\n@@ -380,15 +381,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       expected_ty: Ty<'tcx>)\n                       -> bool {\n         let parent_id = self.tcx.hir.get_parent_node(expr.id);\n-        match self.tcx.hir.find(parent_id) {\n-            Some(parent) => {\n-                // Shouldn't suggest `.into()` on `const`s.\n-                if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n-                    // FIXME(estebank): modify once we decide to suggest `as` casts\n-                    return false;\n-                }\n+        if let Some(parent) = self.tcx.hir.find(parent_id) {\n+            // Shouldn't suggest `.into()` on `const`s.\n+            if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n+                // FIXME(estebank): modify once we decide to suggest `as` casts\n+                return false;\n             }\n-            None => {}\n         };\n \n         let will_truncate = \"will truncate the source value\";\n@@ -662,15 +660,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer\",\n-                                      msg),\n+                                     msg),\n                             into_suggestion,\n                             Applicability::MachineApplicable\n                         );\n                     } else if can_cast {\n                         err.span_suggestion_with_applicability(expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer, rounded if necessary\",\n-                                      msg),\n+                                     msg),\n                             cast_suggestion,\n                             Applicability::MaybeIncorrect  // lossy conversion\n                         );\n@@ -684,7 +682,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer\",\n-                                      msg),\n+                                     msg),\n                             into_suggestion,\n                             Applicability::MachineApplicable\n                         );\n@@ -693,7 +691,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             expr.span,\n                             &format!(\"{}, producing the floating point representation of the \\\n                                       integer, rounded if necessary\",\n-                                      msg),\n+                                     msg),\n                             cast_suggestion,\n                             Applicability::MaybeIncorrect  // lossy conversion\n                         );"}, {"sha": "3686cfb8accde7e0d49a33cc90fdd0009f9a26b4", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -67,13 +67,8 @@ pub fn check_drop_impl<'a, 'tcx>(\n             // already checked by coherence, but compilation may\n             // not have been terminated.\n             let span = tcx.def_span(drop_impl_did);\n-            tcx.sess.delay_span_bug(\n-                span,\n-                &format!(\n-                    \"should have been rejected by coherence check: {}\",\n-                    dtor_self_type\n-                ),\n-            );\n+            tcx.sess.delay_span_bug(span,\n+                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type));\n             Err(ErrorReported)\n         }\n     }\n@@ -310,10 +305,8 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     body_id: ast::NodeId,\n     scope: region::Scope,\n ) -> Result<(), ErrorReported> {\n-    debug!(\n-        \"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n-        ty, scope\n-    );\n+    debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n+           ty, scope);\n \n     let parent_scope = match rcx.region_scope_tree.opt_encl_scope(scope) {\n         Some(parent_scope) => parent_scope,"}, {"sha": "83005bc374ef5213e6dfad2c1e175cadfdbfc43b", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n                 // See the mega-comment at `yield_in_scope` for a proof.\n \n                 debug!(\"comparing counts yield: {} self: {}, source_span = {:?}\",\n-                    expr_count, self.expr_count, source_span);\n+                       expr_count, self.expr_count, source_span);\n \n                 if expr_count >= self.expr_count {\n                     Some(yield_span)"}, {"sha": "24db9505cb807ba9629ef055c0215d66ca5c3751", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -57,7 +57,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n \n         struct_span_err!(tcx.sess, span, E0094,\n                         \"intrinsic has wrong number of type \\\n-                        parameters: found {}, expected {}\",\n+                         parameters: found {}, expected {}\",\n                         i_n_tps, n_tps)\n             .span_label(span, format!(\"expected {} type parameter\", n_tps))\n             .emit();\n@@ -83,7 +83,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let name = it.name.as_str();\n     let (n_tps, inputs, output, unsafety) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n-        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+        assert!(split.len() >= 2, \"Atomic intrinsic in an incorrect format\");\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n@@ -127,8 +127,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"size_of_val\" |  \"min_align_of_val\" => {\n                 (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST,\n-                                                                  ty::BrAnon(0))),\n-                                    param(0))\n+                                                                 ty::BrAnon(0))),\n+                                   param(0))\n                  ], tcx.types.usize)\n             }\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n@@ -306,7 +306,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             \"discriminant_value\" => (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST,\n-                                                                  ty::BrAnon(0))),\n+                                                                 ty::BrAnon(0))),\n                                    param(0))], tcx.types.u64),\n \n             \"try\" => {\n@@ -327,10 +327,10 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             ref other => {\n                 struct_span_err!(tcx.sess, it.span, E0093,\n-                                \"unrecognized intrinsic function: `{}`\",\n-                                *other)\n-                                .span_label(it.span, \"unrecognized intrinsic\")\n-                                .emit();\n+                                 \"unrecognized intrinsic function: `{}`\",\n+                                 *other)\n+                                 .span_label(it.span, \"unrecognized intrinsic\")\n+                                 .emit();\n                 return;\n             }\n         };"}, {"sha": "4e5488b432d48938df035d99473335f4079bb4d4", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -210,9 +210,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         target\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    //\n-\n     /// Returns a set of substitutions for the method *receiver* where all type and region\n     /// parameters are instantiated with fresh variables. This substitution does not include any\n     /// parameters declared on the method itself.\n@@ -291,18 +288,18 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         self.fcx\n             .autoderef(self.span, self_ty)\n             .include_raw_pointers()\n-            .filter_map(|(ty, _)| {\n+            .filter_map(|(ty, _)|\n                 match ty.sty {\n                     ty::Dynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n                     _ => None,\n                 }\n-            })\n+            )\n             .next()\n-            .unwrap_or_else(|| {\n+            .unwrap_or_else(||\n                 span_bug!(self.span,\n                           \"self-type `{}` for ObjectPick never dereferenced to an object\",\n                           self_ty)\n-            })\n+            )\n     }\n \n     fn instantiate_method_substs(\n@@ -373,9 +370,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    //\n-\n     // NOTE: this returns the *unnormalized* predicates and method sig. Because of\n     // inference guessing, the predicates and method signature can't be normalized\n     // until we unify the `Self` type.\n@@ -444,11 +438,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     /// respectively.\n     fn convert_place_derefs_to_mutable(&self) {\n         // Gather up expressions we want to munge.\n-        let mut exprs = Vec::new();\n-        exprs.push(self.self_expr);\n+        let mut exprs = vec![self.self_expr];\n+\n         loop {\n-            let last = exprs[exprs.len() - 1];\n-            match last.node {\n+            match exprs.last().unwrap().node {\n                 hir::ExprKind::Field(ref expr, _) |\n                 hir::ExprKind::Index(ref expr, _) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref expr) => exprs.push(&expr),"}, {"sha": "4af3790450c0f6def3257e278cd99160eb94c3a9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -1255,9 +1255,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     {\n         // Do all probes correspond to the same trait?\n         let container = probes[0].0.item.container;\n-        match container {\n-            ty::TraitContainer(_) => {}\n-            ty::ImplContainer(_) => return None,\n+        if let ty::ImplContainer(_) = container {\n+            return None\n         }\n         if probes[1..].iter().any(|&(p, _)| p.item.container != container) {\n             return None;\n@@ -1461,7 +1460,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     .filter(|x| {\n                         let dist = lev_distance(&*name.as_str(), &x.ident.as_str());\n                         Namespace::from(x.kind) == Namespace::Value && dist > 0\n-                        && dist <= max_dist\n+                            && dist <= max_dist\n                     })\n                     .collect()\n             } else {"}, {"sha": "f5d332521ff0bb0e4a905f8106c87abca1cb5d9d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -88,7 +88,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let report_candidates = |err: &mut DiagnosticBuilder, mut sources: Vec<CandidateSource>| {\n-\n             sources.sort();\n             sources.dedup();\n             // Dynamic limit to avoid hiding just one candidate, which is silly.\n@@ -225,9 +224,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // ({integer}/{float}).\n                     let mut candidates = all_traits(self.tcx)\n                         .into_iter()\n-                        .filter(|info| {\n-                            self.associated_item(info.def_id, item_name, Namespace::Value).is_some()\n-                        });\n+                        .filter_map(|info|\n+                            self.associated_item(info.def_id, item_name, Namespace::Value)\n+                        );\n                     if let (true, false, Some(expr), Some(_)) = (actual.is_numeric(),\n                                                                  actual.has_concrete_skeleton(),\n                                                                  rcvr_expr,\n@@ -247,9 +246,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"f32\"\n                         };\n                         match expr.node {\n-                            hir::ExprKind::Lit(ref lit) => {  // numeric literal\n+                            hir::ExprKind::Lit(ref lit) => { // numeric literal\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n-                                    .unwrap_or(\"<numeric literal>\".to_string());\n+                                    .unwrap_or(\"<numeric literal>\".to_owned());\n \n                                 err.span_suggestion_with_applicability(\n                                                     lit.span,\n@@ -342,8 +341,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // give a helping note that it has to be called as (x.f)(...).\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n-                        match ty.sty {\n-                            ty::Adt(def, substs) if !def.is_enum() => {\n+                        if let ty::Adt(def, substs) = ty.sty {\n+                            if !def.is_enum() {\n                                 let variant = &def.non_enum_variant();\n                                 if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n@@ -377,7 +376,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     break;\n                                 }\n                             }\n-                            _ => {}\n                         }\n                     }\n                 } else {\n@@ -722,12 +720,9 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n         }\n         impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n-                match i.node {\n-                    hir::ItemKind::Trait(..) => {\n-                        let def_id = self.map.local_def_id(i.id);\n-                        self.traits.push(def_id);\n-                    }\n-                    _ => {}\n+                if let hir::ItemKind::Trait(..) = i.node {\n+                    let def_id = self.map.local_def_id(i.id);\n+                    self.traits.push(def_id);\n                 }\n             }\n "}, {"sha": "27f1058d3a4ce0e0dd50777886cab113bae5cb44", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 108, "deletions": 139, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -662,7 +662,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     }\n \n     fn register_predicates<I>(&self, obligations: I)\n-    where I: IntoIterator<Item = traits::PredicateObligation<'tcx>> {\n+        where I: IntoIterator<Item = traits::PredicateObligation<'tcx>>\n+    {\n         for obligation in obligations {\n             self.register_predicate(obligation);\n         }\n@@ -1150,19 +1151,16 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     if let Some(term_id) = fcx.tcx.lang_items().termination() {\n         if let Some((id, _, entry_type)) = *fcx.tcx.sess.entry_fn.borrow() {\n             if id == fn_id {\n-                match entry_type {\n-                    config::EntryFnType::Main => {\n-                        let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n-                        let trait_ref = ty::TraitRef::new(term_id, substs);\n-                        let return_ty_span = decl.output.span();\n-                        let cause = traits::ObligationCause::new(\n-                            return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n-\n-                        inherited.register_predicate(\n-                            traits::Obligation::new(\n-                                cause, param_env, trait_ref.to_predicate()));\n-                    },\n-                    config::EntryFnType::Start => {},\n+                if let config::EntryFnType::Main = entry_type {\n+                    let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n+                    let trait_ref = ty::TraitRef::new(term_id, substs);\n+                    let return_ty_span = decl.output.span();\n+                    let cause = traits::ObligationCause::new(\n+                        return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n+\n+                    inherited.register_predicate(\n+                        traits::Obligation::new(\n+                            cause, param_env, trait_ref.to_predicate()));\n                 }\n             }\n         }\n@@ -1540,10 +1538,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            impl_trait_ref);\n                     } else {\n                          let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n-                                  \"item `{}` is an associated const, \\\n-                                  which doesn't match its trait `{}`\",\n-                                  ty_impl_item.ident,\n-                                  impl_trait_ref);\n+                             \"item `{}` is an associated const, \\\n+                              which doesn't match its trait `{}`\",\n+                             ty_impl_item.ident,\n+                             impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n@@ -1564,10 +1562,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             trait_span);\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n-                                  \"item `{}` is an associated method, \\\n-                                  which doesn't match its trait `{}`\",\n-                                  ty_impl_item.ident,\n-                                  impl_trait_ref);\n+                            \"item `{}` is an associated method, \\\n+                             which doesn't match its trait `{}`\",\n+                            ty_impl_item.ident,\n+                            impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n@@ -1583,10 +1581,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         }\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n-                                  \"item `{}` is an associated type, \\\n-                                  which doesn't match its trait `{}`\",\n-                                  ty_impl_item.ident,\n-                                  impl_trait_ref);\n+                            \"item `{}` is an associated type, \\\n+                             which doesn't match its trait `{}`\",\n+                            ty_impl_item.ident,\n+                            impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n@@ -1624,8 +1622,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(|trait_item| trait_item.ident.to_string())\n-                  .collect::<Vec<_>>().join(\"`, `\"));\n+                .map(|trait_item| trait_item.ident.to_string())\n+                .collect::<Vec<_>>().join(\"`, `\"));\n         err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n                     .map(|trait_item| trait_item.ident.to_string())\n@@ -1683,8 +1681,8 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n-    match t.sty {\n-        ty::Adt(def, substs) if def.is_struct() => {\n+    if let ty::Adt(def, substs) = t.sty {\n+        if def.is_struct() {\n             let fields = &def.non_enum_variant().fields;\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n@@ -1699,15 +1697,14 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n             }\n             match e.sty {\n                 ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n-                _ if e.is_machine()  => { /* struct(u8, u8, u8, u8) is ok */ }\n+                _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n                 _ => {\n                     span_err!(tcx.sess, sp, E0077,\n                               \"SIMD vector element type should be machine type\");\n                     return;\n                 }\n             }\n         }\n-        _ => ()\n     }\n }\n \n@@ -1743,28 +1740,24 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n         return false;\n     }\n-    match t.sty {\n-        ty::Adt(def, substs) if def.is_struct() || def.is_union() => {\n+    if let ty::Adt(def, substs) = t.sty {\n+        if def.is_struct() || def.is_union() {\n             if tcx.adt_def(def.did).repr.align > 0 {\n                 return true;\n             }\n             // push struct def_id before checking fields\n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n                 let f = field.ty(tcx, substs);\n-                match f.sty {\n-                    ty::Adt(def, _) => {\n-                        if check_packed_inner(tcx, def.did, stack) {\n-                            return true;\n-                        }\n+                if let ty::Adt(def, _) = f.sty {\n+                    if check_packed_inner(tcx, def.did, stack) {\n+                        return true;\n                     }\n-                    _ => ()\n                 }\n             }\n             // only need to pop if not early out\n             stack.pop();\n         }\n-        _ => ()\n     }\n     false\n }\n@@ -1793,7 +1786,7 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n         let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| *span).collect();\n         struct_span_err!(tcx.sess, sp, E0690,\n                          \"transparent struct needs exactly one non-zero-sized field, but has {}\",\n-                          non_zst_count)\n+                         non_zst_count)\n         .span_note(field_spans, \"non-zero-sized field\")\n         .emit();\n     }\n@@ -1842,7 +1835,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let mut disr_vals: Vec<Discr<'tcx>> = Vec::new();\n+    let mut disr_vals: Vec<Discr<'tcx>> = Vec::with_capacity(vs.len());\n     for (discr, v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n@@ -2078,13 +2071,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> LocalTy<'tcx> {\n-        match self.locals.borrow().get(&nid) {\n-            Some(&t) => t,\n-            None => {\n-                span_bug!(span, \"no type for local variable {}\",\n-                          self.tcx.hir.node_to_string(nid));\n-            }\n-        }\n+        self.locals.borrow().get(&nid).cloned().unwrap_or_else(||\n+            span_bug!(span, \"no type for local variable {}\",\n+                      self.tcx.hir.node_to_string(nid))\n+        )\n     }\n \n     #[inline]\n@@ -2373,8 +2363,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n-    pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)\n-    {\n+    pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr) {\n         for ty in substs.types() {\n             self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n@@ -2421,8 +2410,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     substs: &Substs<'tcx>)\n                     -> Ty<'tcx>\n     {\n-        self.normalize_associated_types_in(span,\n-                                           &field.ty(self.tcx, substs))\n+        self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n     }\n \n     fn check_casts(&self) {\n@@ -2473,11 +2461,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Select as many obligations as we can at present.\n     fn select_obligations_where_possible(&self, fallback_has_occurred: bool) {\n-        match self.fulfillment_cx.borrow_mut().select_where_possible(self) {\n-            Ok(()) => { }\n-            Err(errors) => {\n-                self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n-            },\n+        if let Err(errors) = self.fulfillment_cx.borrow_mut().select_where_possible(self) {\n+            self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n         }\n     }\n \n@@ -2772,17 +2757,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expected_arg_count = fn_inputs.len();\n \n         let param_count_error = |expected_count: usize,\n-                                arg_count: usize,\n-                                error_code: &str,\n-                                variadic: bool,\n-                                sugg_unit: bool| {\n+                                 arg_count: usize,\n+                                 error_code: &str,\n+                                 variadic: bool,\n+                                 sugg_unit: bool| {\n             let mut err = tcx.sess.struct_span_err_with_code(sp,\n-                &format!(\"this function takes {}{} parameter{} but {} parameter{} supplied\",\n+                &format!(\"this function takes {}{} but {} {} supplied\",\n                     if variadic {\"at least \"} else {\"\"},\n-                    expected_count,\n-                    if expected_count == 1 {\"\"} else {\"s\"},\n-                    arg_count,\n-                    if arg_count == 1 {\" was\"} else {\"s were\"}),\n+                    potentially_plural_count(expected_count, \"parameter\"),\n+                    potentially_plural_count(arg_count, \"parameter\"),\n+                    if arg_count == 1 {\"was\"} else {\"were\"}),\n                 DiagnosticId::Error(error_code.to_owned()));\n \n             if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().def_span(sp)) {\n@@ -2798,10 +2782,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     String::from(\"()\"),\n                     Applicability::MachineApplicable);\n             } else {\n-                err.span_label(sp, format!(\"expected {}{} parameter{}\",\n-                                            if variadic {\"at least \"} else {\"\"},\n-                                            expected_count,\n-                                            if expected_count == 1 {\"\"} else {\"s\"}));\n+                err.span_label(sp, format!(\"expected {}{}\",\n+                                           if variadic {\"at least \"} else {\"\"},\n+                                           potentially_plural_count(expected_count, \"parameter\")));\n             }\n             err.emit();\n         };\n@@ -2967,7 +2950,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-        (0..len).map(|_| self.tcx.types.err).collect()\n+        vec![self.tcx.types.err; len]\n     }\n \n     // AST fragment checking\n@@ -2982,7 +2965,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n             ast::LitKind::ByteStr(ref v) => {\n                 tcx.mk_imm_ref(tcx.types.re_static,\n-                                tcx.mk_array(tcx.types.u8, v.len() as u64))\n+                               tcx.mk_array(tcx.types.u8, v.len() as u64))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,\n             ast::LitKind::Char(_) => tcx.types.char,\n@@ -3051,23 +3034,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             // Add help to type error if this is an `if` condition with an assignment\n-            match (expected, &expr.node) {\n-                (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs)) => {\n-                    let msg = \"try comparing for equality\";\n-                    if let (Ok(left), Ok(right)) = (\n-                        self.tcx.sess.source_map().span_to_snippet(lhs.span),\n-                        self.tcx.sess.source_map().span_to_snippet(rhs.span))\n-                    {\n-                        err.span_suggestion_with_applicability(\n-                            expr.span,\n-                            msg,\n-                            format!(\"{} == {}\", left, right),\n-                            Applicability::MaybeIncorrect);\n-                    } else {\n-                        err.help(msg);\n-                    }\n+            if let (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs))\n+                 = (expected, &expr.node)\n+            {\n+                let msg = \"try comparing for equality\";\n+                if let (Ok(left), Ok(right)) = (\n+                    self.tcx.sess.source_map().span_to_snippet(lhs.span),\n+                    self.tcx.sess.source_map().span_to_snippet(rhs.span))\n+                {\n+                    err.span_suggestion_with_applicability(\n+                        expr.span,\n+                        msg,\n+                        format!(\"{} == {}\", left, right),\n+                        Applicability::MaybeIncorrect);\n+                } else {\n+                    err.help(msg);\n                 }\n-                _ => (),\n             }\n             err.emit();\n         }\n@@ -3355,8 +3337,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx().types.err\n         } else if self.method_exists(field, expr_t, expr.id, true) {\n             type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n-                              \"attempted to take value of method `{}` on type `{}`\",\n-                              field, expr_t)\n+                               \"attempted to take value of method `{}` on type `{}`\",\n+                               field, expr_t)\n                 .help(\"maybe a `()` to call it is missing?\")\n                 .emit();\n             self.tcx().types.err\n@@ -3441,14 +3423,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n-        let mut available = Vec::new();\n-        for field in variant.fields.iter() {\n+        variant.fields.iter().filter(|field| {\n             let def_scope = self.tcx.adjust_ident(field.ident, variant.did, self.body_id).1;\n-            if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                available.push(field.ident.name);\n-            }\n-        }\n-        available\n+            field.vis.is_accessible_from(def_scope, self.tcx)\n+        })\n+        .map(|field| field.ident.name)\n+        .collect()\n     }\n \n     fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n@@ -3480,13 +3460,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |actual| match ty.sty {\n                 ty::Adt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n-                                    \"{} `{}::{}` has no field named `{}`\",\n-                                    kind_name, actual, variant.name, field.ident)\n+                                     \"{} `{}::{}` has no field named `{}`\",\n+                                     kind_name, actual, variant.name, field.ident)\n                 }\n                 _ => {\n                     struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n-                                    \"{} `{}` has no field named `{}`\",\n-                                    kind_name, actual, field.ident)\n+                                     \"{} `{}` has no field named `{}`\",\n+                                     kind_name, actual, field.ident)\n                 }\n             },\n             ty);\n@@ -3571,10 +3551,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 error_happened = true;\n                 if let Some(prev_span) = seen_fields.get(&ident) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n-                                                field.ident.span,\n-                                                E0062,\n-                                                \"field `{}` specified more than once\",\n-                                                ident);\n+                                                   field.ident.span,\n+                                                   E0062,\n+                                                   \"field `{}` specified more than once\",\n+                                                   ident);\n \n                     err.span_label(field.ident.span, \"used more than once\");\n                     err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n@@ -3638,11 +3618,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n-        match *base_expr {\n-            Some(ref base) => {\n-                self.check_expr(&base);\n-            },\n-            None => {}\n+        if let Some(ref base) = *base_expr {\n+            self.check_expr(&base);\n         }\n     }\n \n@@ -3972,11 +3949,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty\n             }\n             hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n-                for output in outputs {\n-                    self.check_expr(output);\n-                }\n-                for input in inputs {\n-                    self.check_expr(input);\n+                for expr in outputs.iter().chain(inputs.iter()) {\n+                    self.check_expr(expr);\n                 }\n                 tcx.mk_unit()\n             }\n@@ -4075,7 +4049,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Ret(ref expr_opt) => {\n                 if self.ret_coercion.is_none() {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                        \"return statement outside of function body\").emit();\n+                                     \"return statement outside of function body\").emit();\n                 } else if let Some(ref e) = *expr_opt {\n                     self.check_return_expr(e);\n                 } else {\n@@ -4393,7 +4367,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }\n                                 if needs_note {\n                                     err.help(\"to access tuple elements, use tuple indexing \\\n-                                            syntax (e.g. `tuple.0`)\");\n+                                              syntax (e.g. `tuple.0`)\");\n                                 }\n                             }\n                             err.emit();\n@@ -4409,7 +4383,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     None => {\n                         struct_span_err!(self.tcx.sess, expr.span, E0627,\n-                                        \"yield statement outside of generator literal\").emit();\n+                                         \"yield statement outside of generator literal\").emit();\n                     }\n                 }\n                 tcx.mk_unit()\n@@ -4523,7 +4497,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n+    pub fn check_decl_local(&self, local: &'gcx hir::Local) {\n         let t = self.local_ty(local.span, local.id).decl_ty;\n         self.write_ty(local.hir_id, t);\n \n@@ -4547,11 +4521,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Don't do all the complex logic below for DeclItem.\n         match stmt.node {\n             hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Local(_) => {}\n-                    hir::DeclKind::Item(_) => {\n-                        return;\n-                    }\n+                if let hir::DeclKind::Item(_) = decl.node {\n+                    return\n                 }\n             }\n             hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n@@ -4809,7 +4780,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 Some(format!(\"{}{}\", receiver, method_call))\n                             }\n                         }\n-                    }) .collect::<Vec<_>>();\n+                    }).collect::<Vec<_>>();\n                 if !suggestions.is_empty() {\n                     err.span_suggestions_with_applicability(\n                         expr.span,\n@@ -5286,18 +5257,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n-        match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n-            Node::Expr(expr) => {\n-                match expr.node {\n-                    hir::ExprKind::Call(ref callee, ..) => {\n-                        if callee.id == node_id {\n-                            return\n-                        }\n-                    }\n-                    _ => {}\n+        if let Node::Expr(expr) = self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n+            if let hir::ExprKind::Call(ref callee, ..) = expr.node {\n+                if callee.id == node_id {\n+                    return\n                 }\n             }\n-            _ => {}\n         }\n \n         self.tcx.sess.span_err(span, \"this function can only be invoked \\\n@@ -5323,8 +5288,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,\n-                                        ctxt: BreakableCtxt<'gcx, 'tcx>, f: F)\n-                                   -> (BreakableCtxt<'gcx, 'tcx>, R) {\n+                                                ctxt: BreakableCtxt<'gcx, 'tcx>, f: F)\n+                                                -> (BreakableCtxt<'gcx, 'tcx>, R) {\n         let index;\n         {\n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n@@ -5398,3 +5363,7 @@ fn fatally_break_rust(sess: &Session) {\n         ::session::config::host_triple(),\n     ));\n }\n+\n+fn potentially_plural_count(count: usize, word: &str) -> String {\n+    format!(\"{} {}{}\", count, word, if count == 1 { \"\" } else { \"s\" })\n+}"}, {"sha": "89ed689b5d407526bbc2d60284b086a86d9e34c9", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 hir::BinOpKind::BitOr  => Some(\"std::ops::BitOrAssign\"),\n                                 hir::BinOpKind::Shl    => Some(\"std::ops::ShlAssign\"),\n                                 hir::BinOpKind::Shr    => Some(\"std::ops::ShrAssign\"),\n-                                _             => None\n+                                _                      => None\n                             };\n                             if let Some(missing_trait) = missing_trait {\n                                 if op.node == hir::BinOpKind::Add &&\n@@ -338,15 +338,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         IsAssign::No => {\n                             let mut err = struct_span_err!(self.tcx.sess, expr.span, E0369,\n-                                            \"binary operation `{}` cannot be applied to type `{}`\",\n-                                            op.node.as_str(),\n-                                            lhs_ty);\n+                                \"binary operation `{}` cannot be applied to type `{}`\",\n+                                op.node.as_str(),\n+                                lhs_ty);\n                             let mut suggested_deref = false;\n                             if let Ref(_, mut rty, _) = lhs_ty.sty {\n                                 if {\n                                     !self.infcx.type_moves_by_default(self.param_env,\n-                                                                        rty,\n-                                                                        lhs_expr.span) &&\n+                                                                      rty,\n+                                                                      lhs_expr.span) &&\n                                         self.lookup_op_method(rty,\n                                                               &[rhs_ty],\n                                                               Op::Binary(op, is_assign))"}, {"sha": "80b4ba6240d335099618e82340053d38e2395479", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -947,8 +947,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::cmt_<'tcx>, span: Span) {\n-        match cmt.cat {\n-            Categorization::Rvalue(region) => match *region {\n+        if let Categorization::Rvalue(region) = cmt.cat {\n+            match *region {\n                 ty::ReScope(rvalue_scope) => {\n                     let typ = self.resolve_type(cmt.ty);\n                     let body_id = self.body_id;\n@@ -969,8 +969,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                         region\n                     );\n                 }\n-            },\n-            _ => {}\n+            }\n         }\n     }\n \n@@ -1118,25 +1117,22 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         );\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n-                match sub_pat.node {\n-                    // `ref x` pattern\n-                    PatKind::Binding(..) => {\n-                        if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n-                            if let ty::BindByReference(mutbl) = bm {\n-                                self.link_region_from_node_type(\n-                                    sub_pat.span,\n-                                    sub_pat.hir_id,\n-                                    mutbl,\n-                                    &sub_cmt,\n-                                );\n-                            }\n-                        } else {\n-                            self.tcx\n-                                .sess\n-                                .delay_span_bug(sub_pat.span, \"missing binding mode\");\n+                // `ref x` pattern\n+                if let PatKind::Binding(..) = sub_pat.node {\n+                    if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n+                        if let ty::BindByReference(mutbl) = bm {\n+                            self.link_region_from_node_type(\n+                                sub_pat.span,\n+                                sub_pat.hir_id,\n+                                mutbl,\n+                                &sub_cmt,\n+                            );\n                         }\n+                    } else {\n+                        self.tcx\n+                            .sess\n+                            .delay_span_bug(sub_pat.span, \"missing binding mode\");\n                     }\n-                    _ => {}\n                 }\n             })\n         }));"}, {"sha": "99effce4ee08df4edfa44c5c68910206de179e24", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -73,15 +73,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n-        match expr.node {\n-            hir::ExprKind::Closure(cc, _, body_id, _, _) => {\n-                let body = self.fcx.tcx.hir.body(body_id);\n-                self.visit_body(body);\n-                self.fcx\n-                    .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n-            }\n-\n-            _ => {}\n+        if let hir::ExprKind::Closure(cc, _, body_id, _, _) = expr.node {\n+            let body = self.fcx.tcx.hir.body(body_id);\n+            self.visit_body(body);\n+            self.fcx\n+                .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n         }\n \n         intravisit::walk_expr(self, expr);\n@@ -335,49 +331,46 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             \"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n             guarantor.cat\n         );\n-        match guarantor.cat {\n-            Categorization::Deref(_, mc::BorrowedPtr(..)) => {\n-                debug!(\n-                    \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n-                    cmt.note\n-                );\n-                match guarantor.note {\n-                    mc::NoteUpvarRef(upvar_id) => {\n-                        debug!(\n-                            \"adjust_upvar_borrow_kind_for_consume: \\\n-                             setting upvar_id={:?} to by value\",\n-                            upvar_id\n-                        );\n-\n-                        // to move out of an upvar, this must be a FnOnce closure\n-                        self.adjust_closure_kind(\n-                            upvar_id.closure_expr_id,\n-                            ty::ClosureKind::FnOnce,\n-                            guarantor.span,\n-                            var_name(tcx, upvar_id.var_id),\n-                        );\n+        if let Categorization::Deref(_, mc::BorrowedPtr(..)) = guarantor.cat {\n+            debug!(\n+                \"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n+                cmt.note\n+            );\n+            match guarantor.note {\n+                mc::NoteUpvarRef(upvar_id) => {\n+                    debug!(\n+                        \"adjust_upvar_borrow_kind_for_consume: \\\n+                         setting upvar_id={:?} to by value\",\n+                        upvar_id\n+                    );\n \n-                        self.adjust_upvar_captures\n-                            .insert(upvar_id, ty::UpvarCapture::ByValue);\n-                    }\n-                    mc::NoteClosureEnv(upvar_id) => {\n-                        // we get just a closureenv ref if this is a\n-                        // `move` closure, or if the upvar has already\n-                        // been inferred to by-value. In any case, we\n-                        // must still adjust the kind of the closure\n-                        // to be a FnOnce closure to permit moves out\n-                        // of the environment.\n-                        self.adjust_closure_kind(\n-                            upvar_id.closure_expr_id,\n-                            ty::ClosureKind::FnOnce,\n-                            guarantor.span,\n-                            var_name(tcx, upvar_id.var_id),\n-                        );\n-                    }\n-                    mc::NoteIndex | mc::NoteNone => {}\n+                    // to move out of an upvar, this must be a FnOnce closure\n+                    self.adjust_closure_kind(\n+                        upvar_id.closure_expr_id,\n+                        ty::ClosureKind::FnOnce,\n+                        guarantor.span,\n+                        var_name(tcx, upvar_id.var_id),\n+                    );\n+\n+                    self.adjust_upvar_captures\n+                        .insert(upvar_id, ty::UpvarCapture::ByValue);\n+                }\n+                mc::NoteClosureEnv(upvar_id) => {\n+                    // we get just a closureenv ref if this is a\n+                    // `move` closure, or if the upvar has already\n+                    // been inferred to by-value. In any case, we\n+                    // must still adjust the kind of the closure\n+                    // to be a FnOnce closure to permit moves out\n+                    // of the environment.\n+                    self.adjust_closure_kind(\n+                        upvar_id.closure_expr_id,\n+                        ty::ClosureKind::FnOnce,\n+                        guarantor.span,\n+                        var_name(tcx, upvar_id.var_id),\n+                    );\n                 }\n+                mc::NoteIndex | mc::NoteNone => {}\n             }\n-            _ => {}\n         }\n     }\n "}, {"sha": "e7ddb497823e75af3662d5339d8942212f0ffb54", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 54, "deletions": 67, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -77,8 +77,8 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n     let item = tcx.hir.expect_item(node_id);\n \n     debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n-            item.id,\n-            tcx.item_path_str(def_id));\n+           item.id,\n+           tcx.item_path_str(def_id));\n \n     match item.node {\n         // Right now we check that every default trait implementation\n@@ -110,8 +110,8 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n                 if trait_ref.is_some() && !is_auto {\n                     span_err!(tcx.sess, item.span, E0192,\n-                                \"negative impls are only allowed for \\\n-                                auto traits (e.g., `Send` and `Sync`)\")\n+                              \"negative impls are only allowed for \\\n+                               auto traits (e.g., `Send` and `Sync`)\")\n                 }\n             }\n         }\n@@ -175,17 +175,17 @@ pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n }\n \n fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            item_id: ast::NodeId,\n-                            span: Span,\n-                            sig_if_method: Option<&hir::MethodSig>) {\n+                                   item_id: ast::NodeId,\n+                                   span: Span,\n+                                   sig_if_method: Option<&hir::MethodSig>) {\n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n             ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n             ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                            fcx.tcx.type_of(def_id))\n+                                          fcx.tcx.type_of(def_id))\n         };\n \n         match item.kind {\n@@ -199,7 +199,7 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n                 let sig = fcx.normalize_associated_types_in(span, &sig);\n                 check_fn_or_method(tcx, fcx, span, sig,\n-                                        item.def_id, &mut implied_bounds);\n+                                   item.def_id, &mut implied_bounds);\n                 let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n                 check_method_receiver(fcx, sig_if_method, &item, self_ty);\n             }\n@@ -220,12 +220,12 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n-                    -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+                            -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     for_id(tcx, item.id, item.span)\n }\n \n fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n-                -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+                          -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     let def_id = tcx.hir.local_def_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n@@ -330,14 +330,12 @@ fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n         let sig = fcx.normalize_associated_types_in(item.span, &sig);\n         let mut implied_bounds = vec![];\n         check_fn_or_method(tcx, fcx, item.span, sig,\n-                                def_id, &mut implied_bounds);\n+                           def_id, &mut implied_bounds);\n         implied_bounds\n     })\n }\n \n-fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    item: &hir::Item)\n-{\n+fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     debug!(\"check_item_type: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, _this| {\n@@ -351,9 +349,9 @@ fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                item: &hir::Item,\n-                ast_self_ty: &hir::Ty,\n-                ast_trait_ref: &Option<hir::TraitRef>)\n+                        item: &hir::Item,\n+                        ast_self_ty: &hir::Ty,\n+                        ast_trait_ref: &Option<hir::TraitRef>)\n {\n     debug!(\"check_impl: {:?}\", item);\n \n@@ -484,11 +482,8 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n         let substituted_pred = pred.subst(fcx.tcx, substs);\n         // Don't check non-defaulted params, dependent defaults (including lifetimes)\n         // or preds with multiple params.\n-        if {\n-            substituted_pred.references_error() || param_count.params.len() > 1\n-                || has_region\n-        } {\n-                None\n+        if substituted_pred.references_error() || param_count.params.len() > 1 || has_region {\n+            None\n         } else if predicates.predicates.contains(&substituted_pred) {\n             // Avoid duplication of predicates that contain no parameters, for example.\n             None\n@@ -535,11 +530,11 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n }\n \n fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                    span: Span,\n-                                    sig: ty::PolyFnSig<'tcx>,\n-                                    def_id: DefId,\n-                                    implied_bounds: &mut Vec<Ty<'tcx>>)\n+                                            fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                            span: Span,\n+                                            sig: ty::PolyFnSig<'tcx>,\n+                                            def_id: DefId,\n+                                            implied_bounds: &mut Vec<Ty<'tcx>>)\n {\n     let sig = fcx.normalize_associated_types_in(span, &sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n@@ -702,7 +697,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n {\n     // check that the method has a valid receiver type, given the type `Self`\n     debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n-            method, self_ty);\n+           method, self_ty);\n \n     if !method.method_has_self_argument {\n         return;\n@@ -806,14 +801,14 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut constrained_parameters: FxHashSet<_> =\n         variances.iter().enumerate()\n-                    .filter(|&(_, &variance)| variance != ty::Bivariant)\n-                    .map(|(index, _)| Parameter(index as u32))\n-                    .collect();\n+                        .filter(|&(_, &variance)| variance != ty::Bivariant)\n+                        .map(|(index, _)| Parameter(index as u32))\n+                        .collect();\n \n     identify_constrained_type_params(tcx,\n-                                        ty_predicates.predicates.as_slice(),\n-                                        None,\n-                                        &mut constrained_parameters);\n+                                     ty_predicates.predicates.as_slice(),\n+                                     None,\n+                                     &mut constrained_parameters);\n \n     for (index, _) in variances.iter().enumerate() {\n         if constrained_parameters.contains(&Parameter(index as u32)) {\n@@ -826,22 +821,17 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        span: Span,\n-                        param_name: ast::Name)\n+                               span: Span,\n+                               param_name: ast::Name)\n {\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n-    match suggested_marker_id {\n-        Some(def_id) => {\n-            err.help(\n-                &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                            param_name,\n-                            tcx.item_path_str(def_id)));\n-        }\n-        None => {\n-            // no lang items, no help!\n-        }\n+    // help is available only in presence of lang items\n+    if let Some(def_id) = suggested_marker_id {\n+        err.help(&format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                          param_name,\n+                          tcx.item_path_str(def_id)));\n     }\n     err.emit();\n }\n@@ -855,11 +845,10 @@ fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n     }).collect();\n \n     for method_param in &generics.params {\n-        match method_param.kind {\n-            // Shadowing is checked in resolve_lifetime.\n-            GenericParamDefKind::Lifetime => continue,\n-            _ => {},\n-        };\n+        // Shadowing is checked in resolve_lifetime.\n+        if let GenericParamDefKind::Lifetime = method_param.kind {\n+            continue\n+        }\n         if impl_params.contains_key(&method_param.name) {\n             // Tighten up the span to focus on only the shadowing type\n             let type_span = tcx.def_span(method_param.def_id);\n@@ -876,10 +865,10 @@ fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n /// Feature gates RFC 2056 - trivial bounds, checking for global bounds that\n /// aren't true.\n fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n-        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-        span: Span,\n-        id: ast::NodeId,\n-) {\n+    fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+    span: Span,\n+    id: ast::NodeId)\n+{\n     use rustc::ty::TypeFoldable;\n \n     let empty_env = ty::ParamEnv::empty();\n@@ -963,15 +952,13 @@ struct AdtField<'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn non_enum_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n-        let fields =\n-            struct_def.fields().iter()\n-            .map(|field| {\n-                let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n-                let field_ty = self.normalize_associated_types_in(field.span,\n-                                                                  &field_ty);\n-                AdtField { ty: field_ty, span: field.span }\n-            })\n-            .collect();\n+        let fields = struct_def.fields().iter().map(|field| {\n+            let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n+            let field_ty = self.normalize_associated_types_in(field.span,\n+                                                              &field_ty);\n+            AdtField { ty: field_ty, span: field.span }\n+        })\n+        .collect();\n         AdtVariant { fields: fields }\n     }\n \n@@ -1010,8 +997,8 @@ fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast:\n \n fn error_194(tcx: TyCtxt, span: Span, trait_decl_span: Span, name: &str) {\n     struct_span_err!(tcx.sess, span, E0194,\n-              \"type parameter `{}` shadows another type parameter of the same name\",\n-              name)\n+                     \"type parameter `{}` shadows another type parameter of the same name\",\n+                     name)\n         .span_label(span, \"shadows another type parameter\")\n         .span_label(trait_decl_span, format!(\"first `{}` declared here\", name))\n         .emit();"}, {"sha": "40f5d27356c7b97a7524174510bf0d4d683864ac", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1694eac74216da22b395a5589b8d080ccd5a2ec/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f1694eac74216da22b395a5589b8d080ccd5a2ec", "patch": "@@ -178,39 +178,34 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         if let hir::ExprKind::Index(ref base, ref index) = e.node {\n             let mut tables = self.fcx.tables.borrow_mut();\n \n-            match tables.expr_ty_adjusted(&base).sty {\n-                // All valid indexing looks like this\n-                ty::Ref(_, base_ty, _) => {\n-                    let index_ty = tables.expr_ty_adjusted(&index);\n-                    let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n-\n-                    if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n-                        // Remove the method call record\n-                        tables.type_dependent_defs_mut().remove(e.hir_id);\n-                        tables.node_substs_mut().remove(e.hir_id);\n-\n-                        tables.adjustments_mut().get_mut(base.hir_id).map(|a| {\n-                            // Discard the need for a mutable borrow\n-                            match a.pop() {\n-                                // Extra adjustment made when indexing causes a drop\n-                                // of size information - we need to get rid of it\n-                                // Since this is \"after\" the other adjustment to be\n-                                // discarded, we do an extra `pop()`\n-                                Some(Adjustment {\n-                                    kind: Adjust::Unsize,\n-                                    ..\n-                                }) => {\n-                                    // So the borrow discard actually happens here\n-                                    a.pop();\n-                                }\n-                                _ => {}\n+            // All valid indexing looks like this; might encounter non-valid indexes at this point\n+            if let ty::Ref(_, base_ty, _) = tables.expr_ty_adjusted(&base).sty {\n+                let index_ty = tables.expr_ty_adjusted(&index);\n+                let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n+\n+                if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n+                    // Remove the method call record\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n+\n+                    tables.adjustments_mut().get_mut(base.hir_id).map(|a| {\n+                        // Discard the need for a mutable borrow\n+                        match a.pop() {\n+                            // Extra adjustment made when indexing causes a drop\n+                            // of size information - we need to get rid of it\n+                            // Since this is \"after\" the other adjustment to be\n+                            // discarded, we do an extra `pop()`\n+                            Some(Adjustment {\n+                                kind: Adjust::Unsize,\n+                                ..\n+                            }) => {\n+                                // So the borrow discard actually happens here\n+                                a.pop();\n                             }\n-                        });\n-                    }\n+                            _ => {}\n+                        }\n+                    });\n                 }\n-                // Might encounter non-valid indexes at this point, so there\n-                // has to be a fall-through\n-                _ => {}\n             }\n         }\n     }\n@@ -445,7 +440,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                                     span,\n                                     &format!(\n                                         \"type parameter `{}` is part of concrete type but not used \\\n-                                        in parameter list for existential type\",\n+                                         in parameter list for existential type\",\n                                         ty,\n                                     ),\n                                 )\n@@ -767,10 +762,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n     // FIXME This should be carefully checked\n     // We could use `self.report_error` but it doesn't accept a ty::Region, right now.\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match self.infcx.fully_resolve(&r) {\n-            Ok(r) => r,\n-            Err(_) => self.tcx.types.re_static,\n-        }\n+        self.infcx.fully_resolve(&r).unwrap_or(self.tcx.types.re_static)\n     }\n }\n "}]}