{"sha": "1fe7525180dbd11b101ce65439218a8be4e2d528", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZTc1MjUxODBkYmQxMWIxMDFjZTY1NDM5MjE4YThiZTRlMmQ1Mjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-24T22:24:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-25T00:31:48Z"}, "message": "Rewrite stmt processing not to recurse to avoid stack overflow if there\nare tons of let statements. Fixes #29466.", "tree": {"sha": "b04330a1ce609e1901643b97925141930a46391b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b04330a1ce609e1901643b97925141930a46391b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fe7525180dbd11b101ce65439218a8be4e2d528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe7525180dbd11b101ce65439218a8be4e2d528", "html_url": "https://github.com/rust-lang/rust/commit/1fe7525180dbd11b101ce65439218a8be4e2d528", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fe7525180dbd11b101ce65439218a8be4e2d528/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c10d74a326d82026bcff3ec4b2da22ea9155584", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c10d74a326d82026bcff3ec4b2da22ea9155584", "html_url": "https://github.com/rust-lang/rust/commit/6c10d74a326d82026bcff3ec4b2da22ea9155584"}], "stats": {"total": 3716, "additions": 3673, "deletions": 43}, "files": [{"sha": "1f3b6ad7bceff09a15f2316c748fed26740e038e", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1fe7525180dbd11b101ce65439218a8be4e2d528/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe7525180dbd11b101ce65439218a8be4e2d528/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1fe7525180dbd11b101ce65439218a8be4e2d528", "patch": "@@ -135,8 +135,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n         self.push_scope(extent, block);\n         let rv = unpack!(block = f(self));\n-        assert_eq!(self.extent_of_innermost_scope(), extent);\n-        self.pop_scope(block);\n+        self.pop_scope(extent, block);\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n         block.and(rv)\n     }\n@@ -156,13 +155,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         });\n     }\n \n-    /// Pops the innermost scope, adding any drops onto the end of\n-    /// `block` that are needed.  This must match 1-to-1 with\n-    /// `push_scope`.\n-    pub fn pop_scope(&mut self, block: BasicBlock) {\n-        debug!(\"pop_scope({:?})\", block);\n+    /// Pops a scope, which should have extent `extent`, adding any\n+    /// drops onto the end of `block` that are needed.  This must\n+    /// match 1-to-1 with `push_scope`.\n+    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) {\n+        debug!(\"pop_scope({:?}, {:?})\", extent, block);\n         let scope = self.scopes.pop().unwrap();\n \n+        assert_eq!(scope.extent, extent);\n+\n         // add in any drops needed on the fallthrough path (any other\n         // exiting paths, such as those that arise from `break`, will\n         // have drops already)"}, {"sha": "ac6b2a3c5313fc17e1e2ef5de38de969631770c6", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1fe7525180dbd11b101ce65439218a8be4e2d528/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe7525180dbd11b101ce65439218a8be4e2d528/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=1fe7525180dbd11b101ce65439218a8be4e2d528", "patch": "@@ -14,48 +14,70 @@ use repr::*;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<'tcx>>) -> BlockAnd<()> {\n-        for stmt in stmts {\n-            unpack!(block = self.stmt(block, stmt));\n-        }\n-        block.unit()\n-    }\n-\n-    pub fn stmt(&mut self, mut block: BasicBlock, stmt: StmtRef<'tcx>) -> BlockAnd<()> {\n+        // This convoluted structure is to avoid using recursion as we walk down a list\n+        // of statements. Basically, the structure we get back is something like:\n+        //\n+        //    let x = <init> in {\n+        //       let y = <init> in {\n+        //           expr1;\n+        //           expr2;\n+        //       }\n+        //    }\n+        //\n+        // To process this, we keep a stack of (Option<CodeExtent>,\n+        // vec::IntoIter<Stmt>) pairs.  At each point we pull off the\n+        // top most pair and extract one statement from the\n+        // iterator. Once it's complete, we pop the scope from the\n+        // first half the pair.\n         let this = self;\n-        let Stmt { span, kind } = this.hir.mirror(stmt);\n-        match kind {\n-            StmtKind::Let { remainder_scope,\n-                            init_scope,\n-                            pattern,\n-                            initializer: Some(initializer),\n-                            stmts } => {\n-                this.in_scope(remainder_scope, block, |this| {\n-                    unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.expr_into_pattern(block, remainder_scope, pattern, initializer)\n+        let mut stmt_lists = vec![(None, stmts.into_iter())];\n+        while !stmt_lists.is_empty() {\n+            let stmt = {\n+                let &mut (_, ref mut stmts) = stmt_lists.last_mut().unwrap();\n+                stmts.next()\n+            };\n+\n+            let stmt = match stmt {\n+                Some(stmt) => stmt,\n+                None => {\n+                    let (extent, _) = stmt_lists.pop().unwrap();\n+                    if let Some(extent) = extent {\n+                        this.pop_scope(extent, block);\n+                    }\n+                    continue\n+                }\n+            };\n+\n+            let Stmt { span, kind } = this.hir.mirror(stmt);\n+            match kind {\n+                StmtKind::Let { remainder_scope, init_scope, pattern, initializer, stmts } => {\n+                    this.push_scope(remainder_scope, block);\n+                    stmt_lists.push((Some(remainder_scope), stmts.into_iter()));\n+                    unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                        // FIXME #30046                              ^~~~\n+                        match initializer {\n+                            Some(initializer) => {\n+                                this.expr_into_pattern(block, remainder_scope, pattern, initializer)\n+                            }\n+                            None => {\n+                                this.declare_bindings(remainder_scope, &pattern);\n+                                block.unit()\n+                            }\n+                        }\n                     }));\n-                    this.stmts(block, stmts)\n-                })\n-            }\n+                }\n \n-            StmtKind::Let { remainder_scope, init_scope, pattern, initializer: None, stmts } => {\n-                this.in_scope(remainder_scope, block, |this| {\n-                    unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.declare_bindings(remainder_scope, &pattern);\n+                StmtKind::Expr { scope, expr } => {\n+                    unpack!(block = this.in_scope(scope, block, |this| {\n+                        let expr = this.hir.mirror(expr);\n+                        let temp = this.temp(expr.ty.clone());\n+                        unpack!(block = this.into(&temp, block, expr));\n+                        this.cfg.push_drop(block, span, DropKind::Deep, &temp);\n                         block.unit()\n                     }));\n-                    this.stmts(block, stmts)\n-                })\n-            }\n-\n-            StmtKind::Expr { scope, expr } => {\n-                this.in_scope(scope, block, |this| {\n-                    let expr = this.hir.mirror(expr);\n-                    let temp = this.temp(expr.ty.clone());\n-                    unpack!(block = this.into(&temp, block, expr));\n-                    this.cfg.push_drop(block, span, DropKind::Deep, &temp);\n-                    block.unit()\n-                })\n+                }\n             }\n         }\n+        block.unit()\n     }\n }"}, {"sha": "9e7b73467229a4f98164d13ca9e68113fc6db531", "filename": "src/test/run-pass/issue-29466.rs", "status": "added", "additions": 3607, "deletions": 0, "changes": 3607, "blob_url": "https://github.com/rust-lang/rust/blob/1fe7525180dbd11b101ce65439218a8be4e2d528/src%2Ftest%2Frun-pass%2Fissue-29466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe7525180dbd11b101ce65439218a8be4e2d528/src%2Ftest%2Frun-pass%2Fissue-29466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29466.rs?ref=1fe7525180dbd11b101ce65439218a8be4e2d528"}]}