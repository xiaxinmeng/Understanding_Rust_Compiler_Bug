{"sha": "0534a555ccb1a62c2f379bbd2e8cd323e6652e31", "node_id": "C_kwDOAAsO6NoAKDA1MzRhNTU1Y2NiMWE2MmMyZjM3OWJiZDJlOGNkMzIzZTY2NTJlMzE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T17:48:22Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-08-18T17:48:22Z"}, "message": "Make line_program_add_file a DebugContext method", "tree": {"sha": "6d8cf2c60a9dc09fcc0082bdd0ef0bc36af929a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d8cf2c60a9dc09fcc0082bdd0ef0bc36af929a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0534a555ccb1a62c2f379bbd2e8cd323e6652e31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0534a555ccb1a62c2f379bbd2e8cd323e6652e31", "html_url": "https://github.com/rust-lang/rust/commit/0534a555ccb1a62c2f379bbd2e8cd323e6652e31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0534a555ccb1a62c2f379bbd2e8cd323e6652e31/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e57774011ab634a04c0efd3bf2e956ee8997245", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e57774011ab634a04c0efd3bf2e956ee8997245", "html_url": "https://github.com/rust-lang/rust/commit/1e57774011ab634a04c0efd3bf2e956ee8997245"}], "stats": {"total": 105, "additions": 52, "deletions": 53}, "files": [{"sha": "4fdaaf4ffe0a038d422eb7b6619f2eb2561e06ef", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0534a555ccb1a62c2f379bbd2e8cd323e6652e31/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0534a555ccb1a62c2f379bbd2e8cd323e6652e31/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=0534a555ccb1a62c2f379bbd2e8cd323e6652e31", "patch": "@@ -84,39 +84,41 @@ fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     }\n }\n \n-fn line_program_add_file(\n-    line_program: &mut LineProgram,\n-    line_strings: &mut LineStringTable,\n-    file: &SourceFile,\n-) -> FileId {\n-    match &file.name {\n-        FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n-            let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n-            let file_name = osstr_as_utf8_bytes(file_name);\n-\n-            let dir_id = if !dir_name.is_empty() {\n-                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n-                line_program.add_directory(dir_name)\n-            } else {\n-                line_program.default_directory()\n-            };\n-            let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n-\n-            let info = make_file_info(file.src_hash);\n-\n-            line_program.file_has_md5 &= info.is_some();\n-            line_program.add_file(file_name, dir_id, info)\n-        }\n-        // FIXME give more appropriate file names\n-        filename => {\n-            let dir_id = line_program.default_directory();\n-            let dummy_file_name = LineString::new(\n-                filename.prefer_remapped().to_string().into_bytes(),\n-                line_program.encoding(),\n-                line_strings,\n-            );\n-            line_program.add_file(dummy_file_name, dir_id, None)\n+impl DebugContext {\n+    pub(crate) fn add_source_file(&mut self, source_file: &SourceFile) -> FileId {\n+        let line_program: &mut LineProgram = &mut self.dwarf.unit.line_program;\n+        let line_strings: &mut LineStringTable = &mut self.dwarf.line_strings;\n+\n+        match &source_file.name {\n+            FileName::Real(path) => {\n+                let (dir_path, file_name) =\n+                    split_path_dir_and_file(path.remapped_path_if_available());\n+                let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n+                let file_name = osstr_as_utf8_bytes(file_name);\n+\n+                let dir_id = if !dir_name.is_empty() {\n+                    let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n+                    line_program.add_directory(dir_name)\n+                } else {\n+                    line_program.default_directory()\n+                };\n+                let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+\n+                let info = make_file_info(source_file.src_hash);\n+\n+                line_program.file_has_md5 &= info.is_some();\n+                line_program.add_file(file_name, dir_id, info)\n+            }\n+            // FIXME give more appropriate file names\n+            filename => {\n+                let dir_id = line_program.default_directory();\n+                let dummy_file_name = LineString::new(\n+                    filename.prefer_remapped().to_string().into_bytes(),\n+                    line_program.encoding(),\n+                    line_strings,\n+                );\n+                line_program.add_file(dummy_file_name, dir_id, None)\n+            }\n         }\n     }\n }\n@@ -130,11 +132,7 @@ impl FunctionDebugContext {\n     ) {\n         let (file, line, column) = get_span_loc(tcx, span, span);\n \n-        let file_id = line_program_add_file(\n-            &mut debug_context.dwarf.unit.line_program,\n-            &mut debug_context.dwarf.line_strings,\n-            &file,\n-        );\n+        let file_id = debug_context.add_source_file(&file);\n \n         let entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n@@ -151,15 +149,12 @@ impl FunctionDebugContext {\n         function_span: Span,\n         source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) -> CodeOffset {\n-        let line_program = &mut debug_context.dwarf.unit.line_program;\n-\n-        let line_strings = &mut debug_context.dwarf.line_strings;\n         let mut last_span = None;\n         let mut last_file = None;\n-        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n+        let mut create_row_for_span = |debug_context: &mut DebugContext, span: Span| {\n             if let Some(last_span) = last_span {\n                 if span == last_span {\n-                    line_program.generate_row();\n+                    debug_context.dwarf.unit.line_program.generate_row();\n                     return;\n                 }\n             }\n@@ -177,33 +172,37 @@ impl FunctionDebugContext {\n                 true\n             };\n             if current_file_changed {\n-                let file_id = line_program_add_file(line_program, line_strings, &file);\n-                line_program.row().file = file_id;\n+                let file_id = debug_context.add_source_file(&file);\n+                debug_context.dwarf.unit.line_program.row().file = file_id;\n                 last_file = Some(file);\n             }\n \n-            line_program.row().line = line;\n-            line_program.row().column = col;\n-            line_program.generate_row();\n+            debug_context.dwarf.unit.line_program.row().line = line;\n+            debug_context.dwarf.unit.line_program.row().column = col;\n+            debug_context.dwarf.unit.line_program.generate_row();\n         };\n \n-        line_program.begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n+        debug_context\n+            .dwarf\n+            .unit\n+            .line_program\n+            .begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n \n         let mut func_end = 0;\n \n         let mcr = context.mach_compile_result.as_ref().unwrap();\n         for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-            line_program.row().address_offset = u64::from(start);\n+            debug_context.dwarf.unit.line_program.row().address_offset = u64::from(start);\n             if !loc.is_default() {\n                 let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                create_row_for_span(line_program, source_info.span);\n+                create_row_for_span(debug_context, source_info.span);\n             } else {\n-                create_row_for_span(line_program, function_span);\n+                create_row_for_span(debug_context, function_span);\n             }\n             func_end = end;\n         }\n \n-        line_program.end_sequence(u64::from(func_end));\n+        debug_context.dwarf.unit.line_program.end_sequence(u64::from(func_end));\n \n         let func_end = mcr.buffer.total_size();\n "}]}