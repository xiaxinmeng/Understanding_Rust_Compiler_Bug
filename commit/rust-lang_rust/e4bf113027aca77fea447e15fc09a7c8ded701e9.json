{"sha": "e4bf113027aca77fea447e15fc09a7c8ded701e9", "node_id": "C_kwDOAAsO6NoAKGU0YmYxMTMwMjdhY2E3N2ZlYTQ0N2UxNWZjMDlhN2M4ZGVkNzAxZTk", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-25T07:52:37Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-25T23:35:28Z"}, "message": "Box `CastTarget` within `PassMode`.\n\nBecause `PassMode::Cast` is by far the largest variant, but is\nrelatively rare.\n\nThis requires making `PassMode` not impl `Copy`, and `Clone` is no\nlonger necessary. This causes lots of sigil adjusting, but nothing very\nnotable.", "tree": {"sha": "b6eff452338b37a0e064a6ac6ca32c8828bab105", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6eff452338b37a0e064a6ac6ca32c8828bab105"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4bf113027aca77fea447e15fc09a7c8ded701e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4bf113027aca77fea447e15fc09a7c8ded701e9", "html_url": "https://github.com/rust-lang/rust/commit/e4bf113027aca77fea447e15fc09a7c8ded701e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4bf113027aca77fea447e15fc09a7c8ded701e9/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "263c426bfd2d8119ad9f615fc0616cf01984435a", "url": "https://api.github.com/repos/rust-lang/rust/commits/263c426bfd2d8119ad9f615fc0616cf01984435a", "html_url": "https://github.com/rust-lang/rust/commit/263c426bfd2d8119ad9f615fc0616cf01984435a"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "7f4619b5c940b12f3701ca2aebba46e92808a163", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -24,7 +24,7 @@ pub(super) fn add_arg_comment<'tcx>(\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: &[Value],\n-    arg_abi_mode: PassMode,\n+    arg_abi_mode: &PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n     if !fx.clif_comments.enabled() {"}, {"sha": "058dee176e2430b96df76c0e9c3e5e9177e92728", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -38,7 +38,7 @@ fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -\n     param\n }\n \n-fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+fn cast_target_to_abi_params(cast: &CastTarget) -> SmallVec<[AbiParam; 2]> {\n     let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n         (0, 0)\n     } else {\n@@ -100,7 +100,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Cast(ref cast) => cast_target_to_abi_params(cast),\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     // Abi requires aligning struct size to pointer size\n@@ -145,7 +145,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Cast(ref cast) => {\n+                (None, cast_target_to_abi_params(cast).into_iter().collect())\n+            }\n             PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n                 (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n@@ -160,7 +162,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n pub(super) fn to_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> SmallVec<[Value; 2]> {\n     let (ptr, meta) = arg.force_stack(fx);\n     assert!(meta.is_none());\n@@ -179,7 +181,7 @@ pub(super) fn from_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n     let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n@@ -224,7 +226,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Cast(ref cast) => to_casted_value(fx, arg, cast),\n         PassMode::Indirect { .. } => {\n             if is_owned {\n                 match arg.force_stack(fx) {\n@@ -268,7 +270,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         local,\n         local_field,\n         &block_params,\n-        arg_abi.mode,\n+        &arg_abi.mode,\n         arg_abi.layout,\n     );\n \n@@ -282,7 +284,9 @@ pub(super) fn cvalue_for_param<'tcx>(\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n-        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Cast(ref cast) => {\n+            Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n             Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))"}, {"sha": "29ef5e2dfdae60356639583629a7c94c268429c2", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -44,7 +44,7 @@ pub(super) fn codegen_return_param<'tcx>(\n         Some(RETURN_PLACE),\n         None,\n         &ret_param,\n-        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        &fx.fn_abi.as_ref().unwrap().ret.mode,\n         fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n@@ -92,7 +92,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n             ret_place\n                 .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast) => {\n             let results =\n                 fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n             let result =\n@@ -131,7 +131,7 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx);\n             let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);"}, {"sha": "9b55db6a5476473119276c011d7427236fd4a929", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -133,7 +133,7 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             match self.ret.mode {\n                 PassMode::Ignore => cx.type_void(),\n                 PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_gcc_type(cx),\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast) => cast.gcc_type(cx),\n                 PassMode::Indirect { .. } => {\n                     argument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                     cx.type_void()\n@@ -157,7 +157,7 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                     unimplemented!();\n                 }\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast) => cast.gcc_type(cx),\n                 PassMode::Indirect { extra_attrs: None, on_stack: true, .. } => {\n                     on_stack_param_indices.insert(argument_tys.len());\n                     arg.memory_ty(cx)"}, {"sha": "f4493776ea268f5f3d042ef559e99ef9c05c2253", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 sym::volatile_load | sym::unaligned_volatile_load => {\n                     let tp_ty = substs.type_at(0);\n                     let mut ptr = args[0].immediate();\n-                    if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                    if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n                         ptr = self.pointercast(ptr, self.type_ptr_to(ty.gcc_type(self)));\n                     }\n                     let load = self.volatile_load(ptr.get_type(), ptr);\n@@ -320,7 +320,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+            if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.gcc_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);\n@@ -416,7 +416,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n         }\n-        else if let PassMode::Cast(cast) = self.mode {\n+        else if let PassMode::Cast(ref cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;"}, {"sha": "09c53afa6c81427fcbe25a51651234c576da3589", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -213,7 +213,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n-        } else if let PassMode::Cast(cast) = self.mode {\n+        } else if let PassMode::Cast(cast) = &self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -335,7 +335,7 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 } + args_capacity,\n         );\n \n-        let llreturn_ty = match self.ret.mode {\n+        let llreturn_ty = match &self.ret.mode {\n             PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_llvm_type(cx),\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n@@ -351,7 +351,7 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 llargument_tys.push(ty.llvm_type(cx));\n             }\n \n-            let llarg_ty = match arg.mode {\n+            let llarg_ty = match &arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n@@ -426,11 +426,11 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             i += 1;\n             i - 1\n         };\n-        match self.ret.mode {\n-            PassMode::Direct(ref attrs) => {\n+        match &self.ret.mode {\n+            PassMode::Direct(attrs) => {\n                 attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n             }\n-            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+            PassMode::Indirect { attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(attrs);\n                 let sret = llvm::CreateStructRetAttr(cx.llcx, self.ret.layout.llvm_type(cx));\n@@ -445,23 +445,23 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             if arg.pad.is_some() {\n                 apply(&ArgAttributes::new());\n             }\n-            match arg.mode {\n+            match &arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(attrs);\n                     let byval = llvm::CreateByValAttr(cx.llcx, arg.layout.llvm_type(cx));\n                     attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[byval]);\n                 }\n-                PassMode::Direct(ref attrs)\n-                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                PassMode::Direct(attrs)\n+                | PassMode::Indirect { attrs, extra_attrs: None, on_stack: false } => {\n                     apply(attrs);\n                 }\n-                PassMode::Indirect { ref attrs, extra_attrs: Some(ref extra_attrs), on_stack } => {\n+                PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack } => {\n                     assert!(!on_stack);\n                     apply(attrs);\n                     apply(extra_attrs);\n                 }\n-                PassMode::Pair(ref a, ref b) => {\n+                PassMode::Pair(a, b) => {\n                     apply(a);\n                     apply(b);\n                 }\n@@ -488,11 +488,11 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             i += 1;\n             i - 1\n         };\n-        match self.ret.mode {\n-            PassMode::Direct(ref attrs) => {\n+        match &self.ret.mode {\n+            PassMode::Direct(attrs) => {\n                 attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, bx.cx, callsite);\n             }\n-            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+            PassMode::Indirect { attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(bx.cx, attrs);\n                 let sret = llvm::CreateStructRetAttr(bx.cx.llcx, self.ret.layout.llvm_type(bx));\n@@ -521,9 +521,9 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             if arg.pad.is_some() {\n                 apply(bx.cx, &ArgAttributes::new());\n             }\n-            match arg.mode {\n+            match &arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(bx.cx, attrs);\n                     let byval = llvm::CreateByValAttr(bx.cx.llcx, arg.layout.llvm_type(bx));\n                     attributes::apply_to_callsite(\n@@ -532,19 +532,15 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                         &[byval],\n                     );\n                 }\n-                PassMode::Direct(ref attrs)\n-                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                PassMode::Direct(attrs)\n+                | PassMode::Indirect { attrs, extra_attrs: None, on_stack: false } => {\n                     apply(bx.cx, attrs);\n                 }\n-                PassMode::Indirect {\n-                    ref attrs,\n-                    extra_attrs: Some(ref extra_attrs),\n-                    on_stack: _,\n-                } => {\n+                PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack: _ } => {\n                     apply(bx.cx, attrs);\n                     apply(bx.cx, extra_attrs);\n                 }\n-                PassMode::Pair(ref a, ref b) => {\n+                PassMode::Pair(a, b) => {\n                     apply(bx.cx, a);\n                     apply(bx.cx, b);\n                 }"}, {"sha": "d46a6dd32c8a5b9c91e450e4e8fdf20cd9a2ad05", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -161,7 +161,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n                 let ptr = args[0].immediate();\n-                let load = if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                let load = if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n                     let llty = ty.llvm_type(self);\n                     let ptr = self.pointercast(ptr, self.type_ptr_to(llty));\n                     self.volatile_load(llty, ptr)\n@@ -374,7 +374,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+            if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.llvm_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);"}, {"sha": "187af47114f254a59cd99fa5e8505521aacb3caa", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.unreachable();\n             return;\n         }\n-        let llval = match self.fn_abi.ret.mode {\n+        let llval = match &self.fn_abi.ret.mode {\n             PassMode::Ignore | PassMode::Indirect { .. } => {\n                 bx.ret_void();\n                 return;\n@@ -360,7 +360,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         llval\n                     }\n                 };\n-                let ty = bx.cast_backend_type(&cast_ty);\n+                let ty = bx.cast_backend_type(cast_ty);\n                 let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n                 bx.load(ty, addr, self.fn_abi.ret.layout.align.abi)\n             }\n@@ -1222,8 +1222,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if let PassMode::Cast(ty) = arg.mode {\n-                let llty = bx.cast_backend_type(&ty);\n+            if let PassMode::Cast(ty) = &arg.mode {\n+                let llty = bx.cast_backend_type(ty);\n                 let addr = bx.pointercast(llval, bx.type_ptr_to(llty));\n                 llval = bx.load(llty, addr, align.min(arg.layout.align.abi));\n             } else {"}, {"sha": "e11ebdce80f77bdf9fc4c640841992476ee65522", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -597,8 +597,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n-                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(&ty));\n+            if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n+                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(ty));\n                 let ptr = bx.pointercast(result.llval, ptr_llty);\n                 bx.store(llval, ptr, result.align);\n             } else {"}, {"sha": "27bb828feacf794a0fba1a1566461f8ae226fb42", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -218,7 +218,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Padding must be fully equal.\n         let pad_compat = || caller_abi.pad == callee_abi.pad;\n         // When comparing the PassMode, we have to be smart about comparing the attributes.\n-        let arg_attr_compat = |a1: ArgAttributes, a2: ArgAttributes| {\n+        let arg_attr_compat = |a1: &ArgAttributes, a2: &ArgAttributes| {\n             // There's only one regular attribute that matters for the call ABI: InReg.\n             // Everything else is things like noalias, dereferencable, nonnull, ...\n             // (This also applies to pointee_size, pointee_align.)\n@@ -233,7 +233,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             return true;\n         };\n-        let mode_compat = || match (caller_abi.mode, callee_abi.mode) {\n+        let mode_compat = || match (&caller_abi.mode, &callee_abi.mode) {\n             (PassMode::Ignore, PassMode::Ignore) => true,\n             (PassMode::Direct(a1), PassMode::Direct(a2)) => arg_attr_compat(a1, a2),\n             (PassMode::Pair(a1, b1), PassMode::Pair(a2, b2)) => {"}, {"sha": "d4430b1609b9c3b01adf391736fc78b3734b5464", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4bf113027aca77fea447e15fc09a7c8ded701e9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=e4bf113027aca77fea447e15fc09a7c8ded701e9", "patch": "@@ -26,7 +26,7 @@ mod x86;\n mod x86_64;\n mod x86_win64;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum PassMode {\n     /// Ignore the argument.\n     ///\n@@ -42,7 +42,7 @@ pub enum PassMode {\n     Pair(ArgAttributes, ArgAttributes),\n     /// Pass the argument after casting it, to either\n     /// a single uniform or a pair of registers.\n-    Cast(CastTarget),\n+    Cast(Box<CastTarget>),\n     /// Pass the argument indirectly via a hidden pointer.\n     /// The `extra_attrs` value, if any, is for the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n@@ -548,7 +548,7 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n-        self.mode = PassMode::Cast(target.into());\n+        self.mode = PassMode::Cast(Box::new(target.into()));\n     }\n \n     pub fn pad_with(&mut self, reg: Reg) {\n@@ -737,6 +737,6 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(ArgAbi<'_, usize>, 208);\n-    static_assert_size!(FnAbi<'_, usize>, 248);\n+    static_assert_size!(ArgAbi<'_, usize>, 72);\n+    static_assert_size!(FnAbi<'_, usize>, 112);\n }"}]}