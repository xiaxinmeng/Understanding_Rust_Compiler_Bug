{"sha": "05ba45c667454028c3e65769d6f63fb0f27c1ca8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YmE0NWM2Njc0NTQwMjhjM2U2NTc2OWQ2ZjYzZmIwZjI3YzFjYTg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T18:02:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-15T18:02:42Z"}, "message": "remove Canceled from API impl", "tree": {"sha": "f3bfbaecca27705d41dfb5864615ff795d564f2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3bfbaecca27705d41dfb5864615ff795d564f2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05ba45c667454028c3e65769d6f63fb0f27c1ca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05ba45c667454028c3e65769d6f63fb0f27c1ca8", "html_url": "https://github.com/rust-lang/rust/commit/05ba45c667454028c3e65769d6f63fb0f27c1ca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05ba45c667454028c3e65769d6f63fb0f27c1ca8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c3d2f78eeea41c6de8430c2a34b38e1cdb861b", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c3d2f78eeea41c6de8430c2a34b38e1cdb861b", "html_url": "https://github.com/rust-lang/rust/commit/02c3d2f78eeea41c6de8430c2a34b38e1cdb861b"}], "stats": {"total": 137, "additions": 61, "deletions": 76}, "files": [{"sha": "439080075593095204482bd106f959ba1e7fccb4", "filename": "crates/ra_db/src/cancellation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_db%2Fsrc%2Fcancellation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fcancellation.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -21,8 +21,6 @@ pub struct Canceled {\n     _private: (),\n }\n \n-pub type Cancelable<T> = Result<T, Canceled>;\n-\n impl Canceled {\n     pub(crate) fn new() -> Canceled {\n         Canceled { _private: () }"}, {"sha": "89113e7a6ff641ae16bc7cad55a4502d6c2f09c9", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -10,7 +10,7 @@ use std::panic;\n use ra_syntax::{TextUnit, TextRange, SourceFile, TreeArc};\n \n pub use crate::{\n-    cancellation::{Canceled, Cancelable},\n+    cancellation::Canceled,\n     syntax_ptr::LocalSyntaxPtr,\n     input::{\n         FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,"}, {"sha": "18b9508ef3cf22f2ee71e55c6dc7f0cd3d3d5b8e", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -1,6 +1,6 @@\n use std::cmp::{max, min};\n \n-use ra_db::{SyntaxDatabase, Cancelable};\n+use ra_db::SyntaxDatabase;\n use ra_syntax::{\n     AstNode, SyntaxNode, TextUnit, TextRange,\n     SyntaxKind::FN_DEF,\n@@ -11,21 +11,23 @@ use ra_syntax::{\n use crate::{FilePosition, CallInfo, db::RootDatabase};\n \n /// Computes parameter information for the given call expression.\n-pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n+pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<CallInfo> {\n     let file = db.source_file(position.file_id);\n     let syntax = file.syntax();\n \n     // Find the calling expression and it's NameRef\n-    let calling_node = ctry!(FnCallNode::with_node(syntax, position.offset));\n-    let name_ref = ctry!(calling_node.name_ref());\n+    let calling_node = FnCallNode::with_node(syntax, position.offset)?;\n+    let name_ref = calling_node.name_ref()?;\n \n     // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n     let file_symbols = db.index_resolve(name_ref);\n-    let symbol = ctry!(file_symbols.into_iter().find(|it| it.ptr.kind() == FN_DEF));\n+    let symbol = file_symbols\n+        .into_iter()\n+        .find(|it| it.ptr.kind() == FN_DEF)?;\n     let fn_file = db.source_file(symbol.file_id);\n     let fn_def = symbol.ptr.resolve(&fn_file);\n     let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n-    let mut call_info = ctry!(CallInfo::new(fn_def));\n+    let mut call_info = CallInfo::new(fn_def)?;\n     // If we have a calling expression let's find which argument we are on\n     let num_params = call_info.parameters.len();\n     let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n@@ -61,7 +63,7 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable\n         }\n     }\n \n-    Ok(Some(call_info))\n+    Some(call_info)\n }\n \n enum FnCallNode<'a> {"}, {"sha": "b1becca03167d60c8ab142bb7d2aa5367a9a8f1f", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{FileId, Cancelable, SyntaxDatabase};\n+use ra_db::{FileId, SyntaxDatabase};\n use ra_syntax::{\n     AstNode, ast,\n     algo::find_node_at_offset,\n@@ -9,21 +9,18 @@ use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,\n-) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n+) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n     let file = db.source_file(position.file_id);\n     let syntax = file.syntax();\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        let navs = reference_definition(db, position.file_id, name_ref)?.to_vec();\n-        return Ok(Some(RangeInfo::new(\n-            name_ref.syntax().range(),\n-            navs.to_vec(),\n-        )));\n+        let navs = reference_definition(db, position.file_id, name_ref).to_vec();\n+        return Some(RangeInfo::new(name_ref.syntax().range(), navs.to_vec()));\n     }\n     if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-        let navs = ctry!(name_definition(db, position.file_id, name)?);\n-        return Ok(Some(RangeInfo::new(name.syntax().range(), navs)));\n+        let navs = name_definition(db, position.file_id, name)?;\n+        return Some(RangeInfo::new(name.syntax().range(), navs));\n     }\n-    Ok(None)\n+    None\n }\n \n pub(crate) enum ReferenceResult {\n@@ -45,7 +42,7 @@ pub(crate) fn reference_definition(\n     db: &RootDatabase,\n     file_id: FileId,\n     name_ref: &ast::NameRef,\n-) -> Cancelable<ReferenceResult> {\n+) -> ReferenceResult {\n     use self::ReferenceResult::*;\n     if let Some(function) =\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())\n@@ -54,7 +51,7 @@ pub(crate) fn reference_definition(\n         // First try to resolve the symbol locally\n         if let Some(entry) = scope.resolve_local_name(name_ref) {\n             let nav = NavigationTarget::from_scope_entry(file_id, &entry);\n-            return Ok(Exact(nav));\n+            return Exact(nav);\n         };\n \n         // Next check if it is a method\n@@ -71,7 +68,7 @@ pub(crate) fn reference_definition(\n                 .and_then(|it| infer_result.method_resolution(it))\n             {\n                 if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n-                    return Ok(Exact(target));\n+                    return Exact(target);\n                 }\n             };\n         }\n@@ -88,7 +85,7 @@ pub(crate) fn reference_definition(\n             let resolved = module.resolve_path(db, &path);\n             if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n                 if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n-                    return Ok(Exact(target));\n+                    return Exact(target);\n                 }\n             }\n         }\n@@ -99,25 +96,25 @@ pub(crate) fn reference_definition(\n         .into_iter()\n         .map(NavigationTarget::from_symbol)\n         .collect();\n-    Ok(Approximate(navs))\n+    Approximate(navs)\n }\n \n fn name_definition(\n     db: &RootDatabase,\n     file_id: FileId,\n     name: &ast::Name,\n-) -> Cancelable<Option<Vec<NavigationTarget>>> {\n+) -> Option<Vec<NavigationTarget>> {\n     if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n         if module.has_semi() {\n             if let Some(child_module) =\n                 hir::source_binder::module_from_declaration(db, file_id, module)\n             {\n                 let nav = NavigationTarget::from_module(db, child_module);\n-                return Ok(Some(vec![nav]));\n+                return Some(vec![nav]);\n             }\n         }\n     }\n-    Ok(None)\n+    None\n }\n \n #[cfg(test)]"}, {"sha": "d91151c15baf2353af6ae59fa145aa699983f733", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{Cancelable, SyntaxDatabase};\n+use ra_db::{SyntaxDatabase};\n use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc,\n     ast::self,\n@@ -7,27 +7,24 @@ use ra_syntax::{\n \n use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, NavigationTarget};\n \n-pub(crate) fn hover(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Option<RangeInfo<String>>> {\n+pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<String>> {\n     let file = db.source_file(position.file_id);\n     let mut res = Vec::new();\n \n     let mut range = None;\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         use crate::goto_definition::{ReferenceResult::*, reference_definition};\n-        let ref_result = reference_definition(db, position.file_id, name_ref)?;\n+        let ref_result = reference_definition(db, position.file_id, name_ref);\n         match ref_result {\n-            Exact(nav) => res.extend(doc_text_for(db, nav)?),\n+            Exact(nav) => res.extend(doc_text_for(db, nav)),\n             Approximate(navs) => {\n                 let mut msg = String::from(\"Failed to exactly resolve the symbol. This is probably because rust_analyzer does not yet support glob imports or traits.\");\n                 if !navs.is_empty() {\n                     msg.push_str(\"  \\nThese items were found instead:\");\n                 }\n                 res.push(msg);\n                 for nav in navs {\n-                    res.extend(doc_text_for(db, nav)?)\n+                    res.extend(doc_text_for(db, nav))\n                 }\n             }\n         }\n@@ -39,25 +36,24 @@ pub(crate) fn hover(\n         let node = find_leaf_at_offset(file.syntax(), position.offset).find_map(|leaf| {\n             leaf.ancestors()\n                 .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())\n-        });\n-        let node = ctry!(node);\n+        })?;\n         let frange = FileRange {\n             file_id: position.file_id,\n             range: node.range(),\n         };\n-        res.extend(type_of(db, frange)?.map(Into::into));\n+        res.extend(type_of(db, frange).map(Into::into));\n         range = Some(node.range());\n     };\n \n-    let range = ctry!(range);\n+    let range = range?;\n     if res.is_empty() {\n-        return Ok(None);\n+        return None;\n     }\n     let res = RangeInfo::new(range, res.join(\"\\n\\n---\\n\"));\n-    Ok(Some(res))\n+    Some(res)\n }\n \n-pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option<String>> {\n+pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n     let file = db.source_file(frange.file_id);\n     let syntax = file.syntax();\n     let leaf_node = find_covering_node(syntax, frange.range);\n@@ -67,34 +63,28 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option\n         .take_while(|it| it.range() == leaf_node.range())\n         .find(|&it| ast::Expr::cast(it).is_some() || ast::Pat::cast(it).is_some())\n         .unwrap_or(leaf_node);\n-    let parent_fn = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n-    let function = ctry!(hir::source_binder::function_from_source(\n-        db,\n-        frange.file_id,\n-        parent_fn\n-    ));\n+    let parent_fn = node.ancestors().find_map(ast::FnDef::cast)?;\n+    let function = hir::source_binder::function_from_source(db, frange.file_id, parent_fn)?;\n     let infer = function.infer(db);\n     let syntax_mapping = function.body_syntax_mapping(db);\n     if let Some(expr) = ast::Expr::cast(node).and_then(|e| syntax_mapping.node_expr(e)) {\n-        Ok(Some(infer[expr].to_string()))\n+        Some(infer[expr].to_string())\n     } else if let Some(pat) = ast::Pat::cast(node).and_then(|p| syntax_mapping.node_pat(p)) {\n-        Ok(Some(infer[pat].to_string()))\n+        Some(infer[pat].to_string())\n     } else {\n-        Ok(None)\n+        None\n     }\n }\n \n // FIXME: this should not really use navigation target. Rather, approximatelly\n // resovled symbol should return a `DefId`.\n-fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-    let result = match (nav.description(db), nav.docs(db)) {\n+fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Option<String> {\n+    match (nav.description(db), nav.docs(db)) {\n         (Some(desc), Some(docs)) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs),\n         (Some(desc), None) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\"),\n         (None, Some(docs)) => Some(docs),\n         _ => None,\n-    };\n-\n-    Ok(result)\n+    }\n }\n \n impl NavigationTarget {"}, {"sha": "f18eb09ae7d48cd625ade3216b9f5ac5d450e976", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -58,9 +58,11 @@ pub use ra_ide_api_light::{\n     LineIndex, LineCol, translate_offset_with_edit,\n };\n pub use ra_db::{\n-    Cancelable, Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId\n+    Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId\n };\n \n+pub type Cancelable<T> = Result<T, Canceled>;\n+\n #[derive(Default)]\n pub struct AnalysisChange {\n     new_roots: Vec<(SourceRootId, bool)>,\n@@ -393,7 +395,7 @@ impl Analysis {\n         position: FilePosition,\n     ) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n         self.db\n-            .catch_canceled(|db| goto_definition::goto_definition(db, position))?\n+            .catch_canceled(|db| goto_definition::goto_definition(db, position))\n     }\n \n     /// Finds all usages of the reference at point.\n@@ -403,18 +405,18 @@ impl Analysis {\n \n     /// Returns a short text descrbing element at position.\n     pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n-        self.with_db(|db| hover::hover(db, position))?\n+        self.with_db(|db| hover::hover(db, position))\n     }\n \n     /// Computes parameter information for the given call expression.\n     pub fn call_info(&self, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n         self.db\n-            .catch_canceled(|db| call_info::call_info(db, position))?\n+            .catch_canceled(|db| call_info::call_info(db, position))\n     }\n \n     /// Returns a `mod name;` declaration which created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n-        self.with_db(|db| parent_module::parent_module(db, position))?\n+        self.with_db(|db| parent_module::parent_module(db, position))\n     }\n \n     /// Returns crates this file belongs too.\n@@ -430,7 +432,7 @@ impl Analysis {\n     /// Returns the set of possible targets to run for the current file.\n     pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n         self.db\n-            .catch_canceled(|db| runnables::runnables(db, file_id))?\n+            .catch_canceled(|db| runnables::runnables(db, file_id))\n     }\n \n     /// Computes syntax highlighting for the given file.\n@@ -460,7 +462,7 @@ impl Analysis {\n \n     /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n-        self.with_db(|db| hover::type_of(db, frange))?\n+        self.with_db(|db| hover::type_of(db, frange))\n     }\n \n     /// Returns the edit required to rename reference at the position to the new"}, {"sha": "e94297fe386de9ab777f4d81d755c1f27e3346f1", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -1,19 +1,16 @@\n-use ra_db::{Cancelable, FilePosition};\n+use ra_db::FilePosition;\n \n use crate::{NavigationTarget, db::RootDatabase};\n \n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n-pub(crate) fn parent_module(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Vec<NavigationTarget>> {\n+pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {\n     let module = match hir::source_binder::module_from_position(db, position) {\n-        None => return Ok(Vec::new()),\n+        None => return Vec::new(),\n         Some(it) => it,\n     };\n     let nav = NavigationTarget::from_module_to_decl(db, module);\n-    Ok(vec![nav])\n+    vec![nav]\n }\n \n #[cfg(test)]"}, {"sha": "0f9f8deb3231422459524c06bff5c2701664cba9", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ba45c667454028c3e65769d6f63fb0f27c1ca8/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=05ba45c667454028c3e65769d6f63fb0f27c1ca8", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     TextRange, SyntaxNode,\n     ast::{self, AstNode, NameOwner, ModuleItemOwner},\n };\n-use ra_db::{Cancelable, SyntaxDatabase};\n+use ra_db::SyntaxDatabase;\n \n use crate::{db::RootDatabase, FileId};\n \n@@ -21,14 +21,13 @@ pub enum RunnableKind {\n     Bin,\n }\n \n-pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n+pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let source_file = db.source_file(file_id);\n-    let res = source_file\n+    source_file\n         .syntax()\n         .descendants()\n         .filter_map(|i| runnable(db, file_id, i))\n-        .collect();\n-    Ok(res)\n+        .collect()\n }\n \n fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Runnable> {"}]}