{"sha": "9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNjcxMTkwMTliNDhiMGMzYzZmYjQ0Y2QzY2JhYjY0YjJhMWE2YjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-25T00:47:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-25T00:47:28Z"}, "message": "Auto merge of #63873 - Centril:rollup-jgglypd, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #62744 (Refactor `TinyList::contains` and `len` to iterate instead of recurse)\n - #63813 (Do not suggest `.try_into()` on `i32::from(x)`)\n - #63833 (Suggest calling closure with resolved return type when appropriate)\n - #63839 (Ensure miri can do bit ops on pointer values)\n - #63854 (Modifies how Arg, Arm, Field, FieldPattern and Variant are visited)\n - #63859 (Don't unwrap the result of `span_to_snippet`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "be5fa33785bd8f04fb8b37e64e0cf2e26de26e2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be5fa33785bd8f04fb8b37e64e0cf2e26de26e2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "html_url": "https://github.com/rust-lang/rust/commit/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeba189cfb2cfc5c5898513352d4ca8f1df06e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeba189cfb2cfc5c5898513352d4ca8f1df06e05", "html_url": "https://github.com/rust-lang/rust/commit/eeba189cfb2cfc5c5898513352d4ca8f1df06e05"}, {"sha": "4d3d06ae53408536443f3a20507b3e96c1ea526a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3d06ae53408536443f3a20507b3e96c1ea526a", "html_url": "https://github.com/rust-lang/rust/commit/4d3d06ae53408536443f3a20507b3e96c1ea526a"}], "stats": {"total": 743, "additions": 436, "deletions": 307}, "files": [{"sha": "17bcb1d0859683af3106c08dce35a1a49c9cf6b4", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -154,20 +154,19 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'a Variant) {\n         let def = self.create_def(v.id,\n                                   DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n         self.with_parent(def, |this| {\n             if let Some(ctor_hir_id) = v.data.ctor_id() {\n                 this.create_def(ctor_hir_id, DefPathData::Ctor, v.span);\n             }\n-            visit::walk_variant(this, v, g, item_id)\n+            visit::walk_variant(this, v)\n         });\n     }\n \n-    fn visit_variant_data(&mut self, data: &'a VariantData, _: Ident,\n-                          _: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, data: &'a VariantData) {\n         for (index, field) in data.fields().iter().enumerate() {\n             let name = field.ident.map(|ident| ident.name)\n                 .unwrap_or_else(|| sym::integer(index));"}, {"sha": "8126db1429247c57d68148642fb642c24a9a9907", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -1040,13 +1040,13 @@ for LateContextAndPass<'a, 'tcx, T> {\n \n     fn visit_variant_data(&mut self,\n                         s: &'tcx hir::VariantData,\n-                        name: ast::Name,\n-                        g: &'tcx hir::Generics,\n-                        item_id: hir::HirId,\n+                        _: ast::Name,\n+                        _: &'tcx hir::Generics,\n+                        _: hir::HirId,\n                         _: Span) {\n-        lint_callback!(self, check_struct_def, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def, s);\n         hir_visit::walk_struct_def(self, s);\n-        lint_callback!(self, check_struct_def_post, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n@@ -1061,9 +1061,9 @@ for LateContextAndPass<'a, 'tcx, T> {\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            lint_callback!(cx, check_variant, v, g);\n+            lint_callback!(cx, check_variant, v);\n             hir_visit::walk_variant(cx, v, g, item_id);\n-            lint_callback!(cx, check_variant_post, v, g);\n+            lint_callback!(cx, check_variant_post, v);\n         })\n     }\n \n@@ -1214,18 +1214,13 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_fn_post, fk, decl, span, id);\n     }\n \n-    fn visit_variant_data(&mut self,\n-                        s: &'a ast::VariantData,\n-                        ident: ast::Ident,\n-                        g: &'a ast::Generics,\n-                        item_id: ast::NodeId,\n-                        _: Span) {\n-        run_early_pass!(self, check_struct_def, s, ident, g, item_id);\n+    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n+        run_early_pass!(self, check_struct_def, s);\n         if let Some(ctor_hir_id) = s.ctor_id() {\n             self.check_id(ctor_hir_id);\n         }\n         ast_visit::walk_struct_def(self, s);\n-        run_early_pass!(self, check_struct_def_post, s, ident, g, item_id);\n+        run_early_pass!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n@@ -1235,11 +1230,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(item_id, &v.attrs, |cx| {\n-            run_early_pass!(cx, check_variant, v, g);\n-            ast_visit::walk_variant(cx, v, g, item_id);\n-            run_early_pass!(cx, check_variant_post, v, g);\n+    fn visit_variant(&mut self, v: &'a ast::Variant) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            run_early_pass!(cx, check_variant, v);\n+            ast_visit::walk_variant(cx, v);\n+            run_early_pass!(cx, check_variant_post, v);\n         })\n     }\n "}, {"sha": "7e2707b98d50a655396044c2e6956022f94964e2", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -248,21 +248,11 @@ macro_rules! late_lint_methods {\n             fn check_trait_item_post(a: &$hir hir::TraitItem);\n             fn check_impl_item(a: &$hir hir::ImplItem);\n             fn check_impl_item_post(a: &$hir hir::ImplItem);\n-            fn check_struct_def(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n-            fn check_struct_def_post(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n+            fn check_struct_def(a: &$hir hir::VariantData);\n+            fn check_struct_def_post(a: &$hir hir::VariantData);\n             fn check_struct_field(a: &$hir hir::StructField);\n-            fn check_variant(a: &$hir hir::Variant, b: &$hir hir::Generics);\n-            fn check_variant_post(a: &$hir hir::Variant, b: &$hir hir::Generics);\n+            fn check_variant(a: &$hir hir::Variant);\n+            fn check_variant_post(a: &$hir hir::Variant);\n             fn check_lifetime(a: &$hir hir::Lifetime);\n             fn check_path(a: &$hir hir::Path, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n@@ -395,21 +385,11 @@ macro_rules! early_lint_methods {\n             fn check_trait_item_post(a: &ast::TraitItem);\n             fn check_impl_item(a: &ast::ImplItem);\n             fn check_impl_item_post(a: &ast::ImplItem);\n-            fn check_struct_def(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n-            fn check_struct_def_post(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n+            fn check_struct_def(a: &ast::VariantData);\n+            fn check_struct_def_post(a: &ast::VariantData);\n             fn check_struct_field(a: &ast::StructField);\n-            fn check_variant(a: &ast::Variant, b: &ast::Generics);\n-            fn check_variant_post(a: &ast::Variant, b: &ast::Generics);\n+            fn check_variant(a: &ast::Variant);\n+            fn check_variant_post(a: &ast::Variant);\n             fn check_lifetime(a: &ast::Lifetime);\n             fn check_path(a: &ast::Path, b: ast::NodeId);\n             fn check_attribute(a: &ast::Attribute);"}, {"sha": "f41fffe507d97f177b38c6097dab7660214e08db", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -385,7 +385,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n         match ty.sty {\n             ty::FnPtr(sig) => sig,\n-            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty),\n+            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty.sty),\n         }\n     }\n }"}, {"sha": "ea771d9f20f8b69a60068870ba93060854736233", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -20,7 +20,6 @@ pub struct TinyList<T: PartialEq> {\n }\n \n impl<T: PartialEq> TinyList<T> {\n-\n     #[inline]\n     pub fn new() -> TinyList<T> {\n         TinyList {\n@@ -60,20 +59,24 @@ impl<T: PartialEq> TinyList<T> {\n \n     #[inline]\n     pub fn contains(&self, data: &T) -> bool {\n-        if let Some(ref head) = self.head {\n-            head.contains(data)\n-        } else {\n-            false\n+        let mut elem = self.head.as_ref();\n+        while let Some(ref e) = elem {\n+            if &e.data == data {\n+                return true;\n+            }\n+            elem = e.next.as_ref().map(|e| &**e);\n         }\n+        false\n     }\n \n     #[inline]\n     pub fn len(&self) -> usize {\n-        if let Some(ref head) = self.head {\n-            head.len()\n-        } else {\n-            0\n+        let (mut elem, mut count) = (self.head.as_ref(), 0);\n+        while let Some(ref e) = elem {\n+            count += 1;\n+            elem = e.next.as_ref().map(|e| &**e);\n         }\n+        count\n     }\n }\n \n@@ -84,40 +87,13 @@ struct Element<T: PartialEq> {\n }\n \n impl<T: PartialEq> Element<T> {\n-\n     fn remove_next(&mut self, data: &T) -> bool {\n-        let new_next = if let Some(ref mut next) = self.next {\n-            if next.data != *data {\n-                return next.remove_next(data)\n-            } else {\n-                next.next.take()\n-            }\n-        } else {\n-            return false\n+        let new_next = match self.next {\n+            Some(ref mut next) if next.data == *data => next.next.take(),\n+            Some(ref mut next) => return next.remove_next(data),\n+            None => return false,\n         };\n-\n         self.next = new_next;\n-\n         true\n     }\n-\n-    fn len(&self) -> usize {\n-        if let Some(ref next) = self.next {\n-            1 + next.len()\n-        } else {\n-            1\n-        }\n-    }\n-\n-    fn contains(&self, data: &T) -> bool {\n-        if self.data == *data {\n-            return true\n-        }\n-\n-        if let Some(ref next) = self.next {\n-            next.contains(data)\n-        } else {\n-            false\n-        }\n-    }\n }"}, {"sha": "0142631590cc9af411574dbf2ab8835b47852754", "filename": "src/librustc_data_structures/tiny_list/tests.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n \n extern crate test;\n-use test::Bencher;\n+use test::{Bencher, black_box};\n \n #[test]\n fn test_contains_and_insert() {\n@@ -98,36 +98,59 @@ fn test_remove_single() {\n #[bench]\n fn bench_insert_empty(b: &mut Bencher) {\n     b.iter(|| {\n-        let mut list = TinyList::new();\n+        let mut list = black_box(TinyList::new());\n         list.insert(1);\n+        list\n     })\n }\n \n #[bench]\n fn bench_insert_one(b: &mut Bencher) {\n     b.iter(|| {\n-        let mut list = TinyList::new_single(0);\n+        let mut list = black_box(TinyList::new_single(0));\n         list.insert(1);\n+        list\n     })\n }\n \n+#[bench]\n+fn bench_contains_empty(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new()).contains(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_contains_unknown(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new_single(0)).contains(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_contains_one(b: &mut Bencher) {\n+    b.iter(|| {\n+        black_box(TinyList::new_single(1)).contains(&1)\n+    });\n+}\n+\n #[bench]\n fn bench_remove_empty(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new().remove(&1)\n+        black_box(TinyList::new()).remove(&1)\n     });\n }\n \n #[bench]\n fn bench_remove_unknown(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new_single(0).remove(&1)\n+        black_box(TinyList::new_single(0)).remove(&1)\n     });\n }\n \n #[bench]\n fn bench_remove_one(b: &mut Bencher) {\n     b.iter(|| {\n-        TinyList::new_single(1).remove(&1)\n+        black_box(TinyList::new_single(1)).remove(&1)\n     });\n }"}, {"sha": "d3c94060e274aec697824fa83b1d5073813cc468", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant) {\n         self.check_missing_docs_attrs(cx,\n                                       Some(v.id),\n                                       &v.attrs,"}, {"sha": "bb6119d0ff2aa0fbdb7eb701ebb148ea6d592456", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -146,7 +146,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant, _: &ast::Generics) {\n+    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant) {\n         self.check_case(cx, \"variant\", &v.ident);\n     }\n \n@@ -350,9 +350,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         &mut self,\n         cx: &LateContext<'_, '_>,\n         s: &hir::VariantData,\n-        _: ast::Name,\n-        _: &hir::Generics,\n-        _: hir::HirId,\n     ) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.ident);"}, {"sha": "f10ff71b15e6810a41e48f3ddb38823de3ad4284", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -415,20 +415,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             \"{:?}\",\n             move_place.ty(self.body, self.infcx.tcx).ty,\n         );\n-        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n-        let is_option = move_ty.starts_with(\"std::option::Option\");\n-        let is_result = move_ty.starts_with(\"std::result::Result\");\n-        if  is_option || is_result {\n-            err.span_suggestion(\n-                span,\n-                &format!(\"consider borrowing the `{}`'s content\", if is_option {\n-                    \"Option\"\n-                } else {\n-                    \"Result\"\n-                }),\n-                format!(\"{}.as_ref()\", snippet),\n-                Applicability::MaybeIncorrect,\n-            );\n+        if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+            let is_option = move_ty.starts_with(\"std::option::Option\");\n+            let is_result = move_ty.starts_with(\"std::result::Result\");\n+            if is_option || is_result {\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\"consider borrowing the `{}`'s content\", if is_option {\n+                        \"Option\"\n+                    } else {\n+                        \"Result\"\n+                    }),\n+                    format!(\"{}.as_ref()\", snippet),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         }\n         err\n     }\n@@ -439,19 +440,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'a>,\n         span: Span,\n     ) {\n-        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         match error {\n             GroupedMoveError::MovesFromPlace {\n                 mut binds_to,\n                 move_from,\n                 ..\n             } => {\n-                err.span_suggestion(\n-                    span,\n-                    \"consider borrowing here\",\n-                    format!(\"&{}\", snippet),\n-                    Applicability::Unspecified,\n-                );\n+                if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider borrowing here\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::Unspecified,\n+                    );\n+                }\n \n                 if binds_to.is_empty() {\n                     let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n@@ -517,27 +519,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ..\n                 }))\n             ) = bind_to.is_user_variable {\n-                let pat_snippet = self.infcx.tcx.sess.source_map()\n-                    .span_to_snippet(pat_span)\n-                    .unwrap();\n-                if pat_snippet.starts_with('&') {\n-                    let pat_snippet = pat_snippet[1..].trim_start();\n-                    let suggestion;\n-                    let to_remove;\n-                    if pat_snippet.starts_with(\"mut\")\n-                        && pat_snippet[\"mut\".len()..].starts_with(Pattern_White_Space)\n-                    {\n-                        suggestion = pat_snippet[\"mut\".len()..].trim_start();\n-                        to_remove = \"&mut\";\n-                    } else {\n-                        suggestion = pat_snippet;\n-                        to_remove = \"&\";\n+                if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n+                {\n+                    if pat_snippet.starts_with('&') {\n+                        let pat_snippet = pat_snippet[1..].trim_start();\n+                        let suggestion;\n+                        let to_remove;\n+                        if pat_snippet.starts_with(\"mut\")\n+                            && pat_snippet[\"mut\".len()..].starts_with(Pattern_White_Space)\n+                        {\n+                            suggestion = pat_snippet[\"mut\".len()..].trim_start();\n+                            to_remove = \"&mut\";\n+                        } else {\n+                            suggestion = pat_snippet;\n+                            to_remove = \"&\";\n+                        }\n+                        suggestions.push((\n+                            pat_span,\n+                            to_remove,\n+                            suggestion.to_owned(),\n+                        ));\n                     }\n-                    suggestions.push((\n-                        pat_span,\n-                        to_remove,\n-                        suggestion.to_owned(),\n-                    ));\n                 }\n             }\n         }"}, {"sha": "e7f37431e50092228df0ca00b0134b1a9d50086e", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -711,8 +711,8 @@ fn annotate_struct_field(\n }\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<(String)> {\n-    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();\n+fn suggest_ref_mut(tcx: TyCtxt<'_>, binding_span: Span) -> Option<String> {\n+    let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).ok()?;\n     if hi_src.starts_with(\"ref\")\n         && hi_src[\"ref\".len()..].starts_with(Pattern_White_Space)\n     {"}, {"sha": "334f1ea1a690140d639044bcc56421cdb0d77cc8", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -95,7 +95,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | \"bitreverse\" => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n+                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n                     _ => throw_unsup!(TypeNotPrimitive(ty)),\n@@ -149,7 +150,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         // term since the sign of the second term can be inferred from this and\n                         // the fact that the operation has overflowed (if either is 0 no\n                         // overflow can occur)\n-                        let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n+                        let first_term: u128 = self.force_bits(l.to_scalar()?, l.layout.size)?;\n                         let first_term_positive = first_term & (1 << (num_bits-1)) == 0;\n                         if first_term_positive {\n                             // Negative overflow not possible since the positive first term\n@@ -187,7 +188,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n-                    let r_val = r.to_scalar()?.to_bits(layout.size)?;\n+                    let r_val = self.force_bits(r.to_scalar()?, layout.size)?;\n                     throw_ub_format!(\"Overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n                 }\n                 self.write_scalar(val, dest)?;\n@@ -196,8 +197,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val_bits = self.read_scalar(args[0])?.to_bits(layout.size)?;\n-                let raw_shift_bits = self.read_scalar(args[1])?.to_bits(layout.size)?;\n+                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let val_bits = self.force_bits(val, layout.size)?;\n+                let raw_shift = self.read_scalar(args[1])?.not_undef()?;\n+                let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n                 let width_bits = layout.size.bits() as u128;\n                 let shift_bits = raw_shift_bits % width_bits;\n                 let inv_shift_bits = (width_bits - shift_bits) % width_bits;"}, {"sha": "b5aab992e3adb6f4e84750ea34987cd38bcdef3a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -629,11 +629,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // post-process\n         Ok(match *discr_kind {\n             layout::DiscriminantKind::Tag => {\n-                let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n-                    Ok(raw_discr) => raw_discr,\n-                    Err(_) =>\n-                        throw_unsup!(InvalidDiscriminant(raw_discr.erase_tag())),\n-                };\n+                let bits_discr = raw_discr\n+                    .not_undef()\n+                    .and_then(|raw_discr| self.force_bits(raw_discr, discr_val.layout.size))\n+                    .map_err(|_| err_unsup!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the layout discriminant"}, {"sha": "34a10de7de7fc045e130c0a899de01b1e8cf8c8a", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -144,11 +144,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size, self)?\n-        )?.to_bits(pointer_size)? as u64;\n+        )?.not_undef()?;\n+        let size = self.force_bits(size, pointer_size)? as u64;\n         let align = alloc.read_ptr_sized(\n             self,\n             vtable.offset(pointer_size * 2, self)?,\n-        )?.to_bits(pointer_size)? as u64;\n+        )?.not_undef()?;\n+        let align = self.force_bits(align, pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align).unwrap()))\n     }\n }"}, {"sha": "5b78727fdd5ad133fff2905eee7a35a299a63053", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -813,8 +813,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_poly_trait_ref(self, t, m);\n     }\n \n-    fn visit_variant_data(&mut self, s: &'a VariantData, _: Ident,\n-                          _: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &'a VariantData) {\n         self.with_banned_assoc_ty_bound(|this| visit::walk_struct_def(this, s))\n     }\n "}, {"sha": "7e03df5b75bdc38b2bd26ae9bb701ffb649f756e", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -334,12 +334,9 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_struct_field(self, s)\n     }\n \n-    fn visit_variant(&mut self,\n-                     v: &'v ast::Variant,\n-                     g: &'v ast::Generics,\n-                     item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'v ast::Variant) {\n         self.record(\"Variant\", Id::None, v);\n-        ast_visit::walk_variant(self, v, g, item_id)\n+        ast_visit::walk_variant(self, v)\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'v ast::Lifetime) {"}, {"sha": "61b9c2a15ba165f514df377aaa229ee6aa9bbaf2", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -799,12 +799,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// adjusted type of the expression, if successful.\n     /// Adjustments are only recorded if the coercion succeeded.\n     /// The expressions *must not* have any pre-existing adjustments.\n-    pub fn try_coerce(&self,\n-                      expr: &hir::Expr,\n-                      expr_ty: Ty<'tcx>,\n-                      target: Ty<'tcx>,\n-                      allow_two_phase: AllowTwoPhase)\n-                      -> RelateResult<'tcx, Ty<'tcx>> {\n+    pub fn try_coerce(\n+        &self,\n+        expr: &hir::Expr,\n+        expr_ty: Ty<'tcx>,\n+        target: Ty<'tcx>,\n+        allow_two_phase: AllowTwoPhase,\n+    ) -> RelateResult<'tcx, Ty<'tcx>> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n "}, {"sha": "0efc433341c1fa343586fb534a94de497b749845", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -587,6 +587,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return false;\n             }\n         }\n+        if let hir::ExprKind::Call(path, args) = &expr.node {\n+            if let (\n+                hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)),\n+                1,\n+            ) = (&path.node, args.len()) {\n+                // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n+                if let (\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)),\n+                    sym::from,\n+                ) = (&base_ty.node, path_segment.ident.name) {\n+                    if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n+                        match ident.name {\n+                            sym::i128 | sym::i64 | sym::i32 | sym::i16 | sym::i8 |\n+                            sym::u128 | sym::u64 | sym::u32 | sym::u16 | sym::u8 |\n+                            sym::isize | sym::usize\n+                            if base_ty_path.segments.len() == 1 => {\n+                                return false;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            }\n+        }\n \n         let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n         let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);"}, {"sha": "d92ce29f284593fc7a692b3d1641d2e5cef520e2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 77, "deletions": 53, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -3917,75 +3917,99 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) -> bool {\n-        match found.sty {\n-            ty::FnDef(..) | ty::FnPtr(_) => {}\n-            _ => return false,\n-        }\n         let hir = self.tcx.hir();\n+        let (def_id, sig) = match found.sty {\n+            ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n+            ty::Closure(def_id, substs) => {\n+                // We don't use `closure_sig` to account for malformed closures like\n+                // `|_: [_; continue]| {}` and instead we don't suggest anything.\n+                let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n+                (def_id, match closure_sig_ty.sty {\n+                    ty::FnPtr(sig) => sig,\n+                    _ => return false,\n+                })\n+            }\n+            _ => return false,\n+        };\n \n-        let sig = found.fn_sig(self.tcx);\n         let sig = self\n             .replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig)\n             .0;\n         let sig = self.normalize_associated_types_in(expr.span, &sig);\n-        if let Ok(_) = self.try_coerce(expr, sig.output(), expected, AllowTwoPhase::No) {\n+        if self.can_coerce(sig.output(), expected) {\n             let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n                 (String::new(), Applicability::MachineApplicable)\n             } else {\n                 (\"...\".to_string(), Applicability::HasPlaceholders)\n             };\n             let mut msg = \"call this function\";\n-            if let ty::FnDef(def_id, ..) = found.sty {\n-                match hir.get_if_local(def_id) {\n-                    Some(Node::Item(hir::Item {\n-                        node: ItemKind::Fn(.., body_id),\n-                        ..\n-                    })) |\n-                    Some(Node::ImplItem(hir::ImplItem {\n-                        node: hir::ImplItemKind::Method(_, body_id),\n-                        ..\n-                    })) |\n-                    Some(Node::TraitItem(hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(.., hir::TraitMethod::Provided(body_id)),\n-                        ..\n-                    })) => {\n-                        let body = hir.body(*body_id);\n-                        sugg_call = body.arguments.iter()\n-                            .map(|arg| match &arg.pat.node {\n-                                hir::PatKind::Binding(_, _, ident, None)\n-                                if ident.name != kw::SelfLower => ident.to_string(),\n-                                _ => \"_\".to_string(),\n-                            }).collect::<Vec<_>>().join(\", \");\n+            match hir.get_if_local(def_id) {\n+                Some(Node::Item(hir::Item {\n+                    node: ItemKind::Fn(.., body_id),\n+                    ..\n+                })) |\n+                Some(Node::ImplItem(hir::ImplItem {\n+                    node: hir::ImplItemKind::Method(_, body_id),\n+                    ..\n+                })) |\n+                Some(Node::TraitItem(hir::TraitItem {\n+                    node: hir::TraitItemKind::Method(.., hir::TraitMethod::Provided(body_id)),\n+                    ..\n+                })) => {\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body.arguments.iter()\n+                        .map(|arg| match &arg.pat.node {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                            if ident.name != kw::SelfLower => ident.to_string(),\n+                            _ => \"_\".to_string(),\n+                        }).collect::<Vec<_>>().join(\", \");\n+                }\n+                Some(Node::Expr(hir::Expr {\n+                    node: ExprKind::Closure(_, _, body_id, closure_span, _),\n+                    span: full_closure_span,\n+                    ..\n+                })) => {\n+                    if *full_closure_span == expr.span {\n+                        return false;\n                     }\n-                    Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n-                        sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                        match hir.as_local_hir_id(def_id).and_then(|hir_id| hir.def_kind(hir_id)) {\n-                            Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n-                                msg = \"instantiate this tuple variant\";\n-                            }\n-                            Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, _)) => {\n-                                msg = \"instantiate this tuple struct\";\n-                            }\n-                            _ => {}\n+                    err.span_label(*closure_span, \"closure defined here\");\n+                    msg = \"call this closure\";\n+                    let body = hir.body(*body_id);\n+                    sugg_call = body.arguments.iter()\n+                        .map(|arg| match &arg.pat.node {\n+                            hir::PatKind::Binding(_, _, ident, None)\n+                            if ident.name != kw::SelfLower => ident.to_string(),\n+                            _ => \"_\".to_string(),\n+                        }).collect::<Vec<_>>().join(\", \");\n+                }\n+                Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n+                    sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                    match hir.as_local_hir_id(def_id).and_then(|hir_id| hir.def_kind(hir_id)) {\n+                        Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n+                            msg = \"instantiate this tuple variant\";\n                         }\n+                        Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, _)) => {\n+                            msg = \"instantiate this tuple struct\";\n+                        }\n+                        _ => {}\n                     }\n-                    Some(Node::ForeignItem(hir::ForeignItem {\n-                        node: hir::ForeignItemKind::Fn(_, idents, _),\n-                        ..\n-                    })) |\n-                    Some(Node::TraitItem(hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n-                        ..\n-                    })) => sugg_call = idents.iter()\n-                            .map(|ident| if ident.name != kw::SelfLower {\n-                                ident.to_string()\n-                            } else {\n-                                \"_\".to_string()\n-                            }).collect::<Vec<_>>()\n-                            .join(\", \"),\n-                    _ => {}\n                 }\n-            };\n+                Some(Node::ForeignItem(hir::ForeignItem {\n+                    node: hir::ForeignItemKind::Fn(_, idents, _),\n+                    ..\n+                })) |\n+                Some(Node::TraitItem(hir::TraitItem {\n+                    node: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n+                    ..\n+                })) => sugg_call = idents.iter()\n+                        .map(|ident| if ident.name != kw::SelfLower {\n+                            ident.to_string()\n+                        } else {\n+                            \"_\".to_string()\n+                        }).collect::<Vec<_>>()\n+                        .join(\", \"),\n+                _ => {}\n+            }\n             if let Ok(code) = self.sess().source_map().span_to_snippet(expr.span) {\n                 err.span_suggestion(\n                     expr.span,"}, {"sha": "a6b56e4d5979f1bd01a62fd4c219b9f17b2f0b70", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -1209,9 +1209,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n     }\n \n-    fn visit_generic_params(&mut self, params: &mut Vec<ast::GenericParam>) {\n-        self.cfg.configure_generic_params(params);\n-        noop_visit_generic_params(params, self);\n+   fn flat_map_generic_param(\n+       &mut self,\n+       param: ast::GenericParam\n+    ) -> SmallVec<[ast::GenericParam; 1]>\n+    {\n+        let param = configure!(self, param);\n+        noop_flat_map_generic_param(param, self)\n     }\n \n     fn visit_attribute(&mut self, at: &mut ast::Attribute) {"}, {"sha": "414d234e4341929e0a82e8b2c9d09344545ce620", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 77, "deletions": 49, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -98,8 +98,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_fn_header(header, self);\n     }\n \n-    fn visit_struct_field(&mut self, sf: &mut StructField) {\n-        noop_visit_struct_field(sf, self);\n+    fn flat_map_struct_field(&mut self, sf: StructField) -> SmallVec<[StructField; 1]> {\n+        noop_flat_map_struct_field(sf, self)\n     }\n \n     fn visit_item_kind(&mut self, i: &mut ItemKind) {\n@@ -130,8 +130,8 @@ pub trait MutVisitor: Sized {\n         noop_flat_map_stmt(s, self)\n     }\n \n-    fn visit_arm(&mut self, a: &mut Arm) {\n-        noop_visit_arm(a, self);\n+    fn flat_map_arm(&mut self, arm: Arm) -> SmallVec<[Arm; 1]> {\n+        noop_flat_map_arm(arm, self)\n     }\n \n     fn visit_pat(&mut self, p: &mut P<Pat>) {\n@@ -174,8 +174,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_foreign_mod(nm, self);\n     }\n \n-    fn visit_variant(&mut self, v: &mut Variant) {\n-        noop_visit_variant(v, self);\n+    fn flat_map_variant(&mut self, v: Variant) -> SmallVec<[Variant; 1]>  {\n+        noop_flat_map_variant(v, self)\n     }\n \n     fn visit_ident(&mut self, i: &mut Ident) {\n@@ -225,8 +225,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_attribute(at, self);\n     }\n \n-    fn visit_arg(&mut self, a: &mut Arg) {\n-        noop_visit_arg(a, self);\n+    fn flat_map_arg(&mut self, arg: Arg) -> SmallVec<[Arg; 1]> {\n+        noop_flat_map_arg(arg, self)\n     }\n \n     fn visit_generics(&mut self, generics: &mut Generics) {\n@@ -245,12 +245,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_variant_data(vdata, self);\n     }\n \n-    fn visit_generic_param(&mut self, param: &mut GenericParam) {\n-        noop_visit_generic_param(param, self);\n-    }\n-\n-    fn visit_generic_params(&mut self, params: &mut Vec<GenericParam>) {\n-        noop_visit_generic_params(params, self);\n+    fn flat_map_generic_param(&mut self, param: GenericParam) -> SmallVec<[GenericParam; 1]> {\n+        noop_flat_map_generic_param(param, self)\n     }\n \n     fn visit_tt(&mut self, tt: &mut TokenTree) {\n@@ -277,8 +273,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_mt(mt, self);\n     }\n \n-    fn visit_field(&mut self, field: &mut Field) {\n-        noop_visit_field(field, self);\n+    fn flat_map_field(&mut self, f: Field) -> SmallVec<[Field; 1]> {\n+        noop_flat_map_field(f, self)\n     }\n \n     fn visit_where_clause(&mut self, where_clause: &mut WhereClause) {\n@@ -300,6 +296,10 @@ pub trait MutVisitor: Sized {\n     fn visit_span(&mut self, _sp: &mut Span) {\n         // Do nothing.\n     }\n+\n+    fn flat_map_field_pattern(&mut self, fp: FieldPat) -> SmallVec<[FieldPat; 1]> {\n+        noop_flat_map_field_pattern(fp, self)\n+    }\n }\n \n /// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n@@ -362,6 +362,26 @@ pub fn visit_method_sig<T: MutVisitor>(MethodSig { header, decl }: &mut MethodSi\n     vis.visit_fn_decl(decl);\n }\n \n+pub fn noop_flat_map_field_pattern<T: MutVisitor>(\n+    mut fp: FieldPat,\n+    vis: &mut T,\n+) -> SmallVec<[FieldPat; 1]> {\n+    let FieldPat {\n+        attrs,\n+        id,\n+        ident,\n+        is_shorthand: _,\n+        pat,\n+        span,\n+    } = &mut fp;\n+    vis.visit_id(id);\n+    vis.visit_ident(ident);\n+    vis.visit_pat(pat);\n+    vis.visit_span(span);\n+    visit_thin_attrs(attrs, vis);\n+    smallvec![fp]\n+}\n+\n pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n     let UseTree { prefix, kind, span } = use_tree;\n     vis.visit_path(prefix);\n@@ -382,16 +402,18 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arm<T: MutVisitor>(\n-    Arm { attrs, pats, guard, body, span, id }: &mut Arm,\n+pub fn noop_flat_map_arm<T: MutVisitor>(\n+    mut arm: Arm,\n     vis: &mut T,\n-) {\n+) -> SmallVec<[Arm; 1]> {\n+    let Arm { attrs, pats, guard, body, span, id } = &mut arm;\n     visit_attrs(attrs, vis);\n     vis.visit_id(id);\n     visit_vec(pats, |pat| vis.visit_pat(pat));\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n     vis.visit_expr(body);\n     vis.visit_span(span);\n+    smallvec![arm]\n }\n \n pub fn noop_visit_ty_constraint<T: MutVisitor>(\n@@ -425,7 +447,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n         }\n         TyKind::BareFn(bft) => {\n             let BareFnTy { unsafety: _, abi: _, generic_params, decl } = bft.deref_mut();\n-            vis.visit_generic_params(generic_params);\n+            generic_params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n             vis.visit_fn_decl(decl);\n         }\n         TyKind::Tup(tys) => visit_vec(tys, |ty| vis.visit_ty(ty)),\n@@ -455,14 +477,17 @@ pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis:\n     items.flat_map_in_place(|item| vis.flat_map_foreign_item(item));\n }\n \n-pub fn noop_visit_variant<T: MutVisitor>(variant: &mut Variant, vis: &mut T) {\n-    let Variant { ident, attrs, id, data, disr_expr, span } = variant;\n+pub fn noop_flat_map_variant<T: MutVisitor>(mut variant: Variant, vis: &mut T)\n+    -> SmallVec<[Variant; 1]>\n+{\n+    let Variant { ident, attrs, id, data, disr_expr, span } = &mut variant;\n     vis.visit_ident(ident);\n     visit_attrs(attrs, vis);\n     vis.visit_id(id);\n     vis.visit_variant_data(data);\n     visit_opt(disr_expr, |disr_expr| vis.visit_anon_const(disr_expr));\n     vis.visit_span(span);\n+    smallvec![variant]\n }\n \n pub fn noop_visit_ident<T: MutVisitor>(Ident { name: _, span }: &mut Ident, vis: &mut T) {\n@@ -562,12 +587,14 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arg<T: MutVisitor>(Arg { attrs, id, pat, span, ty }: &mut Arg, vis: &mut T) {\n+pub fn noop_flat_map_arg<T: MutVisitor>(mut arg: Arg, vis: &mut T) -> SmallVec<[Arg; 1]> {\n+    let Arg { attrs, id, pat, span, ty } = &mut arg;\n     vis.visit_id(id);\n     visit_thin_attrs(attrs, vis);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n     vis.visit_ty(ty);\n+    smallvec![arg]\n }\n \n pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n@@ -693,7 +720,7 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n \n pub fn noop_visit_fn_decl<T: MutVisitor>(decl: &mut P<FnDecl>, vis: &mut T) {\n     let FnDecl { inputs, output, c_variadic: _ } = decl.deref_mut();\n-    visit_vec(inputs, |input| vis.visit_arg(input));\n+    inputs.flat_map_in_place(|arg| vis.flat_map_arg(arg));\n     match output {\n         FunctionRetTy::Default(span) => vis.visit_span(span),\n         FunctionRetTy::Ty(ty) => vis.visit_ty(ty),\n@@ -707,8 +734,12 @@ pub fn noop_visit_param_bound<T: MutVisitor>(pb: &mut GenericBound, vis: &mut T)\n     }\n }\n \n-pub fn noop_visit_generic_param<T: MutVisitor>(param: &mut GenericParam, vis: &mut T) {\n-    let GenericParam { id, ident, attrs, bounds, kind } = param;\n+pub fn noop_flat_map_generic_param<T: MutVisitor>(\n+    mut param: GenericParam,\n+    vis: &mut T\n+) -> SmallVec<[GenericParam; 1]>\n+{\n+    let GenericParam { id, ident, attrs, bounds, kind } = &mut param;\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n     visit_thin_attrs(attrs, vis);\n@@ -722,10 +753,7 @@ pub fn noop_visit_generic_param<T: MutVisitor>(param: &mut GenericParam, vis: &m\n             vis.visit_ty(ty);\n         }\n     }\n-}\n-\n-pub fn noop_visit_generic_params<T: MutVisitor>(params: &mut Vec<GenericParam>, vis: &mut T){\n-    visit_vec(params, |param| vis.visit_generic_param(param));\n+    smallvec![param]\n }\n \n pub fn noop_visit_label<T: MutVisitor>(Label { ident }: &mut Label, vis: &mut T) {\n@@ -739,7 +767,7 @@ fn noop_visit_lifetime<T: MutVisitor>(Lifetime { id, ident }: &mut Lifetime, vis\n \n pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T) {\n     let Generics { params, where_clause, span } = generics;\n-    vis.visit_generic_params(params);\n+    params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n     vis.visit_where_clause(where_clause);\n     vis.visit_span(span);\n }\n@@ -755,7 +783,7 @@ pub fn noop_visit_where_predicate<T: MutVisitor>(pred: &mut WherePredicate, vis:\n         WherePredicate::BoundPredicate(bp) => {\n             let WhereBoundPredicate { span, bound_generic_params, bounded_ty, bounds } = bp;\n             vis.visit_span(span);\n-            vis.visit_generic_params(bound_generic_params);\n+            bound_generic_params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n             vis.visit_ty(bounded_ty);\n             visit_vec(bounds, |bound| vis.visit_param_bound(bound));\n         }\n@@ -777,9 +805,11 @@ pub fn noop_visit_where_predicate<T: MutVisitor>(pred: &mut WherePredicate, vis:\n \n pub fn noop_visit_variant_data<T: MutVisitor>(vdata: &mut VariantData, vis: &mut T) {\n     match vdata {\n-        VariantData::Struct(fields, ..) => visit_vec(fields, |field| vis.visit_struct_field(field)),\n+        VariantData::Struct(fields, ..) => {\n+            fields.flat_map_in_place(|field| vis.flat_map_struct_field(field));\n+        },\n         VariantData::Tuple(fields, id) => {\n-            visit_vec(fields, |field| vis.visit_struct_field(field));\n+            fields.flat_map_in_place(|field| vis.flat_map_struct_field(field));\n             vis.visit_id(id);\n         },\n         VariantData::Unit(id) => vis.visit_id(id),\n@@ -793,28 +823,32 @@ pub fn noop_visit_trait_ref<T: MutVisitor>(TraitRef { path, ref_id }: &mut Trait\n \n pub fn noop_visit_poly_trait_ref<T: MutVisitor>(p: &mut PolyTraitRef, vis: &mut T) {\n     let PolyTraitRef { bound_generic_params, trait_ref, span } = p;\n-    vis.visit_generic_params(bound_generic_params);\n+    bound_generic_params.flat_map_in_place(|param| vis.flat_map_generic_param(param));\n     vis.visit_trait_ref(trait_ref);\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_struct_field<T: MutVisitor>(f: &mut StructField, visitor: &mut T) {\n-    let StructField { span, ident, vis, id, ty, attrs } = f;\n+pub fn noop_flat_map_struct_field<T: MutVisitor>(mut sf: StructField, visitor: &mut T)\n+    -> SmallVec<[StructField; 1]>\n+{\n+    let StructField { span, ident, vis, id, ty, attrs } = &mut sf;\n     visitor.visit_span(span);\n     visit_opt(ident, |ident| visitor.visit_ident(ident));\n     visitor.visit_vis(vis);\n     visitor.visit_id(id);\n     visitor.visit_ty(ty);\n     visit_attrs(attrs, visitor);\n+    smallvec![sf]\n }\n \n-pub fn noop_visit_field<T: MutVisitor>(f: &mut Field, vis: &mut T) {\n-    let Field { ident, expr, span, is_shorthand: _, attrs, id } = f;\n+pub fn noop_flat_map_field<T: MutVisitor>(mut f: Field, vis: &mut T) -> SmallVec<[Field; 1]> {\n+    let Field { ident, expr, span, is_shorthand: _, attrs, id } = &mut f;\n     vis.visit_ident(ident);\n     vis.visit_expr(expr);\n     vis.visit_id(id);\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n+    smallvec![f]\n }\n \n pub fn noop_visit_mt<T: MutVisitor>(MutTy { ty, mutbl: _ }: &mut MutTy, vis: &mut T) {\n@@ -858,7 +892,7 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_generics(generics);\n         }\n         ItemKind::Enum(EnumDef { variants }, generics) => {\n-            visit_vec(variants, |variant| vis.visit_variant(variant));\n+            variants.flat_map_in_place(|variant| vis.flat_map_variant(variant));\n             vis.visit_generics(generics);\n         }\n         ItemKind::Struct(variant_data, generics) |\n@@ -1042,13 +1076,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         }\n         PatKind::Struct(path, fields, _etc) => {\n             vis.visit_path(path);\n-            for FieldPat { ident, pat, is_shorthand: _, attrs, id, span } in fields {\n-                vis.visit_ident(ident);\n-                vis.visit_id(id);\n-                vis.visit_pat(pat);\n-                visit_thin_attrs(attrs, vis);\n-                vis.visit_span(span);\n-            };\n+            fields.flat_map_in_place(|field| vis.flat_map_field_pattern(field));\n         }\n         PatKind::Box(inner) => vis.visit_pat(inner),\n         PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n@@ -1130,7 +1158,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n         }\n         ExprKind::Match(expr, arms) => {\n             vis.visit_expr(expr);\n-            visit_vec(arms, |arm| vis.visit_arm(arm));\n+            arms.flat_map_in_place(|arm| vis.flat_map_arm(arm));\n         }\n         ExprKind::Closure(_capture_by, asyncness, _movability, decl, body, span) => {\n             vis.visit_asyncness(asyncness);\n@@ -1193,7 +1221,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n         ExprKind::Mac(mac) => vis.visit_mac(mac),\n         ExprKind::Struct(path, fields, expr) => {\n             vis.visit_path(path);\n-            visit_vec(fields, |field| vis.visit_field(field));\n+            fields.flat_map_in_place(|field| vis.flat_map_field(field));\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         },\n         ExprKind::Paren(expr) => {"}, {"sha": "a64fec7096132303f403d2edda33f05674fa949f", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -93,8 +93,7 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &VariantData, _: Ident,\n-                          _: &Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &VariantData) {\n         self.count += 1;\n         walk_struct_def(self, s)\n     }\n@@ -107,9 +106,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &Variant) {\n         self.count += 1;\n-        walk_variant(self, v, g, item_id)\n+        walk_variant(self, v)\n     }\n     fn visit_lifetime(&mut self, lifetime: &Lifetime) {\n         self.count += 1;"}, {"sha": "86f6d36c3c6ba53ab7d8bd98fda70e161d65c1e8", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -92,17 +92,16 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n-    fn visit_variant_data(&mut self, s: &'ast VariantData, _: Ident,\n-                          _: &'ast Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &'ast VariantData) {\n         walk_struct_def(self, s)\n     }\n     fn visit_struct_field(&mut self, s: &'ast StructField) { walk_struct_field(self, s) }\n     fn visit_enum_def(&mut self, enum_definition: &'ast EnumDef,\n                       generics: &'ast Generics, item_id: NodeId, _: Span) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) {\n-        walk_variant(self, v, g, item_id)\n+    fn visit_variant(&mut self, v: &'ast Variant) {\n+        walk_variant(self, v)\n     }\n     fn visit_label(&mut self, label: &'ast Label) {\n         walk_label(self, label)\n@@ -163,6 +162,12 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_fn_header(&mut self, _header: &'ast FnHeader) {\n         // Nothing to do\n     }\n+    fn visit_field(&mut self, f: &'ast Field) {\n+        walk_field(self, f)\n+    }\n+    fn visit_field_pattern(&mut self, fp: &'ast FieldPat) {\n+        walk_field_pattern(self, fp)\n+    }\n }\n \n #[macro_export]\n@@ -280,8 +285,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         ItemKind::Struct(ref struct_definition, ref generics) |\n         ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_variant_data(struct_definition, item.ident,\n-                                     generics, item.id, item.span);\n+            visitor.visit_variant_data(struct_definition);\n         }\n         ItemKind::Trait(.., ref generics, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n@@ -300,24 +304,32 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n \n pub fn walk_enum_def<'a, V: Visitor<'a>>(visitor: &mut V,\n                                  enum_definition: &'a EnumDef,\n-                                 generics: &'a Generics,\n-                                 item_id: NodeId) {\n-    walk_list!(visitor, visit_variant, &enum_definition.variants, generics, item_id);\n+                                 _: &'a Generics,\n+                                 _: NodeId) {\n+    walk_list!(visitor, visit_variant, &enum_definition.variants);\n }\n \n-pub fn walk_variant<'a, V>(visitor: &mut V,\n-                           variant: &'a Variant,\n-                           generics: &'a Generics,\n-                           item_id: NodeId)\n+pub fn walk_variant<'a, V: Visitor<'a>>(visitor: &mut V, variant: &'a Variant)\n     where V: Visitor<'a>,\n {\n     visitor.visit_ident(variant.ident);\n-    visitor.visit_variant_data(&variant.data, variant.ident,\n-                             generics, item_id, variant.span);\n+    visitor.visit_variant_data(&variant.data);\n     walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n+pub fn walk_field<'a, V: Visitor<'a>>(visitor: &mut V, f: &'a Field) {\n+    visitor.visit_expr(&f.expr);\n+    visitor.visit_ident(f.ident);\n+    walk_list!(visitor, visit_attribute, f.attrs.iter());\n+}\n+\n+pub fn walk_field_pattern<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a FieldPat) {\n+    visitor.visit_ident(fp.ident);\n+    visitor.visit_pat(&fp.pat);\n+    walk_list!(visitor, visit_attribute, fp.attrs.iter());\n+}\n+\n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n     match typ.node {\n         TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => {\n@@ -441,11 +453,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n         }\n         PatKind::Struct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n-            for field in fields {\n-                walk_list!(visitor, visit_attribute, field.attrs.iter());\n-                visitor.visit_ident(field.ident);\n-                visitor.visit_pat(&field.pat)\n-            }\n+            walk_list!(visitor, visit_field_pattern, fields);\n         }\n         PatKind::Box(ref subpattern) |\n         PatKind::Ref(ref subpattern, _) |\n@@ -686,11 +694,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n-            for field in fields {\n-                walk_list!(visitor, visit_attribute, field.attrs.iter());\n-                visitor.visit_ident(field.ident);\n-                visitor.visit_expr(&field.expr)\n-            }\n+            walk_list!(visitor, visit_field, fields);\n             walk_list!(visitor, visit_expr, optional_base);\n         }\n         ExprKind::Tup(ref subexpressions) => {"}, {"sha": "c77f6c8276e7064fa230582a12566f7870eb07c9", "filename": "src/test/ui/borrowck/move-error-snippets-ext.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets-ext.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -0,0 +1,7 @@\n+// ignore-test\n+\n+macro_rules! aaa {\n+    ($c:ident) => {{\n+        let a = $c;\n+    }}\n+}"}, {"sha": "64f9565382886d3ac355f905881ec8ea18720c35", "filename": "src/test/ui/borrowck/move-error-snippets.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -0,0 +1,23 @@\n+// Test that we don't ICE after trying to construct a cross-file snippet #63800.\n+\n+// compile-flags: --test\n+\n+#[macro_use]\n+#[path = \"move-error-snippets-ext.rs\"]\n+mod move_error_snippets_ext;\n+\n+struct A;\n+\n+macro_rules! sss {\n+    () => {\n+        #[test]\n+        fn fff() {\n+            static D: A = A;\n+            aaa!(D);         //~ ERROR cannot move\n+        }\n+    };\n+}\n+\n+sss!();\n+\n+fn main() {}"}, {"sha": "77463c48591bc101388e25eb659662514dc692de", "filename": "src/test/ui/borrowck/move-error-snippets.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -0,0 +1,15 @@\n+error[E0507]: cannot move out of static item `D`\n+  --> $DIR/move-error-snippets.rs:16:18\n+   |\n+LL | | #[macro_use]\n+   | |__________________^ move occurs because `D` has type `A`, which does not implement the `Copy` trait\n+...\n+LL |               aaa!(D);\n+   |  __________________^\n+...\n+LL |   sss!();\n+   |   ------- in this macro invocation\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0507`."}, {"sha": "dd5af3e344cabd1ffeb8dae4edc204b5883c48d9", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -42,4 +42,6 @@ fn main() {\n     let _: usize = X::bal; //~ ERROR mismatched types\n     let _: usize = X.ban; //~ ERROR attempted to take value of method\n     let _: usize = X.bal; //~ ERROR attempted to take value of method\n+    let closure = || 42;\n+    let _: usize = closure; //~ ERROR mismatched types\n }"}, {"sha": "28b331bdbdcbc468e69b48cd50845d93993e9295", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -214,7 +214,21 @@ error[E0615]: attempted to take value of method `bal` on type `X`\n LL |     let _: usize = X.bal;\n    |                      ^^^ help: use parentheses to call the method: `bal()`\n \n-error: aborting due to 16 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/fn-or-tuple-struct-without-args.rs:46:20\n+   |\n+LL |     let closure = || 42;\n+   |                   -- closure defined here\n+LL |     let _: usize = closure;\n+   |                    ^^^^^^^\n+   |                    |\n+   |                    expected usize, found closure\n+   |                    help: use parentheses to call this closure: `closure()`\n+   |\n+   = note: expected type `usize`\n+              found type `[closure@$DIR/fn-or-tuple-struct-without-args.rs:45:19: 45:24]`\n+\n+error: aborting due to 17 previous errors\n \n Some errors have detailed explanations: E0308, E0423, E0615.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "56549da9c7358b694ad351d442b97ab0de665003", "filename": "src/test/ui/suggestions/mismatched-types-numeric-from.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Fmismatched-types-numeric-from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Fmismatched-types-numeric-from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmismatched-types-numeric-from.rs?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _: u32 = i32::from(0_u8); //~ ERROR mismatched types\n+}"}, {"sha": "223b6747322c14bf061bba5e510a31881b2499d1", "filename": "src/test/ui/suggestions/mismatched-types-numeric-from.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Fmismatched-types-numeric-from.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5/src%2Ftest%2Fui%2Fsuggestions%2Fmismatched-types-numeric-from.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmismatched-types-numeric-from.stderr?ref=9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/mismatched-types-numeric-from.rs:2:18\n+   |\n+LL |     let _: u32 = i32::from(0_u8);\n+   |                  ^^^^^^^^^^^^^^^ expected u32, found i32\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}