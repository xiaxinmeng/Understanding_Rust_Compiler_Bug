{"sha": "c2946402ffb5edde461b5047213e56b4e1500ec8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOTQ2NDAyZmZiNWVkZGU0NjFiNTA0NzIxM2U1NmI0ZTE1MDBlYzg=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-12-04T23:37:21Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-12-05T03:16:40Z"}, "message": "Properly re-use def path hash in incremental mode\n\nFixes #79661\n\nIn incremental compilation mode, we update a `DefPathHash -> DefId`\nmapping every time we create a `DepNode` for a foreign `DefId`.\nThis mapping is written out to the on-disk incremental cache, and is\nread by the next compilation session to allow us to lazily decode\n`DefId`s.\n\nWhen we decode a `DepNode` from the current incremental cache, we need\nto ensure that any previously-recorded `DefPathHash -> DefId` mapping\ngets recorded in the new mapping that we write out. However, PR #74967\ndidn't do this in all cases, leading to us being unable to decode a\n`DefPathHash` in certain circumstances.\n\nThis PR refactors some of the code around `DepNode` deserialization to\nprevent this kind of mistake from happening again.", "tree": {"sha": "6934b4679aa914e0633f30142979289e82f51032", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6934b4679aa914e0633f30142979289e82f51032"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2946402ffb5edde461b5047213e56b4e1500ec8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl/K+6MACgkQtAh+UQ6Y\nsWT42Q/+PtZzPTEgzJxl4FG5Yz97VmobdF3j7A3ShldMlhNWuZzPdUr7ocisoErm\nevfBYw5O/AsjF/b1AIZvYi1dBrDYR4UNMQbZ0QFrPcENSyOIGzCpRi2zCeV05nhG\nWUJIlXv9SsyP5FXKTYhg3v1jcyxJ9Ih94h+DnvpofvRFaN7cSM8zlk5GlWLxXSym\nFoCCUmqwuQXuMk2vHv+TgBNIHRkqxhdNCF6dfECVpkHO6pCHDcHZ/gUPs5pTXKWP\no4bSTg/kIYTSG1G2oeuNbdNME6y3qTHY6QEW0s8kZVTrqgQIQIa4ayIB/DplYTcH\nUsziR9tn99rAXfzZ4kYLKnuRWWlyH7JxvzOmNv8EWw4KyPQ7IMg7CdVUTzVKnaMv\n5PYAjpj9rnF4vo8DsoM9cFBkfSAjXd6Y24JJb/sBbG2mLDkvIQSRlg1HY8Aeci8l\nXCKvFUhaBLqITdlXpWm0I6MIi0kDS85rt0geY2rRqerd3Za2XO4Oh55nz+r2Ux50\n5CqUB1Lm3jzzJPCwH4lM0frZU9Yy2nASgFBh0H4nFxlSJnodL4CdTjQQBfQ7h/ji\npey9Raj2vuesX6/7P7HVd7+Y9Dat2DeNY3I5qEo5UTa5AtqDRkhq/OVG4WqhICOs\nojmLU2DTNz/y6bmy1NGfo97I20jgtBfKmnbXorBfVD6WwSNQmqg=\n=WL++\n-----END PGP SIGNATURE-----", "payload": "tree 6934b4679aa914e0633f30142979289e82f51032\nparent 3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a\nauthor Aaron Hill <aa1ronham@gmail.com> 1607125041 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1607138200 -0500\n\nProperly re-use def path hash in incremental mode\n\nFixes #79661\n\nIn incremental compilation mode, we update a `DefPathHash -> DefId`\nmapping every time we create a `DepNode` for a foreign `DefId`.\nThis mapping is written out to the on-disk incremental cache, and is\nread by the next compilation session to allow us to lazily decode\n`DefId`s.\n\nWhen we decode a `DepNode` from the current incremental cache, we need\nto ensure that any previously-recorded `DefPathHash -> DefId` mapping\ngets recorded in the new mapping that we write out. However, PR #74967\ndidn't do this in all cases, leading to us being unable to decode a\n`DefPathHash` in certain circumstances.\n\nThis PR refactors some of the code around `DepNode` deserialization to\nprevent this kind of mistake from happening again.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2946402ffb5edde461b5047213e56b4e1500ec8", "html_url": "https://github.com/rust-lang/rust/commit/c2946402ffb5edde461b5047213e56b4e1500ec8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2946402ffb5edde461b5047213e56b4e1500ec8/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a", "html_url": "https://github.com/rust-lang/rust/commit/3ff10e74a74ed093fcabac1de27fe1cd65bbbb4a"}], "stats": {"total": 99, "additions": 79, "deletions": 20}, "files": [{"sha": "b269dd09b72eae0721aa887e62a67d114f448886", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=c2946402ffb5edde461b5047213e56b4e1500ec8", "patch": "@@ -220,7 +220,7 @@ pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &De\n                                          .map(|c| c.is_green())\n                                          .unwrap_or(false));\n \n-                        let key = <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node).unwrap();\n+                        let key = <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n                         if queries::$name::cache_on_disk(tcx, &key, None) {\n                             let _ = tcx.$name(key);\n                         }"}, {"sha": "09e5dc857a7511320e552b7f5c40ade65b0b1636", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=c2946402ffb5edde461b5047213e56b4e1500ec8", "patch": "@@ -53,6 +53,19 @@ use std::hash::Hash;\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub struct DepNode<K> {\n     pub kind: K,\n+    // Important - whenever a `DepNode` is constructed, we need to make\n+    // sure to register a `DefPathHash -> DefId` mapping if needed.\n+    // This is currently done in two places:\n+    //\n+    // * When a `DepNode::construct` is called, `arg.to_fingerprint()`\n+    //   is responsible for calling `OnDiskCache::store_foreign_def_id_hash`\n+    //   if needed\n+    // * When a `DepNode` is loaded from the `PreviousDepGraph`,\n+    //   then `PreviousDepGraph::index_to_node` is responsible for calling\n+    //   `tcx.register_reused_dep_path_hash`\n+    //\n+    // FIXME: Enforce this by preventing manual construction of `DefNode`\n+    // (e.g. add a `_priv: ()` field)\n     pub hash: PackedFingerprint,\n }\n "}, {"sha": "8bde552e2d49a33a7c9c75a087db15c3b84db005", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=c2946402ffb5edde461b5047213e56b4e1500ec8", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_span::def_id::DefPathHash;\n \n use parking_lot::{Condvar, Mutex};\n use smallvec::{smallvec, SmallVec};\n@@ -555,7 +554,7 @@ impl<K: DepKind> DepGraph<K> {\n         // We never try to mark eval_always nodes as green\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n-        debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n+        data.previous.debug_assert_eq(prev_dep_node_index, *dep_node);\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n@@ -573,7 +572,7 @@ impl<K: DepKind> DepGraph<K> {\n                         \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n                             be immediately green\",\n                         dep_node,\n-                        data.previous.index_to_node(dep_dep_node_index)\n+                        data.previous.debug_dep_node(dep_dep_node_index),\n                     );\n                     current_deps.push(node_index);\n                 }\n@@ -586,12 +585,12 @@ impl<K: DepKind> DepGraph<K> {\n                         \"try_mark_previous_green({:?}) - END - dependency {:?} was \\\n                             immediately red\",\n                         dep_node,\n-                        data.previous.index_to_node(dep_dep_node_index)\n+                        data.previous.debug_dep_node(dep_dep_node_index)\n                     );\n                     return None;\n                 }\n                 None => {\n-                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index, tcx);\n \n                     // We don't know the state of this dependency. If it isn't\n                     // an eval_always node, let's try to mark it green recursively.\n@@ -700,18 +699,6 @@ impl<K: DepKind> DepGraph<K> {\n             data.current.intern_node(*dep_node, current_deps, fingerprint)\n         };\n \n-        // We have just loaded a deserialized `DepNode` from the previous\n-        // compilation session into the current one. If this was a foreign `DefId`,\n-        // then we stored additional information in the incr comp cache when we\n-        // initially created its fingerprint (see `DepNodeParams::to_fingerprint`)\n-        // We won't be calling `to_fingerprint` again for this `DepNode` (we no longer\n-        // have the original value), so we need to copy over this additional information\n-        // from the old incremental cache into the new cache that we serialize\n-        // and the end of this compilation session.\n-        if dep_node.kind.can_reconstruct_query_key() {\n-            tcx.register_reused_dep_path_hash(DefPathHash(dep_node.hash.into()));\n-        }\n-\n         // ... emitting any stored diagnostic ...\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n@@ -814,7 +801,7 @@ impl<K: DepKind> DepGraph<K> {\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n-                    let dep_node = data.previous.index_to_node(prev_index);\n+                    let dep_node = data.previous.index_to_node(prev_index, tcx);\n                     tcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {"}, {"sha": "9298b652da2d04c142105701271106c24a7ab93b", "filename": "compiler/rustc_query_system/src/dep_graph/prev.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2946402ffb5edde461b5047213e56b4e1500ec8/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs?ref=c2946402ffb5edde461b5047213e56b4e1500ec8", "patch": "@@ -1,7 +1,9 @@\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n use super::{DepKind, DepNode};\n+use crate::dep_graph::DepContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::def_id::DefPathHash;\n \n #[derive(Debug, Encodable, Decodable)]\n pub struct PreviousDepGraph<K: DepKind> {\n@@ -31,7 +33,44 @@ impl<K: DepKind> PreviousDepGraph<K> {\n     }\n \n     #[inline]\n-    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode<K> {\n+    pub fn index_to_node<CTX: DepContext<DepKind = K>>(\n+        &self,\n+        dep_node_index: SerializedDepNodeIndex,\n+        tcx: CTX,\n+    ) -> DepNode<K> {\n+        let dep_node = self.data.nodes[dep_node_index];\n+        // We have just loaded a deserialized `DepNode` from the previous\n+        // compilation session into the current one. If this was a foreign `DefId`,\n+        // then we stored additional information in the incr comp cache when we\n+        // initially created its fingerprint (see `DepNodeParams::to_fingerprint`)\n+        // We won't be calling `to_fingerprint` again for this `DepNode` (we no longer\n+        // have the original value), so we need to copy over this additional information\n+        // from the old incremental cache into the new cache that we serialize\n+        // and the end of this compilation session.\n+        if dep_node.kind.can_reconstruct_query_key() {\n+            tcx.register_reused_dep_path_hash(DefPathHash(dep_node.hash.into()));\n+        }\n+        dep_node\n+    }\n+\n+    /// When debug assertions are enabled, asserts that the dep node at `dep_node_index` is equal to `dep_node`.\n+    /// This method should be preferred over manually calling `index_to_node`.\n+    /// Calls to `index_to_node` may affect global state, so gating a call\n+    /// to `index_to_node` on debug assertions could cause behavior changes when debug assertions\n+    /// are enabled.\n+    #[inline]\n+    pub fn debug_assert_eq(&self, dep_node_index: SerializedDepNodeIndex, dep_node: DepNode<K>) {\n+        debug_assert_eq!(self.data.nodes[dep_node_index], dep_node);\n+    }\n+\n+    /// Obtains a debug-printable version of the `DepNode`.\n+    /// See `debug_assert_eq` for why this should be preferred over manually\n+    /// calling `dep_node_index`\n+    pub fn debug_dep_node(&self, dep_node_index: SerializedDepNodeIndex) -> impl std::fmt::Debug {\n+        // We're returning the `DepNode` without calling `register_reused_dep_path_hash`,\n+        // but `impl Debug` return type means that it can only be used for debug printing.\n+        // So, there's no risk of calls trying to create new dep nodes that have this\n+        // node as a dependency\n         self.data.nodes[dep_node_index]\n     }\n "}, {"sha": "cd32a52ebfd21bd653421734b45883adb5f7c7a5", "filename": "src/test/incremental/auxiliary/issue-79661.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2946402ffb5edde461b5047213e56b4e1500ec8/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-79661.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2946402ffb5edde461b5047213e56b4e1500ec8/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-79661.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fauxiliary%2Fissue-79661.rs?ref=c2946402ffb5edde461b5047213e56b4e1500ec8", "patch": "@@ -0,0 +1,6 @@\n+#![feature(rustc_attrs)]\n+\n+#[cfg_attr(any(rpass2, rpass3), doc = \"Some comment\")]\n+pub struct Foo;\n+\n+pub struct Wrapper(Foo);"}, {"sha": "f86fb33fbf68043808c2cbaa824c478ebc037a01", "filename": "src/test/incremental/issue-79661-missing-def-path-hash.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2946402ffb5edde461b5047213e56b4e1500ec8/src%2Ftest%2Fincremental%2Fissue-79661-missing-def-path-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2946402ffb5edde461b5047213e56b4e1500ec8/src%2Ftest%2Fincremental%2Fissue-79661-missing-def-path-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-79661-missing-def-path-hash.rs?ref=c2946402ffb5edde461b5047213e56b4e1500ec8", "patch": "@@ -0,0 +1,14 @@\n+// aux-build:issue-79661.rs\n+// revisions: rpass1 rpass2 rpass3\n+\n+// Regression test for issue #79661\n+// We were failing to copy over a DefPathHash->DefId mapping\n+// from the old incremental cache to the new incremental cache\n+// when we ended up forcing a query. As a result, a subsequent\n+// unchanged incremental run would crash due to the missing mapping\n+\n+extern crate issue_79661;\n+use issue_79661::Wrapper;\n+\n+pub struct Outer(Wrapper);\n+fn main() {}"}]}