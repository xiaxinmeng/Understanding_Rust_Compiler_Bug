{"sha": "91db9dcf3730207f63b3dfc33b2c438a769b7517", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZGI5ZGNmMzczMDIwN2Y2M2IzZGZjMzNiMmM0MzhhNzY5Yjc1MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-04T15:00:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-04T15:00:13Z"}, "message": "Auto merge of #49870 - pnkfelix:issue-27282-immut-borrow-all-pat-ids-in-guards, r=nikomatsakis\n\nImmutably and implicitly borrow all pattern ids for their guards (NLL only)\n\nThis is an important piece of rust-lang/rust#27282.\n\nIt applies only to NLL mode. It is a change to MIR codegen that is currently toggled on only when NLL is turned on. It thus affect MIR-borrowck but not the earlier static analyses (such as the type checker).\n\nThis change makes it so that any pattern bindings of type T for a match arm will map to a `&T` within the context of the guard expression for that arm, but will continue to map to a `T` in the context of the arm body.\n\nTo avoid surfacing this type distinction in the user source code (which would be a severe change to the language and would also require far more revision to the compiler internals), any occurrence of such an identifier in the guard expression will automatically get a deref op applied to it.\n\nSo an input like:\n```rust\nlet place = (1, Foo::new());\nmatch place {\n  (1, foo) if inspect(foo) => feed(foo),\n  ...\n}\n```\nwill be treated as if it were really something like:\n ```rust\nlet place = (1, Foo::new());\nmatch place {\n    (1, Foo { .. }) if { let tmp1 = &place.1; inspect(*tmp1) }\n                    => { let tmp2 = place.1; feed(tmp2) },\n    ...\n}\n```\n\nAnd an input like:\n```rust\nlet place = (2, Foo::new());\nmatch place {\n    (2, ref mut foo) if inspect(foo) => feed(foo),\n    ...\n}\n```\nwill be treated as if it were really something like:\n\n```rust\nlet place = (2, Foo::new());\nmatch place {\n    (2, Foo { .. }) if { let tmp1 = & &mut place.1; inspect(*tmp1) }\n                    => { let tmp2 = &mut place.1; feed(tmp2) },\n    ...\n}\n```\n\nIn short, any pattern binding will always look like *some* kind of `&T` within the guard at least in terms of how the MIR-borrowck views it, and this will ensure that guard expressions cannot mutate their the match inputs via such bindings. (It also ensures that guard expressions can at most *copy* values from such bindings; non-Copy things cannot be moved via these pattern bindings in guard expressions, since one cannot move out of a `&T`.)", "tree": {"sha": "2d2133016841d8239c831926c669b66cf24581f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d2133016841d8239c831926c669b66cf24581f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91db9dcf3730207f63b3dfc33b2c438a769b7517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91db9dcf3730207f63b3dfc33b2c438a769b7517", "html_url": "https://github.com/rust-lang/rust/commit/91db9dcf3730207f63b3dfc33b2c438a769b7517", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91db9dcf3730207f63b3dfc33b2c438a769b7517/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bfe3072cb5d181e4f60bf1033c8d81239a28385", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bfe3072cb5d181e4f60bf1033c8d81239a28385", "html_url": "https://github.com/rust-lang/rust/commit/0bfe3072cb5d181e4f60bf1033c8d81239a28385"}, {"sha": "930e76e2af5c1ba9f91240da5de20049b52e739c", "url": "https://api.github.com/repos/rust-lang/rust/commits/930e76e2af5c1ba9f91240da5de20049b52e739c", "html_url": "https://github.com/rust-lang/rust/commit/930e76e2af5c1ba9f91240da5de20049b52e739c"}], "stats": {"total": 597, "additions": 505, "deletions": 92}, "files": [{"sha": "3d154e43a9ae12972cd81f0111e328887102effe", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -1467,6 +1467,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.borrowck_mode().use_mir()\n     }\n \n+    /// If true, pattern variables for use in guards on match arms\n+    /// will be bound as references to the data, and occurrences of\n+    /// those variables in the guard expression will implicitly\n+    /// dereference those bindings. (See rust-lang/rust#27282.)\n+    pub fn all_pat_vars_are_implicit_refs_within_guards(self) -> bool {\n+        self.borrowck_mode().use_mir()\n+    }\n+\n     /// If true, we should enable two-phase borrows checks. This is\n     /// done with either `-Ztwo-phase-borrows` or with\n     /// `#![feature(nll)]`."}, {"sha": "db2e078586eda95f346bd4eb11b6227821d44366", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -471,7 +471,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | (RegionKind::ReClosureBound(_), _)\n             | (RegionKind::ReCanonical(_), _)\n             | (RegionKind::ReErased, _) => {\n-                span_bug!(drop_span, \"region does not make sense in this context\");\n+                span_bug!(drop_span, \"region {:?} does not make sense in this context\",\n+                          borrow.region);\n             }\n         }\n     }"}, {"sha": "fae06db31629bbad32f58ce16e51d1e3afae41b3", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::ForGuard::OutsideGuard;\n+use build::matches::ArmHasGuard;\n use hair::*;\n use rustc::mir::*;\n use rustc::hir;\n@@ -113,7 +115,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Declare the bindings, which may create a visibility scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n-                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern);\n+                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n+                                                      ArmHasGuard(false));\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n@@ -135,8 +138,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         }\n \n                         this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n-                            this.storage_live_binding(block, node, span);\n-                            this.schedule_drop_for_binding(node, span);\n+                            this.storage_live_binding(block, node, span, OutsideGuard);\n+                            this.schedule_drop_for_binding(node, span, OutsideGuard);\n                         })\n                     }\n "}, {"sha": "365b9babd0869cfb070ae9bb63e65fa0aaf7ca06", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -11,6 +11,7 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::ForGuard::{OutsideGuard, WithinGuard};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n@@ -86,8 +87,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Place::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n-                let index = this.var_indices[&id];\n-                block.and(Place::Local(index))\n+                let place = if this.is_bound_var_in_guard(id) {\n+                    let index = this.var_local_id(id, WithinGuard);\n+                    if this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards() {\n+                        Place::Local(index).deref()\n+                    } else {\n+                        Place::Local(index)\n+                    }\n+                } else {\n+                    let index = this.var_local_id(id, OutsideGuard);\n+                    Place::Local(index)\n+                };\n+                block.and(place)\n             }\n             ExprKind::StaticRef { id } => {\n                 block.and(Place::Static(Box::new(Static { def_id: id, ty: expr.ty })))"}, {"sha": "6946ac4c7b2771af2a6b7affc10f8870b3adc997", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 267, "deletions": 30, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -14,6 +14,8 @@\n //! details.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n+use build::ForGuard::{self, OutsideGuard, WithinGuard};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::ty::{self, Ty};\n@@ -28,6 +30,11 @@ mod simplify;\n mod test;\n mod util;\n \n+/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// a match arm has a guard expression attached to it.\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct ArmHasGuard(pub bool);\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn match_expr(&mut self,\n                       destination: &Place<'tcx>,\n@@ -66,7 +73,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let body = self.hir.mirror(arm.body.clone());\n             let scope = self.declare_bindings(None, body.span,\n                                               LintLevel::Inherited,\n-                                              &arm.patterns[0]);\n+                                              &arm.patterns[0],\n+                                              ArmHasGuard(arm.guard.is_some()));\n             (body, scope.unwrap_or(self.visibility_scope))\n         }).collect();\n \n@@ -149,7 +157,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                           var: NodeId, span: Span) {\n         if self.hir.tcx().sess.opts.debugging_opts.disable_nll_user_type_assert { return; }\n \n-        let local_id = self.var_indices[&var];\n+        let local_id = self.var_local_id(var, OutsideGuard);\n         let source_info = self.source_info(span);\n \n         debug!(\"user_assert_ty: local_id={:?}\", hir_id.local_id);\n@@ -173,14 +181,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n                                    subpattern: None, .. } => {\n-                let place = self.storage_live_binding(block, var, irrefutable_pat.span);\n+                let place = self.storage_live_binding(block, var, irrefutable_pat.span,\n+                                                      OutsideGuard);\n \n                 if let Some(ty) = ty {\n                     self.user_assert_ty(block, ty, var, irrefutable_pat.span);\n                 }\n \n                 unpack!(block = self.into(&place, block, initializer));\n-                self.schedule_drop_for_binding(var, irrefutable_pat.span);\n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n             _ => {\n@@ -220,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate(block, candidate.bindings);\n+        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n \n         block.unit()\n     }\n@@ -232,7 +241,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             mut var_scope: Option<VisibilityScope>,\n                             scope_span: Span,\n                             lint_level: LintLevel,\n-                            pattern: &Pattern<'tcx>)\n+                            pattern: &Pattern<'tcx>,\n+                            has_guard: ArmHasGuard)\n                             -> Option<VisibilityScope> {\n         assert!(!(var_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a var and a lint scope at the same time\");\n@@ -254,15 +264,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 span,\n                 scope: var_scope.unwrap()\n             };\n-            this.declare_binding(source_info, syntactic_scope, mutability, name, var, ty);\n+            this.declare_binding(source_info, syntactic_scope, mutability, name, var,\n+                                 ty, has_guard);\n         });\n         var_scope\n     }\n \n-    pub fn storage_live_binding(&mut self, block: BasicBlock, var: NodeId, span: Span)\n+    pub fn storage_live_binding(&mut self,\n+                                block: BasicBlock,\n+                                var: NodeId,\n+                                span: Span,\n+                                for_guard: ForGuard)\n                             -> Place<'tcx>\n     {\n-        let local_id = self.var_indices[&var];\n+        let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement {\n             source_info,\n@@ -271,8 +286,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         Place::Local(local_id)\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n-        let local_id = self.var_indices[&var];\n+    pub fn schedule_drop_for_binding(&mut self,\n+                                     var: NodeId,\n+                                     span: Span,\n+                                     for_guard: ForGuard) {\n+        let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n@@ -770,21 +788,139 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                        vec![candidate.next_candidate_pre_binding_block],\n                                });\n \n-        self.bind_matched_candidate(block, candidate.bindings);\n \n+        // rust-lang/rust#27282: The `autoref` business deserves some\n+        // explanation here.\n+        //\n+        // The intent of the `autoref` flag is that when it is true,\n+        // then any pattern bindings of type T will map to a `&T`\n+        // within the context of the guard expression, but will\n+        // continue to map to a `T` in the context of the arm body. To\n+        // avoid surfacing this distinction in the user source code\n+        // (which would be a severe change to the language and require\n+        // far more revision to the compiler), when `autoref` is true,\n+        // then any occurrence of the identifier in the guard\n+        // expression will automatically get a deref op applied to it.\n+        //\n+        // So an input like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { foo if inspect(foo)\n+        //     => feed(foo), ...  }\n+        // ```\n+        //\n+        // will be treated as if it were really something like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { Foo { .. } if { let tmp1 = &place; inspect(*tmp1) }\n+        //     => { let tmp2 = place; feed(tmp2) }, ... }\n+        //\n+        // And an input like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { ref mut foo if inspect(foo)\n+        //     => feed(foo), ...  }\n+        // ```\n+        //\n+        // will be treated as if it were really something like:\n+        //\n+        // ```\n+        // let place = Foo::new();\n+        // match place { Foo { .. } if { let tmp1 = & &mut place; inspect(*tmp1) }\n+        //     => { let tmp2 = &mut place; feed(tmp2) }, ... }\n+        // ```\n+        //\n+        // In short, any pattern binding will always look like *some*\n+        // kind of `&T` within the guard at least in terms of how the\n+        // MIR-borrowck views it, and this will ensure that guard\n+        // expressions cannot mutate their the match inputs via such\n+        // bindings. (It also ensures that guard expressions can at\n+        // most *copy* values from such bindings; non-Copy things\n+        // cannot be moved via pattern bindings in guard expressions.)\n+        //\n+        // ----\n+        //\n+        // Implementation notes (under assumption `autoref` is true).\n+        //\n+        // To encode the distinction above, we must inject the\n+        // temporaries `tmp1` and `tmp2`.\n+        //\n+        // There are two cases of interest: binding by-value, and binding by-ref.\n+        //\n+        // 1. Binding by-value: Things are simple.\n+        //\n+        //    * Establishing `tmp1` creates a reference into the\n+        //      matched place. This code is emitted by\n+        //      bind_matched_candidate_for_guard.\n+        //\n+        //    * `tmp2` is only initialized \"lazily\", after we have\n+        //      checked the guard. Thus, the code that can trigger\n+        //      moves out of the candidate can only fire after the\n+        //      guard evaluated to true. This initialization code is\n+        //      emitted by bind_matched_candidate_for_arm.\n+        //\n+        // 2. Binding by-reference: Things are tricky.\n+        //\n+        //    * Here, the guard expression wants a `&&` or `&&mut`\n+        //      into the original input. This means we need to borrow\n+        //      a reference that we do not immediately have at hand\n+        //      (because all we have is the places associated with the\n+        //      match input itself; it is up to us to create a place\n+        //      holding a `&` or `&mut` that we can then borrow).\n+        //\n+        //    * Therefore, when the binding is by-reference, we\n+        //      *eagerly* introduce the binding for the arm body\n+        //      (`tmp2`) and then borrow it (`tmp1`).\n+        //\n+        //    * This is documented with \"NOTE tricky business\" below.\n+        //\n+        // FIXME The distinction in how `tmp2` is initialized is\n+        // currently encoded in a pretty awkward fashion; namely, by\n+        // passing a boolean to bind_matched_candidate_for_arm_body\n+        // indicating whether all of the by-ref bindings were already\n+        // initialized.\n+        //\n+        // * Also: pnkfelix thinks \"laziness\" is natural; but since\n+        //   MIR-borrowck did not complain with earlier (universally\n+        //   eager) MIR codegen, laziness might not be *necessary*.\n+\n+        let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n+            if autoref {\n+                self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n+                let guard_frame = GuardFrame {\n+                    locals: candidate.bindings.iter()\n+                        .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n+                        .collect(),\n+                };\n+                debug!(\"Entering guard translation context: {:?}\", guard_frame);\n+                self.guard_context.push(guard_frame);\n+            } else {\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+            }\n+\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = self.hir.mirror(guard);\n             let source_info = self.source_info(guard.span);\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n+            if autoref {\n+                let guard_frame = self.guard_context.pop().unwrap();\n+                debug!(\"Exiting guard translation context with locals: {:?}\", guard_frame);\n+            }\n \n             let false_edge_block = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n                                TerminatorKind::if_(self.hir.tcx(), cond, arm_block,\n                                    false_edge_block));\n \n             let otherwise = self.cfg.start_new_block();\n+            if autoref {\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, true);\n+            }\n             self.cfg.terminate(false_edge_block, source_info,\n                                TerminatorKind::FalseEdges {\n                                    real_target: otherwise,\n@@ -793,47 +929,137 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                });\n             Some(otherwise)\n         } else {\n+            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n             self.cfg.terminate(block, candidate_source_info,\n                                TerminatorKind::Goto { target: arm_block });\n             None\n         }\n     }\n \n-    fn bind_matched_candidate(&mut self,\n-                              block: BasicBlock,\n-                              bindings: Vec<Binding<'tcx>>) {\n-        debug!(\"bind_matched_candidate(block={:?}, bindings={:?})\",\n+    fn bind_matched_candidate_for_guard(&mut self,\n+                                        block: BasicBlock,\n+                                        bindings: &[Binding<'tcx>]) {\n+        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\",\n                block, bindings);\n \n+        // Assign each of the bindings. Since we are binding for a\n+        // guard expression, this will never trigger moves out of the\n+        // candidate.\n+        let re_empty = self.hir.tcx().types.re_empty;\n+        for binding in bindings {\n+            let source_info = self.source_info(binding.span);\n+            let local_for_guard = self.storage_live_binding(\n+                block, binding.var_id, binding.span, WithinGuard);\n+            // Question: Why schedule drops if bindings are all\n+            // shared-&'s?  Answer: Because schedule_drop_for_binding\n+            // also emits StorageDead's for those locals.\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, WithinGuard);\n+            match binding.binding_mode {\n+                BindingMode::ByValue => {\n+                    let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n+                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                }\n+                BindingMode::ByRef(region, borrow_kind) => {\n+                    // NOTE tricky business: For `ref id` and `ref mut\n+                    // id` patterns, we want `id` within the guard to\n+                    // correspond to a temp of type `& &T` or `& &mut\n+                    // T`, while within the arm body it will\n+                    // correspond to a temp of type `&T` or `&mut T`,\n+                    // as usual.\n+                    //\n+                    // But to inject the level of indirection, we need\n+                    // something to point to.\n+                    //\n+                    // So:\n+                    //\n+                    // 1. First set up the local for the arm body\n+                    //   (even though we have not yet evaluated the\n+                    //   guard itself),\n+                    //\n+                    // 2. Then setup the local for the guard, which is\n+                    //    just a reference to the local from step 1.\n+                    //\n+                    // Note that since we are setting up the local for\n+                    // the arm body a bit eagerly here (and likewise\n+                    // scheduling its drop code), we should *not* do\n+                    // it redundantly later on.\n+                    //\n+                    // While we could have kept track of this with a\n+                    // flag or collection of such bindings, the\n+                    // treatment of all of these cases is uniform, so\n+                    // we should be safe just avoiding the code\n+                    // without maintaining such state.)\n+                    let local_for_arm_body = self.storage_live_binding(\n+                        block, binding.var_id, binding.span, OutsideGuard);\n+                    self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n+\n+                    // rust-lang/rust#27282: this potentially mutable\n+                    // borrow may require a cast in the future to\n+                    // avoid conflicting with an implicit borrow of\n+                    // the whole match input; or maybe it just\n+                    // requires an extension of our two-phase borrows\n+                    // system. See discussion on rust-lang/rust#49870.\n+                    let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n+                    self.cfg.push_assign(block, source_info, &local_for_arm_body, rvalue);\n+                    let rvalue = Rvalue::Ref(region, BorrowKind::Shared, local_for_arm_body);\n+                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn bind_matched_candidate_for_arm_body(&mut self,\n+                                           block: BasicBlock,\n+                                           bindings: &[Binding<'tcx>],\n+                                           already_initialized_state_for_refs: bool) {\n+        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}, \\\n+                already_initialized_state_for_refs={:?})\",\n+               block, bindings, already_initialized_state_for_refs);\n+\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n+            if let BindingMode::ByRef(..) = binding.binding_mode {\n+                // See \"NOTE tricky business\" above\n+                if already_initialized_state_for_refs { continue; }\n+            }\n+\n             let source_info = self.source_info(binding.span);\n-            let local = self.storage_live_binding(block, binding.var_id, binding.span);\n-            self.schedule_drop_for_binding(binding.var_id, binding.span);\n+            let local = self.storage_live_binding(block, binding.var_id, binding.span,\n+                                                  OutsideGuard);\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             let rvalue = match binding.binding_mode {\n-                BindingMode::ByValue =>\n-                    Rvalue::Use(self.consume_by_copy_or_move(binding.source)),\n-                BindingMode::ByRef(region, borrow_kind) =>\n-                    Rvalue::Ref(region, borrow_kind, binding.source),\n+                BindingMode::ByValue => {\n+                    Rvalue::Use(self.consume_by_copy_or_move(binding.source.clone()))\n+                }\n+                BindingMode::ByRef(region, borrow_kind) => {\n+                    Rvalue::Ref(region, borrow_kind, binding.source.clone())\n+                }\n             };\n             self.cfg.push_assign(block, source_info, &local, rvalue);\n         }\n     }\n \n+    /// Each binding (`ref mut var`/`ref var`/`mut var`/`var`, where\n+    /// the bound `var` has type `T` in the arm body) in a pattern\n+    /// maps to *two* locals. The first local is a binding for\n+    /// occurrences of `var` in the guard, which will all have type\n+    /// `&T`. The second local is a binding for occurrences of `var`\n+    /// in the arm body, which will have type `T`.\n     fn declare_binding(&mut self,\n                        source_info: SourceInfo,\n                        syntactic_scope: VisibilityScope,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n-                       var_ty: Ty<'tcx>)\n-                       -> Local\n+                       var_ty: Ty<'tcx>,\n+                       has_guard: ArmHasGuard)\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, source_info={:?}, \\\n                 syntactic_scope={:?})\",\n                var_id, name, var_ty, source_info, syntactic_scope);\n \n-        let var = self.local_decls.push(LocalDecl::<'tcx> {\n+        let tcx = self.hir.tcx();\n+        let for_arm_body = self.local_decls.push(LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n@@ -842,10 +1068,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             internal: false,\n             is_user_variable: true,\n         });\n-        self.var_indices.insert(var_id, var);\n-\n-        debug!(\"declare_binding: var={:?}\", var);\n-\n-        var\n+        let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n+            let for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n+                mutability,\n+                ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n+                name: Some(name),\n+                source_info,\n+                syntactic_scope,\n+                internal: false,\n+                is_user_variable: true,\n+            });\n+            LocalsForNode::Two { for_guard, for_arm_body }\n+        } else {\n+            LocalsForNode::One(for_arm_body)\n+        };\n+        debug!(\"declare_binding: vars={:?}\", locals);\n+        self.var_indices.insert(var_id, locals);\n     }\n }"}, {"sha": "dd2a336af41d0a7d346e6793ccf064848f589369", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -291,8 +291,14 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     visibility_scope_info: IndexVec<VisibilityScope, VisibilityScopeInfo>,\n     visibility_scope: VisibilityScope,\n \n+    /// the guard-context: each time we build the guard expression for\n+    /// a match arm, we push onto this stack, and then pop when we\n+    /// finish building it.\n+    guard_context: Vec<GuardFrame>,\n+\n     /// Maps node ids of variable bindings to the `Local`s created for them.\n-    var_indices: NodeMap<Local>,\n+    /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n+    var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     unit_temp: Option<Place<'tcx>>,\n \n@@ -305,6 +311,74 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     cached_unreachable_block: Option<BasicBlock>,\n }\n \n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    fn is_bound_var_in_guard(&self, id: ast::NodeId) -> bool {\n+        self.guard_context.iter().any(|frame| frame.locals.iter().any(|local| local.id == id))\n+    }\n+\n+    fn var_local_id(&self, id: ast::NodeId, for_guard: ForGuard) -> Local {\n+        self.var_indices[&id].local_id(for_guard)\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum LocalsForNode {\n+    One(Local),\n+    Two { for_guard: Local, for_arm_body: Local },\n+}\n+\n+#[derive(Debug)]\n+struct GuardFrameLocal {\n+    id: ast::NodeId,\n+}\n+\n+impl GuardFrameLocal {\n+    fn new(id: ast::NodeId, _binding_mode: BindingMode) -> Self {\n+        GuardFrameLocal {\n+            id: id,\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct GuardFrame {\n+    /// These are the id's of names that are bound by patterns of the\n+    /// arm of *this* guard.\n+    ///\n+    /// (Frames higher up the stack will have the id's bound in arms\n+    /// further out, such as in a case like:\n+    ///\n+    /// match E1 {\n+    ///      P1(id1) if (... (match E2 { P2(id2) if ... => B2 })) => B1,\n+    /// }\n+    ///\n+    /// here, when building for FIXME\n+    locals: Vec<GuardFrameLocal>,\n+}\n+\n+/// ForGuard is isomorphic to a boolean flag. It indicates whether we are\n+/// talking about the temp for a local binding for a use within a guard expression,\n+/// or a temp for use outside of a guard expressions.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum ForGuard {\n+    WithinGuard,\n+    OutsideGuard,\n+}\n+\n+impl LocalsForNode {\n+    fn local_id(&self, for_guard: ForGuard) -> Local {\n+        match (self, for_guard) {\n+            (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n+            (&LocalsForNode::Two { for_guard: local_id, .. }, ForGuard::WithinGuard) |\n+            (&LocalsForNode::Two { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n+                local_id,\n+\n+            (&LocalsForNode::One(_), ForGuard::WithinGuard) =>\n+                bug!(\"anything with one local should never be within a guard.\"),\n+        }\n+    }\n+}\n+\n struct CFG<'tcx> {\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n }\n@@ -548,6 +622,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             visibility_scope_info: IndexVec::new(),\n+            guard_context: vec![],\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n@@ -636,11 +711,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Don't introduce extra copies for simple bindings\n                     PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n                         self.local_decls[local].mutability = mutability;\n-                        self.var_indices.insert(var, local);\n+                        self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n-                                                      LintLevel::Inherited, &pattern);\n+                                                      LintLevel::Inherited, &pattern,\n+                                                      matches::ArmHasGuard(false));\n                         unpack!(block = self.place_into_pattern(block, pattern, &place));\n                     }\n                 }"}, {"sha": "098ad8e558fa968f26bf2c3d681e802fee5f5ae4", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -179,8 +179,14 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                     if let RegionKind::ReEmpty = region {\n                         // If the borrowed value dies before the borrow is used, the region for\n                         // the borrow can be empty. Don't track the borrow in that case.\n+                        debug!(\"Borrows::statement_effect_on_borrows \\\n+                                location: {:?} stmt: {:?} has empty region, killing {:?}\",\n+                               location, stmt.kind, index);\n                         sets.kill(&index);\n                         return\n+                    } else {\n+                        debug!(\"Borrows::statement_effect_on_borrows location: {:?} stmt: {:?}\",\n+                               location, stmt.kind);\n                     }\n \n                     assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {"}, {"sha": "985531446270e4dc252fe2be70de698be7d0fcc7", "filename": "src/test/compile-fail/nll/match-guards-always-borrow.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Ftest%2Fcompile-fail%2Fnll%2Fmatch-guards-always-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Ftest%2Fcompile-fail%2Fnll%2Fmatch-guards-always-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fmatch-guards-always-borrow.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//revisions: ast mir\n+//[mir] compile-flags: -Z borrowck=mir\n+\n+#![feature(rustc_attrs)]\n+\n+// Here is arielb1's basic example from rust-lang/rust#27282\n+// that AST borrowck is flummoxed by:\n+\n+fn should_reject_destructive_mutate_in_guard() {\n+    match Some(&4) {\n+        None => {},\n+        ref mut foo if {\n+            (|| { let bar = foo; bar.take() })();\n+            //[mir]~^ ERROR cannot move out of borrowed content [E0507]\n+            false } => { },\n+        Some(s) => std::process::exit(*s),\n+    }\n+}\n+\n+// Here below is a case that needs to keep working: we only use the\n+// binding via immutable-borrow in the guard, and we mutate in the arm\n+// body.\n+fn allow_mutate_in_arm_body() {\n+    match Some(&4) {\n+        None => {},\n+        ref mut foo if foo.is_some() && false => { foo.take(); () }\n+        Some(s) => std::process::exit(*s),\n+    }\n+}\n+\n+// Here below is a case that needs to keep working: we only use the\n+// binding via immutable-borrow in the guard, and we move into the arm\n+// body.\n+fn allow_move_into_arm_body() {\n+    match Some(&4) {\n+        None => {},\n+        mut foo if foo.is_some() && false => { foo.take(); () }\n+        Some(s) => std::process::exit(*s),\n+    }\n+}\n+\n+// Since this is a compile-fail test that is explicitly encoding the\n+// different behavior of AST- vs MIR-borrowck where AST-borrowck does\n+// not error, we need to use rustc_error to placate the test harness\n+// that wants *some* error to occur.\n+#[rustc_error]\n+fn main() { //[ast]~ ERROR compilation successful\n+    should_reject_destructive_mutate_in_guard();\n+    allow_mutate_in_arm_body();\n+    allow_move_into_arm_body();\n+}"}, {"sha": "a31298a0f516007fcd8790a10d9539627b5b91af", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -54,17 +54,17 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      _3 = discriminant(_2);\n-//      _6 = discriminant(_2);\n-//      switchInt(move _6) -> [0isize: bb6, 1isize: bb4, otherwise: bb8];\n+//      _7 = discriminant(_2);\n+//      switchInt(move _7) -> [0isize: bb6, 1isize: bb4, otherwise: bb8];\n //  }\n //  bb1: {\n //      resume;\n //  }\n //  bb2: {  // arm1\n-//      StorageLive(_8);\n-//      _8 = _4;\n-//      _1 = (const 1i32, move _8);\n-//      StorageDead(_8);\n+//      StorageLive(_9);\n+//      _9 = _4;\n+//      _1 = (const 1i32, move _9);\n+//      StorageDead(_9);\n //      goto -> bb13;\n //  }\n //  bb3: { // binding3(empty) and arm3\n@@ -87,24 +87,26 @@ fn main() {\n //      unreachable;\n //  }\n //  bb9: { // binding1 and guard\n-//      StorageLive(_4);\n-//      _4 = ((_2 as Some).0: i32);\n-//      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb10, unwind: bb1];\n+//      StorageLive(_5);\n+//      _5 = &((_2 as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: { // end of guard\n-//      switchInt(move _7) -> [false: bb11, otherwise: bb2];\n+//      StorageLive(_4);\n+//      _4 = ((_2 as Some).0: i32);\n+//      switchInt(move _8) -> [false: bb11, otherwise: bb2];\n //  }\n //  bb11: { // to pre_binding2\n //      falseEdges -> [real: bb5, imaginary: bb5];\n //  }\n //  bb12: { // bindingNoLandingPads.before.mir2 and arm2\n-//      StorageLive(_5);\n-//      _5 = ((_2 as Some).0: i32);\n-//      StorageLive(_9);\n-//      _9 = _5;\n-//      _1 = (const 2i32, move _9);\n-//      StorageDead(_9);\n+//      StorageLive(_6);\n+//      _6 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _6;\n+//      _1 = (const 2i32, move _10);\n+//      StorageDead(_10);\n //      goto -> bb13;\n //  }\n //  bb13: {\n@@ -118,17 +120,17 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      _3 = discriminant(_2);\n-//      _6 = discriminant(_2);\n-//      switchInt(move _6) -> [0isize: bb5, 1isize: bb4, otherwise: bb8];\n+//      _7 = discriminant(_2);\n+//      switchInt(move _7) -> [0isize: bb5, 1isize: bb4, otherwise: bb8];\n //  }\n //  bb1: {\n //      resume;\n //  }\n //  bb2: { // arm1\n-//      StorageLive(_8);\n-//      _8 = _4;\n-//      _1 = (const 1i32, move _8);\n-//      StorageDead(_8);\n+//      StorageLive(_9);\n+//      _9 = _4;\n+//      _1 = (const 1i32, move _9);\n+//      StorageDead(_9);\n //      goto -> bb13;\n //  }\n //  bb3: { // binding3(empty) and arm3\n@@ -151,24 +153,26 @@ fn main() {\n //      unreachable;\n //  }\n //  bb9: { // binding1 and guard\n-//      StorageLive(_4);\n-//      _4 = ((_2 as Some).0: i32);\n-//      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb10, unwind: bb1];\n+//      StorageLive(_5);\n+//      _5 = &((_2 as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: { // end of guard\n-//      switchInt(move _7) -> [false: bb11, otherwise: bb2];\n+//      StorageLive(_4);\n+//      _4 = ((_2 as Some).0: i32);\n+//      switchInt(move _8) -> [false: bb11, otherwise: bb2];\n //  }\n //  bb11: { // to pre_binding2\n //      falseEdges -> [real: bb6, imaginary: bb5];\n //  }\n //  bb12: { // binding2 and arm2\n-//      StorageLive(_5);\n-//      _5 = ((_2 as Some).0: i32);\n-//      StorageLive(_9);\n-//      _9 = _5;\n-//      _1 = (const 2i32, move _9);\n-//      StorageDead(_9);\n+//      StorageLive(_6);\n+//      _6 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _6;\n+//      _1 = (const 2i32, move _10);\n+//      StorageDead(_10);\n //      goto -> bb13;\n //  }\n //  bb13: {\n@@ -182,8 +186,8 @@ fn main() {\n //     ...\n //     _2 = std::option::Option<i32>::Some(const 1i32,);\n //     _3 = discriminant(_2);\n-//     _8 = discriminant(_2);\n-//     switchInt(move _8) -> [1isize: bb4, otherwise: bb5];\n+//     _10 = discriminant(_2);\n+//     switchInt(move _10) -> [1isize: bb4, otherwise: bb5];\n // }\n // bb1: {\n //     resume;\n@@ -213,41 +217,45 @@ fn main() {\n //     unreachable;\n // }\n // bb9: { // binding1: Some(w) if guard()\n-//     StorageLive(_4);\n-//     _4 = ((_2 as Some).0: i32);\n-//     StorageLive(_9);\n-//     _9 = const guard() -> [return: bb10, unwind: bb1];\n+//     StorageLive(_5);\n+//     _5 = &((_2 as Some).0: i32);\n+//     StorageLive(_11);\n+//     _11 = const guard() -> [return: bb10, unwind: bb1];\n // }\n // bb10: { //end of guard\n-//    switchInt(move _9) -> [false: bb11, otherwise: bb2];\n+//    StorageLive(_4);\n+//    _4 = ((_2 as Some).0: i32);\n+//    switchInt(move _11) -> [false: bb11, otherwise: bb2];\n // }\n // bb11: { // to pre_binding2\n //     falseEdges -> [real: bb5, imaginary: bb5];\n // }\n // bb12: { // binding2 & arm2\n-//     StorageLive(_5);\n-//     _5 = _2;\n+//     StorageLive(_6);\n+//     _6 = _2;\n //     _1 = const 2i32;\n //     goto -> bb17;\n // }\n // bb13: { // binding3: Some(y) if guard2(y)\n-//     StorageLive(_6);\n-//     _6 = ((_2 as Some).0: i32);\n-//     StorageLive(_11);\n-//     StorageLive(_12);\n-//     _12 = _6;\n-//     _11 = const guard2(move _12) -> [return: bb14, unwind: bb1];\n+//     StorageLive(_8);\n+//     _8 = &((_2 as Some).0: i32);\n+//     StorageLive(_13);\n+//     StorageLive(_14);\n+//     _14 = (*_8);\n+//     _13 = const guard2(move _14) -> [return: bb14, unwind: bb1];\n // }\n // bb14: { // end of guard2\n-//     StorageDead(_12);\n-//     switchInt(move _11) -> [false: bb15, otherwise: bb3];\n+//     StorageDead(_14);\n+//     StorageLive(_7);\n+//     _7 = ((_2 as Some).0: i32);\n+//     switchInt(move _13) -> [false: bb15, otherwise: bb3];\n // }\n // bb15: { // to pre_binding4\n //     falseEdges -> [real: bb7, imaginary: bb7];\n // }\n // bb16: { // binding4 & arm4\n-//     StorageLive(_7);\n-//     _7 = _2;\n+//     StorageLive(_9);\n+//     _9 = _2;\n //     _1 = const 4i32;\n //     goto -> bb17;\n // }"}, {"sha": "01d9f52424da8d17b4aac85bb68b3993eb72bdd7", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91db9dcf3730207f63b3dfc33b2c438a769b7517/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=91db9dcf3730207f63b3dfc33b2c438a769b7517", "patch": "@@ -2735,10 +2735,12 @@ impl<'test> TestCx<'test> {\n             panic!(\n                 \"Did not find expected line, error: {}\\n\\\n                  Expected Line: {:?}\\n\\\n+                 Test Name: {}\\n\\\n                  Expected:\\n{}\\n\\\n                  Actual:\\n{}\",\n                 extra_msg,\n                 expected_line,\n+                test_name,\n                 expected_content,\n                 normalize_all\n             );"}]}