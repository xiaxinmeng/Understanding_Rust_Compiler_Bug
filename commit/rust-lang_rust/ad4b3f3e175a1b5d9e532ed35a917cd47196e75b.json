{"sha": "ad4b3f3e175a1b5d9e532ed35a917cd47196e75b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNGIzZjNlMTc1YTFiNWQ5ZTUzMmVkMzVhOTE3Y2Q0NzE5NmU3NWI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-14T21:49:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-14T21:49:01Z"}, "message": "const-prop: use one helper method for all lints; consistently lint overflow on BinOps and not on Assert", "tree": {"sha": "88894504b3c2799e579386f9f9899e56a2cf149d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88894504b3c2799e579386f9f9899e56a2cf149d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b", "html_url": "https://github.com/rust-lang/rust/commit/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35071e3e2e74f6f780bc851500b9316e3e82062a", "url": "https://api.github.com/repos/rust-lang/rust/commits/35071e3e2e74f6f780bc851500b9316e3e82062a", "html_url": "https://github.com/rust-lang/rust/commit/35071e3e2e74f6f780bc851500b9316e3e82062a"}], "stats": {"total": 181, "additions": 94, "deletions": 87}, "files": [{"sha": "53acf1490bf58fb9a6de6d2a26536865ee62122c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 80, "deletions": 87, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ad4b3f3e175a1b5d9e532ed35a917cd47196e75b", "patch": "@@ -4,7 +4,8 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n \n-use rustc::mir::interpret::{InterpError, InterpResult, Scalar};\n+use rustc::lint;\n+use rustc::mir::interpret::{InterpResult, Scalar};\n use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -292,7 +293,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine>,\n     tcx: TyCtxt<'tcx>,\n-    source: MirSource<'tcx>,\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     param_env: ParamEnv<'tcx>,\n     // FIXME(eddyb) avoid cloning these two fields more than once,\n@@ -372,7 +372,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         ConstPropagator {\n             ecx,\n             tcx,\n-            source,\n             param_env,\n             can_const_prop,\n             // FIXME(eddyb) avoid cloning these two fields more than once,\n@@ -501,19 +500,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn report_panic_as_lint(&self, source_info: SourceInfo, panic: AssertKind<u64>) -> Option<()> {\n-        // Somewhat convoluted way to re-use the CTFE error reporting code.\n+    fn report_assert_as_lint(\n+        &self,\n+        lint: &'static lint::Lint,\n+        source_info: SourceInfo,\n+        message: &str,\n+        panic: AssertKind<u64>,\n+    ) -> Option<()> {\n         let lint_root = self.lint_root(source_info)?;\n-        let error = InterpError::MachineStop(Box::new(format!(\"{:?}\", panic)));\n-        let mut diagnostic = error_to_const_error(&self.ecx, error.into());\n-        diagnostic.span = source_info.span; // fix the span\n-        diagnostic.report_as_lint(\n-            self.tcx.at(source_info.span),\n-            \"this expression will panic at runtime\",\n-            lint_root,\n-            None,\n-        );\n-        None\n+        self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, |lint| {\n+            let mut err = lint.build(message);\n+            err.span_label(source_info.span, format!(\"{:?}\", panic));\n+            err.emit()\n+        });\n+        return None;\n     }\n \n     fn check_unary_op(\n@@ -530,7 +530,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n             // appropriate to use.\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n-            self.report_panic_as_lint(source_info, AssertKind::OverflowNeg)?;\n+            self.report_assert_as_lint(\n+                lint::builtin::OVERFLOW,\n+                source_info,\n+                \"this arithmetic operation will overflow\",\n+                AssertKind::OverflowNeg,\n+            )?;\n         }\n \n         Some(())\n@@ -552,17 +557,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n             if r_bits.map_or(false, |b| b >= left_bits as u128) {\n-                let lint_root = self.lint_root(source_info)?;\n-                self.tcx.struct_span_lint_hir(\n-                    ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                    lint_root,\n-                    source_info.span,\n-                    |lint| {\n-                        let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n-                        lint.build(&format!(\"attempt to shift {} with overflow\", dir)).emit()\n-                    },\n-                );\n-                return None;\n+                self.report_assert_as_lint(\n+                    lint::builtin::EXCEEDING_BITSHIFTS,\n+                    source_info,\n+                    \"this arithmetic operation will overflow\",\n+                    AssertKind::Overflow(op),\n+                )?;\n             }\n         }\n \n@@ -572,7 +572,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n             Ok(overflow)\n         })? {\n-            self.report_panic_as_lint(source_info, AssertKind::Overflow(op))?;\n+            self.report_assert_as_lint(\n+                lint::builtin::OVERFLOW,\n+                source_info,\n+                \"this arithmetic operation will overflow\",\n+                AssertKind::Overflow(op),\n+            )?;\n         }\n \n         Some(())\n@@ -595,8 +600,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        let overflow_check = self.tcx.sess.overflow_checks();\n-\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -606,21 +609,26 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         //        - In this case, we'll return `None` from this function to stop evaluation.\n         match rvalue {\n             // Additional checking: give lints to the user if an overflow would occur.\n-            // If `overflow_check` is set, running const-prop on the `Assert` terminators\n-            // will already generate the appropriate messages.\n-            Rvalue::UnaryOp(op, arg) if !overflow_check => {\n+            // We do this here and not in the `Assert` terminator as that terminator is\n+            // only sometimes emitted (overflow checks can be disabled), but we want to always\n+            // lint.\n+            Rvalue::UnaryOp(op, arg) => {\n                 trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n                 self.check_unary_op(*op, arg, source_info)?;\n             }\n-\n-            // Additional checking: check for overflows on integer binary operations and report\n-            // them to the user as lints.\n-            // If `overflow_check` is set, running const-prop on the `Assert` terminators\n-            // will already generate the appropriate messages.\n-            Rvalue::BinaryOp(op, left, right) if !overflow_check => {\n+            Rvalue::BinaryOp(op, left, right) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n                 self.check_binary_op(*op, left, right, source_info, place_layout)?;\n             }\n+            Rvalue::CheckedBinaryOp(op, left, right) => {\n+                trace!(\n+                    \"checking CheckedBinaryOp(op = {:?}, left = {:?}, right = {:?})\",\n+                    op,\n+                    left,\n+                    right\n+                );\n+                self.check_binary_op(*op, left, right, source_info, place_layout)?;\n+            }\n \n             // Do not try creating references (#67862)\n             Rvalue::Ref(_, _, place_ref) => {\n@@ -898,54 +906,39 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             }\n                             Operand::Constant(_) => {}\n                         }\n-                        let span = terminator.source_info.span;\n-                        let hir_id = self\n-                            .tcx\n-                            .hir()\n-                            .as_local_hir_id(self.source.def_id())\n-                            .expect(\"some part of a failing const eval must be local\");\n-                        self.tcx.struct_span_lint_hir(\n-                            ::rustc::lint::builtin::CONST_ERR,\n-                            hir_id,\n-                            span,\n-                            |lint| {\n-                                let msg = match msg {\n-                                    AssertKind::Overflow(_)\n-                                    | AssertKind::OverflowNeg\n-                                    | AssertKind::DivisionByZero\n-                                    | AssertKind::RemainderByZero => msg.description().to_owned(),\n-                                    AssertKind::BoundsCheck { ref len, ref index } => {\n-                                        let len = self\n-                                            .eval_operand(len, source_info)\n-                                            .expect(\"len must be const\");\n-                                        let len = match self.ecx.read_scalar(len) {\n-                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n-                                                data,\n-                                                ..\n-                                            })) => data,\n-                                            other => bug!(\"const len not primitive: {:?}\", other),\n-                                        };\n-                                        let index = self\n-                                            .eval_operand(index, source_info)\n-                                            .expect(\"index must be const\");\n-                                        let index = match self.ecx.read_scalar(index) {\n-                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n-                                                data,\n-                                                ..\n-                                            })) => data,\n-                                            other => bug!(\"const index not primitive: {:?}\", other),\n-                                        };\n-                                        format!(\n-                                            \"index out of bounds: \\\n-                                            the len is {} but the index is {}\",\n-                                            len, index,\n-                                        )\n-                                    }\n-                                    // Need proper const propagator for these\n-                                    _ => return,\n-                                };\n-                                lint.build(&msg).emit()\n-                            },\n+                        let msg = match msg {\n+                            AssertKind::DivisionByZero => AssertKind::DivisionByZero,\n+                            AssertKind::RemainderByZero => AssertKind::RemainderByZero,\n+                            AssertKind::BoundsCheck { ref len, ref index } => {\n+                                let len =\n+                                    self.eval_operand(len, source_info).expect(\"len must be const\");\n+                                let len = self\n+                                    .ecx\n+                                    .read_scalar(len)\n+                                    .unwrap()\n+                                    .to_machine_usize(&self.tcx)\n+                                    .unwrap();\n+                                let index = self\n+                                    .eval_operand(index, source_info)\n+                                    .expect(\"index must be const\");\n+                                let index = self\n+                                    .ecx\n+                                    .read_scalar(index)\n+                                    .unwrap()\n+                                    .to_machine_usize(&self.tcx)\n+                                    .unwrap();\n+                                AssertKind::BoundsCheck { len, index }\n+                            }\n+                            // Overflow is are already covered by checks on the binary operators.\n+                            AssertKind::Overflow(_) | AssertKind::OverflowNeg => return,\n+                            // Need proper const propagator for these.\n+                            _ => return,\n+                        };\n+                        self.report_assert_as_lint(\n+                            lint::builtin::PANIC,\n+                            source_info,\n+                            \"this operation will panic at runtime\",\n+                            msg,\n                         );\n                     } else {\n                         if self.should_const_prop(value) {"}, {"sha": "992f8ab26179ddafe1a24bc629bbca619a27f533", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad4b3f3e175a1b5d9e532ed35a917cd47196e75b/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=ad4b3f3e175a1b5d9e532ed35a917cd47196e75b", "patch": "@@ -46,6 +46,18 @@ declare_lint! {\n     \"shift exceeds the type's number of bits\"\n }\n \n+declare_lint! {\n+    pub OVERFLOW,\n+    Deny,\n+    \"arithmetic operation overflows\"\n+}\n+\n+declare_lint! {\n+    pub PANIC,\n+    Deny,\n+    \"operation will cause a panic at runtime\"\n+}\n+\n declare_lint! {\n     pub CONST_ERR,\n     Deny,\n@@ -496,6 +508,8 @@ declare_lint_pass! {\n     HardwiredLints => [\n         ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n         EXCEEDING_BITSHIFTS,\n+        OVERFLOW,\n+        PANIC,\n         UNUSED_IMPORTS,\n         UNUSED_EXTERN_CRATES,\n         UNUSED_QUALIFICATIONS,"}]}