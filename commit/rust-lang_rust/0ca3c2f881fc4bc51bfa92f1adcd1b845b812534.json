{"sha": "0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYTNjMmY4ODFmYzRiYzUxYmZhOTJmMWFkY2QxYjg0NWI4MTI1MzQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-08T16:45:12Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-08T19:38:12Z"}, "message": "syntax: Move most of the `TokenKind` methods to `Token`", "tree": {"sha": "872462c18de8b5bcfad199cb88eb2731305b3f12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/872462c18de8b5bcfad199cb88eb2731305b3f12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "html_url": "https://github.com/rust-lang/rust/commit/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffe23475cba4b933475715ff72ca0be6aea0a398", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffe23475cba4b933475715ff72ca0be6aea0a398", "html_url": "https://github.com/rust-lang/rust/commit/ffe23475cba4b933475715ff72ca0be6aea0a398"}], "stats": {"total": 166, "additions": 66, "deletions": 100}, "files": [{"sha": "99ca8c43cfbe202b577e848f0752d03d83aad3f1", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -257,7 +257,7 @@ impl<'a> Classifier<'a> {\n             token::Question => Class::QuestionMark,\n \n             token::Dollar => {\n-                if self.lexer.peek().kind.is_ident() {\n+                if self.lexer.peek().is_ident() {\n                     self.in_macro_nonterminal = true;\n                     Class::MacroNonTerminal\n                 } else {"}, {"sha": "d7e43f645df7bbb05fd3fa27c90bcae5ea935ebb", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -20,7 +20,7 @@ use crate::source_map::{BytePos, Spanned, dummy_spanned};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n-use crate::parse::token::{self, Token, TokenKind};\n+use crate::parse::token::{self, Token};\n use crate::ptr::P;\n use crate::symbol::{sym, Symbol};\n use crate::ThinVec;\n@@ -467,8 +467,7 @@ impl MetaItem {\n                                              segment.ident.span.ctxt());\n                 idents.push(TokenTree::token(token::ModSep, mod_sep_span).into());\n             }\n-            idents.push(TokenTree::token(TokenKind::from_ast_ident(segment.ident),\n-                                         segment.ident.span).into());\n+            idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident)).into());\n             last_pos = segment.ident.span.hi();\n         }\n         self.node.tokens(self.span).append_to_tree_and_joint_vec(&mut idents);"}, {"sha": "9520adb9029c2277ac3c124f8843b72aa07dbea1", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -428,13 +428,13 @@ pub fn parse_failure_msg(tok: TokenKind) -> String {\n }\n \n /// Performs a token equality check, ignoring syntax context (that is, an unhygienic comparison)\n-fn token_name_eq(t1: &TokenKind, t2: &TokenKind) -> bool {\n-    if let (Some((name1, is_raw1)), Some((name2, is_raw2))) = (t1.ident_name(), t2.ident_name()) {\n-        name1 == name2 && is_raw1 == is_raw2\n-    } else if let (Some(name1), Some(name2)) = (t1.lifetime_name(), t2.lifetime_name()) {\n-        name1 == name2\n+fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n+    if let (Some((ident1, is_raw1)), Some((ident2, is_raw2))) = (t1.ident(), t2.ident()) {\n+        ident1.name == ident2.name && is_raw1 == is_raw2\n+    } else if let (Some(ident1), Some(ident2)) = (t1.lifetime(), t2.lifetime()) {\n+        ident1.name == ident2.name\n     } else {\n-        *t1 == *t2\n+        t1.kind == t2.kind\n     }\n }\n \n@@ -712,7 +712,7 @@ pub fn parse(\n \n         // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n         // either the parse is ambiguous (which should never happen) or there is a syntax error.\n-        if token_name_eq(&parser.token, &token::Eof) {\n+        if parser.token == token::Eof {\n             if eof_items.len() == 1 {\n                 let matches = eof_items[0]\n                     .matches"}, {"sha": "c51f4b20c31c04689e7d2f5f68606adf259450f5", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -4,7 +4,7 @@ use crate::ext::expand::Marker;\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use crate::ext::tt::quoted;\n use crate::mut_visit::noop_visit_tt;\n-use crate::parse::token::{self, NtTT, Token, TokenKind};\n+use crate::parse::token::{self, NtTT, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use smallvec::{smallvec, SmallVec};\n@@ -237,7 +237,7 @@ pub fn transcribe(\n                         Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.mark));\n                     sp = sp.apply_mark(cx.current_expansion.mark);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n-                    result.push(TokenTree::token(TokenKind::from_ast_ident(ident), sp).into());\n+                    result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n                 }\n             }\n "}, {"sha": "2f4c48d4bf9e0c5581c96d39bf2226f88ecb9233", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -1501,7 +1501,7 @@ fn char_at(s: &str, byte: usize) -> char {\n mod tests {\n     use super::*;\n \n-    use crate::ast::{Ident, CrateConfig};\n+    use crate::ast::CrateConfig;\n     use crate::symbol::Symbol;\n     use crate::source_map::{SourceMap, FilePathMapping};\n     use crate::feature_gate::UnstableFeatures;\n@@ -1562,7 +1562,7 @@ mod tests {\n             assert_eq!(string_reader.next_token(), token::Whitespace);\n             let tok1 = string_reader.next_token();\n             let tok2 = Token::new(\n-                token::Ident(Symbol::intern(\"fn\"), false),\n+                mk_ident(\"fn\"),\n                 Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n             );\n             assert_eq!(tok1.kind, tok2.kind);\n@@ -1593,7 +1593,7 @@ mod tests {\n \n     // make the identifier by looking up the string in the interner\n     fn mk_ident(id: &str) -> TokenKind {\n-        TokenKind::from_ast_ident(Ident::from_str(id))\n+        token::Ident(Symbol::intern(id), false)\n     }\n \n     fn mk_lit(kind: token::LitKind, symbol: &str, suffix: Option<&str>) -> TokenKind {"}, {"sha": "8ad43a6c809bd4e07e0579dc2f622361cdf9edfb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -2627,9 +2627,11 @@ impl<'a> Parser<'a> {\n                     token::Ident(name, _) => name,\n                     _ => unreachable!()\n                 };\n-                let mut err = self.fatal(&format!(\"unknown macro variable `{}`\", name));\n-                err.span_label(self.token.span, \"unknown macro variable\");\n-                err.emit();\n+                let span = self.prev_span.to(self.token.span);\n+                self.diagnostic()\n+                    .struct_span_fatal(span, &format!(\"unknown macro variable `{}`\", name))\n+                    .span_label(span, \"unknown macro variable\")\n+                    .emit();\n                 self.bump();\n                 return\n             }"}, {"sha": "0ece5b57935e5fcdd60e74c14fa405dd9719c739", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 41, "deletions": 75, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -241,21 +241,19 @@ pub struct Token {\n     pub span: Span,\n }\n \n-impl TokenKind {\n-    /// Recovers a `TokenKind` from an `ast::Ident`. This creates a raw identifier if necessary.\n-    pub fn from_ast_ident(ident: ast::Ident) -> TokenKind {\n-        Ident(ident.name, ident.is_raw_guess())\n+impl Token {\n+    /// Recovers a `Token` from an `ast::Ident`. This creates a raw identifier if necessary.\n+    crate fn from_ast_ident(ident: ast::Ident) -> Token {\n+        Token::new(Ident(ident.name, ident.is_raw_guess()), ident.span)\n     }\n \n     crate fn is_like_plus(&self) -> bool {\n-        match *self {\n+        match self.kind {\n             BinOp(Plus) | BinOpEq(Plus) => true,\n             _ => false,\n         }\n     }\n-}\n \n-impl Token {\n     /// Returns `true` if the token can appear at the start of an expression.\n     crate fn can_begin_expr(&self) -> bool {\n         match self.kind {\n@@ -310,12 +308,10 @@ impl Token {\n             _ => false,\n         }\n     }\n-}\n \n-impl TokenKind {\n     /// Returns `true` if the token can appear at the start of a const param.\n-    pub fn can_begin_const_arg(&self) -> bool {\n-        match self {\n+    crate fn can_begin_const_arg(&self) -> bool {\n+        match self.kind {\n             OpenDelim(Brace) => true,\n             Interpolated(ref nt) => match **nt {\n                 NtExpr(..) => true,\n@@ -326,9 +322,7 @@ impl TokenKind {\n             _ => self.can_begin_literal_or_bool(),\n         }\n     }\n-}\n \n-impl Token {\n     /// Returns `true` if the token can appear at the start of a generic bound.\n     crate fn can_begin_bound(&self) -> bool {\n         self.is_path_start() || self.is_lifetime() || self.is_keyword(kw::For) ||\n@@ -340,17 +334,19 @@ impl TokenKind {\n     pub fn lit(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> TokenKind {\n         Literal(Lit::new(kind, symbol, suffix))\n     }\n+}\n \n+impl Token {\n     /// Returns `true` if the token is any literal\n     crate fn is_lit(&self) -> bool {\n-        match *self {\n+        match self.kind {\n             Literal(..) => true,\n             _           => false,\n         }\n     }\n \n     crate fn expect_lit(&self) -> Lit {\n-        match *self {\n+        match self.kind {\n             Literal(lit) => lit,\n             _=> panic!(\"`expect_lit` called on non-literal\"),\n         }\n@@ -359,7 +355,7 @@ impl TokenKind {\n     /// Returns `true` if the token is any literal, a minus (which can prefix a literal,\n     /// for example a '-42', or one of the boolean idents).\n     crate fn can_begin_literal_or_bool(&self) -> bool {\n-        match *self {\n+        match self.kind {\n             Literal(..)  => true,\n             BinOp(Minus) => true,\n             Ident(name, false) if name == kw::True => true,\n@@ -371,9 +367,7 @@ impl TokenKind {\n             _            => false,\n         }\n     }\n-}\n \n-impl Token {\n     /// Returns an identifier if this token is an identifier.\n     pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n         match self.kind {\n@@ -397,49 +391,25 @@ impl Token {\n             _ => None,\n         }\n     }\n-}\n \n-impl TokenKind {\n-    /// Returns an identifier name if this token is an identifier.\n-    pub fn ident_name(&self) -> Option<(ast::Name, /* is_raw */ bool)> {\n-        match *self {\n-            Ident(name, is_raw) => Some((name, is_raw)),\n-            Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => Some((ident.name, is_raw)),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-    /// Returns a lifetime name if this token is a lifetime.\n-    pub fn lifetime_name(&self) -> Option<ast::Name> {\n-        match *self {\n-            Lifetime(name) => Some(name),\n-            Interpolated(ref nt) => match **nt {\n-                NtLifetime(ident) => Some(ident.name),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n     /// Returns `true` if the token is an identifier.\n     pub fn is_ident(&self) -> bool {\n-        self.ident_name().is_some()\n+        self.ident().is_some()\n     }\n     /// Returns `true` if the token is a lifetime.\n     crate fn is_lifetime(&self) -> bool {\n-        self.lifetime_name().is_some()\n+        self.lifetime().is_some()\n     }\n \n     /// Returns `true` if the token is a identifier whose name is the given\n     /// string slice.\n     crate fn is_ident_named(&self, name: Symbol) -> bool {\n-        self.ident_name().map_or(false, |(ident_name, _)| ident_name == name)\n+        self.ident().map_or(false, |(ident, _)| ident.name == name)\n     }\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt) = *self {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtPath(..) = **nt {\n                 return true;\n             }\n@@ -456,33 +426,27 @@ impl TokenKind {\n     crate fn is_qpath_start(&self) -> bool {\n         self == &Lt || self == &BinOp(Shl)\n     }\n-}\n \n-impl Token {\n     crate fn is_path_start(&self) -> bool {\n         self == &ModSep || self.is_qpath_start() || self.is_path() ||\n         self.is_path_segment_keyword() || self.is_ident() && !self.is_reserved_ident()\n     }\n-}\n \n-impl TokenKind {\n     /// Returns `true` if the token is a given keyword, `kw`.\n     pub fn is_keyword(&self, kw: Symbol) -> bool {\n-        self.ident_name().map(|(name, is_raw)| name == kw && !is_raw).unwrap_or(false)\n+        self.ident().map(|(id, is_raw)| id.name == kw && !is_raw).unwrap_or(false)\n     }\n \n-    pub fn is_path_segment_keyword(&self) -> bool {\n-        match self.ident_name() {\n-            Some((name, false)) => name.is_path_segment_keyword(),\n+    crate fn is_path_segment_keyword(&self) -> bool {\n+        match self.ident() {\n+            Some((id, false)) => id.is_path_segment_keyword(),\n             _ => false,\n         }\n     }\n-}\n \n-impl Token {\n     // Returns true for reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n-    pub fn is_special_ident(&self) -> bool {\n+    crate fn is_special_ident(&self) -> bool {\n         match self.ident() {\n             Some((id, false)) => id.is_special(),\n             _ => false,\n@@ -512,55 +476,53 @@ impl Token {\n             _ => false,\n         }\n     }\n-}\n \n-impl TokenKind {\n-    crate fn glue(self, joint: TokenKind) -> Option<TokenKind> {\n-        Some(match self {\n-            Eq => match joint {\n+    crate fn glue(self, joint: Token) -> Option<Token> {\n+        let kind = match self.kind {\n+            Eq => match joint.kind {\n                 Eq => EqEq,\n                 Gt => FatArrow,\n                 _ => return None,\n             },\n-            Lt => match joint {\n+            Lt => match joint.kind {\n                 Eq => Le,\n                 Lt => BinOp(Shl),\n                 Le => BinOpEq(Shl),\n                 BinOp(Minus) => LArrow,\n                 _ => return None,\n             },\n-            Gt => match joint {\n+            Gt => match joint.kind {\n                 Eq => Ge,\n                 Gt => BinOp(Shr),\n                 Ge => BinOpEq(Shr),\n                 _ => return None,\n             },\n-            Not => match joint {\n+            Not => match joint.kind {\n                 Eq => Ne,\n                 _ => return None,\n             },\n-            BinOp(op) => match joint {\n+            BinOp(op) => match joint.kind {\n                 Eq => BinOpEq(op),\n                 BinOp(And) if op == And => AndAnd,\n                 BinOp(Or) if op == Or => OrOr,\n                 Gt if op == Minus => RArrow,\n                 _ => return None,\n             },\n-            Dot => match joint {\n+            Dot => match joint.kind {\n                 Dot => DotDot,\n                 DotDot => DotDotDot,\n                 _ => return None,\n             },\n-            DotDot => match joint {\n+            DotDot => match joint.kind {\n                 Dot => DotDotDot,\n                 Eq => DotDotEq,\n                 _ => return None,\n             },\n-            Colon => match joint {\n+            Colon => match joint.kind {\n                 Colon => ModSep,\n                 _ => return None,\n             },\n-            SingleQuote => match joint {\n+            SingleQuote => match joint.kind {\n                 Ident(name, false) => Lifetime(Symbol::intern(&format!(\"'{}\", name))),\n                 _ => return None,\n             },\n@@ -570,9 +532,13 @@ impl TokenKind {\n             Question | OpenDelim(..) | CloseDelim(..) |\n             Literal(..) | Ident(..) | Lifetime(..) | Interpolated(..) | DocComment(..) |\n             Whitespace | Comment | Shebang(..) | Eof => return None,\n-        })\n+        };\n+\n+        Some(Token::new(kind, self.span.to(joint.span)))\n     }\n+}\n \n+impl TokenKind {\n     /// Returns tokens that are likely to be typed accidentally instead of the current token.\n     /// Enables better error recovery when the wrong token is found.\n     crate fn similar_tokens(&self) -> Option<Vec<TokenKind>> {\n@@ -582,14 +548,16 @@ impl TokenKind {\n             _ => None\n         }\n     }\n+}\n \n+impl Token {\n     // See comments in `Nonterminal::to_tokenstream` for why we care about\n     // *probably* equal here rather than actual equality\n     crate fn probably_equal_for_proc_macro(&self, other: &TokenKind) -> bool {\n-        if mem::discriminant(self) != mem::discriminant(other) {\n+        if mem::discriminant(&self.kind) != mem::discriminant(other) {\n             return false\n         }\n-        match (self, other) {\n+        match (&self.kind, other) {\n             (&Eq, &Eq) |\n             (&Lt, &Lt) |\n             (&Le, &Le) |\n@@ -641,9 +609,7 @@ impl TokenKind {\n             _ => panic!(\"forgot to add a token?\"),\n         }\n     }\n-}\n \n-impl Token {\n     crate fn new(kind: TokenKind, span: Span) -> Self {\n         Token { kind, span }\n     }"}, {"sha": "d46d2f549c09bb09625fcd1336118cc531d5ee1a", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -430,11 +430,10 @@ impl TokenStreamBuilder {\n         let last_tree_if_joint = self.0.last().and_then(TokenStream::last_tree_if_joint);\n         if let Some(TokenTree::Token(last_token)) = last_tree_if_joint {\n             if let Some((TokenTree::Token(token), is_joint)) = stream.first_tree_and_joint() {\n-                if let Some(glued_tok) = last_token.kind.glue(token.kind) {\n+                if let Some(glued_tok) = last_token.glue(token) {\n                     let last_stream = self.0.pop().unwrap();\n                     self.push_all_but_last_tree(&last_stream);\n-                    let glued_span = last_token.span.to(token.span);\n-                    let glued_tt = TokenTree::token(glued_tok, glued_span);\n+                    let glued_tt = TokenTree::Token(glued_tok);\n                     let glued_tokenstream = TokenStream::new(vec![(glued_tt, is_joint)]);\n                     self.0.push(glued_tokenstream);\n                     self.push_all_but_first_tree(&stream);"}, {"sha": "69dd96625cc020d694e9aaa039f51658237745ab", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ca3c2f881fc4bc51bfa92f1adcd1b845b812534/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=0ca3c2f881fc4bc51bfa92f1adcd1b845b812534", "patch": "@@ -1,4 +1,4 @@\n-use crate::parse::token::{self, TokenKind, BinOpToken};\n+use crate::parse::token::{self, Token, BinOpToken};\n use crate::symbol::kw;\n use crate::ast::{self, BinOpKind};\n \n@@ -69,9 +69,9 @@ pub enum Fixity {\n \n impl AssocOp {\n     /// Creates a new AssocOP from a token\n-    pub fn from_token(t: &TokenKind) -> Option<AssocOp> {\n+    pub fn from_token(t: &Token) -> Option<AssocOp> {\n         use AssocOp::*;\n-        match *t {\n+        match t.kind {\n             token::BinOpEq(k) => Some(AssignOp(k)),\n             token::Eq => Some(Assign),\n             token::BinOp(BinOpToken::Star) => Some(Multiply),"}]}