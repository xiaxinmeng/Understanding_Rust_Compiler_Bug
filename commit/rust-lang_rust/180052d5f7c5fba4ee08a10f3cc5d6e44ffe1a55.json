{"sha": "180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MDA1MmQ1ZjdjNWZiYTRlZTA4YTEwZjNjYzVkNmU0NGZmZTFhNTU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-20T05:23:47Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-24T09:51:09Z"}, "message": "Rename `universe_size` as `domain_size`.\n\nBecause `domain` is a more obvious term than `universe` for this\nconcept.", "tree": {"sha": "7130b7acc84de3d9e8d1be2d61d724c02ddf5067", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7130b7acc84de3d9e8d1be2d61d724c02ddf5067"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55", "html_url": "https://github.com/rust-lang/rust/commit/180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63d66494aff57411bfec1dd2a3a5f1af900feab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/63d66494aff57411bfec1dd2a3a5f1af900feab6", "html_url": "https://github.com/rust-lang/rust/commit/63d66494aff57411bfec1dd2a3a5f1af900feab6"}], "stats": {"total": 68, "additions": 32, "deletions": 36}, "files": [{"sha": "d4da1bb3601df9bb8cdfa942df0b453d1740e075", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=180052d5f7c5fba4ee08a10f3cc5d6e44ffe1a55", "patch": "@@ -68,34 +68,34 @@ impl<T: Idx> fmt::Debug for IdxSet<T> {\n }\n \n impl<T: Idx> IdxSet<T> {\n-    fn new(init: Word, universe_size: usize) -> Self {\n-        let num_words = (universe_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n+    fn new(init: Word, domain_size: usize) -> Self {\n+        let num_words = (domain_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n         IdxSet {\n             _pd: Default::default(),\n             bits: vec![init; num_words],\n         }\n     }\n \n-    /// Creates set holding every element whose index falls in range 0..universe_size.\n-    pub fn new_filled(universe_size: usize) -> Self {\n-        let mut result = Self::new(!0, universe_size);\n-        result.trim_to(universe_size);\n+    /// Creates set holding every element whose index falls in range 0..domain_size.\n+    pub fn new_filled(domain_size: usize) -> Self {\n+        let mut result = Self::new(!0, domain_size);\n+        result.trim_to(domain_size);\n         result\n     }\n \n     /// Creates set holding no elements.\n-    pub fn new_empty(universe_size: usize) -> Self {\n-        Self::new(0, universe_size)\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        Self::new(0, domain_size)\n     }\n \n     /// Duplicates as a hybrid set.\n     pub fn to_hybrid(&self) -> HybridIdxSet<T> {\n-        // This universe_size may be slightly larger than the one specified\n+        // This domain_size may be slightly larger than the one specified\n         // upon creation, due to rounding up to a whole word. That's ok.\n-        let universe_size = self.bits.len() * BITS_PER_WORD;\n+        let domain_size = self.bits.len() * BITS_PER_WORD;\n \n         // Note: we currently don't bother trying to make a Sparse set.\n-        HybridIdxSet::Dense(self.to_owned(), universe_size)\n+        HybridIdxSet::Dense(self.to_owned(), domain_size)\n     }\n \n     /// Removes all elements\n@@ -105,29 +105,29 @@ impl<T: Idx> IdxSet<T> {\n         }\n     }\n \n-    /// Sets all elements up to `universe_size`\n-    pub fn set_up_to(&mut self, universe_size: usize) {\n+    /// Sets all elements up to `domain_size`\n+    pub fn set_up_to(&mut self, domain_size: usize) {\n         for b in &mut self.bits {\n             *b = !0;\n         }\n-        self.trim_to(universe_size);\n+        self.trim_to(domain_size);\n     }\n \n-    /// Clear all elements above `universe_size`.\n-    fn trim_to(&mut self, universe_size: usize) {\n+    /// Clear all elements above `domain_size`.\n+    fn trim_to(&mut self, domain_size: usize) {\n         // `trim_block` is the first block where some bits have\n         // to be cleared.\n-        let trim_block = universe_size / BITS_PER_WORD;\n+        let trim_block = domain_size / BITS_PER_WORD;\n \n         // all the blocks above it have to be completely cleared.\n         if trim_block < self.bits.len() {\n             for b in &mut self.bits[trim_block+1..] {\n                 *b = 0;\n             }\n \n-            // at that block, the `universe_size % BITS_PER_WORD` lsbs\n+            // at that block, the `domain_size % BITS_PER_WORD` LSBs\n             // should remain.\n-            let remaining_bits = universe_size % BITS_PER_WORD;\n+            let remaining_bits = domain_size % BITS_PER_WORD;\n             let mask = (1<<remaining_bits)-1;\n             self.bits[trim_block] &= mask;\n         }\n@@ -293,8 +293,8 @@ impl<T: Idx> SparseIdxSet<T> {\n         }\n     }\n \n-    fn to_dense(&self, universe_size: usize) -> IdxSet<T> {\n-        let mut dense = IdxSet::new_empty(universe_size);\n+    fn to_dense(&self, domain_size: usize) -> IdxSet<T> {\n+        let mut dense = IdxSet::new_empty(domain_size);\n         for elem in self.0.iter() {\n             dense.add(elem);\n         }\n@@ -323,28 +323,24 @@ impl<'a, T: Idx> Iterator for SparseIter<'a, T> {\n /// Like IdxSet, but with a hybrid representation: sparse when there are few\n /// elements in the set, but dense when there are many. It's especially\n /// efficient for sets that typically have a small number of elements, but a\n-/// large `universe_size`, and are cleared frequently.\n+/// large `domain_size`, and are cleared frequently.\n #[derive(Clone, Debug)]\n pub enum HybridIdxSet<T: Idx> {\n     Sparse(SparseIdxSet<T>, usize),\n     Dense(IdxSet<T>, usize),\n }\n \n impl<T: Idx> HybridIdxSet<T> {\n-    pub fn new_empty(universe_size: usize) -> Self {\n-        HybridIdxSet::Sparse(SparseIdxSet::new(), universe_size)\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        HybridIdxSet::Sparse(SparseIdxSet::new(), domain_size)\n     }\n \n-    fn universe_size(&mut self) -> usize {\n-        match *self {\n+    pub fn clear(&mut self) {\n+        let domain_size = match *self {\n             HybridIdxSet::Sparse(_, size) => size,\n             HybridIdxSet::Dense(_, size) => size,\n-        }\n-    }\n-\n-    pub fn clear(&mut self) {\n-        let universe_size = self.universe_size();\n-        *self = HybridIdxSet::new_empty(universe_size);\n+        };\n+        *self = HybridIdxSet::new_empty(domain_size);\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n@@ -374,11 +370,11 @@ impl<T: Idx> HybridIdxSet<T> {\n                 //        appease the borrow checker.\n                 let dummy = HybridIdxSet::Sparse(SparseIdxSet::new(), 0);\n                 match mem::replace(self, dummy) {\n-                    HybridIdxSet::Sparse(sparse, universe_size) => {\n-                        let mut dense = sparse.to_dense(universe_size);\n+                    HybridIdxSet::Sparse(sparse, domain_size) => {\n+                        let mut dense = sparse.to_dense(domain_size);\n                         let changed = dense.add(elem);\n                         assert!(changed);\n-                        mem::replace(self, HybridIdxSet::Dense(dense, universe_size));\n+                        mem::replace(self, HybridIdxSet::Dense(dense, domain_size));\n                         changed\n                     }\n                     _ => panic!(\"impossible\"),\n@@ -401,7 +397,7 @@ impl<T: Idx> HybridIdxSet<T> {\n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> IdxSet<T> {\n         match self {\n-            HybridIdxSet::Sparse(sparse, universe_size) => sparse.to_dense(universe_size),\n+            HybridIdxSet::Sparse(sparse, domain_size) => sparse.to_dense(domain_size),\n             HybridIdxSet::Dense(dense, _) => dense,\n         }\n     }"}]}