{"sha": "ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNDlmYmUwYTFmNmFjYzEzNTJmNjYyOGMzNmJiN2RmZTNhOTUwZTU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T12:02:53Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-31T12:52:55Z"}, "message": "Complete `self.` prefixed fields and methods inside methods", "tree": {"sha": "ce49d1f51186dd6f455bccadb73a577988ff457a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce49d1f51186dd6f455bccadb73a577988ff457a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "html_url": "https://github.com/rust-lang/rust/commit/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7cbb49057c4495307d91f5db32465c29c175124", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7cbb49057c4495307d91f5db32465c29c175124", "html_url": "https://github.com/rust-lang/rust/commit/d7cbb49057c4495307d91f5db32465c29c175124"}], "stats": {"total": 219, "additions": 165, "deletions": 54}, "files": [{"sha": "0f0553a65c7af67631a0b88c5386d9c42aca303c", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "patch": "@@ -18,8 +18,10 @@ pub(crate) mod unqualified_path;\n \n use std::iter;\n \n-use hir::known;\n+use either::Either;\n+use hir::{known, HasVisibility};\n use ide_db::SymbolKind;\n+use rustc_hash::FxHashSet;\n \n use crate::{\n     item::{Builder, CompletionKind},\n@@ -69,18 +71,25 @@ impl Completions {\n         items.into_iter().for_each(|item| self.add(item.into()))\n     }\n \n-    pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &hir::Type) {\n-        let item = render_field(RenderContext::new(ctx), field, ty);\n+    pub(crate) fn add_field(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        receiver: Option<String>,\n+        field: hir::Field,\n+        ty: &hir::Type,\n+    ) {\n+        let item = render_field(RenderContext::new(ctx), receiver, field, ty);\n         self.add(item);\n     }\n \n     pub(crate) fn add_tuple_field(\n         &mut self,\n         ctx: &CompletionContext,\n+        receiver: Option<String>,\n         field: usize,\n         ty: &hir::Type,\n     ) {\n-        let item = render_tuple_field(RenderContext::new(ctx), field, ty);\n+        let item = render_tuple_field(RenderContext::new(ctx), receiver, field, ty);\n         self.add(item);\n     }\n \n@@ -132,9 +141,11 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         func: hir::Function,\n+        receiver: Option<String>,\n         local_name: Option<hir::Name>,\n     ) {\n-        if let Some(item) = render_method(RenderContext::new(ctx), None, local_name, func) {\n+        if let Some(item) = render_method(RenderContext::new(ctx), None, receiver, local_name, func)\n+        {\n             self.add(item)\n         }\n     }\n@@ -243,3 +254,44 @@ fn complete_enum_variants(\n         }\n     }\n }\n+\n+fn complete_fields(\n+    ctx: &CompletionContext,\n+    receiver: &hir::Type,\n+    mut f: impl FnMut(Either<hir::Field, usize>, hir::Type),\n+) {\n+    for receiver in receiver.autoderef(ctx.db) {\n+        for (field, ty) in receiver.fields(ctx.db) {\n+            if ctx.scope.module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n+                // Skip private field. FIXME: If the definition location of the\n+                // field is editable, we should show the completion\n+                continue;\n+            }\n+            f(Either::Left(field), ty);\n+        }\n+        for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n+            // FIXME: Handle visibility\n+            f(Either::Right(i), ty);\n+        }\n+    }\n+}\n+\n+fn complete_methods(\n+    ctx: &CompletionContext,\n+    receiver: &hir::Type,\n+    mut f: impl FnMut(hir::Function),\n+) {\n+    if let Some(krate) = ctx.krate {\n+        let mut seen_methods = FxHashSet::default();\n+        let traits_in_scope = ctx.scope.traits_in_scope();\n+        receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n+            if func.self_param(ctx.db).is_some()\n+                && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n+                && seen_methods.insert(func.name(ctx.db))\n+            {\n+                f(func);\n+            }\n+            None::<()>\n+        });\n+    }\n+}"}, {"sha": "93f7bd6d4e3e6f8398363836b83d5da12b32d9fc", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "patch": "@@ -1,7 +1,6 @@\n //! Completes references after dot (fields and method calls).\n \n-use hir::{HasVisibility, Type};\n-use rustc_hash::FxHashSet;\n+use either::Either;\n \n use crate::{context::CompletionContext, Completions};\n \n@@ -20,42 +19,12 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     if ctx.is_call {\n         cov_mark::hit!(test_no_struct_field_completion_for_method_call);\n     } else {\n-        complete_fields(acc, ctx, &receiver_ty);\n-    }\n-    complete_methods(acc, ctx, &receiver_ty);\n-}\n-\n-fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n-    for receiver in receiver.autoderef(ctx.db) {\n-        for (field, ty) in receiver.fields(ctx.db) {\n-            if ctx.scope.module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n-                // Skip private field. FIXME: If the definition location of the\n-                // field is editable, we should show the completion\n-                continue;\n-            }\n-            acc.add_field(ctx, field, &ty);\n-        }\n-        for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n-            // FIXME: Handle visibility\n-            acc.add_tuple_field(ctx, i, &ty);\n-        }\n-    }\n-}\n-\n-fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n-    if let Some(krate) = ctx.krate {\n-        let mut seen_methods = FxHashSet::default();\n-        let traits_in_scope = ctx.scope.traits_in_scope();\n-        receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n-            if func.self_param(ctx.db).is_some()\n-                && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n-                && seen_methods.insert(func.name(ctx.db))\n-            {\n-                acc.add_method(ctx, func, None);\n-            }\n-            None::<()>\n+        super::complete_fields(ctx, &receiver_ty, |field, ty| match field {\n+            Either::Left(field) => acc.add_field(ctx, None, field, &ty),\n+            Either::Right(tuple_idx) => acc.add_tuple_field(ctx, None, tuple_idx, &ty),\n         });\n     }\n+    super::complete_methods(ctx, &receiver_ty, |func| acc.add_method(ctx, func, None, None));\n }\n \n #[cfg(test)]"}, {"sha": "0ac47cdbe7eb8b273609a6ca1f5bbeacc4e42b1c", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "patch": "@@ -39,7 +39,7 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n     };\n \n     for (field, ty) in missing_fields {\n-        acc.add_field(ctx, field, &ty);\n+        acc.add_field(ctx, None, field, &ty);\n     }\n \n     Some(())"}, {"sha": "573a399964f1f720bd0b1e2c5e65a66836000926", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "patch": "@@ -11,6 +11,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     if ctx.is_path_disallowed() || ctx.expects_item() {\n         return;\n     }\n+\n     if ctx.expects_assoc_item() {\n         ctx.scope.process_all_names(&mut |name, def| {\n             if let ScopeDef::MacroDef(macro_def) = def {\n@@ -32,6 +33,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         });\n         return;\n     }\n+\n     if let Some(hir::Adt::Enum(e)) =\n         ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n     {\n@@ -45,6 +47,22 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n             cov_mark::hit!(skip_lifetime_completion);\n             return;\n         }\n+        if let ScopeDef::Local(local) = &res {\n+            if local.is_self(ctx.db) {\n+                let ty = local.ty(ctx.db);\n+                super::complete_fields(ctx, &ty, |field, ty| match field {\n+                    either::Either::Left(field) => {\n+                        acc.add_field(ctx, Some(name.to_string()), field, &ty)\n+                    }\n+                    either::Either::Right(tuple_idx) => {\n+                        acc.add_tuple_field(ctx, Some(name.to_string()), tuple_idx, &ty)\n+                    }\n+                });\n+                super::complete_methods(ctx, &ty, |func| {\n+                    acc.add_method(ctx, func, Some(name.to_string()), None)\n+                });\n+            }\n+        }\n         acc.add_resolution(ctx, name, &res);\n     });\n }\n@@ -375,6 +393,36 @@ fn foo() {\n         );\n     }\n \n+    #[test]\n+    fn completes_qualified_fields_and_methods_in_methods() {\n+        check(\n+            r#\"\n+struct Foo { field: i32 }\n+\n+impl Foo { fn foo(&self) { $0 } }\"#,\n+            expect![[r#\"\n+                fd self.field i32\n+                me self.foo() fn(&self)\n+                lc self       &Foo\n+                sp Self\n+                st Foo\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo { fn foo(&mut self) { $0 } }\"#,\n+            expect![[r#\"\n+                fd self.0     i32\n+                me self.foo() fn(&mut self)\n+                lc self       &mut Foo\n+                sp Self\n+                st Foo\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn completes_prelude() {\n         check("}, {"sha": "bf59ff57b1b2c9768e692f238f62f87ab6782851", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "patch": "@@ -25,18 +25,20 @@ use crate::{\n \n pub(crate) fn render_field<'a>(\n     ctx: RenderContext<'a>,\n+    receiver: Option<String>,\n     field: hir::Field,\n     ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).render_field(field, ty)\n+    Render::new(ctx).render_field(receiver, field, ty)\n }\n \n pub(crate) fn render_tuple_field<'a>(\n     ctx: RenderContext<'a>,\n+    receiver: Option<String>,\n     field: usize,\n     ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).render_tuple_field(field, ty)\n+    Render::new(ctx).render_tuple_field(receiver, field, ty)\n }\n \n pub(crate) fn render_resolution<'a>(\n@@ -126,11 +128,19 @@ impl<'a> Render<'a> {\n         Render { ctx }\n     }\n \n-    fn render_field(&self, field: hir::Field, ty: &hir::Type) -> CompletionItem {\n+    fn render_field(\n+        &self,\n+        receiver: Option<String>,\n+        field: hir::Field,\n+        ty: &hir::Type,\n+    ) -> CompletionItem {\n         let is_deprecated = self.ctx.is_deprecated(field);\n         let name = field.name(self.ctx.db()).to_string();\n-        let mut item =\n-            CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), name.clone());\n+        let mut item = CompletionItem::new(\n+            CompletionKind::Reference,\n+            self.ctx.source_range(),\n+            receiver.map_or_else(|| name.to_string(), |receiver| format!(\"{}.{}\", receiver, name)),\n+        );\n         item.kind(SymbolKind::Field)\n             .detail(ty.display(self.ctx.db()).to_string())\n             .set_documentation(field.docs(self.ctx.db()))\n@@ -151,11 +161,17 @@ impl<'a> Render<'a> {\n         item.build()\n     }\n \n-    fn render_tuple_field(&self, field: usize, ty: &hir::Type) -> CompletionItem {\n+    fn render_tuple_field(\n+        &self,\n+        receiver: Option<String>,\n+        field: usize,\n+        ty: &hir::Type,\n+    ) -> CompletionItem {\n         let mut item = CompletionItem::new(\n             CompletionKind::Reference,\n             self.ctx.source_range(),\n-            field.to_string(),\n+            receiver\n+                .map_or_else(|| field.to_string(), |receiver| format!(\"{}.{}\", receiver, field)),\n         );\n \n         item.kind(SymbolKind::Field).detail(ty.display(self.ctx.db()).to_string());"}, {"sha": "b3ba6114d9138e21eb045330eb11c461348687ca", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=ca49fbe0a1f6acc1352f6628c36bb7dfe3a950e5", "patch": "@@ -20,23 +20,25 @@ pub(crate) fn render_fn<'a>(\n     fn_: hir::Function,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_fn\");\n-    Some(FunctionRender::new(ctx, local_name, fn_, false)?.render(import_to_add))\n+    Some(FunctionRender::new(ctx, None, local_name, fn_, false)?.render(import_to_add))\n }\n \n pub(crate) fn render_method<'a>(\n     ctx: RenderContext<'a>,\n     import_to_add: Option<ImportEdit>,\n+    receiver: Option<String>,\n     local_name: Option<hir::Name>,\n     fn_: hir::Function,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_method\");\n-    Some(FunctionRender::new(ctx, local_name, fn_, true)?.render(import_to_add))\n+    Some(FunctionRender::new(ctx, receiver, local_name, fn_, true)?.render(import_to_add))\n }\n \n #[derive(Debug)]\n struct FunctionRender<'a> {\n     ctx: RenderContext<'a>,\n     name: String,\n+    receiver: Option<String>,\n     func: hir::Function,\n     ast_node: Fn,\n     is_method: bool,\n@@ -45,18 +47,22 @@ struct FunctionRender<'a> {\n impl<'a> FunctionRender<'a> {\n     fn new(\n         ctx: RenderContext<'a>,\n+        receiver: Option<String>,\n         local_name: Option<hir::Name>,\n         fn_: hir::Function,\n         is_method: bool,\n     ) -> Option<FunctionRender<'a>> {\n         let name = local_name.unwrap_or_else(|| fn_.name(ctx.db())).to_string();\n         let ast_node = fn_.source(ctx.db())?.value;\n \n-        Some(FunctionRender { ctx, name, func: fn_, ast_node, is_method })\n+        Some(FunctionRender { ctx, name, receiver, func: fn_, ast_node, is_method })\n     }\n \n-    fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n+    fn render(mut self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n         let params = self.params();\n+        if let Some(receiver) = &self.receiver {\n+            self.name = format!(\"{}.{}\", receiver, &self.name)\n+        }\n         let mut item = CompletionItem::new(\n             CompletionKind::Reference,\n             self.ctx.source_range(),\n@@ -148,7 +154,7 @@ impl<'a> FunctionRender<'a> {\n         };\n \n         let mut params_pats = Vec::new();\n-        let params_ty = if self.ctx.completion.dot_receiver.is_some() {\n+        let params_ty = if self.ctx.completion.dot_receiver.is_some() || self.receiver.is_some() {\n             self.func.method_params(self.ctx.db()).unwrap_or_default()\n         } else {\n             if let Some(s) = ast_params.self_param() {\n@@ -253,6 +259,26 @@ impl S {\n fn bar(s: &S) {\n     s.foo(${1:x})$0\n }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"self.foo\",\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {\n+        $0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {\n+        self.foo(${1:x})$0\n+    }\n+}\n \"#,\n         );\n     }"}]}