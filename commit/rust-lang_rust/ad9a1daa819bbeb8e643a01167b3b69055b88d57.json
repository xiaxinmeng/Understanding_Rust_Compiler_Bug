{"sha": "ad9a1daa819bbeb8e643a01167b3b69055b88d57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOWExZGFhODE5YmJlYjhlNjQzYTAxMTY3YjNiNjkwNTViODhkNTc=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-09-12T15:17:58Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-09-12T18:46:38Z"}, "message": "Add -C remark for LLVM optimization remarks\n\nFixes #17116.", "tree": {"sha": "94cd15f43986278e477b85eb31ac3c60cebe8f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94cd15f43986278e477b85eb31ac3c60cebe8f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad9a1daa819bbeb8e643a01167b3b69055b88d57", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad9a1daa819bbeb8e643a01167b3b69055b88d57", "html_url": "https://github.com/rust-lang/rust/commit/ad9a1daa819bbeb8e643a01167b3b69055b88d57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad9a1daa819bbeb8e643a01167b3b69055b88d57/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "225353d8bbad5730c941fc88e854627004e74f2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/225353d8bbad5730c941fc88e854627004e74f2c", "html_url": "https://github.com/rust-lang/rust/commit/225353d8bbad5730c941fc88e854627004e74f2c"}], "stats": {"total": 310, "additions": 297, "deletions": 13}, "files": [{"sha": "53bdf500a217b0d407d44cc000a65f8fbabcfc96", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=ad9a1daa819bbeb8e643a01167b3b69055b88d57", "patch": "@@ -11,11 +11,11 @@\n use back::lto;\n use back::link::{get_cc_prog, remove};\n use driver::driver::{CrateTranslation, ModuleTranslation, OutputFilenames};\n-use driver::config::NoDebugInfo;\n+use driver::config::{NoDebugInfo, Passes, AllPasses};\n use driver::session::Session;\n use driver::config;\n use llvm;\n-use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n+use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use util::common::time;\n use syntax::abi;\n use syntax::codemap;\n@@ -28,9 +28,10 @@ use std::io::fs;\n use std::iter::Unfold;\n use std::ptr;\n use std::str;\n+use std::mem;\n use std::sync::{Arc, Mutex};\n use std::task::TaskBuilder;\n-use libc::{c_uint, c_int};\n+use libc::{c_uint, c_int, c_void};\n \n \n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n@@ -311,21 +312,49 @@ struct CodegenContext<'a> {\n     lto_ctxt: Option<(&'a Session, &'a [String])>,\n     // Handler to use for diagnostics produced during codegen.\n     handler: &'a Handler,\n+    // LLVM optimizations for which we want to print remarks.\n+    remark: Passes,\n }\n \n impl<'a> CodegenContext<'a> {\n-    fn new(handler: &'a Handler) -> CodegenContext<'a> {\n-        CodegenContext {\n-            lto_ctxt: None,\n-            handler: handler,\n-        }\n-    }\n-\n     fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n         CodegenContext {\n             lto_ctxt: Some((sess, reachable)),\n             handler: sess.diagnostic().handler(),\n+            remark: sess.opts.cg.remark.clone(),\n+        }\n+    }\n+}\n+\n+struct DiagHandlerFreeVars<'a> {\n+    llcx: ContextRef,\n+    cgcx: &'a CodegenContext<'a>,\n+}\n+\n+unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n+    let DiagHandlerFreeVars { llcx, cgcx }\n+        = *mem::transmute::<_, *const DiagHandlerFreeVars>(user);\n+\n+    match llvm::diagnostic::Diagnostic::unpack(info) {\n+        llvm::diagnostic::Optimization(opt) => {\n+            let pass_name = CString::new(opt.pass_name, false);\n+            let pass_name = pass_name.as_str().expect(\"got a non-UTF8 pass name from LLVM\");\n+            let enabled = match cgcx.remark {\n+                AllPasses => true,\n+                Passes(ref v) => v.iter().any(|s| s.as_slice() == pass_name),\n+            };\n+\n+            if enabled {\n+                let loc = llvm::debug_loc_to_string(llcx, opt.debug_loc);\n+                cgcx.handler.note(format!(\"optimization {:s} for {:s} at {:s}: {:s}\",\n+                                          opt.kind.describe(),\n+                                          pass_name,\n+                                          if loc.is_empty() { \"[unknown]\" } else { loc.as_slice() },\n+                                          llvm::twine_to_string(opt.message)).as_slice());\n+            }\n         }\n+\n+        _ => (),\n     }\n }\n \n@@ -338,6 +367,17 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     let ModuleTranslation { llmod, llcx } = mtrans;\n     let tm = config.tm;\n \n+    // llcx doesn't outlive this function, so we can put this on the stack.\n+    let fv = DiagHandlerFreeVars {\n+        llcx: llcx,\n+        cgcx: cgcx,\n+    };\n+    if !cgcx.remark.is_empty() {\n+        llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler,\n+                                              &fv as *const DiagHandlerFreeVars\n+                                                  as *mut c_void);\n+    }\n+\n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n         output_names.with_extension(ext.as_slice()).with_c_str(|buf| {\n@@ -785,13 +825,18 @@ fn run_work_multithreaded(sess: &Session,\n     for i in range(0, num_workers) {\n         let work_items_arc = work_items_arc.clone();\n         let diag_emitter = diag_emitter.clone();\n+        let remark = sess.opts.cg.remark.clone();\n \n         let future = TaskBuilder::new().named(format!(\"codegen-{}\", i)).try_future(proc() {\n             let diag_handler = mk_handler(box diag_emitter);\n \n             // Must construct cgcx inside the proc because it has non-Send\n             // fields.\n-            let cgcx = CodegenContext::new(&diag_handler);\n+            let cgcx = CodegenContext {\n+                lto_ctxt: None,\n+                handler: &diag_handler,\n+                remark: remark,\n+            };\n \n             loop {\n                 // Avoid holding the lock for the entire duration of the match."}, {"sha": "f7b0a178734e1bd80494d864db2cbfed8a308d22", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=ad9a1daa819bbeb8e643a01167b3b69055b88d57", "patch": "@@ -235,6 +235,21 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n                        --pretty flowgraph output\", FLOWGRAPH_PRINT_ALL))\n }\n \n+#[deriving(Clone)]\n+pub enum Passes {\n+    Passes(Vec<String>),\n+    AllPasses,\n+}\n+\n+impl Passes {\n+    pub fn is_empty(&self) -> bool {\n+        match *self {\n+            Passes(ref v) => v.is_empty(),\n+            AllPasses => false,\n+        }\n+    }\n+}\n+\n /// Declare a macro that will define all CodegenOptions fields and parsers all\n /// at once. The goal of this macro is to define an interface that can be\n /// programmatically used by the option parser in order to initialize the struct\n@@ -261,7 +276,7 @@ macro_rules! cgoptions(\n         &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n \n     mod cgsetters {\n-        use super::CodegenOptions;\n+        use super::{CodegenOptions, Passes, AllPasses};\n \n         $(\n             pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n@@ -310,6 +325,24 @@ macro_rules! cgoptions(\n                 None => false\n             }\n         }\n+\n+        fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n+            match v {\n+                Some(\"all\") => {\n+                    *slot = AllPasses;\n+                    true\n+                }\n+                v => {\n+                    let mut passes = vec!();\n+                    if parse_list(&mut passes, v) {\n+                        *slot = Passes(passes);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            }\n+        }\n     }\n ) )\n \n@@ -356,6 +389,8 @@ cgoptions!(\n          \"extra data to put in each output filename\"),\n     codegen_units: uint = (1, parse_uint,\n         \"divide crate into N units to optimize in parallel\"),\n+    remark: Passes = (Passes(Vec::new()), parse_passes,\n+        \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n )\n \n pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n@@ -744,6 +779,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n     let cg = build_codegen_options(matches);\n \n+    if !cg.remark.is_empty() && debuginfo == NoDebugInfo {\n+        early_warn(\"-C remark will not show source locations without --debuginfo\");\n+    }\n+\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| s.as_slice()) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,"}, {"sha": "6e1368ec3f90cee3ca5730890deacaf2241ec214", "filename": "src/librustc_llvm/diagnostic.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=ad9a1daa819bbeb8e643a01167b3b69055b88d57", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! LLVM diagnostic reports.\n+\n+use libc::c_char;\n+\n+use {ValueRef, TwineRef, DebugLocRef, DiagnosticInfoRef};\n+\n+pub enum OptimizationDiagnosticKind {\n+    OptimizationRemark,\n+    OptimizationMissed,\n+    OptimizationAnalysis,\n+    OptimizationFailure,\n+}\n+\n+impl OptimizationDiagnosticKind {\n+    pub fn describe(self) -> &'static str {\n+        match self {\n+            OptimizationRemark => \"remark\",\n+            OptimizationMissed => \"missed\",\n+            OptimizationAnalysis => \"analysis\",\n+            OptimizationFailure => \"failure\",\n+        }\n+    }\n+}\n+\n+pub struct OptimizationDiagnostic {\n+    pub kind: OptimizationDiagnosticKind,\n+    pub pass_name: *const c_char,\n+    pub function: ValueRef,\n+    pub debug_loc: DebugLocRef,\n+    pub message: TwineRef,\n+}\n+\n+impl OptimizationDiagnostic {\n+    unsafe fn unpack(kind: OptimizationDiagnosticKind, di: DiagnosticInfoRef)\n+            -> OptimizationDiagnostic {\n+\n+        let mut opt = OptimizationDiagnostic {\n+            kind: kind,\n+            pass_name: 0 as *const c_char,\n+            function: 0 as ValueRef,\n+            debug_loc: 0 as DebugLocRef,\n+            message: 0 as TwineRef,\n+        };\n+\n+        super::LLVMUnpackOptimizationDiagnostic(di,\n+            &mut opt.pass_name,\n+            &mut opt.function,\n+            &mut opt.debug_loc,\n+            &mut opt.message);\n+\n+        opt\n+    }\n+}\n+\n+pub enum Diagnostic {\n+    Optimization(OptimizationDiagnostic),\n+\n+    /// LLVM has other types that we do not wrap here.\n+    UnknownDiagnostic(DiagnosticInfoRef),\n+}\n+\n+impl Diagnostic {\n+    pub unsafe fn unpack(di: DiagnosticInfoRef) -> Diagnostic {\n+        let kind = super::LLVMGetDiagInfoKind(di);\n+\n+        match kind {\n+            super::DK_OptimizationRemark\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationRemark, di)),\n+\n+            super::DK_OptimizationRemarkMissed\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationMissed, di)),\n+\n+            super::DK_OptimizationRemarkAnalysis\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationAnalysis, di)),\n+\n+            super::DK_OptimizationFailure\n+                => Optimization(OptimizationDiagnostic::unpack(OptimizationFailure, di)),\n+\n+            _ => UnknownDiagnostic(di)\n+        }\n+    }\n+}"}, {"sha": "690b288043d6af856c489ee039373c6967a560b7", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ad9a1daa819bbeb8e643a01167b3b69055b88d57", "patch": "@@ -31,13 +31,14 @@ use std::c_str::ToCStr;\n use std::cell::RefCell;\n use std::{raw, mem};\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n-use libc::{c_longlong, c_ulonglong};\n+use libc::{c_longlong, c_ulonglong, c_void};\n use debuginfo::{DIBuilderRef, DIDescriptor,\n                 DIFile, DILexicalBlock, DISubprogram, DIType,\n                 DIBasicType, DIDerivedType, DICompositeType,\n                 DIVariable, DIGlobalVariable, DIArray, DISubrange};\n \n pub mod archive_ro;\n+pub mod diagnostic;\n \n pub type Opcode = u32;\n pub type Bool = c_uint;\n@@ -81,6 +82,15 @@ pub enum Linkage {\n     CommonLinkage = 14,\n }\n \n+#[repr(C)]\n+#[deriving(Show)]\n+pub enum DiagnosticSeverity {\n+    Error,\n+    Warning,\n+    Remark,\n+    Note,\n+}\n+\n #[deriving(Clone)]\n pub enum Attribute {\n     ZExtAttribute = 1 << 0,\n@@ -360,6 +370,18 @@ pub enum CodeGenModel {\n     CodeModelLarge = 5,\n }\n \n+#[repr(C)]\n+pub enum DiagnosticKind {\n+    DK_InlineAsm = 0,\n+    DK_StackSize,\n+    DK_DebugMetadataVersion,\n+    DK_SampleProfile,\n+    DK_OptimizationRemark,\n+    DK_OptimizationRemarkMissed,\n+    DK_OptimizationRemarkAnalysis,\n+    DK_OptimizationFailure,\n+}\n+\n // Opaque pointer types\n pub enum Module_opaque {}\n pub type ModuleRef = *mut Module_opaque;\n@@ -395,6 +417,14 @@ pub enum TargetMachine_opaque {}\n pub type TargetMachineRef = *mut TargetMachine_opaque;\n pub enum Archive_opaque {}\n pub type ArchiveRef = *mut Archive_opaque;\n+pub enum Twine_opaque {}\n+pub type TwineRef = *mut Twine_opaque;\n+pub enum DiagnosticInfo_opaque {}\n+pub type DiagnosticInfoRef = *mut DiagnosticInfo_opaque;\n+pub enum DebugLoc_opaque {}\n+pub type DebugLocRef = *mut DebugLoc_opaque;\n+\n+pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n \n pub mod debuginfo {\n     use super::{ValueRef};\n@@ -1918,6 +1948,24 @@ extern {\n \n     pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n                                   data: *mut *const c_char) -> c_int;\n+\n+    pub fn LLVMWriteTwineToString(T: TwineRef, s: RustStringRef);\n+\n+    pub fn LLVMContextSetDiagnosticHandler(C: ContextRef,\n+                                           Handler: DiagnosticHandler,\n+                                           DiagnosticContext: *mut c_void);\n+\n+    pub fn LLVMUnpackOptimizationDiagnostic(DI: DiagnosticInfoRef,\n+                                            pass_name_out: *mut *const c_char,\n+                                            function_out: *mut ValueRef,\n+                                            debugloc_out: *mut DebugLocRef,\n+                                            message_out: *mut TwineRef);\n+\n+    pub fn LLVMWriteDiagnosticInfoToString(DI: DiagnosticInfoRef, s: RustStringRef);\n+    pub fn LLVMGetDiagInfoSeverity(DI: DiagnosticInfoRef) -> DiagnosticSeverity;\n+    pub fn LLVMGetDiagInfoKind(DI: DiagnosticInfoRef) -> DiagnosticKind;\n+\n+    pub fn LLVMWriteDebugLocToString(C: ContextRef, DL: DebugLocRef, s: RustStringRef);\n }\n \n pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n@@ -2072,6 +2120,16 @@ pub fn build_string(f: |RustStringRef|) -> Option<String> {\n     String::from_utf8(buf.unwrap()).ok()\n }\n \n+pub unsafe fn twine_to_string(tr: TwineRef) -> String {\n+    build_string(|s| LLVMWriteTwineToString(tr, s))\n+        .expect(\"got a non-UTF8 Twine from LLVM\")\n+}\n+\n+pub unsafe fn debug_loc_to_string(c: ContextRef, tr: DebugLocRef) -> String {\n+    build_string(|s| LLVMWriteDebugLocToString(c, tr, s))\n+        .expect(\"got a non-UTF8 DebugLoc from LLVM\")\n+}\n+\n // FIXME #15460 - create a public function that actually calls our\n // static LLVM symbols. Otherwise the linker will just throw llvm\n // away.  We're just calling lots of stuff until we transitively get"}, {"sha": "7896ce2ba761a965e8c6c56d638166efa9e58083", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=ad9a1daa819bbeb8e643a01167b3b69055b88d57", "patch": "@@ -11,6 +11,8 @@\n #include \"rustllvm.h\"\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm/IR/DiagnosticInfo.h\"\n+#include \"llvm/IR/DiagnosticPrinter.h\"\n \n #if LLVM_VERSION_MINOR >= 5\n #include \"llvm/IR/CallSite.h\"\n@@ -823,3 +825,49 @@ extern \"C\" LLVMTypeRef\n LLVMRustArrayType(LLVMTypeRef ElementType, uint64_t ElementCount) {\n     return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n }\n+\n+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(Twine, LLVMTwineRef)\n+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(DebugLoc, LLVMDebugLocRef)\n+\n+extern \"C\" void\n+LLVMWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n+    raw_rust_string_ostream os(str);\n+    unwrap(T)->print(os);\n+}\n+\n+extern \"C\" void\n+LLVMUnpackOptimizationDiagnostic(\n+    LLVMDiagnosticInfoRef di,\n+    const char **pass_name_out,\n+    LLVMValueRef *function_out,\n+    LLVMDebugLocRef *debugloc_out,\n+    LLVMTwineRef *message_out)\n+{\n+    // Undefined to call this not on an optimization diagnostic!\n+    llvm::DiagnosticInfoOptimizationBase *opt\n+        = static_cast<llvm::DiagnosticInfoOptimizationBase*>(unwrap(di));\n+\n+    *pass_name_out = opt->getPassName();\n+    *function_out = wrap(&opt->getFunction());\n+    *debugloc_out = wrap(&opt->getDebugLoc());\n+    *message_out = wrap(&opt->getMsg());\n+}\n+\n+extern \"C\" void LLVMWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di, RustStringRef str) {\n+    raw_rust_string_ostream os(str);\n+    DiagnosticPrinterRawOStream dp(os);\n+    unwrap(di)->print(dp);\n+}\n+\n+extern \"C\" int LLVMGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n+    return unwrap(di)->getKind();\n+}\n+\n+extern \"C\" void LLVMWriteDebugLocToString(\n+    LLVMContextRef C,\n+    LLVMDebugLocRef dl,\n+    RustStringRef str)\n+{\n+    raw_rust_string_ostream os(str);\n+    unwrap(dl)->print(*unwrap(C), os);\n+}"}, {"sha": "54b0c2506c76b4bfb7953b1e392e67619b283f26", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/ad9a1daa819bbeb8e643a01167b3b69055b88d57/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=ad9a1daa819bbeb8e643a01167b3b69055b88d57", "patch": "@@ -71,6 +71,8 @@\n void LLVMRustSetLastError(const char*);\n \n typedef struct OpaqueRustString *RustStringRef;\n+typedef struct LLVMOpaqueTwine *LLVMTwineRef;\n+typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;\n \n extern \"C\" void\n rust_llvm_string_write_impl(RustStringRef str, const char *ptr, size_t size);"}]}