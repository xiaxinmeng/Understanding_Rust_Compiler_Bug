{"sha": "1a84cadc88e23fead7435384bfd986dc08081509", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhODRjYWRjODhlMjNmZWFkNzQzNTM4NGJmZDk4NmRjMDgwODE1MDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-26T14:08:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-26T14:08:47Z"}, "message": "Merge #6347\n\n6347: Support insertion in SyntaxRewriter r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "74c8029d3f0fca58a4ba6734a6361906540e0878", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74c8029d3f0fca58a4ba6734a6361906540e0878"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a84cadc88e23fead7435384bfd986dc08081509", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflthvCRBK7hj4Ov3rIwAAdHIIAAaCO67+7jUpub2WWDAqorwE\nDRyz1fxNcZRbSECl97sFxDOluvnoPOo1IbtM83PFF4mXrg+xqxMCPhqJi3qoLCB9\nwvAktHfmD/yrjXkBHoLyOWIuql18xIW2vay+X0tcpsJn++8Gu1855qTFJFgEjISk\nMn3LAXL50IVgz06e/9tAznjhMuxvp9KVLVo9YjHlwwP9nEa3oMF03YrtBewy6dJF\ny99BSc3IP4rsXEmJWmOCJNA6sUqsaMHhSONdzYDKGMvsHD0dkBduIVdOl2vrveev\nyetj/7jEM/N9K8uUu81jcbFAN/MXkF/QIzAMLH56JJ6+mamlI3++4wYfnKuTEEs=\n=KVPP\n-----END PGP SIGNATURE-----\n", "payload": "tree 74c8029d3f0fca58a4ba6734a6361906540e0878\nparent 29f5154d1c664c8fb1dfae45281873ed97a68a55\nparent 45860d520786a86007f2f86635b4d2f9c3b0c74e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1603721327 +0000\ncommitter GitHub <noreply@github.com> 1603721327 +0000\n\nMerge #6347\n\n6347: Support insertion in SyntaxRewriter r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a84cadc88e23fead7435384bfd986dc08081509", "html_url": "https://github.com/rust-lang/rust/commit/1a84cadc88e23fead7435384bfd986dc08081509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a84cadc88e23fead7435384bfd986dc08081509/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29f5154d1c664c8fb1dfae45281873ed97a68a55", "url": "https://api.github.com/repos/rust-lang/rust/commits/29f5154d1c664c8fb1dfae45281873ed97a68a55", "html_url": "https://github.com/rust-lang/rust/commit/29f5154d1c664c8fb1dfae45281873ed97a68a55"}, {"sha": "45860d520786a86007f2f86635b4d2f9c3b0c74e", "url": "https://api.github.com/repos/rust-lang/rust/commits/45860d520786a86007f2f86635b4d2f9c3b0c74e", "html_url": "https://github.com/rust-lang/rust/commit/45860d520786a86007f2f86635b4d2f9c3b0c74e"}], "stats": {"total": 165, "additions": 141, "deletions": 24}, "files": [{"sha": "065035fe61d6eb21026c17c2b25630899d5bcd0c", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 141, "deletions": 24, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/1a84cadc88e23fead7435384bfd986dc08081509/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a84cadc88e23fead7435384bfd986dc08081509/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=1a84cadc88e23fead7435384bfd986dc08081509", "patch": "@@ -289,11 +289,19 @@ fn _replace_children(\n     with_children(parent, new_children)\n }\n \n+#[derive(Debug, PartialEq, Eq, Hash)]\n+enum InsertPos {\n+    FirstChildOf(SyntaxNode),\n+    // Before(SyntaxElement),\n+    After(SyntaxElement),\n+}\n+\n #[derive(Default)]\n pub struct SyntaxRewriter<'a> {\n     f: Option<Box<dyn Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a>>,\n     //FIXME: add debug_assertions that all elements are in fact from the same file.\n     replacements: FxHashMap<SyntaxElement, Replacement>,\n+    insertions: IndexMap<InsertPos, Vec<SyntaxElement>>,\n }\n \n impl fmt::Debug for SyntaxRewriter<'_> {\n@@ -304,13 +312,96 @@ impl fmt::Debug for SyntaxRewriter<'_> {\n \n impl<'a> SyntaxRewriter<'a> {\n     pub fn from_fn(f: impl Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a) -> SyntaxRewriter<'a> {\n-        SyntaxRewriter { f: Some(Box::new(f)), replacements: FxHashMap::default() }\n+        SyntaxRewriter {\n+            f: Some(Box::new(f)),\n+            replacements: FxHashMap::default(),\n+            insertions: IndexMap::default(),\n+        }\n     }\n     pub fn delete<T: Clone + Into<SyntaxElement>>(&mut self, what: &T) {\n         let what = what.clone().into();\n         let replacement = Replacement::Delete;\n         self.replacements.insert(what, replacement);\n     }\n+    pub fn insert_before<T: Clone + Into<SyntaxElement>, U: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        before: &T,\n+        what: &U,\n+    ) {\n+        let before = before.clone().into();\n+        let pos = match before.prev_sibling_or_token() {\n+            Some(sibling) => InsertPos::After(sibling),\n+            None => match before.parent() {\n+                Some(parent) => InsertPos::FirstChildOf(parent),\n+                None => return,\n+            },\n+        };\n+        self.insertions.entry(pos).or_insert_with(Vec::new).push(what.clone().into());\n+    }\n+    pub fn insert_after<T: Clone + Into<SyntaxElement>, U: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        after: &T,\n+        what: &U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::After(after.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .push(what.clone().into());\n+    }\n+    pub fn insert_as_first_child<T: Clone + Into<SyntaxNode>, U: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        parent: &T,\n+        what: &U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::FirstChildOf(parent.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .push(what.clone().into());\n+    }\n+    pub fn insert_many_before<\n+        T: Clone + Into<SyntaxElement>,\n+        U: IntoIterator<Item = SyntaxElement>,\n+    >(\n+        &mut self,\n+        before: &T,\n+        what: U,\n+    ) {\n+        let before = before.clone().into();\n+        let pos = match before.prev_sibling_or_token() {\n+            Some(sibling) => InsertPos::After(sibling),\n+            None => match before.parent() {\n+                Some(parent) => InsertPos::FirstChildOf(parent),\n+                None => return,\n+            },\n+        };\n+        self.insertions.entry(pos).or_insert_with(Vec::new).extend(what);\n+    }\n+    pub fn insert_many_after<\n+        T: Clone + Into<SyntaxElement>,\n+        U: IntoIterator<Item = SyntaxElement>,\n+    >(\n+        &mut self,\n+        after: &T,\n+        what: U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::After(after.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .extend(what);\n+    }\n+    pub fn insert_many_as_first_children<\n+        T: Clone + Into<SyntaxNode>,\n+        U: IntoIterator<Item = SyntaxElement>,\n+    >(\n+        &mut self,\n+        parent: &T,\n+        what: U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::FirstChildOf(parent.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .extend(what)\n+    }\n     pub fn replace<T: Clone + Into<SyntaxElement>>(&mut self, what: &T, with: &T) {\n         let what = what.clone().into();\n         let replacement = Replacement::Single(with.clone().into());\n@@ -330,7 +421,7 @@ impl<'a> SyntaxRewriter<'a> {\n     }\n \n     pub fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n-        if self.f.is_none() && self.replacements.is_empty() {\n+        if self.f.is_none() && self.replacements.is_empty() && self.insertions.is_empty() {\n             return node.clone();\n         }\n         self.rewrite_children(node)\n@@ -346,14 +437,22 @@ impl<'a> SyntaxRewriter<'a> {\n     ///\n     /// Returns `None` when there are no replacements.\n     pub fn rewrite_root(&self) -> Option<SyntaxNode> {\n+        fn element_to_node_or_parent(element: &SyntaxElement) -> SyntaxNode {\n+            match element {\n+                SyntaxElement::Node(it) => it.clone(),\n+                SyntaxElement::Token(it) => it.parent(),\n+            }\n+        }\n+\n         assert!(self.f.is_none());\n         self.replacements\n             .keys()\n-            .map(|element| match element {\n-                SyntaxElement::Node(it) => it.clone(),\n-                SyntaxElement::Token(it) => it.parent(),\n-            })\n-            // If we only have one replacement, we must return its parent node, since `rewrite` does\n+            .map(element_to_node_or_parent)\n+            .chain(self.insertions.keys().map(|pos| match pos {\n+                InsertPos::FirstChildOf(it) => it.clone(),\n+                InsertPos::After(it) => element_to_node_or_parent(it),\n+            }))\n+            // If we only have one replacement/insertion, we must return its parent node, since `rewrite` does\n             // not replace the node passed to it.\n             .map(|it| it.parent().unwrap_or(it))\n             .fold1(|a, b| least_common_ancestor(&a, &b).unwrap())\n@@ -367,9 +466,16 @@ impl<'a> SyntaxRewriter<'a> {\n         self.replacements.get(element).cloned()\n     }\n \n+    fn insertions(&self, pos: &InsertPos) -> Option<impl Iterator<Item = SyntaxElement> + '_> {\n+        self.insertions.get(pos).map(|insertions| insertions.iter().cloned())\n+    }\n+\n     fn rewrite_children(&self, node: &SyntaxNode) -> SyntaxNode {\n         //  FIXME: this could be made much faster.\n         let mut new_children = Vec::new();\n+        if let Some(elements) = self.insertions(&InsertPos::FirstChildOf(node.clone())) {\n+            new_children.extend(elements.map(element_to_green));\n+        }\n         for child in node.children_with_tokens() {\n             self.rewrite_self(&mut new_children, &child);\n         }\n@@ -383,34 +489,45 @@ impl<'a> SyntaxRewriter<'a> {\n     ) {\n         if let Some(replacement) = self.replacement(&element) {\n             match replacement {\n-                Replacement::Single(NodeOrToken::Node(it)) => {\n-                    acc.push(NodeOrToken::Node(it.green().clone()))\n-                }\n-                Replacement::Single(NodeOrToken::Token(it)) => {\n-                    acc.push(NodeOrToken::Token(it.green().clone()))\n-                }\n+                Replacement::Single(element) => acc.push(element_to_green(element)),\n                 Replacement::Many(replacements) => {\n-                    acc.extend(replacements.iter().map(|it| match it {\n-                        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n-                        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n-                    }))\n+                    acc.extend(replacements.into_iter().map(element_to_green))\n                 }\n                 Replacement::Delete => (),\n             };\n-            return;\n+        } else {\n+            match element {\n+                NodeOrToken::Token(it) => acc.push(NodeOrToken::Token(it.green().clone())),\n+                NodeOrToken::Node(it) => {\n+                    acc.push(NodeOrToken::Node(self.rewrite_children(it).green().clone()));\n+                }\n+            }\n+        }\n+        if let Some(elements) = self.insertions(&InsertPos::After(element.clone())) {\n+            acc.extend(elements.map(element_to_green));\n         }\n-        let res = match element {\n-            NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n-            NodeOrToken::Node(it) => NodeOrToken::Node(self.rewrite_children(it).green().clone()),\n-        };\n-        acc.push(res)\n+    }\n+}\n+\n+fn element_to_green(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n+    match element {\n+        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n+        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n     }\n }\n \n impl ops::AddAssign for SyntaxRewriter<'_> {\n     fn add_assign(&mut self, rhs: SyntaxRewriter) {\n         assert!(rhs.f.is_none());\n-        self.replacements.extend(rhs.replacements)\n+        self.replacements.extend(rhs.replacements);\n+        for (pos, insertions) in rhs.insertions.into_iter() {\n+            match self.insertions.entry(pos) {\n+                indexmap::map::Entry::Occupied(mut occupied) => {\n+                    occupied.get_mut().extend(insertions)\n+                }\n+                indexmap::map::Entry::Vacant(vacant) => drop(vacant.insert(insertions)),\n+            }\n+        }\n     }\n }\n "}]}