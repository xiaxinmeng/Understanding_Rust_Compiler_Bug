{"sha": "df2f1fa7680a86ba228f004e7de731e91a1df1fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMmYxZmE3NjgwYTg2YmEyMjhmMDA0ZTdkZTczMWU5MWExZGYxZmU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-09-25T10:41:49Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-10-02T00:19:45Z"}, "message": "Remove the `_` suffix from slice methods.\n\nDeprecates slicing methods from ImmutableSlice/MutableSlice in favour of slicing syntax or the methods in Slice/SliceMut.\n\nCloses #17273.", "tree": {"sha": "8176be0292df7395c72f72588f69b06925a8c7a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8176be0292df7395c72f72588f69b06925a8c7a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df2f1fa7680a86ba228f004e7de731e91a1df1fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df2f1fa7680a86ba228f004e7de731e91a1df1fe", "html_url": "https://github.com/rust-lang/rust/commit/df2f1fa7680a86ba228f004e7de731e91a1df1fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df2f1fa7680a86ba228f004e7de731e91a1df1fe/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40b9f5ded50ac4ce8c9323921ec556ad611af6b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/40b9f5ded50ac4ce8c9323921ec556ad611af6b7", "html_url": "https://github.com/rust-lang/rust/commit/40b9f5ded50ac4ce8c9323921ec556ad611af6b7"}], "stats": {"total": 285, "additions": 188, "deletions": 97}, "files": [{"sha": "9bfc8e08d8d3cc3fa8241bb2a47538ca090d52bc", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=df2f1fa7680a86ba228f004e7de731e91a1df1fe", "patch": "@@ -389,13 +389,22 @@ macro_rules! bound {\n \n impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n+    #[cfg(stage0)]\n     #[inline]\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n         bound!(Entries, self = self,\n                key = key, is_upper = upper,\n                slice_from = slice_from_, iter = iter,\n                mutability = )\n     }\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n+        bound!(Entries, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = slice_from, iter = iter,\n+               mutability = )\n+    }\n \n     /// Gets an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n@@ -431,13 +440,22 @@ impl<T> TrieMap<T> {\n         self.bound(key, true)\n     }\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n+    #[cfg(stage0)]\n     #[inline]\n     fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n         bound!(MutEntries, self = self,\n                key = key, is_upper = upper,\n                slice_from = slice_from_mut_, iter = iter_mut,\n                mutability = mut)\n     }\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n+        bound!(MutEntries, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = slice_from_mut, iter = iter_mut,\n+               mutability = mut)\n+    }\n \n     /// Deprecated: use `lower_bound_mut`.\n     #[deprecated = \"use lower_bound_mut\"]"}, {"sha": "ee6f5e840becf8834f2c285c246c277ad70aaa1d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=df2f1fa7680a86ba228f004e7de731e91a1df1fe", "patch": "@@ -23,6 +23,7 @@ use core::num;\n use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n+use core::slice::Slice as SliceSlice;\n use core::uint;\n \n use {Mutable, MutableSeq};\n@@ -459,6 +460,36 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }*/\n \n+// Annoying helper function because there are two Slice::as_slice functions in\n+// scope.\n+#[inline]\n+fn slice_to_slice<'a, T, U: Slice<T>>(this: &'a U) -> &'a [T] {\n+    this.as_slice()\n+}\n+\n+\n+#[cfg(not(stage0))]\n+impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        slice_to_slice(self)\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: &uint) -> &'a [T] {\n+        slice_to_slice(self).slice_from(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: &uint) -> &'a [T] {\n+        slice_to_slice(self).slice_to(end)\n+    }\n+    #[inline]\n+    fn slice<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        slice_to_slice(self).slice(start, end)\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -480,6 +511,28 @@ impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        self.as_mut_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_from_mut(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_to_mut(end)\n+    }\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_mut(start, end)\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {"}, {"sha": "77cee2b9863460de55d6da1bb73ef89ee175807c", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=df2f1fa7680a86ba228f004e7de731e91a1df1fe", "patch": "@@ -688,19 +688,19 @@ pub trait IndexMut<Index, Result> {\n  * struct Foo;\n  *\n  * impl ::core::ops::Slice<Foo, Foo> for Foo {\n- *     fn as_slice_<'a>(&'a self) -> &'a Foo {\n+ *     fn as_slice<'a>(&'a self) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_from_<'a>(&'a self, from: &Foo) -> &'a Foo {\n+ *     fn slice_from<'a>(&'a self, from: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_to_<'a>(&'a self, to: &Foo) -> &'a Foo {\n+ *     fn slice_to<'a>(&'a self, to: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n+ *     fn slice<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n@@ -711,7 +711,22 @@ pub trait IndexMut<Index, Result> {\n  * }\n  * ```\n  */\n-// FIXME(#17273) remove the postscript _s\n+#[cfg(not(stage0))]\n+#[lang=\"slice\"]\n+pub trait Slice<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_slice<'a>(&'a self) -> &'a Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from<'a>(&'a self, from: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to<'a>(&'a self, to: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n+}\n+/**\n+ *\n+ */\n+#[cfg(stage0)]\n #[lang=\"slice\"]\n pub trait Slice<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[]\n@@ -738,19 +753,19 @@ pub trait Slice<Idx, Sized? Result> for Sized? {\n  * struct Foo;\n  *\n  * impl ::core::ops::SliceMut<Foo, Foo> for Foo {\n- *     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+ *     fn as_mut_slice<'a>(&'a mut self) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_from_mut_<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n+ *     fn slice_from_mut<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_to_mut_<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n+ *     fn slice_to_mut<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_mut_<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n+ *     fn slice_mut<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n@@ -761,7 +776,22 @@ pub trait Slice<Idx, Sized? Result> for Sized? {\n  * }\n  * ```\n  */\n-// FIXME(#17273) remove the postscript _s\n+#[cfg(not(stage0))]\n+#[lang=\"slice_mut\"]\n+pub trait SliceMut<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from_mut<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to_mut<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n+}\n+/**\n+ *\n+ */\n+#[cfg(stage0)]\n #[lang=\"slice_mut\"]\n pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[mut]\n@@ -773,6 +803,7 @@ pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[mut from..to]\n     fn slice_mut_<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n }\n+\n /**\n  *\n  * The `Deref` trait is used to specify the functionality of dereferencing"}, {"sha": "68b3a3199df5787347cb91195148118017cbbf6f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 58, "deletions": 69, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=df2f1fa7680a86ba228f004e7de731e91a1df1fe", "patch": "@@ -61,32 +61,6 @@ use raw::Slice as RawSlice;\n /// Extension methods for immutable slices.\n #[unstable = \"may merge with other traits; region parameter may disappear\"]\n pub trait ImmutableSlice<'a, T> {\n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Fails when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    //fn slice(&self, start: uint, end: uint) -> &'a [T];\n-\n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Fails when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    // TODO\n-    //fn slice_from(&self, start: uint) -> &'a [T];\n-\n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Fails when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_to(&self, end: uint) -> &'a [T];\n-\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -444,6 +418,35 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice(&0, end)\n+    }\n+    #[inline]\n+    fn slice<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::Slice<uint, [T]> for [T] {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -471,7 +474,36 @@ impl<T> ops::Slice<uint, [T]> for [T] {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_mut(start, len)\n+    }\n \n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_mut(&0, end)\n+    }\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::SliceMut<uint, [T]> for [T] {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n@@ -514,49 +546,6 @@ pub trait MutableSlice<'a, T> {\n     #[deprecated = \"use slicing syntax\"]\n     fn as_mut_slice(self) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slicing syntax\"]\n-    //fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-    //    self[mut start..end]\n-    //}\n-\n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Fails when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n-\n-    /// Deprecated: use `slicing syntax`.\n-    #[deprecated = \"use slicing syntax\"]\n-    //fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-    //    self[mut start..]\n-    //}\n-\n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Fails when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_from_mut(self, start: uint) -> &'a mut [T];\n-\n-    /// Deprecated: use `slicing syntax`.\n-    #[deprecated = \"use slicing syntax\"]\n-    //fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-    //    self[mut ..end]\n-    //}\n-\n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Fails when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    //fn slice_to_mut(self, end: uint) -> &'a mut [T];\n-\n     /// Deprecated: use `iter_mut`.\n     #[deprecated = \"use iter_mut\"]\n     fn mut_iter(self) -> MutItems<'a, T> {"}, {"sha": "e84c894796736d249e83ea9fb887b738b1e34988", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=df2f1fa7680a86ba228f004e7de731e91a1df1fe", "patch": "@@ -373,7 +373,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice_(&0, &0).iter().all(|_| fail!()));\n+    assert!(v.slice(&0, &0).iter().all(|_| fail!()));\n }\n \n #[test]\n@@ -382,7 +382,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice_(&0, &0).iter().any(|_| fail!()));\n+    assert!(!v.slice(&0, &0).iter().any(|_| fail!()));\n }\n \n #[test]"}, {"sha": "aa53773bddf0ceb81e919df3b3acfd2a5bb5ff16", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=df2f1fa7680a86ba228f004e7de731e91a1df1fe", "patch": "@@ -2271,10 +2271,10 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n         match fcx.tcx().lang_items.slice_mut_trait() {\n             Some(trait_did) => {\n                 let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_mut_\",\n-                    (&Some(_), &None) => \"slice_from_mut_\",\n-                    (&None, &Some(_)) => \"slice_to_mut_\",\n-                    (&None, &None) => \"as_mut_slice_\",\n+                    (&Some(_), &Some(_)) => \"slice_mut\",\n+                    (&Some(_), &None) => \"slice_from_mut\",\n+                    (&None, &Some(_)) => \"slice_to_mut\",\n+                    (&None, &None) => \"as_mut_slice\",\n                 };\n \n                 method::lookup_in_trait(fcx,\n@@ -2296,10 +2296,10 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n         match fcx.tcx().lang_items.slice_trait() {\n             Some(trait_did) => {\n                 let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_\",\n-                    (&Some(_), &None) => \"slice_from_\",\n-                    (&None, &Some(_)) => \"slice_to_\",\n-                    (&None, &None) => \"as_slice_\",\n+                    (&Some(_), &Some(_)) => \"slice\",\n+                    (&Some(_), &None) => \"slice_from\",\n+                    (&None, &Some(_)) => \"slice_to\",\n+                    (&None, &None) => \"as_slice\",\n                 };\n \n                 method::lookup_in_trait(fcx,"}, {"sha": "661ff055dc289b9253f8672fc92bf24c2cf34b08", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2f1fa7680a86ba228f004e7de731e91a1df1fe/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=df2f1fa7680a86ba228f004e7de731e91a1df1fe", "patch": "@@ -18,38 +18,38 @@ static mut COUNT: uint = 0;\n struct Foo;\n \n impl Slice<Foo, Foo> for Foo {\n-    fn as_slice_<'a>(&'a self) -> &'a Foo {\n+    fn as_slice<'a>(&'a self) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from_<'a>(&'a self, _from: &Foo) -> &'a Foo {\n+    fn slice_from<'a>(&'a self, _from: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to_<'a>(&'a self, _to: &Foo) -> &'a Foo {\n+    fn slice_to<'a>(&'a self, _to: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n+    fn slice<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n \n impl SliceMut<Foo, Foo> for Foo {\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from_mut_<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n+    fn slice_from_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to_mut_<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n+    fn slice_to_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_mut_<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n+    fn slice_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }"}]}