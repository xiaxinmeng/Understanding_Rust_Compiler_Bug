{"sha": "b9cf5417892ef242c783ef963deff5436205b0f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5Y2Y1NDE3ODkyZWYyNDJjNzgzZWY5NjNkZWZmNTQzNjIwNWIwZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-20T14:04:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-20T14:04:12Z"}, "message": "Auto merge of #66571 - Centril:rollup-41tn2fw, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #65665 (Update Source Code Pro and include italics)\n - #66478 (rustc_plugin: Remove the compatibility shim)\n - #66497 (Fix #53820)\n - #66526 (Add more context to `async fn` trait error)\n - #66532 (Generate DWARF address ranges for faster lookups)\n - #66546 (Remove duplicate function)\n - #66548 ([RISCV] Disable Atomics on all Non-A RISC-V targets)\n - #66553 (remove HermitCore leftovers from sys/unix)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0a875cafe855dc3b67841e2846155b2160ea0154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a875cafe855dc3b67841e2846155b2160ea0154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9cf5417892ef242c783ef963deff5436205b0f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9cf5417892ef242c783ef963deff5436205b0f6", "html_url": "https://github.com/rust-lang/rust/commit/b9cf5417892ef242c783ef963deff5436205b0f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9cf5417892ef242c783ef963deff5436205b0f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea540b0892ed6b62d170c7f0a9aa362e590de8b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea540b0892ed6b62d170c7f0a9aa362e590de8b4", "html_url": "https://github.com/rust-lang/rust/commit/ea540b0892ed6b62d170c7f0a9aa362e590de8b4"}, {"sha": "ebd0ef9a39cbec962ed246d523186a8b88ccb351", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd0ef9a39cbec962ed246d523186a8b88ccb351", "html_url": "https://github.com/rust-lang/rust/commit/ebd0ef9a39cbec962ed246d523186a8b88ccb351"}], "stats": {"total": 629, "additions": 426, "deletions": 203}, "files": [{"sha": "84e0d44d938d81863b26ff16c1c8edbbc9f91b2f", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -3541,7 +3541,6 @@ dependencies = [\n  \"rustc_metadata\",\n  \"rustc_mir\",\n  \"rustc_parse\",\n- \"rustc_plugin\",\n  \"rustc_plugin_impl\",\n  \"rustc_resolve\",\n  \"rustc_save_analysis\",\n@@ -3770,13 +3769,6 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n-[[package]]\n-name = \"rustc_plugin\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc_plugin_impl\",\n-]\n-\n [[package]]\n name = \"rustc_plugin_impl\"\n version = \"0.0.0\""}, {"sha": "b9b6a5f2342e25ed46564966b02b50264397e6e2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -1331,6 +1331,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"for every macro invocation, print its name and arguments\"),\n     debug_macros: bool = (false, parse_bool, [TRACKED],\n         \"emit line numbers debug info inside macros\"),\n+    generate_arange_section: bool = (true, parse_bool, [TRACKED],\n+        \"generate DWARF address ranges for faster lookups\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n         \"don't clear the hygiene data after analysis\"),\n     keep_ast: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "290ca40926104c5cc2a2635bf4f0f595cfbbc2b2", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -62,6 +62,9 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.opts.debugging_opts.disable_instrumentation_preinliner {\n             add(\"-disable-preinline\");\n         }\n+        if sess.opts.debugging_opts.generate_arange_section {\n+            add(\"-generate-arange-section\");\n+        }\n         if get_major_version() >= 8 {\n             match sess.opts.debugging_opts.merge_functions\n                   .unwrap_or(sess.target.target.options.merge_functions) {"}, {"sha": "2b7e4d35248e6d6631680a63b41f300b9529a3d7", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -22,8 +22,7 @@ errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_parse = { path = \"../librustc_parse\" }\n-rustc_plugin = { path = \"../librustc_plugin/deprecated\" } # To get this in the sysroot\n-rustc_plugin_impl = { path = \"../librustc_plugin\" }\n+rustc_plugin_impl = { path = \"../librustc_plugin_impl\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_error_codes = { path = \"../librustc_error_codes\" }"}, {"sha": "6557be9f7ecd0845f71a981d32e0ec56da43c69c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -84,13 +84,6 @@ const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\n \n const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n \n-pub fn source_name(input: &Input) -> FileName {\n-    match *input {\n-        Input::File(ref ifile) => ifile.clone().into(),\n-        Input::Str { ref name, .. } => name.clone(),\n-    }\n-}\n-\n pub fn abort_on_err<T>(result: Result<T, ErrorReported>, sess: &Session) -> T {\n     match result {\n         Err(..) => {"}, {"sha": "e869607c970b0609876852f0e2d2fdf14e0d9de1", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -24,10 +24,6 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use crate::abort_on_err;\n \n-use crate::source_name;\n-\n-\n-\n // This slightly awkward construction is to allow for each PpMode to\n // choose whether it needs to do analyses (which can consume the\n // Session) and then pass through the session (now attached to the\n@@ -391,7 +387,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n }\n \n fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n-    let src_name = source_name(input);\n+    let src_name = input.source_name();\n     let src = String::clone(&sess.source_map()\n         .get_source_file(&src_name)\n         .unwrap()"}, {"sha": "b11fe33880c049f495887df38e70b8c1be0de159", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -383,6 +383,7 @@ E0700: include_str!(\"./error_codes/E0700.md\"),\n E0701: include_str!(\"./error_codes/E0701.md\"),\n E0704: include_str!(\"./error_codes/E0704.md\"),\n E0705: include_str!(\"./error_codes/E0705.md\"),\n+E0706: include_str!(\"./error_codes/E0706.md\"),\n E0712: include_str!(\"./error_codes/E0712.md\"),\n E0713: include_str!(\"./error_codes/E0713.md\"),\n E0714: include_str!(\"./error_codes/E0714.md\"),\n@@ -595,7 +596,6 @@ E0744: include_str!(\"./error_codes/E0744.md\"),\n     E0696, // `continue` pointing to a labeled block\n //  E0702, // replaced with a generic attribute input check\n     E0703, // invalid ABI\n-    E0706, // `async fn` in trait\n //  E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported"}, {"sha": "bee9219af7cf60c61546840168a4e551d0b074cb", "filename": "src/librustc_error_codes/error_codes/E0706.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0706.md", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0706.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0706.md?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -0,0 +1,57 @@\n+ `async fn`s are not yet supported in traits in Rust.\n+\n+Erroneous code example:\n+\n+```compile_fail,edition2018\n+trait T {\n+    // Neither case is currently supported.\n+    async fn foo() {}\n+    async fn bar(&self) {}\n+}\n+```\n+\n+`async fn`s return an `impl Future`, making the following two examples equivalent:\n+\n+```edition2018,ignore (example-of-desugaring-equivalence)\n+async fn foo() -> User {\n+    unimplemented!()\n+}\n+// The async fn above gets desugared as follows:\n+fn foo(&self) -> impl Future<Output = User> + '_ {\n+    unimplemented!()\n+}\n+```\n+\n+But when it comes to supporting this in traits, there are [a few implementation\n+issues][async-is-hard]. One of them is returning `impl Trait` in traits is not supported,\n+as it would require [Generic Associated Types] to be supported:\n+\n+```edition2018,ignore (example-of-desugaring-equivalence)\n+impl MyDatabase {\n+    async fn get_user(&self) -> User {\n+        unimplemented!()\n+    }\n+}\n+\n+impl MyDatabase {\n+    fn get_user(&self) -> impl Future<Output = User> + '_ {\n+        unimplemented!()\n+    }\n+}\n+```\n+\n+Until these issues are resolved, you can use the [`async-trait` crate], allowing you to use\n+`async fn` in traits by desugaring to \"boxed futures\"\n+(`Pin<Box<dyn Future + Send + 'async>>`).\n+\n+Note that using these trait methods will result in a heap allocation per-function-call. This is not\n+a significant cost for the vast majority of applications, but should be considered when deciding\n+whether to use this functionality in the public API of a low-level function that is expected to be\n+called millions of times a second.\n+\n+You might be interested in visiting the [async book] for further information.\n+\n+[`async-trait` crate]: https://crates.io/crates/async-trait\n+[async-is-hard]: https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/\n+[Generic Associated Types]: https://github.com/rust-lang/rust/issues/44265\n+[async book]: https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html"}, {"sha": "7ab5ec2b2329e9b504fb7900bb3029c21b48075c", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -31,7 +31,7 @@ rustc_passes = { path = \"../librustc_passes\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_plugin = { path = \"../librustc_plugin\", package = \"rustc_plugin_impl\" }\n+rustc_plugin_impl = { path = \"../librustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\""}, {"sha": "5df814da770ad50a6d8a670cd7fbfd78f1421aaa", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -29,8 +29,8 @@ use rustc_metadata::cstore;\n use rustc_mir as mir;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, ast_validation, hir_stats, layout_test};\n-use rustc_plugin as plugin;\n-use rustc_plugin::registry::Registry;\n+use rustc_plugin_impl as plugin;\n+use rustc_plugin_impl::registry::Registry;\n use rustc_privacy;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_traits;"}, {"sha": "5e7a7f01e7a328087e7d47f87b42b75369e2324b", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 228, "deletions": 111, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -225,6 +225,7 @@\n ///       anything special (because we know none of the integers are actually wildcards: i.e., we\n ///       can't span wildcards using ranges).\n use self::Constructor::*;\n+use self::SliceKind::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n@@ -582,6 +583,114 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum SliceKind {\n+    /// Patterns of length `n` (`[x, y]`).\n+    FixedLen(u64),\n+    /// Patterns using the `..` notation (`[x, .., y]`). Captures any array constructor of `length\n+    /// >= i + j`. In the case where `array_len` is `Some(_)`, this indicates that we only care\n+    /// about the first `i` and the last `j` values of the array, and everything in between is a\n+    /// wildcard `_`.\n+    VarLen(u64, u64),\n+}\n+\n+impl SliceKind {\n+    fn arity(self) -> u64 {\n+        match self {\n+            FixedLen(length) => length,\n+            VarLen(prefix, suffix) => prefix + suffix,\n+        }\n+    }\n+\n+    /// Whether this pattern includes patterns of length `other_len`.\n+    fn covers_length(self, other_len: u64) -> bool {\n+        match self {\n+            FixedLen(len) => len == other_len,\n+            VarLen(prefix, suffix) => prefix + suffix <= other_len,\n+        }\n+    }\n+\n+    /// Returns a collection of slices that spans the values covered by `self`, subtracted by the\n+    /// values covered by `other`: i.e., `self \\ other` (in set notation).\n+    fn subtract(self, other: Self) -> SmallVec<[Self; 1]> {\n+        // Remember, `VarLen(i, j)` covers the union of `FixedLen` from `i + j` to infinity.\n+        // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n+        match self {\n+            FixedLen(pos_len) => {\n+                if other.covers_length(pos_len) {\n+                    smallvec![]\n+                } else {\n+                    smallvec![self]\n+                }\n+            }\n+            VarLen(pos_prefix, pos_suffix) => {\n+                let pos_len = pos_prefix + pos_suffix;\n+                match other {\n+                    FixedLen(neg_len) => {\n+                        if neg_len < pos_len {\n+                            smallvec![self]\n+                        } else {\n+                            (pos_len..neg_len)\n+                                .map(FixedLen)\n+                                // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n+                                .chain(Some(VarLen(neg_len + 1 - pos_suffix, pos_suffix)))\n+                                .collect()\n+                        }\n+                    }\n+                    VarLen(neg_prefix, neg_suffix) => {\n+                        let neg_len = neg_prefix + neg_suffix;\n+                        if neg_len <= pos_len {\n+                            smallvec![]\n+                        } else {\n+                            (pos_len..neg_len).map(FixedLen).collect()\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// A constructor for array and slice patterns.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct Slice {\n+    /// `None` if the matched value is a slice, `Some(n)` if it is an array of size `n`.\n+    array_len: Option<u64>,\n+    /// The kind of pattern it is: fixed-length `[x, y]` or variable length `[x, .., y]`.\n+    kind: SliceKind,\n+}\n+\n+impl Slice {\n+    /// Returns what patterns this constructor covers: either fixed-length patterns or\n+    /// variable-length patterns.\n+    fn pattern_kind(self) -> SliceKind {\n+        match self {\n+            Slice { array_len: Some(len), kind: VarLen(prefix, suffix) }\n+                if prefix + suffix == len =>\n+            {\n+                FixedLen(len)\n+            }\n+            _ => self.kind,\n+        }\n+    }\n+\n+    /// Returns what values this constructor covers: either values of only one given length, or\n+    /// values of length above a given length.\n+    /// This is different from `pattern_kind()` because in some cases the pattern only takes into\n+    /// account a subset of the entries of the array, but still only captures values of a given\n+    /// length.\n+    fn value_kind(self) -> SliceKind {\n+        match self {\n+            Slice { array_len: Some(len), kind: VarLen(_, _) } => FixedLen(len),\n+            _ => self.kind,\n+        }\n+    }\n+\n+    fn arity(self) -> u64 {\n+        self.pattern_kind().arity()\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n@@ -595,18 +704,16 @@ enum Constructor<'tcx> {\n     IntRange(IntRange<'tcx>),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n-    /// Array patterns of length `n`.\n-    FixedLenSlice(u64),\n-    /// Slice patterns. Captures any array constructor of `length >= i + j`.\n-    VarLenSlice(u64, u64),\n+    /// Array and slice patterns.\n+    Slice(Slice),\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n-            FixedLenSlice { .. } | VarLenSlice { .. } => true,\n+            Slice(_) => true,\n             _ => false,\n         }\n     }\n@@ -635,76 +742,49 @@ impl<'tcx> Constructor<'tcx> {\n             Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n-            &FixedLenSlice(self_len) => {\n-                let overlaps = |c: &Constructor<'_>| match *c {\n-                    FixedLenSlice(other_len) => other_len == self_len,\n-                    VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n-                    _ => false,\n-                };\n-                if other_ctors.iter().any(overlaps) { vec![] } else { vec![self.clone()] }\n-            }\n-            VarLenSlice(..) => {\n-                let mut remaining_ctors = vec![self.clone()];\n-\n-                // For each used ctor, subtract from the current set of constructors.\n-                // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-                // Remember, `VarLenSlice(i, j)` covers the union of `FixedLenSlice` from\n-                // `i + j` to infinity.\n-                for neg_ctor in other_ctors {\n-                    remaining_ctors = remaining_ctors\n-                        .into_iter()\n-                        .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n-                            // Compute `pos_ctor \\ neg_ctor`.\n-                            match (&pos_ctor, neg_ctor) {\n-                                (&FixedLenSlice(pos_len), &VarLenSlice(neg_prefix, neg_suffix)) => {\n-                                    let neg_len = neg_prefix + neg_suffix;\n-                                    if neg_len <= pos_len {\n-                                        smallvec![]\n-                                    } else {\n-                                        smallvec![pos_ctor]\n-                                    }\n-                                }\n-                                (\n-                                    &VarLenSlice(pos_prefix, pos_suffix),\n-                                    &VarLenSlice(neg_prefix, neg_suffix),\n-                                ) => {\n-                                    let neg_len = neg_prefix + neg_suffix;\n-                                    let pos_len = pos_prefix + pos_suffix;\n-                                    if neg_len <= pos_len {\n-                                        smallvec![]\n-                                    } else {\n-                                        (pos_len..neg_len).map(FixedLenSlice).collect()\n-                                    }\n-                                }\n-                                (&VarLenSlice(pos_prefix, pos_suffix), &FixedLenSlice(neg_len)) => {\n-                                    let pos_len = pos_prefix + pos_suffix;\n-                                    if neg_len < pos_len {\n-                                        smallvec![pos_ctor]\n-                                    } else {\n-                                        (pos_len..neg_len)\n-                                            .map(FixedLenSlice)\n-                                            // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n-                                            .chain(Some(VarLenSlice(\n-                                                neg_len + 1 - pos_suffix,\n-                                                pos_suffix,\n-                                            )))\n-                                            .collect()\n-                                    }\n-                                }\n-                                _ if pos_ctor == *neg_ctor => smallvec![],\n-                                _ => smallvec![pos_ctor],\n+            &Slice(slice) => {\n+                let mut other_slices = other_ctors\n+                    .iter()\n+                    .filter_map(|c: &Constructor<'_>| match c {\n+                        Slice(slice) => Some(*slice),\n+                        // FIXME(#65413): We ignore `ConstantValue`s here.\n+                        ConstantValue(..) => None,\n+                        _ => bug!(\"bad slice pattern constructor {:?}\", c),\n+                    })\n+                    .map(Slice::value_kind);\n+\n+                match slice.value_kind() {\n+                    FixedLen(self_len) => {\n+                        if other_slices.any(|other_slice| other_slice.covers_length(self_len)) {\n+                            vec![]\n+                        } else {\n+                            vec![Slice(slice)]\n+                        }\n+                    }\n+                    kind @ VarLen(..) => {\n+                        let mut remaining_slices = vec![kind];\n+\n+                        // For each used slice, subtract from the current set of slices.\n+                        for other_slice in other_slices {\n+                            remaining_slices = remaining_slices\n+                                .into_iter()\n+                                .flat_map(|remaining_slice| remaining_slice.subtract(other_slice))\n+                                .collect();\n+\n+                            // If the constructors that have been considered so far already cover\n+                            // the entire range of `self`, no need to look at more constructors.\n+                            if remaining_slices.is_empty() {\n+                                break;\n                             }\n-                        })\n-                        .collect();\n+                        }\n \n-                    // If the constructors that have been considered so far already cover\n-                    // the entire range of `self`, no need to look at more constructors.\n-                    if remaining_ctors.is_empty() {\n-                        break;\n+                        remaining_slices\n+                            .into_iter()\n+                            .map(|kind| Slice { array_len: slice.array_len, kind })\n+                            .map(Slice)\n+                            .collect()\n                     }\n                 }\n-\n-                remaining_ctors\n             }\n             IntRange(self_range) => {\n                 let mut remaining_ranges = vec![self_range.clone()];\n@@ -798,7 +878,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => vec![],\n             },\n-            FixedLenSlice(_) | VarLenSlice(..) => match ty.kind {\n+            Slice(_) => match ty.kind {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = self.arity(cx, ty);\n                     (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n@@ -828,8 +908,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => 0,\n             },\n-            FixedLenSlice(length) => *length,\n-            VarLenSlice(prefix, suffix) => prefix + suffix,\n+            Slice(slice) => slice.arity(),\n             ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n         }\n     }\n@@ -884,15 +963,31 @@ impl<'tcx> Constructor<'tcx> {\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n                 _ => PatKind::Wild,\n             },\n-            FixedLenSlice(_) => {\n-                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-            }\n-            &VarLenSlice(prefix_len, _) => {\n-                let prefix = subpatterns.by_ref().take(prefix_len as usize).collect();\n-                let suffix = subpatterns.collect();\n-                let wild = Pat::wildcard_from_ty(ty);\n-                PatKind::Slice { prefix, slice: Some(wild), suffix }\n-            }\n+            Slice(slice) => match slice.pattern_kind() {\n+                FixedLen(_) => {\n+                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+                }\n+                VarLen(prefix, _) => {\n+                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix as usize).collect();\n+                    if slice.array_len.is_some() {\n+                        // Improves diagnostics a bit: if the type is a known-size array, instead\n+                        // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n+                        // This is incorrect if the size is not known, since `[_, ..]` captures\n+                        // arrays of lengths `>= 1` whereas `[..]` captures any length.\n+                        while !prefix.is_empty() && prefix.last().unwrap().is_wildcard() {\n+                            prefix.pop();\n+                        }\n+                    }\n+                    let suffix: Vec<_> = if slice.array_len.is_some() {\n+                        // Same as above.\n+                        subpatterns.skip_while(Pat::is_wildcard).collect()\n+                    } else {\n+                        subpatterns.collect()\n+                    };\n+                    let wild = Pat::wildcard_from_ty(ty);\n+                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                }\n+            },\n             &ConstantValue(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n@@ -1105,15 +1200,16 @@ fn all_constructors<'a, 'tcx>(\n         }\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![FixedLenSlice(len)] }\n+            if len != 0 && cx.is_uninhabited(sub_ty) {\n+                vec![]\n+            } else {\n+                vec![Slice(Slice { array_len: Some(len), kind: VarLen(0, 0) })]\n+            }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n-            if cx.is_uninhabited(sub_ty) {\n-                vec![FixedLenSlice(0)]\n-            } else {\n-                vec![VarLenSlice(0, 0)]\n-            }\n+            let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n+            vec![Slice(Slice { array_len: None, kind })]\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n             let ctors: Vec<_> = def\n@@ -1693,18 +1789,18 @@ fn pat_constructor<'tcx>(\n                 Some(FloatRange(lo, hi, end))\n             }\n         }\n-        PatKind::Array { .. } => match pat.ty.kind {\n-            ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(tcx, param_env))),\n-            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pat.ty),\n-        },\n-        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Array { ref prefix, ref slice, ref suffix }\n+        | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            let array_len = match pat.ty.kind {\n+                ty::Array(_, length) => Some(length.eval_usize(tcx, param_env)),\n+                ty::Slice(_) => None,\n+                _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n+            };\n             let prefix = prefix.len() as u64;\n             let suffix = suffix.len() as u64;\n-            if slice.is_some() {\n-                Some(VarLenSlice(prefix, suffix))\n-            } else {\n-                Some(FixedLenSlice(prefix + suffix))\n-            }\n+            let kind =\n+                if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n+            Some(Slice(Slice { array_len, kind }))\n         }\n         PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n@@ -1832,6 +1928,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n ) -> Vec<Constructor<'tcx>> {\n     let ty = pcx.ty;\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n+    debug!(\"split_grouped_constructors({:#?}, {:#?})\", matrix, ctors);\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n@@ -1919,7 +2016,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                         .map(IntRange),\n                 );\n             }\n-            VarLenSlice(self_prefix, self_suffix) => {\n+            Slice(Slice { array_len, kind: VarLen(self_prefix, self_suffix) }) => {\n                 // The exhaustiveness-checking paper does not include any details on\n                 // checking variable-length slice patterns. However, they are matched\n                 // by an infinite collection of fixed-length array patterns.\n@@ -2004,11 +2101,13 @@ fn split_grouped_constructors<'p, 'tcx>(\n                                 _ => {}\n                             }\n                         }\n-                        PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                        PatKind::Slice { ref prefix, slice: None, ref suffix }\n+                        | PatKind::Array { ref prefix, slice: None, ref suffix } => {\n                             let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                             max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n                         }\n-                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix }\n+                        | PatKind::Array { ref prefix, slice: Some(_), ref suffix } => {\n                             max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n                             max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n                         }\n@@ -2026,20 +2125,38 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n                 }\n \n-                // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n-                // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n-                // are treated independently as fixed-lengths slices, and lengths above are\n-                // captured by a final VarLenSlice constructor.\n-                split_ctors.extend(\n-                    (self_prefix + self_suffix..max_prefix_len + max_suffix_len).map(FixedLenSlice),\n-                );\n-                split_ctors.push(VarLenSlice(max_prefix_len, max_suffix_len));\n+                match array_len {\n+                    Some(len) => {\n+                        let kind = if max_prefix_len + max_suffix_len < len {\n+                            VarLen(max_prefix_len, max_suffix_len)\n+                        } else {\n+                            FixedLen(len)\n+                        };\n+                        split_ctors.push(Slice(Slice { array_len, kind }));\n+                    }\n+                    None => {\n+                        // `ctor` originally covered the range `(self_prefix +\n+                        // self_suffix..infinity)`. We now split it into two: lengths smaller than\n+                        // `max_prefix_len + max_suffix_len` are treated independently as\n+                        // fixed-lengths slices, and lengths above are captured by a final VarLen\n+                        // constructor.\n+                        split_ctors.extend(\n+                            (self_prefix + self_suffix..max_prefix_len + max_suffix_len)\n+                                .map(|len| Slice(Slice { array_len, kind: FixedLen(len) })),\n+                        );\n+                        split_ctors.push(Slice(Slice {\n+                            array_len,\n+                            kind: VarLen(max_prefix_len, max_suffix_len),\n+                        }));\n+                    }\n+                }\n             }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),\n         }\n     }\n \n+    debug!(\"split_grouped_constructors(..)={:#?}\", split_ctors);\n     split_ctors\n }\n \n@@ -2251,7 +2368,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            FixedLenSlice(..) | VarLenSlice(..) => {\n+            Slice(_) => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}, {"sha": "c4032ec5dd0dba67110440e051d6d1c6bc7d8bfd", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -173,8 +173,11 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n         if asyncness.is_async() {\n-            struct_span_err!(self.session, span, E0706,\n-                             \"trait fns cannot be declared `async`\").emit()\n+            struct_span_err!(self.session, span, E0706, \"trait fns cannot be declared `async`\")\n+                .note(\"`async` trait functions are not currently supported\")\n+                .note(\"consider using the `async-trait` crate: \\\n+                       https://crates.io/crates/async-trait\")\n+                .emit();\n         }\n     }\n "}, {"sha": "cc75f7b9ab20d1e8e20a20c3af6cd46539307554", "filename": "src/librustc_plugin/deprecated/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml?ref=ea540b0892ed6b62d170c7f0a9aa362e590de8b4", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_plugin\"\n-version = \"0.0.0\"\n-build = false\n-edition = \"2018\"\n-\n-[lib]\n-name = \"rustc_plugin\"\n-path = \"lib.rs\"\n-doctest = false\n-\n-[dependencies]\n-rustc_plugin_impl = { path = \"..\" }"}, {"sha": "1d0afe84c25a89913ea844f143836a2e063a4903", "filename": "src/librustc_plugin/deprecated/lib.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs?ref=ea540b0892ed6b62d170c7f0a9aa362e590de8b4", "patch": "@@ -1,8 +0,0 @@\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![feature(staged_api)]\n-#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n-#![rustc_deprecated(since = \"1.38.0\", reason = \"\\\n-    import this through `rustc_driver::plugin` instead to make TLS work correctly. \\\n-    See https://github.com/rust-lang/rust/issues/62717\")]\n-\n-pub use rustc_plugin_impl::*;"}, {"sha": "c57b32fb2b6942f3d215fec42a8b9ad85a4e3c3e", "filename": "src/librustc_plugin_impl/Cargo.toml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2FCargo.toml?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "previous_filename": "src/librustc_plugin/Cargo.toml"}, {"sha": "01559a95c9c31d83a7bdf826da85a9be157aed01", "filename": "src/librustc_plugin_impl/build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fbuild.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "previous_filename": "src/librustc_plugin/build.rs"}, {"sha": "83e9ebeb935bff30efda4f8bba1da4e70e4ddec5", "filename": "src/librustc_plugin_impl/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Flib.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "previous_filename": "src/librustc_plugin/lib.rs"}, {"sha": "31b3b07c3e1fb81b8f43d1ed6692bff70a706022", "filename": "src/librustc_plugin_impl/load.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "previous_filename": "src/librustc_plugin/load.rs"}, {"sha": "aa5ea80f0b0e4caf0e69da050283ccc9bae53ecb", "filename": "src/librustc_plugin_impl/registry.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_plugin_impl%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fregistry.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "previous_filename": "src/librustc_plugin/registry.rs"}, {"sha": "0db34196bdd6193923f6c635af41ffb34698bb11", "filename": "src/librustc_target/spec/riscv32i_unknown_none_elf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_target%2Fspec%2Friscv32i_unknown_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_target%2Fspec%2Friscv32i_unknown_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Friscv32i_unknown_none_elf.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -17,7 +17,7 @@ pub fn target() -> TargetResult {\n         options: TargetOptions {\n             linker: Some(\"rust-lld\".to_string()),\n             cpu: \"generic-rv32\".to_string(),\n-            max_atomic_width: None,\n+            max_atomic_width: Some(0),\n             atomic_cas: false,\n             features: String::new(),\n             executables: true,"}, {"sha": "621af5a1eca75bb5fd4f26b435714d3354a2c256", "filename": "src/librustc_target/spec/riscv32imc_unknown_none_elf.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_target%2Fspec%2Friscv32imc_unknown_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustc_target%2Fspec%2Friscv32imc_unknown_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Friscv32imc_unknown_none_elf.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -17,8 +17,7 @@ pub fn target() -> TargetResult {\n         options: TargetOptions {\n             linker: Some(\"rust-lld\".to_string()),\n             cpu: \"generic-rv32\".to_string(),\n-            // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86005\n-            max_atomic_width: None, //Some(32),\n+            max_atomic_width: Some(0),\n             atomic_cas: false,\n             features: \"+m,+c\".to_string(),\n             executables: true,"}, {"sha": "2fa56f5851220c6a5533ac7459f109304387123a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -697,10 +697,12 @@ themePicker.onblur = handleThemeButtonsBlur;\n           static_files::source_serif_pro::ITALIC)?;\n     write(cx.dst.join(\"SourceSerifPro-LICENSE.md\"),\n           static_files::source_serif_pro::LICENSE)?;\n-    write(cx.dst.join(\"SourceCodePro-Regular.woff\"),\n+    write(cx.dst.join(\"SourceCodePro-Regular.ttf.woff\"),\n           static_files::source_code_pro::REGULAR)?;\n-    write(cx.dst.join(\"SourceCodePro-Semibold.woff\"),\n+    write(cx.dst.join(\"SourceCodePro-Semibold.ttf.woff\"),\n           static_files::source_code_pro::SEMIBOLD)?;\n+    write(cx.dst.join(\"SourceCodePro-It.ttf.woff\"),\n+          static_files::source_code_pro::ITALIC)?;\n     write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"),\n           static_files::source_code_pro::LICENSE)?;\n     write(cx.dst.join(\"LICENSE-MIT.txt\"),"}, {"sha": "24bdca6544d6dc988d93b1d0e72e9ebba3a4c74a", "filename": "src/librustdoc/html/static/COPYRIGHT.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FCOPYRIGHT.txt?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -23,7 +23,8 @@ included, and carry their own copyright notices and license terms:\n     Copyright (c) Nicolas Gallagher and Jonathan Neal.\n     Licensed under the MIT license (see LICENSE-MIT.txt).\n \n-* Source Code Pro (SourceCodePro-Regular.woff, SourceCodePro-Semibold.woff):\n+* Source Code Pro (SourceCodePro-Regular.ttf.woff,\n+    SourceCodePro-Semibold.ttf.woff, SourceCodePro-It.ttf.woff):\n \n     Copyright 2010, 2012 Adobe Systems Incorporated (http://www.adobe.com/),\n     with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark"}, {"sha": "ebaaf91de0667d42e962e28142de3c9070ce0750", "filename": "src/librustdoc/html/static/SourceCodePro-It.ttf.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-It.ttf.woff", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-It.ttf.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-It.ttf.woff?ref=b9cf5417892ef242c783ef963deff5436205b0f6"}, {"sha": "117c7e5142c3811eed73b9321760132160c526c7", "filename": "src/librustdoc/html/static/SourceCodePro-Regular.ttf.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Regular.ttf.woff", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Regular.ttf.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Regular.ttf.woff?ref=b9cf5417892ef242c783ef963deff5436205b0f6"}, {"sha": "5576670903aea90041f214624c8dd1176fdf6081", "filename": "src/librustdoc/html/static/SourceCodePro-Regular.woff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Regular.woff", "raw_url": "https://github.com/rust-lang/rust/raw/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Regular.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Regular.woff?ref=ea540b0892ed6b62d170c7f0a9aa362e590de8b4"}, {"sha": "270873a86a09b98551ed36397921ac4c9ecaec8c", "filename": "src/librustdoc/html/static/SourceCodePro-Semibold.ttf.woff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Semibold.ttf.woff", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Semibold.ttf.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Semibold.ttf.woff?ref=b9cf5417892ef242c783ef963deff5436205b0f6"}, {"sha": "ca972a11dc428209dd66212e382b884f168e83f7", "filename": "src/librustdoc/html/static/SourceCodePro-Semibold.woff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Semibold.woff", "raw_url": "https://github.com/rust-lang/rust/raw/ea540b0892ed6b62d170c7f0a9aa362e590de8b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Semibold.woff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-Semibold.woff?ref=ea540b0892ed6b62d170c7f0a9aa362e590de8b4"}, {"sha": "6d2f6c7eda6b4f326aa97746820505877c2dc31b", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -39,13 +39,19 @@\n \tfont-weight: 400;\n \t/* Avoid using locally installed font because bad versions are in circulation:\n \t * see https://github.com/rust-lang/rust/issues/24355 */\n-\tsrc: url(\"SourceCodePro-Regular.woff\") format('woff');\n+\tsrc: url(\"SourceCodePro-Regular.ttf.woff\") format('woff');\n+}\n+@font-face {\n+\tfont-family: 'Source Code Pro';\n+\tfont-style: italic;\n+\tfont-weight: 400;\n+\tsrc: url(\"SourceCodePro-It.ttf.woff\") format('woff');\n }\n @font-face {\n \tfont-family: 'Source Code Pro';\n \tfont-style: normal;\n \tfont-weight: 600;\n-\tsrc: url(\"SourceCodePro-Semibold.woff\") format('woff');\n+\tsrc: url(\"SourceCodePro-Semibold.ttf.woff\") format('woff');\n }\n \n * {"}, {"sha": "34055f386fbc048c91d6a539f3467d588f40252a", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -96,11 +96,15 @@ pub mod source_serif_pro {\n \n /// Files related to the Source Code Pro font.\n pub mod source_code_pro {\n-    /// The file `SourceCodePro-Regular.woff`, the Regular variant of the Source Code Pro font.\n-    pub static REGULAR: &'static [u8] = include_bytes!(\"static/SourceCodePro-Regular.woff\");\n+    /// The file `SourceCodePro-Regular.ttf.woff`, the Regular variant of the Source Code Pro font.\n+    pub static REGULAR: &'static [u8] = include_bytes!(\"static/SourceCodePro-Regular.ttf.woff\");\n \n-    /// The file `SourceCodePro-Semibold.woff`, the Semibold variant of the Source Code Pro font.\n-    pub static SEMIBOLD: &'static [u8] = include_bytes!(\"static/SourceCodePro-Semibold.woff\");\n+    /// The file `SourceCodePro-Semibold.ttf.woff`, the Semibold variant of the Source Code Pro\n+    /// font.\n+    pub static SEMIBOLD: &'static [u8] = include_bytes!(\"static/SourceCodePro-Semibold.ttf.woff\");\n+\n+    /// The file `SourceCodePro-It.ttf.woff`, the Italic variant of the Source Code Pro font.\n+    pub static ITALIC: &'static [u8] = include_bytes!(\"static/SourceCodePro-It.ttf.woff\");\n \n     /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n     pub static LICENSE: &'static [u8] = include_bytes!(\"static/SourceCodePro-LICENSE.txt\");"}, {"sha": "7d718032ef6e97ae1a6381896ceca449d6a1e6de", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -10,7 +10,7 @@\n // fallback implementation to use as well.\n //\n // Due to rust-lang/rust#18804, make sure this is not generic!\n-#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"hermit\", target_os = \"redox\",\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"redox\",\n           target_os = \"emscripten\"))]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     use crate::mem;"}, {"sha": "786100e916da02ff42273a51662f8327c8168d12", "filename": "src/test/ui/async-await/async-trait-fn.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fasync-await%2Fasync-trait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fasync-await%2Fasync-trait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-trait-fn.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -0,0 +1,7 @@\n+// edition:2018\n+trait T {\n+    async fn foo() {} //~ ERROR trait fns cannot be declared `async`\n+    async fn bar(&self) {} //~ ERROR trait fns cannot be declared `async`\n+}\n+\n+fn main() {}"}, {"sha": "9acfa2cc0691294b5de863e4bcb7d1d0aabe96b7", "filename": "src/test/ui/async-await/async-trait-fn.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fasync-await%2Fasync-trait-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fasync-await%2Fasync-trait-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-trait-fn.stderr?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -0,0 +1,21 @@\n+error[E0706]: trait fns cannot be declared `async`\n+  --> $DIR/async-trait-fn.rs:3:5\n+   |\n+LL |     async fn foo() {}\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+error[E0706]: trait fns cannot be declared `async`\n+  --> $DIR/async-trait-fn.rs:4:5\n+   |\n+LL |     async fn bar(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0706`."}, {"sha": "bb09ee9a9329633eac10d4738506d82582ca4d98", "filename": "src/test/ui/async-await/edition-deny-async-fns-2015.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fedition-deny-async-fns-2015.stderr?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -57,7 +57,11 @@ error[E0706]: trait fns cannot be declared `async`\n    |\n LL |     async fn foo() {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `async` trait functions are not currently supported\n+   = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: aborting due to 10 previous errors\n \n-For more information about this error, try `rustc --explain E0670`.\n+Some errors have detailed explanations: E0670, E0706.\n+For more information about an error, try `rustc --explain E0670`."}, {"sha": "c910cded96be44c137f7764c1c670fc32e67f412", "filename": "src/test/ui/pattern/issue-53820-slice-pattern-large-array.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fissue-53820-slice-pattern-large-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fissue-53820-slice-pattern-large-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-53820-slice-pattern-large-array.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+// This used to cause a stack overflow in the compiler.\n+\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    const LARGE_SIZE: usize = 1024 * 1024;\n+    let [..] = [0u8; LARGE_SIZE];\n+    match [0u8; LARGE_SIZE] {\n+        [..] => {}\n+    }\n+}"}, {"sha": "63ed49094fc50547a48d7d252536bb1b2897724f", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `&[_, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[..]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:4:11\n    |\n LL |     match buf {\n-   |           ^^^ pattern `&[_, _, _, _]` not covered\n+   |           ^^^ pattern `&[..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "eb3dfac950f798d3a3ddc24fbb87beddc1970bce", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -5,6 +5,20 @@ fn main() {\n     let s1: &[bool; 1] = &[false; 1];\n     let s2: &[bool; 2] = &[false; 2];\n     let s3: &[bool; 3] = &[false; 3];\n+    let s10: &[bool; 10] = &[false; 10];\n+\n+    match s2 {\n+    //~^ ERROR `&[false, _]` not covered\n+        [true, .., true] => {}\n+    }\n+    match s3 {\n+    //~^ ERROR `&[false, ..]` not covered\n+        [true, .., true] => {}\n+    }\n+    match s10 {\n+    //~^ ERROR `&[false, ..]` not covered\n+        [true, .., true] => {}\n+    }\n \n     match s1 {\n         [true, ..] => {}\n@@ -16,7 +30,7 @@ fn main() {\n         [.., false] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, _, true]` not covered\n+    //~^ ERROR `&[false, .., true]` not covered\n         [true, ..] => {}\n         [.., false] => {}\n     }\n@@ -27,10 +41,6 @@ fn main() {\n         [.., false] => {}\n     }\n \n-    match s3 {\n-    //~^ ERROR `&[false, _, _]` not covered\n-        [true, .., true] => {}\n-    }\n     match s {\n     //~^ ERROR `&[_, ..]` not covered\n         [] => {}"}, {"sha": "ebadedccfea217991f539bc1a2f7e73ac3b088ff", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9cf5417892ef242c783ef963deff5436205b0f6/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=b9cf5417892ef242c783ef963deff5436205b0f6", "patch": "@@ -1,91 +1,107 @@\n-error[E0004]: non-exhaustive patterns: `&[false, true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:13:11\n+error[E0004]: non-exhaustive patterns: `&[false, _]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:10:11\n    |\n LL |     match s2 {\n-   |           ^^ pattern `&[false, true]` not covered\n+   |           ^^ pattern `&[false, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, _, true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:18:11\n+error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:14:11\n    |\n LL |     match s3 {\n-   |           ^^ pattern `&[false, _, true]` not covered\n+   |           ^^ pattern `&[false, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:23:11\n+error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:18:11\n    |\n-LL |     match s {\n-   |           ^ pattern `&[false, .., true]` not covered\n+LL |     match s10 {\n+   |           ^^^ pattern `&[false, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:27:11\n+   |\n+LL |     match s2 {\n+   |           ^^ pattern `&[false, true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[false, _, _]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:30:11\n+error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:32:11\n    |\n LL |     match s3 {\n-   |           ^^ pattern `&[false, _, _]` not covered\n+   |           ^^ pattern `&[false, .., true]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:37:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[false, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:34:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:44:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:38:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:48:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:43:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:53:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[false, _, ..]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:48:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:58:11\n    |\n LL |     match s {\n    |           ^ pattern `&[false, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, .., false]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:54:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:64:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, .., false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, _, .., true]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:61:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:71:11\n    |\n LL |     match s {\n    |           ^ pattern `&[_, _, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[true, _, .., _]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:68:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:78:11\n    |\n LL |     match s {\n    |           ^ pattern `&[true, _, .., _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 13 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}]}