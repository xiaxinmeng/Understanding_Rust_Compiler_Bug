{"sha": "8762b797fd37e9a9cab3e5fe534a9672f30e6022", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NjJiNzk3ZmQzN2U5YTljYWIzZTVmZTUzNGE5NjcyZjMwZTYwMjI=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-10-28T10:20:05Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-10-28T10:20:05Z"}, "message": "do not use associated types placeholder for inlay hint\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "9963daa57cd59318cc9a855b5cf665b174027c5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9963daa57cd59318cc9a855b5cf665b174027c5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8762b797fd37e9a9cab3e5fe534a9672f30e6022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8762b797fd37e9a9cab3e5fe534a9672f30e6022", "html_url": "https://github.com/rust-lang/rust/commit/8762b797fd37e9a9cab3e5fe534a9672f30e6022", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8762b797fd37e9a9cab3e5fe534a9672f30e6022/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73161cc9cdcdf7b9f797d7984f2cad497a3f4553", "url": "https://api.github.com/repos/rust-lang/rust/commits/73161cc9cdcdf7b9f797d7984f2cad497a3f4553", "html_url": "https://github.com/rust-lang/rust/commit/73161cc9cdcdf7b9f797d7984f2cad497a3f4553"}], "stats": {"total": 133, "additions": 102, "deletions": 31}, "files": [{"sha": "f1232a72f762987daee6df65b217cfcee54403fb", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 60, "deletions": 28, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8762b797fd37e9a9cab3e5fe534a9672f30e6022/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8762b797fd37e9a9cab3e5fe534a9672f30e6022/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=8762b797fd37e9a9cab3e5fe534a9672f30e6022", "patch": "@@ -74,7 +74,10 @@ pub trait HirDisplay {\n             curr_size: 0,\n             max_size: None,\n             omit_verbose_types: false,\n+            #[cfg(not(test))]\n             display_target: DisplayTarget::SourceCode { module_id },\n+            #[cfg(test)]\n+            display_target: DisplayTarget::Test { module_id },\n         }) {\n             Ok(()) => {}\n             Err(HirDisplayError::FmtError) => panic!(\"Writing to String can't fail!\"),\n@@ -134,12 +137,25 @@ enum DisplayTarget {\n     /// Display types for inserting them in source files.\n     /// The generated code should compile, so paths need to be qualified.\n     SourceCode { module_id: ModuleId },\n+    /// Only for test purpose to keep real types\n+    #[cfg(test)]\n+    Test { module_id: ModuleId },\n }\n \n impl DisplayTarget {\n     fn is_source_code(&self) -> bool {\n         matches!(self, Self::SourceCode {..})\n     }\n+    fn is_test(&self) -> bool {\n+        #[cfg(test)]\n+        {\n+            matches!(self, Self::Test {..})\n+        }\n+        #[cfg(not(test))]\n+        {\n+            false\n+        }\n+    }\n }\n \n #[derive(Debug)]\n@@ -341,41 +357,57 @@ impl HirDisplay for ApplicationTy {\n                             ));\n                         }\n                     }\n+                    #[cfg(test)]\n+                    DisplayTarget::Test { module_id } => {\n+                        if let Some(path) = find_path::find_path(\n+                            f.db.upcast(),\n+                            ItemInNs::Types(def_id.into()),\n+                            module_id,\n+                        ) {\n+                            write!(f, \"{}\", path)?;\n+                        } else {\n+                            return Err(HirDisplayError::DisplaySourceCodeError(\n+                                DisplaySourceCodeError::PathNotFound,\n+                            ));\n+                        }\n+                    }\n                 }\n \n                 if self.parameters.len() > 0 {\n-                    let parameters_to_write =\n-                        if f.display_target.is_source_code() || f.omit_verbose_types() {\n-                            match self\n-                                .ctor\n-                                .as_generic_def()\n-                                .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n-                                .filter(|defaults| !defaults.is_empty())\n-                            {\n-                                None => self.parameters.0.as_ref(),\n-                                Some(default_parameters) => {\n-                                    let mut default_from = 0;\n-                                    for (i, parameter) in self.parameters.iter().enumerate() {\n-                                        match (parameter, default_parameters.get(i)) {\n-                                            (&Ty::Unknown, _) | (_, None) => {\n+                    let parameters_to_write = if f.display_target.is_source_code()\n+                        || f.display_target.is_test()\n+                        || f.omit_verbose_types()\n+                    {\n+                        match self\n+                            .ctor\n+                            .as_generic_def()\n+                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                            .filter(|defaults| !defaults.is_empty())\n+                        {\n+                            None => self.parameters.0.as_ref(),\n+                            Some(default_parameters) => {\n+                                let mut default_from = 0;\n+                                for (i, parameter) in self.parameters.iter().enumerate() {\n+                                    match (parameter, default_parameters.get(i)) {\n+                                        (&Ty::Unknown, _) | (_, None) => {\n+                                            default_from = i + 1;\n+                                        }\n+                                        (_, Some(default_parameter)) => {\n+                                            let actual_default = default_parameter\n+                                                .clone()\n+                                                .subst(&self.parameters.prefix(i));\n+                                            if parameter != &actual_default {\n                                                 default_from = i + 1;\n                                             }\n-                                            (_, Some(default_parameter)) => {\n-                                                let actual_default = default_parameter\n-                                                    .clone()\n-                                                    .subst(&self.parameters.prefix(i));\n-                                                if parameter != &actual_default {\n-                                                    default_from = i + 1;\n-                                                }\n-                                            }\n                                         }\n                                     }\n-                                    &self.parameters.0[0..default_from]\n                                 }\n+                                &self.parameters.0[0..default_from]\n                             }\n-                        } else {\n-                            self.parameters.0.as_ref()\n-                        };\n+                        }\n+                    } else {\n+                        self.parameters.0.as_ref()\n+                    };\n                     if !parameters_to_write.is_empty() {\n                         write!(f, \"<\")?;\n                         f.write_joined(parameters_to_write, \", \")?;\n@@ -391,8 +423,8 @@ impl HirDisplay for ApplicationTy {\n                 let trait_ = f.db.trait_data(trait_);\n                 let type_alias = f.db.type_alias_data(type_alias);\n \n-                // Use placeholder associated types when the target is source code (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n-                if f.display_target.is_source_code() || self.parameters.len() > 1 {\n+                // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n+                if f.display_target.is_test() || self.parameters.len() > 1 {\n                     write!(f, \"{}::{}\", trait_.name, type_alias.name)?;\n                     if self.parameters.len() > 0 {\n                         write!(f, \"<\")?;"}, {"sha": "e98d7c0647e85237ad18a951b1861e7dc56bd16d", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8762b797fd37e9a9cab3e5fe534a9672f30e6022/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8762b797fd37e9a9cab3e5fe534a9672f30e6022/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=8762b797fd37e9a9cab3e5fe534a9672f30e6022", "patch": "@@ -1,7 +1,7 @@\n use expect_test::expect;\n use test_utils::mark;\n \n-use super::{check_infer, check_infer_with_mismatches, check_types};\n+use super::{check_infer, check_infer_with_mismatches, check_types, check_types_source_code};\n \n #[test]\n fn infer_await() {\n@@ -907,7 +907,7 @@ fn test<T: Trait>(t: T) { (*t); }\n }\n \n #[test]\n-fn associated_type_placeholder() {\n+fn associated_type_inlay_hints() {\n     check_types(\n         r#\"\n pub trait ApplyL {\n@@ -929,7 +929,7 @@ fn test<T: ApplyL>() {\n }\n \n #[test]\n-fn associated_type_placeholder_2() {\n+fn associated_type_inlay_hints_2() {\n     check_types(\n         r#\"\n pub trait ApplyL {\n@@ -945,6 +945,45 @@ fn test<T: ApplyL>(t: T) {\n     );\n }\n \n+#[test]\n+fn associated_type_placeholder() {\n+    check_types_source_code(\n+        r#\"\n+pub trait ApplyL {\n+    type Out;\n+}\n+\n+pub struct RefMutL<T>;\n+\n+impl<T> ApplyL for RefMutL<T> {\n+    type Out = <T as ApplyL>::Out;\n+}\n+\n+fn test<T: ApplyL>() {\n+    let y: <RefMutL<T> as ApplyL>::Out = no_matter;\n+    y;\n+} //^ ApplyL::Out<T>\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn associated_type_placeholder_2() {\n+    check_types_source_code(\n+        r#\"\n+pub trait ApplyL {\n+    type Out;\n+}\n+fn foo<T: ApplyL>(t: T) -> <T as ApplyL>::Out;\n+\n+fn test<T: ApplyL>(t: T) {\n+    let y = foo(t);\n+    y;\n+} //^ ApplyL::Out<T>\n+\"#,\n+    );\n+}\n+\n #[test]\n fn argument_impl_trait() {\n     check_infer_with_mismatches("}]}