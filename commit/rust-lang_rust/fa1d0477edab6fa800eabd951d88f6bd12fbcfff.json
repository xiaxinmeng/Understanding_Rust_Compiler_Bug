{"sha": "fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMWQwNDc3ZWRhYjZmYTgwMGVhYmQ5NTFkODhmNmJkMTJmYmNmZmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-10T00:36:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-13T19:13:56Z"}, "message": "core: Move locks, atomic rc to unstable::sync", "tree": {"sha": "1b4a07e68091f4c23e2422aa5662c1b5f3dd9c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b4a07e68091f4c23e2422aa5662c1b5f3dd9c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "html_url": "https://github.com/rust-lang/rust/commit/fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f446244155984a6674f69ab6e9d49704ab0c20d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f446244155984a6674f69ab6e9d49704ab0c20d", "html_url": "https://github.com/rust-lang/rust/commit/4f446244155984a6674f69ab6e9d49704ab0c20d"}], "stats": {"total": 608, "additions": 313, "deletions": 295}, "files": [{"sha": "322584f8df174049d9ed787886aecd1ca9db77d5", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -19,8 +19,8 @@ use option::{Option, Some, None};\n use uint;\n use unstable;\n use vec;\n-use unstable::Exclusive;\n use util::replace;\n+use unstable::sync::{Exclusive, exclusive};\n \n use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n \n@@ -304,7 +304,7 @@ pub struct SharedChan<T> {\n impl<T: Owned> SharedChan<T> {\n     /// Converts a `chan` into a `shared_chan`.\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n-        SharedChan { ch: unstable::exclusive(c) }\n+        SharedChan { ch: exclusive(c) }\n     }\n }\n "}, {"sha": "1a8d996cc46fb9447ee4dcbcfadbc88db1351b35", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -152,7 +152,7 @@ FIXME #4726: It would probably be appropriate to make this a real global\n */\n fn with_env_lock<T>(f: &fn() -> T) -> T {\n     use unstable::global::global_data_clone_create;\n-    use unstable::{Exclusive, exclusive};\n+    use unstable::sync::{Exclusive, exclusive};\n \n     struct SharedValue(());\n     type ValueMutex = Exclusive<SharedValue>;\n@@ -860,7 +860,7 @@ pub fn change_dir(p: &Path) -> bool {\n /// is otherwise unsuccessful.\n pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n     use unstable::global::global_data_clone_create;\n-    use unstable::{Exclusive, exclusive};\n+    use unstable::sync::{Exclusive, exclusive};\n \n     fn key(_: Exclusive<()>) { }\n "}, {"sha": "545f1ac8adaa88f02cc98867f2a86c7ddb010d4f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -90,6 +90,7 @@ use task::{ExistingScheduler, SchedulerHandle};\n use task::unkillable;\n use uint;\n use util;\n+use unstable::sync::{Exclusive, exclusive};\n \n #[cfg(test)] use task::default_task_opts;\n \n@@ -128,7 +129,7 @@ struct TaskGroupData {\n     // tasks in this group.\n     descendants: TaskSet,\n }\n-type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n+type TaskGroupArc = Exclusive<Option<TaskGroupData>>;\n \n type TaskGroupInner<'self> = &'self mut Option<TaskGroupData>;\n \n@@ -158,7 +159,7 @@ struct AncestorNode {\n     ancestors:      AncestorList,\n }\n \n-struct AncestorList(Option<unstable::Exclusive<AncestorNode>>);\n+struct AncestorList(Option<Exclusive<AncestorNode>>);\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n@@ -167,7 +168,7 @@ fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n }\n \n #[inline(always)]\n-fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n+fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n                        blk: &fn(x: &mut AncestorNode) -> U) -> U {\n     x.with(blk)\n }\n@@ -479,7 +480,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                     // here.\n                     let mut members = new_taskset();\n                     taskset_insert(&mut members, spawner);\n-                    let tasks = unstable::exclusive(Some(TaskGroupData {\n+                    let tasks = exclusive(Some(TaskGroupData {\n                         members: members,\n                         descendants: new_taskset(),\n                     }));\n@@ -508,7 +509,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             (g, a, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n-            let g = unstable::exclusive(Some(TaskGroupData {\n+            let g = exclusive(Some(TaskGroupData {\n                 members:     new_taskset(),\n                 descendants: new_taskset(),\n             }));\n@@ -528,7 +529,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                     };\n                 assert!(new_generation < uint::max_value);\n                 // Build a new node in the ancestor list.\n-                AncestorList(Some(unstable::exclusive(AncestorNode {\n+                AncestorList(Some(exclusive(AncestorNode {\n                     generation: new_generation,\n                     parent_group: Some(spawner_group.tasks.clone()),\n                     ancestors: old_ancestors,"}, {"sha": "27a003e04146d807c8252742f7e6e19ab7de5cb5", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -31,14 +31,14 @@ use kinds::Owned;\n use libc::{c_void};\n use option::{Option, Some, None};\n use ops::Drop;\n-use unstable::{Exclusive, exclusive};\n+use unstable::sync::{Exclusive, exclusive};\n use unstable::at_exit::at_exit;\n use unstable::intrinsics::atomic_cxchg;\n use hashmap::HashMap;\n use sys::Closure;\n \n-#[cfg(test)] use unstable::{SharedMutableState, shared_mutable_state};\n-#[cfg(test)] use unstable::get_shared_immutable_state;\n+#[cfg(test)] use unstable::sync::{SharedMutableState, shared_mutable_state};\n+#[cfg(test)] use unstable::sync::get_shared_immutable_state;\n #[cfg(test)] use task::spawn;\n #[cfg(test)] use uint;\n "}, {"sha": "bef7a7f87d3bd7a8622ab9c925a8ba395952d4c7", "filename": "src/libcore/unstable/mod.rs", "status": "modified", "additions": 7, "deletions": 274, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fmod.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -10,13 +10,10 @@\n \n #[doc(hidden)];\n \n-use cast;\n use libc;\n use comm::{GenericChan, GenericPort};\n use prelude::*;\n use task;\n-use task::atomically;\n-use self::finally::Finally;\n \n pub mod at_exit;\n pub mod global;\n@@ -28,23 +25,7 @@ pub mod simd;\n pub mod extfmt;\n #[cfg(not(test))]\n pub mod lang;\n-\n-mod rustrt {\n-    use unstable::{raw_thread, rust_little_lock};\n-\n-    pub extern {\n-        pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n-        pub unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n-        pub unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n-        pub unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n-\n-        pub unsafe fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n-        pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n-    }\n-}\n-\n-#[allow(non_camel_case_types)] // runtime type\n-pub type raw_thread = libc::c_void;\n+pub mod sync;\n \n /**\n \n@@ -63,8 +44,8 @@ pub fn run_in_bare_thread(f: ~fn()) {\n             let closure: &fn() = || {\n                 f()\n             };\n-            let thread = rustrt::rust_raw_thread_start(&closure);\n-            rustrt::rust_raw_thread_join_delete(thread);\n+            let thread = rust_raw_thread_start(&closure);\n+            rust_raw_thread_join_delete(thread);\n             chan.send(());\n         }\n     }\n@@ -88,258 +69,10 @@ fn test_run_in_bare_thread_exchange() {\n     }\n }\n \n-fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n-    unsafe {\n-        let old = intrinsics::atomic_cxchg(address, oldval, newval);\n-        old == oldval\n-    }\n-}\n-\n-/****************************************************************************\n- * Shared state & exclusive ARC\n- ****************************************************************************/\n-\n-struct ArcData<T> {\n-    count:     libc::intptr_t,\n-    // FIXME(#3224) should be able to make this non-option to save memory\n-    data:      Option<T>,\n-}\n-\n-struct ArcDestruct<T> {\n-    data: *libc::c_void,\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for ArcDestruct<T>{\n-    fn finalize(&self) {\n-        unsafe {\n-            do task::unkillable {\n-                let mut data: ~ArcData<T> = cast::transmute(self.data);\n-                let new_count =\n-                    intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n-                assert!(new_count >= 0);\n-                if new_count == 0 {\n-                    // drop glue takes over.\n-                } else {\n-                    cast::forget(data);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n-    ArcDestruct {\n-        data: data\n-    }\n-}\n-\n-/**\n- * COMPLETELY UNSAFE. Used as a primitive for the safe versions in std::arc.\n- *\n- * Data races between tasks can result in crashes and, with sufficient\n- * cleverness, arbitrary type coercion.\n- */\n-pub type SharedMutableState<T> = ArcDestruct<T>;\n-\n-pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n-        SharedMutableState<T> {\n-    let data = ~ArcData { count: 1, data: Some(data) };\n-    let ptr = cast::transmute(data);\n-    ArcDestruct(ptr)\n-}\n-\n-#[inline(always)]\n-pub unsafe fn get_shared_mutable_state<T:Owned>(\n-    rc: *SharedMutableState<T>) -> *mut T\n-{\n-    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    assert!(ptr.count > 0);\n-    let r = cast::transmute(ptr.data.get_ref());\n-    cast::forget(ptr);\n-    return r;\n-}\n-#[inline(always)]\n-pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n-        rc: &'a SharedMutableState<T>) -> &'a T {\n-    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    assert!(ptr.count > 0);\n-    // Cast us back into the correct region\n-    let r = cast::transmute_region(ptr.data.get_ref());\n-    cast::forget(ptr);\n-    return r;\n-}\n-\n-pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n-        -> SharedMutableState<T> {\n-    let mut ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-    assert!(new_count >= 2);\n-    cast::forget(ptr);\n-    ArcDestruct((*rc).data)\n-}\n-\n-impl<T:Owned> Clone for SharedMutableState<T> {\n-    fn clone(&self) -> SharedMutableState<T> {\n-        unsafe {\n-            clone_shared_mutable_state(self)\n-        }\n-    }\n-}\n-\n-/****************************************************************************/\n-\n #[allow(non_camel_case_types)] // runtime type\n-pub type rust_little_lock = *libc::c_void;\n-\n-struct LittleLock {\n-    l: rust_little_lock,\n-}\n-\n-impl Drop for LittleLock {\n-    fn finalize(&self) {\n-        unsafe {\n-            rustrt::rust_destroy_little_lock(self.l);\n-        }\n-    }\n-}\n-\n-fn LittleLock() -> LittleLock {\n-    unsafe {\n-        LittleLock {\n-            l: rustrt::rust_create_little_lock()\n-        }\n-    }\n-}\n-\n-pub impl LittleLock {\n-    #[inline(always)]\n-    unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n-        do atomically {\n-            rustrt::rust_lock_little_lock(self.l);\n-            do (|| {\n-                f()\n-            }).finally {\n-                rustrt::rust_unlock_little_lock(self.l);\n-            }\n-        }\n-    }\n-}\n-\n-struct ExData<T> {\n-    lock: LittleLock,\n-    failed: bool,\n-    data: T,\n-}\n-\n-/**\n- * An arc over mutable data that is protected by a lock. For library use only.\n- */\n-pub struct Exclusive<T> {\n-    x: SharedMutableState<ExData<T>>\n-}\n-\n-pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n-    let data = ExData {\n-        lock: LittleLock(),\n-        failed: false,\n-        data: user_data\n-    };\n-    Exclusive {\n-        x: unsafe {\n-            shared_mutable_state(data)\n-        }\n-    }\n-}\n-\n-impl<T:Owned> Clone for Exclusive<T> {\n-    // Duplicate an exclusive ARC, as std::arc::clone.\n-    fn clone(&self) -> Exclusive<T> {\n-        Exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n-    }\n-}\n-\n-pub impl<T:Owned> Exclusive<T> {\n-    // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n-    // instead of a proper mutex. Same reason for being unsafe.\n-    //\n-    // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n-    // accessing the provided condition variable) are prohibited while inside\n-    // the exclusive. Supporting that is a work in progress.\n-    #[inline(always)]\n-    unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n-        let rec = get_shared_mutable_state(&self.x);\n-        do (*rec).lock.lock {\n-            if (*rec).failed {\n-                fail!(\n-                    ~\"Poisoned exclusive - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            let result = f(&mut (*rec).data);\n-            (*rec).failed = false;\n-            result\n-        }\n-    }\n-\n-    #[inline(always)]\n-    unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n-        do self.with |x| {\n-            f(cast::transmute_immut(x))\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use comm;\n-    use super::exclusive;\n-    use task;\n-    use uint;\n-\n-    #[test]\n-    fn exclusive_arc() {\n-        let mut futures = ~[];\n-\n-        let num_tasks = 10;\n-        let count = 10;\n-\n-        let total = exclusive(~0);\n-\n-        for uint::range(0, num_tasks) |_i| {\n-            let total = total.clone();\n-            let (port, chan) = comm::stream();\n-            futures.push(port);\n-\n-            do task::spawn || {\n-                for uint::range(0, count) |_i| {\n-                    do total.with |count| {\n-                        **count += 1;\n-                    }\n-                }\n-                chan.send(());\n-            }\n-        };\n-\n-        for futures.each |f| { f.recv() }\n-\n-        do total.with |total| {\n-            assert!(**total == num_tasks * count)\n-        };\n-    }\n+pub type raw_thread = libc::c_void;\n \n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_poison() {\n-        // Tests that if one task fails inside of an exclusive, subsequent\n-        // accesses will also fail.\n-        let x = exclusive(1);\n-        let x2 = x.clone();\n-        do task::try || {\n-            do x2.with |one| {\n-                assert!(*one == 2);\n-            }\n-        };\n-        do x.with |one| {\n-            assert!(*one == 1);\n-        }\n-    }\n+extern {\n+    fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n+    fn rust_raw_thread_join_delete(thread: *raw_thread);\n }"}, {"sha": "691f893c4fc6cf6af187225f6800bf82b8d7e2bd", "filename": "src/libcore/unstable/sync.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fsync.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -0,0 +1,283 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use libc;\n+use option::*;\n+use task;\n+use task::atomically;\n+use unstable::finally::Finally;\n+use unstable::intrinsics;\n+use ops::Drop;\n+use clone::Clone;\n+use kinds::Owned;\n+\n+/****************************************************************************\n+ * Shared state & exclusive ARC\n+ ****************************************************************************/\n+\n+struct ArcData<T> {\n+    count:     libc::intptr_t,\n+    // FIXME(#3224) should be able to make this non-option to save memory\n+    data:      Option<T>,\n+}\n+\n+struct ArcDestruct<T> {\n+    data: *libc::c_void,\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for ArcDestruct<T>{\n+    fn finalize(&self) {\n+        unsafe {\n+            do task::unkillable {\n+                let mut data: ~ArcData<T> = cast::transmute(self.data);\n+                let new_count =\n+                    intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n+                assert!(new_count >= 0);\n+                if new_count == 0 {\n+                    // drop glue takes over.\n+                } else {\n+                    cast::forget(data);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n+    ArcDestruct {\n+        data: data\n+    }\n+}\n+\n+/**\n+ * COMPLETELY UNSAFE. Used as a primitive for the safe versions in std::arc.\n+ *\n+ * Data races between tasks can result in crashes and, with sufficient\n+ * cleverness, arbitrary type coercion.\n+ */\n+pub type SharedMutableState<T> = ArcDestruct<T>;\n+\n+pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n+        SharedMutableState<T> {\n+    let data = ~ArcData { count: 1, data: Some(data) };\n+    let ptr = cast::transmute(data);\n+    ArcDestruct(ptr)\n+}\n+\n+#[inline(always)]\n+pub unsafe fn get_shared_mutable_state<T:Owned>(\n+    rc: *SharedMutableState<T>) -> *mut T\n+{\n+    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n+    assert!(ptr.count > 0);\n+    let r = cast::transmute(ptr.data.get_ref());\n+    cast::forget(ptr);\n+    return r;\n+}\n+#[inline(always)]\n+pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n+        rc: &'a SharedMutableState<T>) -> &'a T {\n+    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n+    assert!(ptr.count > 0);\n+    // Cast us back into the correct region\n+    let r = cast::transmute_region(ptr.data.get_ref());\n+    cast::forget(ptr);\n+    return r;\n+}\n+\n+pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n+        -> SharedMutableState<T> {\n+    let mut ptr: ~ArcData<T> = cast::transmute((*rc).data);\n+    let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n+    assert!(new_count >= 2);\n+    cast::forget(ptr);\n+    ArcDestruct((*rc).data)\n+}\n+\n+impl<T:Owned> Clone for SharedMutableState<T> {\n+    fn clone(&self) -> SharedMutableState<T> {\n+        unsafe {\n+            clone_shared_mutable_state(self)\n+        }\n+    }\n+}\n+\n+/****************************************************************************/\n+\n+#[allow(non_camel_case_types)] // runtime type\n+pub type rust_little_lock = *libc::c_void;\n+\n+struct LittleLock {\n+    l: rust_little_lock,\n+}\n+\n+impl Drop for LittleLock {\n+    fn finalize(&self) {\n+        unsafe {\n+            rust_destroy_little_lock(self.l);\n+        }\n+    }\n+}\n+\n+fn LittleLock() -> LittleLock {\n+    unsafe {\n+        LittleLock {\n+            l: rust_create_little_lock()\n+        }\n+    }\n+}\n+\n+pub impl LittleLock {\n+    #[inline(always)]\n+    unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n+        do atomically {\n+            rust_lock_little_lock(self.l);\n+            do (|| {\n+                f()\n+            }).finally {\n+                rust_unlock_little_lock(self.l);\n+            }\n+        }\n+    }\n+}\n+\n+struct ExData<T> {\n+    lock: LittleLock,\n+    failed: bool,\n+    data: T,\n+}\n+\n+/**\n+ * An arc over mutable data that is protected by a lock. For library use only.\n+ */\n+pub struct Exclusive<T> {\n+    x: SharedMutableState<ExData<T>>\n+}\n+\n+pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n+    let data = ExData {\n+        lock: LittleLock(),\n+        failed: false,\n+        data: user_data\n+    };\n+    Exclusive {\n+        x: unsafe {\n+            shared_mutable_state(data)\n+        }\n+    }\n+}\n+\n+impl<T:Owned> Clone for Exclusive<T> {\n+    // Duplicate an exclusive ARC, as std::arc::clone.\n+    fn clone(&self) -> Exclusive<T> {\n+        Exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n+    }\n+}\n+\n+pub impl<T:Owned> Exclusive<T> {\n+    // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n+    // instead of a proper mutex. Same reason for being unsafe.\n+    //\n+    // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n+    // accessing the provided condition variable) are prohibited while inside\n+    // the exclusive. Supporting that is a work in progress.\n+    #[inline(always)]\n+    unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n+        let rec = get_shared_mutable_state(&self.x);\n+        do (*rec).lock.lock {\n+            if (*rec).failed {\n+                fail!(\n+                    ~\"Poisoned exclusive - another task failed inside!\");\n+            }\n+            (*rec).failed = true;\n+            let result = f(&mut (*rec).data);\n+            (*rec).failed = false;\n+            result\n+        }\n+    }\n+\n+    #[inline(always)]\n+    unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n+        do self.with |x| {\n+            f(cast::transmute_immut(x))\n+        }\n+    }\n+}\n+\n+fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n+    unsafe {\n+        let old = intrinsics::atomic_cxchg(address, oldval, newval);\n+        old == oldval\n+    }\n+}\n+\n+extern {\n+    fn rust_create_little_lock() -> rust_little_lock;\n+    fn rust_destroy_little_lock(lock: rust_little_lock);\n+    fn rust_lock_little_lock(lock: rust_little_lock);\n+    fn rust_unlock_little_lock(lock: rust_little_lock);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use comm;\n+    use super::exclusive;\n+    use task;\n+    use uint;\n+\n+    #[test]\n+    fn exclusive_arc() {\n+        let mut futures = ~[];\n+\n+        let num_tasks = 10;\n+        let count = 10;\n+\n+        let total = exclusive(~0);\n+\n+        for uint::range(0, num_tasks) |_i| {\n+            let total = total.clone();\n+            let (port, chan) = comm::stream();\n+            futures.push(port);\n+\n+            do task::spawn || {\n+                for uint::range(0, count) |_i| {\n+                    do total.with |count| {\n+                        **count += 1;\n+                    }\n+                }\n+                chan.send(());\n+            }\n+        };\n+\n+        for futures.each |f| { f.recv() }\n+\n+        do total.with |total| {\n+            assert!(**total == num_tasks * count)\n+        };\n+    }\n+\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn exclusive_poison() {\n+        // Tests that if one task fails inside of an exclusive, subsequent\n+        // accesses will also fail.\n+        let x = exclusive(1);\n+        let x2 = x.clone();\n+        do task::try || {\n+            do x2.with |one| {\n+                assert!(*one == 2);\n+            }\n+        };\n+        do x.with |one| {\n+            assert!(*one == 1);\n+        }\n+    }\n+}"}, {"sha": "e56144ebc0a3bb72bb571d068bc2258e7ab0f581", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -3298,8 +3298,9 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = ~[::unstable::exclusive(()), ::unstable::exclusive(()),\n-                      ::unstable::exclusive(())];\n+        let mut v = ~[::unstable::sync::exclusive(()),\n+                      ::unstable::sync::exclusive(()),\n+                      ::unstable::sync::exclusive(())];\n         let mut _e = v.swap_remove(0);\n         assert!(v.len() == 2);\n         _e = v.swap_remove(1);"}, {"sha": "86a77f36fb6ffbf5d587fd11ffce03b9418ab30c", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -17,9 +17,9 @@ use sync;\n use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n \n use core::cast;\n-use core::unstable::{SharedMutableState, shared_mutable_state};\n-use core::unstable::{clone_shared_mutable_state};\n-use core::unstable::{get_shared_mutable_state, get_shared_immutable_state};\n+use core::unstable::sync::{SharedMutableState, shared_mutable_state};\n+use core::unstable::sync::{clone_shared_mutable_state};\n+use core::unstable::sync::{get_shared_mutable_state, get_shared_immutable_state};\n use core::ptr;\n use core::task;\n "}, {"sha": "108f24d60dc3649719fc392ee53c352f6d1fc4f8", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -15,7 +15,7 @@\n  * in std.\n  */\n \n-use core::unstable::{Exclusive, exclusive};\n+use core::unstable::sync::{Exclusive, exclusive};\n use core::ptr;\n use core::task;\n use core::util;"}, {"sha": "155b398148339bdb0c46e6e4f7400624b18def5c", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x = Some(unstable::exclusive(false));\n+    let x = Some(unstable::sync::exclusive(false));\n     match x {\n         Some(copy z) => { //~ ERROR copying a value of non-copyable type\n             do z.with |b| { assert!(!*b); }"}, {"sha": "ed7a631637433b7196a47229fd4f065f62e5444e", "filename": "src/test/run-pass/alt-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1d0477edab6fa800eabd951d88f6bd12fbcfff/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs?ref=fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = Some(unstable::exclusive(true));\n+    let x = Some(unstable::sync::exclusive(true));\n     match x {\n         Some(ref z) if z.with(|b| *b) => {\n             do z.with |b| { assert!(*b); }"}]}